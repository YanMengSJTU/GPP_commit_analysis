diff --git a/.gitignore b/.gitignore
index dbfe9eb43..6a64b1779 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,4 +39,4 @@ docs/**/*
 **/.idea/dataSources.ids
 **/.idea/datasources.xml
 **/.idea/uiDesigner.xml
-
+**/.idea/runConfigurations.xml
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index 536c52938..da727f2ac 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -291,6 +291,34 @@
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
+        <Objective-C-extensions>
+          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
+          <option name="RELEASE_STYLE" value="IVAR" />
+          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
+          <file>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+          </file>
+          <class>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+          </class>
+          <extensions>
+            <pair source="cpp" header="h" />
+            <pair source="c" header="h" />
+          </extensions>
+        </Objective-C-extensions>
         <XML>
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
diff --git a/.travis.yml b/.travis.yml
index d7e468055..7e00e8d6a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -17,13 +17,15 @@ jdk:
 
 sudo: false
 
-script: 'travis_retry ./gradlew build --parallel'
+script: 'travis_retry ./gradlew build'
 
 after_success:
 - scripts/travis-sonatype-publish.sh
 - ./gradlew jacocoTestReport coveralls
 
+before_cache:
+  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
 cache:
   directories:
-    - $HOME/.gradle/caches
-
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 5fc10cb16..d3fc25937 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,26 +1,48 @@
 # Contributing
-Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other
-aspects of the library (documentation, the wiki etc.)
+Contributions of all types are welcome.
+We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.).
+
 
 ## Asking Questions
-The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on
-freenode.org.][3]
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3].
+
 
 ## Filing issues
-To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more
-information you can provide, the more likely we are to be able help.
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed.
+Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue.
+
+To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
+The more information you can provide, the more likely we are to be able help.
 
-When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if
-you support a particular feature request, feel free to let us know by commenting on the issue.
 
 ## Contributing code
-Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find
-instructions on building the project in our README. Our code style is defined in Intellij project files in the repo
-and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel
-free to put up your pull request anyway and we can help you fix the style issues. If you'd like to
-contribute code, you will need to sign [Google's individual contributor license agreement][4].
+Pull requests are welcome for all parts of the codebase, especially the integration libraries.
+You can find instructions on building the project in [README.md][5].
+Our code style is defined in Intellij project files in the repo and also by our Checkstyle config.
+If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues.
+If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it.
+
+## Labels
+Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:
+
+ * **bug**: feature that should work, but doesn't
+ * **enhancement**: minor tweak/addition to existing behavior
+ * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide
+ * **question**: no need to modify Glide to fix the issue, usually a usage problem
+ * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo
+ * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do
+ * **duplicate**: there's another issue which already covers/tracks this
+ * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons
+ * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide
+ * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases
+ * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use)
+
+*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*
+
 
-[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [2]: https://groups.google.com/forum/#!forum/glidelibrary
 [3]: http://webchat.freenode.net/?channels=glide-library
-[4]: https://developers.google.com/open-source/cla/individual.
+[4]: https://developers.google.com/open-source/cla/individual
+[5]: https://github.com/bumptech/glide
+[6]: https://help.github.com/articles/subscribing-to-conversations/
diff --git a/ISSUE_TEMPLATE.md b/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..f76cfa70d
--- /dev/null
+++ b/ISSUE_TEMPLATE.md
@@ -0,0 +1,50 @@
+<!--
+Please fill in the below fields with some data to help us best diagnose the issue.
+The more specific you are, the better! You can help a lot by not making us ask these questions.
+Feel free to remove any irrelevant parts that you know are not related to the issue.
+Any HTML comment like this will be stripped when rendering markdown, no need to delete them.
+-->
+
+
+<!-- What version of Glide you're running, for example: 3.7.1 | 3.8.0-SNAPSHOT | 4.0.0-SNAPSHOT
+It's essentially the version number from your build.gradle: `dependencies { compile '...:x.y.z' }` -->
+**Glide Version**:
+
+<!-- Do you use any integration library, like OkHttp3 or Volley? For example:
+Fails to display with stock networking, but works with okhttp3-1.4.0 -->
+**Integration libraries**:
+
+<!-- What devices you managed to get the issue to come up on? For example:
+fails on Galaxy S4/GT-I9500 4.4.2, works fine on Nexus 6P 5.1 and Genymotion Nexus 5 5.0.1 -->
+**Device/Android Version**:
+
+<!-- Share the details of your issue in prose, detailing actual and expected behavior. It also helps if you give some info **why** you are trying to do something as opposed to **what** is not working. -->
+**Issue details / Repro steps / Use case background**: 
+
+<!-- How do you use Glide?
+Make sure you include everything as is in your app's code:
+Changing a single method parameter can yield totally different results.
+Please clarify any magic variables that appear in the code, for example: "// `this` is a Fragment"
+-->
+**Glide load line / `GlideModule` (if any) / list Adapter code (if any)**:
+```java
+Glide.with...
+```
+
+<!-- How does your app look like?
+We're most interested in the layout attributes and the hierarchy around the ImageView -->
+**Layout XML**:
+```xml
+<FrameLayout xmlns:android="...
+```
+
+<!--
+What is the error message that you got in the log?
+You can find some help on diagnosing issues here: https://github.com/bumptech/glide/wiki/Debugging-and-Error-Handling
+-->
+**Stack trace / LogCat**:
+```ruby
+paste stack trace and/or log here
+```
+
+<!-- Bonus points if you attach a relevant screenshot, screen recording or a small demo project -->
diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
new file mode 100644
index 000000000..3cd191bf1
--- /dev/null
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -0,0 +1,14 @@
+<!-- Make sure you've run `gradlew clean check jar assemble` before commit. -->
+<!-- Don't forget that you can always force push to your private branches to make changes. -->
+<!-- Please make sure there are no weird commits in the change set by rebasing to latest upstream. -->
+<!-- Please squash typo/checkstyle/review fix commits into the base commit. -->
+
+## Description
+<!-- Please describe the changes you made on a high level. -->
+<!-- Make sure you reference the GitHub issue here if this change is related to one. -->
+
+## Motivation and Context
+<!-- Why is this change required? What problem does it solve? -->
+<!-- If it's fixing a bug reference it or provide repro steps. -->
+
+<!-- If you have any issues feel free to create the PR anyway, we'll help to resolve them. -->
\ No newline at end of file
diff --git a/README.md b/README.md
index 34bbbf0b3..488f9b3c1 100644
--- a/README.md
+++ b/README.md
@@ -2,14 +2,15 @@ Glide
 =====
 
 [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
 
 ![](static/glide_logo.png)
 
-Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api
-that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based
+Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API
+that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based
 stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.
 
 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is
@@ -21,14 +22,14 @@ You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
-```groovy
+```gradle
 repositories {
-  mavenCentral()
+  mavenCentral() // jcenter() works as well because it pulls from Maven Central
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.6.0'
-    compile 'com.android.support:support-v4:19.1.0'
+  compile 'com.github.bumptech.glide:glide:3.7.0'
+  compile 'com.android.support:support-v4:19.1.0'
 }
 ```
 
@@ -38,8 +39,7 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.6.0</version>
-  <type>aar</type>
+  <version>3.7.0</version>
 </dependency>
 <dependency>
   <groupId>com.google.android</groupId>
@@ -48,14 +48,17 @@ Or Maven:
 </dependency>
 ```
 
+For info on using the bleeding edge, see the [Snapshots][17] wiki page.
+
 Proguard
 --------
 Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
-```
+
+```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
+  **[] $VALUES;
+  public *;
 }
 ```
 
@@ -65,104 +68,97 @@ Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [jav
 
 Simple use cases will look something like this:
 
-```Java
-
+```java
 // For a simple view:
-@Override
-public void onCreate(Bundle savedInstanceState) {
-    ...
-
-    ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
+@Override public void onCreate(Bundle savedInstanceState) {
+  ...
+  ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-    Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
-// For a list:
-@Override
-public View getView(int position, View recycled, ViewGroup container) {
-    final ImageView myImageView;
-    if (recycled == null) {
-        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view,
-                container, false);
-    } else {
-        myImageView = (ImageView) recycled;
-    }
-
-    String url = myUrls.get(position);
-
-    Glide.with(myFragment)
-        .load(url)
-        .centerCrop()
-        .placeholder(R.drawable.loading_spinner)
-        .crossFade()
-        .into(myImageView);
-
-    return myImageView;
+// For a simple image list:
+@Override public View getView(int position, View recycled, ViewGroup container) {
+  final ImageView myImageView;
+  if (recycled == null) {
+    myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
+  } else {
+    myImageView = (ImageView) recycled;
+  }
+
+  String url = myUrls.get(position);
+
+  Glide
+    .with(myFragment)
+    .load(url)
+    .centerCrop()
+    .placeholder(R.drawable.loading_spinner)
+    .crossFade()
+    .into(myImageView);
+
+  return myImageView;
 }
 
 ```
 
-OkHttp and Volley
------------------
-Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies. The
-integration libraries are available via Maven or the [releases page][1].
+Status
+------
+[*Version 3* on the `3.0` branch][14] is a stable public release used in multiple open source projects at Google including in the Android Camera
+app and in the 2014 Google IO app. *Version 4* is currently under development on the `master` branch.
 
-For instructions on including either the OkHttp or the Volley integration libraries, see the
-[Integration Libraries][12] wiki page.
+Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues.
 
-Android SDK Version
--------------------
-Glide requires a minimum sdk version of 10.
+Compatibility
+-------------
 
-License
--------
-BSD, part MIT and Apache 2.0. See LICENSE file for details.
-
-Status
-------
-Version 3 is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+ * **Android SDK**: Glide requires a minimum API level of 10.
+ * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
+ * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
+ * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
+ * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
+ * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
 Build
-------
+-----
 Building Glide with gradle is fairly straight forward:
 
-```
-git clone git@github.com:bumptech/glide.git
+```shell
+git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
 cd glide
 git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+**Note**: Make sure your *Android SDK* has the *Android Support Repository* installed, and that your `$ANDROID_HOME` environment
 variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
-Follow the steps in the 'Build' section to setup the project and then:
+Follow the steps in the [Build](#build) section to setup the project and then:
 
-```
+```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
 ```
+You may also find precompiled APKs on the [releases page][1].
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
+Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
 [Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in Intellij 14:
+To open the project in IntelliJ IDEA:
 
-1. Go to File.
-2. Click on 'Open...'
+1. Go to *File* menu or the *Welcome Screen*
+2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select glide-parent.iml
+4. Select `build.gradle`
 
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6], or join our irc channel: [irc.freenode.net#glide-library][13].
+anything else, email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
@@ -170,15 +166,19 @@ Before submitting pull requests, contributors must sign Google's [individual con
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push][10] script.
-* Corey Hall for Glide's [amazing logo][11].
+* The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
+* **Dave Smith** for the [gif decoder gist][9] Glide's gif decoder is based on.
+* **Chris Banes** for his [gradle-mvn-push][10] script.
+* **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
 ------
-Sam Judd - @samajudd
+Sam Judd - @sjudd on GitHub, @samajudd on Twitter
+
+License
+-------
+BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details.
 
 Disclaimer
 ---------
@@ -188,7 +188,7 @@ This is not an official Google product.
 [2]: https://github.com/bumptech/glide/wiki
 [3]: http://bumptech.github.io/glide/javadocs/latest/index.html
 [4]: https://www.jetbrains.com/idea/download/
-[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
 [7]: https://developers.google.com/open-source/cla/individual
 [8]: https://github.com/JakeWharton/DiskLruCache
@@ -197,3 +197,9 @@ This is not an official Google product.
 [11]: static/glide_logo.png
 [12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
 [13]: http://webchat.freenode.net/?channels=glide-library
+[14]: https://github.com/bumptech/glide/tree/3.0
+[15]: https://github.com/bumptech/glide/tree/master
+[16]: https://github.com/bumptech/glide/blob/master/LICENSE
+[17]: https://github.com/bumptech/glide/wiki/Snapshots
+[18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
+[19]: https://github.com/wasabeef/glide-transformations
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index ab3a44b96..72e455faf 100644
--- a/build.gradle
+++ b/build.gradle
@@ -40,11 +40,11 @@ subprojects { project ->
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = "6.6"
+        toolVersion = '6.12.1'
     }
 
     checkstyle {
-        configFile = new File(rootDir, 'checkstyle.xml')
+        configFile = rootProject.file('checkstyle.xml')
         configProperties.checkStyleConfigDir = rootProject.rootDir
     }
 
@@ -73,5 +73,6 @@ subprojects { project ->
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.2.1'
+    gradleVersion = '2.9'
+    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
 }
diff --git a/glide/build.gradle b/glide/build.gradle
index cee746200..be3f5da1c 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -44,6 +44,8 @@ def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
+project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
+
 // Generate javadocs and sources containing batched documentation and sources for all internal projects.
 ['release', 'debug'].each { variantName ->
 
@@ -102,5 +104,3 @@ artifacts {
         classifier 'sources'
     }
 }
-
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/glide/gradle.properties b/glide/gradle.properties
index f205a7f3f..ba722e44c 100644
--- a/glide/gradle.properties
+++ b/glide/gradle.properties
@@ -1,4 +1,3 @@
-POM_NAME=Glide
-POM_ARTIFACT_ID=glide
+POM_NAME=Glide Full
+POM_ARTIFACT_ID=glide-full
 POM_PACKAGING=jar
-
diff --git a/gradle.properties b/gradle.properties
index 2f1163513..b174f6113 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,10 @@
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+
 VERSION_NAME=4.0.0-SNAPSHOT
 VERSION_MAJOR=4
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=12
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -17,7 +19,7 @@ POM_DEVELOPER_EMAIL=judds@google.com
 SUPPORT_V4_VERSION=22.2.0
 SUPPORT_V7_VERSION=22.2.0
 VOLLEY_VERSION=1.0.16
-OK_HTTP_VERSION=2.3.0
+OK_HTTP_VERSION=3.0.1
 # TODO: use this in library/build.gradle.
 ANDROID_GRADLE_VERSION=1.2.3
 
@@ -25,9 +27,9 @@ ROBOLECTRIC_GRADLE_VERSION=1.1.0
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.0-rc3
-MOCKWEBSERVER_VERSION=2.3.0
-TRUTH_VERSION=0.25
+ROBOLECTRIC_VERSION=3.1-SNAPSHOT
+MOCKWEBSERVER_VERSION=3.0.0-RC1
+TRUTH_VERSION=0.26
 
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c97a8bdb9..941144813 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 25f7d42d7..63c5ca6b5 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed May 20 08:28:58 PDT 2015
+#Wed Nov 25 12:48:39 CET 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269e..9d82f7891 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/integration/build.gradle b/integration/build.gradle
index 5467b8ace..d4e8437e3 100644
--- a/integration/build.gradle
+++ b/integration/build.gradle
@@ -1,15 +1 @@
-evaluationDependsOnChildren()
-
-import com.android.build.gradle.api.BaseVariant
-subprojects {
-    android.libraryVariants.all { BaseVariant variant ->
-        def jarTask = project.tasks.create(name: "jar${variant.name.capitalize()}", type: Jar) {
-            from variant.javaCompile.destinationDir
-            exclude "**/R.class"
-            exclude "**/BuildConfig.class"
-            baseName "glide-${project.name}-integration"
-        }
-        jarTask.dependsOn variant.javaCompile
-        artifacts.add('archives', jarTask);
-    }
-}
+// keep an empty file to make sure Gradle recognizes the properties
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 603500c46..0eddb12b8 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,12 +1,8 @@
 apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
@@ -30,7 +26,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE as int
         versionName = VERSION_NAME as String
     }
 
@@ -40,4 +35,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 15bd7b334..9687ee227 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -6,10 +6,5 @@ VERSION_NAME=2.0.0-SNAPSHOT
 VERSION_MAJOR=2
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index f3ca40290..b07554288 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -6,6 +6,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -192,7 +193,7 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
   static class Factory {
 
     public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-      return new GifDecoder(bitmapProvider);
+      return new StandardGifDecoder(bitmapProvider);
     }
 
     public GifHeaderParser buildParser() {
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 1d104591b..0f9ade749 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,6 +3,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -116,6 +117,8 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -307,6 +310,8 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   @Test
   public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
diff --git a/integration/gradle.properties b/integration/gradle.properties
new file mode 100644
index 000000000..9a3b597f9
--- /dev/null
+++ b/integration/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index c70aad959..2a48a7443 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,13 +1,9 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
 
-    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}"
+    compile "com.squareup.okhttp:okhttp:2.7.1"
 }
 
 android {
@@ -18,7 +14,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +23,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 636a1a822..990db7764 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -6,10 +6,5 @@ VERSION_NAME=2.0.0-SNAPSHOT
 VERSION_MAJOR=2
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=8
 
-POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
+POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 738e9602d..873c58611 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -17,7 +17,10 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
+@Deprecated
 public class OkHttpGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 1985ca24a..3fac54a39 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -18,7 +18,10 @@
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher.
  */
+@Deprecated
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 05c0fe683..556f72a82 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -13,7 +11,10 @@
 
 /**
  * A simple model loader for fetching media over http/https using OkHttp.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.
  */
+@Deprecated
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final OkHttpClient client;
@@ -66,8 +67,7 @@ public Factory(OkHttpClient client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
new file mode 100644
index 000000000..6ef7599ff
--- /dev/null
+++ b/integration/okhttp3/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    compile project(':library')
+
+    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
new file mode 100644
index 000000000..4e8d18972
--- /dev/null
+++ b/integration/okhttp3/gradle.properties
@@ -0,0 +1,10 @@
+POM_NAME=Glide OkHttp 3.x Integration
+POM_ARTIFACT_ID=okhttp3-integration
+POM_PACKAGING=aar
+
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
+VERSION_PATCH=0
+
+POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/lint.xml b/integration/okhttp3/lint.xml
new file mode 100644
index 000000000..8b0842417
--- /dev/null
+++ b/integration/okhttp3/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+    <!-- See https://github.com/square/okio/issues/58 -->
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
+    </issue>
+</lint>
diff --git a/integration/okhttp3/src/main/AndroidManifest.xml b/integration/okhttp3/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..bc8e5a72c
--- /dev/null
+++ b/integration/okhttp3/src/main/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.okhttp">
+
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp3.OkHttpGlideModule"
+            android:value="GlideModule"/>
+    </application>
+</manifest>
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
new file mode 100644
index 000000000..17799b54f
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -0,0 +1,31 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
+ * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ */
+public class OkHttpGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
new file mode 100644
index 000000000..0aa8b2fe3
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.util.Log;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
+import okhttp3.Call;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * Fetches an {@link InputStream} using the okhttp library.
+ */
+public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+  private static final String TAG = "OkHttpFetcher";
+  private final Call.Factory client;
+  private final GlideUrl url;
+  private InputStream stream;
+  private ResponseBody responseBody;
+  private volatile Call call;
+
+  public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
+    this.client = client;
+    this.url = url;
+  }
+
+  @Override
+  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
+    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+      String key = headerEntry.getKey();
+      requestBuilder.addHeader(key, headerEntry.getValue());
+    }
+    Request request = requestBuilder.build();
+
+    call = client.newCall(request);
+    call.enqueue(new okhttp3.Callback() {
+      @Override
+      public void onFailure(Call call, IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp failed to obtain result", e);
+        }
+        callback.onLoadFailed(e);
+      }
+
+      @Override
+      public void onResponse(Call call, Response response) throws IOException {
+        if (response.isSuccessful()) {
+          long contentLength = response.body().contentLength();
+          responseBody = response.body();
+          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
+        }
+        callback.onDataReady(stream);
+      }
+    });
+  }
+
+  @Override
+  public void cleanup() {
+    try {
+      if (stream != null) {
+        stream.close();
+      }
+    } catch (IOException e) {
+      // Ignored
+    }
+    if (responseBody != null) {
+      responseBody.close();
+    }
+  }
+
+  @Override
+  public void cancel() {
+    Call local = call;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
new file mode 100644
index 000000000..73d8b1167
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+
+import java.io.InputStream;
+
+/**
+ * A simple model loader for fetching media over http/https using OkHttp.
+ */
+public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+
+  private final Call.Factory client;
+
+  public OkHttpUrlLoader(Call.Factory client) {
+    this.client = client;
+  }
+
+  @Override
+  public boolean handles(GlideUrl url) {
+    return true;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
+      Options options) {
+    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
+  }
+
+  /**
+   * The default factory for {@link OkHttpUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile Call.Factory internalClient;
+    private Call.Factory client;
+
+    private static Call.Factory getInternalClient() {
+      if (internalClient == null) {
+        synchronized (Factory.class) {
+          if (internalClient == null) {
+            internalClient = new OkHttpClient();
+          }
+        }
+      }
+      return internalClient;
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton client.
+     */
+    public Factory() {
+      this(getInternalClient());
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using given client.
+     *
+     * @param client this is typically an instance of {@code OkHttpClient}.
+     */
+    public Factory(Call.Factory client) {
+      this.client = client;
+    }
+
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new OkHttpUrlLoader(client);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing, this instance doesn't own the client.
+    }
+  }
+}
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 854dcefdd..498808a55 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,11 +1,7 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 }
@@ -18,7 +14,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +23,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
index 06c3c48dc..7bf1e8bea 100644
--- a/integration/recyclerview/gradle.properties
+++ b/integration/recyclerview/gradle.properties
@@ -6,10 +6,5 @@ VERSION_NAME=2.0.0-SNAPSHOT
 VERSION_MAJOR=2
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to display images in RecyclerView.
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 3a592592b..7c9f79531 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,20 +1,16 @@
 apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
@@ -25,7 +21,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -35,4 +30,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 0fad11225..ff93096bd 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -6,10 +6,5 @@ VERSION_NAME=2.0.0-SNAPSHOT
 VERSION_MAJOR=2
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
deleted file mode 100644
index b1cd97f05..000000000
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.bumptech.glide.integration.volley;
-
-import com.android.volley.Request;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * TODO: contribute cancel modifications to volley and remove this class.
- *
- * A Future that represents a Volley request.
- *
- * Used by providing as your response and error listeners. For example:
- * <pre>
- * RequestFuture&lt;JSONObject&gt; future = RequestFuture.newFuture();
- * MyRequest request = new MyRequest(URL, future, future);
- *
- * // If you want to be able to cancel the request:
- * future.setRequest(requestQueue.add(request));
- *
- * // Otherwise:
- * requestQueue.add(request);
- *
- * try {
- *   JSONObject response = future.get();
- *   // do something with response
- * } catch (InterruptedException e) {
- *   // handle the error
- * } catch (ExecutionException e) {
- *   // handle the error
- * }
- * </pre>
- *
- * @param <T> The type of parsed response this future expects.
- */
-public class VolleyRequestFuture<T> implements Future<T>,
-    Response.Listener<T>,
-    Response.ErrorListener {
-  private Request<?> mRequest;
-  private boolean mResultReceived = false;
-  private T mResult;
-  private VolleyError mException;
-  private boolean mIsCancelled = false;
-
-  public static <E> VolleyRequestFuture<E> newFuture() {
-    return new VolleyRequestFuture<E>();
-  }
-
-  public synchronized void setRequest(Request<?> request) {
-    mRequest = request;
-    if (mIsCancelled && mRequest != null) {
-      mRequest.cancel();
-    }
-  }
-
-  @Override
-  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isDone()) {
-      return false;
-    }
-    mIsCancelled = true;
-    if (mRequest != null) {
-      mRequest.cancel();
-    }
-    notifyAll();
-
-    return true;
-  }
-
-  @Override
-  public T get() throws InterruptedException, ExecutionException {
-    try {
-      return doGet(null);
-    } catch (TimeoutException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override
-  public T get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
-  }
-
-  private synchronized T doGet(Long timeoutMs)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (mResultReceived) {
-      return mResult;
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (timeoutMs == null) {
-      wait(0);
-    } else if (timeoutMs > 0) {
-      wait(timeoutMs);
-    }
-
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (!mResultReceived) {
-      throw new TimeoutException();
-    }
-
-    return mResult;
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return mIsCancelled;
-  }
-
-  @Override
-  public synchronized boolean isDone() {
-    return mResultReceived || mException != null || isCancelled();
-  }
-
-  @Override
-  public synchronized void onResponse(T response) {
-    mResultReceived = true;
-    mResult = response;
-    notifyAll();
-  }
-
-  @Override
-  public synchronized void onErrorResponse(VolleyError error) {
-    mException = error;
-    notifyAll();
-  }
-}
-
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 02e517cc0..89466cfca 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -93,7 +93,7 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
+   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
   public static class GlideRequest extends Request<byte[]> {
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a07ef442e..63ded0783 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -73,8 +73,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory factory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
     }
 
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index 6adda6f3f..f1d102ad8 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -18,8 +18,9 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 
 import org.junit.After;
 import org.junit.Before;
@@ -97,7 +98,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -109,7 +110,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -124,7 +125,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -162,7 +163,7 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -202,11 +203,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private DataFetcher<InputStream> getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private DataFetcher<InputStream> getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
   }
 
diff --git a/library/build.gradle b/library/build.gradle
index 0b745203f..0a0d891f8 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -25,15 +25,16 @@ dependencies {
     testCompile 'com.google.guava:guava-testlib:18.0'
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 }
 
 android.testOptions.unitTests.all {
     // configure max heap size of the test JVM
     maxHeapSize = '2048m'
+    jvmArgs '-XX:MaxPermSize=2048m'
 }
 
 android {
@@ -44,8 +45,9 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
+
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -82,6 +84,10 @@ afterEvaluate {
 
     check.dependsOn('findbugs')
 
+    pmd {
+        toolVersion '5.4.0'
+    }
+
     task pmd(type: Pmd) {
         targetJdk = TargetJdk.VERSION_1_7
 
@@ -128,3 +134,15 @@ afterEvaluate {
         }
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
+// exclude <dependency> tag for android support-v4 library from :glide's pom
+// this will ensure that this warning will not prevent the build from completing:
+// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries but is a jar
+// most users will need to override support-v4 version anyway if a newer version is available
+// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
+afterEvaluate {
+    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
+        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
+    }
+}
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index f929a391d..e9defbbe7 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -36,4 +36,10 @@
        <Bug pattern="DM_DEFAULT_ENCODING" />
     </Match>
 
+    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/gradle.properties b/library/gradle.properties
index 6f3b84292..b361d87c5 100644
--- a/library/gradle.properties
+++ b/library/gradle.properties
@@ -1,3 +1,7 @@
-POM_NAME=Glide Library
-POM_ARTIFACT_ID=library
+POM_NAME=Glide
+POM_ARTIFACT_ID=glide
 POM_PACKAGING=aar
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 000000000..0432be6d2
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,5 @@
+-keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+    **[] $VALUES;
+    public *;
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index a7ce42d77..e56ce022e 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -12,6 +12,7 @@
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
@@ -20,8 +21,8 @@
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
@@ -29,6 +30,7 @@
 import com.bumptech.glide.load.model.ByteArrayLoader;
 import com.bumptech.glide.load.model.ByteBufferEncoder;
 import com.bumptech.glide.load.model.ByteBufferFileLoader;
+import com.bumptech.glide.load.model.DataUrlLoader;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.MediaStoreFileLoader;
@@ -60,6 +62,7 @@
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
@@ -92,7 +95,8 @@
   private final BitmapPreFiller bitmapPreFiller;
   private final GlideContext glideContext;
   private final Registry registry;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool arrayPool;
+  private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
 
   /**
@@ -159,36 +163,44 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  // For testing.
-  static void tearDown() {
+  @VisibleForTesting
+  public static void tearDown() {
     glide = null;
   }
 
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      Context context, int logLevel, RequestOptions defaultRequestOptions) {
+  Glide(
+      Context context,
+      Engine engine,
+      MemoryCache memoryCache,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      ConnectivityMonitorFactory connectivityMonitorFactory,
+      int logLevel,
+      RequestOptions defaultRequestOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.connectivityMonitorFactory = connectivityMonitorFactory;
 
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
-    Resources resources = context.getResources();
+    final Resources resources = context.getResources();
 
     Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, byteArrayPool);
-    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,
-        byteArrayPool);
-    registry = new Registry(context)
+        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    ByteBufferGifDecoder byteBufferGifDecoder =
+        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
+    registry = new Registry()
         .register(ByteBuffer.class, new ByteBufferEncoder())
-        .register(InputStream.class, new StreamEncoder(byteArrayPool))
+        .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(ByteBuffer.class, Bitmap.class,
             new ByteBufferBitmapDecoder(downsampler))
         .append(InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, byteArrayPool))
+            new StreamBitmapDecoder(downsampler, arrayPool))
         .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
         .register(Bitmap.class, new BitmapEncoder())
         /* GlideBitmapDrawables */
@@ -197,13 +209,13 @@ static void tearDown() {
                 new ByteBufferBitmapDecoder(downsampler)))
         .append(InputStream.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, byteArrayPool)))
+                new StreamBitmapDecoder(downsampler, arrayPool)))
         .append(ParcelFileDescriptor.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
         .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
         /* Gifs */
         .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, byteArrayPool))
+            new StreamGifDecoder(byteBufferGifDecoder, arrayPool))
         .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .register(GifDrawable.class, new GifDrawableEncoder())
         /* Gif Frames */
@@ -217,24 +229,37 @@ static void tearDown() {
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
         .append(File.class, File.class, new UnitModelLoader.Factory<File>())
         /* Models */
-        .register(new InputStreamRewinder.Factory(byteArrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(Integer.class, ParcelFileDescriptor.class,
-            new ResourceLoader.FileDescriptorFactory())
+        .register(new InputStreamRewinder.Factory(arrayPool))
+        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                int.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                Integer.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+        .append(
+                Uri.class,
+                ParcelFileDescriptor.class,
+                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(
+            Uri.class,
+             InputStream.class,
+             new UriLoader.StreamFactory(context.getContentResolver()))
+        .append(Uri.class, ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
@@ -272,8 +297,19 @@ public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
-  public ByteArrayPool getByteArrayPool() {
-    return byteArrayPool;
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  /**
+   * @return The context associated with this instance.
+   */
+  public Context getContext() {
+    return glideContext.getBaseContext();
+  }
+
+  ConnectivityMonitorFactory getConnectivityMonitorFactory() {
+    return connectivityMonitorFactory;
   }
 
   GlideContext getGlideContext() {
@@ -316,9 +352,12 @@ public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void clearMemory() {
-    bitmapPool.clearMemory();
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
     memoryCache.clearMemory();
-    byteArrayPool.clearMemory();
+    bitmapPool.clearMemory();
+    arrayPool.clearMemory();
   }
 
   /**
@@ -327,9 +366,12 @@ public void clearMemory() {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void trimMemory(int level) {
-    bitmapPool.trimMemory(level);
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.trimMemory(level);
-    byteArrayPool.trimMemory(level);
+    bitmapPool.trimMemory(level);
+    arrayPool.trimMemory(level);
   }
 
   /**
@@ -355,6 +397,9 @@ public void clearDiskCache() {
    * to change the default. </p>
    */
   public void setMemoryCategory(MemoryCategory memoryCategory) {
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
     bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
   }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 5f29cad0e..f0db1051b 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -6,17 +6,19 @@
 
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.request.RequestOptions;
 
 /**
@@ -27,12 +29,13 @@
 
   private Engine engine;
   private BitmapPool bitmapPool;
-  private ByteArrayPool byteArrayPool;
+  private ArrayPool arrayPool;
   private MemoryCache memoryCache;
   private GlideExecutor sourceExecutor;
   private GlideExecutor diskCacheExecutor;
   private DiskCache.Factory diskCacheFactory;
   private MemorySizeCalculator memorySizeCalculator;
+  private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
   private RequestOptions defaultRequestOptions = new RequestOptions();
 
@@ -53,14 +56,14 @@ public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
   }
 
   /**
-   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
    * and retrieved as needed.
    *
-   * @param byteArrayPool The pool to use.
+   * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {
-    this.byteArrayPool = byteArrayPool;
+  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
     return this;
   }
 
@@ -205,6 +208,19 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
     return this;
   }
 
+  /**
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
+   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
+   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   *
+   * @param factory The factory to use
+   * @return This builder.
+   */
+  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+    this.connectivityMonitorFactory = factory;
+    return this;
+  }
+
   /**
    * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
    *
@@ -247,17 +263,21 @@ GlideBuilder setEngine(Engine engine) {
 
   Glide createGlide() {
     if (sourceExecutor == null) {
-      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
-      sourceExecutor = new GlideExecutor("source", cores);
+      sourceExecutor = GlideExecutor.newSourceExecutor();
     }
+
     if (diskCacheExecutor == null) {
-      diskCacheExecutor = new GlideExecutor("disk-cache", 1);
+      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
 
+    if (connectivityMonitorFactory == null) {
+      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
+    }
+
     if (bitmapPool == null) {
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
         int size = memorySizeCalculator.getBitmapPoolSize();
@@ -267,8 +287,8 @@ Glide createGlide() {
       }
     }
 
-    if (byteArrayPool == null) {
-      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());
+    if (arrayPool == null) {
+      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
     if (memoryCache == null) {
@@ -280,10 +300,18 @@ Glide createGlide() {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
+      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
+          GlideExecutor.newUnlimitedSourceExecutor());
     }
 
-    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,
+    return new Glide(
+        context,
+        engine,
+        memoryCache,
+        bitmapPool,
+        arrayPool,
+        connectivityMonitorFactory,
+        logLevel,
         defaultRequestOptions.lock());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index fba351ea0..3614d0ca1 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,9 +1,6 @@
 package com.bumptech.glide;
 
-import android.app.Activity;
-import android.app.Fragment;
 import android.support.annotation.Nullable;
-import android.support.v4.app.FragmentActivity;
 import android.widget.AbsListView;
 
 import com.bumptech.glide.request.target.BaseTarget;
@@ -93,41 +90,6 @@
     int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public ListPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public ListPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
-   */
-  public ListPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
   /**
    * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing
    * the dimensions of images to preload, the list of models to preload for a given position, and
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index dea54a6b9..e188cc5a4 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.load.Encoder;
@@ -43,9 +42,8 @@
   private final LoadPathCache loadPathCache = new LoadPathCache();
   private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
 
-  public Registry(Context context) {
-    this.modelLoaderRegistry =
-        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+  public Registry() {
+    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index b44e50b6e..d22e33b2f 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -20,7 +20,7 @@
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 
@@ -37,7 +37,7 @@
 public class RequestBuilder<TranscodeType> implements Cloneable {
   private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
       new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =
+  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
@@ -77,7 +77,14 @@
     this.requestOptions = defaultRequestOptions;
   }
 
-  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {
+  /**
+   * Applies the given options to the request, options set or unset in the given options will
+   * replace those previously set in options in this class.
+   *
+   * @see BaseRequestOptions#apply(BaseRequestOptions)
+   * @return This request builder.
+   */
+  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
     Preconditions.checkNotNull(requestOptions);
     BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
         ? this.requestOptions.clone() : this.requestOptions;
@@ -85,8 +92,17 @@
     return this;
   }
 
+  /**
+   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+   * this load completes.
+   *
+   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+   * previously.
+   *
+   * @return This request builder.
+   */
   public RequestBuilder<TranscodeType> transition(
-      TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
     return this;
   }
@@ -296,7 +312,7 @@
    * @see #load(Object)
    */
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new StringSignature(UUID.randomUUID().toString()))
+    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
         .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
   }
 
@@ -328,11 +344,9 @@
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
-  public <Y extends Target<TranscodeType>> Y into(Y target) {
+  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
     Util.assertMainThread();
-    if (target == null) {
-      throw new IllegalArgumentException("You must pass in a non null Target");
-    }
+    Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
@@ -364,11 +378,11 @@
    */
   public Target<TranscodeType> into(ImageView view) {
     Util.assertMainThread();
-    if (view == null) {
-      throw new IllegalArgumentException("You must pass in a non null View");
-    }
+    Preconditions.checkNotNull(view);
 
-    if (!requestOptions.isTransformationSet() && view.getScaleType() != null) {
+    if (!requestOptions.isTransformationSet()
+        && requestOptions.isTransformationAllowed()
+        && view.getScaleType() != null) {
       if (requestOptions.isLocked()) {
         requestOptions = requestOptions.clone();
       }
@@ -376,6 +390,9 @@
         case CENTER_CROP:
           requestOptions.optionalCenterCrop(context);
           break;
+        case CENTER_INSIDE:
+          requestOptions.optionalCenterInside(context);
+          break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
@@ -523,7 +540,7 @@ public void run() {
    */
   @Deprecated
   public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().into(width, height);
+    return getDownloadOnlyRequest().submit(width, height);
   }
 
   private RequestBuilder<File> getDownloadOnlyRequest() {
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 40078f8b7..90966b7c2 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -14,7 +14,6 @@
 import android.view.View;
 
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
@@ -53,7 +52,7 @@
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
+  private final Glide glide;
   private final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
@@ -72,17 +71,24 @@ public void run() {
   @NonNull
   private BaseRequestOptions<?> requestOptions;
 
-  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
+  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
   }
 
-  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
-    this.context = Glide.get(context).getGlideContext();
+  RequestManager(
+      Glide glide,
+      Lifecycle lifecycle,
+      RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker,
+      ConnectivityMonitorFactory factory) {
+    this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
 
+    final Context context = glide.getGlideContext().getBaseContext();
+
+
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -97,10 +103,10 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
     }
     lifecycle.addListener(connectivityMonitor);
 
-    defaultRequestOptions = this.context.getDefaultRequestOptions();
+    defaultRequestOptions = glide.getGlideContext().getDefaultRequestOptions();
     requestOptions = defaultRequestOptions;
 
-    Glide.get(context).registerRequestManager(this);
+    glide.registerRequestManager(this);
   }
 
   /**
@@ -155,14 +161,14 @@ public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void onTrimMemory(int level) {
-    context.onTrimMemory(level);
+    glide.getGlideContext().onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void onLowMemory() {
-    context.onLowMemory();
+    glide.getGlideContext().onLowMemory();
   }
 
   /**
@@ -269,7 +275,7 @@ public void onDestroy() {
     lifecycle.removeListener(this);
     lifecycle.removeListener(connectivityMonitor);
     mainHandler.removeCallbacks(addSelfToLifecycle);
-    Glide.get(context).unregisterRequestManager(this);
+    glide.unregisterRequestManager(this);
   }
 
   /**
@@ -279,7 +285,8 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
   public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).transition(new BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);
+    return as(Bitmap.class).transition(new GenericTransitionOptions<Bitmap>())
+            .apply(DECODE_TYPE_BITMAP);
   }
 
   /**
@@ -370,7 +377,7 @@ public void onDestroy() {
    * @return A new request builder for loading the given resource class.
    */
   public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(context, this, resourceClass);
+    return new RequestBuilder<>(glide.getGlideContext(), this, resourceClass);
   }
 
   /**
@@ -415,7 +422,7 @@ public void run() {
   private void untrackOrDelegate(Target<?> target) {
     boolean isOwnedByUs = untrack(target);
     if (!isOwnedByUs) {
-      Glide.get(context).removeFromManagers(target);
+      glide.removeFromManagers(target);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 99a177abc..f8fdd6d37 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -24,7 +24,7 @@ public MultiTransformation(Transformation<T>... transformations) {
   }
 
   public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
-    if (transformationList.size() < 1) {
+    if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index 04a03e5b6..e3b70a8c4 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -142,6 +142,8 @@ public String toString() {
   /**
    * An interface that updates a {@link MessageDigest} with the given value as part of a process to
    * generate a disk cache key.
+   *
+   * @param <T> The type of the option.
    */
   public interface CacheKeyUpdater<T> {
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 823ed42bf..25ae1c129 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -63,7 +63,7 @@ public DataSource getDataSource() {
 
   /**
    * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns
-   * the conrete data type returned by the AssetManager.
+   * the concrete data type returned by the AssetManager.
    *
    * @param assetManager An AssetManager to use to open the given path.
    * @param path         A string path pointing to a resource in assets to open.
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 76a9ea297..286b43a37 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 
@@ -12,14 +12,18 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
   }
 
   @Override
   protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
+    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (assetFileDescriptor == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return assetFileDescriptor.getParcelFileDescriptor();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 13d0700fd..a79a24c33 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.data;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
 
 import java.io.IOException;
@@ -16,7 +16,7 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
-  InputStreamRewinder(InputStream is, ByteArrayPool byteArrayPool) {
+  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
@@ -37,9 +37,9 @@ public void cleanup() {
    * java.io.InputStream}s.
    */
   public static final class Factory implements DataRewinder.Factory<InputStream> {
-    private final ByteArrayPool byteArrayPool;
+    private final ArrayPool byteArrayPool;
 
-    public Factory(ByteArrayPool byteArrayPool) {
+    public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index add61c095..498c70d80 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.util.Log;
 
@@ -21,25 +20,24 @@
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
   private final Uri uri;
-  private final Context context;
+  private final ContentResolver contentResolver;
   private T data;
 
   /**
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
-   * @param context Any {@link android.content.Context}.
+   * @param contentResolver Any {@link android.content.ContentResolver}.
    * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
-  public LocalUriFetcher(Context context, Uri uri) {
-    this.context = context.getApplicationContext();
+  public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
   public final void loadData(Priority priority, DataCallback<? super T> callback) {
-    ContentResolver contentResolver = context.getContentResolver();
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index aafdc25aa..f572fc576 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 
 import java.io.FileNotFoundException;
@@ -12,14 +11,18 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  public StreamLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
+    super(resolver, uri);
   }
 
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openInputStream(uri);
+    InputStream inputStream = contentResolver.openInputStream(uri);
+    if (inputStream == null) {
+      throw new FileNotFoundException("InputStream is null for :" + uri);
+    }
+    return inputStream;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 307f2385e..6fa7ffe17 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
@@ -11,7 +12,7 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.ExifOrientationStream;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -21,29 +22,31 @@
  * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
  * files obtained from the {@link MediaStore}.
  */
+@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
 public class ThumbFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "MediaStoreThumbFetcher";
-  private final Context context;
   private final Uri mediaStoreImageUri;
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
+  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
+
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
-    return build(context, uri, new ImageThumbnailQuery());
+    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
 
   public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
-    return build(context, uri, new VideoThumbnailQuery());
+    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));
   }
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
-    ByteArrayPool byteArrayPool = Glide.get(context).getByteArrayPool();
-    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
+    return new ThumbFetcher(
+        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));
   }
 
   // Visible for testing.
-  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
-    this.context = context;
+  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
@@ -64,11 +67,11 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
   }
 
   private InputStream openThumbInputStream() throws FileNotFoundException {
-    InputStream result = opener.open(context, mediaStoreImageUri);
+    InputStream result = opener.open(mediaStoreImageUri);
 
     int orientation = -1;
     if (result != null) {
-      orientation = opener.getOrientation(context, mediaStoreImageUri);
+      orientation = opener.getOrientation(mediaStoreImageUri);
     }
 
     if (orientation != -1) {
@@ -104,6 +107,13 @@ public DataSource getDataSource() {
   }
 
   static class VideoThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    VideoThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Video.Thumbnails.DATA
     };
@@ -112,19 +122,26 @@ public DataSource getDataSource() {
         + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String videoId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { videoId },
+          new String[] {videoId},
           null /*sortOrder*/);
     }
   }
 
 
   static class ImageThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    ImageThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Images.Thumbnails.DATA,
     };
@@ -133,13 +150,13 @@ public Cursor query(Context context, Uri uri) {
         + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String imageId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { imageId },
+          new String[] {imageId},
           null /*sortOrder*/);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
index befebff43..07474cd13 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 
 interface ThumbnailQuery {
-  Cursor query(Context context, Uri uri);
+  Cursor query(Uri uri);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 9b9f899f8..a96f27006 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
+import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 
 import java.io.File;
@@ -19,24 +19,30 @@
   private static final FileService DEFAULT_SERVICE = new FileService();
   private final FileService service;
   private final ThumbnailQuery query;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
+  private final ContentResolver contentResolver;
 
-  public ThumbnailStreamOpener(ThumbnailQuery query, ByteArrayPool byteArrayPool) {
-    this(DEFAULT_SERVICE, query, byteArrayPool);
+  public ThumbnailStreamOpener(
+      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {
+    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
-      ByteArrayPool byteArrayPool) {
+  public ThumbnailStreamOpener(
+      FileService service,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
     this.service = service;
     this.query = query;
     this.byteArrayPool = byteArrayPool;
+    this.contentResolver = contentResolver;
   }
 
-  public int getOrientation(Context context, Uri uri) {
+  public int getOrientation(Uri uri) {
     int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
     InputStream is = null;
     try {
-      is = context.getContentResolver().openInputStream(uri);
+      is = contentResolver.openInputStream(uri);
       orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -54,11 +60,11 @@ public int getOrientation(Context context, Uri uri) {
     return orientation;
   }
 
-  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
+  public InputStream open(Uri uri) throws FileNotFoundException {
     Uri thumbnailUri = null;
     InputStream inputStream = null;
 
-    final Cursor cursor = query.query(context, uri);
+    final Cursor cursor = query.query(uri);
     try {
       if (cursor == null || !cursor.moveToFirst()) {
         return null;
@@ -78,7 +84,7 @@ public InputStream open(Context context, Uri uri) throws FileNotFoundException {
       }
     }
     if (thumbnailUri != null) {
-      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
+      inputStream = contentResolver.openInputStream(thumbnailUri);
     }
     return inputStream;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index bd1899d7a..2b42d1f9b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -28,7 +28,7 @@
      * @param sourceKey The id of the loaded data.
      * @param data The loaded data, or null if the load failed.
      * @param fetcher The data fetcher we attempted to load from.
-     * @param dataSource The data souce we were loading from.
+     * @param dataSource The data source we were loading from.
      * @param attemptedKey The key we were loading data from (may be an alternate).
      */
     void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 285e5fe3e..3a010fed0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -137,7 +137,7 @@ boolean hasLoadPath(Class<?> dataClass) {
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
      if (result == null) {
-      if (!transformations.isEmpty() && isTransformationRequired) {
+      if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 222d32249..907826b3a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -561,7 +561,7 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     private ResourceEncoder<Z> encoder;
     private LockedResource<Z> toEncode;
 
-    // We just need the encoder and resouce type to match, which this will enforce.
+    // We just need the encoder and resource type to match, which this will enforce.
     @SuppressWarnings("unchecked")
     <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
       this.key = key;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index 0633c1c16..b110e3121 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -93,7 +93,7 @@ public boolean decodeCachedData() {
   public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
-      return true;
+      return false;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3d1e3133e..377524e0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -64,16 +64,18 @@ public void cancel() {
   }
 
   public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
-        null, null);
+      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor) {
+    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+        null, null, null, null, null, null);
   }
 
   // Visible for testing.
   Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+      GlideExecutor sourceExecutor, GlideExecutor sourceUnlimitedExecutor, Map<Key, EngineJob> jobs,
+      EngineKeyFactory keyFactory, Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      EngineJobFactory engineJobFactory, DecodeJobFactory decodeJobFactory,
+      ResourceRecycler resourceRecycler) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
@@ -93,7 +95,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
+          sourceUnlimitedExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -143,6 +146,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       boolean isTransformationRequired,
       Options options,
       boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -177,7 +181,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
+    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
+        useUnlimitedSourceExecutorPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
         glideContext,
         model,
@@ -432,26 +437,30 @@ public boolean queueIdle() {
   static class EngineJobFactory {
     private final GlideExecutor diskCacheExecutor;
     private final GlideExecutor sourceExecutor;
+    private final GlideExecutor sourceUnlimitedExecutor;
     private final EngineJobListener listener;
     private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
         new FactoryPools.Factory<EngineJob<?>>() {
           @Override
           public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);
+            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+                listener, pool);
           }
         });
 
     EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        EngineJobListener listener) {
+        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
+      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.listener = listener;
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
+    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool) {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable);
+      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index c58965ca1..36c997b22 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -39,9 +39,11 @@
   private final EngineJobListener listener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
+  private final GlideExecutor sourceUnlimitedExecutor;
 
   private Key key;
   private boolean isCacheable;
+  private boolean useUnlimitedSourceGeneratorPool;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +59,38 @@
   private volatile boolean isCancelled;
 
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+        DEFAULT_FACTORY);
   }
 
   // Visible for testing.
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
+    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
   // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable) {
+  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
     this.key = key;
     this.isCacheable = isCacheable;
+    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     return this;
   }
 
   public void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : sourceExecutor;
+    GlideExecutor executor = decodeJob.willDecodeFromCache()
+        ? diskCacheExecutor
+        : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
@@ -110,6 +119,10 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+  }
+
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
   // would cause a ConcurrentModificationException. However, we need to obey the cancellation
   // request such that if notifying a callback early in the callbacks list cancels a callback later
@@ -136,8 +149,9 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved =
-        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
+        || sourceExecutor.remove(decodeJob)
+        || sourceUnlimitedExecutor.remove(decodeJob);
     listener.onEngineJobCancelled(this, key);
 
     if (isPendingJobRemoved) {
@@ -227,7 +241,7 @@ public void reschedule(DecodeJob<?> job) {
     if (isCancelled) {
       MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
     } else {
-      sourceExecutor.execute(job);
+      getActiveSourceExecutor().execute(job);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 070017e78..5ae6da255 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.bumptech.glide.load.DataSource;
@@ -178,6 +180,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
   }
 
   private static final class IndentedAppendable implements Appendable {
+    private static final String EMPTY_SEQUENCE = "";
     private static final String INDENT = "  ";
     private final Appendable appendable;
     private boolean printedNewLine = true;
@@ -198,19 +201,31 @@ public Appendable append(char c) throws IOException {
     }
 
     @Override
-    public Appendable append(CharSequence charSequence) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence) throws IOException {
+      charSequence = safeSequence(charSequence);
       return append(charSequence, 0, charSequence.length());
     }
 
     @Override
-    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence, int start, int end)
+        throws IOException {
+      charSequence = safeSequence(charSequence);
       if (printedNewLine) {
         printedNewLine = false;
         appendable.append(INDENT);
       }
-      printedNewLine = csq.length() > 0 && csq.charAt(end - 1) == '\n';
-      appendable.append(csq, start, end);
+      printedNewLine = charSequence.length() > 0 && charSequence.charAt(end - 1) == '\n';
+      appendable.append(charSequence, start, end);
       return this;
     }
+
+    @NonNull
+    private CharSequence safeSequence(@Nullable CharSequence sequence) {
+      if (sequence == null) {
+        return EMPTY_SEQUENCE;
+      } else {
+        return sequence;
+      }
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 65c0decd0..0801cd92b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -40,6 +40,9 @@ public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
+    if (sourceIds.isEmpty()) {
+      return false;
+    }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index ea3f11714..f6221fa1d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -4,6 +4,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Util;
 
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -37,10 +38,10 @@ public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
       return height == other.height && width == other.width
-          && (transformation == null
-              ? other.transformation == null : transformation.equals(other.transformation))
+          && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
-          && sourceKey.equals(other.sourceKey) && signature.equals(other.signature)
+          && sourceKey.equals(other.sourceKey)
+          && signature.equals(other.signature)
           && options.equals(other.options);
     }
     return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
new file mode 100644
index 000000000..048a43247
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+/**
+ * Interface for handling operations on a primitive array type.
+ * @param <T> Array type (eg byte[], int[])
+ */
+public interface ArrayAdapterInterface<T> {
+
+  /**
+   * TAG for logging.
+   */
+  String getTag();
+
+  /**
+   * Return the length of the given array.
+   */
+  int getArrayLength(T array);
+
+  /**
+   * Reset the array for re-use (e.g. set all values to 0).
+   */
+  void resetArray(T array);
+
+  /**
+   * Allocate and return an array of the specified size.
+   */
+  T newArray(int length);
+
+  /**
+   * Return the size of an element in the array in bytes (e.g. for int return 4).
+   */
+  int getElementSizeInBytes();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
similarity index 64%
rename from library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
rename to library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 0213653b8..34d78b312 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 /**
- * Pool containing byte[] arrays of various sizes.
+ * Interface for an array pool that pools arrays of different types.
  */
-public interface ByteArrayPool {
+public interface ArrayPool {
   /**
    * A standard size to use to increase hit rates when the required size isn't defined.
    * Currently 64KB.
@@ -11,22 +11,21 @@
   int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
 
   /**
-   * Optionally adds the given byte array to the pool.
+   * Optionally adds the given array of the given type to the pool.
    *
    * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
    * pool.
    */
-  void put(byte[] bytes);
+  <T> void put(T array, Class<T> arrayClass);
 
   /**
-   * Returns a non-null byte array with a length >= to the given size.
+   * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
    */
-  byte[] get(int size);
-
+  <T> T get(int size, Class<T> arrayClass);
   /**
-   * Clears all byte arrays from the pool.
+   * Clears all arrays from the pool.
    */
   void clearMemory();
 
@@ -36,4 +35,5 @@
    * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
+
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
new file mode 100644
index 000000000..96a79def3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive byte arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
+  private static final String TAG = "ByteArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(byte[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(byte[] array) {
+    Arrays.fill(array, (byte) 0);
+  }
+
+  @Override
+  public byte[] newArray(int length) {
+    return new byte[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 1;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
new file mode 100644
index 000000000..e6f8129be
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive int arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
+  private static final String TAG = "IntegerArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(int[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(int[] array) {
+    Arrays.fill(array, 0);
+  }
+
+  @Override
+  public int[] newArray(int length) {
+    return new int[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 4;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
new file mode 100644
index 000000000..072aa25fd
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -0,0 +1,260 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ */
+public final class LruArrayPool implements ArrayPool {
+  // 4MB.
+  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+
+  /**
+   * The maximum number of times larger an int array may be to be than a requested size to eligible
+   * to be returned from the pool.
+   */
+  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
+  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
+
+  private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
+  private final KeyPool keyPool = new KeyPool();
+  private final Map<Class, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class, ArrayAdapterInterface> adapters = new HashMap<>();
+  private final int maxSize;
+  private int currentSize;
+
+  @VisibleForTesting
+  public LruArrayPool() {
+    maxSize = DEFAULT_SIZE;
+  }
+
+  /**
+   * Constructor for a new pool.
+   *
+   * @param maxSize The maximum size in integers of the pool.
+   */
+  public LruArrayPool(int maxSize) {
+    this.maxSize = maxSize;
+  }
+
+  @Override
+  public synchronized <T> void put(T array, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    int size = arrayAdapter.getArrayLength(array);
+    if (!isSmallEnoughForReuse(size)) {
+      return;
+    }
+    Key key = keyPool.get(size, arrayClass);
+
+    groupedMap.put(key, array);
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+    currentSize += size * arrayAdapter.getElementSizeInBytes();
+    evict();
+  }
+
+  @Override
+  public <T> T get(int size, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result;
+    synchronized (this) {
+      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+      final Key key;
+      if (mayFillRequest(size, possibleSize)) {
+        key = keyPool.get(possibleSize, arrayClass);
+      } else {
+        key = keyPool.get(size, arrayClass);
+      }
+
+      result = getArrayForKey(key);
+      if (result != null) {
+        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
+      }
+    }
+
+    if (result != null) {
+      arrayAdapter.resetArray(result);
+    } else {
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+      }
+      result = arrayAdapter.newArray(size);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  private <T> T getArrayForKey(Key key) {
+    return (T) groupedMap.get(key);
+  }
+
+  private boolean isSmallEnoughForReuse(int intSize) {
+    return intSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  }
+
+  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
+    return actualSize != null
+        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
+  }
+
+  private boolean isNoMoreThanHalfFull() {
+    return currentSize == 0 || (maxSize / currentSize >= 2);
+  }
+
+  @Override
+  public synchronized void clearMemory() {
+    evictToSize(0);
+  }
+
+  @Override
+  public synchronized void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      evictToSize(maxSize / 2);
+    }
+  }
+
+  private void evict() {
+    evictToSize(maxSize);
+  }
+
+  private void evictToSize(int size) {
+    while (currentSize > size) {
+      Object evicted = groupedMap.removeLast();
+      Preconditions.checkNotNull(evicted);
+      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);
+      currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "evicted: " + arrayAdapter.getArrayLength(evicted));
+      }
+    }
+  }
+
+  private void decrementArrayOfSize(int size, Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException(
+          "Tried to decrement empty size" + ", size: " + size + ", this: " + this);
+    }
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(arrayClass);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(arrayClass, sizes);
+    }
+    return sizes;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {
+    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
+    ArrayAdapterInterface adapter = adapters.get(arrayPoolClass);
+    if (adapter == null) {
+      if (arrayPoolClass.equals(int[].class)) {
+        adapter = new IntegerArrayAdapter();
+      } else if (arrayPoolClass.equals(byte[].class)) {
+        adapter = new ByteArrayAdapter();
+      } else {
+          throw new IllegalArgumentException("No array pool found for: "
+              + arrayPoolClass.getSimpleName());
+      }
+      adapters.put(arrayPoolClass, adapter);
+    }
+    return adapter;
+  }
+
+  // VisibleForTesting
+  int getCurrentSize() {
+    int currentSize = 0;
+    for (Class<?> type : sortedSizes.keySet()) {
+      for (Integer size : sortedSizes.get(type).keySet()) {
+        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);
+        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();
+      }
+    }
+    return currentSize;
+  }
+
+  private static final class KeyPool extends BaseKeyPool<Key> {
+
+    Key get(int size, Class arrayClass) {
+      Key result = get();
+      result.init(size, arrayClass);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  private static final class Key implements Poolable {
+    private final KeyPool pool;
+    private int size;
+    private Class arrayClass;
+
+    Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    void init(int length, Class arrayClass) {
+      this.size = length;
+      this.arrayClass = arrayClass;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size && arrayClass == other.arrayClass;
+      }
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{" + "size=" + size + "array=" + arrayClass + '}';
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (arrayClass != null ? arrayClass.hashCode() : 0);
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 754544bea..8edb0f23c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -201,9 +201,9 @@ public void trimMemory(int level) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "trimMemory, level=" + level);
     }
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       trimToSize(maxSize / 2);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
deleted file mode 100644
index dd6d5dc68..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
+++ /dev/null
@@ -1,195 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.util.Log;
-
-import java.util.Arrays;
-import java.util.TreeMap;
-
-/**
- * A fixed size LruByteArrayPool that evicts arrays using an LRU strategy to keep the pool under
- * the maximum byte size.
- */
-public final class LruByteArrayPool implements ByteArrayPool {
-  private static final String TAG = "LruBytesPool";
-  // 4MB.
-  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
-  /**
-   * The maximum number of times larger a byte array may be to be than a requested size to eligble
-   * to be returned from the pool.
-   */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
-  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
-  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
-  private final GroupedLinkedMap<Key, byte[]> groupedMap = new GroupedLinkedMap<>();
-  private final KeyPool keyPool = new KeyPool();
-  private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<>();
-  private final int maxSizeBytes;
-
-  private int currentSizeBytes;
-
-  /**
-   * Constructor for a new pool with a standard size.
-   */
-  public LruByteArrayPool() {
-    this(DEFAULT_SIZE);
-  }
-
-  /**
-   * Constructor for a new pool.
-   *
-   * @param maxSizeBytes The maximum size in bytes of the pool.
-   */
-  public LruByteArrayPool(int maxSizeBytes) {
-    this.maxSizeBytes = maxSizeBytes;
-  }
-
-  @Override
-  public synchronized void put(byte[] bytes) {
-    int size = bytes.length;
-    if (!isSmallEnoughForReuse(size)) {
-      return;
-    }
-    Key key = keyPool.get(size);
-
-    groupedMap.put(key, bytes);
-    Integer current = sortedSizes.get(size);
-    sortedSizes.put(size, current == null ? 1 : current + 1);
-    currentSizeBytes += size;
-    evict();
-  }
-
-  @Override
-  public byte[] get(int size) {
-    byte[] result;
-    synchronized (this) {
-      Integer possibleSize = sortedSizes.ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize);
-      } else {
-        key = keyPool.get(size);
-      }
-
-      result = groupedMap.get(key);
-      if (result != null) {
-        currentSizeBytes -= result.length;
-        decrementByteArrayOfSize(result.length);
-      }
-    }
-
-    if (result != null) {
-      Arrays.fill(result, (byte) 0);
-    } else {
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Allocated " + size + " bytes");
-      }
-      result = new byte[size];
-    }
-
-    return result;
-  }
-
-  private boolean isSmallEnoughForReuse(int byteSize) {
-    return byteSize <= maxSizeBytes / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
-  }
-
-  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
-    return actualSize != null
-        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
-  }
-
-  private boolean isNoMoreThanHalfFull() {
-    return currentSizeBytes == 0 || (maxSizeBytes / currentSizeBytes >= 2);
-  }
-
-  @Override
-  public synchronized void clearMemory() {
-    evictToSize(0);
-  }
-
-  @Override
-  public synchronized void trimMemory(int level) {
-     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-      clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      evictToSize(maxSizeBytes / 2);
-    }
-  }
-
-  private void evict() {
-    evictToSize(maxSizeBytes);
-  }
-
-  private void evictToSize(int size) {
-    while (currentSizeBytes > size) {
-      byte[] evicted = groupedMap.removeLast();
-      currentSizeBytes -= evicted.length;
-      decrementByteArrayOfSize(evicted.length);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "evicted: " + evicted.length);
-      }
-    }
-  }
-
-  private void decrementByteArrayOfSize(int size) {
-    Integer current = sortedSizes.get(size);
-    if (current == 1) {
-      sortedSizes.remove(current);
-    } else {
-      sortedSizes.put(size, current - 1);
-    }
-  }
-
-  private static final class KeyPool extends BaseKeyPool<Key> {
-
-    Key get(int size) {
-      Key result = get();
-      result.init(size);
-      return result;
-    }
-
-    @Override
-    protected Key create() {
-      return new Key(this);
-    }
-  }
-
-  private static final class Key implements Poolable {
-    private final KeyPool pool;
-    private int size;
-
-    Key(KeyPool pool) {
-      this.pool = pool;
-    }
-
-    void init(int length) {
-      this.size = length;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Key) {
-        Key other = (Key) o;
-        return size == other.size;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return size;
-    }
-
-    @Override
-    public String toString() {
-      return "Key{"
-          + "size=" + size
-          + '}';
-    }
-
-    @Override
-    public void offer() {
-      pool.offer(this);
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 0a011dbc3..4e9dbdd2e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -213,7 +213,7 @@ public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
         return size == other.size
-            && (config == null ? other.config == null : config.equals(other.config));
+            && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 82391d42a..455204dca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -41,11 +41,11 @@ protected int getSize(Resource<?> item) {
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       // Nearing middle of list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       // Entering list of cached background apps
       // Evict oldest half of our bitmap cache
       trimToSize(getCurrentSize() / 2);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 6156e8802..49ee8459b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -23,7 +23,7 @@
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
   private final Context context;
-  private final int byteArrayPoolSize;
+  private final int arrayPoolSize;
 
   interface ScreenDimensions {
     int getWidthPixels();
@@ -32,10 +32,12 @@
 
   MemorySizeCalculator(Context context, ActivityManager activityManager,
       ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetByteArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
+      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
     this.context = context;
-    byteArrayPoolSize = isLowMemoryDevice(activityManager)
-        ? targetByteArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR : targetByteArrayPoolSize;
+    arrayPoolSize =
+        isLowMemoryDevice(activityManager)
+            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : targetArrayPoolSize;
     final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
 
     final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
@@ -43,7 +45,7 @@
 
     int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
     int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
-    int availableSize = maxSize - byteArrayPoolSize;
+    int availableSize = maxSize - arrayPoolSize;
 
     if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
@@ -55,14 +57,23 @@
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      Log.d(TAG, "Calculation complete"
-          + ", Calculated memory cache size: " + toMb(memoryCacheSize)
-          + ", pool size: " + toMb(bitmapPoolSize)
-          + ", byte array size: " + toMb(byteArrayPoolSize)
-          + ", memory class limited? " + (targetMemoryCacheSize + targetPoolSize > maxSize)
-          + ", max size: " + toMb(maxSize)
-          + ", memoryClass: " + activityManager.getMemoryClass()
-          + ", isLowMemoryDevice: " + isLowMemoryDevice(activityManager));
+      Log.d(
+          TAG,
+          "Calculation complete"
+              + ", Calculated memory cache size: "
+              + toMb(memoryCacheSize)
+              + ", pool size: "
+              + toMb(bitmapPoolSize)
+              + ", byte array size: "
+              + toMb(arrayPoolSize)
+              + ", memory class limited? "
+              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + ", max size: "
+              + toMb(maxSize)
+              + ", memoryClass: "
+              + activityManager.getMemoryClass()
+              + ", isLowMemoryDevice: "
+              + isLowMemoryDevice(activityManager));
     }
   }
 
@@ -81,10 +92,10 @@ public int getBitmapPoolSize() {
   }
 
   /**
-   * Returns the recommended byte array pool size for the device it is run on in bytes.
+   * Returns the recommended array pool size for the device it is run on in bytes.
    */
-  public int getByteArrayPoolSize() {
-    return byteArrayPoolSize;
+  public int getArrayPoolSizeInBytes() {
+    return arrayPoolSize;
   }
 
   private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
@@ -101,9 +112,11 @@ private String toMb(int bytes) {
 
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static boolean isLowMemoryDevice(ActivityManager activityManager) {
-    final int sdkInt = Build.VERSION.SDK_INT;
-    return sdkInt < Build.VERSION_CODES.HONEYCOMB
-        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      return activityManager.isLowRamDevice();
+    } else {
+      return Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;
+    }
   }
 
   /**
@@ -117,7 +130,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
-    static final int BYTE_ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+    static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
     private final Context context;
 
@@ -129,7 +142,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
     private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
     private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int byteArrayPoolSizeBytes = BYTE_ARRAY_POOL_SIZE_BYTES;
+    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -194,14 +207,14 @@ public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
 
     /**
      * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool} to use to store temporary
+     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
      * arrays while decoding data and returns this builder.
      *
      * <p>This number will be halved on low memory devices that return {@code true} from
      * {@link ActivityManager#isLowRamDevice()}.
      */
-    public Builder setByteArrayPoolSize(int byteArrayPoolSizeBytes) {
-      this.byteArrayPoolSizeBytes = byteArrayPoolSizeBytes;
+    public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
+      this.arrayPoolSizeBytes = arrayPoolSizeBytes;
       return this;
     }
 
@@ -219,9 +232,9 @@ Builder setScreenDimensions(ScreenDimensions screenDimensions) {
 
     public MemorySizeCalculator build() {
       return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, byteArrayPoolSizeBytes, maxSizeMultiplier,
+          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
           lowMemoryMaxSizeMultiplier);
-    }
+      }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 06cc14ffa..612350704 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,8 +1,12 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.v4.util.Pools;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -13,16 +17,17 @@
  */
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-
-  private static String calculateHexStringDigest(Key key) {
-     try {
-        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-        key.updateDiskCacheKey(messageDigest);
-        return Util.sha256BytesToHex(messageDigest.digest());
-      } catch (NoSuchAlgorithmException e) {
-       throw new RuntimeException(e);
-      }
-  }
+  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
+      new FactoryPools.Factory<PoolableDigestContainer>() {
+        @Override
+        public PoolableDigestContainer create() {
+          try {
+            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+          } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      });
 
   public String getSafeKey(Key key) {
     String safeKey;
@@ -37,4 +42,30 @@ public String getSafeKey(Key key) {
     }
     return safeKey;
   }
+
+  private String calculateHexStringDigest(Key key) {
+    PoolableDigestContainer container = digestPool.acquire();
+    try {
+      key.updateDiskCacheKey(container.messageDigest);
+      // calling digest() will automatically reset()
+      return Util.sha256BytesToHex(container.messageDigest.digest());
+    } finally {
+      digestPool.release(container);
+    }
+  }
+
+  private static final class PoolableDigestContainer implements FactoryPools.Poolable {
+
+    private final MessageDigest messageDigest;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    PoolableDigestContainer(MessageDigest messageDigest) {
+      this.messageDigest = messageDigest;
+    }
+
+    @Override
+    public StateVerifier getVerifier() {
+      return stateVerifier;
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index aca64853a..270b22013 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -1,79 +1,280 @@
 package com.bumptech.glide.load.engine.executor;
 
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.support.annotation.NonNull;
 import android.util.Log;
 
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public class GlideExecutor extends ThreadPoolExecutor {
+public final class GlideExecutor extends ThreadPoolExecutor {
+
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data not found in
+   * cache.
+   */
+  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data found in
+   * Glide's cache.
+   */
+  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  /**
+   * The default thread count for executors used to load/decode/transform data found in Glide's
+   * cache.
+   */
+  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+
   private static final String TAG = "GlideExecutor";
-  private static final String DEFAULT_NAME = "fifo-pool";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+  private final boolean executeSynchronously;
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * The default thread name prefix for executors from unlimited thread pool used to
+   * load/decode/transform data not found in cache.
+   */
+  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+  /**
+   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   */
+  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
+      TimeUnit.SECONDS.toMillis(10);
+
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param poolSize The number of threads.
+   * <p>Disk cache executors do not allow network operations on their threads.
    */
-  public GlideExecutor(int poolSize) {
-    this(poolSize, new DefaultThreadFactory());
+  public static GlideExecutor newDiskCacheExecutor() {
+    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Disk cache executors do not allow network operations on their threads.
    *
-   * @param poolSize The number of threads.
-   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected
-   *                                  throwables thrown by Futures run by the pool.
+   * @param threadCount The number of threads.
+   * @param name The prefix for each thread name.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(int poolSize,
+  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param name The prefix for threads created by this pool.
-   * @param poolSize The number of threads.
+   * <p>Source executors allow network operations on their threads.
    */
-  public GlideExecutor(String name, int poolSize) {
-    this(poolSize, new DefaultThreadFactory(name));
+  public static GlideExecutor newSourceExecutor() {
+    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
+   * <p>Source executors allow network operations on their threads.
+   *
+   * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
-   * @param poolSize The number of threads.
    * @param uncaughtThrowableStrategy The {@link
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(String name, int poolSize,
+  public static GlideExecutor newSourceExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(name, uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  }
+
+  /**
+   * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
+   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
+   * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
+   * {@code corePoolSize} threads.
+   * See <a href=
+   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
+   * ThreadPoolExecutor documentation</a>.
+   *
+   * <p>Source executors allow network operations on their threads.
+   */
+  public static GlideExecutor newUnlimitedSourceExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
+        SOURCE_UNLIMITED_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT,
+        false /*preventNetworkOperations*/,
+        false /*executeSynchronously*/,
+        new SynchronousQueue<Runnable>());
   }
 
-  private GlideExecutor(int corePoolSize, ThreadFactory threadFactory) {
-    super(corePoolSize, corePoolSize, 0, TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(), threadFactory);
+  // Visible for testing.
+  GlideExecutor(int poolSize, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        poolSize /* corePoolSize */,
+        poolSize /* maximumPoolSize */,
+        0 /* keepAliveTimeInMs */,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously);
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously,
+        new PriorityBlockingQueue<Runnable>());
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
+    super(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        TimeUnit.MILLISECONDS,
+        queue,
+        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
+    this.executeSynchronously = executeSynchronously;
+  }
+
+  @Override
+  public void execute(Runnable command) {
+    if (executeSynchronously) {
+      command.run();
+    } else {
+      super.execute(command);
+    }
+  }
+
+  @NonNull
+  @Override
+  public Future<?> submit(Runnable task) {
+    return maybeWait(super.submit(task));
+  }
+
+  private <T> Future<T> maybeWait(Future<T> future) {
+    if (executeSynchronously) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+    }
+    return future;
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    return maybeWait(super.submit(task, result));
+  }
+
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    return maybeWait(super.submit(task));
   }
 
   /**
-   * A strategy for handling unexpected and uncaught throwables thrown by futures run on the pool.
+   * Determines the number of cores available on the device.
+   *
+   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
+   * be the number of available cores depending on the device's current state. See
+   * http://goo.gl/8H670N.
+   */
+  public static int calculateBestThreadCount() {
+    File[] cpus = null;
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    }
+
+    int cpuCount = cpus != null ? cpus.length : 0;
+    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
+    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+  }
+
+  /**
+   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
+   * pool.
    */
   public enum UncaughtThrowableStrategy {
     /**
-     * Silently catches and ignores the uncaught throwables.
+     * Silently catches and ignores the uncaught {@link Throwable}s.
      */
     IGNORE,
     /**
-     * Logs the uncaught throwables using {@link #TAG} and {@link Log}.
+     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
     LOG {
       @Override
@@ -84,7 +285,7 @@ protected void handle(Throwable t) {
       }
     },
     /**
-     * Rethrows the uncaught throwables to crash the app.
+     * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
     THROW {
       @Override
@@ -96,43 +297,46 @@ protected void handle(Throwable t) {
       }
     };
 
+    /** The default strategy, currently {@link #LOG}. */
+    public static final UncaughtThrowableStrategy DEFAULT = LOG;
+
     protected void handle(Throwable t) {
       // Ignore.
     }
   }
 
   /**
-   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads slightly above priority {@link
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
     private final String name;
     private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
-    private int threadNum = 0;
+    private final boolean preventNetworkOperations;
+    private int threadNum;
 
-    DefaultThreadFactory() {
-      this(DEFAULT_NAME);
-    }
-
-    DefaultThreadFactory(String name) {
-      this(name, UncaughtThrowableStrategy.LOG);
-    }
-
-    DefaultThreadFactory(UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-      this(DEFAULT_NAME, uncaughtThrowableStrategy);
-    }
-
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+        boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
+      this.preventNetworkOperations = preventNetworkOperations;
     }
 
     @Override
-    public Thread newThread(Runnable runnable) {
-      final Thread result = new Thread(runnable, name + "-thread-" + threadNum) {
+    public synchronized Thread newThread(@NonNull Runnable runnable) {
+      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          android.os.Process.setThreadPriority(
+              android.os.Process.THREAD_PRIORITY_BACKGROUND
+              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+          if (preventNetworkOperations) {
+            StrictMode.setThreadPolicy(
+                new ThreadPolicy.Builder()
+                    .detectNetwork()
+                    .penaltyDeath()
+                    .build());
+          }
           try {
             super.run();
           } catch (Throwable t) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index b91c4f73a..9bd0fd808 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -53,7 +53,7 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
   }
 
   // Visible for testing.
-  PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
+  PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
     final int maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index baa57e8c9..1e15874b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -61,10 +60,15 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       AssetFetcherFactory<InputStream> {
 
+    private final AssetManager assetManager;
+
+    public StreamFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
@@ -85,10 +89,15 @@ public void teardown() {
       ParcelFileDescriptor>,
       AssetFetcherFactory<ParcelFileDescriptor> {
 
+    private final AssetManager assetManager;
+
+    public FileDescriptorFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 52683e37d..45279ed3d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -90,8 +88,7 @@ public DataSource getDataSource() {
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -117,8 +114,7 @@ public void teardown() {
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
     @Override
-    public ModelLoader<byte[], InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index febd8bc1b..4e717d5ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Log;
 
 import com.bumptech.glide.Priority;
@@ -37,8 +36,7 @@ public boolean handles(File file) {
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
     @Override
-    public ModelLoader<File, ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
new file mode 100644
index 000000000..aeff27aeb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -0,0 +1,159 @@
+package com.bumptech.glide.load.model;
+
+import android.util.Base64;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A simple model loader for loading data from a Data URL String.
+ *
+ * Data URIs use the "data" scheme.
+ *
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ *
+ * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],somedata"</pre>
+ *
+ * @param <Data> The type of data that can be opened.
+ */
+public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+
+  private static final String DATA_SCHEME_IMAGE = "data:image";
+  private static final String BASE64_TAG = ";base64";
+  private final DataDecoder<Data> dataDecoder;
+
+  public DataUrlLoader(DataDecoder<Data> dataDecoder) {
+    this.dataDecoder = dataDecoder;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
+    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  }
+
+  @Override
+  public boolean handles(String url) {
+    return url.startsWith(DATA_SCHEME_IMAGE);
+  }
+
+  /**
+   * Allows decoding a specific type of data from a Data URL String.
+   *
+   * @param <Data> The type of data that can be opened.
+   */
+  public interface DataDecoder<Data> {
+
+    Data decode(String uri) throws IllegalArgumentException;
+
+    void close(Data data) throws IOException;
+
+    Class<Data> getDataClass();
+  }
+
+  private static final class DataUriFetcher<Data> implements DataFetcher<Data> {
+
+    private final String dataUri;
+    private final DataDecoder<Data> reader;
+    private Data data;
+
+    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+      this.dataUri = dataUri;
+      this.reader = reader;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      try {
+        data = reader.decode(dataUri);
+        callback.onDataReady(data);
+      } catch (IllegalArgumentException e) {
+        callback.onLoadFailed(e);
+      }
+    }
+
+    @Override
+    public void cleanup() {
+      try {
+        reader.close(data);
+      } catch (IOException e) {
+        // Ignored.
+      }
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<Data> getDataClass() {
+      return reader.getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for loading {@link InputStream} from Data URL string.
+   */
+  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+
+    private final DataDecoder<InputStream> opener;
+
+    public StreamFactory() {
+      opener = new DataDecoder<InputStream>() {
+        @Override
+        public InputStream decode(String url) {
+          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+            throw new IllegalArgumentException("Not a valid image data URL.");
+          }
+
+          int commaIndex = url.indexOf(',');
+          if (commaIndex == -1) {
+            throw new IllegalArgumentException("Missing comma in data URL.");
+          }
+
+          String beforeComma = url.substring(0, commaIndex);
+          if (!beforeComma.endsWith(BASE64_TAG)) {
+            throw new IllegalArgumentException("Not a base64 image data URL.");
+          }
+
+          String afterComma = url.substring(commaIndex + 1);
+          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+          return new ByteArrayInputStream(bytes);
+        }
+
+        @Override
+        public void close(InputStream inputStream) throws IOException {
+          inputStream.close();
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      };
+    }
+
+    @Override
+    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new DataUrlLoader<>(opener);
+    }
+
+    @Override
+    public final void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index e917a8f8b..370f10c0a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
 
@@ -115,8 +114,7 @@ public Factory(FileOpener<Data> opener) {
     }
 
     @Override
-    public final ModelLoader<File, Data> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 78f292430..66a76cd11 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 /**
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
@@ -8,6 +10,15 @@
  */
 public interface LazyHeaderFactory {
 
+    /**
+     * Returns an http header, or {@code null} if no header could be built.
+     *
+     * <p>Returning {@code null} or an empty String from this method will result in this particular
+     * key/value being excluded from the headers provided in the request. If there are multiple
+     * factories or values for a particular key, any non-null values will still be included for that
+     * key.
+     */
+    @Nullable
     String buildHeader();
 
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 915185fbd..27164f763 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -47,12 +47,18 @@
       int size = factories.size();
       for (int i = 0; i < size; i++) {
         LazyHeaderFactory factory = factories.get(i);
-        sb.append(factory.buildHeader());
-        if (i != factories.size() - 1) {
-          sb.append(',');
+        String header = factory.buildHeader();
+        if (!TextUtils.isEmpty(header)) {
+          sb.append(header);
+          if (i != factories.size() - 1) {
+            sb.append(',');
+          }
         }
       }
-      combinedHeaders.put(entry.getKey(), sb.toString());
+      String values = sb.toString();
+      if (!TextUtils.isEmpty(values)) {
+        combinedHeaders.put(entry.getKey(), sb.toString());
+      }
     }
 
     return combinedHeaders;
@@ -117,9 +123,9 @@ public int hashCode() {
     }
 
     private boolean copyOnModify = true;
-    private boolean isEncodingDefault = true;
     private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
-    private boolean isUserAgentDefault = headers.containsKey(DEFAULT_USER_AGENT);
+    private boolean isEncodingDefault = true;
+    private boolean isUserAgentDefault = true;
 
     /**
      * Adds a value for the given header and returns this builder.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index ac81aa270..4e0b98081 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -99,8 +99,14 @@ public DataSource getDataSource() {
    */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index c3813f9ad..19e126019 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -18,13 +18,11 @@
   /**
    * Build a concrete ModelLoader for this model type.
    *
-   * @param context      A context that cannot be retained by the factory but can be retained by the
-   *                     {@link ModelLoader}
    * @param multiFactory A map of classes to factories that can be used to construct additional
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
+  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index bf3ffbab4..dacf01427 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import java.util.ArrayList;
@@ -18,8 +17,8 @@
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
+    this(new MultiModelLoaderFactory(exceptionListPool));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index e6c82d9c2..8596436ea 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
@@ -21,20 +21,18 @@
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
-  private final Context context;
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
   private final Pool<List<Exception>> exceptionListPool;
 
-  public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(context, exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
+    this(exceptionListPool, DEFAULT_FACTORY);
   }
 
   // Visible for testing.
-  MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool,
+  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
       Factory factory) {
     this.exceptionListPool = exceptionListPool;
-    this.context = context.getApplicationContext();
     this.factory = factory;
   }
 
@@ -157,8 +155,7 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
 
   @SuppressWarnings("unchecked")
   private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
-    return (ModelLoader<Model, Data>) Preconditions
-        .checkNotNull(entry.factory.build(context, this));
+    return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
   @SuppressWarnings("unchecked")
@@ -196,9 +193,10 @@ public boolean handles(Class<?> modelClass) {
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
 
+    @Nullable
     @Override
     public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
-      throw new UnsupportedOperationException("EmptyModelLoader does not handle data");
+      return null;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 8c420ae9f..bda92f708 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -23,10 +22,6 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
-  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
-    this(context.getResources(), uriLoader);
-  }
-
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
@@ -65,10 +60,15 @@ public boolean handles(Integer model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
+    private final Resources resources;
+
+    public StreamFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
+    public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
@@ -83,11 +83,16 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
+    private final Resources resources;
+
+    public FileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context,
-          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 45b168512..496dd9e84 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -4,7 +4,7 @@
 
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -18,15 +18,15 @@
  */
 public class StreamEncoder implements Encoder<InputStream> {
   private static final String TAG = "StreamEncoder";
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamEncoder(ByteArrayPool byteArrayPool) {
+  public StreamEncoder(ArrayPool byteArrayPool) {
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
   public boolean encode(InputStream data, File file, Options options) {
-    byte[] buffer = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
     try {
@@ -49,7 +49,7 @@ public boolean encode(InputStream data, File file, Options options) {
           // Do nothing.
         }
       }
-      byteArrayPool.put(buffer);
+      byteArrayPool.put(buffer, byte[].class);
     }
     return success;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 5f878b1c5..9863fdc7b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
@@ -63,8 +62,7 @@ private static Uri toFileUri(String path) {
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @Override
-    public ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -81,8 +79,7 @@ public void teardown() {
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index b3807a2db..198f01bfa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -64,13 +62,13 @@ public DataSource getDataSource() {
 
   /**
    * Factory for producing {@link com.bumptech.glide.load.model.UnitModelLoader}s.
+   *
+   * @param <Model> The type of model that will also be returned as decodable data.
    */
-  public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType,
-      ResourceType> {
+  public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
 
     @Override
-    public ModelLoader<ResourceType, ResourceType> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
       return new UnitModelLoader<>();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index d6a66a163..8eaff09ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 
@@ -36,18 +35,16 @@
       )
   );
 
-  private final Context context;
   private final LocalUriFetcherFactory<Data> factory;
 
-  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
-    this.context = context;
+  public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
   public LoadData<Data> buildLoadData(Uri model, int width, int height,
       Options options) {
-    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+    return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
@@ -61,7 +58,7 @@ public boolean handles(Uri model) {
    * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
    */
   public interface LocalUriFetcherFactory<Data> {
-    DataFetcher<Data> build(Context context, Uri uri);
+    DataFetcher<Data> build(Uri uri);
   }
 
   /**
@@ -70,15 +67,20 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       LocalUriFetcherFactory<InputStream> {
 
+    private final ContentResolver contentResolver;
+
+    public StreamFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<InputStream> build(Context context, Uri uri) {
-      return new StreamLocalUriFetcher(context, uri);
+    public DataFetcher<InputStream> build(Uri uri) {
+      return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
@@ -94,15 +96,20 @@ public void teardown() {
       ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
+    private final ContentResolver contentResolver;
+
+    public FileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
-      return new FileDescriptorLocalUriFetcher(context, uri);
+    public DataFetcher<ParcelFileDescriptor> build(Uri uri) {
+      return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f71d7e789..c957b8388 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -50,8 +49,7 @@ public boolean handles(Uri uri) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index a42d2ca14..f336b4430 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.support.annotation.Nullable;
 
 import com.bumptech.glide.load.Options;
@@ -56,8 +55,7 @@ public boolean handles(GlideUrl model) {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index e3f11a6f4..a0638f0b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -44,8 +43,7 @@ public boolean handles(Uri model) {
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index 635d8c131..672aae25f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -43,9 +43,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 1ab758391..cfda8463b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -35,6 +35,7 @@
   @Nullable
   public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
+      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -57,9 +58,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 5cbda7216..76bb9a227 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -40,8 +38,7 @@ public boolean handles(URL model) {
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
     @Override
-    public ModelLoader<URL, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
deleted file mode 100644
index 6a89df27a..000000000
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import android.graphics.Bitmap;
-
-import com.bumptech.glide.TransitionOptions;
-
-/**
- * Provides {@link Bitmap} specific animation options.
- *
- * TODO: we should probably just use GenericAnimationOptions instead.
- */
-public final class BitmapTransitionOptions extends TransitionOptions<BitmapTransitionOptions,
-    Bitmap> {
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
new file mode 100644
index 000000000..daeb15fad
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import java.security.MessageDigest;
+
+/**
+ * Returns the image with its original size if its dimensions match or are smaller
+ * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
+ * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
+ * the image will be equal to the given dimension and the other will be less than the given
+ * dimension (maintaining the image's aspect ratio).
+ */
+public class CenterInside extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public CenterInside(Context context) {
+    super(context);
+  }
+
+  public CenterInside(BitmapPool bitmapPool) {
+    super(bitmapPool);
+  }
+
+  @Override
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CenterInside;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
+}
+
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 0ab010b53..c5c293483 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -11,12 +11,13 @@
    * requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
+   * {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
    * two downsampling can be used.
    */
-  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
   /**
    * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
@@ -24,7 +25,8 @@
    * the requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
+   * or {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
    * two downsampling can be used.
@@ -43,6 +45,15 @@
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
+  /**
+   * Returns the original image if it is smaller than the target, otherwise it will be downscaled
+   * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
+   * to the requested size and the other is less or equal than the requested size.
+   *
+   * <p>This method will not upscale.</p>
+   */
+  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+
   /**
    * Performs no downsampling or scaling.
    */
@@ -86,7 +97,7 @@ public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requ
   public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
       int requestedWidth, int requestedHeight);
 
-  private static class CenterInside extends DownsampleStrategy {
+  private static class FitCenter extends DownsampleStrategy {
 
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
@@ -168,6 +179,23 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
     }
   }
 
+  private static class CenterInside extends DownsampleStrategy {
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+
+      return Math.min(1.f,
+          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
   /**
    * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
    * or higher quality.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 065e9796a..1341dc975 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -11,8 +11,8 @@
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Preconditions;
@@ -21,8 +21,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.Queue;
 import java.util.Set;
 
@@ -47,6 +49,17 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
+  private static final String ICO_MIME_TYPE = "image/x-ico";
+  private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  WBMP_MIME_TYPE,
+                  ICO_MIME_TYPE
+              )
+          )
+      );
   private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
     public void onObtainBounds() {
@@ -73,10 +86,10 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
   public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-      ByteArrayPool byteArrayPool) {
+       ArrayPool byteArrayPool) {
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
@@ -134,7 +147,7 @@ public boolean handles(ByteBuffer byteBuffer) {
     Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
         + " mark()");
 
-    byte[] bytesForOptions = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
     bitmapFactoryOptions.inTempStorage = bytesForOptions;
 
@@ -147,7 +160,7 @@ public boolean handles(ByteBuffer byteBuffer) {
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
-      byteArrayPool.put(bytesForOptions);
+      byteArrayPool.put(bytesForOptions, byte[].class);
     }
   }
 
@@ -240,9 +253,17 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
         ? Math.max(widthScaleFactor, heightScaleFactor)
         : Math.min(widthScaleFactor, heightScaleFactor);
 
-    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
-    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
-      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+    int powerOfTwoSampleSize;
+    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
+    if (Build.VERSION.SDK_INT <= 23
+        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
+      powerOfTwoSampleSize = 1;
+    } else {
+      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+      if (rounding == SampleSizeRounding.MEMORY
+          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+      }
     }
 
     float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
@@ -400,17 +421,19 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
     int sourceHeight = options.outHeight;
     String outMimeType = options.outMimeType;
     final Bitmap result;
+    TransformationUtils.getBitmapDrawableLock().lock();
     try {
       result = BitmapFactory.decodeStream(is, null, options);
     } catch (IllegalArgumentException e) {
       throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+    } finally {
+      TransformationUtils.getBitmapDrawableLock().unlock();
     }
 
     if (options.inJustDecodeBounds) {
       is.reset();
 
     }
-
     return result;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
index 2411ddab0..6f261e000 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
@@ -8,7 +8,7 @@
 
 import android.util.Log;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
 
 import java.io.IOException;
@@ -40,6 +40,10 @@
     PNG_A(true),
     /** PNG type without alpha. */
     PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
     /**
      * Unrecognized type.
      */
@@ -71,17 +75,32 @@ public boolean hasAlpha() {
   private static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
-
-  private final ByteArrayPool byteArrayPool;
+  // WebP-related
+  // "RIFF"
+  private static final int RIFF_HEADER = 0x52494646;
+  // "WEBP"
+  private static final int WEBP_HEADER = 0x57454250;
+  // "VP8" null.
+  private static final int VP8_HEADER = 0x56503800;
+  private static final int VP8_HEADER_MASK = 0xFFFFFF00;
+  private static final int VP8_HEADER_TYPE_MASK = 0x000000FF;
+  // 'X'
+  private static final int VP8_HEADER_TYPE_EXTENDED = 0x00000058;
+  // 'L'
+  private static final int VP8_HEADER_TYPE_LOSSLESS = 0x0000004C;
+  private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
+  private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
+
+  private final ArrayPool byteArrayPool;
   private final Reader reader;
 
-  public ImageHeaderParser(InputStream is, ByteArrayPool byteArrayPool) {
+  public ImageHeaderParser(InputStream is, ArrayPool byteArrayPool) {
     Preconditions.checkNotNull(is);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
     reader = new StreamReader(is);
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ByteArrayPool byteArrayPool) {
+  public ImageHeaderParser(ByteBuffer byteBuffer, ArrayPool byteArrayPool) {
     Preconditions.checkNotNull(byteBuffer);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
     reader = new ByteBufferReader(byteBuffer);
@@ -117,7 +136,33 @@ public ImageType getType() throws IOException {
       return GIF;
     }
 
-    return UNKNOWN;
+    // WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container
+    // for details.
+    if (firstFourBytes != RIFF_HEADER) {
+      return UNKNOWN;
+    }
+    // Bytes 4 - 7 contain length information. Skip these.
+    reader.skip(4);
+    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if (thirdFourBytes != WEBP_HEADER) {
+      return UNKNOWN;
+    }
+    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
+      return UNKNOWN;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) {
+      // Skip some more length bytes and check for transparency/alpha flag.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_EXTENDED_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) {
+      // See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt
+      // for more info.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_LOSSLESS_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    return ImageType.WEBP;
   }
 
   /**
@@ -145,11 +190,11 @@ public int getOrientation() throws IOException {
         return UNKNOWN_ORIENTATION;
       }
 
-      byte[] exifData = byteArrayPool.get(exifSegmentLength);
+      byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
         return parseExifSegment(exifData, exifSegmentLength);
       } finally {
-        byteArrayPool.put(exifData);
+        byteArrayPool.put(exifData, byte[].class);
       }
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 33a25b6f7..187d3633f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,7 +17,7 @@
  *  limitations under the License.
  */
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -62,18 +62,18 @@
    * The current position within the byte array {@code buf}.
    */
   private int pos;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool) {
-    this(in, byteArrayPool, ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  public RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool) {
+    this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
   // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool,
+  RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool,
       int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
-    buf = byteArrayPool.get(bufferSize);
+    buf = byteArrayPool.get(bufferSize, byte[].class);
   }
 
   /**
@@ -111,7 +111,7 @@ public synchronized void fixMarkLimit() {
 
   public synchronized void release() {
     if (buf != null) {
-      byteArrayPool.put(buf);
+      byteArrayPool.put(buf, byte[].class);
       buf = null;
     }
   }
@@ -125,7 +125,7 @@ public synchronized void release() {
   @Override
   public void close() throws IOException {
     if (buf != null) {
-      byteArrayPool.put(buf);
+      byteArrayPool.put(buf, byte[].class);
       buf = null;
     }
     InputStream localIn = in;
@@ -161,13 +161,13 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       if (newLength > marklimit) {
         newLength = marklimit;
       }
-      byte[] newbuf = byteArrayPool.get(newLength);
+      byte[] newbuf = byteArrayPool.get(newLength, byte[].class);
       System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
       byte[] oldbuf = localBuf;
       // Reassign buf, which will invalidate any local references
       // FIXME: what if buf was null?
       localBuf = buf = newbuf;
-      byteArrayPool.put(oldbuf);
+      byteArrayPool.put(oldbuf, byte[].class);
     } else if (markpos > 0) {
       System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
new file mode 100644
index 000000000..33af8b853
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rounds the corners of a bitmap.
+ */
+public final class RoundedCorners extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int roundingRadius;
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
+    super(bitmapPool);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(Context context, int roundingRadius) {
+    super(context);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  @Override
+  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
+        roundingRadius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode() + roundingRadius;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
+    messageDigest.update(radiusData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index bedf360ba..7d580e161 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -5,8 +5,8 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.util.ExceptionCatchingInputStream;
 import com.bumptech.glide.util.MarkEnforcingInputStream;
 
@@ -19,9 +19,9 @@
 public class StreamBitmapDecoder implements ResourceDecoder<InputStream, Bitmap> {
 
   private final Downsampler downsampler;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamBitmapDecoder(Downsampler downsampler, ByteArrayPool byteArrayPool) {
+  public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
     this.downsampler = downsampler;
     this.byteArrayPool = byteArrayPool;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 0f201106d..85da2b8c8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -2,19 +2,27 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * A class with methods to efficiently resize Bitmaps.
@@ -26,6 +34,18 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+  /**
+   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
+   * drawing is not thread safe.
+   * This lock only locks for these specific devices. For other types of devices the lock is always
+   * available and therefore does not impact performance
+   */
+  private static final Lock BITMAP_DRAWABLE_LOCK = "XT1097".equals(Build.MODEL)
+      // TODO: Switch to Build.VERSION_CODES.LOLLIPOP_MR1 when apps have updated target API levels.
+      && Build.VERSION.SDK_INT == 22
+      ? new ReentrantLock()
+      : new NoLock();
+
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
     CIRCLE_CROP_BITMAP_PAINT.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
@@ -35,43 +55,47 @@ private TransformationUtils() {
     // Utility class.
   }
 
+
+  public static Lock getBitmapDrawableLock() {
+    return BITMAP_DRAWABLE_LOCK;
+  }
+
   /**
    * A potentially expensive operation to crop the given Bitmap so that it fills the given
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
    * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param width    The width in pixels of the final Bitmap.
    * @param height   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int width,
+  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
-      return toCrop;
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
+      return inBitmap;
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
     float dx = 0, dy = 0;
     Matrix m = new Matrix();
-    if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
-      scale = (float) height / (float) toCrop.getHeight();
-      dx = (width - toCrop.getWidth() * scale) * 0.5f;
+    if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
+      scale = (float) height / (float) inBitmap.getHeight();
+      dx = (width - inBitmap.getWidth() * scale) * 0.5f;
     } else {
-      scale = (float) width / (float) toCrop.getWidth();
-      dy = (height - toCrop.getHeight() * scale) * 0.5f;
+      scale = (float) width / (float) inBitmap.getWidth();
+      dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(toCrop));
+    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toCrop, result);
+    TransformationUtils.setAlpha(inBitmap, result);
 
-    Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toCrop, m, DEFAULT_PAINT);
+    applyMatrix(inBitmap, result, m);
     return result;
   }
 
@@ -80,69 +104,94 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop
    * dimensions maintain the original proportions.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toFit  The Bitmap to shrink.
+   * @param inBitmap  The Bitmap to shrink.
    * @param width  The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
    * height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap toFit, int width,
+  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toFit.getWidth() == width && toFit.getHeight() == height) {
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
-    final float widthPercentage = width / (float) toFit.getWidth();
-    final float heightPercentage = height / (float) toFit.getHeight();
+    final float widthPercentage = width / (float) inBitmap.getWidth();
+    final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
     // take the floor of the target width/height, not round. If the matrix
     // passed into drawBitmap rounds differently, we want to slightly
     // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * toFit.getWidth());
-    final int targetHeight = (int) (minPercentage * toFit.getHeight());
+    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
 
-    if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
+    if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "adjusted target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
 
-    Bitmap.Config config = getSafeConfig(toFit);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toFit, toReuse);
+    TransformationUtils.setAlpha(inBitmap, toReuse);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       Log.v(TAG, "request: " + width + "x" + height);
-      Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
+      Log.v(TAG, "toFit:   " + inBitmap.getWidth() + "x" + inBitmap.getHeight());
       Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
       Log.v(TAG, "minPct:   " + minPercentage);
     }
 
-    Canvas canvas = new Canvas(toReuse);
     Matrix matrix = new Matrix();
     matrix.setScale(minPercentage, minPercentage);
-    canvas.drawBitmap(toFit, matrix, DEFAULT_PAINT);
+    applyMatrix(inBitmap, toReuse, matrix);
 
     return toReuse;
   }
 
+  /**
+   * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
+   * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
+   *
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap  The Bitmap to center.
+   * @param width  The width in pixels of the target.
+   * @param height The height in pixels of the target.
+   * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
+   * height is larger than the given dimensions
+   */
+  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+                                 int height) {
+    if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size larger or equal to input, returning input");
+      }
+      return inBitmap;
+    } else {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size too big for input, fit centering instead");
+      }
+      return fitCenter(pool, inBitmap, width, height);
+    }
+  }
+
   /**
    * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
    * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
    * the transformation for transformations that don't add or remove transparent pixels.
    *
-   * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
+   * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
    * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
    *                    transformation.
    */
-  public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, toTransform.hasAlpha());
+  public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
+    setAlphaIfAvailable(outBitmap, inBitmap.hasAlpha());
   }
 
   @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
@@ -201,6 +250,7 @@ public static int getExifOrientationDegrees(int exifOrientation) {
         break;
       default:
         degreesToRotate = 0;
+        break;
     }
     return degreesToRotate;
   }
@@ -210,33 +260,31 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    *
    * @param pool            A pool that may or may not contain an image of the necessary
    *                        dimensions.
-   * @param toOrient        The bitmap to rotate/flip.
+   * @param inBitmap        The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap toOrient,
+  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
     final Matrix matrix = new Matrix();
     initializeMatrixForRotation(exifOrientation, matrix);
     if (matrix.isIdentity()) {
-      return toOrient;
+      return inBitmap;
     }
 
     // From Bitmap.createBitmap.
-    final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
 
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(toOrient);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
-    final Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toOrient, matrix, DEFAULT_PAINT);
-
+    applyMatrix(inBitmap, result, matrix);
     return result;
   }
 
@@ -245,42 +293,136 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap t
    * have the same width and height equal to the min-edge of the result image.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param destWidth    The width in pixels of the final Bitmap.
    * @param destHeight   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int destWidth,
-      int destHeight) {
+  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int destWidth, int destHeight) {
     int destMinEdge = Math.min(destWidth, destHeight);
     float radius = destMinEdge / 2f;
-    Rect destRect = new Rect((destWidth - destMinEdge) / 2, (destHeight - destMinEdge) / 2,
-        destMinEdge, destMinEdge);
 
-    int srcWidth = toCrop.getWidth();
-    int srcHeight = toCrop.getHeight();
-    int srcMinEdge = Math.min(srcWidth, srcHeight);
-    Rect srcRect = new Rect((srcWidth - srcMinEdge) / 2, (srcHeight - srcMinEdge) / 2,
-        srcMinEdge, srcMinEdge);
+    int srcWidth = inBitmap.getWidth();
+    int srcHeight = inBitmap.getHeight();
+
+    float scaleX = destMinEdge / (float) srcWidth;
+    float scaleY = destMinEdge / (float) srcHeight;
+    float maxScale = Math.max(scaleX, scaleY);
+
+    float scaledWidth = maxScale * srcWidth;
+    float scaledHeight = maxScale * srcHeight;
+    float left = (destMinEdge - scaledWidth) / 2f;
+    float top = (destMinEdge - scaledHeight) / 2f;
+
+    RectF destRect = new RectF(left, top, left + scaledWidth, top + scaledHeight);
 
-    Bitmap result = pool.get(destWidth, destHeight, getSafeConfig(toCrop));
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+
+    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
     setAlphaIfAvailable(result, true /*hasAlpha*/);
-    Canvas canvas = new Canvas(result);
 
-    // Draw a circle
-    canvas.drawCircle(destRect.left + radius, destRect.top + radius, radius,
-        CIRCLE_CROP_SHAPE_PAINT);
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      // Draw a circle
+      canvas.drawCircle(radius, radius, radius, CIRCLE_CROP_SHAPE_PAINT);
+      // Draw the bitmap in the circle
+      canvas.drawBitmap(toTransform, null, destRect, CIRCLE_CROP_BITMAP_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
 
-    // Draw the bitmap in the circle
-    canvas.drawBitmap(toCrop, srcRect, destRect, CIRCLE_CROP_BITMAP_PAINT);
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
 
     return result;
   }
 
+  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
+      @NonNull Bitmap maybeAlphaSafe) {
+    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+      return maybeAlphaSafe;
+    }
+
+    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
+        Bitmap.Config.ARGB_8888);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*pain*/);
+
+    // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
+    // when we're finished with it.
+    return argbBitmap;
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param width the width of the generated bitmap.
+   * @param height the height of the generated bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   */
+  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int width, int height, int roundingRadius) {
+    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
+    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+
+    setAlphaIfAvailable(result, true /* hasAlpha */);
+
+    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
+        Shader.TileMode.CLAMP);
+    Paint paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setShader(shader);
+    RectF rect = new RectF(0, 0, result.getWidth(), result.getHeight());
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      canvas.drawRoundRect(rect, roundingRadius, roundingRadius, paint);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
+
+    return result;
+  }
+
+  // Avoids warnings in M+.
+  private static void clear(Canvas canvas) {
+    canvas.setBitmap(null);
+  }
+
   private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
+  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
+      Matrix matrix) {
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(targetBitmap);
+      canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+  }
+
   // Visible for testing.
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
@@ -312,4 +454,37 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
         // Do nothing.
     }
   }
+
+  private static final class NoLock implements Lock {
+    @Override
+    public void lock() {
+      // do nothing
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+      // do nothing
+    }
+
+    @Override
+    public boolean tryLock() {
+      return true;
+    }
+
+    @Override
+    public boolean tryLock(long time, @NonNull TimeUnit unit) throws InterruptedException {
+      return true;
+    }
+
+    @Override
+    public void unlock() {
+      // do nothing
+    }
+
+    @NonNull
+    @Override
+    public Condition newCondition() {
+      throw new UnsupportedOperationException("Should not be called");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index c3cb3f5c6..9c240aed5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -125,17 +125,20 @@ public boolean handles(ParcelFileDescriptor data, Options options) {
     }
     Integer frameOption = options.get(FRAME_OPTION);
 
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
     final Bitmap result;
-    if (frameTimeMicros == DEFAULT_FRAME) {
-      result = mediaMetadataRetriever.getFrameAtTime();
-    } else if (frameOption == null) {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-    } else {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
+      if (frameTimeMicros == DEFAULT_FRAME) {
+        result = mediaMetadataRetriever.getFrameAtTime();
+      } else if (frameOption == null) {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
+      } else {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+      }
+    } finally {
+      mediaMetadataRetriever.release();
     }
-    mediaMetadataRetriever.release();
     resource.close();
     return BitmapResource.obtain(result, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 9d8c8a2f2..0bf0ee1b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -11,28 +11,102 @@
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade().
+   */
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int).
+   */
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int).
+   */
   public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
     return new DrawableTransitionOptions().crossFade(animationId, duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory).
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder).
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new DrawableTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
   public DrawableTransitionOptions crossFade() {
-    return transition(new DrawableCrossFadeFactory());
+    return crossFade(new DrawableCrossFadeFactory.Builder());
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
   public DrawableTransitionOptions crossFade(int duration) {
-    return transition(new DrawableCrossFadeFactory(duration));
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   *     #setDefaultAnimationId(int)}.
+   * @param duration The duration of the animation, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
   public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return transition(new DrawableCrossFadeFactory(animationId, duration));
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transition(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return crossFade(builder.build());
   }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index aa62a9250..7c436428a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -8,12 +8,14 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
@@ -45,31 +47,35 @@
   private final Context context;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
-  private final ByteArrayPool byteArrayPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getByteArrayPool());
+    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
-  public ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool) {
-    this(context, bitmapPool, byteArrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+  public ByteBufferGifDecoder(
+      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
-  ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      GifHeaderParserPool parserPool, GifDecoderFactory gifDecoderFactory) {
+  ByteBufferGifDecoder(
+      Context context,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      GifHeaderParserPool parserPool,
+      GifDecoderFactory gifDecoderFactory) {
     this.context = context;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
     this.gifDecoderFactory = gifDecoderFactory;
-    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);
+    this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
+    ArrayPool byteArrayPool = new LruArrayPool();
     return !options.get(DISABLE_ANIMATION)
         && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
   }
@@ -135,7 +141,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
   static class GifDecoderFactory {
     public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
-      return new GifDecoder(provider, header, data, sampleSize);
+      return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 6b2988df9..dd75da497 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -6,8 +6,8 @@
 import android.support.annotation.Nullable;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 
 /**
  * Implements {@link com.bumptech.glide.gifdecoder.GifDecoder.BitmapProvider} by wrapping Glide's
@@ -15,23 +15,23 @@
  */
 public final class GifBitmapProvider implements GifDecoder.BitmapProvider {
   private final BitmapPool bitmapPool;
-  @Nullable private final ByteArrayPool byteArrayPool;
+  @Nullable private final ArrayPool arrayPool;
 
   /**
    * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /*byteArrayPool*/);
+    this(bitmapPool, null /* arrayPool */);
   }
 
   /**
-   * Constructs an instance with a shared byte array pool. Byte arrays will be reused where
+   * Constructs an instance with a shared array pool. Arrays will be reused where
    * possible.
    */
-  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ByteArrayPool byteArrayPool) {
+  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
   }
 
   @NonNull
@@ -47,17 +47,35 @@ public void release(Bitmap bitmap) {
 
   @Override
   public byte[] obtainByteArray(int size) {
-    if (byteArrayPool == null) {
+    if (arrayPool == null) {
       return new byte[size];
     }
-    return byteArrayPool.get(size);
+    return arrayPool.get(size, byte[].class);
   }
 
+  @SuppressWarnings("PMD.UseVarargs")
   @Override
   public void release(byte[] bytes) {
-    if (byteArrayPool == null) {
+    if (arrayPool == null) {
       return;
     }
-    byteArrayPool.put(bytes);
+    arrayPool.put(bytes, byte[].class);
+  }
+
+  @Override
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
+    }
+    return arrayPool.get(size, int[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  @Override
+  public void release(int[] array) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(array, int[].class);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index dfcffbc6f..b7243dace 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -12,8 +12,10 @@
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -94,18 +96,26 @@
   public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
       Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
       Bitmap firstFrame) {
-    this(new GifState(context, bitmapPool,
-        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
-            frameTransformation, firstFrame)));
+    this(
+        new GifState(
+            bitmapPool,
+            new GifFrameLoader(
+                // TODO(b/27524013): Factor out this call to Glide.get()
+                Glide.get(context),
+                gifDecoder,
+                targetFrameWidth,
+                targetFrameHeight,
+                frameTransformation,
+                firstFrame)));
   }
 
   GifDrawable(GifState state) {
     this.state = Preconditions.checkNotNull(state);
   }
 
-  // Visible for testing.
-  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(context, bitmapPool, frameLoader));
+  @VisibleForTesting
+  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
+    this(new GifState(bitmapPool, frameLoader));
     this.paint = paint;
   }
 
@@ -162,6 +172,8 @@ public void stop() {
   }
 
   private void startRunning() {
+    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
+        + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -179,6 +191,9 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
+    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
+        + " Ensure that you unset the Drawable from your View before changing the View's"
+        + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -313,13 +328,11 @@ public void setLoopCount(int loopCount) {
 
   static class GifState extends ConstantState {
     static final int GRAVITY = Gravity.FILL;
-    final Context context;
     final BitmapPool bitmapPool;
     final GifFrameLoader frameLoader;
 
-    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
+    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
       this.bitmapPool = bitmapPool;
-      this.context = context.getApplicationContext();
       this.frameLoader = frameLoader;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 5431bca24..2775b496f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -17,6 +17,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
@@ -35,6 +36,7 @@
   private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
   private final RequestManager requestManager;
+  private final BitmapPool bitmapPool;
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
@@ -49,23 +51,40 @@
     void onFrameReady();
   }
 
-  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
-      Transformation<Bitmap> transformation, Bitmap firstFrame) {
-    this(context,
-        Glide.with(context),
+  public GifFrameLoader(
+      Glide glide,
+      GifDecoder gifDecoder,
+      int width,
+      int height,
+      Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this(
+        glide.getContext(),
+        glide.getBitmapPool(),
+        Glide.with(glide.getContext()),
         gifDecoder,
         null /*handler*/,
-        getRequestBuilder(context, width, height), transformation, firstFrame);
+        getRequestBuilder(Glide.with(glide.getContext()), width, height),
+        transformation,
+        firstFrame);
   }
 
-  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
-      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  GifFrameLoader(
+      Context context,
+      BitmapPool bitmapPool,
+      RequestManager requestManager,
+      GifDecoder gifDecoder,
+      Handler handler,
+      RequestBuilder<Bitmap> requestBuilder,
+      Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this.requestManager = requestManager;
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
     this.context = context;
+    this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
 
@@ -193,7 +212,7 @@ private void loadNextFrame() {
 
   private void recycleFirstFrame() {
     if (firstFrame != null) {
-      Glide.get(context).getBitmapPool().put(firstFrame);
+      bitmapPool.put(firstFrame);
       firstFrame = null;
     }
   }
@@ -267,9 +286,14 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
     }
   }
 
-  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
-    return Glide.with(context).asBitmap().apply(
-        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  private static RequestBuilder<Bitmap> getRequestBuilder(
+      RequestManager requestManager, int width, int height) {
+    return requestManager
+        .asBitmap()
+        .apply(
+            diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .skipMemoryCache(true)
+                .override(width, height));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index bef067093..91038724c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -6,7 +6,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 
@@ -31,10 +31,10 @@
       "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
   public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ByteArrayPool byteArrayPool) {
+      ArrayPool byteArrayPool) {
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e6c965436..ad1c55c6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -11,7 +11,7 @@
 public interface ResourceTranscoder<Z, R> {
 
   /**
-   * Transcodes the given resource to the new resource type and returns the wew resource.
+   * Transcodes the given resource to the new resource type and returns the new resource.
    *
    * @param toTranscode The resource to transcode.
    */
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index 3b130fd70..b226cd425 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -1,23 +1,16 @@
 package com.bumptech.glide.manager;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 
 /**
- * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
- * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
- * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
- * the required permission.
+ * A factory class that produces a functional
+ * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
  */
-public class ConnectivityMonitorFactory {
-  public ConnectivityMonitor build(Context context,
-      ConnectivityMonitor.ConnectivityListener listener) {
-    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-    if (hasPermission) {
-      return new DefaultConnectivityMonitor(context, listener);
-    } else {
-      return new NullConnectivityMonitor();
-    }
-  }
+public interface ConnectivityMonitorFactory {
+
+  @NonNull
+  ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index 945df9f96..d191bda2a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -7,6 +7,9 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 
+/**
+ * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
+ */
 class DefaultConnectivityMonitor implements ConnectivityMonitor {
   private final Context context;
   private final ConnectivityListener listener;
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
new file mode 100644
index 000000000..ab3713962
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.manager;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+
+/**
+ * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
+ * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
+ * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
+ * the required permission.
+ */
+public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+
+  @NonNull
+  public ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
+    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
+    if (hasPermission) {
+      return new DefaultConnectivityMonitor(context, listener);
+    } else {
+      return new NullConnectivityMonitor();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 5a84cd246..53044cee1 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -11,7 +11,7 @@
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
-   * returning {@code true} if the listener was removed sucessfully, and {@code false} otherwise.
+   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise.
    *
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 1650bf2f2..86cb7bd8a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -165,7 +165,7 @@ public void onAttach(Activity activity) {
     super.onAttach(activity);
     try {
       registerFragmentWithRoot(activity);
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Unable to register fragment with root", e);
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index e46936da8..58d248d61 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -14,6 +14,7 @@
 import android.support.v4.app.FragmentManager;
 import android.util.Log;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Util;
 
@@ -82,9 +83,12 @@ private RequestManager getApplicationManager(Context context) {
           // activity. However, in this case since the manager attached to the application will not
           // receive lifecycle events, we must force the manager to start resumed using
           // ApplicationLifecycle.
+
+          // TODO(b/27524013): Factor out this Glide.get() call.
+          Glide glide = Glide.get(context);
           applicationManager =
-              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode());
+              new RequestManager(
+                  glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
         }
       }
     }
@@ -186,8 +190,10 @@ RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -214,8 +220,10 @@ RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -239,6 +247,7 @@ public boolean handleMessage(Message message) {
         break;
       default:
         handled = false;
+        break;
     }
     if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
       Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 6fa4b4c41..df141b567 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -154,7 +154,7 @@ public void onAttach(Activity activity) {
     super.onAttach(activity);
     try {
       registerFragmentWithRoot(getActivity());
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Unable to register fragment with root", e);
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index 061856a6c..132e669f8 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -19,7 +19,7 @@
  *                      public class FlickrGlideModule implements GlideModule {
  *                          {@literal @}Override
  *                          public void applyOptions(Context context, GlideBuilder builder) {
- *                              buidler.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
+ *                              builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
  *                          }
  *
  *                          {@literal @}Override
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 7d9a755e5..6b658d5f4 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -11,6 +12,7 @@
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
 public final class ManifestParser {
+  private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
 
   private final Context context;
@@ -20,20 +22,30 @@ public ManifestParser(Context context) {
   }
 
   public List<GlideModule> parse() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Loading Glide modules");
+    }
     List<GlideModule> modules = new ArrayList<>();
     try {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
-      if (appInfo.metaData != null) {
-        for (String key : appInfo.metaData.keySet()) {
-          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
-            modules.add(parseModule(key));
+      if (appInfo.metaData == null) {
+        return modules;
+      }
+      for (String key : appInfo.metaData.keySet()) {
+        if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+          modules.add(parseModule(key));
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Loaded Glide module: " + key);
           }
         }
       }
     } catch (PackageManager.NameNotFoundException e) {
       throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
     }
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Finished loading Glide modules");
+    }
 
     return modules;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index dbb9b2097..649905f51 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -18,6 +18,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
 import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
@@ -61,6 +62,9 @@
   private static final int FALLBACK = 1 << 13;
   private static final int FALLBACK_ID = 1 << 14;
   private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
 
   private int fields;
 
@@ -76,6 +80,7 @@
   private int overrideWidth = UNSET;
   private Key signature = EmptySignature.obtain();
   private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
   private Drawable fallbackDrawable;
   private int fallbackId;
 
@@ -85,6 +90,7 @@
   private boolean isLocked;
   private Resources.Theme theme;
   private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
 
   /**
    * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
@@ -110,6 +116,17 @@ public final CHILD sizeMultiplier(float sizeMultiplier) {
     return selfOrThrowIfLocked();
   }
 
+  public final CHILD useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
    *
@@ -409,6 +426,10 @@ public final CHILD decode(@NonNull Class<?> resourceClass) {
     return selfOrThrowIfLocked();
   }
 
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
   public final boolean isTransformationSet() {
     return isSet(TRANSFORMATION);
   }
@@ -469,6 +490,8 @@ public CHILD downsample(@NonNull DownsampleStrategy strategy) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
    * ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
    * @see #centerCrop(android.content.Context)
@@ -481,6 +504,8 @@ public CHILD optionalCenterCrop(Context context) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
    * throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #transform(Class, com.bumptech.glide.load.Transformation)
    * @see #optionalCenterCrop(android.content.Context)
@@ -493,29 +518,63 @@ public CHILD centerCrop(Context context) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
    * ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
    * @see #fitCenter(android.content.Context)
    */
   public CHILD optionalFitCenter(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
   }
 
   /**
    * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
    * throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #transform(Class, com.bumptech.glide.load.Transformation)
    * @see #optionalFitCenter(android.content.Context)
    */
   public CHILD fitCenter(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   * @see #centerInside(Context) (android.content.Context)
+   */
+  public CHILD optionalCenterInside(Context context) {
+    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #transform(Class, com.bumptech.glide.load.Transformation)
+   * @see #optionalCenterInside(Context) (android.content.Context)
+   */
+  public CHILD centerInside(Context context) {
+    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
   }
 
   /**
    * Applies {@link CircleCrop} to all default types, and ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link Context}.
    * @see #optionalTransform(Context, Transformation)
    * @see #circleCrop(Context)
@@ -528,6 +587,8 @@ public CHILD optionalCircleCrop(Context context) {
    * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
    * an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link Context}.
    * @see #transform(Class, Transformation)
    * @see #optionalCenterCrop(Context)
@@ -563,6 +624,8 @@ final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
    * and throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context        Any {@link android.content.Context}.
    * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
    *                       {@link android.graphics.Bitmap}s.
@@ -576,6 +639,7 @@ public CHILD transform(Context context, @NonNull Transformation<Bitmap> transfor
 
     optionalTransform(context, transformation);
     isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
     return selfOrThrowIfLocked();
   }
 
@@ -585,6 +649,8 @@ public CHILD transform(Context context, @NonNull Transformation<Bitmap> transfor
    * {@link android.graphics.drawable.BitmapDrawable}, and
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context        Any {@link android.content.Context}.
    * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
    *                       {@link android.graphics.Bitmap}s.
@@ -616,6 +682,8 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
    * an unknown resource class will throw an exception. To allow unknown types, users must always
    * call the optional version of each method. </p>
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param resourceClass  The type of resource to transform.
    * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
    */
@@ -627,8 +695,10 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
 
     Preconditions.checkNotNull(resourceClass);
     Preconditions.checkNotNull(transformation);
-    fields |= TRANSFORMATION;
     transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
     return selfOrThrowIfLocked();
   }
 
@@ -636,6 +706,8 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
    * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
    * the given type and throws if asked to transform an unknown resource type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param resourceClass  The type of resource to transform.
    * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
@@ -647,6 +719,7 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
 
     optionalTransform(resourceClass, transformation);
     isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
     return selfOrThrowIfLocked();
   }
 
@@ -660,9 +733,12 @@ public final CHILD dontTransform() {
       return clone().dontTransform();
     }
 
-    fields &= ~TRANSFORMATION;
     transformations.clear();
+    fields &= ~TRANSFORMATION;
     isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
     return selfOrThrowIfLocked();
   }
 
@@ -691,6 +767,9 @@ public final CHILD apply(BaseRequestOptions<?> other) {
     if (isSet(other.fields, SIZE_MULTIPLIER)) {
       sizeMultiplier = other.sizeMultiplier;
     }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
     if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
       diskCacheStrategy = other.diskCacheStrategy;
     }
@@ -731,10 +810,25 @@ public final CHILD apply(BaseRequestOptions<?> other) {
     if (isSet(other.fields, THEME)) {
       theme = other.theme;
     }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
 
-    isTransformationRequired |= other.isTransformationRequired;
     fields |= other.fields;
-    transformations.putAll(other.transformations);
     options.putAll(other.options);
 
     return selfOrThrowIfLocked();
@@ -864,4 +958,8 @@ private boolean isSet(int flag) {
   private static boolean isSet(int fields, int flag) {
     return (fields & flag) != 0;
   }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 3c57db530..094c7cf01 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -23,13 +23,27 @@
  *
  * <pre>
  *     {@code
- *      RequestFutureTarget target = Glide.load("")...
- *     Object resource = target.get();
- *     // Do something with resource, and when finished:
- *     target.cancel(false);
+ *      FutureTarget<File> target = null;
+ *      RequestManager requestManager = Glide.with(context);
+ *      try {
+ *        target = requestManager
+ *           .downloadOnly()
+ *           .load(model)
+ *           .submit();
+ *        File downloadedFile = target.get();
+ *        // ... do something with the file (usually throws IOException)
+ *      } catch (ExecutionException | InterruptedException | IOException e) {
+ *        // ... bug reporting or recovery
+ *      } finally {
+ *        // make sure to cancel pending operations and free resources
+ *        if (target != null) {
+ *          target.cancel(true); // mayInterruptIfRunning
+ *        }
+ *      }
  *     }
  *     </pre>
- * The {@link #cancel(boolean)} call will make sure any resources used are recycled.
+ * The {@link #cancel(boolean)} call will cancel pending operations and
+ * make sure that any resources used are recycled.
  * </p>
  *
  * @param <R> The type of the resource that will be loaded.
@@ -167,7 +181,7 @@ public synchronized void onResourceReady(R resource, Transition<? super R> trans
 
   private synchronized R doGet(Long timeoutMillis)
       throws ExecutionException, InterruptedException, TimeoutException {
-    if (assertBackgroundThread) {
+    if (assertBackgroundThread && !isDone()) {
       Util.assertBackgroundThread();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index cd8ddb751..0bde3e95a 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -38,9 +38,9 @@
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
-   * @param isFirstResource True if this exception is for the first resource to load.
-   * @return True if the listener has handled updating the target for the given exception, false to
-   * allow Glide's request to update the target.
+   * @param isFirstResource {@code true} if this exception is for the first resource to load.
+   * @return {@code true} if the listener has handled updating the target for the given exception,
+   *         {@code false} to allow Glide's request to update the target.
    */
   boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
       boolean isFirstResource);
@@ -53,12 +53,13 @@ boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
    * @param model             The specific model that was used to load the image.
    * @param target            The target the model was loaded into.
    * @param dataSource        The {@link DataSource} the resource was loaded from.
-   * @param isFirstResource   True if this is the first resource to in this load to be loaded into
-   *                          the target. For example when loading a thumbnail and a fullsize image,
-   *                          this will be true for the first image to load and false for the
-   *                          second.
-   * @return True if the listener has handled setting the resource on the target (including any
-   * animations), false to allow Glide's request to update the target (again including animations).
+   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
+   *                          loaded into the target. For example when loading a thumbnail and a
+   *                          full-sized image, this will be {@code true} for the first image to
+   *                          load and {@code false} for the second.
+   * @return {@code true} if the listener has handled setting the resource on the target,
+   *         {@code false} to allow Glide's request to update the target.
+   *         Setting the resource includes handling animations, be sure to take that into account.
    */
   boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
       boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 6e8aa1e65..3bf554ecd 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -26,6 +26,7 @@
   private static RequestOptions skipMemoryCacheTrueOptions;
   private static RequestOptions skipMemoryCacheFalseOptions;
   private static RequestOptions fitCenterOptions;
+  private static RequestOptions centerInsideOptions;
   private static RequestOptions centerCropOptions;
   private static RequestOptions circleCropOptions;
   private static RequestOptions noTransformOptions;
@@ -131,6 +132,18 @@ public static RequestOptions fitCenterTransform(Context context) {
     return fitCenterOptions;
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #centerInside(Context)} set.
+   */
+  public static RequestOptions centerInsideTransform(Context context) {
+    if (centerInsideOptions == null) {
+      centerInsideOptions = new RequestOptions()
+              .centerInside(context.getApplicationContext())
+              .autoLock();
+    }
+    return centerInsideOptions;
+  }
+
   /**
    * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index e8262fa69..f498d529b 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -200,7 +200,14 @@ public void begin() {
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
-      onLoadFailed(new GlideException("Received null model"));
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+        width = overrideWidth;
+        height = overrideHeight;
+      }
+      // Only log at more verbose log levels if the user has set a fallback drawable, because
+      // fallback Drawables indicate the user expects null models occasionally.
+      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+      onLoadFailed(new GlideException("Received null model"), logLevel);
       return;
     }
 
@@ -334,9 +341,9 @@ private Drawable getFallbackDrawable() {
     return fallbackDrawable;
   }
 
-  private Drawable loadDrawable(int resouceId) {
+  private Drawable loadDrawable(int resourceId) {
     Resources resources = glideContext.getResources();
-    return ResourcesCompat.getDrawable(resources, resouceId, requestOptions.getTheme());
+    return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());
   }
 
   private void setErrorPlaceholder() {
@@ -366,8 +373,8 @@ public void onSizeReady(int width, int height) {
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = Math.round(sizeMultiplier * width);
-    this.height = Math.round(sizeMultiplier * height);
+    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
@@ -386,12 +393,17 @@ public void onSizeReady(int width, int height) {
         requestOptions.isTransformationRequired(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
+        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
 
+  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+  }
+
   private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
@@ -482,9 +494,13 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
    */
   @Override
   public void onLoadFailed(GlideException e) {
+    onLoadFailed(e, Log.WARN);
+  }
+
+  private void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
     int logLevel = glideContext.getLogLevel();
-    if (logLevel <= Log.WARN) {
+    if (logLevel <= maxLogLevel) {
       Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
       if (logLevel <= Log.INFO) {
         e.logRootCauses(GLIDE_TAG);
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 195c24d69..d878f0c07 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -43,7 +43,7 @@ private boolean parentCanSetImage() {
 
   /**
    * Returns true if the request is the request loading the fullsize image and if neither the full
-   * nor the thumbnail image have completed sucessfully.
+   * nor the thumbnail image have completed successfully.
    *
    * @param request {@inheritDoc}.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 6928462ae..ccfe0f1fe 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -17,7 +17,6 @@
  * for every subsequent load. </p>
  */
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
-
   private final int[] widgetIds;
   private final ComponentName componentName;
   private final RemoteViews remoteViews;
@@ -29,16 +28,16 @@
    * it.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param viewId      The id of the ImageView view that will load the image.
    * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
    * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, int... widgetIds) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -56,29 +55,30 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
    * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, ComponentName componentName) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -94,14 +94,14 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
+   * @param viewId        The id of the ImageView view that will load the image.
    * @param remoteViews   RemoteViews object which contains the ImageView that will load the
    *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId,
-      ComponentName componentName) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 85ed326a4..bebc127fb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -93,6 +93,8 @@ public void onResourceReady(Z resource, @Nullable Transition<? super Z> transiti
     if (resource instanceof Animatable) {
       animatable = (Animatable) resource;
       animatable.start();
+    } else {
+      animatable = null;
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index ec889d0ad..35d32b295 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -18,10 +18,10 @@
  * for every subsequent load. </p>
  */
 public class NotificationTarget extends SimpleTarget<Bitmap> {
-
   private final RemoteViews remoteViews;
   private final Context context;
   private final int notificationId;
+  private final String notificationTag;
   private final Notification notification;
   private final int viewId;
 
@@ -30,35 +30,58 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param notification   The Notification object that we want to update.
-   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
-      Notification notification, int notificationId) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+  public NotificationTarget(Context context,
+      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+    this(context, viewId, remoteViews, notification, notificationId, null);
   }
 
   /**
-   * Constructor using a Notification object and a notificationId to get a handle on the
-   * Notification in order to update it.
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the
+   * target width and height.
+   *
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
+   *                        May be {@code null}.
+   */
+  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
+      Notification notification, int notificationId, String notificationTag) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
+      notificationTag);
+  }
+
+  /**
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param width          Desired width of the bitmap that will be loaded.(Need to be manually put
-   *                       because of RemoteViews limitations.)
-   * @param height         Desired height of the bitmap that will be loaded. (Need to be manually
-   *                       put because of RemoteViews limitations.)
-   * @param notification   The Notification object that we want to update.
-   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param width           Desired width of the bitmap that will be loaded.(Need to be manually put
+   *                        because of RemoteViews limitations.)
+   * @param height          Desired height of the bitmap that will be loaded. (Need to be manually
+   *                        put because of RemoteViews limitations.)
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the
+   *                        Bitmap. May be {@code null}.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, Notification notification, int notificationId) {
+  public NotificationTarget(Context context, int width, int height, int viewId,
+      RemoteViews remoteViews, Notification notification, int notificationId,
+      String notificationTag) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
     this.notification =
@@ -67,6 +90,7 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
         Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
     this.viewId = viewId;
     this.notificationId = notificationId;
+    this.notificationTag = notificationTag;
   }
 
   /**
@@ -75,7 +99,7 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationId, this.notification);
+    manager.notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 1199c6870..8144e5d90 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -5,7 +5,7 @@
 /**
  * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
- * Typicaly use cases look something like this:
+ * Typically use cases look something like this:
  * <pre>
  * <code>
  * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 2245adace..5adf88de7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -31,11 +31,15 @@
    * A lifecycle callback that is called when a load is started.
    *
    * <p> Note - This may not be called for every load, it is possible for example for loads to fail
-   * before the load starts (when the model object is null). </p>
+   * before the load starts (when the model object is null).
    *
    * <p> Note - This method may be called multiple times before any other lifecycle method is
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here. </p>
+   * restart may cause a call here.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -45,7 +49,11 @@
    * A lifecycle callback that is called when a load fails.
    *
    * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null. </p>
+   * } if the model object is null.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -61,6 +69,10 @@
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
    *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
+   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadCleared(@Nullable Drawable placeholder);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index 84306618b..c3d658f9b 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -14,7 +14,7 @@
  * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
  * a scrolling list like ListView, GridView, or RecyclerView.
  *
- * <p>{@link FixedSizeDrawable} may cause skewing or other undesireable behavior depending on
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on
  * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
  * {@link BitmapImageViewTarget} as alternatives.
  *
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 336d4b069..5e85c6c28 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -6,6 +6,7 @@
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.v4.view.ViewCompat;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
@@ -204,7 +205,13 @@ void getSize(SizeReadyCallback cb) {
       int currentWidth = getViewWidthOrParam();
       int currentHeight = getViewHeightOrParam();
       if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
-        cb.onSizeReady(currentWidth, currentHeight);
+        int paddingAdjustedWidth = currentWidth == WindowManager.LayoutParams.WRAP_CONTENT
+            ? currentWidth
+            : currentWidth - ViewCompat.getPaddingStart(view) - ViewCompat.getPaddingEnd(view);
+        int paddingAdjustedHeight = currentHeight == LayoutParams.WRAP_CONTENT
+            ? currentHeight
+            : currentHeight - view.getPaddingTop() - view.getPaddingBottom();
+        cb.onSizeReady(paddingAdjustedWidth, paddingAdjustedHeight);
       } else {
         // We want to notify callbacks in the order they were added and we only expect one or two
         // callbacks to
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index e4e3a0d93..166c34b08 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -15,35 +15,20 @@
  * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
- * the memory cache this factory produces an {@link NoTransition}. </p>
+ * the memory cache this factory produces an {@link NoTransition}.
  */
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private static final int DEFAULT_DURATION_MS = 300;
   private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
   private DrawableCrossFadeTransition firstResourceTransition;
   private DrawableCrossFadeTransition secondResourceTransition;
 
-  public DrawableCrossFadeFactory() {
-    this(DEFAULT_DURATION_MS);
-  }
-
-  public DrawableCrossFadeFactory(int duration) {
-    this(new ViewAnimationFactory<Drawable>(
-        new DefaultViewTransitionAnimationFactory(duration)), duration);
-  }
-
-  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
-  }
-
-  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
-  }
-
-  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
+  protected DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory,
+      int duration, boolean isCrossFadeEnabled) {
     this.viewAnimationFactory = viewAnimationFactory;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
@@ -59,36 +44,117 @@ public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
 
   private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
       if (firstResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);
-          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        firstResourceTransition = buildTransition(dataSource, true /*isFirstResource*/);
       }
       return firstResourceTransition;
   }
 
   private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
       if (secondResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);
-          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        secondResourceTransition = buildTransition(dataSource, false /*isFirstResource*/);
       }
       return secondResourceTransition;
   }
 
-  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private DrawableCrossFadeTransition buildTransition(DataSource dataSource,
+      boolean isFirstResource) {
+    Transition<Drawable> defaultAnimation =
+        viewAnimationFactory.build(dataSource, isFirstResource);
+    return new DrawableCrossFadeTransition(defaultAnimation, duration, isCrossFadeEnabled);
+  }
+
+  private static final class DefaultViewTransitionAnimationFactory implements
+      ViewTransition.ViewTransitionAnimationFactory {
 
-    private final int duration;
+    private final int durationMillis;
 
-    DefaultViewTransitionAnimationFactory(int duration) {
-      this.duration = duration;
+    DefaultViewTransitionAnimationFactory(int durationMillis) {
+      this.durationMillis = durationMillis;
     }
 
     @Override
     public Animation build(Context context) {
       AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(duration);
+      animation.setDuration(durationMillis);
       return animation;
     }
   }
+
+  /**
+   * A Builder for {@link DrawableCrossFadeFactory}.
+   */
+  public static class Builder {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private int durationMillis;
+    private ViewAnimationFactory<Drawable> factory;
+    private boolean isCrossFadeEnabled;
+
+    public Builder() {
+      this(DEFAULT_DURATION_MS);
+    }
+
+    /**
+     * @param durationMillis The duration of both the default animation when no previous Drawable
+     *     is present and the cross fade animation when a previous Drawable is present. This value
+     *     will not be used by the default animation if {@link #setDefaultAnimationId(int)},
+     *     {@link #setDefaultAnimation(Animation)}, or
+     *     {@link #setDefaultAnimationFactory(ViewAnimationFactory)} is called.
+     */
+    public Builder(int durationMillis) {
+      this.durationMillis = durationMillis;
+      factory = new ViewAnimationFactory<>(
+          new DefaultViewTransitionAnimationFactory(durationMillis));
+    }
+
+    /**
+     * Enables or disables animating the alpha of the {@link Drawable} the cross fade will animate
+     * from.
+     *
+     * <p>Defaults to {@code false}.
+     *
+     * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
+     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
+     *     alpha will remain at 100 throughout the animation. See
+     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     */
+    public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
+      this.isCrossFadeEnabled = isCrossFadeEnabled;
+      return this;
+    }
+
+    /**
+     * Sets the resource id of the {@link Animation} to use when no previous {@link Drawable} is
+     * available to animate from.
+     *
+     * <p>Defaults to a simple fade in.
+     */
+    public Builder setDefaultAnimationId(int animationId) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animationId));
+    }
+
+    /**
+     * Sets the {@link Animation} to use when no previous {@link Drawable} is available to animate
+     * from.
+     *
+     * <p>It is not safe to use the same {@link Animation} object for multiple animations
+     * simultaneously. Always pass in a new instance to this method.
+     */
+    public Builder setDefaultAnimation(Animation animation) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animation));
+    }
+
+    /**
+     * Sets the {@link ViewAnimationFactory} to use to generate animations to animate when no
+     * previous {@link Drawable} is available to animate from.
+     */
+    public Builder setDefaultAnimationFactory(ViewAnimationFactory<Drawable> factory) {
+      this.factory = factory;
+      return this;
+    }
+
+    public DrawableCrossFadeFactory build() {
+      return new DrawableCrossFadeFactory(factory, durationMillis, isCrossFadeEnabled);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 2cbca19c7..ee1ff46e2 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -13,17 +13,28 @@
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
   private final Transition<Drawable> defaultAnimation;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
 
   /**
    * Constructor that takes a default animation and a duration in milliseconds that the cross fade
    * animation should last.
    *
+   * @param defaultAnimation The {@link Transition} to use if there is no previous
+   *                         {@link Drawable} (either a placeholder or previous resource) to
+   *                         transition from.
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
+   *                         animating the new resource's alpha to 100. Otherwise, only animates
+   *                         the new resource's alpha to 100 while leaving the previous resource's
+   *                         alpha at 100. See
+   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
+  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration,
+      boolean isCrossFadeEnabled) {
     this.defaultAnimation = defaultAnimation;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   /**
@@ -43,7 +54,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
     if (previous != null) {
       TransitionDrawable transitionDrawable =
           new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(true);
+      transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
       transitionDrawable.startTransition(duration);
       adapter.setDrawable(transitionDrawable);
       return true;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 5192b150b..2417f8ab6 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -15,6 +15,9 @@
 
   /**
    * A factory that always returns the same {@link NoTransition}.
+   *
+   * @param <R> the resource type that will be transitioned into a
+   * {@link com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 0764fe285..907a4effb 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -55,7 +55,7 @@ private static Key obtainVersionSignature(Context context) {
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new StringSignature(versionCode);
+    return new ObjectKey(versionCode);
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 37f15a62f..4c0474748 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Util;
 
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -32,6 +33,7 @@ public MediaStoreSignature(String mimeType, long dateModified, int orientation)
     this.orientation = orientation;
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -49,10 +51,9 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
+    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
       return false;
     }
-
     return true;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java b/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
deleted file mode 100644
index 5492f2216..000000000
--- a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Preconditions;
-
-import java.security.MessageDigest;
-
-/**
- * A unique Signature that wraps a String.
- *
- * TODO: remove this and replace with ObjectKey.
- */
-public class StringSignature implements Key {
-  private final String signature;
-
-  public StringSignature(String signature) {
-    this.signature = Preconditions.checkNotNull(signature);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-
-    StringSignature that = (StringSignature) o;
-
-    return signature.equals(that.signature);
-  }
-
-  @Override
-  public int hashCode() {
-    return signature.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "StringSignature{"
-        + "signature='" + signature + '\''
-        + '}';
-  }
-
-  @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    messageDigest.update(signature.getBytes(CHARSET));
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 72204c4b4..a3f5c3de0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -112,6 +113,27 @@ public static InputStream toStream(ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
+  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+    ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
+
+    byte[] buffer = BUFFER_REF.getAndSet(null);
+    if (buffer == null) {
+      buffer = new byte[BUFFER_SIZE];
+    }
+
+    int n = -1;
+    while ((n = stream.read(buffer)) >= 0) {
+      outStream.write(buffer, 0, n);
+    }
+
+    BUFFER_REF.set(buffer);
+
+    byte[] bytes = outStream.toByteArray();
+
+    // Some resource decoders require a direct byte buffer. Prefer allocateDirect() over wrap()
+    return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
+  }
+
   private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index de27683b6..18fd5e04e 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -3,6 +3,7 @@
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
+@SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
   private Class<?> second;
@@ -35,6 +36,7 @@ public String toString() {
     return "MultiClassKey{" + "first=" + first + ", second=" + second + '}';
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -52,10 +54,7 @@ public boolean equals(Object o) {
     if (!second.equals(that.second)) {
       return false;
     }
-    if (third == null && that.third != null) {
-      return false;
-    }
-    if (third != null && !third.equals(that.third)) {
+    if (!Util.bothNullOrEqual(third, that.third)) {
       return false;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 762d49765..0f9c35794 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -37,6 +37,7 @@ public static String sha256BytesToHex(byte[] bytes) {
   // Taken from:
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
+  @SuppressWarnings("PMD.UseVarargs")
   private static String bytesToHex(byte[] bytes, char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
@@ -108,6 +109,7 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
+        break;
     }
     return bytesPerPixel;
   }
@@ -178,4 +180,13 @@ public static boolean isOnBackgroundThread() {
       }
       return result;
   }
+
+  /**
+   * Null-safe equivalent of {@code a.equals(b)}.
+   *
+   * @see java.util.Objects#equals
+   */
+  public static boolean bothNullOrEqual(Object a, Object b) {
+    return a == null ? b == null : a.equals(b);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5677b391d..f37f74fe8 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -40,7 +40,7 @@ public ViewPreloadSizeProvider() {
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
   public ViewPreloadSizeProvider(View view) {
-    setView(view);
+    this.viewTarget = new SizeViewTarget(view, this);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 87c9d71fc..009ddebf6 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -105,6 +105,8 @@ public void reset(List<T> object) {
 
   /**
    * Creates new instances of the given type.
+   *
+   * @param <T> The type of Object that will be created.
    */
   public interface Factory<T> {
     T create();
@@ -112,6 +114,8 @@ public void reset(List<T> object) {
 
   /**
    * Resets state when objects are returned to the pool.
+   *
+   * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
     void reset(T object);
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index b5268c68b..65460d082 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -26,7 +26,7 @@ private StateVerifier() { }
   public abstract void throwIfRecycled();
 
   /**
-   * Sets whether or not our objet is recycled.
+   * Sets whether or not our object is recycled.
    */
   abstract void setRecycled(boolean isRecycled);
 
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 01bdd28b8..bbc03b66a 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -39,6 +39,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
@@ -125,7 +126,7 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
 
     Lifecycle lifecycle = mock(Lifecycle.class);
     RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
     requestManager.resumeRequests();
   }
 
@@ -507,7 +508,7 @@ public void testNullModelPrefersErrorDrawable() {
   }
 
   @Test
-  public void testNullModelPrefersFallbackDrwaable() {
+  public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
     Drawable error = new ColorDrawable(Color.RED);
     Drawable fallback = new ColorDrawable(Color.BLUE);
@@ -534,7 +535,7 @@ public void testClone() throws IOException {
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
     Target secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
-    RequestBuilder<Drawable> firstRequest = Glide.with(getContext())
+    RequestBuilder<Drawable> firstRequest = requestManager
         .load(mockUri("content://first"));
 
     firstRequest.into(firstTarget);
@@ -543,7 +544,7 @@ public void testClone() throws IOException {
         .apply(placeholderOf(new ColorDrawable(Color.RED)))
         .into(secondTarget);
 
-    verify(firstTarget).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
+    verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
     verify(secondTarget).onResourceReady(notNull(), isA(Transition.class));
   }
 
@@ -560,8 +561,7 @@ public void testClone() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
     when(failLoader.handles(isA(failModel))).thenReturn(true);
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(failLoader);
+    when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
     Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
   }
@@ -599,8 +599,7 @@ private Context getContext() {
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(modelLoader);
+    when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
     Glide.get(RuntimeEnvironment.application).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
@@ -654,15 +653,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     @Override
     public void applyOptions(Context context, GlideBuilder builder) {
       // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = mock(GlideExecutor.class);
-      doAnswer(new Answer<Void>() {
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-          Runnable runnable = (Runnable) invocation.getArguments()[0];
-          runnable.run();
-          return null;
-        }
-      }).when(executor).execute(isA(Runnable.class));
+      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
 
       DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
       when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
@@ -699,7 +690,7 @@ public void registerComponents(Context context, Registry registry) {
           .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
       when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
       ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
           .thenReturn(mockUrlLoader);
 
       registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index 34d04e635..b76b5dc58 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -75,7 +75,7 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       public int expectedPosition;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -132,7 +132,7 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       int expectedPosition = toPreload - 1;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -257,8 +257,8 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition++;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
@@ -275,7 +275,7 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
 
     preloader.onScroll(null, 1, 10, 1 + 10 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
@@ -293,8 +293,8 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition--;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
@@ -312,11 +312,11 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     preloader.onScroll(null, 3, 2, 3 + 2);
     preloader.onScroll(null, 2, 2, 3 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
-  private List<Integer> getTagetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
+  private List<Integer> getTargetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
     ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
@@ -372,7 +372,7 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     }
 
     @Override
-    public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+    public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
       return new int[] { 100, 100 };
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index f08fae2af..d27622655 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -70,12 +70,12 @@ public void testRemovesPreviousRequestFromRequestTracker() {
     verify(requestManager).clear(eq(target));
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullTarget() {
     getNullModelRequest().into((Target) null);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullView() {
     getNullModelRequest().into((ImageView) null);
   }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0e171262f..4b964e1ee 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -57,8 +57,13 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
           }
         });
     requestTracker = mock(RequestTracker.class);
-    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
-        requestTracker, factory);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index a682ff139..d60e9c262 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -2,7 +2,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 
@@ -18,7 +19,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifOrientationStreamTest {
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
@@ -28,7 +29,7 @@ private InputStream openOrientationExample(boolean isLandscape, int item) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 678b9460a..549097336 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,9 +10,10 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 
 import org.junit.After;
 import org.junit.Before;
@@ -55,7 +56,7 @@ public void setUp() throws IOException {
     defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
     HttpURLConnection.setFollowRedirects(false);
     mockWebServer = new MockWebServer();
-    mockWebServer.play();
+    mockWebServer.start();
 
     streamCaptor = ArgumentCaptor.forClass(InputStream.class);
   }
@@ -80,7 +81,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -91,7 +92,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -120,7 +121,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -137,9 +138,9 @@ public void testHandlesUpToFiveRedirects() throws Exception {
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -176,7 +177,7 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -204,7 +205,7 @@ public void testSetsReadTimeout() throws Exception {
     MockWebServer tempWebServer = new MockWebServer();
     tempWebServer.enqueue(
         new MockResponse().setBody("test").throttleBody(1, TIMEOUT_TIME_MS, TimeUnit.MILLISECONDS));
-    tempWebServer.play();
+    tempWebServer.start();
 
     try {
       getFetcher().loadData(Priority.HIGH, callback);
@@ -233,11 +234,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private HttpUrlFetcher getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private HttpUrlFetcher getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
         HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af261f814..d56c443a0 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -64,7 +64,7 @@ public void testHandlesExceptionOnClose() throws Exception {
     final Closeable closeable = mock(Closeable.class);
 
     public TestLocalUriFetcher(Context context, Uri uri) {
-      super(context, uri);
+      super(context.getContentResolver(), uri);
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 0b0673dc3..db9fade55 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -17,7 +17,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
@@ -38,12 +37,12 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+    fetcher = new ThumbFetcher(uri, opener);
   }
 
   @Test
   public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.LOW, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
@@ -51,7 +50,7 @@ public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
 
   @Test
   public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.HIGH, callback);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index a6f9070da..47b5c6eef 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -8,12 +8,13 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.content.ContentResolver;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -41,43 +42,41 @@ public void setUp() {
 
   @Test
   public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(new MatrixCursor(new String[1]));
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
     cursor.addRow(new Object[] { "" });
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(cursor);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.exists(eq(harness.file))).thenReturn(false);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.length(eq(harness.file))).thenReturn(0L);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testClosesCursor() throws FileNotFoundException {
-    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    harness.get().open(harness.uri);
     assertTrue(harness.cursor.isClosed());
   }
 
@@ -86,27 +85,33 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     InputStream expected = new ByteArrayInputStream(new byte[0]);
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .registerInputStream(harness.uri, expected);
-    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertEquals(expected, harness.get().open(harness.uri));
   }
 
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    ThumbFetcher.VideoThumbnailQuery query =
+        new ThumbFetcher.VideoThumbnailQuery(getContentResovler());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
   }
 
   @Test
-  public void testImageQueryReturnsImageCurosr() {
+  public void testImageQueryReturnsImageCursor() {
     Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    ThumbFetcher.ImageThumbnailQuery query =
+        new ThumbFetcher.ImageThumbnailQuery(getContentResovler());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
+  }
+
+  private static ContentResolver getContentResovler() {
+    return RuntimeEnvironment.application.getContentResolver();
   }
 
   private static class Harness {
@@ -115,18 +120,18 @@ public void testImageQueryReturnsImageCurosr() {
     Uri uri = Uri.fromFile(file);
     ThumbnailQuery query = mock(ThumbnailQuery.class);
     FileService service = mock(FileService.class);
-    ByteArrayPool byteArrayPool = new LruByteArrayPool();
+    ArrayPool byteArrayPool = new LruArrayPool();
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
-      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
       when(service.length(eq(file))).thenReturn(1L);
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+      return new ThumbnailStreamOpener(service, query, byteArrayPool, getContentResovler());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index b9790640b..1dc6554fe 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data.resource;
 
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -26,6 +27,8 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.internal.ShadowExtractor;
 
+import java.io.FileNotFoundException;
+
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
@@ -38,9 +41,9 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsFileDescriptor() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    final Uri uri = Uri.parse("file://nothing");
+  public void testLoadResource_returnsFileDescriptor() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
     ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
@@ -50,9 +53,24 @@ public void testLoadsFileDescriptor() throws Exception {
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
     shadow.registerFileDescriptor(uri, assetFileDescriptor);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
 
+  @Test
+  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
+
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index ee8f8d922..968c448be 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -1,14 +1,17 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.isNotNull;
 import static org.mockito.Mockito.verify;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+import com.bumptech.glide.tests.ContentResolverShadow;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -18,11 +21,14 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.internal.ShadowExtractor;
 
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
 import java.io.InputStream;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class StreamLocalUriFetcherTest {
   @Mock DataFetcher.DataCallback<InputStream> callback;
 
@@ -32,11 +38,32 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsInputStream() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+  public void testLoadResource_returnsInputStream() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
   }
+
+  @Test
+  public void testLoadResource_withNullInputStream_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+
+    shadow.registerInputStream(uri, null /*inputStream*/);
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 1987cc797..0df1fe1fb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -21,6 +21,7 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 
 import org.junit.Before;
@@ -414,27 +415,42 @@ public void testCancelsDecodeJobOnCancel() {
   @Test
   public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
     EngineJob<Object> job = harness.getJob();
+    harness.diskCacheService.shutdownNow();
     job.reschedule(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.diskCacheService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
-  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart() {
+  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    EngineJob<Object> job = harness.getJob();
+
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
   }
 
   @SuppressWarnings("unchecked")
@@ -444,20 +460,22 @@ public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart(
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     int numCbs = 10;
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     EngineJob<Object> job;
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
+          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -476,17 +494,19 @@ public MultiCbHarness() {
     Resource<Object> resource = mock(Resource.class);
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     public EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      EngineJob result = new EngineJob(diskCacheService, sourceService, sourceUnlimitedService,
+          listener, pool, factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 8cbe62361..2b888bd38 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -27,6 +27,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
@@ -420,7 +421,21 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
   public void testFactoryIsGivenNecessaryArguments() {
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(true) /*isMemoryCacheable*/);
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(true) /*useUnlimitedSourceGeneratorPool*/);
   }
 
   @Test
@@ -469,6 +484,7 @@ public void runTest() throws Exception {
     Options options = new Options();
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -476,13 +492,16 @@ public EngineTestHarness() {
 
       job = mock(EngineJob.class);
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),
-          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,
-          decodeJobFactory, resourceRecycler);
+      engine = new Engine(cache, mock(DiskCache.Factory.class),
+          GlideExecutor.newDiskCacheExecutor(),
+          MockGlideExecutor.newMainThreadExecutor(),
+          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+          jobs, keyFactory, activeResources,
+          engineJobFactory, decodeJobFactory, resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean())).thenReturn(job);
       return engine.load(glideContext,
           model,
           signature,
@@ -496,6 +515,7 @@ public EngineTestHarness() {
           false /*isTransformationRequired*/,
           options,
           isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
index fe8c252b1..97bac56e7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -7,7 +7,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
 
@@ -42,7 +42,7 @@ public void testDifferIfSourceKeyDiffers()
     mutateAndAssertDifferent(new FactoryMutation() {
       @Override
       public void mutate(Factory factory) {
-        factory.sourceKey = new StringSignature("secondKey");
+        factory.sourceKey = new ObjectKey("secondKey");
       }
     });
   }
@@ -52,7 +52,7 @@ public void testDiffersIfSignatureDiffers() {
     mutateAndAssertDifferent(new FactoryMutation() {
       @Override
       public void mutate(Factory factory) {
-        factory.signature = new StringSignature("secondSignature");
+        factory.signature = new ObjectKey("secondSignature");
       }
     });
   }
@@ -116,8 +116,8 @@ private void mutateAndAssertDifferent(FactoryMutation mutation) {
   }
 
   static class Factory {
-    Key sourceKey = new StringSignature("sourceKey");
-    Key signature = new StringSignature("signature");
+    Key sourceKey = new ObjectKey("sourceKey");
+    Key signature = new ObjectKey("signature");
     int width = 100;
     int height = 100;
     Transformation<?> transformation = mock(Transformation.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..f48d297dd
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,111 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.DEFAULT, sdk = 18)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final Class ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() throws Exception {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(ADAPTER.getArrayLength(array) >= size);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
+        ARRAY_CLASS);
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+    }
+  }
+
+  private Object createArray(Class type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 6db6062dd..14b51fedc 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,7 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -102,18 +102,18 @@ public void testEvictedBitmapsAreRecycled() {
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesHalfOfBitmaps() {
-    testTrimMemory(MAX_SIZE, TRIM_MEMORY_BACKGROUND, MAX_SIZE / 2);
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
-    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_BACKGROUND, 0);
+  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
   }
 
   @Test
-  public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_MODERATE, TRIM_MEMORY_COMPLETE }) {
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
+    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 61918f223..4944d2564 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -39,30 +39,30 @@ public TrimClearMemoryCacheHarness() {
   }
 
   @Test
-  public void testTrimMemoryModerate() {
+  public void testTrimMemoryBackground() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
 
     verify(harness.listener).onResourceRemoved(eq(harness.first));
     verify(harness.listener).onResourceRemoved(eq(harness.second));
   }
 
   @Test
-  public void testTrimMemoryComplete() {
+  public void testTrimMemoryModerate() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener).onResourceRemoved(harness.second);
   }
 
   @Test
-  public void testTrimMemoryBackground() {
+  public void testTrimMemoryUiHidden() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener, never()).onResourceRemoved(harness.second);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 3d3bb983c..d22bf9fa9 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -141,7 +141,7 @@ public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
 
     Util.setSdkVersionInt(10);
 
-    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();
+    int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
   }
 
@@ -161,7 +161,7 @@ private int getLargeEnoughMemoryClass() {
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
     float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
-    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;
+    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
     ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
     MemorySizeCalculator.ScreenDimensions screenDimensions =
@@ -176,7 +176,7 @@ public MemorySizeCalculator getCalculator() {
           .setMaxSizeMultiplier(sizeMultiplier)
           .setActivityManager(activityManager)
           .setScreenDimensions(screenDimensions)
-          .setByteArrayPoolSize(byteArrayPoolSizeBytes)
+          .setArrayPoolSize(byteArrayPoolSizeBytes)
           .build();
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 1a6f5d9cd..54cf63722 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -19,7 +19,7 @@
   @Test
   public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
-    GlideExecutor executor = new GlideExecutor(1);
+    GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
       executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
         @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..af0dce220
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.load.engine.executor;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+public final class MockGlideExecutor {
+
+  private MockGlideExecutor() { }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
+
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
+        "mock-unlimited-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
new file mode 100644
index 000000000..b5d18a96a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.support.annotation.Nullable;
+import android.util.Base64;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Tests for the {@link DataUrlLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DataUrlLoaderTest {
+
+  // A valid base64-encoded PNG (a small "Google" logo).
+  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
+      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
+      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
+      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
+      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
+      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
+      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
+      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
+      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
+      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
+      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
+      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
+      + "AASUVORK5CYII=";
+
+  private static final String INVALID_URL_WRONG_SCHEME1 = "test";
+  private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
+  private static final String INVALID_URL_WRONG_SCHEME3 = "data:text";
+  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOTBASE64";
+  private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
+
+  @Mock
+  private MultiModelLoaderFactory multiFactory;
+  private DataUrlLoader<Object> dataUrlLoader;
+  private DataFetcher<Object> fetcher;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    options = new Options();
+    dataUrlLoader = (DataUrlLoader) factory.build(multiFactory);
+    fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
+
+  }
+
+  @Test
+  public void testHandleDataUri() {
+    assertTrue(dataUrlLoader.handles(VALID_PNG));
+  }
+
+  @Test
+  public void testHandleFalseDataUri() {
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME1));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME2));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME3));
+  }
+
+  @Test
+  public void testDecode() throws IOException {
+    byte[] expected = Base64
+        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
+    ((ByteArrayInputStream) callback.data).read(result);
+    assertTrue(Arrays.equals(result, expected));
+    assertNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeInvalidScheme() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeMissingComma() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeWrongEncoding() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  private class CallBack implements DataFetcher.DataCallback<Object> {
+
+    public Object data;
+    public Exception exception;
+
+    @Override
+    public void onDataReady(@Nullable Object data) {
+      this.data = data;
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) {
+      this.exception = e;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 8e0269c4e..3b65bc59a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -6,8 +6,12 @@
 
 import com.google.common.testing.EqualsTester;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -18,6 +22,22 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LazyHeadersTest {
+  private static final String DEFAULT_USER_AGENT = "default_user_agent";
+  private static final String DEFAULT_USER_AGENT_PROPERTY = "http.agent";
+  private String initialUserAgent;
+
+  @Before
+  public void setUp() {
+    initialUserAgent = System.getProperty(DEFAULT_USER_AGENT_PROPERTY);
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, DEFAULT_USER_AGENT);
+  }
+
+  @After
+  public void tearDown() {
+    if (initialUserAgent != null) {
+      System.setProperty(DEFAULT_USER_AGENT_PROPERTY, initialUserAgent);
+    }
+  }
 
   @Test
   public void testIncludesEagerHeaders() {
@@ -211,6 +231,55 @@ public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
     assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
   }
 
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
+    Builder builder = new Builder();
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "value";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("test", "value");
+  }
+
   @Test
   public void testEquals() {
     LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 3664fcce2..286d33e59 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
@@ -22,7 +20,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
@@ -48,10 +45,10 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     exceptionListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
-            multiModelLoaderFactory);
-    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
-    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
+        multiModelLoaderFactory);
+    when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
 
   @Test
@@ -299,7 +296,7 @@ public void testBuild_respectsPrependOrder() {
       boolean append) {
     ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
     ModelLoader<X, Y> loader = mock(ModelLoader.class);
-    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+    when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
     } else {
@@ -307,9 +304,5 @@ public void testBuild_respectsPrependOrder() {
     }
     return loader;
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index 492e029dc..4a914c316 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -44,7 +44,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     options = new Options();
 
-    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+    loader = new ResourceLoader<>(RuntimeEnvironment.application.getResources(), uriLoader);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 184012b38..b2ca67086 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -3,7 +3,7 @@
 import static org.junit.Assert.assertEquals;
 
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
 
 import org.junit.After;
@@ -26,7 +26,7 @@
 
   @Before
   public void setUp() {
-    encoder = new StreamEncoder(new LruByteArrayPool());
+    encoder = new StreamEncoder(new LruArrayPool());
     file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 47fcd5457..85b1dd864 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -2,11 +2,9 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -18,7 +16,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.io.File;
@@ -43,13 +40,13 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
-    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+    loader = new UriLoader<>(factory);
   }
 
   @Test
   public void testHandlesFileUris() throws IOException {
     Uri fileUri = Uri.fromFile(new File("f"));
-    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
     assertEquals(localUriFetcher,
@@ -59,7 +56,7 @@ public void testHandlesFileUris() throws IOException {
   @Test
   public void testHandlesResourceUris() throws IOException {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
     assertEquals(localUriFetcher,
@@ -69,14 +66,10 @@ public void testHandlesResourceUris() throws IOException {
   @Test
   public void testHandlesContentUris() {
     Uri contentUri = Uri.parse("content://com.bumptech.glide");
-    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
     assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
         options).fetcher);
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 60e3e3db7..0c3dc6762 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -21,16 +21,12 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
 
 import java.io.File;
 import java.io.IOException;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -137,21 +133,4 @@ public void tearDown() {
       file.delete();
     }
   }
-
-  @Implements(Bitmap.class)
-  public static class AlphaShadowBitmap extends ShadowBitmap {
-    private boolean hasAlpha;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
new file mode 100644
index 000000000..3121e7701
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -0,0 +1,118 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+public class CenterInsideTest {
+
+  @Mock Resource<Bitmap> resource;
+  @Mock Transformation<Bitmap> transformation;
+  private BitmapPool pool;
+  private CenterInside centerInside;
+  private int bitmapWidth;
+  private int bitmapHeight;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    pool = new BitmapPoolAdapter();
+
+    centerInside = new CenterInside(pool);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+            centerInside.transform(resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfSmallerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(resource, 150, 150);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsNewResourceIfLargerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(resource, 50, 50);
+
+    assertNotEquals(resource, result);
+  }
+
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    centerInside.transform(resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    centerInside.transform(resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(centerInside, new CenterInside(pool));
+
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(centerInside, transformation);
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 63bd65c10..6a629a101 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -90,18 +90,17 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
 
   @TargetApi(12)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
-    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    int minEdge = Math.min(width, height);
+    float radius = minEdge / 2f;
+
+    Bitmap result = Bitmap.createBitmap(minEdge, minEdge, Bitmap.Config.ARGB_8888);
     result.setHasAlpha(true);
     Canvas canvas = new Canvas(result);
     Paint paint = new Paint();
+    paint.setAntiAlias(true);
     paint.setColor(Color.RED);
 
-    int minEdge = Math.min(width, height);
-    float radius = minEdge / 2f;
-    int left = (width - minEdge) / 2;
-    int top = (height - minEdge) / 2;
-
-    canvas.drawCircle(left + radius, top + radius, radius, paint);
+    canvas.drawCircle(radius, radius, radius, paint);
     return result;
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
index f68d1e556..c6a624025 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -91,11 +91,11 @@ public void testAtLeast_withSourceGreaterInOneDimension_returnsScaleFactorOfSmal
 
   @Test
   public void testCenterInside_scalesImageToFitWithinRequestedBounds() {
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 200, 300, 300))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300))
         .isEqualTo(300 / 200f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(270, 480, 724, 440))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440))
         .isEqualTo(440 / 480f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index c88e3081a..5f9a022d1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -8,18 +8,22 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.os.Build;
 import android.util.DisplayMetrics;
 
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
+import com.bumptech.glide.tests.Util;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Matchers;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -39,9 +43,10 @@
 @Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
 public class DownsamplerTest {
   @Mock private BitmapPool bitmapPool;
-  @Mock private ByteArrayPool byteArrayPool;
+  @Mock private ArrayPool byteArrayPool;
   private Downsampler downsampler;
   private Options options;
+  private int initialSdkVersion;
 
   @Before
   public void setUp() throws Exception {
@@ -49,9 +54,16 @@ public void setUp() throws Exception {
     options = new Options();
     DisplayMetrics displayMetrics =
         RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt()))
-        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+    when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
+        .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
     downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
   }
 
   @Test
@@ -112,7 +124,7 @@ public void testCalculateScaling_withAtLeast() {
 
   @Test
   public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_INSIDE;
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
     runScaleTest(100, 100, 100, 100, strategy, 100, 100);
     runScaleTest(200, 200, 100, 100, strategy, 100, 100);
     runScaleTest(400, 400, 100, 100, strategy, 100, 100);
@@ -152,9 +164,34 @@ public void testCalculateScaling_withNone() {
     runScaleTest(87, 78, 100, 100, strategy, 87, 78);
   }
 
+  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
+  @Test
+  public void testCalculateScaling_withWbmp() {
+    Util.setSdkVersionInt(23);
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
+    BitmapFactory.Options options = new BitmapFactory.Options();
+
+    options.outMimeType = "image/vnd.wap.wbmp";
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
+    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
+  }
+
   private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
       int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
+    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
+        expectedHeight, new BitmapFactory.Options());
+  }
+
+  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
+      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
+      BitmapFactory.Options options) {
     Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
         options);
     assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
index 705246076..ff4c32ff4 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.testutil.TestResourceUtil;
 
@@ -28,11 +29,11 @@
       new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
           0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
 
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
@@ -95,6 +96,32 @@ public void run(ImageHeaderParser parser) throws IOException {
     });
   }
 
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType());
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType());
+      }
+    });
+  }
+
   @Test
   public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
     byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
@@ -160,11 +187,11 @@ public void testHandlesSometimesZeroSkips() throws IOException {
 
   private static void runTest(byte[] data, ParserTestCase test) throws IOException {
     InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruByteArrayPool());
+    ImageHeaderParser parser = new ImageHeaderParser(is, new LruArrayPool());
     test.run(parser);
 
     ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruByteArrayPool());
+    parser = new ImageHeaderParser(buffer, new LruArrayPool());
     test.run(parser);
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index c8edbaeac..f9b3e6452 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -7,7 +7,8 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -29,7 +30,7 @@
 
   private RecyclableBufferedInputStream stream;
   private byte[] data;
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   @Before
   public void setUp() {
@@ -38,7 +39,7 @@ public void setUp() {
       data[i] = (byte) i;
     }
 
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
     InputStream wrapped = new ByteArrayInputStream(data);
     stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index 24bd56cad..184c81df0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -445,8 +445,6 @@ public void testInitializeMatrixSetsRotateOnRotation() {
   @Implements(Bitmap.class)
   public static class AlphaShadowBitmap extends ShadowBitmap {
 
-    private boolean hasAlpha;
-
     @Implementation
     public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       // Robolectric doesn't match the framework behavior with null configs, so we have to do so
@@ -454,15 +452,5 @@ public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       Preconditions.checkNotNull("Config must not be null");
       return ShadowBitmap.createBitmap(width, height, config);
     }
-
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index f403e3080..257e50e75 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -14,7 +14,7 @@
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.tests.GlideShadowLooper;
 
 import org.junit.Before;
@@ -34,6 +34,7 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
@@ -58,8 +59,13 @@ public void setUp() {
         .thenReturn(gifDecoder);
 
     options = new Options();
-    decoder = new ByteBufferGifDecoder(RuntimeEnvironment.application, bitmapPool,
-        new LruByteArrayPool(), parserPool, decoderFactory);
+    decoder =
+        new ByteBufferGifDecoder(
+            RuntimeEnvironment.application,
+            bitmapPool,
+            new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
+            parserPool,
+            decoderFactory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index d838b7efa..add4df1e2 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -77,7 +77,7 @@ public void setUp() {
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -104,7 +104,7 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
   @Test
   public void testDoesDrawCurrentFrameIfOneIsAvailable() {
     Canvas canvas = mock(Canvas.class);
-    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    Bitmap currentFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
 
     drawable.draw(canvas);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 759a88013..1bc4f7992 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -18,7 +18,9 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
+import android.support.annotation.NonNull;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
@@ -32,6 +34,7 @@
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -71,8 +74,30 @@ public void setUp() {
 
     requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
 
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
-        requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(handler);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @NonNull
+  private GifFrameLoader createGifFrameLoader(Handler handler) {
+    Glide glide = getGlideSingleton();
+    return new GifFrameLoader(
+        glide.getContext(),
+        glide.getBitmapPool(),
+        requestManager,
+        gifDecoder,
+        handler,
+        requestBuilder,
+        transformation,
+        firstFrame);
+  }
+
+  private static Glide getGlideSingleton() {
+    return Glide.get(RuntimeEnvironment.application);
   }
 
   @SuppressWarnings("unchecked")
@@ -174,8 +199,7 @@ public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
   @Test
   public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -192,9 +216,8 @@ public void testOnFrameReadyClearsPreviousFrame() {
 
   @Test
   public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
-     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
-        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null.
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -229,9 +252,8 @@ public void testDelayTargetSetsResourceOnResourceReady() {
 
   @Test
   public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-    // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null;
+    loader = createGifFrameLoader(null);
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Request request = mock(Request.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index bd4efeda5..c87378fe9 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -4,7 +4,7 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -32,7 +32,7 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruByteArrayPool());
+    decoder = new StreamGifDecoder(byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 41fea2adc..0631bd73f 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -49,7 +49,7 @@ public void testUsesGivenFormat() {
   }
 
   @Test
-  public void testBitampResourceIsRecycled() {
+  public void testBitmapResourceIsRecycled() {
     harness.getTranscodedDescription();
 
     verify(harness.bitmapResource).recycle();
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
index 2219e7720..d3d024977 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -26,7 +26,7 @@ public void testReturnsUnitDecoderIfClassesAreIdentical() {
   }
 
   @Test
-  public void testCanRegisterAndRetreiveResouceTranscoder() {
+  public void testCanRegisterAndRetrieveResourceTranscoder() {
     ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
     factories.register(File.class, String.class, transcoder);
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
rename to library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index d1a14b0a1..e78445533 100644
--- a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -13,12 +13,12 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-public class ConnectivityMonitorFactoryTest {
+public class DefaultConnectivityMonitorFactoryTest {
   private ConnectivityMonitorFactory factory;
 
   @Before
   public void setUp() {
-    factory = new ConnectivityMonitorFactory();
+    factory = new DefaultConnectivityMonitorFactory();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 2110a1613..3ee515868 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -65,7 +65,7 @@ public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturn
   }
 
   @Test
-  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
     tracker.clearRemoveAndRecycle(request);
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
index 16b4f1d4a..dad0d87eb 100644
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.request;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
+
+import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.Transformation;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -16,20 +20,122 @@
 public class BaseRequestOptionsTest {
 
   private TestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     options = new TestOptions();
   }
 
   @Test
-  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
     TestOptions other = new TestOptions();
-    other.transform(Object.class, mock(Transformation.class));
+    other.transform(Bitmap.class, transformation);
     options.apply(other);
     assertThat(options.isTransformationSet()).isTrue();
   }
 
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(RuntimeEnvironment.application, transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    TestOptions other = new TestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    TestOptions other = new TestOptions();
+    other.transform(RuntimeEnvironment.application, transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
   private static class TestOptions extends BaseRequestOptions<TestOptions> {
     // Empty.
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index fb73a052b..6a8ef0884 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -207,6 +207,14 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
     future.get();
   }
 
+  @Test
+  public void testGetSucceedsOnMainThreadIfDone()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.onResourceReady(new Object(), null);
+    future.get();
+  }
+
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 43af5105f..e9ae5049f 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -75,6 +75,7 @@
     GlideContext glideContext = mock(GlideContext.class);
     Key signature = mock(Key.class);
     Priority priority = Priority.HIGH;
+    boolean useUnlimitedSourceGeneratorsPool = false;
 
     Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
 
@@ -91,7 +92,8 @@ public RequestHarness() {
         .fallback(fallbackDrawable)
         .override(overrideWidth, overrideHeight)
         .priority(priority)
-        .signature(signature);
+        .signature(signature)
+        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest
           .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
               priority, target, requestListener, requestCoordinator, engine, factory);
@@ -275,7 +277,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -294,7 +296,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -538,7 +540,7 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -652,7 +654,7 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -674,7 +676,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -703,7 +705,42 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = true;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = false;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), any(ResourceCallback.class));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 8a13ace4b..da94c9799 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -26,7 +26,6 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
     .UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
-
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
   private int viewId;
@@ -43,7 +42,7 @@ public void setUp() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -55,7 +54,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName()
   public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -68,7 +67,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -80,7 +79,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -91,39 +90,39 @@ public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithWidgetIds() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithComponentName() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId, 1
-    /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId,
-        mock(ComponentName.class));
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (int[]) null /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsWhenGivenEmptyWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (ComponentName) null);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);
   }
 
   @Implements(AppWidgetManager.class)
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index 1a0dfc8d1..38d60fe05 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -26,12 +26,12 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
     .UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
-
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
   private int viewId;
   private Notification notification;
   private int notificationId;
+  private String notificationTag;
   private NotificationTarget target;
 
   @Before
@@ -44,11 +44,12 @@ public void setUp() {
     viewId = 123;
     notification = mock(Notification.class);
     notificationId = 456;
+    notificationTag = "tag";
 
 
     target =
-        new NotificationTarget(RuntimeEnvironment.application, remoteViews, viewId, 100 /*width*/,
-            100 /*height*/, notification, notificationId);
+        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+            viewId, remoteViews, notification, notificationId, notificationTag);
   }
 
   @Test
@@ -64,36 +65,41 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
     /*glideAnimation*/);
 
     assertEquals(notificationId, shadowManager.updatedNotificationId);
+    assertEquals(notificationTag, shadowManager.updatedNotificationTag);
     assertEquals(notification, shadowManager.updatedNotification);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, mock(RemoteViews.class), 123 /*viewId*/,
-        100 /*width*/, 100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, null /*remoteViews*/, 123 /*viewId*/,
-        100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Implements(NotificationManager.class)
   public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
     int updatedNotificationId;
+    String updatedNotificationTag;
     Notification updatedNotification;
 
     @Implementation
-    public void notify(int notificationId, Notification notification) {
+    public void notify(String notificationTag, int notificationId, Notification notification) {
+      updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
       updatedNotification = notification;
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 3debccfcd..8e59457ff 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -35,7 +35,6 @@
 import org.robolectric.internal.ShadowExtractor;
 import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
 
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
@@ -393,8 +392,19 @@ public void testThrowsIfGivenNullView() {
     new TestViewTarget(null);
   }
 
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    view.setLayoutParams(new LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
+  public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index b6fa33ac8..62dd94c0d 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -24,7 +24,8 @@
   @Before
   public void setUp() {
     ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/,
+        false /*isCrosFadeEnabled*/);
   }
 
   @Test
@@ -40,7 +41,7 @@ public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource()
   }
 
   @Test
-  public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
+  public void testReturnsAnimationIfNotFromMemoryCacheAndNotIsFirstResource() {
     assertNotEquals(NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 78861713d..35dc2eba1 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -73,7 +73,7 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
     Transition<Drawable> defaultAnimation = mock(Transition.class);
     int duration = 200;
     DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration);
+        new DrawableCrossFadeTransition(defaultAnimation, duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 2d92de3d4..79f8e961c 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 
@@ -20,7 +21,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifTest {
 
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   private InputStream open(String imageName) throws IOException {
     return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
@@ -47,7 +48,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
@@ -73,11 +74,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
deleted file mode 100644
index 463d17cca..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class StringSignatureTest {
-
-  @Test
-  public void testStringSignatureIsNotEqualIfStringDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("first");
-    StringSignature second = new StringSignature("second");
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testStringSignatureIsEqualIfStringIsTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("signature");
-    StringSignature second = new StringSignature("signature");
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
index aa6adc361..61e476548 100644
--- a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -6,26 +6,31 @@
 
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowContentResolver;
 
+import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
 
 @Implements(ContentResolver.class)
-public class ContentResolverShadow extends ShadowContentResolver {
-  private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+public class ContentResolverShadow {
+  private final Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+  private final Map<Uri, InputStream> inputStreamMap = new HashMap<>();
 
   public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
     fileDescriptorMap.put(uri, fileDescriptor);
   }
 
+  public void registerInputStream(Uri uri, InputStream inputStream) {
+    inputStreamMap.put(uri, inputStream);
+  }
+
+  @Implementation
+  public InputStream openInputStream(Uri uri) {
+    return inputStreamMap.get(uri);
+  }
+
   @Implementation
   public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
-    AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
-    if (fileDescriptor != null) {
-      return fileDescriptor;
-    } else {
-      return null;
-    }
+    return fileDescriptorMap.get(uri);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index 366f7d425..ab333bec8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -24,6 +24,7 @@
 import java.io.OutputStream;
 import java.security.MessageDigest;
 
+// FIXME move to testutil module
 public class Util {
 
   public static String getExpectedClassId(Class clazz) {
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
new file mode 100644
index 000000000..4eb221597
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ByteBufferUtilTest {
+  private static final int BUFFER_SIZE = 16384;
+
+  @Test
+  public void testFromStream_small() throws IOException {
+    testFromStream(4);
+  }
+
+  @Test
+  public void testFromStream_empty() throws IOException {
+    testFromStream(0);
+  }
+
+  @Test
+  public void testFromStream_bufferAndAHalf() throws IOException {
+    testFromStream(BUFFER_SIZE + BUFFER_SIZE / 2);
+  }
+
+  @Test
+  public void testFromStream_massive() throws IOException {
+    testFromStream(12 * BUFFER_SIZE + 12345);
+  }
+
+  /**
+   * All tests are basically the same thing but with different amounts of data.
+   */
+  private void testFromStream(int dataLength) throws IOException {
+    byte[] bytes = createByteData(dataLength);
+    InputStream byteStream = new ByteArrayInputStream(bytes);
+    ByteBuffer byteBuffer = ByteBufferUtil.fromStream(byteStream);
+    assertByteBufferContents(byteBuffer, bytes);
+    byteStream.close();
+  }
+
+  private byte[] createByteData(int size) {
+    byte[] bytes = new byte[size];
+
+    // Put some arbitrary bytes in there.
+    for (int i = 0; i < size; i++) {
+      bytes[i] = (byte) (i % 4);
+    }
+
+    return bytes;
+  }
+
+  private void assertByteBufferContents(ByteBuffer buffer, byte[] expectedBytes) {
+    assertEquals(expectedBytes.length, buffer.limit());
+    for (int i = 0; i < expectedBytes.length; i++) {
+      assertEquals(expectedBytes[i], buffer.get(i));
+    }
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 708f68e3a..1060dce0a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -29,8 +27,7 @@
     private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
 
     @Override
-    public ModelLoader<Photo, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
           modelCache);
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index de9b10705..7bbcb4d81 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -31,7 +31,7 @@
 import java.util.List;
 
 /**
- * A fragment that shows square image thumbnails whose size is determined by the framgent's
+ * A fragment that shows square image thumbnails whose size is determined by the fragment's
  * arguments in a grid pattern.
  */
 public class FlickrPhotoGrid extends Fragment implements PhotoViewer {
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 8a924d58a..163c9d220 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -354,7 +354,7 @@ public void run() {
         FutureTarget<File> futureTarget = Glide.with(context)
             .downloadOnly()
             .load(photo)
-            .into(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 36cb19ab6..42570507e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -91,6 +91,7 @@ public String toString() {
     return getPartialUrl();
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
index b3442f26b..2858df855 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -2,7 +2,7 @@
 
 import android.os.Parcel;
 
-/** Query wusing flickr's recent API. */
+/** Query using Flickr's recent API. */
 public final class RecentQuery implements Query {
   public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
     @Override
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 8346d8778..30b337cf4 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -29,5 +29,5 @@ android {
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
-    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.gallery/.MainActivity'
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 3d27c6fe7..5e76ef724 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.giphy;
 
-import android.content.Context;
 import android.text.TextUtils;
 
 import com.bumptech.glide.load.Options;
@@ -31,8 +30,7 @@ public boolean handles(Api.GifResult model) {
 
 
     @Override
-    public ModelLoader<Api.GifResult, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 973afa473..58a4e9f06 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,7 +1,8 @@
 apply plugin: 'com.android.application'
 
-repositories {
-    mavenCentral()
+dependencies {
+    compile project(':library')
+    compile 'com.caverock:androidsvg:1.2.1'
 }
 
 android {
@@ -23,11 +24,6 @@ android {
     }
 }
 
-dependencies {
-    compile project(':library')
-    compile 'com.caverock:androidsvg:1.2.1'
-}
-
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
     commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity'
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index ec5af0341..a27f1999b 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,6 +15,10 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
+ * Local test with (..._REPOSITORY_URL properties must be full paths):
+ * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
+ * For faster runs add: -x check
+ * 
  */
 
 apply plugin: 'maven'
@@ -29,20 +33,20 @@ def isReleaseBuild() {
 
 def getReleaseRepositoryUrl() {
     return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+            : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
     return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-            : "https://oss.sonatype.org/content/repositories/snapshots/"
+            : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
 def getRepositoryUsername() {
-    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME')?NEXUS_USERNAME:"")
+    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : '')
 }
 
 def getRepositoryPassword() {
-    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD')?NEXUS_PASSWORD:"")
+    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : '')
 }
 
 afterEvaluate { project ->
@@ -51,6 +55,11 @@ afterEvaluate { project ->
     uploadArchives {
         repositories {
             mavenDeployer {
+                // allow uploading through FTP protocol with the following command:
+                // gradle uploadArchives -PSNAPSHOT_REPOSITORY_URL=ftp://host/repo/path -PUSERNAME=uname -PPASSWORD=passwd
+                configuration = configurations.create('deployerJars')
+                configuration.dependencies.add dependencies.create('org.apache.maven.wagon:wagon-ftp:2.2')
+
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
                 pom.groupId = GROUP
@@ -78,14 +87,14 @@ afterEvaluate { project ->
 
                     licenses {
                         license {
-                            name = "Simplified BSD License"
-                            url = "http://www.opensource.org/licenses/bsd-license"
-                            distribution = "repo"
+                            name = 'Simplified BSD License'
+                            url = 'http://www.opensource.org/licenses/bsd-license'
+                            distribution = 'repo'
                         }
                         license {
-                            name = "The Apache Software License, Version 2.0"
-                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
-                            distribution = "repo"
+                            name = 'The Apache Software License, Version 2.0'
+                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                            distribution = 'repo'
                         }
                     }
 
@@ -102,16 +111,16 @@ afterEvaluate { project ->
     }
 
     signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }
         sign configurations.archives
     }
 
-    if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-        def releaseVariants = project.android.libraryVariants.findAll { variant ->
-            variant.buildType.name.equalsIgnoreCase("release")
-        }
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
-        def androidSdkDirectory = project.android.sdkDirectory
+    if (isAndroidProject) {
+        def releaseVariants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('release')
+        }
 
         task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJava) {
             source = releaseVariants.collect { it.javaCompile.source }
@@ -119,8 +128,8 @@ afterEvaluate { project ->
                     project.android.bootClasspath) })
 
             options {
-                links("http://docs.oracle.com/javase/7/docs/api/")
-                linksOffline("http://d.android.com/reference", "${androidSdkDirectory}/docs/reference")
+                links('http://docs.oracle.com/javase/7/docs/api/')
+                linksOffline('http://d.android.com/reference', "${android.sdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
@@ -128,24 +137,45 @@ afterEvaluate { project ->
         }
 
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+            classifier = 'javadoc'
             from androidJavadocs.destinationDir
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
         task androidSourcesJar(type: Jar) {
+            classifier = 'sources'
             from project.android.sourceSets.main.java.source
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
-    }
 
-    artifacts {
-        if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-            archives androidSourcesJar {
-                classifier "sources"
-            }
-            archives androidJavadocsJar {
-                classifier "javadoc"
-            }
+        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJava /* == variant.javaCompile */) {
+            from compileReleaseJava.destinationDir
+            exclude '**/R.class'
+            exclude '**/BuildConfig.class'
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
+        }
+
+        artifacts {
+            archives androidLibraryJar
+            archives androidSourcesJar
+            archives androidJavadocsJar
+        }
+    } else if (project.plugins.hasPlugin('java')) {
+        task sourcesJar(type: Jar, dependsOn: classes) {
+            classifier = 'sources'
+            from sourceSets.main.allSource
+        }
+
+        task javadocsJar(type: Jar, dependsOn: javadoc) {
+            classifier = 'javadoc'
+            from javadoc.destinationDir
+        }
+
+        artifacts {
+            archives sourcesJar
+            archives javadocsJar
         }
     }
+    logger.info("Published artifacts in ${configurations.archives}:")
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
 }
diff --git a/settings.gradle b/settings.gradle
index 6f0fe1a45..5239ec3ec 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -12,6 +12,7 @@ include ':samples:gallery'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':integration:okhttp3'
 include ':integration:gifencoder'
 include ':integration:recyclerview'
 include ':testutil'
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 847e0dad0..743de2592 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e
+Subproject commit 743de259274020cdef3de809b8537c0775043c8a
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index e0904012a..bd5aa45e0 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -2,13 +2,13 @@ apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
 dependencies {
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
 
     testCompile project(':testutil')
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
@@ -21,3 +21,5 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
new file mode 100644
index 000000000..75215b58f
--- /dev/null
+++ b/third_party/gif_decoder/gradle.properties
@@ -0,0 +1,10 @@
+POM_NAME=Glide Gif Decoder Library
+POM_ARTIFACT_ID=gifdecoder
+POM_PACKAGING=aar
+
+VERSION_NAME=1.0.0-SNAPSHOT
+VERSION_MAJOR=1
+VERSION_MINOR=0
+VERSION_PATCH=0
+
+POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index b23984a94..9fe113b01 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,60 +1,15 @@
 package com.bumptech.glide.gifdecoder;
 
-/**
- * Copyright (c) 2013 Xcellent Creations, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.util.Log;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames for animation
- * purposes.  Image data can be read from either and InputStream source or a byte[].
- *
- * This class is optimized for running animations with the frames, there are no methods to get
- * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
- * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
- * in the animation sequence.
- *
- * The animation must be manually moved forward using {@link #advance()} before requesting the next
- * frame.  This method must also be called before you request the first frame or an error will
- * occur.
- *
- * Implementation adapted from sample code published in Lyons. (2004). <em>Java for
- * Programmers</em>, republished under the MIT Open Source License
+ * Shared interface for GIF decoders.
  */
-public class GifDecoder {
-  private static final String TAG = GifDecoder.class.getSimpleName();
+public interface GifDecoder {
 
   /**
    * File read status: No errors.
@@ -72,70 +27,6 @@
    * Unable to fully decode the current frame.
    */
   public static final int STATUS_PARTIAL_DECODE = 3;
-  /**
-   * max decoder pixel stack size.
-   */
-  private static final int MAX_STACK_SIZE = 4096;
-
-  /**
-   * GIF Disposal Method meaning take no action.
-   */
-  private static final int DISPOSAL_UNSPECIFIED = 0;
-  /**
-   * GIF Disposal Method meaning leave canvas from previous frame.
-   */
-  private static final int DISPOSAL_NONE = 1;
-  /**
-   * GIF Disposal Method meaning clear canvas to background color.
-   */
-  private static final int DISPOSAL_BACKGROUND = 2;
-  /**
-   * GIF Disposal Method meaning clear canvas to frame before last.
-   */
-  private static final int DISPOSAL_PREVIOUS = 3;
-
-  private static final int NULL_CODE = -1;
-
-  private static final int INITIAL_FRAME_POINTER = -1;
-
-  private static final int BYTES_PER_INTEGER = 4;
-
-  // Global File Header values and parsing flags.
-  // Active color table.
-  private int[] act;
-
-  // Raw GIF data from input source.
-  private ByteBuffer rawData;
-
-  // Raw data read working array.
-  private byte[] block;
-
-  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
-  // to greatly reduce JNI overhead.
-  private static final int WORK_BUFFER_SIZE = 16384;
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
-  private GifHeaderParser parser;
-
-  // LZW decoder working arrays.
-  private short[] prefix;
-  private byte[] suffix;
-  private byte[] pixelStack;
-  private byte[] mainPixels;
-  private int[] mainScratch;
-
-  private int framePointer;
-  private GifHeader header;
-  private BitmapProvider bitmapProvider;
-  private Bitmap previousImage;
-  private boolean savePrevious;
-  private int status;
-  private int sampleSize;
-  private int downsampledHeight;
-  private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
 
   /**
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
@@ -170,34 +61,24 @@
      */
     void release(byte[] bytes);
 
-  }
-
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
-    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
-  }
-
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
-      int sampleSize) {
-    this(provider);
-    setData(gifHeader, rawData, sampleSize);
-  }
+    /**
+     * Returns an int array used for decoding/generating the frame bitmaps.
+     * @param size
+     */
+    int[] obtainIntArray(int size);
 
-  public GifDecoder(BitmapProvider provider) {
-    this.bitmapProvider = provider;
-    header = new GifHeader();
+    /**
+     * Release the given array back to the pool.
+     * @param array
+     */
+    void release(int[] array);
   }
 
-  public int getWidth() {
-    return header.width;
-  }
+  int getWidth();
 
-  public int getHeight() {
-    return header.height;
-  }
+  int getHeight();
 
-  public ByteBuffer getData() {
-    return rawData;
-  }
+  ByteBuffer getData();
 
   /**
    * Returns the current status of the decoder.
@@ -206,16 +87,12 @@ public ByteBuffer getData() {
    * was decoded successfully and/or completely. Format and open failures persist across frames.
    * </p>
    */
-  public int getStatus() {
-    return status;
-  }
+  int getStatus();
 
   /**
    * Move the animation frame counter forward.
    */
-  public void advance() {
-    framePointer = (framePointer + 1) % header.frameCount;
-  }
+  void advance();
 
   /**
    * Gets display duration for specified frame.
@@ -223,134 +100,52 @@ public void advance() {
    * @param n int index of frame.
    * @return delay in milliseconds.
    */
-  public int getDelay(int n) {
-    int delay = -1;
-    if ((n >= 0) && (n < header.frameCount)) {
-      delay = header.frames.get(n).delay;
-    }
-    return delay;
-  }
+  int getDelay(int n);
 
   /**
    * Gets display duration for the upcoming frame in ms.
    */
-  public int getNextDelay() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      return 0;
-    }
-
-    return getDelay(framePointer);
-  }
+  int getNextDelay();
 
   /**
    * Gets the number of frames read from file.
    *
    * @return frame count.
    */
-  public int getFrameCount() {
-    return header.frameCount;
-  }
+  int getFrameCount();
 
   /**
    * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
    *
    * @return frame index.
    */
-  public int getCurrentFrameIndex() {
-    return framePointer;
-  }
+  int getCurrentFrameIndex();
 
   /**
    * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
    * decode any frames.
    */
-  public void resetFrameIndex() {
-    framePointer = INITIAL_FRAME_POINTER;
-  }
+  void resetFrameIndex();
 
   /**
    * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
    *
    * @return iteration count if one was specified, else 1.
    */
-  public int getLoopCount() {
-    return header.loopCount;
-  }
+  int getLoopCount();
 
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
    */
-  public int getByteSize() {
-    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
-  }
+  int getByteSize();
 
   /**
    * Get the next frame in the animation sequence.
    *
    * @return Bitmap representation of frame.
    */
-  public synchronized Bitmap getNextFrame() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
-            + framePointer);
-      }
-      status = STATUS_FORMAT_ERROR;
-    }
-    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to decode frame, status=" + status);
-      }
-      return null;
-    }
-    status = STATUS_OK;
-
-    GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
-    int previousIndex = framePointer - 1;
-    if (previousIndex >= 0) {
-      previousFrame = header.frames.get(previousIndex);
-    }
-
-    final int savedBgColor = header.bgColor;
-
-    // Set the appropriate color table.
-    if (currentFrame.lct == null) {
-      act = header.gct;
-    } else {
-      act = currentFrame.lct;
-      if (header.bgIndex == currentFrame.transIndex) {
-        header.bgColor = 0;
-      }
-    }
-
-    int save = 0;
-    if (currentFrame.transparency) {
-      save = act[currentFrame.transIndex];
-      // Set transparent color if specified.
-      act[currentFrame.transIndex] = 0;
-    }
-    if (act == null) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "No Valid Color Table");
-      }
-      // No color table defined.
-      status = STATUS_FORMAT_ERROR;
-      return null;
-    }
-
-    // Transfer pixel data to image.
-    Bitmap result = setPixels(currentFrame, previousFrame);
-
-    // Reset the transparent pixel in the color table
-    if (currentFrame.transparency) {
-      act[currentFrame.transIndex] = save;
-    }
-    header.bgColor = savedBgColor;
-
-    return result;
-  }
+  Bitmap getNextFrame();
 
   /**
    * Reads GIF image from stream.
@@ -358,103 +153,15 @@ public synchronized Bitmap getNextFrame() {
    * @param is containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public int read(InputStream is, int contentLength) {
-    if (is != null) {
-      try {
-        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-        int nRead;
-        byte[] data = new byte[16384];
-        while ((nRead = is.read(data, 0, data.length)) != -1) {
-          buffer.write(data, 0, nRead);
-        }
-        buffer.flush();
+  int read(InputStream is, int contentLength);
 
-        read(buffer.toByteArray());
-      } catch (IOException e) {
-        Log.w(TAG, "Error reading data from stream", e);
-      }
-    } else {
-      status = STATUS_OPEN_ERROR;
-    }
+  void clear();
 
-    try {
-      if (is != null) {
-        is.close();
-      }
-    } catch (IOException e) {
-      Log.w(TAG, "Error closing stream", e);
-    }
+  void setData(GifHeader header, byte[] data);
 
-    return status;
-  }
+  void setData(GifHeader header, ByteBuffer buffer);
 
-  public void clear() {
-    header = null;
-    mainPixels = null;
-    mainScratch = null;
-    if (previousImage != null) {
-      bitmapProvider.release(previousImage);
-    }
-    previousImage = null;
-    rawData = null;
-    isFirstFrameTransparent = false;
-    if (block != null) {
-      bitmapProvider.release(block);
-    }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
-  }
-
-  public synchronized void setData(GifHeader header, byte[] data) {
-    setData(header, ByteBuffer.wrap(data));
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
-    setData(header, buffer, 1);
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
-    if (sampleSize <= 0) {
-      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
-    }
-    // Make sure sample size is a power of 2.
-    sampleSize = Integer.highestOneBit(sampleSize);
-    this.status = STATUS_OK;
-    this.header = header;
-    isFirstFrameTransparent = false;
-    framePointer = INITIAL_FRAME_POINTER;
-    // Initialize the raw data buffer.
-    rawData = buffer.asReadOnlyBuffer();
-    rawData.position(0);
-    rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-    // No point in specially saving an old frame if we're never going to use it.
-    savePrevious = false;
-    for (GifFrame frame : header.frames) {
-      if (frame.dispose == DISPOSAL_PREVIOUS) {
-        savePrevious = true;
-        break;
-      }
-    }
-
-    this.sampleSize = sampleSize;
-    // Now that we know the size, init scratch arrays.
-    // TODO: Find a way to avoid this entirely or at least downsample it
-    // (either should be possible).
-    mainPixels = new byte[header.width * header.height];
-    mainScratch = new int[(header.width / sampleSize) * (header.height / sampleSize)];
-    downsampledWidth = header.width / sampleSize;
-    downsampledHeight = header.height / sampleSize;
-  }
-
-  private GifHeaderParser getHeaderParser() {
-    if (parser == null) {
-      parser = new GifHeaderParser();
-    }
-    return parser;
-  }
+  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -462,380 +169,6 @@ private GifHeaderParser getHeaderParser() {
    * @param data containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public synchronized int read(byte[] data) {
-    this.header = getHeaderParser().setData(data).parseHeader();
-    if (data != null) {
-      setData(header, data);
-    }
-
-    return status;
-  }
-
-  /**
-   * Creates new frame image from current data (and previous frames as specified by their
-   * disposition codes).
-   */
-  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-    // Final location of blended pixels.
-    final int[] dest = mainScratch;
-
-    // fill in starting image contents based on last image's dispose code
-    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
-      // mainScratch and therefore so will our dest array.
-      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-        // Start with a canvas filled with the background color
-        int c = 0;
-        if (!currentFrame.transparency) {
-          c = header.bgColor;
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
-        }
-        Arrays.fill(dest, c);
-      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-        // Start with the previous frame
-        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-            downsampledHeight);
-      }
-    }
-
-    // Decode pixels for this frame  into the global pixels[] scratch.
-    decodeBitmapData(currentFrame);
-
-    int downsampledIH = currentFrame.ih / sampleSize;
-    int downsampledIY = currentFrame.iy / sampleSize;
-    int downsampledIW = currentFrame.iw / sampleSize;
-    int downsampledIX = currentFrame.ix / sampleSize;
-    // Copy each source line to the appropriate place in the destination.
-    int pass = 1;
-    int inc = 8;
-    int iline = 0;
-    boolean isFirstFrame = framePointer == 0;
-    for (int i = 0; i < downsampledIH; i++) {
-      int line = i;
-      if (currentFrame.interlace) {
-        if (iline >= downsampledIH) {
-          pass++;
-          switch (pass) {
-            case 2:
-              iline = 4;
-              break;
-            case 3:
-              iline = 2;
-              inc = 4;
-              break;
-            case 4:
-              iline = 1;
-              inc = 2;
-              break;
-            default:
-              break;
-          }
-        }
-        line = iline;
-        iline += inc;
-      }
-      line += downsampledIY;
-      if (line < downsampledHeight) {
-        int k = line * downsampledWidth;
-        // Start of line in dest.
-        int dx = k + downsampledIX;
-        // End of dest line.
-        int dlim = dx + downsampledIW;
-        if (k + downsampledWidth < dlim) {
-          // Past dest edge.
-          dlim = k + downsampledWidth;
-        }
-        // Start of line in source.
-        int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
-          if (averageColor != 0) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
-        }
-      }
-    }
-
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
-    }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
-  }
-
-  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
-      int currentFrameIw) {
-    int alphaSum = 0;
-    int redSum = 0;
-    int greenSum = 0;
-    int blueSum = 0;
-
-    int totalAdded = 0;
-    // Find the pixels in the current row.
-    for (int i = positionInMainPixels;
-        i < positionInMainPixels + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    // Find the pixels in the next row.
-    for (int i = positionInMainPixels + currentFrameIw;
-        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    if (totalAdded == 0) {
-      return 0;
-    } else {
-      return ((alphaSum / totalAdded) << 24)
-          | ((redSum / totalAdded) << 16)
-          | ((greenSum / totalAdded) << 8)
-          | (blueSum / totalAdded);
-     }
-  }
-
-  /**
-   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-   */
-  private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
-    if (frame != null) {
-      // Jump to the frame start position.
-      rawData.position(frame.bufferFrameStart);
-    }
-
-    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
-        i, datum,
-        dataSize, first, top, bi, pi;
-
-    if (mainPixels == null || mainPixels.length < npix) {
-      // Allocate new pixel array.
-      mainPixels = new byte[npix];
-    }
-    if (prefix == null) {
-      prefix = new short[MAX_STACK_SIZE];
-    }
-    if (suffix == null) {
-      suffix = new byte[MAX_STACK_SIZE];
-    }
-    if (pixelStack == null) {
-      pixelStack = new byte[MAX_STACK_SIZE + 1];
-    }
-
-    // Initialize GIF data stream decoder.
-    dataSize = readByte();
-    clear = 1 << dataSize;
-    endOfInformation = clear + 1;
-    available = clear + 2;
-    oldCode = NULL_CODE;
-    codeSize = dataSize + 1;
-    codeMask = (1 << codeSize) - 1;
-    for (code = 0; code < clear; code++) {
-      // XXX ArrayIndexOutOfBoundsException.
-      prefix[code] = 0;
-      suffix[code] = (byte) code;
-    }
-
-    // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
-        // Read a new data block.
-        count = readBlock();
-        if (count <= 0) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-        bi = 0;
-      }
-
-      datum += (((int) block[bi]) & 0xff) << bits;
-      bits += 8;
-      bi++;
-      count--;
-
-      while (bits >= codeSize) {
-        // Get the next code.
-        code = datum & codeMask;
-        datum >>= codeSize;
-        bits -= codeSize;
-
-        // Interpret the code.
-        if (code == clear) {
-          // Reset decoder.
-          codeSize = dataSize + 1;
-          codeMask = (1 << codeSize) - 1;
-          available = clear + 2;
-          oldCode = NULL_CODE;
-          continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
-          oldCode = code;
-          first = code;
-          continue;
-        }
-        inCode = code;
-        if (code >= available) {
-          pixelStack[top++] = (byte) first;
-          code = oldCode;
-        }
-        while (code >= clear) {
-          pixelStack[top++] = suffix[code];
-          code = prefix[code];
-        }
-        first = ((int) suffix[code]) & 0xff;
-        pixelStack[top++] = (byte) first;
-
-        // Add a new string to the string table.
-        if (available < MAX_STACK_SIZE) {
-          prefix[available] = (short) oldCode;
-          suffix[available] = (byte) first;
-          available++;
-          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
-            codeMask += available;
-          }
-        }
-        oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
-      }
-    }
-
-    // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = 0;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
-  }
-
-  /**
-   * Reads a single byte from the input stream.
-   */
-  private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & 0xFF;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
-  }
-
-  /**
-   * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer".
-   */
-  private int readBlock() {
-    int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
-    }
-    return blockSize;
-  }
+  int read(byte[] data);
 
-  private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    setAlpha(result);
-    return result;
-  }
-
-  @TargetApi(12)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= 12) {
-      bitmap.setHasAlpha(true);
-    }
-  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 2036b6cab..3a0a16bb7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -17,7 +17,7 @@
   public static final String TAG = "GifHeaderParser";
 
   // The minimum frame delay in hundredths of a second.
-  static final int MIN_FRAME_DELAY = 3;
+  static final int MIN_FRAME_DELAY = 2;
   // The default frame delay in hundredths of a second for GIFs with frame delays less than the
   // minimum.
   static final int DEFAULT_FRAME_DELAY = 10;
@@ -79,13 +79,32 @@ public GifHeader parseHeader() {
     return header;
   }
 
+  /**
+   * Determines if the GIF is animated by trying to read in the first 2 frames
+   * This method reparses the data even if the header has already been read.
+   */
+  public boolean isAnimated() {
+    readHeader();
+    if (!err()) {
+      readContents(2 /* maxFrames */);
+    }
+    return header.frameCount > 1;
+  }
+
   /**
    * Main file parser. Reads GIF content blocks.
    */
   private void readContents() {
+    readContents(Integer.MAX_VALUE /* maxFrames */);
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames
+   */
+  private void readContents(int maxFrames) {
     // Read GIF file content blocks.
     boolean done = false;
-    while (!(done || err())) {
+    while (!(done || err() || header.frameCount > maxFrames)) {
       int code = read();
       switch (code) {
         // Image separator.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
new file mode 100644
index 000000000..ba7c1d660
--- /dev/null
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -0,0 +1,762 @@
+package com.bumptech.glide.gifdecoder;
+
+/**
+ * Copyright (c) 2013 Xcellent Creations, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
+ *
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
+ *
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
+ *
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
+ */
+public class StandardGifDecoder implements GifDecoder {
+  private static final String TAG = StandardGifDecoder.class.getSimpleName();
+
+  /**
+   * max decoder pixel stack size.
+   */
+  private static final int MAX_STACK_SIZE = 4096;
+
+  /**
+   * GIF Disposal Method meaning take no action.
+   */
+  private static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   */
+  private static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   */
+  private static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   */
+  private static final int DISPOSAL_PREVIOUS = 3;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = 4;
+
+  // Global File Header values and parsing flags.
+  // Active color table.
+  private int[] act;
+
+  // Raw GIF data from input source.
+  private ByteBuffer rawData;
+
+  // Raw data read working array.
+  private byte[] block;
+
+  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
+  // to greatly reduce JNI overhead.
+  private static final int WORK_BUFFER_SIZE = 16384;
+  @Nullable private byte[] workBuffer;
+  private int workBufferSize = 0;
+  private int workBufferPosition = 0;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private GifDecoder.BitmapProvider bitmapProvider;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  private boolean isFirstFrameTransparent;
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  @Override
+  public int getWidth() {
+    return header.width;
+  }
+
+  @Override
+  public int getHeight() {
+    return header.height;
+  }
+
+  @Override
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  @Override
+  public int getStatus() {
+    return status;
+  }
+
+  @Override
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  @Override
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  @Override
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
+
+    return getDelay(framePointer);
+  }
+
+  @Override
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  @Override
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  @Override
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  @Override
+  public int getLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  @Override
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
+            + framePointer);
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame = null;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    }
+
+    final int savedBgColor = header.bgColor;
+
+    // Set the appropriate color table.
+    if (currentFrame.lct == null) {
+      act = header.gct;
+    } else {
+      act = currentFrame.lct;
+      if (header.bgIndex == currentFrame.transIndex) {
+        header.bgColor = 0;
+      }
+    }
+
+    int save = 0;
+    if (currentFrame.transparency) {
+      save = act[currentFrame.transIndex];
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = 0;
+    }
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No Valid Color Table");
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
+
+    // Transfer pixel data to image.
+    Bitmap result = setPixels(currentFrame, previousFrame);
+
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      act[currentFrame.transIndex] = save;
+    }
+    header.bgColor = savedBgColor;
+
+    return result;
+  }
+
+  @Override
+  public int read(InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16384];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
+    }
+
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
+    }
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = false;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+    if (workBuffer != null) {
+      bitmapProvider.release(workBuffer);
+    }
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
+    }
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    isFirstFrameTransparent = false;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
+    }
+
+    this.sampleSize = sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO: Find a way to avoid this entirely or at least downsample it
+    // (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch =
+        bitmapProvider.obtainIntArray((header.width / sampleSize) * (header.height / sampleSize));
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+  }
+
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
+    }
+    return parser;
+  }
+
+  @Override
+  public synchronized int read(byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
+    }
+
+    return status;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // clear all pixels when meet first frame
+    if (previousFrame == null) {
+      Arrays.fill(dest, 0);
+    }
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        int c = 0;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
+        }
+        Arrays.fill(dest, c);
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
+
+    // Decode pixels for this frame into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
+        }
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
+        }
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+        while (dx < dlim) {
+          // Map color and insert in destination.
+          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+          if (averageColor != 0) {
+            dest[dx] = averageColor;
+          } else if (!isFirstFrameTransparent && isFirstFrame) {
+            isFirstFrameTransparent = true;
+          }
+          sx += sampleSize;
+          dx++;
+        }
+      }
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+        i < positionInMainPixels + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return 0;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+     }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    workBufferSize = 0;
+    workBufferPosition = 0;
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
+    }
+
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum,
+        dataSize, first, top, bi, pi;
+
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
+    }
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
+    }
+
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
+    }
+
+    // Decode GIF pixel stream.
+    datum = bits = count = first = top = pi = bi = 0;
+    for (i = 0; i < npix; ) {
+      // Load bytes until there are enough bits for a code.
+      if (count == 0) {
+        // Read a new data block.
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & 0xff) << bits;
+      bits += 8;
+      bi++;
+      count--;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
+        }
+
+        if (code > available) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+
+        if (code == endOfInformation) {
+          break;
+        }
+
+        if (oldCode == NULL_CODE) {
+          pixelStack[top++] = suffix[code];
+          oldCode = code;
+          first = code;
+          continue;
+        }
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top++] = (byte) first;
+          code = oldCode;
+        }
+        while (code >= clear) {
+          pixelStack[top++] = suffix[code];
+          code = prefix[code];
+        }
+        first = ((int) suffix[code]) & 0xff;
+        pixelStack[top++] = (byte) first;
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          available++;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            codeSize++;
+            codeMask += available;
+          }
+        }
+        oldCode = inCode;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi++] = pixelStack[--top];
+          i++;
+        }
+      }
+    }
+
+    // Clear missing pixels.
+    for (i = pi; i < npix; i++) {
+      mainPixels[i] = 0;
+    }
+  }
+
+  /**
+   * Reads the next chunk for the intermediate work buffer.
+   */
+  private void readChunkIfNeeded() {
+    if (workBufferSize > workBufferPosition) {
+      return;
+    }
+    if (workBuffer == null) {
+      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
+    }
+    workBufferPosition = 0;
+    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
+    rawData.get(workBuffer, 0, workBufferSize);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    try {
+      readChunkIfNeeded();
+      return workBuffer[workBufferPosition++] & 0xFF;
+    } catch (Exception e) {
+      status = STATUS_FORMAT_ERROR;
+      return 0;
+    }
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize > 0) {
+      try {
+        if (block == null) {
+          block = bitmapProvider.obtainByteArray(255);
+        }
+        final int remaining = workBufferSize - workBufferPosition;
+        if (remaining >= blockSize) {
+          // Block can be read from the current work buffer.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
+          workBufferPosition += blockSize;
+        } else if (rawData.remaining() + remaining >= blockSize) {
+          // Block can be read in two passes.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
+          workBufferPosition = workBufferSize;
+          readChunkIfNeeded();
+          final int secondHalfRemaining = blockSize - remaining;
+          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
+          workBufferPosition += secondHalfRemaining;
+        } else {
+          status = STATUS_FORMAT_ERROR;
+        }
+      } catch (Exception e) {
+        Log.w(TAG, "Error Reading Block", e);
+        status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    setAlpha(result);
+    return result;
+  }
+
+  @TargetApi(12)
+  private static void setAlpha(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= 12) {
+      bitmap.setHasAlpha(true);
+    }
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 9566e4c32..82b0c7d43 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -2,6 +2,8 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
@@ -14,8 +16,12 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
 
 import java.io.IOException;
+import java.util.Arrays;
 
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
@@ -37,7 +43,7 @@ public void testCanDecodeFramesFromTestGif() throws IOException {
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap bitmap = decoder.getNextFrame();
@@ -50,7 +56,7 @@ public void testFrameIndexStartsAtNegativeOne() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
@@ -60,7 +66,7 @@ public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     assertEquals(0, decoder.getCurrentFrameIndex());
@@ -71,7 +77,7 @@ public void testAdvanceWrapsIndexBackToZero() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 2;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -84,7 +90,7 @@ public void testSettingDataResetsFramePointer() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -94,6 +100,65 @@ public void testSettingDataResetsFramePointer() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  /**
+   * Preserve generated bitmap data for checking.
+   */
+  @Implements(Bitmap.class)
+  public static class CustomShadowBitmap extends ShadowBitmap {
+
+    private int[] pixels;
+
+    @Implementation
+    public void setPixels(int[] pixels, int offset, int stride,
+        int x, int y, int width, int height) {
+      this.pixels = new int[pixels.length];
+      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
+    }
+
+    public int[] getPixels() {
+      return pixels;
+    }
+  }
+
   private static class MockProvider implements GifDecoder.BitmapProvider {
 
     @NonNull
@@ -119,5 +184,15 @@ public void release(byte[] bytes) {
       // Do nothing.
     }
 
+    @Override
+    public int[] obtainIntArray(int size) {
+      return new int[size];
+    }
+
+    @Override
+    public void release(int[] array) {
+      // Do Nothing
+    }
+
   }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index fa14b3870..22f2e5c78 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
 import com.bumptech.glide.testutil.TestUtil;
@@ -214,6 +215,49 @@ public void testCanParseMultipleFrames() {
     assertEquals(expectedFrames, header.frames.size());
   }
 
+  @Test
+  public void testIsAnimatedMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int numFrames = 3;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < numFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    assertTrue(parser.isAnimated());
+  }
+
+  @Test
+  public void testIsNotAnimatedOneFrame() {
+    final int lzwMinCodeSize = 2;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    assertFalse(parser.isAnimated());
+  }
+
+
   @Test(expected = IllegalStateException.class)
   public void testThrowsIfParseHeaderCalledBeforeSetData() {
     GifHeaderParser parser = new GifHeaderParser();
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif
new file mode 100644
index 000000000..3c64b1d65
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif
new file mode 100644
index 000000000..158e329ba
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif differ
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index aa1123f67..e08a214f7 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -22,6 +22,7 @@
  *     e.setDelay(1000);   // 1 frame per sec
  *     e.addFrame(image1);
  *     e.addFrame(image2);
+ *     e.addFrame(image3, 100, 100);    // set position of the frame
  *     e.finish();
  * </pre>
  *
@@ -38,13 +39,18 @@
 public class AnimatedGifEncoder {
     private static final String TAG = "AnimatedGifEncoder";
 
-    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index
+    // automatically.
     private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
     private int width; // image size
 
     private int height;
 
+    private int fixedWidth;   // set by setSize()
+
+    private int fixedHeight;
+
     private Integer transparent = null; // transparent color if given
 
     private int transIndex; // transparent index in color table
@@ -140,22 +146,46 @@ public void setTransparent(int color) {
      * Adds next GIF frame. The frame is not written immediately, but is actually
      * deferred until the next frame is received so that timing data can be
      * inserted. Invoking <code>finish()</code> flushes all frames. If
-     * <code>setSize</code> was not invoked, the size of the first image is used
-     * for all subsequent frames.
+     * <code>setSize</code> was invoked, the size is used for all subsequent frames.
+     * Otherwise, the actual size of the image is used for each frames.
      *
      * @param im
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
     public boolean addFrame(Bitmap im) {
+        return addFrame(im, 0, 0);
+    }
+
+    /**
+     * Adds next GIF frame to the specified position. The frame is not written immediately, but is
+     * actually deferred until the next frame is received so that timing data can be inserted.
+     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the
+     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for
+     * each frame.
+     *
+     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame
+     *
+     * @param im
+     *          BufferedImage containing frame to write.
+     * @param x
+     *          Column number, in pixels, of the left edge of the image, with respect to the left
+     *          edge of the Logical Screen.
+     * @param y
+     *          Row number, in pixels, of the top edge of the image with respect to the top edge of
+     *          the Logical Screen.
+     * @return true if successful.
+     */
+    public boolean addFrame(Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
         boolean ok = true;
         try {
-            if (!sizeSet) {
-                // use first frame's size
-                setSize(im.getWidth(), im.getHeight());
+            if (sizeSet) {
+                setFrameSize(fixedWidth, fixedHeight);
+            } else {
+                setFrameSize(im.getWidth(), im.getHeight());
             }
             image = im;
             getImagePixels(); // convert to correct format if necessary
@@ -169,7 +199,7 @@ public boolean addFrame(Bitmap im) {
                 }
             }
             writeGraphicCtrlExt(); // write graphic control extension
-            writeImageDesc(); // image descriptor
+            writeImageDesc(x, y); // image descriptor
             if (!firstFrame) {
                 writePalette(); // local color table
             }
@@ -243,8 +273,8 @@ public void setQuality(int quality) {
     }
 
     /**
-     * Sets the GIF frame size. The default size is the size of the first frame
-     * added if this method is not invoked.
+     * Sets the fixed GIF frame size for all the frames.
+     * This should be called before start.
      *
      * @param w
      *          int frame width.
@@ -252,15 +282,33 @@ public void setQuality(int quality) {
      *          int frame width.
      */
     public void setSize(int w, int h) {
-        if (started && !firstFrame)
+        if (started) {
             return;
+        }
+
+        fixedWidth = w;
+        fixedHeight = h;
+        if (fixedWidth < 1) {
+            fixedWidth = 320;
+        }
+        if (fixedHeight < 1) {
+            fixedHeight = 240;
+        }
+
+        sizeSet = true;
+    }
+
+    /**
+     * Sets current GIF frame size.
+     *
+     * @param w
+     *          int frame width.
+     * @param h
+     *          int frame width.
+     */
+    private void setFrameSize(int w, int h) {
         width = w;
         height = h;
-        if (width < 1)
-            width = 320;
-        if (height < 1)
-            height = 240;
-        sizeSet = true;
     }
 
     /**
@@ -400,11 +448,12 @@ private void getImagePixels() {
         }
 
         double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
-        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
-        // See issue #214.
+        // Assume images with greater where more than n% of the pixels are transparent actually have
+        // transparency. See issue #214.
         hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage
+                + "% transparent pixels");
         }
     }
 
@@ -442,10 +491,10 @@ private void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    private void writeImageDesc() throws IOException {
+    private void writeImageDesc(int x, int y) throws IOException {
         out.write(0x2c); // image separator
-        writeShort(0); // image position x,y = 0,0
-        writeShort(0);
+        writeShort(x); // image position
+        writeShort(y);
         writeShort(width); // image size
         writeShort(height);
         // packed fields
diff --git a/third_party/gradle.properties b/third_party/gradle.properties
new file mode 100644
index 000000000..d01cfd2be
--- /dev/null
+++ b/third_party/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-thirdparty
