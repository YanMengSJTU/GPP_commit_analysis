diff --git a/.gitignore b/.gitignore
index dbfe9eb43..6a64b1779 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,4 +39,4 @@ docs/**/*
 **/.idea/dataSources.ids
 **/.idea/datasources.xml
 **/.idea/uiDesigner.xml
-
+**/.idea/runConfigurations.xml
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index 536c52938..fe060621a 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -291,6 +291,34 @@
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
+        <Objective-C-extensions>
+          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
+          <option name="RELEASE_STYLE" value="IVAR" />
+          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
+          <file>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+          </file>
+          <class>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+          </class>
+          <extensions>
+            <pair source="cpp" header="h" />
+            <pair source="c" header="h" />
+          </extensions>
+        </Objective-C-extensions>
         <XML>
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
@@ -321,6 +349,6 @@
         </codeStyleSettings>
       </value>
     </option>
-    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
   </component>
 </project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index d9b0b7959..e3dc14645 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,8 +3,8 @@ android:
   components:
   - tools
   - platform-tools
-  - build-tools-22.0.1
-  - android-22
+  - build-tools-25.0.2
+  - android-25
   - extra-android-m2repository
   - extra-android-support
 
@@ -12,18 +12,19 @@ android:
   - 'android-sdk-license.*'
 
 jdk:
-  - openjdk7
-  - oraclejdk7
+  - oraclejdk8
 
 sudo: false
 
-script: 'travis_retry ./gradlew build --parallel'
+script: 'travis_retry ./gradlew build'
 
 after_success:
 - scripts/travis-sonatype-publish.sh
 - ./gradlew jacocoTestReport coveralls
 
+before_cache:
+  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
 cache:
   directories:
-    - $HOME/.gradle
-
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 5fc10cb16..d3fc25937 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,26 +1,48 @@
 # Contributing
-Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other
-aspects of the library (documentation, the wiki etc.)
+Contributions of all types are welcome.
+We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.).
+
 
 ## Asking Questions
-The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on
-freenode.org.][3]
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3].
+
 
 ## Filing issues
-To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more
-information you can provide, the more likely we are to be able help.
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed.
+Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue.
+
+To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
+The more information you can provide, the more likely we are to be able help.
 
-When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if
-you support a particular feature request, feel free to let us know by commenting on the issue.
 
 ## Contributing code
-Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find
-instructions on building the project in our README. Our code style is defined in Intellij project files in the repo
-and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel
-free to put up your pull request anyway and we can help you fix the style issues. If you'd like to
-contribute code, you will need to sign [Google's individual contributor license agreement][4].
+Pull requests are welcome for all parts of the codebase, especially the integration libraries.
+You can find instructions on building the project in [README.md][5].
+Our code style is defined in Intellij project files in the repo and also by our Checkstyle config.
+If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues.
+If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it.
+
+## Labels
+Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:
+
+ * **bug**: feature that should work, but doesn't
+ * **enhancement**: minor tweak/addition to existing behavior
+ * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide
+ * **question**: no need to modify Glide to fix the issue, usually a usage problem
+ * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo
+ * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do
+ * **duplicate**: there's another issue which already covers/tracks this
+ * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons
+ * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide
+ * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases
+ * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use)
+
+*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*
+
 
-[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [2]: https://groups.google.com/forum/#!forum/glidelibrary
 [3]: http://webchat.freenode.net/?channels=glide-library
-[4]: https://developers.google.com/open-source/cla/individual.
+[4]: https://developers.google.com/open-source/cla/individual
+[5]: https://github.com/bumptech/glide
+[6]: https://help.github.com/articles/subscribing-to-conversations/
diff --git a/ISSUE_TEMPLATE.md b/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..f76cfa70d
--- /dev/null
+++ b/ISSUE_TEMPLATE.md
@@ -0,0 +1,50 @@
+<!--
+Please fill in the below fields with some data to help us best diagnose the issue.
+The more specific you are, the better! You can help a lot by not making us ask these questions.
+Feel free to remove any irrelevant parts that you know are not related to the issue.
+Any HTML comment like this will be stripped when rendering markdown, no need to delete them.
+-->
+
+
+<!-- What version of Glide you're running, for example: 3.7.1 | 3.8.0-SNAPSHOT | 4.0.0-SNAPSHOT
+It's essentially the version number from your build.gradle: `dependencies { compile '...:x.y.z' }` -->
+**Glide Version**:
+
+<!-- Do you use any integration library, like OkHttp3 or Volley? For example:
+Fails to display with stock networking, but works with okhttp3-1.4.0 -->
+**Integration libraries**:
+
+<!-- What devices you managed to get the issue to come up on? For example:
+fails on Galaxy S4/GT-I9500 4.4.2, works fine on Nexus 6P 5.1 and Genymotion Nexus 5 5.0.1 -->
+**Device/Android Version**:
+
+<!-- Share the details of your issue in prose, detailing actual and expected behavior. It also helps if you give some info **why** you are trying to do something as opposed to **what** is not working. -->
+**Issue details / Repro steps / Use case background**: 
+
+<!-- How do you use Glide?
+Make sure you include everything as is in your app's code:
+Changing a single method parameter can yield totally different results.
+Please clarify any magic variables that appear in the code, for example: "// `this` is a Fragment"
+-->
+**Glide load line / `GlideModule` (if any) / list Adapter code (if any)**:
+```java
+Glide.with...
+```
+
+<!-- How does your app look like?
+We're most interested in the layout attributes and the hierarchy around the ImageView -->
+**Layout XML**:
+```xml
+<FrameLayout xmlns:android="...
+```
+
+<!--
+What is the error message that you got in the log?
+You can find some help on diagnosing issues here: https://github.com/bumptech/glide/wiki/Debugging-and-Error-Handling
+-->
+**Stack trace / LogCat**:
+```ruby
+paste stack trace and/or log here
+```
+
+<!-- Bonus points if you attach a relevant screenshot, screen recording or a small demo project -->
diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
new file mode 100644
index 000000000..3cd191bf1
--- /dev/null
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -0,0 +1,14 @@
+<!-- Make sure you've run `gradlew clean check jar assemble` before commit. -->
+<!-- Don't forget that you can always force push to your private branches to make changes. -->
+<!-- Please make sure there are no weird commits in the change set by rebasing to latest upstream. -->
+<!-- Please squash typo/checkstyle/review fix commits into the base commit. -->
+
+## Description
+<!-- Please describe the changes you made on a high level. -->
+<!-- Make sure you reference the GitHub issue here if this change is related to one. -->
+
+## Motivation and Context
+<!-- Why is this change required? What problem does it solve? -->
+<!-- If it's fixing a bug reference it or provide repro steps. -->
+
+<!-- If you have any issues feel free to create the PR anyway, we'll help to resolve them. -->
\ No newline at end of file
diff --git a/README.md b/README.md
index 34bbbf0b3..495fd8877 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,16 @@
 Glide
 =====
 
-[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide) [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
 
 ![](static/glide_logo.png)
 
-Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api
-that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based
+Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API
+that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based
 stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.
 
 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is
@@ -21,14 +22,15 @@ You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
-```groovy
+```gradle
 repositories {
-  mavenCentral()
+  mavenCentral() // jcenter() works as well because it pulls from Maven Central
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.6.0'
-    compile 'com.android.support:support-v4:19.1.0'
+  compile 'com.github.bumptech.glide:glide:4.0.0-RC0'
+  compile 'com.android.support:support-v4:25.3.1'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.0.0-RC0'
 }
 ```
 
@@ -38,131 +40,135 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.6.0</version>
-  <type>aar</type>
+  <version>4.0.0-RC0</version>
 </dependency>
 <dependency>
   <groupId>com.google.android</groupId>
   <artifactId>support-v4</artifactId>
   <version>r7</version>
 </dependency>
+<dependency>
+  <groupdId>com.github.bumptech.glide</groupId>
+  <artifactId>compiler</artifactId>
+  <version>4.0.0-RC0</version>
+  <optional>true</optional>
+</dependency>
 ```
 
-Proguard
+For info on using the bleeding edge, see the [Snapshots][17] wiki page.
+
+ProGuard
 --------
-Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
-```
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):
+
+```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
+  **[] $VALUES;
+  public *;
 }
+
+# for DexGuard only
+-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
 ```
 
 How do I use Glide?
 -------------------
-Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
+Checkout the [documentation][20] for pages on a variety of topics, and see the [javadocs][3].
 
-Simple use cases will look something like this:
+For Glide v3, see the [wiki][2].
 
-```Java
+Simple use cases with Glide's [generated API][21] will look something like this:
 
+```java
 // For a simple view:
-@Override
-public void onCreate(Bundle savedInstanceState) {
-    ...
+@Override public void onCreate(Bundle savedInstanceState) {
+  ...
+  ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-    ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
-
-    Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  GlideApp.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
-// For a list:
-@Override
-public View getView(int position, View recycled, ViewGroup container) {
-    final ImageView myImageView;
-    if (recycled == null) {
-        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view,
-                container, false);
-    } else {
-        myImageView = (ImageView) recycled;
-    }
-
-    String url = myUrls.get(position);
-
-    Glide.with(myFragment)
-        .load(url)
-        .centerCrop()
-        .placeholder(R.drawable.loading_spinner)
-        .crossFade()
-        .into(myImageView);
-
-    return myImageView;
+// For a simple image list:
+@Override public View getView(int position, View recycled, ViewGroup container) {
+  final ImageView myImageView;
+  if (recycled == null) {
+    myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
+  } else {
+    myImageView = (ImageView) recycled;
+  }
+
+  String url = myUrls.get(position);
+
+  GlideApp
+    .with(myFragment)
+    .load(url)
+    .centerCrop()
+    .placeholder(R.drawable.loading_spinner)
+    .into(myImageView);
+
+  return myImageView;
 }
-
 ```
 
-OkHttp and Volley
------------------
-Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies. The
-integration libraries are available via Maven or the [releases page][1].
-
-For instructions on including either the OkHttp or the Volley integration libraries, see the
-[Integration Libraries][12] wiki page.
+Status
+------
+[*Version 3* on the `3.0` branch][14] is a stable public release used in multiple open source projects at Google including in the Android Camera
+app and in the 2014 Google IO app. *Version 4* is currently under development on the `master` branch.
 
-Android SDK Version
--------------------
-Glide requires a minimum sdk version of 10.
+Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues.
 
-License
--------
-BSD, part MIT and Apache 2.0. See LICENSE file for details.
+Compatibility
+-------------
 
-Status
-------
-Version 3 is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+ * **Android SDK**: Glide requires a minimum API level of 10.
+ * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
+ * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
+ * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
+ * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
+ * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
 Build
-------
+-----
 Building Glide with gradle is fairly straight forward:
 
-```
-git clone git@github.com:bumptech/glide.git
+```shell
+git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
 cd glide
 git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+**Note**: Make sure your *Android SDK* has the *Android Support Repository* installed, and that your `$ANDROID_HOME` environment
 variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
-Follow the steps in the 'Build' section to setup the project and then:
+Follow the steps in the [Build](#build) section to setup the project and then:
 
-```
+```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
 ```
+You may also find precompiled APKs on the [releases page][1].
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
+Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
 [Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in Intellij 14:
+To open the project in IntelliJ IDEA:
 
-1. Go to File.
-2. Click on 'Open...'
+1. Go to *File* menu or the *Welcome Screen*
+2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select glide-parent.iml
+4. Select `build.gradle`
 
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6], or join our irc channel: [irc.freenode.net#glide-library][13].
+anything else, email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
@@ -170,15 +176,19 @@ Before submitting pull requests, contributors must sign Google's [individual con
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push][10] script.
-* Corey Hall for Glide's [amazing logo][11].
+* The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
+* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on.
+* **Chris Banes** for his [gradle-mvn-push][10] script.
+* **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
 ------
-Sam Judd - @samajudd
+Sam Judd - @sjudd on GitHub, @samajudd on Twitter
+
+License
+-------
+BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details.
 
 Disclaimer
 ---------
@@ -186,9 +196,9 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/javadocs/latest/index.html
+[3]: http://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
-[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
 [7]: https://developers.google.com/open-source/cla/individual
 [8]: https://github.com/JakeWharton/DiskLruCache
@@ -197,3 +207,11 @@ This is not an official Google product.
 [11]: static/glide_logo.png
 [12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
 [13]: http://webchat.freenode.net/?channels=glide-library
+[14]: https://github.com/bumptech/glide/tree/3.0
+[15]: https://github.com/bumptech/glide/tree/master
+[16]: https://github.com/bumptech/glide/blob/master/LICENSE
+[17]: https://github.com/bumptech/glide/wiki/Snapshots
+[18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
+[19]: https://github.com/wasabeef/glide-transformations
+[20]: http://bumptech.github.io/glide/
+[21]: http://bumptech.github.io/glide/doc/generatedapi.html
diff --git a/annotation/.gitignore b/annotation/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/build.gradle b/annotation/build.gradle
new file mode 100644
index 000000000..d6a7f76df
--- /dev/null
+++ b/annotation/build.gradle
@@ -0,0 +1,3 @@
+apply plugin: 'java'
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
\ No newline at end of file
diff --git a/annotation/compiler/.gitignore b/annotation/compiler/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
new file mode 100644
index 000000000..0b51f2584
--- /dev/null
+++ b/annotation/compiler/build.gradle
@@ -0,0 +1,17 @@
+import org.gradle.internal.jvm.Jvm
+
+apply plugin: 'java'
+
+dependencies {
+    compile 'com.squareup:javapoet:1.8.0'
+    compile 'com.google.auto.service:auto-service:1.0-rc3'
+    compile 'com.google.code.findbugs:jsr305:3.0.1'
+    compile project(':annotation')
+    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    compile files(Jvm.current().getToolsJar())
+
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile 'com.google.testing.compile:compile-testing:0.10'
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/gradle.properties b/annotation/compiler/gradle.properties
new file mode 100644
index 000000000..1f7f8a7a7
--- /dev/null
+++ b/annotation/compiler/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotation processor
+POM_ARTIFACT_ID=compiler
+POM_PACKAGING=jar
+POM_DESCRIPTION=Glide's anntation processor. Should be included in all Applications and in all libraries that use Glide's modules for configuration.
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
new file mode 100644
index 000000000..6e45b850a
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -0,0 +1,230 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeSpec.Builder;
+import com.squareup.javapoet.WildcardTypeName;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules
+ * and the original AppGlideModule.
+ *
+ * <p>The generated class will always call the AppGlideModule last to give it priority over choices
+ * made or classes registered in LibraryGlideModules.
+ *
+ * <p>Android logging is included to allow developers to see exactly which modules are included at
+ * runtime.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
+ *    private final com.bumptech.glide.samples.giphy.GiphyGlideModule appGlideModule;
+ *
+ *    GeneratedAppGlideModule() {
+ *      appGlideModule = new com.bumptech.glide.samples.giphy.GiphyGlideModule();
+ *      if (android.util.Log.isLoggable("Glide", android.util.Log.DEBUG)) {
+ *        android.util.Log.d("Glide", "Discovered AppGlideModule from annotation:"
+ *            + " com.bumptech.glide.samples.giphy.GiphyGlideModule");
+ *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:"
+ *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");
+ *      }
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void applyOptions(android.content.Context context,
+ *        com.bumptech.glide.GlideBuilder builder) {
+ *      appGlideModule.applyOptions(context, builder);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void registerComponents(android.content.Context context,
+ *        com.bumptech.glide.Registry registry) {
+ *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule()
+ *          .registerComponents(context, registry);
+ *      appGlideModule.registerComponents(context, registry);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public boolean isManifestParsingEnabled() {
+ *      return appGlideModule.isManifestParsingEnabled();
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *      return appGlideModule.getExcludedModuleClasses();
+ *    }
+ *  }
+ * </code>
+ * </pre>
+ */
+final class AppModuleGenerator {
+  static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String GLIDE_LOG_TAG = "Glide";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
+      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+  private final ProcessorUtil processorUtil;
+
+  AppModuleGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
+    ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
+    Set<String> excludedGlideModuleClassNames =
+        getExcludedGlideModuleClassNames(appGlideModule);
+
+    MethodSpec constructor =
+        generateConstructor(
+            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec registerComponents =
+        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec getExcludedModuleClasses =
+        generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
+
+    MethodSpec applyOptions =
+        MethodSpec.methodBuilder("applyOptions")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
+            .build();
+
+    MethodSpec isManifestParsingEnabled =
+        MethodSpec.methodBuilder("isManifestParsingEnabled")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .returns(boolean.class)
+            .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
+            .build();
+
+    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build()
+        )
+        .superclass(
+            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+        .addMethod(constructor)
+        .addMethod(applyOptions)
+        .addMethod(registerComponents)
+        .addMethod(isManifestParsingEnabled)
+        .addMethod(getExcludedModuleClasses);
+
+    ClassName generatedRequestManagerFactoryClassName =
+        ClassName.get(
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME,
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME);
+
+    builder.addMethod(
+        MethodSpec.methodBuilder("getRequestManagerFactory")
+            .addAnnotation(Override.class)
+            .returns(generatedRequestManagerFactoryClassName)
+            .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
+            .build());
+    return builder.build();
+  }
+
+  // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
+  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+    TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName classOfWildcardOfObjet =
+        ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
+    ParameterizedTypeName setOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
+    ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .returns(setOfClassOfWildcardOfObject);
+
+    if (excludedClassNames.isEmpty()) {
+      builder.addStatement("return $T.emptySet()", Collections.class);
+    } else {
+      builder.addStatement(
+          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          hashSetOfClassOfWildcardOfObject);
+      for (String excludedClassName : excludedClassNames) {
+        // TODO: Remove this when we no longer support manifest parsing.
+        // Using a Literal ($L) instead of a type ($T) to get a fully qualified import that allows
+        // us to suppress deprecation warnings. Aimed at deprecated GlideModules.
+        builder.addStatement("excludedClasses.add($L.class)", excludedClassName);
+      }
+      builder.addStatement("return excludedClasses");
+    }
+
+    return builder.build();
+  }
+
+  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
+      Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder registerComponents =
+        MethodSpec.methodBuilder("registerComponents")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+
+    for (String glideModule : libraryGlideModuleClassNames) {
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        continue;
+      }
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      registerComponents.addStatement(
+          "new $T().registerComponents(context, registry)", moduleClassName);
+    }
+    // Order matters here. The AppGlideModule must be called last.
+    registerComponents.addStatement("appGlideModule.registerComponents(context, registry)");
+    return registerComponents.build();
+  }
+
+  private MethodSpec generateConstructor(ClassName appGlideModule,
+      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
+    constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+
+    ClassName androidLogName = ClassName.get("android.util", "Log");
+
+    // Add some log lines to indicate to developers which modules where discovered.
+    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
+        androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        "Discovered AppGlideModule from annotation: " + appGlideModule);
+    // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
+    for (String glideModule : libraryGlideModuleClassNames) {
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+      } else {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+      }
+    }
+    constructorBuilder.endControlFlow();
+    return constructorBuilder.build();
+  }
+
+  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+        appGlideModule, Excludes.class);
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
new file mode 100644
index 000000000..17f64f327
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -0,0 +1,177 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Runs the final steps of Glide's annotation process and generates the combined
+ * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
+ * {@link com.bumptech.glide.RequestManager}, and
+ * {@link com.bumptech.glide.request.RequestOptions} classes.
+ */
+final class AppModuleProcessor {
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final List<TypeElement> appGlideModules = new ArrayList<>();
+  private final RequestOptionsGenerator requestOptionsGenerator;
+  private final RequestManagerGenerator requestManagerGenerator;
+  private final AppModuleGenerator appModuleGenerator;
+  private final RequestBuilderGenerator requestBuilderGenerator;
+  private final RequestManagerFactoryGenerator requestManagerFactoryGenerator;
+  private final GlideGenerator glideGenerator;
+
+  AppModuleProcessor(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    appModuleGenerator = new AppModuleGenerator(processorUtil);
+    requestOptionsGenerator = new RequestOptionsGenerator(processingEnv, processorUtil);
+    requestManagerGenerator = new RequestManagerGenerator(processingEnv, processorUtil);
+    requestManagerFactoryGenerator = new RequestManagerFactoryGenerator(processingEnv);
+    glideGenerator = new GlideGenerator(processingEnv, processorUtil);
+    requestBuilderGenerator = new RequestBuilderGenerator(processingEnv, processorUtil);
+  }
+
+  void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+       if (processorUtil.isAppGlideModule(element)) {
+         appGlideModules.add(element);
+       }
+     }
+
+    processorUtil.debugLog("got app modules: " + appGlideModules);
+
+    if (appGlideModules.size() > 1) {
+      throw new IllegalStateException(
+          "You cannot have more than one AppGlideModule, found: " + appGlideModules);
+    }
+  }
+
+  boolean maybeWriteAppModule() {
+    // appGlideModules is added to in order to catch errors where multiple AppGlideModules may be
+    // present for a single application or library. Because we only add to appGlideModules, we use
+    // isGeneratedAppGlideModuleWritten to make sure the GeneratedAppGlideModule is written at
+    // most once.
+    if (appGlideModules.isEmpty()) {
+      return false;
+    }
+    TypeElement appModule = appGlideModules.get(0);
+    processorUtil.debugLog("Processing app module: " + appModule);
+    // If this package is null, it means there are no classes with this package name. One way this
+    // could happen is if we process an annotation and reach this point without writing something
+    // to the package. We do not error check here because that shouldn't happen with the
+    // current implementation.
+    PackageElement glideGenPackage =
+        processingEnv.getElementUtils().getPackageElement(COMPILER_PACKAGE_NAME);
+    FoundIndexedClassNames indexedClassNames = getIndexedClassNames(glideGenPackage);
+
+    // Write all generated code to the package containing the AppGlideModule. Doing so fixes
+    // classpath collisions if more than one Application containing a AppGlideModule is included
+    // in a project.
+    String generatedCodePackageName = appModule.getEnclosingElement().toString();
+
+    TypeSpec generatedRequestOptions =
+          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+
+    TypeSpec generatedRequestBuilder =
+        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+    writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
+
+    TypeSpec requestManager =
+        requestManagerGenerator.generate(
+            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            indexedClassNames.extensions);
+    writeRequestManager(generatedCodePackageName, requestManager);
+
+    TypeSpec requestManagerFactory =
+        requestManagerFactoryGenerator.generate(generatedCodePackageName, requestManager);
+    writeRequestManagerFactory(requestManagerFactory);
+
+    TypeSpec glide =
+        glideGenerator.generate(generatedCodePackageName, getGlideName(appModule), requestManager);
+    writeGlide(generatedCodePackageName, glide);
+
+    TypeSpec generatedAppGlideModule =
+        appModuleGenerator.generate(appModule, indexedClassNames.glideModules);
+    writeAppModule(generatedAppGlideModule);
+
+    processorUtil.infoLog("Wrote GeneratedAppGlideModule with: " + indexedClassNames.glideModules);
+
+    return true;
+  }
+
+  private String getGlideName(TypeElement appModule) {
+    return appModule.getAnnotation(GlideModule.class).glideName();
+  }
+
+  @SuppressWarnings("unchecked")
+  private FoundIndexedClassNames getIndexedClassNames(PackageElement glideGenPackage) {
+    Set<String> glideModules = new HashSet<>();
+    Set<String> extensions = new HashSet<>();
+    List<? extends Element> glideGeneratedElements = glideGenPackage.getEnclosedElements();
+    for (Element indexer : glideGeneratedElements) {
+      Index annotation = indexer.getAnnotation(Index.class);
+      // If the annotation is null, it means we've come across another class in the same package
+      // that we can safely ignore.
+      if (annotation != null) {
+        Collections.addAll(glideModules, annotation.modules());
+        Collections.addAll(extensions, annotation.extensions());
+      }
+    }
+
+    processorUtil.debugLog("Found GlideModules: " + glideModules);
+    return new FoundIndexedClassNames(glideModules, extensions);
+  }
+
+  private void writeGlide(String packageName, TypeSpec glide) {
+    processorUtil.writeClass(packageName, glide);
+  }
+
+  private void writeRequestManager(String packageName, TypeSpec requestManager) {
+    processorUtil.writeClass(packageName, requestManager);
+  }
+
+  // We dont' care about collisions in IDEs since this class isn't an API class.
+  private void writeRequestManagerFactory(TypeSpec requestManagerFactory) {
+    processorUtil.writeClass(
+        AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, requestManagerFactory);
+  }
+
+  // The app module we generate subclasses a package private class. We don't care about classpath
+  // collisions in IDEs since this class isn't an API class.
+  private void writeAppModule(TypeSpec appModule) {
+    processorUtil.writeClass(AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, appModule);
+  }
+
+  private void writeRequestOptions(String packageName, TypeSpec requestOptions) {
+    processorUtil.writeClass(packageName, requestOptions);
+  }
+
+  private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
+    processorUtil.writeClass(packageName, requestBuilder);
+  }
+
+  private static final class FoundIndexedClassNames {
+    final Set<String> glideModules;
+    final Set<String> extensions;
+
+    private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
+      this.glideModules = glideModules;
+      this.extensions = extensions;
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
new file mode 100644
index 000000000..4d6ac80c8
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Writes Indexer classes annotated with {@link Index} for all
+ * classes found annotated with {@link GlideExtension}.
+ */
+final class ExtensionProcessor {
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
+
+  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+    List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
+    processorUtil.debugLog("Processing types : " + elements);
+    for (TypeElement typeElement : elements) {
+      GlideExtensionValidator.validateExtension(typeElement);
+      processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
+    }
+
+    if (elements.isEmpty()) {
+      return false;
+    }
+    TypeSpec spec = indexerGenerator.generate(elements);
+    processorUtil.writeIndexer(spec);
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideExtension.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
new file mode 100644
index 000000000..9046219e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -0,0 +1,129 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideType;
+import com.google.auto.service.AutoService;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+// Links in Javadoc will work due to build setup, even though there is no direct dependency here.
+/**
+ * Generates classes based on Glide's annotations that configure Glide, add support for additional
+ * resource types, and/or extend Glide's API.
+ *
+ * <p>This processor discovers all {@link AppGlideModule} and
+ * {@link LibraryGlideModule} implementations that are
+ * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
+ * annotation will be ignored.
+ *
+ * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
+ * annotated classes.
+ *
+ * <p>Multiple classes are generated by this processor:
+ * <ul>
+ *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a
+ *      specific package that will later be used by the processor to discover all
+ *      {@link LibraryGlideModule} classes.
+ *   <li>For {@link AppGlideModule}s - A single
+ *      {@link AppGlideModule} implementation
+ *     ({@link com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@link LibraryGlideModule}s and the
+ *     original {@link AppGlideModule} in the correct order when Glide is
+ *     initialized.
+ *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
+ *   <ul>
+ *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     static versions of all builder methods in the base class and both static and instance
+ *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *     <li>If one or more methods in one or more
+ *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *     {@link GlideType}:
+ *     <ul>
+ *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated
+ *       method for each method annotated with
+ *       {@link GlideType}.
+ *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s.
+ *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@link com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@link com.bumptech.glide.RequestManager} implementation when appropriate.
+ *     </ul>
+ *   </ul>
+ * </ul>
+ *
+ * <p>{@link AppGlideModule} implementations must only be included in
+ * applications, not in libraries. There must be exactly one
+ * {@link AppGlideModule} implementation per
+ * Application. The {@link AppGlideModule} class is
+ * used as a signal that all modules have been found and that the final merged
+ * {@link com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ */
+@AutoService(Processor.class)
+public final class GlideAnnotationProcessor extends AbstractProcessor {
+  static final boolean DEBUG = false;
+  private ProcessorUtil processorUtil;
+  private LibraryModuleProcessor libraryModuleProcessor;
+  private AppModuleProcessor appModuleProcessor;
+  private boolean isGeneratedAppGlideModuleWritten;
+  private ExtensionProcessor extensionProcessor;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnvironment) {
+    super.init(processingEnvironment);
+    processorUtil = new ProcessorUtil(processingEnvironment);
+    IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
+    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
+    appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
+    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> result = new HashSet<>();
+    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());
+    result.addAll(extensionProcessor.getSupportedAnnotationTypes());
+    return result;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+   /**
+   * Each round we do the following:
+   * <ol>
+   *   <li>Find all AppGlideModules and save them to an instance variable (throw if > 1).
+   *   <li>Find all LibraryGlideModules
+   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name.
+   *   <li>If we wrote any Indexers, return and wait for the next round.
+   *   <li>If we didn't write any Indexers and there is a AppGlideModule, write the
+   *   GeneratedAppGlideModule. Once the GeneratedAppGlideModule is written, we expect to be
+   *   finished. Any further generation of related classes will result in errors.
+   * </ol>
+   */
+  @Override
+  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+    processorUtil.process();
+    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    appModuleProcessor.processModules(set, env);
+
+    if (newExtensionWritten || newModulesWritten) {
+      if (isGeneratedAppGlideModuleWritten) {
+        throw new IllegalStateException("Cannot process annotations after writing AppGlideModule");
+      }
+      return true;
+    }
+
+    if (!isGeneratedAppGlideModuleWritten) {
+      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();
+    }
+    return true;
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
new file mode 100644
index 000000000..488c5578f
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -0,0 +1,94 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.annotation.GlideType;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
+ * contains methods with the expected format.
+ *
+ * <p>Validation is performed so that errors can be found when a library is compiled. Without
+ * validation, an error written in to a library wouldn't be found until Glide tried to generate code
+ * for an Application.
+ */
+final class GlideExtensionValidator {
+
+  private GlideExtensionValidator() { }
+
+  static void validateExtension(TypeElement typeElement) {
+    if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
+      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+    }
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() == ElementKind.CONSTRUCTOR) {
+        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found a non-private constructor");
+        }
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (!executableElement.getParameters().isEmpty()) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found parameters in the constructor");
+        }
+        continue;
+      }
+      if (element.getKind() == ElementKind.METHOD) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (executableElement.getAnnotation(GlideOption.class) != null) {
+          validateExtendsRequestOptions(executableElement);
+        } else if (executableElement.getAnnotation(GlideType.class) != null) {
+          validateExtendsRequestManager(executableElement);
+        }
+      }
+    }
+  }
+
+  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideOption.class);
+    if (executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException("@GlideOption methods must take a "
+          + "RequestOptions object as their first parameter, but given none");
+    }
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().equals(
+        "com.bumptech.glide.request.RequestOptions")) {
+      throw new IllegalArgumentException("@GlideOption methods must take a"
+          + " RequestOptions object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideType.class);
+    if (executableElement.getParameters().size() != 1) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestOptions object as their first and only parameter, found multiple for: "
+      + executableElement.getEnclosingElement() + "#" + executableElement);
+    }
+
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestBuilder object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+    }
+    TypeMirror returnType = executableElement.getReturnType();
+    if (returnType.getKind() != TypeKind.VOID) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
new file mode 100644
index 000000000..34cfdf645
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -0,0 +1,204 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates a Glide look-alike that acts as the entry point to the generated API
+ * (GlideApp.with(...)).
+ *
+ * <p>>Generated {@link com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <pre>
+ * <code>
+ * public final class GlideApp {
+ *   private GiphyGlide() {
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context) {
+ *     return Glide.getPhotoCacheDir(context);
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context, String cacheName) {
+ *     return Glide.getPhotoCacheDir(context, cacheName);
+ *   }
+ *
+ *   public static Glide get(Context context) {
+ *     return Glide.get(context);
+ *   }
+ *
+ *   public static void tearDown() {
+ *     Glide.tearDown();
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Context context) {
+ *     return (GeneratedRequestManager) Glide.with(context);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Activity activity) {
+ *    return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(FragmentActivity activity) {
+ *     return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ * </code>
+ * </pre>
+ */
+final class GlideGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+
+  GlideGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(
+      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {
+    return TypeSpec.classBuilder(glideName)
+        .addJavadoc(
+            "The entry point for interacting with Glide for Applications\n"
+                + "\n"
+                + "<p>Includes all generated APIs from all\n"
+                + "{@link $T}s in source and dependent libraries.\n"
+                + "\n"
+                + "<p>This class is generated and should not be modified"
+                + "\n"
+                + "@see $T\n", GlideExtension.class, glideType)
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addMethod(MethodSpec.constructorBuilder()
+            .addModifiers(Modifier.PRIVATE)
+            .build())
+        .addMethods(
+            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
+        .build();
+  }
+
+  private List<MethodSpec> generateOverridesForGlideMethods(
+      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
+    return Lists.transform(discoverGlideMethodsToOverride(),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            if (isGlideWithMethod(input)) {
+              return overrideGlideWithMethod(
+                  generatedCodePackageName, generatedRequestManager, input);
+            } else {
+              return overrideGlideStaticMethod(input);
+            }
+          }
+        });
+  }
+
+  private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+
+    TypeElement element =
+        (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
+
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(Lists.transform(parameters,
+                new Function<VariableElement, ParameterSpec>() {
+                  @Override
+                  public ParameterSpec apply(VariableElement input) {
+                    return ParameterSpec.get(input);
+                  }
+            }));
+
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    boolean returnsValue = element != null;
+    if (returnsValue) {
+      builder.returns(ClassName.get(element));
+    }
+
+    String code = returnsValue ? "return " : "";
+    code += "$T.$N(";
+    List<Object> args = new ArrayList<>();
+    args.add(ClassName.get(glideType));
+    args.add(methodToOverride.getSimpleName());
+    if (!parameters.isEmpty()) {
+      for (VariableElement param : parameters) {
+        code += "$L, ";
+        args.add(param.getSimpleName());
+      }
+      code = code.substring(0, code.length() - 2);
+    }
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+    return builder.build();
+  }
+
+  private List<ExecutableElement> discoverGlideMethodsToOverride() {
+    return processorUtil.findStaticMethods(glideType);
+  }
+
+  private boolean isGlideWithMethod(ExecutableElement element) {
+    return processorUtil.isReturnValueTypeMatching(element, requestManagerType);
+  }
+
+  private MethodSpec overrideGlideWithMethod(
+      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
+    ClassName generatedRequestManagerClassName =
+        ClassName.get(packageName, generatedRequestManager.name);
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    Preconditions.checkArgument(
+        parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
+    VariableElement parameter = parameters.iterator().next();
+    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .returns(generatedRequestManagerClassName)
+        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
+        .addStatement("return ($T) $T.$N($L)",
+            generatedRequestManagerClassName, glideType,
+            methodToOverride.getSimpleName().toString(),
+            parameter.getSimpleName())
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
new file mode 100644
index 000000000..afae52f38
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates an empty class with an annotation containing the class names of one or more
+ * LibraryGlideModules and/or one or more GlideExtensions.
+ *
+ * <p>We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries
+ * can be bundled into an AAR and later retrieved by the annotation processor when it processes the
+ * AppGlideModule in an application.
+ *
+ * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      modules = "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule"
+ *  )
+ *  public class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule
+ *  {
+ *  }
+ * </code>
+ * </pre>
+ *
+ * <p>The output file generated by this class with a GlideExtension looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      extensions = "com.bumptech.glide.integration.gif.GifOptions"
+ *  )
+ *  public class Indexer_GlideExtension_com_bumptech_glide_integration_gif_GifOptions {
+ *  }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class IndexerGenerator {
+  private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
+  private final ProcessorUtil processorUtil;
+
+  IndexerGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(List<TypeElement> types) {
+    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> extensions = new ArrayList<>();
+    for (TypeElement element : types) {
+      if (processorUtil.isExtension(element)) {
+        extensions.add(element);
+      } else if (processorUtil.isLibraryGlideModule(element)) {
+        modules.add(element);
+      } else {
+        throw new IllegalArgumentException("Unrecognized type: " + element);
+      }
+    }
+    if (!modules.isEmpty() && !extensions.isEmpty()) {
+      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
+          + "other. Modules: " + modules + " Extensions: " + extensions);
+    }
+    if (!modules.isEmpty()) {
+      return generate(types, GlideModule.class);
+    } else {
+      return generate(types, GlideExtension.class);
+    }
+  }
+
+  private static TypeSpec generate(List<TypeElement> libraryModules,
+      Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder =
+        AnnotationSpec.builder(Index.class);
+
+    String value = getAnnotationValue(annotation);
+    for (TypeElement childModule : libraryModules) {
+      annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
+    }
+
+    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    for (TypeElement element : libraryModules) {
+      indexerName += element.getQualifiedName().toString().replace(".", "_");
+      indexerName += "_";
+    }
+    indexerName = indexerName.substring(0, indexerName.length() - 1);
+
+    return TypeSpec.classBuilder(indexerName)
+        .addAnnotation(annotationBuilder.build())
+        .addModifiers(Modifier.PUBLIC)
+        .build();
+  }
+
+  private static String getAnnotationValue(Class<? extends Annotation> annotation) {
+    if (annotation == GlideModule.class) {
+      return "modules";
+    } else if (annotation == GlideExtension.class) {
+      return "extensions";
+    } else {
+      throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
new file mode 100644
index 000000000..8f79cb7e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates Indexer classes annotated with {@link Index} for all
+ * {@link LibraryGlideModule}s.
+ */
+final class LibraryModuleProcessor {
+  private ProcessorUtil processorUtil;
+  private IndexerGenerator indexerGenerator;
+
+  LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     // Order matters here, if we find an Indexer below, we return before writing the root module.
+    // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
+    List<TypeElement> libraryGlideModules = new ArrayList<>();
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      // Root elements are added separately and must be checked separately because they're sub
+      // classes of LibraryGlideModules.
+      if (processorUtil.isAppGlideModule(element)) {
+        continue;
+      } else if (!processorUtil.isLibraryGlideModule(element)) {
+        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
+            + " and AppGlideModule implementations, not: " + element);
+      }
+
+      libraryGlideModules.add(element);
+    }
+
+    processorUtil.debugLog("got child modules: " + libraryGlideModules);
+    if (libraryGlideModules.isEmpty()) {
+      return false;
+    }
+
+    TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
+    processorUtil.writeIndexer(indexer);
+    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
+        + "indexers are found");
+     // If I write an Indexer in a round in the target package, then try to find all classes in
+    // the target package, my newly written Indexer won't be found. Since we wrote a class with
+    // an Annotation handled by this processor, we know we will be called again in the next round
+    // and we can safely wait to write our AppGlideModule until then.
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideModule.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
new file mode 100644
index 000000000..5229afc21
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -0,0 +1,364 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.sun.tools.javac.code.Attribute;
+import com.sun.tools.javac.code.Type.ClassType;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/**
+ * Utilities for writing classes and logging.
+ */
+final class ProcessorUtil {
+  private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
+  private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
+  private static final String LIBRARY_GLIDE_MODULE_SIMPLE_NAME = "LibraryGlideModule";
+  private static final String APP_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + APP_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String LIBRARY_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final TypeElement appGlideModuleType;
+  private final TypeElement libraryGlideModuleType;
+  private int round;
+
+  ProcessorUtil(ProcessingEnvironment processingEnv) {
+    this.processingEnv = processingEnv;
+
+    appGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(APP_GLIDE_MODULE_QUALIFIED_NAME);
+    libraryGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(LIBRARY_GLIDE_MODULE_QUALIFIED_NAME);
+  }
+
+  void process() {
+    round++;
+  }
+
+  boolean isAppGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        appGlideModuleType.asType());
+  }
+
+  boolean isLibraryGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        libraryGlideModuleType.asType());
+  }
+
+  boolean isExtension(TypeElement element) {
+    return element.getAnnotation(GlideExtension.class) != null;
+  }
+
+  void writeIndexer(TypeSpec indexer) {
+    writeClass(COMPILER_PACKAGE_NAME, indexer);
+  }
+
+  void writeClass(String packageName, TypeSpec clazz) {
+    try {
+      debugLog("Writing class:\n" + clazz);
+      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  List<ExecutableElement> findAnnotatedElementsInClasses(
+      Set<String> classNames, Class<? extends Annotation> annotationClass) {
+    List<ExecutableElement> result = new ArrayList<>();
+    for (String glideExtensionClassName : classNames) {
+      TypeElement glideExtension = processingEnv.getElementUtils()
+          .getTypeElement(glideExtensionClassName);
+      for (Element element : glideExtension.getEnclosedElements()) {
+        if (element.getAnnotation(annotationClass) != null) {
+          result.add((ExecutableElement) element);
+        }
+      }
+    }
+    return result;
+  }
+
+  List<TypeElement> getElementsFor(
+      Class<? extends Annotation> clazz, RoundEnvironment env) {
+    Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
+    return ElementFilter.typesIn(annotatedElements);
+  }
+
+  /**
+   * Generates a Javadoc code block for generated methods that delegate to methods in
+   * {@link GlideExtension}s.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
+   * </code>
+   * </pre>
+   *
+   * @param method The method from the {@link GlideExtension} annotated class that the generated
+   * method this Javadoc will be attached to delegates to.
+   */
+  CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
+    // Use the simple name of the containing type instead of just the containing type's TypeMirror
+    // so that we avoid appending <CHILD> or other type arguments to the class and breaking
+    // Javadoc's linking.
+    // With this we get @see RequestOptions#methodName().
+    // With just ClassName.get(element.getEnclosingElement().asType()), we get:
+    // @see RequestOptions<CHILD>#methodName().
+    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(), method.getParameters());
+  }
+
+  /**
+   * Generates a Javadoc block for generated methods that delegate to other methods.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
+   *         methodParam1, methodParamN)
+   * </code>
+   * </pre>
+   * @param nameOfClassContainingMethod The simple class name of the class containing the method
+   * without any generic types like {@literal <T>}.
+   * @param methodSimpleName The name of the method.
+   * @param methodParameters A maybe empty list of all the parameters for the method in question.
+   */
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      List<? extends VariableElement> methodParameters) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSimpleName, Lists.transform(methodParameters,
+            new Function<VariableElement, Object>() {
+              @Override
+              public Object apply(VariableElement input) {
+                return getJavadocSafeName(input);
+              }
+            }));
+  }
+
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSpec.name, Lists.transform(methodSpec.parameters,
+            new Function<ParameterSpec, Object>() {
+              @Override
+              public Object apply(ParameterSpec input) {
+                return input.type;
+              }
+            }));
+  }
+
+  private CodeBlock generateSeeMethodJavadocInternal(
+      TypeName nameOfClassContainingMethod, String methodName,
+      List<Object> safeParameterNames) {
+     String javadocString = "@see $T#$L(";
+    List<Object> javadocArgs = new ArrayList<>();
+    javadocArgs.add(nameOfClassContainingMethod);
+    javadocArgs.add(methodName);
+
+    for (Object param : safeParameterNames) {
+      javadocString += "$T, ";
+      javadocArgs.add(param);
+    }
+    if (javadocArgs.size() > 2) {
+      javadocString = javadocString.substring(0, javadocString.length() - 2);
+    }
+    javadocString += ")\n";
+    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+  }
+
+
+   /**
+   * Returns a safe String to use in a Javadoc that will function in a link.
+   *
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
+   * in {@literal RequestOptions<T>} for example).
+   */
+  private TypeName getJavadocSafeName(Element element) {
+    Types typeUtils = processingEnv.getTypeUtils();
+    TypeMirror type = element.asType();
+    if (typeUtils.asElement(type) == null) {
+      // If there is no Element, it's a primitive and can't have additional types, so we're done.
+      return ClassName.get(element.asType());
+    }
+    Name simpleName = typeUtils.asElement(type).getSimpleName();
+    return ClassName.bestGuess(simpleName.toString());
+  }
+
+  void debugLog(String toLog) {
+    if (DEBUG) {
+      infoLog(toLog);
+    }
+  }
+
+  void infoLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethods(TypeElement clazz) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  Set<String> findClassValuesFromAnnotationOnClassAsNames(
+      Element clazz, Class<? extends Annotation> annotationClass) {
+    String annotationClassName = annotationClass.getName();
+    AnnotationValue excludedModuleAnnotationValue = null;
+    for (AnnotationMirror annotationMirror : clazz.getAnnotationMirrors()) {
+      // Two different AnnotationMirrors the same class might not be equal, so compare Strings
+      // instead. This check is necessary because a given class may have multiple Annotations.
+      if (!annotationClassName.equals(annotationMirror.getAnnotationType().toString())) {
+        continue;
+      }
+      Set<? extends Map.Entry<? extends ExecutableElement, ? extends AnnotationValue>> values =
+          annotationMirror.getElementValues().entrySet();
+      // Excludes has only one value. If we ever change that, we'd need to iterate over all
+      // values in the entry set and compare the keys to whatever our Annotation's attribute is
+      // (usually value).
+      if (values.size() != 1) {
+        throw new IllegalArgumentException("Expected single value, but found: " + values);
+      }
+      excludedModuleAnnotationValue = values.iterator().next().getValue();
+      if (excludedModuleAnnotationValue == null) {
+        throw new NullPointerException("Failed to find Excludes#value");
+      }
+    }
+    if (excludedModuleAnnotationValue == null) {
+      return Collections.emptySet();
+    }
+    Object value = excludedModuleAnnotationValue.getValue();
+    if (value instanceof List) {
+      List values = (List) value;
+      Set<String> result = new HashSet<>(values.size());
+      for (Object current : values) {
+        Attribute.Class currentClass = (Attribute.Class) current;
+        result.add(currentClass.getValue().toString());
+      }
+      return result;
+    } else {
+      ClassType classType = (ClassType) value;
+      return Collections.singleton(classType.toString());
+    }
+  }
+
+  private enum MethodType {
+    STATIC,
+    INSTANCE
+  }
+
+  private final class FilterPublicMethods implements Predicate<Element> {
+    @Nullable
+    private final TypeMirror returnType;
+    private final MethodType methodType;
+
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+      this.returnType = returnType;
+      this.methodType = methodType;
+    }
+
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+      this(returnType != null ? returnType.asType() : null, methodType);
+    }
+
+    @Override
+    public boolean apply(@Nullable Element input) {
+      if (input == null
+          || input.getKind() != ElementKind.METHOD
+          || !input.getModifiers().contains(Modifier.PUBLIC)) {
+        return false;
+      }
+      boolean isStatic = input.getModifiers().contains(Modifier.STATIC);
+      if (methodType == MethodType.STATIC && !isStatic) {
+        return false;
+      } else if (methodType == MethodType.INSTANCE && isStatic) {
+        return false;
+      }
+      ExecutableElement method = (ExecutableElement) input;
+      if (returnType == null) {
+        return true;
+      }
+      return isReturnValueTypeMatching(method, returnType);
+    }
+  }
+
+  boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expectedReturnType) {
+    return isReturnValueTypeMatching(method, expectedReturnType.asType());
+  }
+
+  private boolean isReturnValueTypeMatching(
+      ExecutableElement method, TypeMirror expectedReturnType) {
+    return processingEnv.getTypeUtils().isAssignable(
+        method.getReturnType(), expectedReturnType);
+  }
+
+  private static final class ToMethod implements Function<Element, ExecutableElement> {
+
+    @Nullable
+    @Override
+    public ExecutableElement apply(@Nullable Element input) {
+      return (ExecutableElement) input;
+    }
+  }
+
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
new file mode 100644
index 000000000..21c147ddc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -0,0 +1,351 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import com.squareup.javapoet.WildcardTypeName;
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
+ * classes.
+ *
+ * <p>Generated code looks like this:
+ * <pre>
+ * <code>
+ * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
+ *   GlideRequest(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+ *     super(transcodeClass, other);
+ *   }
+ *
+ *   GlideRequest(GlideContext context, RequestManager requestManager,
+ *       Class<TranscodeType> transcodeClass) {
+ *     super(context, requestManager ,transcodeClass);
+ *   }
+ *
+ *   {@literal @Override}
+ *   protected GlideRequest<File> getDownloadOnlyRequest() {
+ *    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} GlideOptions#dontAnimate()
+ *    *\/
+ *   public GlideRequest<TranscodeType> dontAnimate() {
+ *     if (getMutableOptions() instanceof GlideOptions) {
+ *       this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+ *     } else {
+ *       this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+ *     }
+ *     return this;
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} RequestOptions#sizeMultiplier(float)
+ *    *\/
+ *   public GlideRequest<TranscodeType> sizeMultiplier(float sizeMultiplier) {
+ *     this.requestOptions = getMutableOptions().sizeMultiplier(sizeMultiplier);
+ *     return this;
+ *   }
+ *
+ *   ...
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestBuilderGenerator {
+  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String REQUEST_BUILDER_SIMPLE_NAME = "RequestBuilder";
+  static final String REQUEST_BUILDER_QUALIFIED_NAME =
+      REQUEST_BUILDER_PACKAGE_NAME + "." + REQUEST_BUILDER_SIMPLE_NAME;
+
+  // Uses package private methods and variables.
+  private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
+
+  /**
+   * An arbitrary name of the Generic type in the generated RequestBuilder.
+   * e.g. RequestBuilder<TranscodeType>
+   */
+  private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
+  /** A set of method names to avoid overriding from RequestOptions. */
+  private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
+      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private ClassName generatedRequestBuilderClassName;
+  private final TypeVariableName transcodeTypeName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
+  private final TypeElement requestOptionsType;
+  private final TypeElement requestBuilderType;
+  private ClassName requestOptionsClassName;
+
+  RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    requestBuilderType = processingEnv.getElementUtils()
+        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+
+    transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
+
+    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+
+    if (generatedOptions != null) {
+      requestOptionsClassName =
+          ClassName.get(generatedCodePackageName, generatedOptions.name);
+    } else {
+      requestOptionsClassName =
+          ClassName.get(
+              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
+              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+    }
+
+    ParameterizedTypeName requestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(
+            ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
+            transcodeTypeName);
+
+    return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
+        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
+            requestBuilderType)
+        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
+        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
+        .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
+        .addJavadoc("\n")
+        .addJavadoc("<p>Generated code, do not modify.\n")
+        .addJavadoc("\n")
+        .addJavadoc("@see $T\n", requestBuilderType)
+        .addJavadoc("@see $T\n", requestOptionsType)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "unused")
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addTypeVariable(transcodeTypeName)
+        .superclass(requestBuilderOfTranscodeType)
+        .addMethods(generateConstructors())
+        .addMethod(generateDownloadOnlyRequestMethod())
+        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(generateRequestBuilderOverrides())
+        .build();
+  }
+
+  /**
+   * Generates overrides of all methods in {@link com.bumptech.glide.RequestBuilder} that return
+   * {@link com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   */
+  private List<MethodSpec> generateRequestBuilderOverrides() {
+    TypeMirror rawRequestBuilderType =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestBuilderOverride(input);
+          }
+        });
+  }
+
+  /**
+   * Generates an override of a particular method in {@link com.bumptech.glide.RequestBuilder} that
+   * returns {@link com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * instead.
+   */
+  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  /**
+   * Generates methods with equivalent names and arguments to methods annotated with
+   * {@link GlideOption} in
+   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   */
+  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      @Nullable final TypeSpec generatedOptions) {
+    if (generatedOptions == null) {
+      return Collections.emptyList();
+    }
+    return FluentIterable
+        .from(generatedOptions.methodSpecs)
+        .filter(new Predicate<MethodSpec>() {
+          @Override
+          public boolean apply(MethodSpec input) {
+            return isUsefulGeneratedRequestOption(input);
+          }
+        })
+        .transform(new Function<MethodSpec, MethodSpec>() {
+          @Override
+          public MethodSpec apply(MethodSpec input) {
+            return generateGeneratedRequestOptionEquivalent(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   *
+   * <p>Only newly generated methods will be included in the generated
+   * {@link com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * methods that override other methods to avoid duplicates.
+   */
+  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
+    return
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
+        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionMethod.hasModifier(Modifier.STATIC)
+        && requestOptionMethod.returnType.toString()
+            .equals(requestOptionsClassName.toString());
+  }
+
+   /**
+   * Generates a particular method with  an equivalent name and arguments to the given method
+   * from the generated {@link com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   */
+  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
+    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
+        .add(".$N(", requestOptionMethod.name)
+        .add(FluentIterable.from(requestOptionMethod.parameters)
+            .transform(new Function<ParameterSpec, String>() {
+              @Override
+              public String apply(ParameterSpec input) {
+                return input.name;
+              }
+            })
+            .join(Joiner.on(", ")))
+        .add(");\n")
+        .build();
+
+    return MethodSpec.methodBuilder(requestOptionMethod.name)
+        .addJavadoc(
+            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
+        .addModifiers(Modifier.PUBLIC)
+        .addTypeVariables(requestOptionMethod.typeVariables)
+        .addParameters(requestOptionMethod.parameters)
+        .returns(generatedRequestBuilderOfTranscodeType)
+        .beginControlFlow(
+            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
+        .addCode("this.requestOptions = (($T) getMutableOptions())",
+            requestOptionsClassName)
+        .addCode(callRequestOptionsMethod)
+        .nextControlFlow("else")
+        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
+            requestOptionsClassName))
+        .addCode(callRequestOptionsMethod)
+        .endControlFlow()
+        .addStatement("return this")
+        .build();
+  }
+
+  private List<MethodSpec> generateConstructors() {
+    ParameterizedTypeName classOfTranscodeType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), transcodeTypeName);
+
+    TypeName wildcardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName requestBuilderOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(requestBuilderType), wildcardOfObject);
+
+    MethodSpec firstConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addParameter(requestBuilderOfWildcardOfObject, "other")
+        .addStatement("super($N, $N)", "transcodeClass", "other")
+        .build();
+
+    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
+    ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
+    MethodSpec secondConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(glide, "glide")
+            .addParameter(requestManager, "requestManager")
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass")
+            .build();
+    return ImmutableList.of(firstConstructor, secondConstructor);
+  }
+
+  /**
+   * Overrides the protected downloadOnly method in {@link com.bumptech.glide.RequestBuilder} to
+   * return our generated subclass instead.
+   */
+  private MethodSpec generateDownloadOnlyRequestMethod() {
+    ParameterizedTypeName generatedRequestBuilderOfFile
+        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    return MethodSpec.methodBuilder("getDownloadOnlyRequest")
+        .addAnnotation(Override.class)
+        .returns(generatedRequestBuilderOfFile)
+        .addModifiers(Modifier.PROTECTED)
+        .addStatement("return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName, File.class, "this",
+            "DOWNLOAD_ONLY_OPTIONS")
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
new file mode 100644
index 000000000..a86bb1a37
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -0,0 +1,89 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of
+ * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@link com.bumptech.glide.RequestManager} implementation.
+ *
+ * <p>Generated {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * classes look like this:
+ * <pre>
+ * <code>
+ * public class GeneratedRequestManagerFactory
+ *     implements RequestManagerRetriever.RequestManagerFactory {
+ *   {@literal @Override}
+ *   public RequestManager build(Glide glide, Lifecycle lifecycle,
+ *       RequestManagerTreeNode treeNode) {
+ *     return new GeneratedRequestManager(glide, lifecycle, treeNode);
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerFactoryGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
+      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
+      "GeneratedRequestManagerFactory";
+
+  private final TypeElement glideType;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement requestManagerFactoryInterface;
+  private final ClassName requestManagerClassName;
+
+  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv) {
+    Elements elementUtils = processingEnv.getElementUtils();
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestManagerFactoryInterface =
+        elementUtils.getTypeElement(REQUEST_MANAGER_FACTORY_QUALIFIED_NAME);
+
+    TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+  }
+
+  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addSuperinterface(ClassName.get(requestManagerFactoryInterface))
+        .addJavadoc("Generated code, do not modify\n")
+        .addMethod(
+            MethodSpec.methodBuilder("build")
+                .addModifiers(Modifier.PUBLIC)
+                .addAnnotation(Override.class)
+                .returns(requestManagerClassName)
+                .addParameter(ClassName.get(glideType), "glide")
+                .addParameter(ClassName.get(lifecycleType), "lifecycle")
+                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addStatement(
+                    "return new $T(glide, lifecycle, treeNode)",
+                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
+                .build()
+        )
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
new file mode 100644
index 000000000..920d439f6
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -0,0 +1,293 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of {@link com.bumptech.glide.RequestManager} that contains generated
+ * methods from {@link GlideExtension}s and {@link GlideType}.
+ *
+ * <p>Generated {@link com.bumptech.glide.RequestManager} implementations look like this:
+ * <pre>
+ * <code>
+ * public final class GeneratedRequestManager extends RequestManager {
+ *   GeneratedRequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+ *     super(glide, lifecycle, treeNode);
+ *   }
+ *
+ *   public RequestBuilder<GifDrawable> asGif() {
+ *     RequestBuilder<GifDrawable> requestBuilder = this.as(GifDrawable.class);
+ *     GifOptions.asGif(requestBuilder);
+ *     return requestBuilder;
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
+      "GlideRequests";
+
+  private ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final ClassName requestManagerClassName;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+  private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
+
+  RequestManagerGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestBuilderType =
+        elementUtils.getTypeElement(RequestBuilderGenerator.REQUEST_BUILDER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  @Nullable
+  TypeSpec generate(
+      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      Set<String> glideExtensions) {
+    generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
+         .superclass(requestManagerClassName)
+         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                 + "annotated with {@link $T}\n"
+                 + "\n"
+                 + "<p>Generated code, do not modify\n",
+             GlideExtension.class, GlideType.class)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+         .addMethod(generateCallSuperConstructor())
+         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
+         .addMethods(generateRequestManagerMethodOverrides())
+         .addMethods(
+             FluentIterable.from(
+                 Collections.singletonList(
+                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                 .filter(Predicates.<MethodSpec>notNull()))
+         .build();
+  }
+
+  private MethodSpec generateCallSuperConstructor() {
+    return MethodSpec.constructorBuilder()
+        .addModifiers(Modifier.PUBLIC)
+        .addParameter(ClassName.get(glideType), "glide")
+        .addParameter(ClassName.get(lifecycleType), "lifecycle")
+        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+        .addStatement("super(glide, lifecycle, treeNode)")
+        .build();
+  }
+
+  private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
+    TypeVariableName resourceType = TypeVariableName.get("ResourceType");
+    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
+        .get(ClassName.get(Class.class), resourceType);
+
+    ClassName generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, requestBuilder.name);
+
+    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
+        .get(generatedRequestBuilderClassName, resourceType);
+
+    return MethodSpec.methodBuilder("as")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .addTypeVariable(TypeVariableName.get("ResourceType"))
+        .addParameter(classOfResouceType, "resourceClass")
+        .returns(requestBuilderOfResourceType)
+        .addStatement("return new $T<>(glide, this, resourceClass)",
+            this.generatedRequestBuilderClassName)
+        .build();
+  }
+
+  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+    // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
+    // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
+    // assignable to the raw RequestBuilder.
+    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
+        .erasure(requestBuilderType.asType());
+
+    final TypeElement classType =
+        processingEnv.getElementUtils().getTypeElement(Class.class.getCanonicalName());
+    final TypeMirror rawClassType = processingEnv.getTypeUtils().erasure(classType.asType());
+
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(new Predicate<ExecutableElement>() {
+          @Override
+          public boolean apply(ExecutableElement input) {
+            // Skip the <T> as(Class<T>) method.
+            return !input.getSimpleName().toString().equals("as");
+          }
+        })
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestManagerMethodOverride(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Generates overrides of existing RequestManager methods so that they return our generated
+   * RequestBuilder subtype.
+   */
+  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
+     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+      Set<String> glideExtensions) {
+    List<ExecutableElement> requestManagerExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
+
+    return Lists.transform(requestManagerExtensionMethods,
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateAdditionalRequestManagerMethod(input);
+          }
+        });
+  }
+
+  // Generates methods added to RequestManager via GlideExtensions.
+  private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addStatement(
+            "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
+        .addStatement("$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement("return requestBuilder")
+        .build();
+  }
+
+  /**
+   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
+   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   */
+  @Nullable
+  private MethodSpec generateOverrideSetRequestOptions(
+      String generatedCodePackageName, @Nullable TypeSpec generatedRequestOptions) {
+    if (generatedRequestOptions == null) {
+      return null;
+    }
+
+    Elements elementUtils = processingEnv.getElementUtils();
+    TypeElement requestOptionsType =
+            elementUtils.getTypeElement(
+                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+    TypeElement androidNonNullType =
+            elementUtils.getTypeElement("android.support.annotation.NonNull");
+
+    // This class may have just been generated and therefore may not be found if we try to obtain
+    // it via Elements, so use just the String version instead.
+    String generatedRequestOptionsQualifiedName =
+        generatedCodePackageName + "." + generatedRequestOptions.name;
+
+    String methodName = "setRequestOptions";
+    String parameterName = "toSet";
+
+    return MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class)
+        .addModifiers(Modifier.PROTECTED)
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
+                .addAnnotation(ClassName.get(androidNonNullType))
+                .build())
+        .beginControlFlow("if ($N instanceof $L)",
+            parameterName, generatedRequestOptionsQualifiedName)
+        .addStatement("super.$N($N)", methodName, parameterName)
+        .nextControlFlow("else")
+        .addStatement("super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName, parameterName)
+        .endControlFlow()
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
new file mode 100644
index 000000000..b9d7e913d
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -0,0 +1,614 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Strings;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
+ * containing static versions of methods included in the base class and static and instance versions
+ * of all methods annotated with {@link GlideOption} in classes annotated with
+ * {@link GlideExtension}.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
+ *
+ *   public static com.google.android.apps.photos.glide.GlideOptions signatureOf(
+ *       com.bumptech.glide.load.Key arg0) {
+ *     return new com.google.android.apps.photos.glide.GlideOptions()
+ *         .apply(com.bumptech.glide.request.RequestOptions.signatureOf(arg0));
+ *   }
+ *
+ *   ... // The rest of the static versions of methods from RequestOptions go here.
+ *
+ *   // Now on to methods generated from an extension:
+ *   public com.bumptech.glide.GlideOptions dontAnimate() {
+ *     com.bumptech.glide.integration.gifdecoder.GifOptions.dontAnimate(this);
+ *     return this;
+ *   }
+ *
+ *   public static com.bumptech.glide.GlideOptions noAnimation() {
+ *     return new com.bumptech.glide.GlideOptions().dontAnimate();
+ *   }
+ * }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class RequestOptionsGenerator {
+  private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
+  static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private final ProcessingEnvironment processingEnvironment;
+  private final ClassName requestOptionsName;
+  private final TypeElement requestOptionsType;
+  private final ProcessorUtil processorUtil;
+  private ClassName glideOptionsName;
+  private int nextStaticFieldUniqueId;
+
+  RequestOptionsGenerator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
+        REQUEST_OPTIONS_SIMPLE_NAME);
+
+    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
+    glideOptionsName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
+
+    List<MethodAndStaticVar> methodsForExtensions =
+        generateMethodsForExtensions(glideExtensionClassNames);
+
+    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
+        Iterables.transform(methodsForExtensions,
+            new Function<MethodAndStaticVar, MethodSignature>() {
+              @Nullable
+              @Override
+              public MethodSignature apply(MethodAndStaticVar f) {
+                return new MethodSignature(f.method);
+              }
+            }));
+
+    List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+
+    List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
+    for (MethodAndStaticVar item : staticOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(item.method))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(item);
+    }
+    for (MethodSpec methodSpec : instanceOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(methodSpec))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(new MethodAndStaticVar(methodSpec));
+    }
+    allMethodsAndStaticVars.addAll(methodsForExtensions);
+
+    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+        .addModifiers(Modifier.FINAL)
+        .addModifiers(Modifier.PUBLIC)
+        .superclass(requestOptionsName);
+
+    for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
+      if (methodAndStaticVar.method != null) {
+        classBuilder.addMethod(methodAndStaticVar.method);
+      }
+      if (methodAndStaticVar.staticField != null) {
+        classBuilder.addField(methodAndStaticVar.staticField);
+      }
+    }
+    return classBuilder.build();
+  }
+
+  private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
+    Builder builder = CodeBlock.builder()
+        .add("Automatically generated from {@link $T} annotated classes.\n",
+            GlideExtension.class)
+        .add("\n")
+        .add("@see $T\n", requestOptionsName);
+
+    for (String glideExtensionClass : glideExtensionClassNames) {
+      builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
+    }
+    return builder.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForExtensions(
+      Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(
+            glideExtensionClassNames, GlideOption.class);
+
+    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(input);
+          }
+        });
+  }
+
+  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
+    return MethodSpec.overriding(methodToOverride)
+        .returns(glideOptionsName)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
+      ExecutableElement element) {
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
+    int overrideType = getOverrideType(element);
+    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " RequestOptions, but no such method was found. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    }
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(";
+      List<Object> args = new ArrayList<>();
+      args.add(element.getSimpleName().toString());
+      if (!parameters.isEmpty()) {
+        for (VariableElement variable : parameters) {
+          callSuper += "$L, ";
+          args.add(variable.getSimpleName().toString());
+        }
+        callSuper = callSuper.substring(0, callSuper.length() - 2);
+      }
+      callSuper += ")";
+
+      builder.addStatement(callSuper, args.toArray(new Object[0]))
+          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
+              requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+    }
+
+    for (VariableElement variable : parameters) {
+      builder.addParameter(getParameterSpec(variable));
+    }
+
+    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
+    List<Object> args = new ArrayList<>();
+    String code = "$T.$L($L, ";
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add("this");
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code += "$L, ";
+        args.add(variable.getSimpleName().toString());
+      }
+    }
+    code = code.substring(0, code.length() - 2);
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+
+    builder.addStatement("return this");
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+
+    result.add(new MethodAndStaticVar(builder.build()));
+    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
+    List<ExecutableElement> staticMethodsThatReturnRequestOptions =
+        processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
+    List<MethodAndStaticVar> staticMethods = new ArrayList<>();
+    for (ExecutableElement element : staticMethodsThatReturnRequestOptions) {
+      if (element.getAnnotation(Deprecated.class) != null) {
+        continue;
+      }
+      staticMethods.add(generateStaticMethodEquivalentForRequestOptionsStaticMethod(element));
+    }
+    return staticMethods;
+  }
+
+  /**
+   * This method is a bit of a hack, but it lets us tie the static version of a method with the
+   * instance version. In turn that lets us call the instance versions on the generated subclass,
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods
+   * on the generated subclass allows our static methods to properly call code that overrides
+   * an existing method in RequestOptions.
+   *
+   * <p>The string names here just map between the static methods in
+   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   */
+  private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
+    String equivalentInstanceMethodName;
+    if ("bitmapTransform".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "transform";
+    } else if ("decodeTypeOf".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "decode";
+    } else if (staticMethodName.endsWith("Transform")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 9);
+    } else if (staticMethodName.endsWith("Of")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 2);
+    } else if ("noTransformation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontTransform";
+    } else if ("noAnimation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontAnimate";
+    } else if (staticMethodName.equals("option")) {
+      equivalentInstanceMethodName = "set";
+    } else {
+      throw new IllegalArgumentException("Unrecognized static method name: " + staticMethodName);
+    }
+    return equivalentInstanceMethodName;
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStaticMethod(
+      ExecutableElement staticMethod) {
+    boolean memoize = memoizeStaticMethodFromArguments(staticMethod);
+    String staticMethodName = staticMethod.getSimpleName().toString();
+
+    String equivalentInstanceMethodName =
+        getInstanceMethodNameFromStaticMethodName(staticMethodName);
+
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = staticMethod.getParameters();
+    String createNewOptionAndCall = "new $T().$N(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, equivalentInstanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = staticMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
+    return staticMethod.getParameters().isEmpty()
+        || (staticMethod.getParameters().size() == 1
+        && staticMethod.getParameters().get(0).getSimpleName().toString()
+        .equals("android.content.Context"));
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
+      ExecutableElement instanceMethod) {
+    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
+    if (skipStaticMethod) {
+      return new MethodAndStaticVar();
+    }
+    String staticMethodName = getStaticMethodName(instanceMethod);
+    String instanceMethodName = instanceMethod.getSimpleName().toString();
+    if (Strings.isNullOrEmpty(staticMethodName)) {
+      if (instanceMethodName.startsWith("dont")) {
+        staticMethodName = "no" + instanceMethodName.replace("dont", "");
+      } else {
+        staticMethodName = instanceMethodName + "Of";
+      }
+    }
+    boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
+
+    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = instanceMethod.getParameters();
+
+    // Always remove the first parameter because it's always RequestOptions in extensions. The
+    // actual method we want to generate will pass the RequestOptions in to the extension method,
+    // but should not itself require a RequestOptions object to be passed in.
+    if (parameters.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Expected non-empty parameters for: " + instanceMethod);
+    }
+    // Remove is not supported.
+    parameters = parameters.subList(1, parameters.size());
+
+    String createNewOptionAndCall = "new $T().$L(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = instanceMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private boolean isAndroidContext(VariableElement variableElement) {
+    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
+    return element.toString().equals("android.content.Context");
+  }
+
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static ParameterSpec getParameterSpec(VariableElement variable) {
+    return ParameterSpec.builder(
+        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private static int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
+  @Nullable
+  private static String getStaticMethodName(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    String result = glideOption != null ? glideOption.staticMethodName() : null;
+    return Strings.emptyToNull(result);
+  }
+
+  private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.memoizeStaticMethod();
+  }
+
+  private static boolean skipStaticMethod(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.skipStaticMethod();
+  }
+
+  private static final class MethodAndStaticVar {
+    @Nullable
+    final MethodSpec method;
+    @Nullable
+    final FieldSpec staticField;
+
+    MethodAndStaticVar() {
+      this(null /*method*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method) {
+      this(method, null /*staticField*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method, @Nullable FieldSpec staticField) {
+      this.method = method;
+      this.staticField = staticField;
+    }
+  }
+
+  private static final class MethodSignature {
+    private final TypeName returnType;
+    private final List<TypeName> parameterTypes;
+    private final Set<Modifier> modifiers;
+    private final String name;
+
+    MethodSignature(MethodSpec spec) {
+      name = spec.name;
+      modifiers = spec.modifiers;
+      returnType = spec.returnType;
+      parameterTypes =
+          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
+            @Nullable
+            @Override
+            public TypeName apply(ParameterSpec parameterSpec) {
+              return parameterSpec.type;
+
+            }
+          });
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof MethodSignature) {
+        MethodSignature other = (MethodSignature) o;
+        return name.equals(other.name)
+            && returnType.equals(other.returnType)
+            && parameterTypes.equals(other.parameterTypes)
+            && modifiers.equals(other.modifiers);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+    }
+  }
+}
diff --git a/annotation/gradle.properties b/annotation/gradle.properties
new file mode 100644
index 000000000..ab55616cf
--- /dev/null
+++ b/annotation/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotations
+POM_ARTIFACT_ID=annotations
+POM_PACKAGING=jar
+POM_DESCRIPTION=A set of annotations for configuring Glide.
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
new file mode 100644
index 000000000..0a15f5a0d
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
+ * from an application.
+ *
+ * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
+ *
+ * <p>Cannot be used to exclude AppGlideModules (there must be at most one per Application anyway).
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Excludes {
+  Class[] value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
new file mode 100644
index 000000000..bb525c849
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicate a class that extends Glide's public API.
+ *
+ * @see GlideOption
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideExtension { }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
new file mode 100644
index 000000000..690b8f727
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies AppGlideModules and ChildeGlideModules for Glide's annotation processor to merge at
+ * compile time.
+ *
+ * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideModule {
+  /**
+   * Returns the name of the class that will be used as a replacement for
+   * {@link com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   */
+  String glideName() default "GlideApp";
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
new file mode 100644
index 000000000..50bfbecb0
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.request.RequestOptions}.
+ *
+ * <p>All annotated methods will be added to a single
+ * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * Overlapping method names in different extensions may cause errors at compile time.
+ *
+ * <p>Static equivalents of annotated methods will also be generated.
+ *
+ * <p>Methods with this annotation will only be found if they belong to classes annotated with
+ * {@link GlideExtension}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideOption {
+   /** Does not intend to override a method in a super class. */
+  int OVERRIDE_NONE = 0;
+  /** Expects to call super and then add additional functionality to an overridden method. */
+  int OVERRIDE_EXTEND = 1;
+  /** Expects to not call super and replace an overridden method. */
+  int OVERRIDE_REPLACE = 2;
+
+  /**
+   * Determines how and whether a generated method should extend a method from it's parent.
+   *
+   * <p>Must be one of {@link #OVERRIDE_NONE}, {@link #OVERRIDE_EXTEND}, {@link #OVERRIDE_REPLACE}.
+   *
+   * <p>The extended method is determined by String and argument matching against methods in the
+   * extended class. If {@link #OVERRIDE_NONE} is used and the method and arguments match a method
+   * in the extended class, a compile time error will result. Similarly if any other override type
+   * is used and no method/arguments in the extended class match, a compile time error will result.
+   */
+  int override() default OVERRIDE_NONE;
+
+  /**
+   * Sets the name for the generated static version of this method.
+   *
+   * <p>If this value is not set, the static method name is just the original method name with "Of"
+   * appended.
+   */
+  String staticMethodName() default "";
+
+  /**
+   * {@code true} to indicate that it's safe to statically memoize the result of this method using
+   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
+   *
+   * <p>This method should only be used for no-arg methods where there's only a single possible
+   * value.
+   *
+   * <p>Memoization can save object allocations for frequently used options.
+   */
+  boolean memoizeStaticMethod() default false;
+
+  /**
+   * {@code true} to prevent a static builder method from being generated.
+   *
+   * <p>By default static methods are generated for all methods annotated with
+   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
+   * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
+   * instance version of the method on it and returns it. For example:
+   * <pre>
+   * <code>
+   * public static GlideOptions noAnimation() {
+   *   return new GlideOptions().dontAnimate();
+   * }
+   * </code>
+   * </pre>
+   *
+   * @see #memoizeStaticMethod()
+   * @see #staticMethodName()
+   */
+  boolean skipStaticMethod() default false;
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
new file mode 100644
index 000000000..f0c19a599
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.RequestManager}.
+ *
+ * <p>If one or more method is found with this annotation, an additional API entry point that
+ * exposes a generated {@link com.bumptech.glide.RequestManager} subclass will be created. The
+ * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
+ * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
+ * API entry point will provide access to these additional methods.
+ *
+ * <p>The name of the API entry point created when one of these methods is found can be controlled
+ * by {@link GlideModule#glideName()}.
+ *
+ * <p>Methods with this annotation will only be found if they are contained in a class annotated
+ * with {@link GlideExtension}.
+ *
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the
+ * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
+ * matching the value of {@link #value()}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideType {
+
+  /**
+   * A Resource class name, like GifDrawable.class, Bitmap.class etc.
+   *
+   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
+   */
+  Class<?> value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
new file mode 100644
index 000000000..81ba54ae1
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used to retrieve LibraryGlideModule and GlideExtension classes in our annotation processor from
+ * libraries and applications.
+ *
+ * <p>Part of the internals of Glide's annotation processor and not for public use.
+ */
+@Target(ElementType.TYPE)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+@interface Index {
+  String[] modules() default {};
+  String[] extensions() default {};
+}
diff --git a/build.gradle b/build.gradle
index ab3a44b96..de9f3c9d1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -9,7 +9,6 @@ buildscript {
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
         classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
-        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
     }
 }
 
@@ -40,11 +39,11 @@ subprojects { project ->
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = "6.6"
+        toolVersion = '6.12.1'
     }
 
     checkstyle {
-        configFile = new File(rootDir, 'checkstyle.xml')
+        configFile = rootProject.file('checkstyle.xml')
         configProperties.checkStyleConfigDir = rootProject.rootDir
     }
 
@@ -65,13 +64,17 @@ subprojects { project ->
 
     gradle.projectsEvaluated {
         tasks.withType(JavaCompile) {
-            if (!name.contains('Test')) {
-                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
-            }
+            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
         }
     }
+
+    // We generate a combined javadoc, no need to create javadocs for each library independently.
+    if (!project.name.equals('glide')) {
+        tasks.withType(Javadoc).all { enabled = false }
+    }
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.2.1'
+    gradleVersion = '2.9'
+    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
 }
diff --git a/checkstyle.xml b/checkstyle.xml
index 66380c192..b5285c17f 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -14,6 +14,9 @@
         <property name="message" value="Line has trailing spaces."/>
     </module>
 
+    <!-- Ensure trailling newline for compatibility -->
+    <module name="NewlineAtEndOfFile" />
+
     <!-- Space after 'for' and 'if' -->
     <module name="RegexpSingleline">
         <property name="format" value="^\s*(for|if)\b[^ ]"/>
@@ -93,7 +96,7 @@
 
           <property name="sortStaticImportsAlphabetically" value="true"/>
            <property name="severity" value="error"/>
-           <property name="groups" value="com.google,*,java,javax"/>
+           <property name="groups" value="*"/>
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
diff --git a/glide/build.gradle b/glide/build.gradle
index cee746200..4e8216ad8 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,67 +1,142 @@
 apply plugin: 'java'
 
-evaluationDependsOn(':third_party:gif_decoder')
-evaluationDependsOn(':third_party:disklrucache')
-evaluationDependsOn(':library')
+// The paths of Android projects that should be included in the jar and javadoc.
+static def getAndroidPathsForJar() {
+    [':third_party:gif_decoder', ':library']
+}
+
+// The paths of Java projects that should be included in the jar and javadoc.
+static def getJavaPathsForJar() {
+    [':third_party:disklrucache']
+}
+
+// The paths of Android projects that should be included only in Javadoc, not in the jar.
+static def getAndroidPathsForJavadoc() {
+    [
+            ':integration:okhttp',
+            ':integration:okhttp3',
+            ':integration:volley',
+            ':integration:gifencoder'
+    ]
+}
+
+// The paths of Java projects that should be included only in Javadoc, not in the jar.
+static def getJavaPathsForJavadoc() {
+    [':annotation', ':annotation:compiler']
+}
+
+(getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).forEach {
+    evaluationDependsOn(it)
+}
+
+def asProjects(paths) {
+    paths.collect { project(it) }
+}
 
 def getAndroidSdkDirectory() {
-  project(':library').android.sdkDirectory
+    project(':library').android.sdkDirectory
 }
 
 def getAndroidCompileSdkVersion() {
-  project(':library').android.compileSdkVersion
+    project(':library').android.compileSdkVersion
+}
+
+def getInternalAndroidProjectsForJar() {
+    asProjects(getAndroidPathsForJar())
+}
+
+def getInternalJavaProjectsForJar() {
+    asProjects(getJavaPathsForJar())
+}
+
+def getInternalAndroidProjectsForJavadoc() {
+    asProjects(getAndroidPathsForJavadoc())
 }
 
-def getInternalAndroidProjects() {
-    [':third_party:gif_decoder', ':library'].collect { project(it) }
+def getInternalJavaProjectsForJavadoc() {
+    asProjects(getJavaPathsForJavadoc())
 }
-def getInternalJavaProjects() {
-    [':third_party:disklrucache'].collect { project(it) }
+
+def getReleaseVariantAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('release')
 }
 
-def getAllInternalProjects() {
-    getInternalAndroidProjects() + getInternalJavaProjects()
+def getAndroidLibraryVariantsForJar(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJar(), variantName)
 }
 
-def getReleaseVariantAndroidProjects() {
-    getAndroidLibraryVariants('release')
+def getAndroidLibraryVariantsForJavadoc(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJavadoc(), variantName)
 }
 
-def getAndroidLibraryVariants(variantName) {
-    getInternalAndroidProjects().collect { project ->
+static def getAndroidLibraryVariants(projects, variantName) {
+    projects.collect { project ->
         project.android.libraryVariants.findAll { type ->
             type.buildType.name.equalsIgnoreCase(variantName)
         }
     }.sum()
 }
 
-def getSourceFilesForVariant(variantName) {
-    getAndroidLibraryVariants(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjects().collect { it.sourceSets.main.allJava }
+def getSourceFilesForVariantJar(variantName) {
+    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+}
+
+def getSourceFilesForVariantJavadoc(variantName) {
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
 def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
-// Generate javadocs and sources containing batched documentation and sources for all internal projects.
+def getSupportJar() {
+    "${getAndroidSdkDirectory()}/extras/android/support/v4/android-support-v4.jar"
+}
+
+project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
+
+// Generate javadocs and sources containing batched documentation and sources for all internal
+// projects.
 ['release', 'debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariant(variantName)
+      from getSourceFilesForVariantJar(variantName)
     }
 
     def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
-        source = getSourceFilesForVariant(variantName)
+        source = getSourceFilesForVariantJar(variantName)
+        source += getSourceFilesForVariantJavadoc(variantName)
 
-        classpath = files(getAndroidLibraryVariants(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar())
+        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
         })
-        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }
+        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
+        })
+        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        classpathFiles += (getInternalJavaProjectsForJar().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        // Finds dependencies of Android packages that would otherwise be ignored (Volley in
+        // particular)
+        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {
+            files("${it.projectDir}/build/intermediates/classes/release")
+        }
+        classpath = files(classpathFiles)
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
-            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference")
+            links("https://square.github.io/okhttp/3.x/okhttp/")
+            links("https://square.github.io/okhttp/2.x/okhttp/")
+            // TODO: Ideally this would point to something hosted by Android.
+            links("http://afzaln.com/volley/")
+            linksOffline("http://d.android.com/reference",
+                    "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
@@ -74,23 +149,30 @@ def getAndroidJar() {
     clean.dependsOn(cleanJavadocTask)
 
     def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {
-      from javadocTask.destinationDir
+        from javadocTask.destinationDir
     } as Task
     javadocJarTask.dependsOn(javadocTask)
 }
 
 jar {
     from files(
-            getReleaseVariantAndroidProjects().collect { variant ->
+            getReleaseVariantAndroidProjectsForJar().collect { variant ->
                 variant.javaCompile.destinationDir
             }
     )
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjects().collect { it.sourceSets.main.output })
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
 }
 
-getAllInternalProjects().each { project ->
+def getAllInternalProjectBuildDeps() {
+    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
+            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
+}
+
+getAllInternalProjectBuildDeps().each { project ->
+    releaseJavadoc.dependsOn(project.tasks.assemble)
+    debugJavadoc.dependsOn(project.tasks.assemble)
     jar.dependsOn(project.tasks.build)
 }
 
@@ -102,5 +184,3 @@ artifacts {
         classifier 'sources'
     }
 }
-
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/glide/gradle.properties b/glide/gradle.properties
index f205a7f3f..ba722e44c 100644
--- a/glide/gradle.properties
+++ b/glide/gradle.properties
@@ -1,4 +1,3 @@
-POM_NAME=Glide
-POM_ARTIFACT_ID=glide
+POM_NAME=Glide Full
+POM_ARTIFACT_ID=glide-full
 POM_PACKAGING=jar
-
diff --git a/gradle.properties b/gradle.properties
index 47f269985..d8cd6407d 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,10 @@
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+
 VERSION_NAME=4.0.0-SNAPSHOT
 VERSION_MAJOR=4
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=12
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -13,26 +15,25 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
+SUPPORT_V4_VERSION=25.3.1
+SUPPORT_V7_VERSION=25.3.1
+VOLLEY_VERSION=1.0.0
+OK_HTTP_VERSION=3.0.1
+ANDROID_GRADLE_VERSION=2.3.0
 
-SUPPORT_V4_VERSION=22.1.1
-SUPPORT_V7_VERSION=22.1.1
-VOLLEY_VERSION=1.0.16
-OK_HTTP_VERSION=2.3.0
-# TODO: use this in library/build.gradle.
-ANDROID_GRADLE_VERSION=1.2.3
-
-ROBOLECTRIC_GRADLE_VERSION=1.1.0
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.0-rc3
-MOCKWEBSERVER_VERSION=2.3.0
-TRUTH_VERSION=0.25
+ROBOLECTRIC_VERSION=3.3.2
+MOCKWEBSERVER_VERSION=3.0.0-RC1
+TRUTH_VERSION=0.26
 
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
 
-COMPILE_SDK_VERSION=22
-BUILD_TOOLS_VERSION=22.0.1
-TARGET_SDK_VERSION=22
-MIN_SDK_VERSION=10
+COMPILE_SDK_VERSION=25
+BUILD_TOOLS_VERSION=25.0.2
+TARGET_SDK_VERSION=25
+MIN_SDK_VERSION=14
+
+org.gradle.jvmargs=-Xmx2048M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c97a8bdb9..941144813 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 25f7d42d7..06cc66097 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed May 20 08:28:58 PDT 2015
+#Fri Mar 31 22:27:21 PDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269e..9d82f7891 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/integration/build.gradle b/integration/build.gradle
index 5467b8ace..d4e8437e3 100644
--- a/integration/build.gradle
+++ b/integration/build.gradle
@@ -1,15 +1 @@
-evaluationDependsOnChildren()
-
-import com.android.build.gradle.api.BaseVariant
-subprojects {
-    android.libraryVariants.all { BaseVariant variant ->
-        def jarTask = project.tasks.create(name: "jar${variant.name.capitalize()}", type: Jar) {
-            from variant.javaCompile.destinationDir
-            exclude "**/R.class"
-            exclude "**/BuildConfig.class"
-            baseName "glide-${project.name}-integration"
-        }
-        jarTask.dependsOn variant.javaCompile
-        artifacts.add('archives', jarTask);
-    }
-}
+// keep an empty file to make sure Gradle recognizes the properties
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 603500c46..7219f4ffa 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,12 +1,7 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
-
-repositories {
-    mavenCentral()
-}
 
 dependencies {
-    compile project(':glide')
+    compile project(':library')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
@@ -30,7 +25,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE as int
         versionName = VERSION_NAME as String
     }
 
@@ -40,4 +34,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 15bd7b334..1ceaa1dac 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide GifEncoder Integration
 POM_ARTIFACT_ID=gifencoder-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 4ee8af211..9051d5f12 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.integration.gifencoder;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -21,7 +21,6 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
 import com.bumptech.glide.util.LogTime;
-
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -60,15 +59,17 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
+  private Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(BitmapPool bitmapPool) {
-    this(bitmapPool, FACTORY);
+  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+    this(context, bitmapPool, FACTORY);
   }
 
   // Visible for testing.
-  ReEncodingGifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
+  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
+    this.context = context;
     this.bitmapPool = bitmapPool;
     provider = new GifBitmapProvider(bitmapPool);
     this.factory = factory;
@@ -116,7 +117,7 @@ private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
 
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Re-encoded gif with " + drawable.getFrameCount() + " frames and "
+      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and "
           + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
           + " ms");
     }
@@ -157,8 +158,8 @@ private boolean writeDataDirect(ByteBuffer data, File file) {
     try {
       ByteBufferUtil.toFile(data, file);
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.WARN)) {
-        Logs.log(Log.WARN, "Failed to write gif data", e);
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to write GIF data", e);
       }
       return false;
     }
@@ -181,8 +182,9 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
       Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
-    Resource<Bitmap> transformedResource = transformation
-        .transform(bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
+    Resource<Bitmap> transformedResource =
+        transformation.transform(
+            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
     if (!bitmapResource.equals(transformedResource)) {
       bitmapResource.recycle();
     }
@@ -193,7 +195,7 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
   static class Factory {
 
     public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-      return new GifDecoder(bitmapProvider);
+      return new StandardGifDecoder(bitmapProvider);
     }
 
     public GifHeaderParser buildParser() {
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index aeddf5db1..dde1d0243 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,6 +3,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -12,8 +13,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
+import android.content.Context;
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -26,7 +28,10 @@
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -38,11 +43,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-
 /**
  * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
  */
@@ -54,8 +54,9 @@
   @Mock GifHeaderParser parser;
   @Mock AnimatedGifEncoder gifEncoder;
   @Mock Resource<Bitmap> frameResource;
-  @Mock Transformation<Bitmap> frameTransformation;
   @Mock GifDrawable gifDrawable;
+  @Mock Transformation<Bitmap> frameTransformation;
+  @Mock Resource<Bitmap> transformedResource;
 
   private ReEncodingGifResourceEncoder encoder;
   private Options options;
@@ -66,6 +67,8 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
+    Application context = RuntimeEnvironment.application;
+
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
@@ -73,7 +76,8 @@ public void setUp() {
     when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
         .thenReturn(frameResource);
 
-    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
+    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
+    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt()))
         .thenReturn(frameResource);
 
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
@@ -81,11 +85,11 @@ public void setUp() {
 
     when(resource.get()).thenReturn(gifDrawable);
 
-    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
+    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);
     options = new Options();
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
 
-    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    file = new File(context.getCacheDir(), "test");
   }
 
   @After
@@ -115,6 +119,8 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -242,12 +248,11 @@ public void testWritesTransformedBitmaps() {
     when(gifDrawable.getIntrinsicHeight()).thenReturn(expectedHeight);
 
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
-    final Resource<Bitmap> transformedResource = mock(Resource.class);
     when(transformedResource.get()).thenReturn(transformedFrame);
-    Transformation<Bitmap> transformation = mock(Transformation.class);
-    when(transformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+    when(frameTransformation.transform(
+        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
-    when(gifDrawable.getFrameTransformation()).thenReturn(transformation);
+    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
     encoder.encode(resource, file, options);
 
@@ -257,8 +262,7 @@ public void testWritesTransformedBitmaps() {
   @Test
   public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
     when(decoder.getFrameCount()).thenReturn(1);
-    Resource<Bitmap> transformedResource = mock(Resource.class);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
     when(transformedResource.get()).thenReturn(expected);
@@ -276,9 +280,8 @@ public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDiffere
   public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDifferent() {
     when(decoder.getFrameCount()).thenReturn(1);
     Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
-    Resource<Bitmap> transformedResource = mock(Resource.class);
     when(transformedResource.get()).thenReturn(expected);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
 
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
@@ -293,7 +296,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
   @Test
   public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(frameResource);
     Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
     when(frameResource.get()).thenReturn(expected);
@@ -310,6 +313,8 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   @Test
   public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
@@ -330,4 +335,8 @@ private String getEncodedData() {
       throw new RuntimeException(e);
     }
   }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
 }
diff --git a/integration/gradle.properties b/integration/gradle.properties
new file mode 100644
index 000000000..9a3b597f9
--- /dev/null
+++ b/integration/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index c70aad959..c01164e2e 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,13 +1,10 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
+    annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}"
+    compile "com.squareup.okhttp:okhttp:2.7.1"
 }
 
 android {
@@ -18,7 +15,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +24,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 636a1a822..e725ea973 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
-POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
+POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index c11d7167d..738e5c900 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,9 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.okhttp">
 
-    <application>
-        <meta-data
-            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
-            android:value="GlideModule"/>
-    </application>
+    <application />
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 738e9602d..9301703b6 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -17,7 +15,10 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
+@Deprecated
 public class OkHttpGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..5a46639f9
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 1a32b2ca2..2b1f90a78 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,32 +1,32 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Synthetic;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher.
  */
+@Deprecated
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
-  private static final String USER_AGENT_HEADER = "User-Agent";
-  private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+  private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  private InputStream stream;
-  private ResponseBody responseBody;
+  @Synthetic InputStream stream;
+  @Synthetic ResponseBody responseBody;
 
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
@@ -36,35 +36,29 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
   @Override
   public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
-    boolean isUserAgentSet = false;
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
-      isUserAgentSet |= USER_AGENT_HEADER.equalsIgnoreCase(key);
-    }
-    if (!isUserAgentSet) {
-      requestBuilder.addHeader(USER_AGENT_HEADER, DEFAULT_USER_AGENT);
     }
     Request request = requestBuilder.build();
 
     client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
       @Override
       public void onFailure(Request request, IOException e) {
-        if (Logs.isEnabled(Log.DEBUG)) {
-          Logs.log(Log.DEBUG, "OkHttp failed to obtain result", e);
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp failed to obtain result", e);
         }
         callback.onLoadFailed(e);
       }
 
       @Override
       public void onResponse(Response response) throws IOException {
+        responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
-          responseBody = response.body();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-        } else if (Logs.isEnabled(Log.DEBUG)) {
-          Logs.log(Log.DEBUG, "OkHttp got error response: " + response.code() + ", "
-              + response.message());
+        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
         }
         callback.onDataReady(stream);
       }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 05c0fe683..48468bf63 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,19 +1,19 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.squareup.okhttp.OkHttpClient;
-
 import java.io.InputStream;
 
 /**
  * A simple model loader for fetching media over http/https using OkHttp.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.
  */
+@Deprecated
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final OkHttpClient client;
@@ -66,8 +66,7 @@ public Factory(OkHttpClient client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
new file mode 100644
index 000000000..59a222795
--- /dev/null
+++ b/integration/okhttp3/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    compile project(':library')
+    annotationProcessor project(':annotation:compiler')
+
+    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
new file mode 100644
index 000000000..f241acfb1
--- /dev/null
+++ b/integration/okhttp3/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide OkHttp 3.x Integration
+POM_ARTIFACT_ID=okhttp3-integration
+POM_PACKAGING=aar
+POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/lint.xml b/integration/okhttp3/lint.xml
new file mode 100644
index 000000000..8b0842417
--- /dev/null
+++ b/integration/okhttp3/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+    <!-- See https://github.com/square/okio/issues/58 -->
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
+    </issue>
+</lint>
diff --git a/integration/okhttp3/src/main/AndroidManifest.xml b/integration/okhttp3/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..bc8e5a72c
--- /dev/null
+++ b/integration/okhttp3/src/main/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.okhttp">
+
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp3.OkHttpGlideModule"
+            android:value="GlideModule"/>
+    </application>
+</manifest>
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
new file mode 100644
index 000000000..1c05bf678
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
+ * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
+ * annotations.
+ */
+@Deprecated
+public class OkHttpGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..911b5acac
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
new file mode 100644
index 000000000..61adb97b1
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -0,0 +1,98 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.util.Log;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Synthetic;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+import okhttp3.Call;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+/**
+ * Fetches an {@link InputStream} using the okhttp library.
+ */
+public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+  private static final String TAG = "OkHttpFetcher";
+  private final Call.Factory client;
+  private final GlideUrl url;
+  @Synthetic InputStream stream;
+  @Synthetic ResponseBody responseBody;
+  private volatile Call call;
+
+  public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
+    this.client = client;
+    this.url = url;
+  }
+
+  @Override
+  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
+    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+      String key = headerEntry.getKey();
+      requestBuilder.addHeader(key, headerEntry.getValue());
+    }
+    Request request = requestBuilder.build();
+
+    call = client.newCall(request);
+    call.enqueue(new okhttp3.Callback() {
+      @Override
+      public void onFailure(Call call, IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp failed to obtain result", e);
+        }
+        callback.onLoadFailed(e);
+      }
+
+      @Override
+      public void onResponse(Call call, Response response) throws IOException {
+        responseBody = response.body();
+        if (response.isSuccessful()) {
+          long contentLength = responseBody.contentLength();
+          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
+        }
+        callback.onDataReady(stream);
+      }
+    });
+  }
+
+  @Override
+  public void cleanup() {
+    try {
+      if (stream != null) {
+        stream.close();
+      }
+    } catch (IOException e) {
+      // Ignored
+    }
+    if (responseBody != null) {
+      responseBody.close();
+    }
+  }
+
+  @Override
+  public void cancel() {
+    Call local = call;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
new file mode 100644
index 000000000..b63164a59
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import java.io.InputStream;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+
+/**
+ * A simple model loader for fetching media over http/https using OkHttp.
+ */
+public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+
+  private final Call.Factory client;
+
+  public OkHttpUrlLoader(Call.Factory client) {
+    this.client = client;
+  }
+
+  @Override
+  public boolean handles(GlideUrl url) {
+    return true;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
+      Options options) {
+    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
+  }
+
+  /**
+   * The default factory for {@link OkHttpUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile Call.Factory internalClient;
+    private Call.Factory client;
+
+    private static Call.Factory getInternalClient() {
+      if (internalClient == null) {
+        synchronized (Factory.class) {
+          if (internalClient == null) {
+            internalClient = new OkHttpClient();
+          }
+        }
+      }
+      return internalClient;
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton client.
+     */
+    public Factory() {
+      this(getInternalClient());
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using given client.
+     *
+     * @param client this is typically an instance of {@code OkHttpClient}.
+     */
+    public Factory(Call.Factory client) {
+      this.client = client;
+    }
+
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new OkHttpUrlLoader(client);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing, this instance doesn't own the client.
+    }
+  }
+}
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
new file mode 100644
index 000000000..498808a55
--- /dev/null
+++ b/integration/recyclerview/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    compile project(':library')
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
new file mode 100644
index 000000000..700106ff1
--- /dev/null
+++ b/integration/recyclerview/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide RecyclerView Integration
+POM_ARTIFACT_ID=recyclerview-integration
+POM_PACKAGING=aar
+POM_DESCRIPTION=An integration library to display images in RecyclerView.
diff --git a/integration/recyclerview/lint.xml b/integration/recyclerview/lint.xml
new file mode 100644
index 000000000..ff7e5955c
--- /dev/null
+++ b/integration/recyclerview/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+</lint>
diff --git a/integration/recyclerview/src/main/AndroidManifest.xml b/integration/recyclerview/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..0d880314c
--- /dev/null
+++ b/integration/recyclerview/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.recyclerview">
+    <application />
+</manifest>
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
new file mode 100644
index 000000000..a3fd25880
--- /dev/null
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.integration.recyclerview;
+
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.widget.AbsListView;
+import android.widget.ListView;
+
+/**
+ * Converts {@link android.support.v7.widget.RecyclerView.OnScrollListener} events to
+ * {@link AbsListView} scroll events.
+ *
+ * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
+ */
+public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
+  public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
+  private final AbsListView.OnScrollListener scrollListener;
+  private int lastFirstVisible = -1;
+  private int lastVisibleCount = -1;
+  private int lastItemCount = -1;
+
+  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+    this.scrollListener = scrollListener;
+  }
+
+  @Override
+  public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+    int listViewState;
+    switch (newState) {
+      case RecyclerView.SCROLL_STATE_DRAGGING:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL;
+        break;
+      case RecyclerView.SCROLL_STATE_IDLE:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_IDLE;
+        break;
+      case RecyclerView.SCROLL_STATE_SETTLING:
+        listViewState = ListView.OnScrollListener.SCROLL_STATE_FLING;
+        break;
+      default:
+        listViewState = UNKNOWN_SCROLL_STATE;
+    }
+
+    scrollListener.onScrollStateChanged(null /*view*/, listViewState);
+  }
+
+  @Override
+  public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+    LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
+
+    int firstVisible = layoutManager.findFirstVisibleItemPosition();
+    int visibleCount = Math.abs(firstVisible - layoutManager.findLastVisibleItemPosition());
+    int itemCount = recyclerView.getAdapter().getItemCount();
+
+    if (firstVisible != lastFirstVisible || visibleCount != lastVisibleCount
+        || itemCount != lastItemCount) {
+      scrollListener.onScroll(null, firstVisible, visibleCount, itemCount);
+      lastFirstVisible = firstVisible;
+      lastVisibleCount = visibleCount;
+      lastItemCount = itemCount;
+    }
+  }
+}
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
new file mode 100644
index 000000000..47be184a7
--- /dev/null
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.integration.recyclerview;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.support.v7.widget.RecyclerView;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.ListPreloader;
+import com.bumptech.glide.ListPreloader.PreloadModelProvider;
+import com.bumptech.glide.ListPreloader.PreloadSizeProvider;
+import com.bumptech.glide.RequestManager;
+
+/**
+ * Loads a few resources ahead in the direction of scrolling in any {@link RecyclerView} so that
+ * images are in the memory cache just before the corresponding view in created in the list. Gives
+ * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
+ * cache size.
+ *
+ * <p> Must be added as a listener to the {@link RecyclerView} using
+ * {@link RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its
+ * corresponding methods called from another
+ * {@link android.support.v7.widget.RecyclerView.OnScrollListener} to function. </p>
+ *
+ * <p> This class only works with {@link android.support.v7.widget.LinearLayoutManager} and
+ * subclasses of {@link android.support.v7.widget.LinearLayoutManager}. </p>
+ *
+ * @param <T> The type of the model being displayed in the {@link RecyclerView}.
+ */
+@SuppressWarnings("unused")
+public final class RecyclerViewPreloader<T> extends RecyclerView.OnScrollListener {
+
+  private final RecyclerToListViewScrollListener recyclerScrollListener;
+
+  /**
+   * Helper constructor that accepts an {@link Activity}.
+   */
+  public RecyclerViewPreloader(Activity activity,
+      PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link FragmentActivity}.
+   */
+  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link Fragment}.
+   */
+  public RecyclerViewPreloader(Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+
+  /**
+   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   */
+  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
+      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
+    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+  }
+  /**
+   * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
+   * of models to preload for a given position, and the request to use to load images.
+   *
+   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadDimensionProvider Provides the dimensions of images to load.
+   * @param maxPreload               Maximum number of items to preload.
+   */
+  public RecyclerViewPreloader(RequestManager requestManager,
+      PreloadModelProvider<T> preloadModelProvider,
+      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+
+    ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
+        preloadDimensionProvider, maxPreload);
+    recyclerScrollListener = new RecyclerToListViewScrollListener(listPreloader);
+  }
+
+  @Override
+  public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+    recyclerScrollListener.onScrolled(recyclerView, dx, dy);
+  }
+}
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 3a592592b..8f04a9b1a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,20 +1,16 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
-
-repositories {
-    mavenCentral()
-}
 
 dependencies {
-    compile project(':glide')
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
+    compile project(':library')
+    compile "com.android.volley:volley:${VOLLEY_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
@@ -25,7 +21,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -35,4 +30,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 0fad11225..198619280 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 85f2b5add..669e7b732 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -16,8 +14,11 @@
  *
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * information, see {@link com.bumptech.glide.module.GlideModule}.
+ *
+ * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
+@Deprecated
 public class VolleyGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
new file mode 100644
index 000000000..22f12df4e
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
+ * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class VolleyLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+  }
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
index 837efdc8a..bbc313217 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -3,7 +3,6 @@
 import com.android.volley.Request;
 import com.android.volley.Request.Priority;
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
-
 import java.io.InputStream;
 import java.util.Map;
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
deleted file mode 100644
index b1cd97f05..000000000
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.bumptech.glide.integration.volley;
-
-import com.android.volley.Request;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * TODO: contribute cancel modifications to volley and remove this class.
- *
- * A Future that represents a Volley request.
- *
- * Used by providing as your response and error listeners. For example:
- * <pre>
- * RequestFuture&lt;JSONObject&gt; future = RequestFuture.newFuture();
- * MyRequest request = new MyRequest(URL, future, future);
- *
- * // If you want to be able to cancel the request:
- * future.setRequest(requestQueue.add(request));
- *
- * // Otherwise:
- * requestQueue.add(request);
- *
- * try {
- *   JSONObject response = future.get();
- *   // do something with response
- * } catch (InterruptedException e) {
- *   // handle the error
- * } catch (ExecutionException e) {
- *   // handle the error
- * }
- * </pre>
- *
- * @param <T> The type of parsed response this future expects.
- */
-public class VolleyRequestFuture<T> implements Future<T>,
-    Response.Listener<T>,
-    Response.ErrorListener {
-  private Request<?> mRequest;
-  private boolean mResultReceived = false;
-  private T mResult;
-  private VolleyError mException;
-  private boolean mIsCancelled = false;
-
-  public static <E> VolleyRequestFuture<E> newFuture() {
-    return new VolleyRequestFuture<E>();
-  }
-
-  public synchronized void setRequest(Request<?> request) {
-    mRequest = request;
-    if (mIsCancelled && mRequest != null) {
-      mRequest.cancel();
-    }
-  }
-
-  @Override
-  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isDone()) {
-      return false;
-    }
-    mIsCancelled = true;
-    if (mRequest != null) {
-      mRequest.cancel();
-    }
-    notifyAll();
-
-    return true;
-  }
-
-  @Override
-  public T get() throws InterruptedException, ExecutionException {
-    try {
-      return doGet(null);
-    } catch (TimeoutException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override
-  public T get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
-  }
-
-  private synchronized T doGet(Long timeoutMs)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (mResultReceived) {
-      return mResult;
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (timeoutMs == null) {
-      wait(0);
-    } else if (timeoutMs > 0) {
-      wait(timeoutMs);
-    }
-
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (!mResultReceived) {
-      throw new TimeoutException();
-    }
-
-    return mResult;
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return mIsCancelled;
-  }
-
-  @Override
-  public synchronized boolean isDone() {
-    return mResultReceived || mException != null || isCancelled();
-  }
-
-  @Override
-  public synchronized void onResponse(T response) {
-    mResultReceived = true;
-    mResult = response;
-    notifyAll();
-  }
-
-  @Override
-  public synchronized void onErrorResponse(VolleyError error) {
-    mException = error;
-    notifyAll();
-  }
-}
-
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index af2e5f393..f0b4340fa 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
 import android.util.Log;
-
 import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
@@ -9,12 +8,10 @@
 import com.android.volley.Response;
 import com.android.volley.VolleyError;
 import com.android.volley.toolbox.HttpHeaderParser;
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Collections;
@@ -24,6 +21,7 @@
  * A DataFetcher backed by volley for fetching images via http.
  */
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
+  private static final String TAG = "VolleyStreamFetcher";
   public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
     @Override
     public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
@@ -93,7 +91,7 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
+   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
   public static class GlideRequest extends Request<byte[]> {
@@ -125,8 +123,8 @@ public Priority getPriority() {
 
     @Override
     protected VolleyError parseNetworkError(VolleyError volleyError) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Volley failed to retrieve response", volleyError);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Volley failed to retrieve response", volleyError);
       }
       callback.onLoadFailed(volleyError);
       return super.parseNetworkError(volleyError);
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a07ef442e..02c3c0921 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -9,7 +8,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
@@ -73,8 +71,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory factory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
     }
 
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index 6adda6f3f..b1271b9a2 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -10,7 +10,6 @@
 import static org.mockito.Mockito.when;
 
 import android.os.SystemClock;
-
 import com.android.volley.RequestQueue;
 import com.android.volley.VolleyError;
 import com.android.volley.toolbox.Volley;
@@ -18,9 +17,14 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,13 +41,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowSystemClock;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-
 /**
  * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
  * responses.
@@ -97,7 +94,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -109,7 +106,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -124,7 +121,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -162,7 +159,7 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -202,11 +199,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private DataFetcher<InputStream> getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private DataFetcher<InputStream> getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
   }
 
diff --git a/library/build.gradle b/library/build.gradle
index 0b745203f..fc59f7a8b 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 apply plugin: 'maven'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
@@ -19,21 +18,26 @@ coveralls {
 dependencies {
     compile project(':third_party:gif_decoder')
     compile project(':third_party:disklrucache')
+    compile project(':annotation')
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-
+    provided "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
     testCompile project(':testutil')
     testCompile 'com.google.guava:guava-testlib:18.0'
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 }
 
 android.testOptions.unitTests.all {
     // configure max heap size of the test JVM
     maxHeapSize = '2048m'
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        jvmArgs '-XX:MaxPermSize=2048m'
+    }
 }
 
 android {
@@ -44,8 +48,9 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
+
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -82,6 +87,10 @@ afterEvaluate {
 
     check.dependsOn('findbugs')
 
+    pmd {
+        toolVersion '5.4.0'
+    }
+
     task pmd(type: Pmd) {
         targetJdk = TargetJdk.VERSION_1_7
 
@@ -102,9 +111,9 @@ afterEvaluate {
 
     check.dependsOn('pmd')
 
-    task jacocoTestReport(type: JacocoReport, dependsOn: testDebug) {
-        def coverageSourceDirs = ['src/main/java']
-        group = "Reporting"
+   task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
+       def coverageSourceDirs = ['src/main/java']
+       group = "Reporting"
         description = "Generate Jacoco coverage reports"
 
         classDirectories = fileTree(
@@ -128,3 +137,16 @@ afterEvaluate {
         }
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
+// exclude <dependency> tag for android support-v4 library from :glide's pom
+// this will ensure that this warning will not prevent the build from completing:
+// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
+// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
+// available
+// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
+afterEvaluate {
+    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
+        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
+    }
+}
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index f929a391d..e9defbbe7 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -36,4 +36,10 @@
        <Bug pattern="DM_DEFAULT_ENCODING" />
     </Match>
 
+    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/gradle.properties b/library/gradle.properties
index 6f3b84292..b361d87c5 100644
--- a/library/gradle.properties
+++ b/library/gradle.properties
@@ -1,3 +1,7 @@
-POM_NAME=Glide Library
-POM_ARTIFACT_ID=library
+POM_NAME=Glide
+POM_ARTIFACT_ID=glide
 POM_PACKAGING=aar
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=
diff --git a/library/lint.xml b/library/lint.xml
index ff7e5955c..869eb6598 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
+    <issue id="RestrictedApi" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 01bb11a73..76249e191 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -35,4 +35,24 @@
     </rule>
 
 
+    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->
+    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"
+          message="Document empty constructor">
+
+        <properties>
+            <property name="xpath">
+                <value>
+                    <![CDATA[
+//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and
+($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false'
+ and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])]
+ ]]>
+                </value>
+            </property>
+
+        </properties>
+
+    </rule>
+
+
 </ruleset>
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 000000000..078afb542
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,6 @@
+-keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
+-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+    **[] $VALUES;
+    public *;
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
new file mode 100644
index 000000000..1c852b961
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.module.AppGlideModule;
+import java.util.Set;
+
+/**
+ * A temporary interface to allow {@link AppGlideModule}s to exclude
+ * {@link com.bumptech.glide.annotation.GlideModule}s to ease the migration from
+ * {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation processing system.
+ */
+@Deprecated
+abstract class GeneratedAppGlideModule extends AppGlideModule {
+  /**
+   * This method can be removed when manifest parsing is no longer supported.
+   */
+  @Deprecated
+  @NonNull
+  abstract Set<Class<?>> getExcludedModuleClasses();
+
+  @Nullable
+  RequestManagerRetriever.RequestManagerFactory getRequestManagerFactory() {
+    return null;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 606761aa1..1fe9588f5 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,11 +1,53 @@
 package com.bumptech.glide;
 
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.request.transition.ViewPropertyTransition;
+
 /**
  * Implementation of {@link TransitionOptions} that exposes only generic methods that can be applied
  * to any resource type.
  *
  * @param <TranscodeType> The type of the resource that will be displayed.
  */
+@SuppressWarnings("PMD.UseUtilityClass")
 public final class GenericTransitionOptions<TranscodeType> extends
     TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+  /**
+   * Removes any existing animation put on the builder.
+   *
+   * @see GenericTransitionOptions#dontTransition()
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
+    return new GenericTransitionOptions<TranscodeType>().dontTransition();
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation.
+   *
+   * @see GenericTransitionOptions#transition(int)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      int viewAnimationId) {
+    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator.
+   *
+   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      ViewPropertyTransition.Animator animator) {
+    return new GenericTransitionOptions<TranscodeType>().transition(animator);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory.
+   *
+   * @see GenericTransitionOptions#transition(TransitionFactory)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      TransitionFactory<? super TranscodeType> transitionFactory) {
+    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 6e072a32c..a6ef96c89 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -11,16 +11,18 @@
 import android.net.Uri;
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
@@ -28,6 +30,7 @@
 import com.bumptech.glide.load.model.ByteArrayLoader;
 import com.bumptech.glide.load.model.ByteBufferEncoder;
 import com.bumptech.glide.load.model.ByteBufferFileLoader;
+import com.bumptech.glide.load.model.DataUrlLoader;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.MediaStoreFileLoader;
@@ -46,6 +49,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
@@ -59,20 +63,24 @@
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.InputStream;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 /**
  * A singleton to present a simple static interface for building requests with
@@ -81,11 +89,6 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class Glide implements ComponentCallbacks2 {
-  /**
-   * 250 MB of cache.
-   */
-  static final int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
   private static volatile Glide glide;
@@ -96,8 +99,11 @@
   private final BitmapPreFiller bitmapPreFiller;
   private final GlideContext glideContext;
   private final Registry registry;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool arrayPool;
+  private final RequestManagerRetriever requestManagerRetriever;
+  private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
+  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
 
   /**
    * Returns a directory with a default name in the private cache directory of the application to
@@ -106,6 +112,7 @@
    * @param context A context.
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
+  @Nullable
   public static File getPhotoCacheDir(Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
@@ -118,6 +125,7 @@ public static File getPhotoCacheDir(Context context) {
    * @param cacheName The name of the subdirectory in which to store the cache.
    * @see #getPhotoCacheDir(android.content.Context)
    */
+  @Nullable
   public static File getPhotoCacheDir(Context context, String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
@@ -143,17 +151,7 @@ public static Glide get(Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
-          Context applicationContext = context.getApplicationContext();
-          List<GlideModule> modules = new ManifestParser(applicationContext).parse();
-
-          GlideBuilder builder = new GlideBuilder(applicationContext);
-          for (GlideModule module : modules) {
-            module.applyOptions(applicationContext, builder);
-          }
-          glide = builder.createGlide();
-          for (GlideModule module : modules) {
-            module.registerComponents(applicationContext, glide.registry);
-          }
+          initGlide(context);
         }
       }
     }
@@ -161,34 +159,134 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  // For testing.
-  static void tearDown() {
+  @VisibleForTesting
+  public static void init(Glide glide) {
+    Glide.glide = glide;
+  }
+
+  @VisibleForTesting
+  public static void tearDown() {
     glide = null;
   }
 
+  @SuppressWarnings("deprecation")
+  private static void initGlide(Context context) {
+    Context applicationContext = context.getApplicationContext();
+
+    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+    List<GlideModule> manifestModules = Collections.emptyList();
+    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
+      manifestModules = new ManifestParser(applicationContext).parse();
+    }
+
+    if (annotationGeneratedModule != null
+        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
+      Set<Class<?>> excludedModuleClasses =
+          annotationGeneratedModule.getExcludedModuleClasses();
+      for (Iterator<GlideModule> iterator = manifestModules.iterator(); iterator.hasNext();) {
+        GlideModule current = iterator.next();
+        if (!excludedModuleClasses.contains(current.getClass())) {
+          continue;
+        }
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+        }
+        iterator.remove();
+      }
+    }
+
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      for (GlideModule glideModule : manifestModules) {
+        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
+      }
+    }
+
+    RequestManagerRetriever.RequestManagerFactory factory =
+        annotationGeneratedModule != null
+            ? annotationGeneratedModule.getRequestManagerFactory() : null;
+    GlideBuilder builder = new GlideBuilder()
+        .setRequestManagerFactory(factory);
+    for (GlideModule module : manifestModules) {
+      module.applyOptions(applicationContext, builder);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.applyOptions(applicationContext, builder);
+    }
+    glide = builder.build(applicationContext);
+    for (GlideModule module : manifestModules) {
+      module.registerComponents(applicationContext, glide.registry);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.registerComponents(applicationContext, glide.registry);
+    }
+  }
+
+  @Nullable
+  @SuppressWarnings({"unchecked", "deprecation"})
+  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+    GeneratedAppGlideModule result = null;
+    try {
+      Class<GeneratedAppGlideModule> clazz =
+          (Class<GeneratedAppGlideModule>)
+              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+      result = clazz.newInstance();
+    } catch (ClassNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:glide:compiler"
+            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
+            + " LibraryGlideModules will be silently ignored");
+      }
+    } catch (InstantiationException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    } catch (IllegalAccessException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    }
+    return result;
+  }
+
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      Context context, DecodeFormat decodeFormat) {
+  Glide(
+      Context context,
+      Engine engine,
+      MemoryCache memoryCache,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      RequestManagerRetriever requestManagerRetriever,
+      ConnectivityMonitorFactory connectivityMonitorFactory,
+      int logLevel,
+      RequestOptions defaultRequestOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.requestManagerRetriever = requestManagerRetriever;
+    this.connectivityMonitorFactory = connectivityMonitorFactory;
+
+    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
-    Resources resources = context.getResources();
+    final Resources resources = context.getResources();
 
-    Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, byteArrayPool);
-    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,
-        byteArrayPool);
-    registry = new Registry(context)
-        .register(ByteBuffer.class, new ByteBufferEncoder())
-        .register(InputStream.class, new StreamEncoder(byteArrayPool))
+    registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
+
+    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+        resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    ByteBufferGifDecoder byteBufferGifDecoder =
+        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+
+    registry.register(ByteBuffer.class, new ByteBufferEncoder())
+        .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(ByteBuffer.class, Bitmap.class,
             new ByteBufferBitmapDecoder(downsampler))
         .append(InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, byteArrayPool))
+            new StreamBitmapDecoder(downsampler, arrayPool))
         .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
         .register(Bitmap.class, new BitmapEncoder())
         /* GlideBitmapDrawables */
@@ -197,16 +295,16 @@ static void tearDown() {
                 new ByteBufferBitmapDecoder(downsampler)))
         .append(InputStream.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, byteArrayPool)))
+                new StreamBitmapDecoder(downsampler, arrayPool)))
         .append(ParcelFileDescriptor.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
         .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
-        /* Gifs */
+        /* GIFs */
         .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, byteArrayPool))
+            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .register(GifDrawable.class, new GifDrawableEncoder())
-        /* Gif Frames */
+        /* GIF Frames */
         .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
         .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
         /* Files */
@@ -217,24 +315,37 @@ static void tearDown() {
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
         .append(File.class, File.class, new UnitModelLoader.Factory<File>())
         /* Models */
-        .register(new InputStreamRewinder.Factory(byteArrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(Integer.class, ParcelFileDescriptor.class,
-            new ResourceLoader.FileDescriptorFactory())
+        .register(new InputStreamRewinder.Factory(arrayPool))
+        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                int.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                Integer.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+        .append(
+                Uri.class,
+                ParcelFileDescriptor.class,
+                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(
+            Uri.class,
+             InputStream.class,
+             new UriLoader.StreamFactory(context.getContentResolver()))
+        .append(Uri.class, ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
@@ -245,9 +356,8 @@ static void tearDown() {
         .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
-    RequestOptions options = new RequestOptions().format(decodeFormat);
-    glideContext =
-        new GlideContext(context, registry, imageViewTargetFactory, options, engine, this);
+    glideContext = new GlideContext(context, registry, imageViewTargetFactory,
+        defaultRequestOptions, engine, this, logLevel);
   }
 
   /**
@@ -273,8 +383,19 @@ public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
-  public ByteArrayPool getByteArrayPool() {
-    return byteArrayPool;
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  /**
+   * @return The context associated with this instance.
+   */
+  public Context getContext() {
+    return glideContext.getBaseContext();
+  }
+
+  ConnectivityMonitorFactory getConnectivityMonitorFactory() {
+    return connectivityMonitorFactory;
   }
 
   GlideContext getGlideContext() {
@@ -317,9 +438,12 @@ public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void clearMemory() {
-    bitmapPool.clearMemory();
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
     memoryCache.clearMemory();
-    byteArrayPool.clearMemory();
+    bitmapPool.clearMemory();
+    arrayPool.clearMemory();
   }
 
   /**
@@ -328,9 +452,12 @@ public void clearMemory() {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void trimMemory(int level) {
-    bitmapPool.trimMemory(level);
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.trimMemory(level);
-    byteArrayPool.trimMemory(level);
+    bitmapPool.trimMemory(level);
+    arrayPool.trimMemory(level);
   }
 
   /**
@@ -345,6 +472,14 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
+
+  /**
+   * Internal method.
+   */
+  public RequestManagerRetriever getRequestManagerRetriever() {
+    return requestManagerRetriever;
+  }
+
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
@@ -354,10 +489,28 @@ public void clearDiskCache() {
    * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
    * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
    * to change the default. </p>
+   *
+   * @return the previous MemoryCategory used by Glide.
    */
-  public void setMemoryCategory(MemoryCategory memoryCategory) {
+  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
     bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
+    MemoryCategory oldCategory = this.memoryCategory;
+    this.memoryCategory = memoryCategory;
+    return oldCategory;
+  }
+
+  private static RequestManagerRetriever getRetriever(@Nullable Context context) {
+    // Context could be null for other reasons (ie the user passes in null), but in practice it will
+    // only occur due to errors with the Fragment lifecycle.
+    Preconditions.checkNotNull(
+        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+            + "returns null (which usually occurs when getActivity() is called before the Fragment "
+            + "is attached or after the Fragment is destroyed).");
+    return Glide.get(context).getRequestManagerRetriever();
   }
 
   /**
@@ -383,8 +536,7 @@ public void setMemoryCategory(MemoryCategory memoryCategory) {
    * @see #with(android.support.v4.app.FragmentActivity)
    */
   public static RequestManager with(Context context) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(context);
+    return getRetriever(context).get(context);
   }
 
   /**
@@ -395,8 +547,7 @@ public static RequestManager with(Context context) {
    * @return A RequestManager for the given activity that can be used to start a load.
    */
   public static RequestManager with(Activity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -408,8 +559,7 @@ public static RequestManager with(Activity activity) {
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
   public static RequestManager with(FragmentActivity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -419,10 +569,8 @@ public static RequestManager with(FragmentActivity activity) {
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public static RequestManager with(android.app.Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
@@ -434,8 +582,31 @@ public static RequestManager with(android.app.Fragment fragment) {
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
   public static RequestManager with(Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
+   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   *
+   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
+   * is a child of the View returned by the {@link Fragment#getView()}} method.
+   *
+   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
+   * variants unless you're loading in a View subclass.
+   *
+   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after
+   * the View is attached.
+   *
+   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
+   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
+   * avoiding entirely or using the {@link Fragment}s from the support library instead.
+   *
+   * @param view The view to search for a containing Fragment or Activity from.
+   * @return A RequestManager that can be used to start a load.
+   */
+  public static RequestManager with(View view) {
+    return getRetriever(view.getContext()).get(view);
   }
 
   public Registry getRegistry() {
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index b233827d3..784aa08b9 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,41 +1,43 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.os.Build;
-
+import android.support.annotation.Nullable;
+import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
+import com.bumptech.glide.request.RequestOptions;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
-public class GlideBuilder {
-  private final Context context;
-
+public final class GlideBuilder {
   private Engine engine;
   private BitmapPool bitmapPool;
-  private ByteArrayPool byteArrayPool;
+  private ArrayPool arrayPool;
   private MemoryCache memoryCache;
   private GlideExecutor sourceExecutor;
   private GlideExecutor diskCacheExecutor;
-  private DecodeFormat decodeFormat;
   private DiskCache.Factory diskCacheFactory;
   private MemorySizeCalculator memorySizeCalculator;
-
-  public GlideBuilder(Context context) {
-    this.context = context.getApplicationContext();
-  }
+  private ConnectivityMonitorFactory connectivityMonitorFactory;
+  private int logLevel = Log.INFO;
+  private RequestOptions defaultRequestOptions = new RequestOptions();
+  @Nullable
+  private RequestManagerFactory requestManagerFactory;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -50,14 +52,14 @@ public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
   }
 
   /**
-   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
    * and retrieved as needed.
    *
-   * @param byteArrayPool The pool to use.
+   * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {
-    this.byteArrayPool = byteArrayPool;
+  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
     return this;
   }
 
@@ -98,7 +100,7 @@ public DiskCache build() {
    * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
    * com.bumptech.glide.load.engine.Resource} data on disk.
    *
-   * @param diskCacheFactory The disk cche factory to use.
+   * @param diskCacheFactory The disk cache factory to use.
    * @return This builder.
    */
   public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
@@ -111,7 +113,7 @@ public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
    * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
    * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly. </p>
+   * for thumbnail requests to work properly.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
@@ -128,7 +130,7 @@ public GlideBuilder setResizeExecutor(GlideExecutor service) {
    * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
    *
    * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly. </p>
+   * for thumbnail requests to work properly.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
@@ -140,6 +142,21 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
     return this;
   }
 
+  /**
+   * Sets the default {@link RequestOptions} to use for all loads across the app.
+   *
+   * <p>Applying additional options with {@link
+   * RequestBuilder#apply(RequestOptions)} will override defaults
+   * set here.
+   *
+   * @param requestOptions The options to use by default.
+   * @return This builder.
+   */
+  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
+    this.defaultRequestOptions = requestOptions;
+    return this;
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
    * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
@@ -148,16 +165,14 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * <p> Decode format is always a suggestion, not a requirement. See {@link
    * com.bumptech.glide.load.DecodeFormat} for more details. </p>
    *
-   * <p> If you instantiate and use a custom decoder, it will use {@link
-   * com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default. </p>
-   *
-   * <p> Calls to this method are ignored on KitKat and Lollipop. See #301. </p>
-   *
    * @param decodeFormat The format to use.
    * @return This builder.
+   *
+   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead.
    */
+  @Deprecated
   public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-    this.decodeFormat = decodeFormat;
+    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
     return this;
   }
 
@@ -189,36 +204,89 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
     return this;
   }
 
+  /**
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
+   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
+   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   *
+   * @param factory The factory to use
+   * @return This builder.
+   */
+  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+    this.connectivityMonitorFactory = factory;
+    return this;
+  }
+
+  /**
+   * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
+   *
+   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},
+   * {@link Log#WARN}, or {@link Log#ERROR}.
+   *
+   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including
+   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged
+   * per successful request, including timing logs, although many lines may be logged for
+   * failures including multiple complete stack traces. {@link Log#INFO} means
+   * failed loads will be logged including multiple complete stack traces, but successful loads
+   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be
+   * logged. {@link Log#ERROR} means only exceptional cases will be logged.
+   *
+   * <p>All logs will be logged using the 'Glide' tag.
+   *
+   * <p>Many other debugging logs are available in individual classes. The log level supplied here
+   * only controls a small set of informative and well formatted logs. Users wishing to debug
+   * certain aspects of the library can look for individual <code>TAG</code> variables at the tops
+   * of classes and use <code>adb shell setprop log.tag.TAG</code> to enable or disable any relevant
+   * tags.
+   *
+   * @param logLevel The log level to use from {@link Log}.
+   * @return This builder.
+   */
+  public GlideBuilder setLogLevel(int logLevel) {
+    if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
+      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
+          + " Log.INFO, Log.WARN, or Log.ERROR");
+    }
+    this.logLevel = logLevel;
+    return this;
+  }
+
+  GlideBuilder setRequestManagerFactory(
+      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+    return this;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  Glide createGlide() {
+  public Glide build(Context context) {
     if (sourceExecutor == null) {
-      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
-      sourceExecutor = new GlideExecutor("source", cores);
+      sourceExecutor = GlideExecutor.newSourceExecutor();
     }
+
     if (diskCacheExecutor == null) {
-      diskCacheExecutor = new GlideExecutor("disk-cache", 1);
+      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
 
+    if (connectivityMonitorFactory == null) {
+      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
+    }
+
     if (bitmapPool == null) {
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-        int size = memorySizeCalculator.getBitmapPoolSize();
-        bitmapPool = new LruBitmapPool(size);
-      } else {
-        bitmapPool = new BitmapPoolAdapter();
-      }
+      int size = memorySizeCalculator.getBitmapPoolSize();
+      bitmapPool = new LruBitmapPool(size);
     }
 
-    if (byteArrayPool == null) {
-      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());
+    if (arrayPool == null) {
+      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
     if (memoryCache == null) {
@@ -230,13 +298,22 @@ Glide createGlide() {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
+      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
+          GlideExecutor.newUnlimitedSourceExecutor());
     }
 
-    if (decodeFormat == null) {
-      decodeFormat = DecodeFormat.DEFAULT;
-    }
+    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
+        requestManagerFactory);
 
-    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, decodeFormat);
+    return new Glide(
+        context,
+        engine,
+        memoryCache,
+        bitmapPool,
+        arrayPool,
+        requestManagerRetriever,
+        connectivityMonitorFactory,
+        logLevel,
+        defaultRequestOptions.lock());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 35da4e73c..ebf5f06fd 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -9,7 +9,6 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
@@ -24,25 +23,27 @@
   private final Handler mainHandler;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
-  private final RequestOptions options;
+  private final RequestOptions defaultRequestOptions;
   private final Engine engine;
   private final ComponentCallbacks2 componentCallbacks;
+  private final int logLevel;
 
   public GlideContext(Context context, Registry registry,
-      ImageViewTargetFactory imageViewTargetFactory, RequestOptions options, Engine engine,
-      ComponentCallbacks2 componentCallbacks) {
+      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
+      Engine engine, ComponentCallbacks2 componentCallbacks, int logLevel) {
     super(context.getApplicationContext());
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
-    this.options = options;
+    this.defaultRequestOptions = defaultRequestOptions;
     this.engine = engine;
     this.componentCallbacks = componentCallbacks;
+    this.logLevel = logLevel;
 
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
-  public RequestOptions getOptions() {
-    return options;
+  public RequestOptions getDefaultRequestOptions() {
+    return defaultRequestOptions;
   }
 
   public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
@@ -61,6 +62,10 @@ public Registry getRegistry() {
     return registry;
   }
 
+  public int getLogLevel() {
+    return logLevel;
+  }
+
   @Override
   public void onTrimMemory(int level) {
     componentCallbacks.onTrimMemory(level);
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index 53b3e54f8..9844786b3 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide;
 
-import android.app.Activity;
-import android.app.Fragment;
-import android.support.v4.app.FragmentActivity;
+import android.support.annotation.Nullable;
 import android.widget.AbsListView;
-
 import com.bumptech.glide.request.target.BaseTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.List;
 import java.util.Queue;
 
@@ -30,7 +27,7 @@
 
   private final int maxPreload;
   private final PreloadTargetQueue preloadTargetQueue;
-  private RequestManager requestManager;
+  private final RequestManager requestManager;
   private final PreloadModelProvider<T> preloadModelProvider;
   private final PreloadSizeProvider<T> preloadDimensionProvider;
 
@@ -88,44 +85,10 @@
      *
      * @param item A model
      */
+    @Nullable
     int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public ListPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public ListPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
-   */
-  public ListPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
   /**
    * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing
    * the dimensions of images to preload, the list of models to preload for a given position, and
@@ -215,7 +178,7 @@ private void preloadAdapterPosition(List<T> items, int position, boolean isIncre
   private void preloadItem(T item, int position, int i) {
     final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
     if (dimensions != null) {
-      RequestBuilder preloadRequestBuilder =
+      RequestBuilder<Object> preloadRequestBuilder =
           this.preloadModelProvider.getPreloadRequestBuilder(item);
       preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
     }
@@ -248,8 +211,11 @@ public PreloadTarget next(int width, int height) {
   }
 
   private static class PreloadTarget extends BaseTarget<Object> {
-    private int photoHeight;
-    private int photoWidth;
+    @Synthetic int photoHeight;
+    @Synthetic int photoWidth;
+
+    @Synthetic
+    PreloadTarget() { }
 
     @Override
     public void onResourceReady(Object resource, Transition<? super Object> transition) {
@@ -260,5 +226,10 @@ public void onResourceReady(Object resource, Transition<? super Object> transiti
     public void getSize(SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
+
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing because we don't retain references to SizeReadyCallbacks.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Logs.java b/library/src/main/java/com/bumptech/glide/Logs.java
deleted file mode 100644
index 2c44bcc55..000000000
--- a/library/src/main/java/com/bumptech/glide/Logs.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.bumptech.glide;
-
-import android.util.Log;
-
-/**
- * Uniform logs across Glide.
- */
-public final class Logs {
-  private static final String TAG = "Glide";
-
-  private Logs() {
-    // Utility class.
-  }
-
-  public static boolean isEnabled(int logLevel) {
-    return Log.isLoggable(TAG, logLevel);
-  }
-
-  public static void log(int logLevel, String message) {
-    log(logLevel, message, null);
-  }
-
-  public static void log(int logLevel, String message, Exception e) {
-    switch (logLevel) {
-      case Log.ERROR:
-        Log.e(TAG, message, e);
-        break;
-      case Log.WARN:
-        Log.w(TAG, message, e);
-        break;
-      case Log.INFO:
-        Log.i(TAG, message, e);
-        break;
-      case Log.DEBUG:
-        Log.d(TAG, message, e);
-        break;
-      case Log.VERBOSE:
-        Log.v(TAG, message, e);
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown level: " + logLevel);
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 4b6677f61..7468be5be 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,14 +1,13 @@
 package com.bumptech.glide;
 
-import android.content.Context;
-
+import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.data.DataRewinderRegistry;
 import com.bumptech.glide.load.engine.DecodePath;
-import com.bumptech.glide.load.engine.ExceptionListPool;
 import com.bumptech.glide.load.engine.LoadPath;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -17,11 +16,12 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.ImageHeaderParserRegistry;
 import com.bumptech.glide.provider.LoadPathCache;
 import com.bumptech.glide.provider.ModelToResourceClassCache;
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
-
+import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -36,20 +36,21 @@
   private final ResourceEncoderRegistry resourceEncoderRegistry;
   private final DataRewinderRegistry dataRewinderRegistry;
   private final TranscoderRegistry transcoderRegistry;
+  private final ImageHeaderParserRegistry imageHeaderParserRegistry;
 
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
-  private final ExceptionListPool exceptionListPool = new ExceptionListPool();
+  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
 
-  public Registry(Context context) {
-    this.modelLoaderRegistry =
-        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+  public Registry() {
+    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
+    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
   }
 
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
@@ -86,6 +87,11 @@ public Registry register(DataRewinder.Factory factory) {
     return this;
   }
 
+  public Registry register(ImageHeaderParser parser) {
+    imageHeaderParserRegistry.add(parser);
+    return this;
+  }
+
   /**
    * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
    * of the given class. Generally the best use of this method is to replace one of the default
@@ -223,6 +229,14 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  public List<ImageHeaderParser> getImageHeaderParsers() {
+    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
+    if (result.isEmpty()) {
+      throw new NoImageHeaderParserException();
+    }
+    return result;
+  }
+
   /**
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
@@ -232,7 +246,7 @@ public NoModelLoaderAvailableException(Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class modelClass, Class dataClass) {
+    public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
@@ -263,4 +277,13 @@ public MissingComponentException(String message) {
       super(message);
     }
   }
+
+  /**
+   * Thrown when no {@link ImageHeaderParser} is registered.
+   */
+  public static final class NoImageHeaderParserException extends MissingComponentException {
+    public NoImageHeaderParserException() {
+      super("Failed to find image header parser.");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 29c59a1fb..81fea6e36 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -3,10 +3,10 @@
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -18,10 +18,9 @@
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.net.URL;
 import java.util.UUID;
@@ -33,55 +32,79 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class RequestBuilder<TranscodeType> implements Cloneable {
-  private static final BaseRequestOptions DEFAULT_REQUEST_OPTIONS = new RequestOptions();
   private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
       new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =
+  // Used in generated subclasses
+  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final GlideContext context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
+  private final RequestOptions defaultRequestOptions;
+  private final Glide glide;
 
-  private BaseRequestOptions<?> requestOptions = DEFAULT_REQUEST_OPTIONS;
+  @NonNull protected RequestOptions requestOptions;
   @SuppressWarnings("unchecked")
   private TransitionOptions<?, ? super TranscodeType> transitionOptions =
       (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
 
-  private Object model;
+  @Nullable private Object model;
   // model may occasionally be null, so to enforce that load() was called, put a boolean rather
   // than relying on model not to be null.
+  @Nullable private RequestListener<TranscodeType> requestListener;
+  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
+  @Nullable private Float thumbSizeMultiplier;
   private boolean isModelSet;
-  private RequestListener<TranscodeType> requestListener;
-  private RequestBuilder<TranscodeType> thumbnailBuilder;
-  private Float thumbSizeMultiplier;
   private boolean isThumbnailBuilt;
 
-  RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.context, other.requestManager, transcodeClass);
-    model = other.model;
-    isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
-  }
-
-  RequestBuilder(GlideContext context, RequestManager requestManager,
+  protected RequestBuilder(Glide glide, RequestManager requestManager,
       Class<TranscodeType> transcodeClass) {
+    this.glide = glide;
     this.requestManager = requestManager;
-    this.context = Preconditions.checkNotNull(context);
+    this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
-    requestOptions = context.getOptions().clone();
+    this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.requestOptions = defaultRequestOptions;
   }
 
-  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {
+  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+    this(other.glide, other.requestManager, transcodeClass);
+    model = other.model;
+    isModelSet = other.isModelSet;
+    requestOptions = other.requestOptions;
+  }
+
+  /**
+   * Applies the given options to the request, options set or unset in the given options will
+   * replace those previously set in options in this class.
+   *
+   * @see RequestOptions#apply(RequestOptions)
+   * @return This request builder.
+   */
+  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    this.requestOptions = DEFAULT_REQUEST_OPTIONS.equals(this.requestOptions) ? requestOptions
-        : this.requestOptions.apply(requestOptions);
+    this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
+  protected RequestOptions getMutableOptions() {
+    return defaultRequestOptions == this.requestOptions
+        ? this.requestOptions.clone() : this.requestOptions;
+  }
+
+  /**
+   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+   * this load completes.
+   *
+   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+   * previously.
+   *
+   * @return This request builder.
+   */
   public RequestBuilder<TranscodeType> transition(
-      TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
     return this;
   }
@@ -95,7 +118,8 @@
    * @return This request builder.
    */
   @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> listener(RequestListener<TranscodeType> requestListener) {
+  public RequestBuilder<TranscodeType> listener(
+      @Nullable RequestListener<TranscodeType> requestListener) {
     this.requestListener = requestListener;
 
     return this;
@@ -115,7 +139,8 @@
    * <p> Recursive calls to thumbnail are supported. </p>
    */
   @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(RequestBuilder<TranscodeType> thumbnailRequest) {
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
     this.thumbnailBuilder = thumbnailRequest;
 
     return this;
@@ -123,8 +148,8 @@
 
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the
-   * fullsize load, the thumbnail will be shown. If the thumbnail load completes after the fullsize
+   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
    * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
@@ -134,9 +159,9 @@
    * <p> Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the fullsize load and will not be
+   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
    * copied for the thumbnail load. </p>
    *
    * <p> Recursive calls to thumbnail are supported. </p>
@@ -155,7 +180,6 @@
     return this;
   }
 
-
   /**
    * Sets the specific model to load data for.
    *
@@ -166,11 +190,11 @@
    * @return This request builder.
    */
   @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> load(Object model) {
+  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
 
-  private RequestBuilder<TranscodeType> loadGeneric(Object model) {
+  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
     this.model = model;
     isModelSet = true;
     return this;
@@ -182,11 +206,11 @@
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
    * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create that identifies the data currently at the given String that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -195,7 +219,7 @@
    * @param string A file path, or a uri or url handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
-  public RequestBuilder<TranscodeType> load(String string) {
+  public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
   }
 
@@ -205,11 +229,11 @@
    * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
    * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create based on the data at the given Uri that will invalidate the cache
    * if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate. </p>
    *
    * @see #load(Object)
@@ -217,7 +241,7 @@
    * @param uri The Uri representing the image. Must be of a type handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
-  public RequestBuilder<TranscodeType> load(Uri uri) {
+  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
 
@@ -227,11 +251,11 @@
    * <p> Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
    * to mixin a signature you create that identifies the data currently in the File that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -239,7 +263,7 @@
    *
    * @param file The File containing the image
    */
-  public RequestBuilder<TranscodeType> load(File file) {
+  public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
 
@@ -255,14 +279,14 @@
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
-  public RequestBuilder<TranscodeType> load(Integer resourceId) {
+  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
 
@@ -276,7 +300,7 @@
    * {@link #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
-  public RequestBuilder<TranscodeType> load(URL url) {
+  public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
 
@@ -289,8 +313,8 @@
    * @param model the data to load.
    * @see #load(Object)
    */
-  public RequestBuilder<TranscodeType> load(byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new StringSignature(UUID.randomUUID().toString()))
+  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
+    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
         .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
   }
 
@@ -322,13 +346,11 @@
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
-  public <Y extends Target<TranscodeType>> Y into(Y target) {
+  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
     Util.assertMainThread();
-    if (target == null) {
-      throw new IllegalArgumentException("You must pass in a non null Target");
-    }
+    Preconditions.checkNotNull(target);
     if (!isModelSet) {
-      throw new IllegalArgumentException("You must first put a model (try #load())");
+      throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
     Request previous = target.getRequest();
@@ -358,24 +380,31 @@
    */
   public Target<TranscodeType> into(ImageView view) {
     Util.assertMainThread();
-    if (view == null) {
-      throw new IllegalArgumentException("You must pass in a non null View");
-    }
+    Preconditions.checkNotNull(view);
 
-    if (!requestOptions.isTransformationSet() && view.getScaleType() != null) {
+    if (!requestOptions.isTransformationSet()
+        && requestOptions.isTransformationAllowed()
+        && view.getScaleType() != null) {
       if (requestOptions.isLocked()) {
         requestOptions = requestOptions.clone();
       }
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop(context);
+          requestOptions.optionalCenterCrop();
+          break;
+        case CENTER_INSIDE:
+          requestOptions.optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter(context);
+          requestOptions.optionalFitCenter();
+          break;
+        case FIT_XY:
+          requestOptions.optionalCenterInside();
           break;
-        //$CASES-OMITTED$
+        case CENTER:
+        case MATRIX:
         default:
           // Do nothing.
       }
@@ -389,29 +418,65 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
-   * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
-   * resource in a blocking manner.
    * @see RequestManager#clear(Target)
+   *
+   * @deprecated Use {@link #submit(int, int)} instead.
    */
+  @Deprecated
   public FutureTarget<TranscodeType> into(int width, int height) {
+    return submit(width, height);
+  }
+
+  /**
+   * Returns a future that can be used to do a blocking get on a background thread.
+   *
+   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
+   * since the width and height will be overridden by values passed to {@link
+   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
+   * with override values are applied, or whenever you want to retrieve the image in its original
+   * size.
+   *
+   * @see #submit(int, int)
+   * @see #into(Target)
+   */
+  public FutureTarget<TranscodeType> submit() {
+    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+  }
+
+  /**
+   * Returns a future that can be used to do a blocking get on a background thread.
+   *
+   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *               previously called.
+   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *               overridden by
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *               previously called).
+   */
+  public FutureTarget<TranscodeType> submit(int width, int height) {
     final RequestFutureTarget<TranscodeType> target =
         new RequestFutureTarget<>(context.getMainHandler(), width, height);
 
-    // TODO: Currently all loads must be started on the main thread...
-    context.getMainHandler().post(new Runnable() {
-      @Override
-      public void run() {
-        if (!target.isCancelled()) {
-          into(target);
+    if (Util.isOnBackgroundThread()) {
+      context.getMainHandler().post(new Runnable() {
+        @Override
+        public void run() {
+          if (!target.isCancelled()) {
+            into(target);
+          }
         }
-      }
-    });
+      });
+    } else {
+      into(target);
+    }
 
     return target;
   }
@@ -424,11 +489,11 @@ public void run() {
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @return A {@link Target} that can be used to cancel the load via
    * {@link RequestManager#clear(Target)}.
@@ -459,7 +524,10 @@ public void run() {
    * @param target The Target that will receive the cache File when the load completes
    * @param <Y>    The type of Target.
    * @return The given Target.
+   *
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
+  @Deprecated
   public <Y extends Target<File>> Y downloadOnly(Y target) {
     return getDownloadOnlyRequest().into(target);
   }
@@ -473,12 +541,15 @@ public void run() {
    * @param height The height in pixels to use to fetch the data.
    * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
    * containing the data.
+   *
+   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
    */
+  @Deprecated
   public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().into(width, height);
+    return getDownloadOnlyRequest().submit(width, height);
   }
 
-  private RequestBuilder<File> getDownloadOnlyRequest() {
+  protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
@@ -502,7 +573,7 @@ private Request buildRequest(Target<TranscodeType> target) {
   }
 
   private Request buildRequestRecursive(Target<TranscodeType> target,
-      ThumbnailRequestCoordinator parentCoordinator,
+      @Nullable ThumbnailRequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
       Priority priority, int overrideWidth, int overrideHeight) {
     if (thumbnailBuilder != null) {
@@ -544,7 +615,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
       Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
           priority, overrideWidth, overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+      RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
       Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
@@ -560,7 +631,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
   }
 
   private Request obtainRequest(Target<TranscodeType> target,
-      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
+      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
       int overrideWidth, int overrideHeight) {
     requestOptions.lock();
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 625f85a18..3a1ecec2a 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -1,15 +1,18 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
-
-import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
@@ -24,7 +27,9 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+import java.io.File;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -41,8 +46,12 @@
 public class RequestManager implements LifecycleListener {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
-  private final GlideContext context;
-  private final Lifecycle lifecycle;
+  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
+          .skipMemoryCache(true);
+
+  protected final Glide glide;
+  @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
   private final TargetTracker targetTracker = new TargetTracker();
@@ -55,17 +64,28 @@ public void run() {
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
 
-  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
+  @NonNull
+  private RequestOptions requestOptions;
+
+  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
   }
 
-  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
-    this.context = Glide.get(context).getGlideContext();
+  // Our usage is safe here.
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  RequestManager(
+      Glide glide,
+      Lifecycle lifecycle,
+      RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker,
+      ConnectivityMonitorFactory factory) {
+    this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
 
+    final Context context = glide.getGlideContext().getBaseContext();
+
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -80,21 +100,76 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
     }
     lifecycle.addListener(connectivityMonitor);
 
-    Glide.get(context).registerRequestManager(this);
+    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
+
+    glide.registerRequestManager(this);
+  }
+
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    this.requestOptions = toSet.clone().autoClone();
+  }
+
+  private void updateRequestOptions(RequestOptions toUpdate) {
+    this.requestOptions.apply(toUpdate);
+  }
+
+  /**
+   * Updates the default {@link RequestOptions} for all loads started with this request manager
+   * with the given {@link RequestOptions}.
+   *
+   * <p>The {@link RequestOptions} provided here are applied on top of those provided via {@link
+   * GlideBuilder#setDefaultRequestOptions(RequestOptions)}. If there are conflicts, the options
+   * applied here will win. Note that this method does not mutate options provided to
+   * {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>Multiple sets of options can be applied. If there are conflicts the last {@link
+   * RequestOptions} applied will win.
+   *
+   * <p>The modified options will only be applied to loads started after this method is called.
+   *
+   * @see RequestBuilder#apply(RequestOptions)
+   *
+   * @return This request manager.
+   */
+  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
+    updateRequestOptions(requestOptions);
+    return this;
+  }
+
+  /**
+   * Replaces the default {@link RequestOptions} for all loads started with this request manager
+   * with the given {@link RequestOptions}.
+   *
+   * <p>The {@link RequestOptions} provided here replace those that have been previously provided
+   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
+   * #setDefaultRequestOptions(RequestOptions)} and {@link
+   * #applyDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
+   * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
+   * options and mutate the clone.
+   *
+   * @see #applyDefaultRequestOptions(RequestOptions)
+   *
+   * @return This request manager.
+   */
+  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
+    setRequestOptions(requestOptions);
+    return this;
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void onTrimMemory(int level) {
-    context.onTrimMemory(level);
+    glide.getGlideContext().onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void onLowMemory() {
-    context.onLowMemory();
+    glide.getGlideContext().onLowMemory();
   }
 
   /**
@@ -201,7 +276,7 @@ public void onDestroy() {
     lifecycle.removeListener(this);
     lifecycle.removeListener(connectivityMonitor);
     mainHandler.removeCallbacks(addSelfToLifecycle);
-    Glide.get(context).unregisterRequestManager(this);
+    glide.unregisterRequestManager(this);
   }
 
   /**
@@ -211,7 +286,8 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
   public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).transition(new BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);
+    return as(Bitmap.class).transition(new GenericTransitionOptions<Bitmap>())
+            .apply(DECODE_TYPE_BITMAP);
   }
 
   /**
@@ -245,6 +321,54 @@ public void onDestroy() {
     return as(Drawable.class).transition(new DrawableTransitionOptions());
   }
 
+  /**
+   * A helper method equivalent to calling {@link #asDrawable()} and then {@link
+   * RequestBuilder#load(Object)} with the given model.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  public RequestBuilder<Drawable> load(@Nullable Object model) {
+    return asDrawable().load(model);
+  }
+
+  /**
+   * Attempts always load the resource into the cache and return the {@link File} containing the
+   * cached source data.
+   *
+   * <p>This method is designed to work for remote data that is or will be cached using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
+   * recommended.
+   *
+   * @return A new request builder for downloading content to cache and returning the cache File.
+   */
+  public RequestBuilder<File> downloadOnly() {
+    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link
+   * RequestBuilder#load(Object)} with the given model.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  public RequestBuilder<File> download(@Nullable Object model) {
+    return downloadOnly().load(model);
+  }
+
+  /**
+   * Attempts to always load a {@link File} containing the resource, either using a file path
+   * obtained from the media store (for local images/videos), or using Glide's disk cache
+   * (for remote images/videos).
+   *
+   * <p>For remote content, prefer {@link #downloadOnly()}.
+   *
+   * @return A new request builder for obtaining File paths to content.
+   */
+  public RequestBuilder<File> asFile() {
+    return as(File.class).apply(skipMemoryCacheOf(true));
+  }
+
   /**
    * Attempts to load the resource using any registered
    * {@link com.bumptech.glide.load.ResourceDecoder}s
@@ -254,7 +378,7 @@ public void onDestroy() {
    * @return A new request builder for loading the given resource class.
    */
   public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(context, this, resourceClass);
+    return new RequestBuilder<>(glide, this, resourceClass);
   }
 
   /**
@@ -267,7 +391,7 @@ public void onDestroy() {
    * @param view The view to cancel loads and free resources for.
    * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
    *                                  tag.
-   * @see #clear(Target).
+   * @see #clear(Target)
    */
   public void clear(View view) {
     clear(new ClearTarget(view));
@@ -279,30 +403,43 @@ public void clear(View view) {
    *
    * @param target The Target to cancel loads for.
    */
-  public void clear(Target<?> target) {
-    Util.assertMainThread();
+  public void clear(@Nullable final Target<?> target) {
     if (target == null) {
       return;
     }
 
-    untrackOrDelegate(target);
+    if (Util.isOnMainThread()) {
+      untrackOrDelegate(target);
+    } else {
+      mainHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          clear(target);
+        }
+      });
+    }
   }
 
   private void untrackOrDelegate(Target<?> target) {
     boolean isOwnedByUs = untrack(target);
     if (!isOwnedByUs) {
-      Glide.get(context).removeFromManagers(target);
+      glide.removeFromManagers(target);
     }
   }
 
   boolean untrack(Target<?> target) {
     Request request = target.getRequest();
+    // If the Target doesn't have a request, it's already been cleared.
+    if (request == null) {
+      return true;
+    }
+
     if (requestTracker.clearRemoveAndRecycle(request)) {
       targetTracker.untrack(target);
       target.setRequest(null);
       return true;
     } else {
-      return true;
+      return false;
     }
   }
 
@@ -311,6 +448,10 @@ void track(Target<?> target, Request request) {
     requestTracker.runRequest(request);
   }
 
+  RequestOptions getDefaultRequestOptions() {
+    return requestOptions;
+  }
+
   @Override
   public String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index ea285ebf3..7768f6fcc 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -28,9 +28,9 @@ public final CHILD dontTransition() {
   }
 
   /**
-   * Sets a {@link android.view.animation} to run on the wrapped target when an resource load
-   * finishes. Will only be run if the resource was loaded asynchronously (ie was not in the memory
-   * cache)
+   * Sets an {@link android.view.animation.Animation} to run on the wrapped target when an resource
+   * load finishes.
+   * Will only be run if the resource was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
    *                        transition.
@@ -42,8 +42,8 @@ public final CHILD transition(int viewAnimationId) {
 
   /**
    * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
-   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
-   * asynchronously (ie was not in the memory cache).
+   * may be wrapping when a resource load finishes.
+   * Will only be run if the load was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
    *                 .Animator} to run.
diff --git a/library/src/main/java/com/bumptech/glide/load/DataSource.java b/library/src/main/java/com/bumptech/glide/load/DataSource.java
index e1f8d2039..699a13bfe 100644
--- a/library/src/main/java/com/bumptech/glide/load/DataSource.java
+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java
@@ -21,7 +21,6 @@
    * Indicates data was retrieved from modified content in the on device cache.
    */
   RESOURCE_DISK_CACHE,
-
   /**
    * Indicates data was retrieved from the in memory cache.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index c44ed4aa8..118d407dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load;
 
-import android.os.Build;
-
 /**
  * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for
  * {@link android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
@@ -36,6 +34,5 @@
   /**
    * The default value for DecodeFormat.
    */
-  public static final DecodeFormat DEFAULT = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-      ? PREFER_ARGB_8888 : PREFER_RGB_565;
+  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
new file mode 100644
index 000000000..6b4430c98
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+import java.io.IOException;
+
+/**
+ * Thrown when an http request fails.
+ *
+ * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so
+ * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
+ * the underlying http library.
+ */
+public final class HttpException extends IOException {
+  public static final int UNKNOWN = -1;
+  private final int statusCode;
+
+  public HttpException(int statusCode) {
+    this("Http request failed with status code: " + statusCode, statusCode);
+  }
+
+  public HttpException(String message) {
+    this(message, UNKNOWN);
+  }
+
+  public HttpException(String message, int statusCode) {
+    this(message, statusCode, null /*cause*/);
+  }
+
+  public HttpException(String message, int statusCode, @Nullable Throwable cause) {
+    super(message, cause);
+    this.statusCode = statusCode;
+  }
+
+  /**
+   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing
+   * a status code.
+   */
+  public int getStatusCode() {
+    return statusCode;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
new file mode 100644
index 000000000..6cecef3ac
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.load;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Interface for the ImageHeaderParser.
+ */
+public interface ImageHeaderParser {
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because
+   * no exif segment containing orientation data existed, or because of an I/O error attempting to
+   * read the exif segment.
+   */
+  int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  enum ImageType {
+    GIF(true),
+    JPEG(false),
+    RAW(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
+    /**
+     * Unrecognized type.
+     */
+    UNKNOWN(false);
+    private final boolean hasAlpha;
+
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+
+  ImageType getType(InputStream is) throws IOException;
+  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   * @throws IOException
+   */
+  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
new file mode 100644
index 000000000..b092e15f2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Utilities for the ImageHeaderParser.
+ */
+public final class ImageHeaderParserUtils {
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
+  // will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private ImageHeaderParserUtils() { }
+
+  /** Returns the ImageType for the given InputStream. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        ImageType type = parser.getType(is);
+        if (type != ImageType.UNKNOWN) {
+          return type;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the ImageType for the given ByteBuffer. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+      throws IOException {
+    if (buffer == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    for (ImageHeaderParser parser : parsers) {
+      ImageType type = parser.getType(buffer);
+      if (type != ImageType.UNKNOWN) {
+        return type;
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the orientation for the given InputStream. */
+  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        int orientation = parser.getOrientation(is, byteArrayPool);
+        if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
+          return orientation;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 99a177abc..c4c5d712b 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 import java.util.Arrays;
 import java.util.Collection;
@@ -24,7 +24,7 @@ public MultiTransformation(Transformation<T>... transformations) {
   }
 
   public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
-    if (transformationList.size() < 1) {
+    if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
@@ -32,11 +32,12 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(
+      Context context, Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
-      Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
+      Resource<T> transformed = transformation.transform(context, previous, outWidth, outHeight);
       if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
         previous.recycle();
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index 6896150af..a63bdc44b 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -90,6 +90,7 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
   /**
    * Returns a reasonable default to use if no other value is set, or {@code null}.
    */
+  @Nullable
   public T getDefaultValue() {
     return defaultValue;
   }
@@ -139,6 +140,8 @@ public String toString() {
   /**
    * An interface that updates a {@link MessageDigest} with the given value as part of a process to
    * generate a disk cache key.
+   *
+   * @param <T> The type of the option.
    */
   public interface CacheKeyUpdater<T> {
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 909cb3620..32aa7c227 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -2,7 +2,6 @@
 
 import android.support.v4.util.ArrayMap;
 import android.support.v4.util.SimpleArrayMap;
-
 import java.security.MessageDigest;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index 16139d879..f8e67f7e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.IOException;
 
 /**
@@ -19,7 +19,7 @@
    * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (ie a GIF decoder should verify that the image contains the GIF header block. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block. </p>
    *
    * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
    * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
@@ -54,5 +54,6 @@
    *                expected type.
    * @throws IOException
    */
+  @Nullable
   Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 315403a66..659dad412 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -8,9 +9,9 @@
  * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
  * transformation in disk caches.
  *
- * <p> Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
+ * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
  * obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. </p>
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
@@ -19,13 +20,28 @@
   /**
    * Transforms the given resource and returns the transformed resource.
    *
-   * <p> Note - If the original resource object is not returned, the original resource will be
+   * <p>If the original resource object is not returned, the original resource will be
    * recycled and it's internal resources may be reused. This means it is not safe to rely on the
    * original resource or any internal state of the original resource in any new resource that is
    * created. Usually this shouldn't occur, but if absolutely necessary either the original resource
    * object can be returned with modified internal state, or the data in the original resource can
-   * be copied into the transformed resource. </p>
+   * be copied into the transformed resource.
    *
+   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and
+   * {@link #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a
+   * simple String key an easy way to do this is to append a version number to your key. Failing to
+   * do so will mean users may see images loaded from cache that had the old version of the
+   * Transformation applied. Changing the return values of those methods will ensure that the cache
+   * key has changed and therefore that any cached resources will be re-generated using the updated
+   * Transformation.
+   *
+   * <p>During development you may need to either using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} or make sure {@link
+   * #updateDiskCacheKey(java.security.MessageDigest)} changes each time you make a change to the
+   * Transformation. Otherwise the resource you request may be loaded from disk cache and your
+   * Transformation may not be called.
+   *
+   * @param context The Application context
    * @param resource  The resource to transform.
    * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
    *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
@@ -35,5 +51,5 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
+  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 0c0c19d65..7a379c792 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -2,11 +2,8 @@
 
 import android.content.res.AssetManager;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.IOException;
 
 /**
@@ -16,6 +13,7 @@
  * @param <T> The type of data obtained from the asset path (InputStream, FileDescriptor etc).
  */
 public abstract class AssetPathFetcher<T> implements DataFetcher<T> {
+  private static final String TAG = "AssetPathFetcher";
   private final String assetPath;
   private final AssetManager assetManager;
   private T data;
@@ -30,8 +28,8 @@ public void loadData(Priority priority, DataCallback<? super T> callback) {
     try {
       data = loadResource(assetManager, assetPath);
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Failed to load data from asset manager", e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to load data from asset manager", e);
       }
       callback.onLoadFailed(e);
       return;
@@ -63,7 +61,7 @@ public DataSource getDataSource() {
 
   /**
    * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns
-   * the conrete data type returned by the AssetManager.
+   * the concrete data type returned by the AssetManager.
    *
    * @param assetManager An AssetManager to use to open the given path.
    * @param path         A string path pointing to a resource in assets to open.
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index efb600996..29f9e4cc9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 
@@ -29,10 +30,11 @@
     /**
      * Called with the loaded data if the load succeeded, or with {@code null} if the load failed.
      */
-    void onDataReady(T data);
+    void onDataReady(@Nullable T data);
 
     /**
      * Called when the load fails.
+     *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
     void onLoadFailed(Exception e);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 63914f07c..1d7ce3c2e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,47 +1,47 @@
 package com.bumptech.glide.load.data;
 
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Stores a mapping of data class to {@link com.bumptech.glide.load.data.DataRewinder.Factory} and
- * allows  registation of new types and factories.
+ * allows registration of new types and factories.
  */
 public class DataRewinderRegistry {
-  private final Map<Class, DataRewinder.Factory> rewinders = new HashMap<>();
-  private static final DataRewinder.Factory DEFAULT_FACTORY = new DataRewinder.Factory<Object>() {
-    @Override
-    public DataRewinder<Object> build(Object data) {
-      return new DefaultRewinder(data);
-    }
+  private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
+  private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
+      new DataRewinder.Factory<Object>() {
+        @Override
+        public DataRewinder<Object> build(Object data) {
+          return new DefaultRewinder(data);
+        }
 
-    @Override
-    public Class<Object> getDataClass() {
-      throw new UnsupportedOperationException("Not implemented");
-    }
-  };
+        @Override
+        public Class<Object> getDataClass() {
+          throw new UnsupportedOperationException("Not implemented");
+        }
+      };
 
-  public synchronized void register(DataRewinder.Factory factory) {
+  public synchronized void register(DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
   @SuppressWarnings("unchecked")
   public synchronized <T> DataRewinder<T> build(T data) {
     Preconditions.checkNotNull(data);
-    DataRewinder.Factory result = rewinders.get(data.getClass());
+    DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
       for (DataRewinder.Factory<?> registeredFactory : rewinders.values()) {
         if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) {
-          result = registeredFactory;
+          result = (DataRewinder.Factory<T>) registeredFactory;
           break;
         }
       }
     }
 
     if (result == null) {
-      result = DEFAULT_FACTORY;
+      result = (DataRewinder.Factory<T>) DEFAULT_FACTORY;
     }
     return result.build(data);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 6adf9ffa5..893efb440 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -2,7 +2,6 @@
 
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 76a9ea297..7d3492701 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -12,14 +11,18 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
   }
 
   @Override
   protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
+    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (assetFileDescriptor == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return assetFileDescriptor.getParcelFileDescriptor();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index c5807d54e..e441bef2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -2,14 +2,13 @@
 
 import android.text.TextUtils;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
 import com.bumptech.glide.util.LogTime;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -22,10 +21,7 @@
  */
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
-  private static final String ENCODING_HEADER = "Accept-Encoding";
-  private static final String DEFAULT_ENCODING = "identity";
   private static final int MAXIMUM_REDIRECTS = 5;
-  private static final int DEFAULT_TIMEOUT_MS = 2500;
   // Visible for testing.
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
@@ -38,8 +34,8 @@
   private InputStream stream;
   private volatile boolean isCancelled;
 
-  public HttpUrlFetcher(GlideUrl glideUrl) {
-    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
+  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
+    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
   // Visible for testing.
@@ -57,16 +53,16 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
       result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
           glideUrl.getHeaders());
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Failed to load data for url", e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
       return;
     }
 
-    if (Logs.isEnabled(Log.VERBOSE)) {
-      Logs.log(Log.VERBOSE, "Finished http url fetcher fetch in "
-          + LogTime.getElapsedMillis(startTime) + " ms and loaded " + result);
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
+          + " ms and loaded " + result);
     }
     callback.onDataReady(result);
   }
@@ -81,6 +77,7 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       try {
         if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
           throw new HttpException("In re-direct loop");
+
         }
       } catch (URISyntaxException e) {
         // Do nothing, this is best effort.
@@ -91,16 +88,15 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
     for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
       urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
     }
-    // Do our best to avoid gzip since it's both inefficient for images and also makes it more
-    // difficult for us to detect and prevent partial content rendering. See #440.
-    if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {
-      urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);
-    }
     urlConnection.setConnectTimeout(timeout);
     urlConnection.setReadTimeout(timeout);
     urlConnection.setUseCaches(false);
     urlConnection.setDoInput(true);
 
+    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
+    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
+    urlConnection.setInstanceFollowRedirects(false);
+
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
     if (isCancelled) {
@@ -172,35 +168,11 @@ public DataSource getDataSource() {
     HttpURLConnection build(URL url) throws IOException;
   }
 
-  /**
-   * Thrown when an http request fails.
-   *
-   * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so
-   * users may attempt to retry certain types of errors.
-   */
-  public static final class HttpException extends IOException {
-    public static final int UNKNOWN = -1;
-    private int statusCode;
-
-    HttpException(int statusCode) {
-      this("Http request failed with status code: " + statusCode, statusCode);
-    }
-
-    HttpException(String message) {
-      this(message, UNKNOWN);
-    }
+  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
 
-    HttpException(String message, int statusCode) {
-      super(message);
-      this.statusCode = statusCode;
-    }
+    @Synthetic
+    DefaultHttpUrlConnectionFactory() { }
 
-    public int getStatusCode() {
-      return statusCode;
-    }
-  }
-
-  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
     @Override
     public HttpURLConnection build(URL url) throws IOException {
       return (HttpURLConnection) url.openConnection();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 13d0700fd..08fce42d8 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.data;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -16,7 +15,7 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
-  InputStreamRewinder(InputStream is, ByteArrayPool byteArrayPool) {
+  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
@@ -37,9 +36,9 @@ public void cleanup() {
    * java.io.InputStream}s.
    */
   public static final class Factory implements DataRewinder.Factory<InputStream> {
-    private final ByteArrayPool byteArrayPool;
+    private final ArrayPool byteArrayPool;
 
-    public Factory(ByteArrayPool byteArrayPool) {
+    public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 07ee79604..0f6488260 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -1,14 +1,10 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -20,31 +16,31 @@
  *            java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
  */
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
+  private static final String TAG = "LocalUriFetcher";
   private final Uri uri;
-  private final Context context;
+  private final ContentResolver contentResolver;
   private T data;
 
   /**
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
-   * @param context Any {@link android.content.Context}.
+   * @param contentResolver Any {@link android.content.ContentResolver}.
    * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
-  public LocalUriFetcher(Context context, Uri uri) {
-    this.context = context.getApplicationContext();
+  public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
   public final void loadData(Priority priority, DataCallback<? super T> callback) {
-    ContentResolver contentResolver = context.getContentResolver();
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Failed to open Uri", e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to open Uri", e);
       }
       callback.onLoadFailed(e);
       return;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index 3fb7b3974..00879955f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
-
 import java.io.IOException;
 import java.io.InputStream;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index aafdc25aa..fe0eed476 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide.load.data;
 
+import android.annotation.TargetApi;
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.UriMatcher;
 import android.net.Uri;
-
+import android.os.Build;
+import android.provider.ContactsContract;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -12,14 +14,76 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  public StreamLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  /**
+   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
+   */
+  private static final int ID_CONTACTS_LOOKUP = 1;
+  /**
+   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
+   */
+  private static final int ID_CONTACTS_THUMBNAIL = 2;
+  /**
+   * A contact uri (e.g. content://com.android.contacts/contacts/38)
+   */
+  private static final int ID_CONTACTS_CONTACT = 3;
+  /**
+   * A contact display photo (high resolution) uri
+   * (e.g. content://com.android.contacts/5/display_photo)
+   */
+  private static final int ID_CONTACTS_PHOTO = 4;
+  /**
+   * Match the incoming Uri for special cases which we can handle nicely.
+   */
+  private static final UriMatcher URI_MATCHER;
+
+  static {
+    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);
+  }
+
+  public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
+    super(resolver, uri);
   }
 
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openInputStream(uri);
+    InputStream inputStream = loadResourceFromUri(uri, contentResolver);
+    if (inputStream == null) {
+      throw new FileNotFoundException("InputStream is null for " + uri);
+    }
+    return inputStream;
+  }
+
+
+  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    switch (URI_MATCHER.match(uri)) {
+      case ID_CONTACTS_CONTACT:
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_LOOKUP:
+        // If it was a Lookup uri then resolve it first, then continue loading the contact uri.
+        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
+        if (uri == null) {
+          throw new FileNotFoundException("Contact cannot be found");
+        }
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_THUMBNAIL:
+      case ID_CONTACTS_PHOTO:
+      case UriMatcher.NO_MATCH:
+      default:
+        return contentResolver.openInputStream(uri);
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
+    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
+        true /*preferHighres*/);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 3e29232bb..f7f7db337 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -1,19 +1,17 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.ExifOrientationStream;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -22,28 +20,33 @@
  * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
  * files obtained from the {@link MediaStore}.
  */
+@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
 public class ThumbFetcher implements DataFetcher<InputStream> {
-  private final Context context;
+  private static final String TAG = "MediaStoreThumbFetcher";
   private final Uri mediaStoreImageUri;
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
+  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
+
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
-    return build(context, uri, new ImageThumbnailQuery());
+    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
 
   public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
-    return build(context, uri, new VideoThumbnailQuery());
+    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));
   }
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
-    ByteArrayPool byteArrayPool = Glide.get(context).getByteArrayPool();
-    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
+    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
+        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
+        context.getContentResolver());
+    return new ThumbFetcher(uri, opener);
   }
 
   // Visible for testing.
-  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
-    this.context = context;
+  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
@@ -53,8 +56,8 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Failed to find thumbnail file", e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to find thumbnail file", e);
       }
       callback.onLoadFailed(e);
       return;
@@ -64,11 +67,11 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
   }
 
   private InputStream openThumbInputStream() throws FileNotFoundException {
-    InputStream result = opener.open(context, mediaStoreImageUri);
+    InputStream result = opener.open(mediaStoreImageUri);
 
     int orientation = -1;
     if (result != null) {
-      orientation = opener.getOrientation(context, mediaStoreImageUri);
+      orientation = opener.getOrientation(mediaStoreImageUri);
     }
 
     if (orientation != -1) {
@@ -104,6 +107,13 @@ public DataSource getDataSource() {
   }
 
   static class VideoThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    VideoThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Video.Thumbnails.DATA
     };
@@ -112,19 +122,26 @@ public DataSource getDataSource() {
         + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String videoId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { videoId },
+          new String[] {videoId},
           null /*sortOrder*/);
     }
   }
 
 
   static class ImageThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    ImageThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Images.Thumbnails.DATA,
     };
@@ -133,13 +150,13 @@ public Cursor query(Context context, Uri uri) {
         + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String imageId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { imageId },
+          new String[] {imageId},
           null /*sortOrder*/);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
index befebff43..07474cd13 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 
 interface ThumbnailQuery {
-  Cursor query(Context context, Uri uri);
+  Cursor query(Uri uri);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 9b9f899f8..323f02e17 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -1,64 +1,75 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
+import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 class ThumbnailStreamOpener {
   private static final String TAG = "ThumbStreamOpener";
   private static final FileService DEFAULT_SERVICE = new FileService();
+
   private final FileService service;
   private final ThumbnailQuery query;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
+  private final ContentResolver contentResolver;
+  private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(ThumbnailQuery query, ByteArrayPool byteArrayPool) {
-    this(DEFAULT_SERVICE, query, byteArrayPool);
+  public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
+    this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
-      ByteArrayPool byteArrayPool) {
+  public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
+      FileService service,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
     this.service = service;
     this.query = query;
     this.byteArrayPool = byteArrayPool;
+    this.contentResolver = contentResolver;
+    this.parsers = parsers;
   }
 
-  public int getOrientation(Context context, Uri uri) {
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
+  public int getOrientation(Uri uri) {
     InputStream is = null;
     try {
-      is = context.getContentResolver().openInputStream(uri);
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
+      is = contentResolver.openInputStream(uri);
+      return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+      // openInputStream can throw NPEs.
+    } catch (IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "Failed to open uri: " + uri, e);
+        Log.d(TAG, "Failed to open uri: " + uri, e);
       }
     } finally {
       if (is != null) {
-          try {
-              is.close();
-          } catch (IOException e) {
-              // Ignored.
-          }
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
       }
     }
-    return orientation;
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
   }
 
-  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
+  public InputStream open(Uri uri) throws FileNotFoundException {
     Uri thumbnailUri = null;
     InputStream inputStream = null;
 
-    final Cursor cursor = query.query(context, uri);
+    final Cursor cursor = query.query(uri);
     try {
       if (cursor == null || !cursor.moveToFirst()) {
         return null;
@@ -78,7 +89,13 @@ public InputStream open(Context context, Uri uri) throws FileNotFoundException {
       }
     }
     if (thumbnailUri != null) {
-      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
+      try {
+        inputStream = contentResolver.openInputStream(thumbnailUri);
+        // openInputStream can throw NPEs.
+      } catch (NullPointerException e) {
+        throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
+      }
     }
     return inputStream;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index bb8284dec..a97652e7d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -5,7 +5,6 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index 36e9ac5fb..e70792c74 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index 8f69c4d1b..eb7d4a4bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -1,12 +1,8 @@
 package com.bumptech.glide.load.engine;
 
-import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-
 import java.io.File;
 
 /**
@@ -19,7 +15,6 @@
  *                  Resource<Bitmap> etc).
  */
 class DataCacheWriter<DataType> implements DiskCache.Writer {
-
   private final Encoder<DataType> encoder;
   private final DataType data;
   private final Options options;
@@ -32,10 +27,6 @@
 
   @Override
   public boolean write(File file) {
-    boolean success = encoder.encode(data, file, options);
-    if (!success && Logs.isEnabled(Log.DEBUG)) {
-      Logs.log(Log.DEBUG, "Failed to write to cache");
-    }
-    return success;
+    return encoder.encode(data, file, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index 0f4833831..ae7cddb8d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -26,10 +27,10 @@
      * @param sourceKey The id of the loaded data.
      * @param data The loaded data, or null if the load failed.
      * @param fetcher The data fetcher we attempted to load from.
-     * @param dataSource The data souce we were loading from.
+     * @param dataSource The data source we were loading from.
      * @param attemptedKey The key we were loading data from (may be an alternate).
      */
-    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
+    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
         DataSource dataSource, Key attemptedKey);
 
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 285e5fe3e..bbd9504ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -12,7 +12,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.load.resource.UnitTransformation;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
@@ -137,7 +136,7 @@ boolean hasLoadPath(Class<?> dataClass) {
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
      if (result == null) {
-      if (!transformations.isEmpty() && isTransformationRequired) {
+      if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
@@ -199,8 +198,14 @@ boolean isSourceKey(Key key) {
       int size = loadData.size();
       for (int i = 0; i < size; i++) {
         LoadData<?> data = loadData.get(i);
-        cacheKeys.add(data.sourceKey);
-        cacheKeys.addAll(data.alternateKeys);
+        if (!cacheKeys.contains(data.sourceKey)) {
+          cacheKeys.add(data.sourceKey);
+        }
+        for (int j = 0; j < data.alternateKeys.size(); j++) {
+          if (!cacheKeys.contains(data.alternateKeys.get(j))) {
+            cacheKeys.add(data.alternateKeys.get(j));
+          }
+        }
       }
     }
     return cacheKeys;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 7c9c2d072..8b2abacef 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -2,9 +2,7 @@
 
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.DataSource;
@@ -17,8 +15,9 @@
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.util.LogTime;
-import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -34,37 +33,43 @@
  */
 class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,
     Runnable,
-    Comparable<DecodeJob<?>> {
+    Comparable<DecodeJob<?>>,
+    Poolable {
   private static final String TAG = "DecodeJob";
-  private static final RunReason INITIAL_RUN_REASON = RunReason.INITIALIZE;
 
+  @Synthetic final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  private final List<Exception> exceptions = new ArrayList<>();
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
-  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Exception> exceptions = new ArrayList<>();
+  @Synthetic final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  private final ReleaseManager releaseManager = new ReleaseManager();
+
   private GlideContext glideContext;
-  private Key signature;
+  @Synthetic Key signature;
   private Priority priority;
   private EngineKey loadKey;
-  private int width;
-  private int height;
-  private DiskCacheStrategy diskCacheStrategy;
-  private Options options;
+  @Synthetic int width;
+  @Synthetic int height;
+  @Synthetic DiskCacheStrategy diskCacheStrategy;
+  @Synthetic Options options;
   private Callback<R> callback;
   private int order;
   private Stage stage;
-  private RunReason runReason = INITIAL_RUN_REASON;
-  private volatile DataFetcherGenerator generator;
+  private RunReason runReason;
+  private long startFetchTime;
+  private boolean onlyRetrieveFromCache;
+
   private Thread currentThread;
-  private Key currentSourceKey;
+  @Synthetic Key currentSourceKey;
+  private Key currentAttemptingKey;
   private Object currentData;
   private DataSource currentDataSource;
   private DataFetcher<?> currentFetcher;
-  private long startFetchTime;
 
-  private volatile boolean isCancelled;
+  private volatile DataFetcherGenerator currentGenerator;
   private volatile boolean isCallbackNotified;
-  private Key currentAttemptingKey;
+  private volatile boolean isCancelled;
 
   DecodeJob(DiskCacheProvider diskCacheProvider, Pools.Pool<DecodeJob<?>> pool) {
     this.diskCacheProvider = diskCacheProvider;
@@ -84,6 +89,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
       int order) {
@@ -108,14 +114,59 @@
     this.width = width;
     this.height = height;
     this.diskCacheStrategy = diskCacheStrategy;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     this.options = options;
     this.callback = callback;
     this.order = order;
+    this.runReason = RunReason.INITIALIZE;
     return this;
   }
 
-  void release() {
+  /**
+   * Returns true if this job will attempt to decode a resource from the disk cache, and false if it
+   * will always decode from source.
+   */
+  boolean willDecodeFromCache() {
+    Stage firstStage = getNextStage(Stage.INITIALIZE);
+    return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;
+  }
+
+  /**
+   * Called when this object is no longer in use externally.
+   *
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
+   *                           is neither in progress nor will ever be called again.
+   */
+  void release(boolean isRemovedFromQueue) {
+    if (releaseManager.release(isRemovedFromQueue)) {
+      releaseInternal();
+    }
+  }
+
+  /**
+   * Called when we've finished encoding (either because the encode process is complete, or because
+   * we don't have anything to encode).
+   */
+  private void onEncodeComplete() {
+    if (releaseManager.onEncodeComplete()) {
+      releaseInternal();
+    }
+  }
+
+  /**
+   * Called when the load has failed due to a an error or a series of errors.
+   */
+  private void onLoadFailed() {
+    if (releaseManager.onFailed()) {
+      releaseInternal();
+    }
+  }
+
+  private void releaseInternal() {
+    releaseManager.reset();
+    deferredEncodeManager.clear();
     decodeHelper.clear();
+    isCallbackNotified = false;
     glideContext = null;
     signature = null;
     options = null;
@@ -123,8 +174,7 @@ void release() {
     loadKey = null;
     callback = null;
     stage = null;
-    runReason = INITIAL_RUN_REASON;
-    generator = null;
+    currentGenerator = null;
     currentThread = null;
     currentSourceKey = null;
     currentData = null;
@@ -132,7 +182,6 @@ void release() {
     currentFetcher = null;
     startFetchTime = 0L;
     isCancelled = false;
-    isCallbackNotified = false;
     exceptions.clear();
     pool.release(this);
   }
@@ -150,40 +199,9 @@ private int getPriority() {
     return priority.ordinal();
   }
 
-  /**
-   * Why we're being executed again.
-   */
-  private enum RunReason {
-    /** The first time we've been submitted. */
-    INITIALIZE,
-    /**
-     * We want to switch from the disk cache service to the source executor.
-     */
-    SWITCH_TO_SOURCE_SERVICE,
-    /**
-     * We retrieved some data on a thread we don't own and want to switch back to our thread to
-     * process the data.
-     */
-    DECODE_DATA,
-  }
-
-  /**
-   * Where we're trying to decode data from.
-   */
-  private enum Stage {
-    /** The initial stage. */
-    INITIALIZE,
-    /** Decode from a cached resource. */
-    RESOURCE_CACHE,
-    /** Decode from cached source data. */
-    DATA_CACHE,
-    /** Decode from retrieved source. */
-    SOURCE,
-  }
-
   public void cancel() {
     isCancelled = true;
-    DataFetcherGenerator local = generator;
+    DataFetcherGenerator local = currentGenerator;
     if (local != null) {
       local.cancel();
     }
@@ -202,9 +220,14 @@ public void run() {
       runWrapped();
     } catch (RuntimeException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "DecodeJob threw unexpectedly, isCancelled: " + isCancelled, e);
+        Log.d(TAG, "DecodeJob threw unexpectedly"
+            + ", isCancelled: " + isCancelled
+            + ", stage: " + stage, e);
+      }
+      // When we're encoding we've already notified our callback and it isn't safe to do so again.
+      if (stage != Stage.ENCODE) {
+        notifyFailed();
       }
-      notifyFailed();
       if (!isCancelled) {
         throw e;
       }
@@ -215,7 +238,7 @@ private void runWrapped() {
      switch (runReason) {
       case INITIALIZE:
         stage = getNextStage(Stage.INITIALIZE);
-        generator = getNextGenerator();
+        currentGenerator = getNextGenerator();
         runGenerators();
         break;
       case SWITCH_TO_SOURCE_SERVICE:
@@ -230,9 +253,6 @@ private void runWrapped() {
   }
 
   private DataFetcherGenerator getNextGenerator() {
-    if (stage == null) {
-      return null;
-    }
     switch (stage) {
       case RESOURCE_CACHE:
         return new ResourceCacheGenerator(decodeHelper, this);
@@ -240,6 +260,8 @@ private DataFetcherGenerator getNextGenerator() {
         return new DataCacheGenerator(decodeHelper, this);
       case SOURCE:
         return new SourceGenerator(decodeHelper, this);
+      case FINISHED:
+        return null;
       default:
         throw new IllegalStateException("Unrecognized stage: " + stage);
     }
@@ -249,9 +271,10 @@ private void runGenerators() {
     currentThread = Thread.currentThread();
     startFetchTime = LogTime.getLogTime();
     boolean isStarted = false;
-    while (!isCancelled && generator != null && !(isStarted = generator.startNext())) {
+    while (!isCancelled && currentGenerator != null
+        && !(isStarted = currentGenerator.startNext())) {
       stage = getNextStage(stage);
-      generator = getNextGenerator();
+      currentGenerator = getNextGenerator();
 
       if (stage == Stage.SOURCE) {
         reschedule();
@@ -259,7 +282,7 @@ private void runGenerators() {
       }
     }
     // We've run out of stages and generators, give up.
-    if ((stage == null || isCancelled) && !isStarted) {
+    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
       notifyFailed();
     }
 
@@ -271,22 +294,23 @@ private void notifyFailed() {
     setNotifiedOrThrow();
     GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
     callback.onLoadFailed(e);
+    onLoadFailed();
   }
 
-  private void notifyComplete(Resource<R> resource) {
+  private void notifyComplete(Resource<R> resource, DataSource dataSource) {
     setNotifiedOrThrow();
-    callback.onResourceReady(resource);
+    callback.onResourceReady(resource, dataSource);
   }
 
   private void setNotifiedOrThrow() {
-    Preconditions.checkArgument(!isCallbackNotified, "Already notified callback");
+    stateVerifier.throwIfRecycled();
+    if (isCallbackNotified) {
+      throw new IllegalStateException("Already notified");
+    }
     isCallbackNotified = true;
   }
 
   private Stage getNextStage(Stage current) {
-    if (current == null) {
-      return null;
-    }
     switch (current) {
       case INITIALIZE:
         return diskCacheStrategy.decodeCachedResource()
@@ -295,9 +319,13 @@ private Stage getNextStage(Stage current) {
         return diskCacheStrategy.decodeCachedData()
             ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
-        return Stage.SOURCE;
+        // Skip loading from source if the user opted to only retrieve the resource from cache.
+        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
+      case SOURCE:
+      case FINISHED:
+        return Stage.FINISHED;
       default:
-        return null;
+        throw new IllegalArgumentException("Unrecognized stage: " + current);
     }
   }
 
@@ -326,6 +354,7 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
   @Override
   public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
       DataSource dataSource) {
+    fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
     exceptions.add(exception);
@@ -338,7 +367,7 @@ public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fe
   }
 
   private void decodeFromRetrievedData() {
-    if (Logs.isEnabled(Log.VERBOSE)) {
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logWithTimeAndKey("Retrieved data", startFetchTime,
           "data: " + currentData
           + ", cache key: " + currentSourceKey
@@ -352,19 +381,37 @@ private void decodeFromRetrievedData() {
       exceptions.add(e);
     }
     if (resource != null) {
-      notifyComplete(resource);
-      cleanup();
+      notifyEncodeAndRelease(resource, currentDataSource);
     } else {
       runGenerators();
     }
   }
 
-  private void cleanup() {
-    currentData = null;
-    currentDataSource = null;
-    currentFetcher = null;
-    currentSourceKey = null;
-    currentThread = null;
+  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    if (resource instanceof Initializable) {
+      ((Initializable) resource).initialize();
+    }
+
+    Resource<R> result = resource;
+    LockedResource<R> lockedResource = null;
+    if (deferredEncodeManager.hasResourceToEncode()) {
+      lockedResource = LockedResource.obtain(resource);
+      result = lockedResource;
+    }
+
+    notifyComplete(result, dataSource);
+
+    stage = Stage.ENCODE;
+    try {
+      if (deferredEncodeManager.hasResourceToEncode()) {
+        deferredEncodeManager.encode(diskCacheProvider, options);
+      }
+    } finally {
+      if (lockedResource != null) {
+        lockedResource.unlock();
+      }
+      onEncodeComplete();
+    }
   }
 
   private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
@@ -375,7 +422,7 @@ private void cleanup() {
       }
       long startTime = LogTime.getLogTime();
       Resource<R> result = decodeFromFetcher(data, dataSource);
-      if (Logs.isEnabled(Log.VERBOSE)) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Decoded result " + result, startTime);
       }
       return result;
@@ -407,18 +454,22 @@ private void logWithTimeAndKey(String message, long startTime) {
   }
 
   private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
-    Logs.log(Log.VERBOSE,
-        message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey + (
-            extraArgs != null ? ", " + extraArgs : "") + ", thread: " + Thread.currentThread()
-            .getName());
+    Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
+        + (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
+        + Thread.currentThread().getName());
   }
 
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
 
-  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
+  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
 
-    public DecodeCallback(DataSource dataSource) {
+    @Synthetic
+    DecodeCallback(DataSource dataSource) {
       this.dataSource = dataSource;
     }
 
@@ -429,7 +480,7 @@ public DecodeCallback(DataSource dataSource) {
       Resource<Z> transformed = decoded;
       if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
         appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(decoded, width, height);
+        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
       }
       // TODO: Make this the responsibility of the Transformation.
       if (!decoded.equals(transformed)) {
@@ -446,7 +497,7 @@ public DecodeCallback(DataSource dataSource) {
         encodeStrategy = EncodeStrategy.NONE;
       }
 
-      long startEncodeTime = LogTime.getLogTime();
+      Resource<Z> result = transformed;
       boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
       if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
           encodeStrategy)) {
@@ -463,15 +514,11 @@ public DecodeCallback(DataSource dataSource) {
           throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
         }
 
-        diskCacheProvider.getDiskCache().put(key, new DataCacheWriter<>(encoder, transformed,
-            options));
-        if (Logs.isEnabled(Log.VERBOSE)) {
-          logWithTimeAndKey("Encoded resource to cache", startEncodeTime,
-              "cache key: " + key
-              + ", encode strategy: " + encodeStrategy);
-        }
+        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+        deferredEncodeManager.init(key, encoder, lockedResult);
+        result = lockedResult;
       }
-      return transformed;
+      return result;
     }
 
     @SuppressWarnings("unchecked")
@@ -480,9 +527,86 @@ public DecodeCallback(DataSource dataSource) {
     }
   }
 
+  /**
+   * Responsible for indicating when it is safe for the job to be cleared and returned to the pool.
+   */
+  private static class ReleaseManager {
+    private boolean isReleased;
+    private boolean isEncodeComplete;
+    private boolean isFailed;
+
+    @Synthetic
+    ReleaseManager() { }
+
+    synchronized boolean release(boolean isRemovedFromQueue) {
+      isReleased = true;
+      return isComplete(isRemovedFromQueue);
+    }
+
+    synchronized boolean onEncodeComplete() {
+      isEncodeComplete = true;
+      return isComplete(false /*isRemovedFromQueue*/);
+    }
+
+    synchronized boolean onFailed() {
+      isFailed = true;
+      return isComplete(false /*isRemovedFromQueue*/);
+    }
+
+    synchronized void reset() {
+      isEncodeComplete = false;
+      isReleased = false;
+      isFailed = false;
+    }
+
+    private boolean isComplete(boolean isRemovedFromQueue) {
+      return (isFailed || isRemovedFromQueue || isEncodeComplete) && isReleased;
+    }
+  }
+
+  /**
+   * Allows transformed resources to be encoded after the transcoded result is already delivered
+   * to requestors.
+   */
+  private static class DeferredEncodeManager<Z> {
+    private Key key;
+    private ResourceEncoder<Z> encoder;
+    private LockedResource<Z> toEncode;
+
+    @Synthetic
+    DeferredEncodeManager() { }
+
+    // We just need the encoder and resource type to match, which this will enforce.
+    @SuppressWarnings("unchecked")
+    <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
+      this.key = key;
+      this.encoder = (ResourceEncoder<Z>) encoder;
+      this.toEncode = (LockedResource<Z>) toEncode;
+    }
+
+    void encode(DiskCacheProvider diskCacheProvider, Options options) {
+      try {
+        diskCacheProvider.getDiskCache().put(key,
+            new DataCacheWriter<>(encoder, toEncode, options));
+      } finally {
+        toEncode.unlock();
+      }
+    }
+
+    boolean hasResourceToEncode() {
+      return toEncode != null;
+    }
+
+    void clear() {
+      key = null;
+      encoder = null;
+      toEncode = null;
+    }
+  }
+
   interface Callback<R> {
 
-    void onResourceReady(Resource<R> resource);
+    void onResourceReady(Resource<R> resource, DataSource dataSource);
 
     void onLoadFailed(GlideException e);
 
@@ -492,4 +616,39 @@ public DecodeCallback(DataSource dataSource) {
   interface DiskCacheProvider {
     DiskCache getDiskCache();
   }
+
+  /**
+   * Why we're being executed again.
+   */
+  private enum RunReason {
+    /** The first time we've been submitted. */
+    INITIALIZE,
+    /**
+     * We want to switch from the disk cache service to the source executor.
+     */
+    SWITCH_TO_SOURCE_SERVICE,
+    /**
+     * We retrieved some data on a thread we don't own and want to switch back to our thread to
+     * process the data.
+     */
+    DECODE_DATA,
+  }
+
+  /**
+   * Where we're trying to decode data from.
+   */
+  private enum Stage {
+    /** The initial stage. */
+    INITIALIZE,
+    /** Decode from a cached resource. */
+    RESOURCE_CACHE,
+    /** Decode from cached source data. */
+    DATA_CACHE,
+    /** Decode from retrieved source. */
+    SOURCE,
+    /** Encoding transformed resources after a successful load. */
+    ENCODE,
+    /** No more viable stages. */
+    FINISHED,
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index d5ac09050..6198bc5f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.v4.util.Pools.Pool;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -21,16 +19,17 @@
  *                       returned to the caller.
  */
 public class DecodePath<DataType, ResourceType, Transcode> {
+  private static final String TAG = "DecodePath";
   private final Class<DataType> dataClass;
   private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
   private final ResourceTranscoder<ResourceType, Transcode> transcoder;
-  private final ExceptionListPool listPool;
+  private final Pool<List<Exception>> listPool;
   private final String failureMessage;
 
   public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, ExceptionListPool listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
@@ -68,8 +67,8 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
           result = decoder.decode(data, width, height, options);
         }
       } catch (IOException e) {
-        if (Logs.isEnabled(Log.VERBOSE)) {
-          Logs.log(Log.VERBOSE, "Failed to decode data for " + decoder, e);
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
         exceptions.add(e);
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index 6f40a91a3..b110e3121 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -6,13 +6,13 @@
 /**
  * Set of available caching strategies for media.
  */
-public enum DiskCacheStrategy {
+public abstract class DiskCacheStrategy {
 
   /**
    * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with
    * {@link #RESOURCE} only.
    */
-  ALL(true /*decodeCachedData*/, true /*decodeCachedResource*/) {
+  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
       return dataSource == DataSource.REMOTE;
@@ -23,11 +23,22 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
         EncodeStrategy encodeStrategy) {
       return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
     }
-  },
+
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
+
   /**
    * Saves no data to cache.
    */
-  NONE(false /*decodeCachedData*/, false /*decodeCachedResource*/) {
+  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
       return false;
@@ -38,11 +49,22 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
         EncodeStrategy encodeStrategy) {
       return false;
     }
-  },
+
+    @Override
+    public boolean decodeCachedResource() {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return false;
+    }
+  };
+
   /**
    * Writes retrieved data directly to the disk cache before it's decoded.
    */
-  DATA(true /*decodeCachedData*/, false /*decodeCachedResource*/) {
+  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
       return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
@@ -53,11 +75,22 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
         EncodeStrategy encodeStrategy) {
       return false;
     }
-  },
+
+    @Override
+    public boolean decodeCachedResource() {
+      return false;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
+
   /**
    * Writes resources to disk after they've been decoded.
    */
-  RESOURCE(false /*decodeCachedData*/, true /*decodeCachedResource*/) {
+  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
       return false;
@@ -68,7 +101,18 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
         EncodeStrategy encodeStrategy) {
       return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
     }
-  },
+
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
+    }
+
+    @Override
+    public boolean decodeCachedData() {
+      return false;
+    }
+  };
+
   /**
    * Tries to intelligently choose a strategy based on the data source of the
    * {@link com.bumptech.glide.load.data.DataFetcher} and the
@@ -76,7 +120,7 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
    * {@link com.bumptech.glide.load.ResourceEncoder} (if an
    * {@link com.bumptech.glide.load.ResourceEncoder} is available).
    */
-  AUTOMATIC(true /*decodeCachedData*/, true /*decodeCachedResource*/) {
+  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
       return dataSource == DataSource.REMOTE;
@@ -89,24 +133,34 @@ public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource d
           || dataSource == DataSource.LOCAL)
           && encodeStrategy == EncodeStrategy.TRANSFORMED;
     }
-  };
 
-  private final boolean decodeCachedData;
-  private final boolean decodeCachedResource;
+    @Override
+    public boolean decodeCachedResource() {
+      return true;
+    }
 
-  DiskCacheStrategy(boolean decodeCachedData,
-      boolean decodeCachedResource) {
-    this.decodeCachedData = decodeCachedData;
-    this.decodeCachedResource = decodeCachedResource;
-  }
+    @Override
+    public boolean decodeCachedData() {
+      return true;
+    }
+  };
 
   /**
    * Returns true if this request should cache the original unmodified data.
+   *
+   * @param dataSource Indicates where the data was originally retrieved.
    */
   public abstract boolean isDataCacheable(DataSource dataSource);
 
   /**
    * Returns true if this request should cache the final transformed resource.
+   *
+   * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an
+   *                                alternative, rather than the primary, cache key.
+   * @param dataSource Indicates where the data used to decode the resource was originally
+   *                   retrieved.
+   * @param encodeStrategy The {@link EncodeStrategy} the {@link
+   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
    */
   public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,
       DataSource dataSource, EncodeStrategy encodeStrategy);
@@ -114,14 +168,10 @@ public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,
   /**
    * Returns true if this request should attempt to decode cached resource data.
    */
-  public boolean decodeCachedResource() {
-    return decodeCachedResource;
-  }
+  public abstract boolean decodeCachedResource();
 
   /**
    * Returns true if this request should attempt to decode cached source data.
    */
-  public boolean decodeCachedData() {
-    return decodeCachedData;
-  }
+  public abstract boolean decodeCachedData();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 13ce29f2a..1dc070d50 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -4,9 +4,9 @@
 import android.os.MessageQueue;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
@@ -16,8 +16,9 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
+import com.bumptech.glide.util.pool.FactoryPools;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
@@ -31,7 +32,7 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob> jobs;
+  private final Map<Key, EngineJob<?>> jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
@@ -48,10 +49,10 @@
    * Allows a request to indicate it no longer is interested in a given load.
    */
   public static class LoadStatus {
-    private final EngineJob engineJob;
+    private final EngineJob<?> engineJob;
     private final ResourceCallback cb;
 
-    public LoadStatus(ResourceCallback cb, EngineJob engineJob) {
+    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
       this.cb = cb;
       this.engineJob = engineJob;
     }
@@ -61,17 +62,27 @@ public void cancel() {
     }
   }
 
-  public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
-        null, null);
+  public Engine(MemoryCache memoryCache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor) {
+    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+        null, null, null, null, null, null);
   }
 
   // Visible for testing.
-  Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+  Engine(MemoryCache cache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      Map<Key, EngineJob<?>> jobs,
+      EngineKeyFactory keyFactory,
+      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      EngineJobFactory engineJobFactory,
+      DecodeJobFactory decodeJobFactory,
+      ResourceRecycler resourceRecycler) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
@@ -91,7 +102,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
+          sourceUnlimitedExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -141,6 +153,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       boolean isTransformationRequired,
       Options options,
       boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
+      boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -150,7 +164,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
 
     EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
     if (cached != null) {
-      cb.onResourceReady(cached);
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Loaded resource from cache", startTime, key);
       }
@@ -159,14 +173,14 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
 
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
-      cb.onResourceReady(active);
+      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
       return null;
     }
 
-    EngineJob current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key);
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -175,7 +189,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
+    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
+        useUnlimitedSourceExecutorPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
         glideContext,
         model,
@@ -189,6 +204,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
         diskCacheStrategy,
         transformations,
         isTransformationRequired,
+        onlyRetrieveFromCache,
         options,
         engineJob);
     jobs.put(key, engineJob);
@@ -241,22 +257,22 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
-    final EngineResource result;
+    final EngineResource<?> result;
     if (cached == null) {
       result = null;
     } else if (cached instanceof EngineResource) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
-      result = (EngineResource) cached;
+      result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
     }
     return result;
   }
 
-  public void release(Resource resource) {
+  public void release(Resource<?> resource) {
     Util.assertMainThread();
     if (resource instanceof EngineResource) {
-      ((EngineResource) resource).release();
+      ((EngineResource<?>) resource).release();
     } else {
       throw new IllegalArgumentException("Cannot release anything but an EngineResource");
     }
@@ -281,7 +297,7 @@ public void onEngineJobComplete(Key key, EngineResource<?> resource) {
   @Override
   public void onEngineJobCancelled(EngineJob engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key);
     if (engineJob.equals(current)) {
       jobs.remove(key);
     }
@@ -343,7 +359,7 @@ public DiskCache getDiskCache() {
   }
 
   private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    private final Key key;
+    @Synthetic final Key key;
 
     public ResourceWeakReference(Key key, EngineResource<?> r,
         ReferenceQueue<? super EngineResource<?>> q) {
@@ -377,9 +393,14 @@ public boolean queueIdle() {
 
   // Visible for testing.
   static class DecodeJobFactory {
-    private static final String TAG = "DecodeJobFactory";
-    private final DecodeJob.DiskCacheProvider diskCacheProvider;
-    private final Pools.Pool<DecodeJob<?>> pool = new Pools.SimplePool<>(JOB_POOL_SIZE);
+    @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+        new FactoryPools.Factory<DecodeJob<?>>() {
+          @Override
+          public DecodeJob<?> create() {
+            return new DecodeJob<Object>(diskCacheProvider, pool);
+          }
+        });
     private int creationOrder;
 
     DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
@@ -399,15 +420,10 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
       DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
-      if (result == null) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "Create new job");
-        }
-        result = new DecodeJob<>(diskCacheProvider, pool);
-      }
       return result.init(
           glideContext,
           model,
@@ -421,6 +437,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          onlyRetrieveFromCache,
           options,
           callback,
           creationOrder++);
@@ -429,29 +446,32 @@ public boolean queueIdle() {
 
   // Visible for testing.
   static class EngineJobFactory {
-    private static final String TAG = "EngineJobFactory";
-    private final GlideExecutor diskCacheExecutor;
-    private final GlideExecutor sourceExecutor;
-    private final EngineJobListener listener;
-    private final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(JOB_POOL_SIZE);
+    @Synthetic final GlideExecutor diskCacheExecutor;
+    @Synthetic final GlideExecutor sourceExecutor;
+    @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final EngineJobListener listener;
+    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+        new FactoryPools.Factory<EngineJob<?>>() {
+          @Override
+          public EngineJob<?> create() {
+            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+                listener, pool);
+          }
+        });
 
     EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        EngineJobListener listener) {
+        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
+      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.listener = listener;
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
+    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool) {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      if (result == null) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "Create new job");
-        }
-        result = new EngineJob<>(diskCacheExecutor, sourceExecutor, listener, pool);
-      }
-      return result.init(key, isMemoryCacheable);
+      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 3ea6cdc0f..6c193eafc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -4,12 +4,14 @@
 import android.os.Looper;
 import android.os.Message;
 import android.support.v4.util.Pools;
-
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
+import com.bumptech.glide.util.pool.FactoryPools.Poolable;
+import com.bumptech.glide.util.pool.StateVerifier;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -17,25 +19,32 @@
  * A class that manages a load by adding and removing callbacks for for the load and notifying
  * callbacks when the load completes.
  */
-class EngineJob<R> implements DecodeJob.Callback<R> {
+class EngineJob<R> implements DecodeJob.Callback<R>,
+    Poolable {
   private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
   private static final Handler MAIN_THREAD_HANDLER =
       new Handler(Looper.getMainLooper(), new MainThreadCallback());
 
   private static final int MSG_COMPLETE = 1;
   private static final int MSG_EXCEPTION = 2;
+  // Used when we realize we're cancelled on a background thread in reschedule and can recycle
+  // immediately rather than waiting for a result or an error.
+  private static final int MSG_CANCELLED = 3;
 
   private final List<ResourceCallback> cbs = new ArrayList<>(2);
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final Pools.Pool<EngineJob<?>> pool;
   private final EngineResourceFactory engineResourceFactory;
   private final EngineJobListener listener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
+  private final GlideExecutor sourceUnlimitedExecutor;
+
   private Key key;
   private boolean isCacheable;
-
-  private boolean isCancelled;
+  private boolean useUnlimitedSourceGeneratorPool;
   private Resource<?> resource;
+  private DataSource dataSource;
   private boolean hasResource;
   private GlideException exception;
   private boolean hasLoadFailed;
@@ -43,46 +52,52 @@
   // status.
   private List<ResourceCallback> ignoredCallbacks;
   private EngineResource<?> engineResource;
-
   private DecodeJob<R> decodeJob;
-  private boolean isReleased;
+
+  // Checked primarily on the main thread, but also on other threads in reschedule.
+  private volatile boolean isCancelled;
 
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+        DEFAULT_FACTORY);
   }
 
   // Visible for testing.
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
+    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
   // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable) {
+  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
     this.key = key;
     this.isCacheable = isCacheable;
-    isReleased = false;
+    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     return this;
   }
 
   public void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    diskCacheExecutor.execute(decodeJob);
+    GlideExecutor executor = decodeJob.willDecodeFromCache()
+        ? diskCacheExecutor
+        : getActiveSourceExecutor();
+    executor.execute(decodeJob);
   }
 
   public void addCallback(ResourceCallback cb) {
-    if (isReleased) {
-      throw new RuntimeException("Already released");
-    }
     Util.assertMainThread();
+    stateVerifier.throwIfRecycled();
     if (hasResource) {
-      cb.onResourceReady(engineResource);
+      cb.onResourceReady(engineResource, dataSource);
     } else if (hasLoadFailed) {
       cb.onLoadFailed(exception);
     } else {
@@ -91,10 +106,8 @@ public void addCallback(ResourceCallback cb) {
   }
 
   public void removeCallback(ResourceCallback cb) {
-    if (isReleased) {
-      throw new RuntimeException("Already released");
-    }
     Util.assertMainThread();
+    stateVerifier.throwIfRecycled();
     if (hasResource || hasLoadFailed) {
       addIgnoredCallback(cb);
     } else {
@@ -105,6 +118,10 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+  }
+
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
   // would cause a ConcurrentModificationException. However, we need to obey the cancellation
   // request such that if notifying a callback early in the callbacks list cancels a callback later
@@ -131,12 +148,13 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved =
-        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
+        || sourceExecutor.remove(decodeJob)
+        || sourceUnlimitedExecutor.remove(decodeJob);
     listener.onEngineJobCancelled(this, key);
 
     if (isPendingJobRemoved) {
-      release();
+      release(true /*isRemovedFromQueue*/);
     }
   }
 
@@ -145,16 +163,17 @@ boolean isCancelled() {
     return isCancelled;
   }
 
-  private void handleResultOnMainThread() {
-    if (isReleased) {
-      throw new RuntimeException("Already released");
-    }
+  @Synthetic
+  void handleResultOnMainThread() {
+    stateVerifier.throwIfRecycled();
     if (isCancelled) {
       resource.recycle();
-      release();
+      release(false /*isRemovedFromQueue*/);
       return;
     } else if (cbs.isEmpty()) {
       throw new IllegalStateException("Received a resource without any callbacks to notify");
+    } else if (hasResource) {
+      throw new IllegalStateException("Already have resource");
     }
     engineResource = engineResourceFactory.build(resource, isCacheable);
     hasResource = true;
@@ -167,17 +186,27 @@ private void handleResultOnMainThread() {
     for (ResourceCallback cb : cbs) {
       if (!isInIgnoredCallbacks(cb)) {
         engineResource.acquire();
-        cb.onResourceReady(engineResource);
+        cb.onResourceReady(engineResource, dataSource);
       }
     }
     // Our request is complete, so we can release the resource.
     engineResource.release();
 
-    release();
+    release(false /*isRemovedFromQueue*/);
   }
 
-  private void release() {
-    isReleased = true;
+  @Synthetic
+  void handleCancelledOnMainThread() {
+    stateVerifier.throwIfRecycled();
+    if (!isCancelled) {
+      throw new IllegalStateException("Not cancelled");
+    }
+    listener.onEngineJobCancelled(this, key);
+    release(false /*isRemovedFromQueue*/);
+  }
+
+  private void release(boolean isRemovedFromQueue) {
+    Util.assertMainThread();
     cbs.clear();
     key = null;
     engineResource = null;
@@ -188,15 +217,17 @@ private void release() {
     hasLoadFailed = false;
     isCancelled = false;
     hasResource = false;
-    decodeJob.release();
+    decodeJob.release(isRemovedFromQueue);
     decodeJob = null;
     exception = null;
+    dataSource = null;
     pool.release(this);
   }
 
   @Override
-  public void onResourceReady(Resource<R> resource) {
+  public void onResourceReady(Resource<R> resource, DataSource dataSource) {
     this.resource = resource;
+    this.dataSource = dataSource;
     MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
   }
 
@@ -209,21 +240,22 @@ public void onLoadFailed(GlideException e) {
   @Override
   public void reschedule(DecodeJob<?> job) {
     if (isCancelled) {
-      release();
+      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
     } else {
-      sourceExecutor.execute(job);
+      getActiveSourceExecutor().execute(job);
     }
   }
 
-  private void handleExceptionOnMainThread() {
-    if (isReleased) {
-      throw new RuntimeException("Already released");
-    }
+  @Synthetic
+  void handleExceptionOnMainThread() {
+    stateVerifier.throwIfRecycled();
     if (isCancelled) {
-      release();
+      release(false /*isRemovedFromQueue*/);
       return;
     } else if (cbs.isEmpty()) {
       throw new IllegalStateException("Received an exception without any callbacks to notify");
+    } else if (hasLoadFailed) {
+      throw new IllegalStateException("Already failed once");
     }
     hasLoadFailed = true;
 
@@ -235,7 +267,12 @@ private void handleExceptionOnMainThread() {
       }
     }
 
-    release();
+    release(false /*isRemovedFromQueue*/);
+  }
+
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
   }
 
   // Visible for testing.
@@ -247,19 +284,26 @@ private void handleExceptionOnMainThread() {
 
   private static class MainThreadCallback implements Handler.Callback {
 
+    @Synthetic
+    MainThreadCallback() { }
+
     @Override
     public boolean handleMessage(Message message) {
-      if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) {
-        EngineJob job = (EngineJob) message.obj;
-        if (MSG_COMPLETE == message.what) {
+      EngineJob<?> job = (EngineJob<?>) message.obj;
+      switch (message.what) {
+        case MSG_COMPLETE:
           job.handleResultOnMainThread();
-        } else {
+          break;
+        case MSG_EXCEPTION:
           job.handleExceptionOnMainThread();
-        }
-        return true;
+          break;
+        case MSG_CANCELLED:
+          job.handleCancelledOnMainThread();
+          break;
+        default:
+          throw new IllegalStateException("Unrecognized message: " + message.what);
       }
-
-      return false;
+      return true;
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 855f48b04..a95e820a8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -4,7 +4,6 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index b458d3132..ec00d0a06 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -3,7 +3,6 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-
 import java.util.Map;
 
 class EngineKeyFactory {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 0ba087590..c03168f69 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ExceptionListPool.java b/library/src/main/java/com/bumptech/glide/load/engine/ExceptionListPool.java
deleted file mode 100644
index cbc445525..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/ExceptionListPool.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import android.support.v4.util.Pools;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A simple wrapper for an {@link android.support.v4.util.Pools.Pool} that returns non-null
- * {@link List}s for {@link Exception}s.
- */
-public final class ExceptionListPool implements Pools.Pool<List<Exception>> {
-  private static final String TAG = "ExceptionListPool";
-  private final Pools.Pool<List<Exception>> pool = new Pools.SynchronizedPool<>(20);
-
-  @Override
-  public List<Exception> acquire() {
-    List<Exception> result = pool.acquire();
-    if (result == null) {
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Allocate new list");
-      }
-      result = new ArrayList<>();
-    }
-    return result;
-  }
-
-  @Override
-  public boolean release(List<Exception> instance) {
-    instance.clear();
-    return pool.release(instance);
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index f7d40cc6a..4dca3166a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
-
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.PrintWriter;
@@ -57,10 +57,10 @@ public Throwable fillInStackTrace() {
   /**
    * Returns a list of causes that are immediate children of this exception.
    *
-   * @see #getRootCauses().
-   *
    * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
-   * causes, and in turn my have been caused by other failures.
+   * causes, and in turn my have been caused by other failures.</p>
+   *
+   * @see #getRootCauses()
    */
   public List<Exception> getCauses() {
     return causes;
@@ -91,7 +91,7 @@ public void logRootCauses(String tag) {
     Log.e(tag, getClass() + ": " + getMessage());
     List<Exception> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
-      Log.e(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
+      Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
     }
   }
 
@@ -178,6 +178,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
   }
 
   private static final class IndentedAppendable implements Appendable {
+    private static final String EMPTY_SEQUENCE = "";
     private static final String INDENT = "  ";
     private final Appendable appendable;
     private boolean printedNewLine = true;
@@ -198,19 +199,31 @@ public Appendable append(char c) throws IOException {
     }
 
     @Override
-    public Appendable append(CharSequence charSequence) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence) throws IOException {
+      charSequence = safeSequence(charSequence);
       return append(charSequence, 0, charSequence.length());
     }
 
     @Override
-    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence, int start, int end)
+        throws IOException {
+      charSequence = safeSequence(charSequence);
       if (printedNewLine) {
         printedNewLine = false;
         appendable.append(INDENT);
       }
-      printedNewLine = csq.length() > 0 && csq.charAt(end - 1) == '\n';
-      appendable.append(csq, start, end);
+      printedNewLine = charSequence.length() > 0 && charSequence.charAt(end - 1) == '\n';
+      appendable.append(charSequence, start, end);
       return this;
     }
+
+    @NonNull
+    private CharSequence safeSequence(@Nullable CharSequence sequence) {
+      if (sequence == null) {
+        return EMPTY_SEQUENCE;
+      } else {
+        return sequence;
+      }
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
new file mode 100644
index 000000000..9b34820b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * A callback allowing a resource to do some optimization on a background thread before being
+ * returned to the ui.
+ */
+public interface Initializable {
+
+  /**
+   * Called on a background thread so the {@link Resource} can do some eager initialization.
+   */
+  void initialize();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index 455567a72..d182da6ea 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -21,13 +21,13 @@
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
-  private final ExceptionListPool listPool;
+  private final Pool<List<Exception>> listPool;
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
   public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, ExceptionListPool listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
new file mode 100644
index 000000000..5ee05aca7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -0,0 +1,92 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.v4.util.Pools;
+import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
+
+/**
+ * A resource that defers any calls to {@link Resource#recycle()} until after {@link #unlock()} is
+ * called.
+ *
+ * <p>If the resource was recycled prior to {@link #unlock()}, then {@link #unlock()} will also
+ * recycle the resource.
+ */
+final class LockedResource<Z> implements Resource<Z>,
+    FactoryPools.Poolable {
+  private static final Pools.Pool<LockedResource<?>> POOL = FactoryPools.threadSafe(20,
+      new FactoryPools.Factory<LockedResource<?>>() {
+        @Override
+        public LockedResource<?> create() {
+          return new LockedResource<Object>();
+        }
+      });
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private Resource<Z> toWrap;
+  private boolean isLocked;
+  private boolean isRecycled;
+
+  @SuppressWarnings("unchecked")
+  static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
+    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    result.init(resource);
+    return result;
+  }
+
+  @Synthetic
+  LockedResource() { }
+
+  private void init(Resource<Z> toWrap) {
+    isRecycled = false;
+    isLocked = true;
+    this.toWrap = toWrap;
+  }
+
+  private void release() {
+    toWrap = null;
+    POOL.release(this);
+  }
+
+  public synchronized void unlock() {
+    stateVerifier.throwIfRecycled();
+
+    if (!isLocked) {
+      throw new IllegalStateException("Already unlocked");
+    }
+    this.isLocked = false;
+    if (isRecycled) {
+      recycle();
+    }
+  }
+
+  @Override
+  public Class<Z> getResourceClass() {
+    return toWrap.getResourceClass();
+  }
+
+  @Override
+  public Z get() {
+    return toWrap.get();
+  }
+
+  @Override
+  public int getSize() {
+    return toWrap.getSize();
+  }
+
+  @Override
+  public synchronized void recycle() {
+    stateVerifier.throwIfRecycled();
+
+    this.isRecycled = true;
+    if (!isLocked) {
+      toWrap.recycle();
+      release();
+    }
+  }
+
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 65c0decd0..b0d444ed9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -6,7 +6,6 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
@@ -40,6 +39,9 @@ public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
+    if (sourceIds.isEmpty()) {
+      return false;
+    }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index ea3f11714..2fbd7051e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -4,7 +4,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.LruCache;
-
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -37,10 +37,10 @@ public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
       return height == other.height && width == other.width
-          && (transformation == null
-              ? other.transformation == null : transformation.equals(other.transformation))
+          && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
-          && sourceKey.equals(other.sourceKey) && signature.equals(other.signature)
+          && sourceKey.equals(other.sourceKey)
+          && signature.equals(other.signature)
           && options.equals(other.options);
     }
     return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index ddd5d55cb..6d8d365b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -3,7 +3,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -33,10 +33,13 @@ public void recycle(Resource<?> resource) {
   private static class ResourceRecyclerCallback implements Handler.Callback {
     public static final int RECYCLE_RESOURCE = 1;
 
+    @Synthetic
+    ResourceRecyclerCallback() { }
+
     @Override
     public boolean handleMessage(Message message) {
       if (message.what == RECYCLE_RESOURCE) {
-        Resource resource = (Resource) message.obj;
+        Resource<?> resource = (Resource<?>) message.obj;
         resource.recycle();
         return true;
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index 9f75a856a..c3f3420dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -10,7 +8,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.util.LogTime;
-
 import java.util.Collections;
 
 /**
@@ -24,6 +21,7 @@
 class SourceGenerator implements DataFetcherGenerator,
     DataFetcher.DataCallback<Object>,
     DataFetcherGenerator.FetcherReadyCallback {
+  private static final String TAG = "SourceGenerator";
 
   private final DecodeHelper<?> helper;
   private final FetcherReadyCallback cb;
@@ -78,8 +76,8 @@ private void cacheData(Object dataToCache) {
           new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());
       originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
       helper.getDiskCache().put(originalKey, writer);
-      if (Logs.isEnabled(Log.VERBOSE)) {
-        Logs.log(Log.VERBOSE, "Finished encoding source to cache"
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished encoding source to cache"
             + ", key: " + originalKey
             + ", data: " + dataToCache
             + ", encoder: " + encoder
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
new file mode 100644
index 000000000..18427396a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+/**
+ * Interface for handling operations on a primitive array type.
+ * @param <T> Array type (e.g. byte[], int[])
+ */
+public interface ArrayAdapterInterface<T> {
+
+  /**
+   * TAG for logging.
+   */
+  String getTag();
+
+  /**
+   * Return the length of the given array.
+   */
+  int getArrayLength(T array);
+
+  /**
+   * Allocate and return an array of the specified size.
+   */
+  T newArray(int length);
+
+  /**
+   * Return the size of an element in the array in bytes (e.g. for int return 4).
+   */
+  int getElementSizeInBytes();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
similarity index 59%
rename from library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
rename to library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 0213653b8..bfdb18621 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 /**
- * Pool containing byte[] arrays of various sizes.
+ * Interface for an array pool that pools arrays of different types.
  */
-public interface ByteArrayPool {
+public interface ArrayPool {
   /**
    * A standard size to use to increase hit rates when the required size isn't defined.
    * Currently 64KB.
@@ -11,22 +11,23 @@
   int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
 
   /**
-   * Optionally adds the given byte array to the pool.
+   * Optionally adds the given array of the given type to the pool.
    *
    * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
    * pool.
    */
-  void put(byte[] bytes);
+  <T> void put(T array, Class<T> arrayClass);
 
   /**
-   * Returns a non-null byte array with a length >= to the given size.
+   * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
    */
-  byte[] get(int size);
-
+  <T> T get(int size, Class<T> arrayClass);
   /**
-   * Clears all byte arrays from the pool.
+   * Clears all arrays from the pool.
    */
   void clearMemory();
 
@@ -36,4 +37,5 @@
    * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
+
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index 1a24f4c9c..f9448856b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -54,7 +54,8 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
-  private static String getBitmapString(int width, int height, Bitmap.Config config) {
+  @Synthetic
+  static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index 32702852b..ffdba43d3 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 abstract class BaseKeyPool<T extends Poolable> {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 4671340d5..3fecc0360 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 /**
  * An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects.
@@ -13,8 +14,8 @@
   int getMaxSize();
 
   /**
-   * Multiplies the initial size of the pool by the given multipler to dynamically and synchronously
-   * allow users to adjust the size of the pool.
+   * Multiplies the initial size of the pool by the given multiplier to dynamically and
+   * synchronously allow users to adjust the size of the pool.
    *
    * <p> If the current total size of the pool is larger than the max size after the given
    * multiplier is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new
@@ -25,27 +26,23 @@
   void setSizeMultiplier(float sizeMultiplier);
 
   /**
-   * Adds the given {@link android.graphics.Bitmap} and returns {@code true} if the {@link
-   * android.graphics.Bitmap} was eligible to be added and {@code false} otherwise.
+   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool
+   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
    *
-   * <p> Note - If the {@link android.graphics.Bitmap} is rejected (this method returns false) then
-   * it is the caller's responsibility to call {@link android.graphics.Bitmap#recycle()}. </p>
-   *
-   * <p> Note - This method will return {@code true} if the given {@link android.graphics.Bitmap} is
-   * synchronously evicted after being accepted. The only time this method will return {@code false}
-   * is if the {@link android.graphics.Bitmap} is not eligible to be added to the pool (either it is
-   * not mutable or it is larger than the max pool size). </p>
+   * <p> Callers must <em>not</em> continue to use the Bitmap after calling this method. </p>
    *
    * @param bitmap The {@link android.graphics.Bitmap} to attempt to add.
    * @see android.graphics.Bitmap#isMutable()
    * @see android.graphics.Bitmap#recycle()
    */
-  boolean put(Bitmap bitmap);
+  void put(Bitmap bitmap);
 
   /**
    * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and
-   * configuration, and containing only transparent pixels or null if no such {@link
-   * android.graphics.Bitmap} could be obtained from the pool.
+   * configuration, and containing only transparent pixels.
+   *
+   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated. </p>
    *
    * <p> Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
    * than {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link
@@ -68,12 +65,15 @@
    *               android.graphics.Bitmap}.
    * @see #getDirty(int, int, android.graphics.Bitmap.Config)
    */
+  @NonNull
   Bitmap get(int width, int height, Bitmap.Config config);
 
   /**
    * Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned
-   * non-null {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain
-   * random data.
+   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data.
+   *
+   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated. </p>
    *
    * <p> Although this method is slightly more efficient than {@link #get(int, int,
    * android.graphics.Bitmap.Config)} it should be used with caution and only when the caller is
@@ -89,6 +89,7 @@
    * could be obtained from the pool.
    * @see #get(int, int, android.graphics.Bitmap.Config)
    */
+  @NonNull
   Bitmap getDirty(int width, int height, Bitmap.Config config);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index e441edc7b..af72c1b82 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 
 /**
  * An {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool BitmapPool} implementation
@@ -19,18 +20,20 @@ public void setSizeMultiplier(float sizeMultiplier) {
   }
 
   @Override
-  public boolean put(Bitmap bitmap) {
-    return false;
+  public void put(Bitmap bitmap) {
+    bitmap.recycle();
   }
 
+  @NonNull
   @Override
   public Bitmap get(int width, int height, Bitmap.Config config) {
-    return null;
+    return Bitmap.createBitmap(width, height, config);
   }
 
+  @NonNull
   @Override
   public Bitmap getDirty(int width, int height, Bitmap.Config config) {
-    return null;
+    return get(width, height, config);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
new file mode 100644
index 000000000..95f5ff708
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Adapter for handling primitive byte arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
+  private static final String TAG = "ByteArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(byte[] array) {
+    return array.length;
+  }
+
+  @Override
+  public byte[] newArray(int length) {
+    return new byte[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 1;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index ae74906ca..d190a475f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
+import android.support.annotation.Nullable;
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -33,6 +35,7 @@ public void put(K key, V value) {
     entry.add(value);
   }
 
+  @Nullable
   public V get(K key) {
     LinkedEntry<K, V> entry = keyToEntry.get(key);
     if (entry == null) {
@@ -47,6 +50,7 @@ public V get(K key) {
     return entry.removeLast();
   }
 
+  @Nullable
   public V removeLast() {
     LinkedEntry<K, V> last = head.prev;
 
@@ -116,7 +120,7 @@ private void makeTail(LinkedEntry<K, V> entry) {
   }
 
   private static class LinkedEntry<K, V> {
-    private final K key;
+    @Synthetic final K key;
     private List<V> values;
     LinkedEntry<K, V> next;
     LinkedEntry<K, V> prev;
@@ -132,6 +136,7 @@ public LinkedEntry(K key) {
       this.key = key;
     }
 
+    @Nullable
     public V removeLast() {
       final int valueSize = size();
       return valueSize > 0 ? values.remove(valueSize - 1) : null;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
new file mode 100644
index 000000000..4fb179c38
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Adapter for handling primitive int arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
+  private static final String TAG = "IntegerArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(int[] array) {
+    return array.length;
+  }
+
+  @Override
+  public int[] newArray(int length) {
+    return new int[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 4;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
new file mode 100644
index 000000000..6da2cb0e0
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -0,0 +1,261 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ */
+public final class LruArrayPool implements ArrayPool {
+  // 4MB.
+  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+
+  /**
+   * The maximum number of times larger an int array may be to be than a requested size to eligible
+   * to be returned from the pool.
+   */
+  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
+  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
+
+  private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
+  private final KeyPool keyPool = new KeyPool();
+  private final Map<Class<?>, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class<?>, ArrayAdapterInterface<?>> adapters = new HashMap<>();
+  private final int maxSize;
+  private int currentSize;
+
+  @VisibleForTesting
+  public LruArrayPool() {
+    maxSize = DEFAULT_SIZE;
+  }
+
+  /**
+   * Constructor for a new pool.
+   *
+   * @param maxSize The maximum size in integers of the pool.
+   */
+  public LruArrayPool(int maxSize) {
+    this.maxSize = maxSize;
+  }
+
+  @Override
+  public synchronized <T> void put(T array, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    int size = arrayAdapter.getArrayLength(array);
+    int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
+    if (!isSmallEnoughForReuse(arrayBytes)) {
+      return;
+    }
+    Key key = keyPool.get(size, arrayClass);
+
+    groupedMap.put(key, array);
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+    currentSize += arrayBytes;
+    evict();
+  }
+
+  @Override
+  public <T> T get(int size, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result;
+    synchronized (this) {
+      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+      final Key key;
+      if (mayFillRequest(size, possibleSize)) {
+        key = keyPool.get(possibleSize, arrayClass);
+      } else {
+        key = keyPool.get(size, arrayClass);
+      }
+
+      result = getArrayForKey(key);
+      if (result != null) {
+        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
+      }
+    }
+
+    if (result == null) {
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+      }
+      result = arrayAdapter.newArray(size);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  private <T> T getArrayForKey(Key key) {
+    return (T) groupedMap.get(key);
+  }
+
+  private boolean isSmallEnoughForReuse(int byteSize) {
+    return byteSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  }
+
+  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
+    return actualSize != null
+        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
+  }
+
+  private boolean isNoMoreThanHalfFull() {
+    return currentSize == 0 || (maxSize / currentSize >= 2);
+  }
+
+  @Override
+  public synchronized void clearMemory() {
+    evictToSize(0);
+  }
+
+  @Override
+  public synchronized void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      evictToSize(maxSize / 2);
+    }
+  }
+
+  private void evict() {
+    evictToSize(maxSize);
+  }
+
+  private void evictToSize(int size) {
+    while (currentSize > size) {
+      Object evicted = groupedMap.removeLast();
+      Preconditions.checkNotNull(evicted);
+      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);
+      currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "evicted: " + arrayAdapter.getArrayLength(evicted));
+      }
+    }
+  }
+
+  private void decrementArrayOfSize(int size, Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException(
+          "Tried to decrement empty size" + ", size: " + size + ", this: " + this);
+    }
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(arrayClass);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(arrayClass, sizes);
+    }
+    return sizes;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {
+    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
+    ArrayAdapterInterface<?> adapter = adapters.get(arrayPoolClass);
+    if (adapter == null) {
+      if (arrayPoolClass.equals(int[].class)) {
+        adapter = new IntegerArrayAdapter();
+      } else if (arrayPoolClass.equals(byte[].class)) {
+        adapter = new ByteArrayAdapter();
+      } else {
+          throw new IllegalArgumentException("No array pool found for: "
+              + arrayPoolClass.getSimpleName());
+      }
+      adapters.put(arrayPoolClass, adapter);
+    }
+    return (ArrayAdapterInterface<T>) adapter;
+  }
+
+  // VisibleForTesting
+  int getCurrentSize() {
+    int currentSize = 0;
+    for (Class<?> type : sortedSizes.keySet()) {
+      for (Integer size : sortedSizes.get(type).keySet()) {
+        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);
+        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();
+      }
+    }
+    return currentSize;
+  }
+
+  private static final class KeyPool extends BaseKeyPool<Key> {
+
+    @Synthetic
+    KeyPool() { }
+
+    Key get(int size, Class<?> arrayClass) {
+      Key result = get();
+      result.init(size, arrayClass);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  private static final class Key implements Poolable {
+    private final KeyPool pool;
+    @Synthetic int size;
+    private Class<?> arrayClass;
+
+    Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    void init(int length, Class<?> arrayClass) {
+      this.size = length;
+      this.arrayClass = arrayClass;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size && arrayClass == other.arrayClass;
+      }
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{" + "size=" + size + "array=" + arrayClass + '}';
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (arrayClass != null ? arrayClass.hashCode() : 0);
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 7c1ff54ac..2cf9c0f37 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -5,8 +5,10 @@
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -76,7 +78,7 @@ public synchronized void setSizeMultiplier(float sizeMultiplier) {
   }
 
   @Override
-  public synchronized boolean put(Bitmap bitmap) {
+  public synchronized void put(Bitmap bitmap) {
     if (bitmap == null) {
       throw new NullPointerException("Bitmap must not be null");
     }
@@ -91,7 +93,8 @@ public synchronized boolean put(Bitmap bitmap) {
                 + ", is mutable: " + bitmap.isMutable()
                 + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));
       }
-      return false;
+      bitmap.recycle();
+      return;
     }
 
     final int size = strategy.getSize(bitmap);
@@ -107,7 +110,6 @@ public synchronized boolean put(Bitmap bitmap) {
     dump();
 
     evict();
-    return true;
   }
 
   private void evict() {
@@ -115,21 +117,33 @@ private void evict() {
   }
 
   @Override
-  public synchronized Bitmap get(int width, int height, Bitmap.Config config) {
-    Bitmap result = getDirty(width, height, config);
+  @NonNull
+  public Bitmap get(int width, int height, Bitmap.Config config) {
+    Bitmap result = getDirtyOrNull(width, height, config);
     if (result != null) {
       // Bitmaps in the pool contain random data that in some cases must be cleared for an image
       // to be rendered correctly. we shouldn't force all consumers to independently erase the
       // contents individually, so we do so here. See issue #131.
       result.eraseColor(Color.TRANSPARENT);
+    } else {
+      result = Bitmap.createBitmap(width, height, config);
     }
 
     return result;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+  @NonNull
   @Override
-  public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config) {
+  public Bitmap getDirty(int width, int height, Bitmap.Config config) {
+    Bitmap result = getDirtyOrNull(width, height, config);
+    if (result == null) {
+      result = Bitmap.createBitmap(width, height, config);
+    }
+    return result;
+  }
+
+  @Nullable
+  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
     final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
@@ -142,9 +156,7 @@ public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config)
       hits++;
       currentSize -= strategy.getSize(result);
       tracker.remove(result);
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-        result.setHasAlpha(true);
-      }
+      normalize(result);
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       Log.v(TAG, "Get bitmap=" + strategy.logBitmap(width, height, config));
@@ -154,6 +166,20 @@ public synchronized Bitmap getDirty(int width, int height, Bitmap.Config config)
     return result;
   }
 
+  // Setting these two values provides Bitmaps that are essentially equivalent to those returned
+  // from Bitmap.createBitmap.
+  private static void normalize(Bitmap bitmap) {
+    bitmap.setHasAlpha(true);
+    maybeSetPreMultiplied(bitmap);
+  }
+
+  @TargetApi(Build.VERSION_CODES.KITKAT)
+  private static void maybeSetPreMultiplied(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      bitmap.setPremultiplied(true);
+    }
+  }
+
   @Override
   public void clearMemory() {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -168,9 +194,9 @@ public void trimMemory(int level) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "trimMemory, level=" + level);
     }
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       trimToSize(maxSize / 2);
     }
   }
@@ -259,6 +285,10 @@ public void remove(Bitmap bitmap) {
   }
 
   private static class NullBitmapTracker implements BitmapTracker {
+
+    @Synthetic
+    NullBitmapTracker() { }
+
     @Override
     public void add(Bitmap bitmap) {
       // Do nothing.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
deleted file mode 100644
index dd6d5dc68..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
+++ /dev/null
@@ -1,195 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.util.Log;
-
-import java.util.Arrays;
-import java.util.TreeMap;
-
-/**
- * A fixed size LruByteArrayPool that evicts arrays using an LRU strategy to keep the pool under
- * the maximum byte size.
- */
-public final class LruByteArrayPool implements ByteArrayPool {
-  private static final String TAG = "LruBytesPool";
-  // 4MB.
-  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
-  /**
-   * The maximum number of times larger a byte array may be to be than a requested size to eligble
-   * to be returned from the pool.
-   */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
-  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
-  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
-  private final GroupedLinkedMap<Key, byte[]> groupedMap = new GroupedLinkedMap<>();
-  private final KeyPool keyPool = new KeyPool();
-  private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<>();
-  private final int maxSizeBytes;
-
-  private int currentSizeBytes;
-
-  /**
-   * Constructor for a new pool with a standard size.
-   */
-  public LruByteArrayPool() {
-    this(DEFAULT_SIZE);
-  }
-
-  /**
-   * Constructor for a new pool.
-   *
-   * @param maxSizeBytes The maximum size in bytes of the pool.
-   */
-  public LruByteArrayPool(int maxSizeBytes) {
-    this.maxSizeBytes = maxSizeBytes;
-  }
-
-  @Override
-  public synchronized void put(byte[] bytes) {
-    int size = bytes.length;
-    if (!isSmallEnoughForReuse(size)) {
-      return;
-    }
-    Key key = keyPool.get(size);
-
-    groupedMap.put(key, bytes);
-    Integer current = sortedSizes.get(size);
-    sortedSizes.put(size, current == null ? 1 : current + 1);
-    currentSizeBytes += size;
-    evict();
-  }
-
-  @Override
-  public byte[] get(int size) {
-    byte[] result;
-    synchronized (this) {
-      Integer possibleSize = sortedSizes.ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize);
-      } else {
-        key = keyPool.get(size);
-      }
-
-      result = groupedMap.get(key);
-      if (result != null) {
-        currentSizeBytes -= result.length;
-        decrementByteArrayOfSize(result.length);
-      }
-    }
-
-    if (result != null) {
-      Arrays.fill(result, (byte) 0);
-    } else {
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Allocated " + size + " bytes");
-      }
-      result = new byte[size];
-    }
-
-    return result;
-  }
-
-  private boolean isSmallEnoughForReuse(int byteSize) {
-    return byteSize <= maxSizeBytes / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
-  }
-
-  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
-    return actualSize != null
-        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
-  }
-
-  private boolean isNoMoreThanHalfFull() {
-    return currentSizeBytes == 0 || (maxSizeBytes / currentSizeBytes >= 2);
-  }
-
-  @Override
-  public synchronized void clearMemory() {
-    evictToSize(0);
-  }
-
-  @Override
-  public synchronized void trimMemory(int level) {
-     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-      clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      evictToSize(maxSizeBytes / 2);
-    }
-  }
-
-  private void evict() {
-    evictToSize(maxSizeBytes);
-  }
-
-  private void evictToSize(int size) {
-    while (currentSizeBytes > size) {
-      byte[] evicted = groupedMap.removeLast();
-      currentSizeBytes -= evicted.length;
-      decrementByteArrayOfSize(evicted.length);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "evicted: " + evicted.length);
-      }
-    }
-  }
-
-  private void decrementByteArrayOfSize(int size) {
-    Integer current = sortedSizes.get(size);
-    if (current == 1) {
-      sortedSizes.remove(current);
-    } else {
-      sortedSizes.put(size, current - 1);
-    }
-  }
-
-  private static final class KeyPool extends BaseKeyPool<Key> {
-
-    Key get(int size) {
-      Key result = get();
-      result.init(size);
-      return result;
-    }
-
-    @Override
-    protected Key create() {
-      return new Key(this);
-    }
-  }
-
-  private static final class Key implements Poolable {
-    private final KeyPool pool;
-    private int size;
-
-    Key(KeyPool pool) {
-      this.pool = pool;
-    }
-
-    void init(int length) {
-      this.size = length;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Key) {
-        Key other = (Key) o;
-        return size == other.size;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return size;
-    }
-
-    @Override
-    public String toString() {
-      return "Key{"
-          + "size=" + size
-          + '}';
-    }
-
-    @Override
-    public void offer() {
-      pool.offer(this);
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
index 7a248607a..376dd9665 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.support.annotation.Nullable;
 
 interface LruPoolStrategy {
   void put(Bitmap bitmap);
 
+  @Nullable
   Bitmap get(int width, int height, Bitmap.Config config);
 
+  @Nullable
   Bitmap removeLast();
 
   String logBitmap(Bitmap bitmap);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index b023b16e6..05964ba05 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -3,9 +3,9 @@
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
-
+import android.support.annotation.Nullable;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -57,6 +57,7 @@ public void put(Bitmap bitmap) {
   }
 
   @Override
+  @Nullable
   public Bitmap get(int width, int height, Bitmap.Config config) {
     int size = Util.getBitmapByteSize(width, height, config);
     Key bestKey = findBestKey(size, config);
@@ -89,6 +90,7 @@ private Key findBestKey(int size, Bitmap.Config config) {
   }
 
   @Override
+  @Nullable
   public Bitmap removeLast() {
     Bitmap removed = groupedMap.removeLast();
     if (removed != null) {
@@ -177,7 +179,7 @@ protected Key create() {
   static final class Key implements Poolable {
     private final KeyPool pool;
 
-    private int size;
+    @Synthetic int size;
     private Bitmap.Config config;
 
     public Key(KeyPool pool) {
@@ -210,7 +212,7 @@ public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
         return size == other.size
-            && (config == null ? other.config == null : config.equals(other.config));
+            && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
@@ -223,7 +225,8 @@ public int hashCode() {
     }
   }
 
-  private static String getBitmapString(int size, Bitmap.Config config) {
+  @Synthetic
+  static String getBitmapString(int size, Bitmap.Config config) {
     return "[" + size + "](" + config + ")";
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index a9a996b5a..205ec7e4f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -3,9 +3,9 @@
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
-
+import android.support.annotation.Nullable;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.TreeMap;
 
 /**
@@ -33,6 +33,7 @@ public void put(Bitmap bitmap) {
   }
 
   @Override
+  @Nullable
   public Bitmap get(int width, int height, Bitmap.Config config) {
     final int size = Util.getBitmapByteSize(width, height, config);
     Key key = keyPool.get(size);
@@ -55,6 +56,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
   }
 
   @Override
+  @Nullable
   public Bitmap removeLast() {
     Bitmap removed = groupedMap.removeLast();
     if (removed != null) {
@@ -99,7 +101,8 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  private static String getBitmapString(int size) {
+  @Synthetic
+  static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
@@ -121,7 +124,7 @@ protected Key create() {
   // Visible for testing.
   static final class Key implements Poolable {
     private final KeyPool pool;
-    private int size;
+    @Synthetic int size;
 
     Key(KeyPool pool) {
       this.pool = pool;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 90c1e7c24..31cdcf025 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
@@ -21,6 +21,7 @@
       /**
        * Returns a new disk cache, or {@code null} if no disk cache could be created.
        */
+      @Nullable
       DiskCache build();
   }
 
@@ -46,6 +47,7 @@
    * @param key The key in the cache.
    * @return An InputStream representing the data at key at the time get is called.
    */
+  @Nullable
   File get(Key key);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 73bbe74c7..d551af16a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 35586d8ae..13318a8fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -2,7 +2,7 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -65,12 +65,18 @@ void release(Key key) {
   private static class WriteLock  {
     final Lock lock = new ReentrantLock();
     int interestedThreads;
+
+    @Synthetic
+    WriteLock() { }
   }
 
   private static class WriteLockPool {
     private static final int MAX_POOL_SIZE = 10;
     private final Queue<WriteLock> pool = new ArrayDeque<>();
 
+    @Synthetic
+    WriteLockPool() { }
+
     WriteLock obtain() {
       WriteLock result;
       synchronized (pool) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 4aeb30c6d..c0e6f5269 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -5,11 +5,9 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.util.Log;
-
 import com.bumptech.glide.disklrucache.DiskLruCache;
 import com.bumptech.glide.disklrucache.DiskLruCache.Value;
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 import java.io.IOException;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index 885a8e97e..ab4ca652c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index a69112738..225743b89 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 82391d42a..44071a869 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -41,11 +40,11 @@ protected int getSize(Resource<?> item) {
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       // Nearing middle of list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       // Entering list of cached background apps
       // Evict oldest half of our bitmap cache
       trimToSize(getCurrentSize() / 2);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index 0c807ed93..3cf56d4c5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -40,6 +41,7 @@
    *
    * @param key The key.
    */
+  @Nullable
   Resource<?> remove(Key key);
 
   /**
@@ -49,6 +51,7 @@
    * @param resource The {@link com.bumptech.glide.load.engine.EngineResource} to store.
    * @return The old value of key (null if key is not in map).
    */
+  @Nullable
   Resource<?> put(Key key, Resource<?> resource);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 6156e8802..7e0bb505e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -23,7 +21,7 @@
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
   private final Context context;
-  private final int byteArrayPoolSize;
+  private final int arrayPoolSize;
 
   interface ScreenDimensions {
     int getWidthPixels();
@@ -32,10 +30,12 @@
 
   MemorySizeCalculator(Context context, ActivityManager activityManager,
       ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetByteArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
+      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
     this.context = context;
-    byteArrayPoolSize = isLowMemoryDevice(activityManager)
-        ? targetByteArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR : targetByteArrayPoolSize;
+    arrayPoolSize =
+        isLowMemoryDevice(activityManager)
+            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : targetArrayPoolSize;
     final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
 
     final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
@@ -43,7 +43,7 @@
 
     int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
     int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
-    int availableSize = maxSize - byteArrayPoolSize;
+    int availableSize = maxSize - arrayPoolSize;
 
     if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
@@ -55,14 +55,23 @@
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      Log.d(TAG, "Calculation complete"
-          + ", Calculated memory cache size: " + toMb(memoryCacheSize)
-          + ", pool size: " + toMb(bitmapPoolSize)
-          + ", byte array size: " + toMb(byteArrayPoolSize)
-          + ", memory class limited? " + (targetMemoryCacheSize + targetPoolSize > maxSize)
-          + ", max size: " + toMb(maxSize)
-          + ", memoryClass: " + activityManager.getMemoryClass()
-          + ", isLowMemoryDevice: " + isLowMemoryDevice(activityManager));
+      Log.d(
+          TAG,
+          "Calculation complete"
+              + ", Calculated memory cache size: "
+              + toMb(memoryCacheSize)
+              + ", pool size: "
+              + toMb(bitmapPoolSize)
+              + ", byte array size: "
+              + toMb(arrayPoolSize)
+              + ", memory class limited? "
+              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + ", max size: "
+              + toMb(maxSize)
+              + ", memoryClass: "
+              + activityManager.getMemoryClass()
+              + ", isLowMemoryDevice: "
+              + isLowMemoryDevice(activityManager));
     }
   }
 
@@ -81,10 +90,10 @@ public int getBitmapPoolSize() {
   }
 
   /**
-   * Returns the recommended byte array pool size for the device it is run on in bytes.
+   * Returns the recommended array pool size for the device it is run on in bytes.
    */
-  public int getByteArrayPoolSize() {
-    return byteArrayPoolSize;
+  public int getArrayPoolSizeInBytes() {
+    return arrayPoolSize;
   }
 
   private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
@@ -99,11 +108,14 @@ private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
   private static boolean isLowMemoryDevice(ActivityManager activityManager) {
-    final int sdkInt = Build.VERSION.SDK_INT;
-    return sdkInt < Build.VERSION_CODES.HONEYCOMB
-        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+    // Explicitly check with an if statement, on some devices both parts of boolean expressions
+    // can be evaluated even if we'd normally expect a short circuit.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      return activityManager.isLowRamDevice();
+    } else {
+      return false;
+    }
   }
 
   /**
@@ -117,7 +129,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
-    static final int BYTE_ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+    static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
     private final Context context;
 
@@ -129,7 +141,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
     private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
     private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int byteArrayPoolSizeBytes = BYTE_ARRAY_POOL_SIZE_BYTES;
+    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -194,14 +206,14 @@ public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
 
     /**
      * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool} to use to store temporary
+     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
      * arrays while decoding data and returns this builder.
      *
      * <p>This number will be halved on low memory devices that return {@code true} from
      * {@link ActivityManager#isLowRamDevice()}.
      */
-    public Builder setByteArrayPoolSize(int byteArrayPoolSizeBytes) {
-      this.byteArrayPoolSizeBytes = byteArrayPoolSizeBytes;
+    public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
+      this.arrayPoolSizeBytes = arrayPoolSizeBytes;
       return this;
     }
 
@@ -219,9 +231,9 @@ Builder setScreenDimensions(ScreenDimensions screenDimensions) {
 
     public MemorySizeCalculator build() {
       return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, byteArrayPoolSizeBytes, maxSizeMultiplier,
+          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
           lowMemoryMaxSizeMultiplier);
-    }
+      }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 06cc14ffa..2a81c4d9a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.v4.util.Pools;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
@@ -13,16 +16,17 @@
  */
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-
-  private static String calculateHexStringDigest(Key key) {
-     try {
-        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-        key.updateDiskCacheKey(messageDigest);
-        return Util.sha256BytesToHex(messageDigest.digest());
-      } catch (NoSuchAlgorithmException e) {
-       throw new RuntimeException(e);
-      }
-  }
+  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
+      new FactoryPools.Factory<PoolableDigestContainer>() {
+        @Override
+        public PoolableDigestContainer create() {
+          try {
+            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+          } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      });
 
   public String getSafeKey(Key key) {
     String safeKey;
@@ -37,4 +41,30 @@ public String getSafeKey(Key key) {
     }
     return safeKey;
   }
+
+  private String calculateHexStringDigest(Key key) {
+    PoolableDigestContainer container = digestPool.acquire();
+    try {
+      key.updateDiskCacheKey(container.messageDigest);
+      // calling digest() will automatically reset()
+      return Util.sha256BytesToHex(container.messageDigest.digest());
+    } finally {
+      digestPool.release(container);
+    }
+  }
+
+  private static final class PoolableDigestContainer implements FactoryPools.Poolable {
+
+    @Synthetic final MessageDigest messageDigest;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    PoolableDigestContainer(MessageDigest messageDigest) {
+      this.messageDigest = messageDigest;
+    }
+
+    @Override
+    public StateVerifier getVerifier() {
+      return stateVerifier;
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index aca64853a..b79e11178 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -1,79 +1,286 @@
 package com.bumptech.glide.load.engine.executor;
 
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public class GlideExecutor extends ThreadPoolExecutor {
+public final class GlideExecutor extends ThreadPoolExecutor {
+
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data not found in
+   * cache.
+   */
+  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data found in
+   * Glide's cache.
+   */
+  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  /**
+   * The default thread count for executors used to load/decode/transform data found in Glide's
+   * cache.
+   */
+  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+
   private static final String TAG = "GlideExecutor";
-  private static final String DEFAULT_NAME = "fifo-pool";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+  private final boolean executeSynchronously;
+
+  /**
+   * The default thread name prefix for executors from unlimited thread pool used to
+   * load/decode/transform data not found in cache.
+   */
+  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+  /**
+   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   */
+  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
+      TimeUnit.SECONDS.toMillis(10);
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param poolSize The number of threads.
+   * <p>Disk cache executors do not allow network operations on their threads.
    */
-  public GlideExecutor(int poolSize) {
-    this(poolSize, new DefaultThreadFactory());
+  public static GlideExecutor newDiskCacheExecutor() {
+    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
-   * @param poolSize The number of threads.
-   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected
-   *                                  throwables thrown by Futures run by the pool.
+   * <p>Disk cache executors do not allow network operations on their threads.
+   *
+   * @param threadCount The number of threads.
+   * @param name The prefix for each thread name.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(int poolSize,
+  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param name The prefix for threads created by this pool.
-   * @param poolSize The number of threads.
+   * <p>Source executors allow network operations on their threads.
    */
-  public GlideExecutor(String name, int poolSize) {
-    this(poolSize, new DefaultThreadFactory(name));
+  public static GlideExecutor newSourceExecutor() {
+    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Source executors allow network operations on their threads.
    *
+   * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
-   * @param poolSize The number of threads.
    * @param uncaughtThrowableStrategy The {@link
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(String name, int poolSize,
+  public static GlideExecutor newSourceExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(name, uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  }
+
+  /**
+   * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
+   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
+   * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
+   * {@code corePoolSize} threads.
+   * See <a href=
+   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
+   * ThreadPoolExecutor documentation</a>.
+   *
+   * <p>Source executors allow network operations on their threads.
+   */
+  public static GlideExecutor newUnlimitedSourceExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
+        SOURCE_UNLIMITED_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT,
+        false /*preventNetworkOperations*/,
+        false /*executeSynchronously*/,
+        new SynchronousQueue<Runnable>());
+  }
+
+  // Visible for testing.
+  GlideExecutor(int poolSize, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        poolSize /* corePoolSize */,
+        poolSize /* maximumPoolSize */,
+        0 /* keepAliveTimeInMs */,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously);
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously,
+        new PriorityBlockingQueue<Runnable>());
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
+    super(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        TimeUnit.MILLISECONDS,
+        queue,
+        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
+    this.executeSynchronously = executeSynchronously;
+  }
+
+  @Override
+  public void execute(Runnable command) {
+    if (executeSynchronously) {
+      command.run();
+    } else {
+      super.execute(command);
+    }
+  }
+
+  @NonNull
+  @Override
+  public Future<?> submit(Runnable task) {
+    return maybeWait(super.submit(task));
+  }
+
+  private <T> Future<T> maybeWait(Future<T> future) {
+    if (executeSynchronously) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+    }
+    return future;
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    return maybeWait(super.submit(task, result));
+  }
+
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    return maybeWait(super.submit(task));
   }
 
-  private GlideExecutor(int corePoolSize, ThreadFactory threadFactory) {
-    super(corePoolSize, corePoolSize, 0, TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(), threadFactory);
+  /**
+   * Determines the number of cores available on the device.
+   *
+   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
+   * be the number of available cores depending on the device's current state. See
+   * http://goo.gl/8H670N.
+   */
+  public static int calculateBestThreadCount() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    File[] cpus = null;
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+
+    int cpuCount = cpus != null ? cpus.length : 0;
+    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
+    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
   }
 
   /**
-   * A strategy for handling unexpected and uncaught throwables thrown by futures run on the pool.
+   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
+   * pool.
    */
   public enum UncaughtThrowableStrategy {
     /**
-     * Silently catches and ignores the uncaught throwables.
+     * Silently catches and ignores the uncaught {@link Throwable}s.
      */
     IGNORE,
     /**
-     * Logs the uncaught throwables using {@link #TAG} and {@link Log}.
+     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
     LOG {
       @Override
@@ -84,7 +291,7 @@ protected void handle(Throwable t) {
       }
     },
     /**
-     * Rethrows the uncaught throwables to crash the app.
+     * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
     THROW {
       @Override
@@ -96,43 +303,46 @@ protected void handle(Throwable t) {
       }
     };
 
+    /** The default strategy, currently {@link #LOG}. */
+    public static final UncaughtThrowableStrategy DEFAULT = LOG;
+
     protected void handle(Throwable t) {
       // Ignore.
     }
   }
 
   /**
-   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads slightly above priority {@link
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
     private final String name;
-    private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
-    private int threadNum = 0;
-
-    DefaultThreadFactory() {
-      this(DEFAULT_NAME);
-    }
-
-    DefaultThreadFactory(String name) {
-      this(name, UncaughtThrowableStrategy.LOG);
-    }
-
-    DefaultThreadFactory(UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-      this(DEFAULT_NAME, uncaughtThrowableStrategy);
-    }
+    @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
+    @Synthetic final boolean preventNetworkOperations;
+    private int threadNum;
 
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+        boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
+      this.preventNetworkOperations = preventNetworkOperations;
     }
 
     @Override
-    public Thread newThread(Runnable runnable) {
-      final Thread result = new Thread(runnable, name + "-thread-" + threadNum) {
+    public synchronized Thread newThread(@NonNull Runnable runnable) {
+      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          android.os.Process.setThreadPriority(
+              android.os.Process.THREAD_PRIORITY_BACKGROUND
+              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+          if (preventNetworkOperations) {
+            StrictMode.setThreadPolicy(
+                new ThreadPolicy.Builder()
+                    .detectNetwork()
+                    .penaltyDeath()
+                    .build());
+          }
           try {
             super.run();
           } catch (Throwable t) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index 64f38a2fb..a2f92a9db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -5,13 +5,12 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.util.Log;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.security.MessageDigest;
 import java.util.HashSet;
 import java.util.Set;
@@ -91,8 +90,15 @@ private boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
-      Bitmap bitmap = Bitmap
-          .createBitmap(toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
+      final Bitmap bitmap;
+      if (!seenTypes.contains(toAllocate)) {
+        seenTypes.add(toAllocate);
+        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
+            toAllocate.getConfig());
+      } else {
+        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
+            toAllocate.getConfig());
+      }
 
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
       // not empty so
@@ -100,7 +106,7 @@ private boolean allocate() {
       if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
         memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
       } else {
-        addToBitmapPool(toAllocate, bitmap);
+        bitmapPool.put(bitmap);
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -121,21 +127,6 @@ private int getFreeMemoryCacheBytes() {
     return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
   }
 
-  private void addToBitmapPool(PreFillType toAllocate, Bitmap bitmap) {
-    // The pool may not move sizes to the front of the LRU on put. Do a get here to make sure the
-    // size we're adding
-    // is at the front of the queue so that the Bitmap we're adding won't be evicted immediately.
-    if (seenTypes.add(toAllocate)) {
-      Bitmap fromPool =
-          bitmapPool.get(toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
-      if (fromPool != null) {
-        bitmapPool.put(fromPool);
-      }
-    }
-
-    bitmapPool.put(bitmap);
-  }
-
   @Override
   public void run() {
     if (allocate()) {
@@ -151,6 +142,9 @@ private long getNextDelay() {
 
   private static class UniqueKey implements Key {
 
+    @Synthetic
+    UniqueKey() { }
+
     @Override
     public void updateDiskCacheKey(MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index b91c4f73a..42a5a46c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,12 +3,10 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.HashMap;
 import java.util.Map;
 
@@ -53,7 +51,7 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
   }
 
   // Visible for testing.
-  PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
+  PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
     final int maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index daa78a4e8..9c07fb07c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.prefill;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -133,7 +133,7 @@ public Builder(int width, int height) {
      * @param config The config to use, or null to use Glide's default.
      * @return This builder.
      */
-    public Builder setConfig(Bitmap.Config config) {
+    public Builder setConfig(@Nullable Bitmap.Config config) {
       this.config = config;
       return this;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index baa57e8c9..7083de7bc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -1,17 +1,14 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
 import com.bumptech.glide.load.data.StreamAssetPathFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -61,10 +58,15 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       AssetFetcherFactory<InputStream> {
 
+    private final AssetManager assetManager;
+
+    public StreamFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
@@ -85,10 +87,15 @@ public void teardown() {
       ParcelFileDescriptor>,
       AssetFetcherFactory<ParcelFileDescriptor> {
 
+    private final AssetManager assetManager;
+
+    public FileDescriptorFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 52683e37d..8a486cce7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.EmptySignature;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -90,8 +87,7 @@ public DataSource getDataSource() {
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -117,8 +113,7 @@ public void teardown() {
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
     @Override
-    public ModelLoader<byte[], InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 4fbd048eb..278d16f2f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index b76092d7c..cb28480a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,16 +1,12 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -19,6 +15,7 @@
  * Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}.
  */
 public class ByteBufferFileLoader implements ModelLoader<File, ByteBuffer> {
+  private static final String TAG = "ByteBufferFileLoader";
 
   @Override
   public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
@@ -37,8 +34,7 @@ public boolean handles(File file) {
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
     @Override
-    public ModelLoader<File, ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -62,8 +58,8 @@ public void loadData(Priority priority, DataCallback<? super ByteBuffer> callbac
       try {
         result = ByteBufferUtil.fromFile(file);
       } catch (IOException e) {
-        if (Logs.isEnabled(Log.DEBUG)) {
-          Logs.log(Log.DEBUG, "Failed to obtain ByteBuffer for file", e);
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to obtain ByteBuffer for file", e);
         }
         callback.onLoadFailed(e);
         return;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
new file mode 100644
index 000000000..0e3297acb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -0,0 +1,157 @@
+package com.bumptech.glide.load.model;
+
+import android.util.Base64;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A simple model loader for loading data from a Data URL String.
+ *
+ * Data URIs use the "data" scheme.
+ *
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ *
+ * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
+ *
+ * @param <Data> The type of data that can be opened.
+ */
+public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+
+  private static final String DATA_SCHEME_IMAGE = "data:image";
+  private static final String BASE64_TAG = ";base64";
+  private final DataDecoder<Data> dataDecoder;
+
+  public DataUrlLoader(DataDecoder<Data> dataDecoder) {
+    this.dataDecoder = dataDecoder;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
+    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  }
+
+  @Override
+  public boolean handles(String url) {
+    return url.startsWith(DATA_SCHEME_IMAGE);
+  }
+
+  /**
+   * Allows decoding a specific type of data from a Data URL String.
+   *
+   * @param <Data> The type of data that can be opened.
+   */
+  public interface DataDecoder<Data> {
+
+    Data decode(String uri) throws IllegalArgumentException;
+
+    void close(Data data) throws IOException;
+
+    Class<Data> getDataClass();
+  }
+
+  private static final class DataUriFetcher<Data> implements DataFetcher<Data> {
+
+    private final String dataUri;
+    private final DataDecoder<Data> reader;
+    private Data data;
+
+    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+      this.dataUri = dataUri;
+      this.reader = reader;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      try {
+        data = reader.decode(dataUri);
+        callback.onDataReady(data);
+      } catch (IllegalArgumentException e) {
+        callback.onLoadFailed(e);
+      }
+    }
+
+    @Override
+    public void cleanup() {
+      try {
+        reader.close(data);
+      } catch (IOException e) {
+        // Ignored.
+      }
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<Data> getDataClass() {
+      return reader.getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for loading {@link InputStream} from Data URL string.
+   */
+  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+
+    private final DataDecoder<InputStream> opener;
+
+    public StreamFactory() {
+      opener = new DataDecoder<InputStream>() {
+        @Override
+        public InputStream decode(String url) {
+          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+            throw new IllegalArgumentException("Not a valid image data URL.");
+          }
+
+          int commaIndex = url.indexOf(',');
+          if (commaIndex == -1) {
+            throw new IllegalArgumentException("Missing comma in data URL.");
+          }
+
+          String beforeComma = url.substring(0, commaIndex);
+          if (!beforeComma.endsWith(BASE64_TAG)) {
+            throw new IllegalArgumentException("Not a base64 image data URL.");
+          }
+
+          String afterComma = url.substring(commaIndex + 1);
+          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+          return new ByteArrayInputStream(bytes);
+        }
+
+        @Override
+        public void close(InputStream inputStream) throws IOException {
+          inputStream.close();
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      };
+    }
+
+    @Override
+    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new DataUrlLoader<>(opener);
+    }
+
+    @Override
+    public final void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 532c9cac9..104af06e4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,16 +1,12 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -24,6 +20,7 @@
  *               java.io.InputStream} or {@link java.io.FileDescriptor} etc).
  */
 public class FileLoader<Data> implements ModelLoader<File, Data> {
+  private static final String TAG = "FileLoader";
 
   private final FileOpener<Data> fileOpener;
 
@@ -67,8 +64,8 @@ public void loadData(Priority priority, DataCallback<? super Data> callback) {
       try {
         data = opener.open(file);
       } catch (FileNotFoundException e) {
-        if (Logs.isEnabled(Log.DEBUG)) {
-          Logs.log(Log.DEBUG, "Failed to open file", e);
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to open file", e);
         }
         callback.onLoadFailed(e);
         return;
@@ -115,8 +112,7 @@ public Factory(FileOpener<Data> opener) {
     }
 
     @Override
-    public final ModelLoader<File, Data> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index a51e53707..02a26aa26 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.security.MessageDigest;
@@ -28,20 +27,22 @@
  */
 public class GlideUrl implements Key {
   private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
-  private final URL url;
   private final Headers headers;
-  private final String stringUrl;
+  @Nullable private final URL url;
+  @Nullable private final String stringUrl;
 
-  private String safeStringUrl;
-  private URL safeUrl;
-  private volatile byte[] cacheKeyBytes;
+  @Nullable private String safeStringUrl;
+  @Nullable private URL safeUrl;
+  @Nullable private volatile byte[] cacheKeyBytes;
+
+  private int hashCode;
 
   public GlideUrl(URL url) {
-    this(url, Headers.NONE);
+    this(url, Headers.DEFAULT);
   }
 
   public GlideUrl(String url) {
-    this(url, Headers.NONE);
+    this(url, Headers.DEFAULT);
   }
 
   public GlideUrl(URL url, Headers headers) {
@@ -140,8 +141,10 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int hashCode = getCacheKey().hashCode();
-    hashCode = 31 * hashCode + headers.hashCode();
+    if (hashCode == 0) {
+      hashCode = getCacheKey().hashCode();
+      hashCode = 31 * hashCode + headers.hashCode();
+    }
     return hashCode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
index b60a3da88..f55d16f4e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Headers.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -10,7 +10,12 @@
  */
 public interface Headers {
 
-  /** An empty Headers object that can be used if users don't want to provide headers. */
+  /**
+   * An empty Headers object that can be used if users don't want to provide headers.
+   *
+   * @deprecated Use {@link #DEFAULT} instead.
+   */
+  @Deprecated
   Headers NONE = new Headers() {
       @Override
       public Map<String, String> getHeaders() {
@@ -18,6 +23,12 @@
       }
   };
 
+  /**
+   * A Headers object containing reasonable defaults that should be used when users don't want
+   * to provide their own headers.
+   */
+  Headers DEFAULT = new LazyHeaders.Builder().build();
+
   /**
    * Returns a non-null map containing a set of headers to apply to an http request.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 78f292430..66a76cd11 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 /**
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
@@ -8,6 +10,15 @@
  */
 public interface LazyHeaderFactory {
 
+    /**
+     * Returns an http header, or {@code null} if no header could be built.
+     *
+     * <p>Returning {@code null} or an empty String from this method will result in this particular
+     * key/value being excluded from the headers provided in the request. If there are multiple
+     * factories or values for a particular key, any non-null values will still be included for that
+     * key.
+     */
+    @Nullable
     String buildHeader();
 
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index ca2f5c658..31b30bb5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.text.TextUtils;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -45,12 +46,18 @@
       int size = factories.size();
       for (int i = 0; i < size; i++) {
         LazyHeaderFactory factory = factories.get(i);
-        sb.append(factory.buildHeader());
-        if (i != factories.size() - 1) {
-          sb.append(',');
+        String header = factory.buildHeader();
+        if (!TextUtils.isEmpty(header)) {
+          sb.append(header);
+          if (i != factories.size() - 1) {
+            sb.append(',');
+          }
         }
       }
-      combinedHeaders.put(entry.getKey(), sb.toString());
+      String values = sb.toString();
+      if (!TextUtils.isEmpty(values)) {
+        combinedHeaders.put(entry.getKey(), sb.toString());
+      }
     }
 
     return combinedHeaders;
@@ -78,21 +85,55 @@ public int hashCode() {
   }
 
   /**
-   * Builder class for {@link LazyHeaders}.
+   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
+   * key* lazily on a background thread.
    *
    * <p> This class is not thread safe. </p>
+   *
+   * <p> This class may include default values for User-Agent and Accept-Encoding headers. These
+   * will be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or
+   * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
+   * would usually append an additional value. </p>
    */
+   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
+  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
-    private boolean copyOnModify;
-    private Map<String, List<LazyHeaderFactory>> headers = new HashMap<>();
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
+    private static final String ENCODING_HEADER = "Accept-Encoding";
+    private static final String DEFAULT_ENCODING = "identity";
+    private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;
+
+    // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for
+    // images and also makes it more difficult for us to detect and prevent partial content
+    // rendering. See #440.
+    static {
+      Map<String, List<LazyHeaderFactory>> temp
+          = new HashMap<>(2);
+      if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {
+        temp.put(USER_AGENT_HEADER,
+            Collections.<LazyHeaderFactory>singletonList(
+                new StringHeaderFactory(DEFAULT_USER_AGENT)));
+      }
+      temp.put(ENCODING_HEADER,
+          Collections.<LazyHeaderFactory>singletonList(
+              new StringHeaderFactory(DEFAULT_ENCODING)));
+      DEFAULT_HEADERS = Collections.unmodifiableMap(temp);
+    }
+
+    private boolean copyOnModify = true;
+    private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
+    private boolean isEncodingDefault = true;
+    private boolean isUserAgentDefault = true;
 
     /**
      * Adds a value for the given header and returns this builder.
      *
-     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires
-     * I/O (ie an oauth token). </p>
+     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
+
      */
     public Builder addHeader(String key, String value) {
       return addHeader(key, new StringHeaderFactory(value));
@@ -100,27 +141,78 @@ public Builder addHeader(String key, String value) {
 
     /**
      * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
-     * key* lazily on a background thread.
+     * key lazily on a background thread.
      *
-     * <p> Headers may have multiple values whose order is defined by the order in which this
-     * method is called. </p>
+     * <p> Headers may have multiple values whose order is defined by the order in which
+     * this method is called. </p>
      *
-     * <p> This class does not prevent you from adding the same value to a given key multiple times
-     * </p>
+     * <p> This class does not prevent you from adding the same value to a given key multiple
+     * times </p>
      */
     public Builder addHeader(String key, LazyHeaderFactory factory) {
-      if (copyOnModify) {
-        copyOnModify = false;
-        headers = copyHeaders();
+      if ((isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key))
+          || (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key))) {
+        return setHeader(key, factory);
       }
 
+      copyIfNecessary();
+      getFactories(key).add(factory);
+      return this;
+    }
+
+    /**
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
+     * with the given {@link LazyHeaderFactory}.
+     *
+     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     *
+     * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token). </p>
+     */
+    public Builder setHeader(String key, String value) {
+      return setHeader(key, value == null ? null : new StringHeaderFactory(value));
+    }
+
+    /**
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
+     * with the given {@link LazyHeaderFactory}.
+     *
+     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     */
+    public Builder setHeader(String key, LazyHeaderFactory factory) {
+      copyIfNecessary();
+      if (factory == null) {
+        headers.remove(key);
+      } else {
+        List<LazyHeaderFactory> factories = getFactories(key);
+        factories.clear();
+        factories.add(factory);
+      }
+
+      if (isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key)) {
+        isEncodingDefault = false;
+      }
+      if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
+        isUserAgentDefault = false;
+      }
+
+      return this;
+    }
+
+    private List<LazyHeaderFactory> getFactories(String key) {
       List<LazyHeaderFactory> factories = headers.get(key);
       if (factories == null) {
         factories = new ArrayList<>();
         headers.put(key, factories);
       }
-      factories.add(factory);
-      return this;
+      return factories;
+    }
+
+    private void copyIfNecessary() {
+      if (copyOnModify) {
+        copyOnModify = false;
+        headers = copyHeaders();
+      }
     }
 
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index ac81aa270..5326fd2d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -5,14 +5,12 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.text.TextUtils;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 
@@ -99,8 +97,14 @@ public DataSource getDataSource() {
    */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 7e36ae63b..a4f10978a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 /**
@@ -40,6 +40,7 @@ protected void onItemEvicted(ModelKey<A> key, B item) {
    * @param height The height in pixels of the view the image is being loaded into.
    * @return The cached result, or null.
    */
+  @Nullable
   public B get(A model, int width, int height) {
     ModelKey<A> key = ModelKey.get(model, width, height);
     B result = cache.get(key);
@@ -107,7 +108,7 @@ public void release() {
     @Override
     public boolean equals(Object o) {
       if (o instanceof ModelKey) {
-        ModelKey other = (ModelKey) o;
+        @SuppressWarnings("unchecked") ModelKey<A> other = (ModelKey<A>) o;
         return width == other.width && height == other.height && model.equals(other.model);
       }
       return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 4f208479a..230551c5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -21,7 +21,7 @@
  *
  * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
  * the size of a view on devices with different densities, but also allows you to use layout weights
- * or otherwise programatically put the dimensions of the view without forcing you to fetch a
+ * or otherwise programmatically put the dimensions of the view without forcing you to fetch a
  * generic resource size.
  *
  * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
@@ -76,6 +76,7 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
    *               the resource should be loaded at its original height.
    */
+  @Nullable
   LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index c3813f9ad..19e126019 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -18,13 +18,11 @@
   /**
    * Build a concrete ModelLoader for this model type.
    *
-   * @param context      A context that cannot be retained by the factory but can be retained by the
-   *                     {@link ModelLoader}
    * @param multiFactory A map of classes to factories that can be used to construct additional
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
+  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index 6fc168095..77923f2c4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
-import com.bumptech.glide.load.engine.ExceptionListPool;
-
+import android.support.v4.util.Pools.Pool;
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -19,8 +17,8 @@
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Context context, ExceptionListPool exceptionListPool) {
-    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
+    this(new MultiModelLoaderFactory(exceptionListPool));
   }
 
   // Visible for testing.
@@ -96,6 +94,9 @@ public ModelLoaderRegistry(Context context, ExceptionListPool exceptionListPool)
   private static class ModelLoaderCache {
     private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
 
+    @Synthetic
+    ModelLoaderCache() { }
+
     public void clear() {
       cachedModelLoaders.clear();
     }
@@ -114,7 +115,7 @@ public void clear() {
     }
 
     private static class Entry<Model> {
-      private final List<ModelLoader<Model, ?>> loaders;
+      @Synthetic final List<ModelLoader<Model, ?>> loaders;
 
       public Entry(List<ModelLoader<Model, ?>> loaders) {
         this.loaders = loaders;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index a2ad2f2ec..dd8b59921 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.model;
 
+import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
-import com.bumptech.glide.load.engine.ExceptionListPool;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -26,10 +25,10 @@
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
-  private final ExceptionListPool exceptionListPool;
+  private final Pool<List<Exception>> exceptionListPool;
 
   MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
-      ExceptionListPool exceptionListPool) {
+      Pool<List<Exception>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
@@ -73,13 +72,13 @@ public String toString() {
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
 
     private final List<DataFetcher<Data>> fetchers;
-    private final ExceptionListPool exceptionListPool;
+    private final Pool<List<Exception>> exceptionListPool;
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
     private List<Exception> exceptions;
 
-    MultiFetcher(List<DataFetcher<Data>> fetchers, ExceptionListPool exceptionListPool) {
+    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
       this.exceptionListPool = exceptionListPool;
       Preconditions.checkNotEmpty(fetchers);
       this.fetchers = fetchers;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 9a0f277a7..4c63136a5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
+import android.support.annotation.Nullable;
+import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.ExceptionListPool;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -21,19 +20,18 @@
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
-  private final Context context;
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
-  private final ExceptionListPool exceptionListPool;
+  private final Pool<List<Exception>> exceptionListPool;
 
-  public MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListPool) {
-    this(context, exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
+    this(exceptionListPool, DEFAULT_FACTORY);
   }
 
   // Visible for testing.
-  MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListPool, Factory factory) {
+  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
+      Factory factory) {
     this.exceptionListPool = exceptionListPool;
-    this.context = context.getApplicationContext();
     this.factory = factory;
   }
 
@@ -74,23 +72,28 @@ public MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListP
   }
 
   synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
-    List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
-    for (Entry<?, ?> entry : entries) {
-      // Avoid stack overflow recursively creating model loaders by only creating loaders in
-      // recursive requests if they haven't been created earlier in the chain. For example:
-      // A Uri loader may translate to another model, which in turn may translate back to a Uri.
-      // The original Uri loader won't be provided to the intermediate model loader, although other
-      // Uri loaders will be.
-      if (alreadyUsedEntries.contains(entry)) {
-        continue;
-      }
-      if (entry.handles(modelClass)) {
-        alreadyUsedEntries.add(entry);
-        loaders.add(this.<Model, Object>build(entry));
-        alreadyUsedEntries.remove(entry);
+    try {
+      List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
+      for (Entry<?, ?> entry : entries) {
+        // Avoid stack overflow recursively creating model loaders by only creating loaders in
+        // recursive requests if they haven't been created earlier in the chain. For example:
+        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
+        // The original Uri loader won't be provided to the intermediate model loader, although
+        // other Uri loaders will be.
+        if (alreadyUsedEntries.contains(entry)) {
+          continue;
+        }
+        if (entry.handles(modelClass)) {
+          alreadyUsedEntries.add(entry);
+          loaders.add(this.<Model, Object>build(entry));
+          alreadyUsedEntries.remove(entry);
+        }
       }
+      return loaders;
+    } catch (Throwable t) {
+      alreadyUsedEntries.clear();
+      throw t;
     }
-    return loaders;
   }
 
   synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
@@ -105,37 +108,42 @@ public MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListP
 
   public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
       Class<Data> dataClass) {
-    List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
-    boolean ignoredAnyEntries = false;
-    for (Entry<?, ?> entry : entries) {
-      // Avoid stack overflow recursively creating model loaders by only creating loaders in
-      // recursive requests if they haven't been created earlier in the chain. For example:
-      // A Uri loader may translate to another model, which in turn may translate back to a Uri.
-      // The original Uri loader won't be provided to the intermediate model loader, although other
-      // Uri loaders will be.
-      if (alreadyUsedEntries.contains(entry)) {
-        ignoredAnyEntries = true;
-        continue;
+    try {
+      List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
+      boolean ignoredAnyEntries = false;
+      for (Entry<?, ?> entry : entries) {
+        // Avoid stack overflow recursively creating model loaders by only creating loaders in
+        // recursive requests if they haven't been created earlier in the chain. For example:
+        // A Uri loader may translate to another model, which in turn may translate back to a Uri.
+        // The original Uri loader won't be provided to the intermediate model loader, although
+        // other Uri loaders will be.
+        if (alreadyUsedEntries.contains(entry)) {
+          ignoredAnyEntries = true;
+          continue;
+        }
+        if (entry.handles(modelClass, dataClass)) {
+          alreadyUsedEntries.add(entry);
+          loaders.add(this.<Model, Data>build(entry));
+          alreadyUsedEntries.remove(entry);
+        }
       }
-      if (entry.handles(modelClass, dataClass)) {
-        alreadyUsedEntries.add(entry);
-        loaders.add(this.<Model, Data>build(entry));
-        alreadyUsedEntries.remove(entry);
-      }
-    }
-    if (loaders.size() > 1) {
-      return factory.build(loaders, exceptionListPool);
-    } else if (loaders.size() == 1) {
-      return loaders.get(0);
-    } else {
-      // Avoid crashing if recursion results in no loaders available. The assertion is supposed to
-      // catch completely unhandled types, recursion may mean a subtype isn't handled somewhere
-      // down the stack, which is often ok.
-      if (ignoredAnyEntries) {
-        return emptyModelLoader();
+      if (loaders.size() > 1) {
+        return factory.build(loaders, exceptionListPool);
+      } else if (loaders.size() == 1) {
+        return loaders.get(0);
       } else {
-        throw new NoModelLoaderAvailableException(modelClass, dataClass);
+        // Avoid crashing if recursion results in no loaders available. The assertion is supposed to
+        // catch completely unhandled types, recursion may mean a subtype isn't handled somewhere
+        // down the stack, which is often ok.
+        if (ignoredAnyEntries) {
+          return emptyModelLoader();
+        } else {
+          throw new NoModelLoaderAvailableException(modelClass, dataClass);
+        }
       }
+    } catch (Throwable t) {
+      alreadyUsedEntries.clear();
+      throw t;
     }
   }
 
@@ -146,8 +154,7 @@ public MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListP
 
   @SuppressWarnings("unchecked")
   private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
-    return (ModelLoader<Model, Data>) Preconditions
-        .checkNotNull(entry.factory.build(context, this));
+    return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
   @SuppressWarnings("unchecked")
@@ -157,8 +164,8 @@ public MultiModelLoaderFactory(Context context, ExceptionListPool exceptionListP
 
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
-    private final Class<Data> dataClass;
-    private final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final Class<Data> dataClass;
+    @Synthetic final ModelLoaderFactory<Model, Data> factory;
 
     public Entry(Class<Model> modelClass, Class<Data> dataClass,
         ModelLoaderFactory<Model, Data> factory) {
@@ -178,16 +185,20 @@ public boolean handles(Class<?> modelClass) {
 
   static class Factory {
     public <Model, Data> MultiModelLoader<Model, Data> build(
-        List<ModelLoader<Model, Data>> modelLoaders, ExceptionListPool exceptionListPool) {
+        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
       return new MultiModelLoader<>(modelLoaders, exceptionListPool);
     }
   }
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
 
+    @Synthetic
+    EmptyModelLoader() { }
+
+    @Nullable
     @Override
     public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
-      throw new UnsupportedOperationException("EmptyModelLoader does not handle data");
+      return null;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 434aadfb4..24fc4b6ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 
 /**
@@ -22,10 +20,6 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
-  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
-    this(context.getResources(), uriLoader);
-  }
-
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
@@ -38,6 +32,7 @@ public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
 
+  @Nullable
   private Uri getResourceUri(Integer model) {
     try {
       return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://"
@@ -63,10 +58,15 @@ public boolean handles(Integer model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
+    private final Resources resources;
+
+    public StreamFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
+    public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
@@ -81,11 +81,16 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
+    private final Resources resources;
+
+    public FileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context,
-          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 45b168512..28a06ca9e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -18,15 +16,15 @@
  */
 public class StreamEncoder implements Encoder<InputStream> {
   private static final String TAG = "StreamEncoder";
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamEncoder(ByteArrayPool byteArrayPool) {
+  public StreamEncoder(ArrayPool byteArrayPool) {
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
   public boolean encode(InputStream data, File file, Options options) {
-    byte[] buffer = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
     try {
@@ -49,7 +47,7 @@ public boolean encode(InputStream data, File file, Options options) {
           // Do nothing.
         }
       }
-      byteArrayPool.put(buffer);
+      byteArrayPool.put(buffer, byte[].class);
     }
     return success;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index d0148ce8f..62061cf16 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.File;
 import java.io.InputStream;
 
@@ -27,7 +25,7 @@ public StringLoader(ModelLoader<Uri, Data> uriLoader) {
   public LoadData<Data> buildLoadData(String model, int width, int height,
       Options options) {
     Uri uri = parseUri(model);
-    return uriLoader.buildLoadData(uri, width, height, options);
+    return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
 
   @Override
@@ -35,6 +33,7 @@ public boolean handles(String model) {
     return true;
   }
 
+  @Nullable
   private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
@@ -61,8 +60,7 @@ private static Uri toFileUri(String path) {
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @Override
-    public ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -79,8 +77,7 @@ public void teardown() {
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index b3807a2db..198f01bfa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -64,13 +62,13 @@ public DataSource getDataSource() {
 
   /**
    * Factory for producing {@link com.bumptech.glide.load.model.UnitModelLoader}s.
+   *
+   * @param <Model> The type of model that will also be returned as decodable data.
    */
-  public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType,
-      ResourceType> {
+  public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
 
     @Override
-    public ModelLoader<ResourceType, ResourceType> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
       return new UnitModelLoader<>();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index d6a66a163..26cc3be5f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,16 +1,13 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -36,18 +33,16 @@
       )
   );
 
-  private final Context context;
   private final LocalUriFetcherFactory<Data> factory;
 
-  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
-    this.context = context;
+  public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
   public LoadData<Data> buildLoadData(Uri model, int width, int height,
       Options options) {
-    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+    return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
@@ -61,7 +56,7 @@ public boolean handles(Uri model) {
    * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
    */
   public interface LocalUriFetcherFactory<Data> {
-    DataFetcher<Data> build(Context context, Uri uri);
+    DataFetcher<Data> build(Uri uri);
   }
 
   /**
@@ -70,15 +65,20 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       LocalUriFetcherFactory<InputStream> {
 
+    private final ContentResolver contentResolver;
+
+    public StreamFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<InputStream> build(Context context, Uri uri) {
-      return new StreamLocalUriFetcher(context, uri);
+    public DataFetcher<InputStream> build(Uri uri) {
+      return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
@@ -94,15 +94,20 @@ public void teardown() {
       ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
+    private final ContentResolver contentResolver;
+
+    public FileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
-      return new FileDescriptorLocalUriFetcher(context, uri);
+    public DataFetcher<ParcelFileDescriptor> build(Uri uri) {
+      return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f71d7e789..af2f2459a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -50,8 +47,7 @@ public boolean handles(Uri uri) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index 88cfd81a5..d2944e47e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,14 +1,13 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -22,19 +21,20 @@
  */
 public abstract class BaseGlideUrlLoader<Model> implements ModelLoader<Model, InputStream> {
   private final ModelLoader<GlideUrl, InputStream> concreteLoader;
-  private final ModelCache<Model, GlideUrl> modelCache;
+  @Nullable private final ModelCache<Model, GlideUrl> modelCache;
 
   protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader) {
     this(concreteLoader, null);
   }
 
   protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
-      ModelCache<Model, GlideUrl> modelCache) {
+      @Nullable ModelCache<Model, GlideUrl> modelCache) {
     this.concreteLoader = concreteLoader;
     this.modelCache = modelCache;
   }
 
   @Override
+  @Nullable
   public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
@@ -108,7 +108,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
+  @Nullable
   protected Headers getHeaders(Model model, int width, int height, Options options) {
-    return Headers.NONE;
+    return Headers.DEFAULT;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index 7294128ad..d29625946 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -9,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
@@ -17,8 +16,16 @@
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+  /**
+   * An integer option that is used to determine the maximum connect and read timeout durations (in
+   * milliseconds) for network connections.
+   *
+   * <p>Defaults to 2500ms.
+   */
+  public static final Option<Integer> TIMEOUT = Option.memory(
+      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
 
-  private final ModelCache<GlideUrl, GlideUrl> modelCache;
+  @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
   public HttpGlideUrlLoader() {
     this(null);
@@ -41,7 +48,8 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
         url = model;
       }
     }
-    return new LoadData<>(url, new HttpUrlFetcher(url));
+    int timeout = options.get(TIMEOUT);
+    return new LoadData<>(url, new HttpUrlFetcher(url, timeout));
   }
 
   @Override
@@ -56,8 +64,7 @@ public boolean handles(GlideUrl model) {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index e3f11a6f4..37b1e12fa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,14 +1,11 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -44,8 +41,7 @@ public boolean handles(Uri model) {
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index 635d8c131..c10cfc90a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,7 +2,6 @@
 
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -43,9 +41,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index a14853e01..2263f1cc5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -11,7 +11,6 @@
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -31,8 +30,10 @@
   }
 
   @Override
+  @Nullable
   public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
+      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -55,9 +56,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 5cbda7216..1dc7951d4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.net.URL;
 
@@ -40,8 +37,7 @@ public boolean handles(URL model) {
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
     @Override
-    public ModelLoader<URL, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 702ed39f0..023e2d978 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.resource;
 
+import android.content.Context;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 
 /**
@@ -28,7 +28,7 @@ private UnitTransformation() {
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
     return resource;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 6b9d9afae..5a0f9064d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,14 +4,12 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index 162783822..a414e6dd0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,13 +2,11 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index fc80aa1fa..989664e20 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
@@ -16,7 +16,8 @@
  * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
  * recycled. </p>
  */
-public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
+public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
+    implements Initializable {
   private final BitmapPool bitmapPool;
 
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
@@ -38,4 +39,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(drawable.getBitmap());
   }
+
+  @Override
+  public void initialize() {
+    drawable.getBitmap().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 6527b931e..299e31d42 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,13 +3,11 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -17,31 +15,43 @@
  */
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Context context;
-  private final BitmapPool bitmapPool;
   private final Transformation<Bitmap> wrapped;
 
-  public BitmapDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(context, Glide.get(context).getBitmapPool(), wrapped);
+  public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  // Visible for testing.
-  BitmapDrawableTransformation(Context context, BitmapPool bitmapPool,
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       Transformation<Bitmap> wrapped) {
-    this.context = context.getApplicationContext();
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this(wrapped);
   }
 
   @Override
-  public Resource<BitmapDrawable> transform(Resource<BitmapDrawable> drawableResourceToTransform,
-      int outWidth, int outHeight) {
+  public Resource<BitmapDrawable> transform(
+      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
+      int outHeight) {
     BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
     Bitmap bitmapToTransform = drawableToTransform.getBitmap();
 
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
     Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(bitmapResourceToTransform, outWidth, outHeight);
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
 
     if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
       return drawableResourceToTransform;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index d769ae12a..b4ef6c4ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -2,7 +2,6 @@
 
 import android.graphics.Bitmap;
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index c3a1d2302..102c688c0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -10,7 +11,8 @@
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
-public class BitmapResource implements Resource<Bitmap> {
+public class BitmapResource implements Resource<Bitmap>,
+    Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -21,7 +23,8 @@
    * @param bitmap     A Bitmap.
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
-  public static BitmapResource obtain(Bitmap bitmap, BitmapPool bitmapPool) {
+  @Nullable
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
     if (bitmap == null) {
       return null;
     } else {
@@ -51,8 +54,11 @@ public int getSize() {
 
   @Override
   public void recycle() {
-    if (!bitmapPool.put(bitmap)) {
-      bitmap.recycle();
-    }
+    bitmapPool.put(bitmap);
+  }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index e7190549c..f204cc54e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -52,23 +52,29 @@
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  private final BitmapPool bitmapPool;
+  public BitmapTransformation() {
+    // Intentionally empty.
+  }
 
-  public BitmapTransformation(Context context) {
-    this(Glide.get(context).getBitmapPool());
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public BitmapTransformation(BitmapPool bitmapPool) {
-    this.bitmapPool = bitmapPool;
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
+  public final Resource<Bitmap> transform(
+      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap toTransform = resource.get();
     int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
     int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
@@ -108,9 +114,9 @@ public BitmapTransformation(BitmapPool bitmapPool) {
    * @param toTransform The {@link android.graphics.Bitmap} to transform.
    * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
    *                    need to match exactly).
-   * @param outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not
+   * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
    *                    need to match exactly).
    */
-  protected abstract Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth,
-      int outHeight);
+  protected abstract Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 6a89df27a..f24c63ce6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -1,14 +1,144 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.graphics.drawable.Drawable;
 import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.request.transition.BitmapTransitionFactory;
+import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
- * Provides {@link Bitmap} specific animation options.
- *
- * TODO: we should probably just use GenericAnimationOptions instead.
+ * Contains {@link Bitmap} specific animation options.
  */
-public final class BitmapTransitionOptions extends TransitionOptions<BitmapTransitionOptions,
-    Bitmap> {
+public final class BitmapTransitionOptions extends
+    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
+  public static BitmapTransitionOptions withCrossFade() {
+    return new BitmapTransitionOptions().crossFade();
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int duration) {
+    return new BitmapTransitionOptions().crossFade(duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int animationId, int duration) {
+    return new BitmapTransitionOptions().crossFade(animationId, duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new BitmapTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
+   * that is possible on drawables.
+   *
+   * @see #transitionUsing(TransitionFactory)
+   */
+  public static BitmapTransitionOptions withWrapped(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static BitmapTransitionOptions with(
+      TransitionFactory<Bitmap> transitionFactory) {
+    return new BitmapTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade() {
+    return crossFade(new DrawableCrossFadeFactory.Builder());
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  public BitmapTransitionOptions crossFade(int duration) {
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  public BitmapTransitionOptions crossFade(int animationId, int duration) {
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a any Drawable based animation to run on Bitmaps as well.
+   */
+  public BitmapTransitionOptions transitionUsing(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return transitionUsing(builder.build());
+  }
 }
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index b8cb4624a..6a6c9ec8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index 4ba4a3806..bdc38562a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -2,9 +2,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -18,25 +17,26 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop(Context context) {
-    super(context);
+  public CenterCrop() {
+    // Intentionally empty.
+  }
+
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public CenterCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-    final Bitmap toReuse = pool.get(outWidth, outHeight,
-        toTransform.getConfig() != null ? toTransform.getConfig() : Bitmap.Config.ARGB_8888);
-    Bitmap transformed = TransformationUtils.centerCrop(toReuse, toTransform, outWidth, outHeight);
-    if (toReuse != null && toReuse != transformed && !pool.put(toReuse)) {
-      toReuse.recycle();
-    }
-    return transformed;
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
new file mode 100644
index 000000000..6efdbad47
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Returns the image with its original size if its dimensions match or are smaller
+ * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
+ * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
+ * the image will be equal to the given dimension and the other will be less than the given
+ * dimension (maintaining the image's aspect ratio).
+ */
+public class CenterInside extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public CenterInside() {
+    // Intentionally empty.
+  }
+
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") Context context) {
+    this();
+  }
+
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
+  }
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CenterInside;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
+}
+
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 4375c9330..655487175 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -2,10 +2,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -21,25 +19,32 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop(Context context) {
-    super(context);
+  public CircleCrop() {
+    // Intentionally empty.
+  }
+
+  /**
+   * @deprecated Use {@link #CircleCrop()}.
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public CircleCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #CircleCrop()}
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-    final Bitmap toReuse = pool.get(outWidth, outHeight,
-        toTransform.getConfig() != null ? toTransform.getConfig() : Config.ARGB_8888);
-    Bitmap transformed = TransformationUtils.circleCrop(toReuse, toTransform, outWidth, outHeight);
-    if (toReuse != null && toReuse != transformed && !pool.put(toReuse)) {
-      toReuse.recycle();
-    }
-    return transformed;
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
similarity index 68%
rename from library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
rename to library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 2411ddab0..5bfe67f8c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -1,16 +1,15 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
 import android.util.Log;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -20,80 +19,66 @@
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
-public class ImageHeaderParser {
-  private static final String TAG = "ImageHeaderParser";
-  /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
-   */
-  public static final int UNKNOWN_ORIENTATION = -1;
-
-  /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
-   */
-  public enum ImageType {
-    GIF(true),
-    JPEG(false),
-    /** PNG type with alpha. */
-    PNG_A(true),
-    /** PNG type without alpha. */
-    PNG(false),
-    /**
-     * Unrecognized type.
-     */
-    UNKNOWN(false);
-    private final boolean hasAlpha;
-
-    ImageType(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
+public final class DefaultImageHeaderParser implements ImageHeaderParser {
+  // Due to https://code.google.com/p/android/issues/detail?id=97751.
+  // TAG needs to be under 23 chars, so "Default" > "Dflt".
+  private static final String TAG = "DfltImageHeaderParser";
 
   private static final int GIF_HEADER = 0x474946;
   private static final int PNG_HEADER = 0x89504E47;
-  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  static final int EXIF_MAGIC_NUMBER = 0xFFD8;
   // "MM".
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
   private static final int MARKER_EOI = 0xD9;
-  private static final int SEGMENT_START_ID = 0xFF;
-  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  static final int SEGMENT_START_ID = 0xFF;
+  static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+  // WebP-related
+  // "RIFF"
+  private static final int RIFF_HEADER = 0x52494646;
+  // "WEBP"
+  private static final int WEBP_HEADER = 0x57454250;
+  // "VP8" null.
+  private static final int VP8_HEADER = 0x56503800;
+  private static final int VP8_HEADER_MASK = 0xFFFFFF00;
+  private static final int VP8_HEADER_TYPE_MASK = 0x000000FF;
+  // 'X'
+  private static final int VP8_HEADER_TYPE_EXTENDED = 0x00000058;
+  // 'L'
+  private static final int VP8_HEADER_TYPE_LOSSLESS = 0x0000004C;
+  private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
+  private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
+
+  @Override
+  public ImageType getType(InputStream is) throws IOException {
+    return getType(new StreamReader(Preconditions.checkNotNull(is)));
+  }
 
-  private final ByteArrayPool byteArrayPool;
-  private final Reader reader;
-
-  public ImageHeaderParser(InputStream is, ByteArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(is);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new StreamReader(is);
+  @Override
+  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+    return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ByteArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(byteBuffer);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new ByteBufferReader(byteBuffer);
+  @Override
+  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  // 0xD0A3C68 -> <htm
-  // 0xCAFEBABE -> <!DOCTYPE...
-  public boolean hasAlpha() throws IOException {
-    return getType().hasAlpha();
+  @Override
+  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  public ImageType getType() throws IOException {
+  private ImageType getType(Reader reader) throws IOException {
     int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
@@ -117,7 +102,33 @@ public ImageType getType() throws IOException {
       return GIF;
     }
 
-    return UNKNOWN;
+    // WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container
+    // for details.
+    if (firstFourBytes != RIFF_HEADER) {
+      return UNKNOWN;
+    }
+    // Bytes 4 - 7 contain length information. Skip these.
+    reader.skip(4);
+    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if (thirdFourBytes != WEBP_HEADER) {
+      return UNKNOWN;
+    }
+    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
+      return UNKNOWN;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) {
+      // Skip some more length bytes and check for transparency/alpha flag.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_EXTENDED_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) {
+      // See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt
+      // for more info.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_LOSSLESS_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    return ImageType.WEBP;
   }
 
   /**
@@ -128,7 +139,7 @@ public ImageType getType() throws IOException {
    * contain an orientation
    * @throws IOException
    */
-  public int getOrientation() throws IOException {
+  private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
 
     if (!handles(magicNumber)) {
@@ -137,7 +148,7 @@ public int getOrientation() throws IOException {
       }
       return UNKNOWN_ORIENTATION;
     } else {
-      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      int exifSegmentLength = moveToExifSegmentAndGetLength(reader);
       if (exifSegmentLength == -1) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
@@ -145,16 +156,17 @@ public int getOrientation() throws IOException {
         return UNKNOWN_ORIENTATION;
       }
 
-      byte[] exifData = byteArrayPool.get(exifSegmentLength);
+      byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
-        return parseExifSegment(exifData, exifSegmentLength);
+        return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
-        byteArrayPool.put(exifData);
+        byteArrayPool.put(exifData, byte[].class);
       }
     }
   }
 
-  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+  private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLength)
+      throws IOException {
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -194,7 +206,7 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * Moves reader to the start of the exif segment and returns the length of the exif segment or
    * {@code -1} if no exif segment is found.
    */
-  private int moveToExifSegmentAndGetLength() throws IOException {
+  private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
     short segmentId, segmentType;
     int segmentLength;
     while (true) {
@@ -334,29 +346,33 @@ private static boolean handles(int imageMagicNumber) {
         || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
   }
 
-  private static class RandomAccessReader {
+  private static final class RandomAccessReader {
     private final ByteBuffer data;
 
-    public RandomAccessReader(byte[] data, int length) {
+    RandomAccessReader(byte[] data, int length) {
       this.data = (ByteBuffer) ByteBuffer.wrap(data)
           .order(ByteOrder.BIG_ENDIAN)
           .limit(length);
     }
 
-    public void order(ByteOrder byteOrder) {
+    void order(ByteOrder byteOrder) {
       this.data.order(byteOrder);
     }
 
-    public int length() {
+    int length() {
       return data.remaining();
     }
 
-    public int getInt32(int offset) {
-      return data.getInt(offset);
+    int getInt32(int offset) {
+      return isAvailable(offset, 4) ? data.getInt(offset) : -1;
     }
 
-    public short getInt16(int offset) {
-      return data.getShort(offset);
+    short getInt16(int offset) {
+      return isAvailable(offset, 2) ? data.getShort(offset) : -1;
+    }
+
+    private boolean isAvailable(int offset, int byteSize) {
+      return data.remaining() - offset >= byteSize;
     }
   }
 
@@ -368,11 +384,11 @@ public short getInt16(int offset) {
     int getByte() throws IOException;
   }
 
-  private static class ByteBufferReader implements Reader {
+  private static final class ByteBufferReader implements Reader {
 
     private final ByteBuffer byteBuffer;
 
-    public ByteBufferReader(ByteBuffer byteBuffer) {
+    ByteBufferReader(ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
       byteBuffer.order(ByteOrder.BIG_ENDIAN);
     }
@@ -397,7 +413,10 @@ public long skip(long total) throws IOException {
     @Override
     public int read(byte[] buffer, int byteCount) throws IOException {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
-      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      if (toRead == 0) {
+        return -1;
+      }
+      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);
       return toRead;
     }
 
@@ -410,10 +429,10 @@ public int getByte() throws IOException {
     }
   }
 
-  private static class StreamReader implements Reader {
+  private static final class StreamReader implements Reader {
     private final InputStream is;
     // Motorola / big endian byte order.
-    public StreamReader(InputStream is) {
+    StreamReader(InputStream is) {
       this.is = is;
     }
 
@@ -470,4 +489,3 @@ public int getByte() throws IOException {
     }
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index d91b83a23..71548c5e9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * Indicates the algorithm to use when downsampling images.
  */
@@ -11,9 +13,13 @@
    * requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
+   * {@link #CENTER_INSIDE}.
+   *
+   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
+   * two downsampling can be used.
    */
-  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
   /**
    * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
@@ -21,7 +27,11 @@
    * the requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
+   * or {@link #CENTER_INSIDE}.
+   *
+   * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
+   * two downsampling can be used.
    */
   public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
 
@@ -37,15 +47,24 @@
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
+  /**
+   * Returns the original image if it is smaller than the target, otherwise it will be downscaled
+   * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
+   * to the requested size and the other is less or equal than the requested size.
+   *
+   * <p>This method will not upscale.</p>
+   */
+  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+
   /**
    * Performs no downsampling or scaling.
    */
   public static final DownsampleStrategy NONE = new None();
 
   /**
-   * Default strategy, currently {@link #AT_LEAST}.
+   * Default strategy, currently {@link #CENTER_OUTSIDE}.
    */
-  public static final DownsampleStrategy DEFAULT = AT_LEAST;
+  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
   /**
    * Returns a float (0, +infinity) indicating a scale factor to apply to the source
@@ -57,6 +76,9 @@
    * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale
    * factor may not be applied precisely.
    *
+   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power
+   * of two downsampling will be applied.
+   *
    * @param sourceWidth   The width in pixels of the image to be downsampled.
    * @param sourceHeight  The height in pixels of the image to be downsampled.
    * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
@@ -77,7 +99,10 @@ public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requ
   public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
       int requestedWidth, int requestedHeight);
 
-  private static class CenterInside extends DownsampleStrategy {
+  private static class FitCenter extends DownsampleStrategy {
+
+    @Synthetic
+    FitCenter() { }
 
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
@@ -95,7 +120,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class CenterOutside extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    CenterOutside() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
@@ -112,6 +141,9 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
 
   private static class AtLeast extends DownsampleStrategy {
 
+    @Synthetic
+    AtLeast() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -127,6 +159,10 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class AtMost extends DownsampleStrategy {
+
+    @Synthetic
+    AtMost() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -146,7 +182,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class None extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    None() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       return 1f;
@@ -159,6 +199,26 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
     }
   }
 
+  private static class CenterInside extends DownsampleStrategy {
+
+    @Synthetic
+    CenterInside() { }
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+
+      return Math.min(1.f,
+          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
   /**
    * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
    * or higher quality.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 3d66bf708..e16adcc79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -4,26 +4,29 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 
@@ -48,6 +51,30 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  /**
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the
+   * resource from the caller.  The final resource dimensions may differ from the requested
+   * width and height, and thus setting this to true may result in the bitmap size differing
+   * from the resource dimensions.
+   *
+   * This can be used as a performance optimization for KitKat and above by fixing the size of the
+   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * allocate new bitmaps for images of different sizes.
+   */
+  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
+
+  private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
+  private static final String ICO_MIME_TYPE = "image/x-ico";
+  private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  WBMP_MIME_TYPE,
+                  ICO_MIME_TYPE
+              )
+          )
+      );
   private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
     public void onObtainBounds() {
@@ -74,10 +101,12 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
+  private final List<ImageHeaderParser> parsers;
 
-  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-      ByteArrayPool byteArrayPool) {
+  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
@@ -135,45 +164,83 @@ public boolean handles(ByteBuffer byteBuffer) {
     Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
         + " mark()");
 
-    byte[] bytesForOptions = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
     bitmapFactoryOptions.inTempStorage = bytesForOptions;
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
+          fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
-      byteArrayPool.put(bytesForOptions);
+      byteArrayPool.put(bytesForOptions, byte[].class);
     }
   }
 
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
       DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      DecodeCallbacks callbacks) throws IOException {
+      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
 
     int[] sourceDimensions = getDimensions(is, options, callbacks);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
-    int orientation = getOrientation(is);
-    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(getOrientation(is));
+    int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
 
     options.inPreferredConfig = getConfig(is, decodeFormat);
     if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
       options.inDither = true;
     }
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
-        requestedHeight, options);
 
-    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
-        sourceHeight, callbacks);
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+
+    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
+        targetHeight, options);
+
+    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || isKitKatOrGreater)
+        && shouldUsePool(is)) {
+      int expectedWidth;
+      int expectedHeight;
+      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+        expectedWidth = targetWidth;
+        expectedHeight = targetHeight;
+      } else {
+        float densityMultiplier = isScaling(options)
+            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        int sampleSize = options.inSampleSize;
+        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+        expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+              + " [" + sourceWidth + "x" + sourceHeight + "]"
+              + ", sampleSize: " + sampleSize
+              + ", targetDensity: " + options.inTargetDensity
+              + ", density: " + options.inDensity
+              + ", density multiplier: " + densityMultiplier);
+        }
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
+      }
+    }
+    Bitmap downsampled = decodeStream(is, options, callbacks);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -187,9 +254,9 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
       // the expected density dpi.
       downsampled.setDensity(displayMetrics.densityDpi);
 
-      rotated = TransformationUtils.rotateImageExif(downsampled, bitmapPool, orientation);
-      if (!downsampled.equals(rotated) && !bitmapPool.put(downsampled)) {
-        downsampled.recycle();
+      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);
+      if (!downsampled.equals(rotated)) {
+        bitmapPool.put(downsampled);
       }
     }
 
@@ -198,16 +265,13 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
   // Visible for testing.
   static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
+      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
       BitmapFactory.Options options) {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
     }
 
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-
     final float exactScaleFactor;
     if (degreesToRotate == 90 || degreesToRotate == 270) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
@@ -241,16 +305,28 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
         ? Math.max(widthScaleFactor, heightScaleFactor)
         : Math.min(widthScaleFactor, heightScaleFactor);
 
-    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
-    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
-      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+    int powerOfTwoSampleSize;
+    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
+    if (Build.VERSION.SDK_INT <= 23
+        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
+      powerOfTwoSampleSize = 1;
+    } else {
+      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+      if (rounding == SampleSizeRounding.MEMORY
+          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+      }
     }
 
     float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
 
     options.inSampleSize = powerOfTwoSampleSize;
-    options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
-    options.inDensity = 1000;
+    // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
+    // densities here so we calculate the final Bitmap size correctly.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
+      options.inDensity = 1000;
+    }
     if (isScaling(options)) {
       options.inScaled = true;
     } else {
@@ -269,51 +345,6 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private int getOrientation(InputStream is) throws IOException {
-    is.mark(MARK_POSITION);
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
-    try {
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Cannot determine the image orientation from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return orientation;
-  }
-
-  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
-      throws IOException {
-    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
-        && shouldUsePool(is)) {
-
-      float densityMultiplier = isScaling(options)
-          ? (float) options.inTargetDensity / options.inDensity : 1f;
-
-      int sampleSize = options.inSampleSize;
-      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
-      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
-      int expectedWidth = (int) Math.ceil(downsampledWidth * densityMultiplier);
-      int expectedHeight = (int) Math.ceil(downsampledHeight * densityMultiplier);
-
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-            + " [" + sourceWidth + "x" + sourceHeight + "]"
-            + ", sampleSize: " + sampleSize
-            + ", targetDensity: " + options.inTargetDensity
-            + ", density: " + options.inDensity
-            + ", density multiplier: " + densityMultiplier);
-      }
-      // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-      setInBitmap(options, pool.getDirty(expectedWidth, expectedHeight, options.inPreferredConfig));
-    }
-    return decodeStream(is, options, callbacks);
-  }
-
   private boolean shouldUsePool(InputStream is) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
@@ -321,18 +352,15 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       return true;
     }
 
-    is.mark(MARK_POSITION);
     try {
-      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
+      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
       // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
       // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
       return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Cannot determine the image type from header", e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Cannot determine the image type from header", e);
       }
-    } finally {
-      is.reset();
     }
     return false;
   }
@@ -345,16 +373,13 @@ private boolean shouldUsePool(InputStream is) throws IOException {
     }
 
     boolean hasAlpha = false;
-    is.mark(MARK_POSITION);
     try {
-      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.DEBUG)) {
-        Logs.log(Log.DEBUG, "Cannot determine whether the image has alpha or not from header for"
-            + " format " + format, e);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
+            + ", format " + format, e);
       }
-    } finally {
-      is.reset();
     }
 
     return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
@@ -394,17 +419,19 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
     int sourceHeight = options.outHeight;
     String outMimeType = options.outMimeType;
     final Bitmap result;
+    TransformationUtils.getBitmapDrawableLock().lock();
     try {
       result = BitmapFactory.decodeStream(is, null, options);
     } catch (IllegalArgumentException e) {
       throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+    } finally {
+      TransformationUtils.getBitmapDrawableLock().unlock();
     }
 
     if (options.inJustDecodeBounds) {
       is.reset();
 
     }
-
     return result;
   }
 
@@ -425,31 +452,27 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", thread: " + Thread.currentThread().getName());
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static String getInBitmapString(BitmapFactory.Options options) {
-    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
-        ? getBitmapString(options.inBitmap) : null;
+    return getBitmapString(options.inBitmap);
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static String getBitmapString(Bitmap bitmap) {
-    final String result;
     if (bitmap == null) {
-      result = null;
-    } else {
-      String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-          ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-      result = "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
-          + sizeString;
+      return null;
     }
-    return result;
+
+    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
+    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+        + sizeString;
   }
 
   // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
       int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
     return new IOException("Exception decoding bitmap"
@@ -459,14 +482,12 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      options.inBitmap = recycled;
-    }
+  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
+      int height) {
+    // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
+    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static synchronized BitmapFactory.Options getDefaultOptions() {
     BitmapFactory.Options decodeBitmapOptions;
     synchronized (OPTIONS_QUEUE) {
@@ -487,7 +508,6 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
@@ -500,11 +520,8 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.outWidth = 0;
     decodeBitmapOptions.outHeight = 0;
     decodeBitmapOptions.outMimeType = null;
-
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      decodeBitmapOptions.inBitmap = null;
-      decodeBitmapOptions.inMutable = true;
-    }
+    decodeBitmapOptions.inBitmap = null;
+    decodeBitmapOptions.inMutable = true;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 173a10586..c29ef691d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -2,9 +2,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -16,17 +15,30 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter(Context context) {
-    super(context);
+  public FitCenter() {
+    // Intentionally empty.
+  }
+
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public FitCenter(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
-    return TransformationUtils.fitCenter(toTransform, pool, outWidth, outHeight);
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 83b9abb90..412c5cc5b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,8 +4,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -15,7 +15,8 @@
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+    Initializable {
 
   private final Bitmap bitmap;
   private final Resources resources;
@@ -53,8 +54,11 @@ public int getSize() {
 
   @Override
   public void recycle() {
-    if (!bitmapPool.put(bitmap)) {
-      bitmap.recycle();
-    }
+    bitmapPool.put(bitmap);
+  }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 33a25b6f7..24f2f35ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,8 +17,7 @@
  *  limitations under the License.
  */
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -62,18 +61,18 @@
    * The current position within the byte array {@code buf}.
    */
   private int pos;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool) {
-    this(in, byteArrayPool, ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  public RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool) {
+    this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
   // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool,
+  RecyclableBufferedInputStream(InputStream in, ArrayPool byteArrayPool,
       int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
-    buf = byteArrayPool.get(bufferSize);
+    buf = byteArrayPool.get(bufferSize, byte[].class);
   }
 
   /**
@@ -111,7 +110,7 @@ public synchronized void fixMarkLimit() {
 
   public synchronized void release() {
     if (buf != null) {
-      byteArrayPool.put(buf);
+      byteArrayPool.put(buf, byte[].class);
       buf = null;
     }
   }
@@ -125,7 +124,7 @@ public synchronized void release() {
   @Override
   public void close() throws IOException {
     if (buf != null) {
-      byteArrayPool.put(buf);
+      byteArrayPool.put(buf, byte[].class);
       buf = null;
     }
     InputStream localIn = in;
@@ -161,13 +160,13 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       if (newLength > marklimit) {
         newLength = marklimit;
       }
-      byte[] newbuf = byteArrayPool.get(newLength);
+      byte[] newbuf = byteArrayPool.get(newLength, byte[].class);
       System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
       byte[] oldbuf = localBuf;
       // Reassign buf, which will invalidate any local references
       // FIXME: what if buf was null?
       localBuf = buf = newbuf;
-      byteArrayPool.put(oldbuf);
+      byteArrayPool.put(oldbuf, byte[].class);
     } else if (markpos > 0) {
       System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length - markpos);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
new file mode 100644
index 000000000..be3e804a2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -0,0 +1,75 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rounds the corners of a bitmap.
+ */
+public final class RoundedCorners extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int roundingRadius;
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(int roundingRadius) {
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
+   */
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
+    this(roundingRadius);
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
+   */
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
+    this(roundingRadius);
+  }
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
+        roundingRadius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode() + roundingRadius;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
+    messageDigest.update(radiusData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 6fa3e3809..78ec0ff8b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,15 +1,13 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.util.ExceptionCatchingInputStream;
 import com.bumptech.glide.util.MarkEnforcingInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -19,9 +17,9 @@
 public class StreamBitmapDecoder implements ResourceDecoder<InputStream, Bitmap> {
 
   private final Downsampler downsampler;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamBitmapDecoder(Downsampler downsampler, ByteArrayPool byteArrayPool) {
+  public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
     this.downsampler = downsampler;
     this.byteArrayPool = byteArrayPool;
   }
@@ -98,8 +96,8 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
       // ExceptionCatchingInputStream and throw them here.
       IOException streamException = exceptionStream.getException();
       if (streamException != null) {
-        if (downsampled != null && !bitmapPool.put(downsampled)) {
-          downsampled.recycle();
+        if (downsampled != null) {
+          bitmapPool.put(downsampled);
         }
         throw streamException;
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 8cbd2ebb3..e7abbb8ab 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,19 +1,28 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * A class with methods to efficiently resize Bitmaps.
@@ -25,6 +34,23 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+
+  // See #738.
+  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
+      Arrays.asList(
+          "XT1097",
+          "XT1085");
+  /**
+   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
+   * drawing is not thread safe.
+   * This lock only locks for these specific devices. For other types of devices the lock is always
+   * available and therefore does not impact performance
+   */
+  private static final Lock BITMAP_DRAWABLE_LOCK =
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
+          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
+          ? new ReentrantLock() : new NoLock();
+
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
     CIRCLE_CROP_BITMAP_PAINT.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
@@ -34,50 +60,47 @@ private TransformationUtils() {
     // Utility class.
   }
 
+
+  public static Lock getBitmapDrawableLock() {
+    return BITMAP_DRAWABLE_LOCK;
+  }
+
   /**
    * A potentially expensive operation to crop the given Bitmap so that it fills the given
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
-   * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped
-   *                 portion of toCrop into.
-   * @param toCrop   The Bitmap to resize.
+   * @param pool     The BitmapPool to obtain a bitmap from.
+   * @param inBitmap   The Bitmap to resize.
    * @param width    The width in pixels of the final Bitmap.
    * @param height   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
-    if (toCrop == null) {
-      return null;
-    } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
-      return toCrop;
+  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+      int height) {
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
+      return inBitmap;
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
     float dx = 0, dy = 0;
     Matrix m = new Matrix();
-    if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
-      scale = (float) height / (float) toCrop.getHeight();
-      dx = (width - toCrop.getWidth() * scale) * 0.5f;
+    if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
+      scale = (float) height / (float) inBitmap.getHeight();
+      dx = (width - inBitmap.getWidth() * scale) * 0.5f;
     } else {
-      scale = (float) width / (float) toCrop.getWidth();
-      dy = (height - toCrop.getHeight() * scale) * 0.5f;
+      scale = (float) width / (float) inBitmap.getWidth();
+      dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-    final Bitmap result;
-    if (recycled != null) {
-      result = recycled;
-    } else {
-      result = Bitmap.createBitmap(width, height, getSafeConfig(toCrop));
-    }
 
+    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toCrop, result);
+    TransformationUtils.setAlpha(inBitmap, result);
 
-    Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toCrop, m, DEFAULT_PAINT);
+    applyMatrix(inBitmap, result, m);
     return result;
   }
 
@@ -85,103 +108,95 @@ public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int h
    * An expensive operation to resize the given Bitmap down so that it fits within the given
    * dimensions maintain the original proportions.
    *
-   * @param toFit  The Bitmap to shrink.
-   * @param pool   The BitmapPool to try to reuse a bitmap from.
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap  The Bitmap to shrink.
    * @param width  The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
    * height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
-    if (toFit.getWidth() == width && toFit.getHeight() == height) {
+  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+      int height) {
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
-    final float widthPercentage = width / (float) toFit.getWidth();
-    final float heightPercentage = height / (float) toFit.getHeight();
+    final float widthPercentage = width / (float) inBitmap.getWidth();
+    final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
     // take the floor of the target width/height, not round. If the matrix
     // passed into drawBitmap rounds differently, we want to slightly
     // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * toFit.getWidth());
-    final int targetHeight = (int) (minPercentage * toFit.getHeight());
+    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
 
-    if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
+    if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "adjusted target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
 
-    Bitmap.Config config = getSafeConfig(toFit);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
-    if (toReuse == null) {
-      toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
-    }
+
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toFit, toReuse);
+    TransformationUtils.setAlpha(inBitmap, toReuse);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       Log.v(TAG, "request: " + width + "x" + height);
-      Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
+      Log.v(TAG, "toFit:   " + inBitmap.getWidth() + "x" + inBitmap.getHeight());
       Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
       Log.v(TAG, "minPct:   " + minPercentage);
     }
 
-    Canvas canvas = new Canvas(toReuse);
     Matrix matrix = new Matrix();
     matrix.setScale(minPercentage, minPercentage);
-    canvas.drawBitmap(toFit, matrix, DEFAULT_PAINT);
+    applyMatrix(inBitmap, toReuse, matrix);
 
     return toReuse;
   }
 
   /**
-   * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
-   * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
-   * the transformation for transformations that don't add or remove transparent pixels.
+   * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
+   * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
    *
-   * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
-   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
-   *                    transformation.
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap  The Bitmap to center.
+   * @param width  The width in pixels of the target.
+   * @param height The height in pixels of the target.
+   * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
+   * height is larger than the given dimensions
    */
-  public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, toTransform.hasAlpha());
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void setAlphaIfAvailable(Bitmap bitmap, boolean hasAlpha) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && bitmap != null) {
-      bitmap.setHasAlpha(hasAlpha);
+  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+                                 int height) {
+    if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size larger or equal to input, returning input");
+      }
+      return inBitmap;
+    } else {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size too big for input, fit centering instead");
+      }
+      return fitCenter(pool, inBitmap, width, height);
     }
   }
 
   /**
-   * Returns a matrix with rotation put based on Exif orientation tag. If the orientation is
-   * undefined or 0 null is returned.
+   * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
+   * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
+   * the transformation for transformations that don't add or remove transparent pixels.
    *
-   * @param pathToOriginal Path to original image file that may have exif data.
-   * @return A rotation in degrees based on exif orientation
-   * @deprecated No longer used by Glide, scheduled to be removed in Glide 4.0
+   * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
+   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
+   *                    transformation.
    */
-  @TargetApi(Build.VERSION_CODES.ECLAIR)
-  @Deprecated
-  public static int getOrientation(String pathToOriginal) {
-    int degreesToRotate = 0;
-    try {
-      ExifInterface exif = new ExifInterface(pathToOriginal);
-      int orientation =
-          exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
-      return getExifOrientationDegrees(orientation);
-    } catch (Exception e) {
-      if (Log.isLoggable(TAG, Log.ERROR)) {
-        Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
-      }
-    }
-    return degreesToRotate;
+  public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
+    outBitmap.setHasAlpha(inBitmap.hasAlpha());
   }
 
   /**
@@ -193,15 +208,14 @@ public static int getOrientation(String pathToOriginal) {
    *                        returned unmodified.
    * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
    */
-  public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
+  public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRotate) {
     Bitmap result = imageToOrient;
     try {
       if (degreesToRotate != 0) {
         Matrix matrix = new Matrix();
         matrix.setRotate(degreesToRotate);
-        result = Bitmap
-            .createBitmap(imageToOrient, 0, 0, imageToOrient.getWidth(), imageToOrient.getHeight(),
-                matrix, true);
+        result = Bitmap.createBitmap(imageToOrient, 0, 0, imageToOrient.getWidth(),
+            imageToOrient.getHeight(), matrix, true /*filter*/);
       }
     } catch (Exception e) {
       if (Log.isLoggable(TAG, Log.ERROR)) {
@@ -234,6 +248,7 @@ public static int getExifOrientationDegrees(int exifOrientation) {
         break;
       default:
         degreesToRotate = 0;
+        break;
     }
     return degreesToRotate;
   }
@@ -241,37 +256,33 @@ public static int getExifOrientationDegrees(int exifOrientation) {
   /**
    * Rotate and/or flip the image to match the given exif orientation.
    *
-   * @param toOrient        The bitmap to rotate/flip.
    * @param pool            A pool that may or may not contain an image of the necessary
    *                        dimensions.
+   * @param inBitmap        The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
+  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int exifOrientation) {
     final Matrix matrix = new Matrix();
     initializeMatrixForRotation(exifOrientation, matrix);
     if (matrix.isIdentity()) {
-      return toOrient;
+      return inBitmap;
     }
 
     // From Bitmap.createBitmap.
-    final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
 
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(toOrient);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
-    if (result == null) {
-      result = Bitmap.createBitmap(newWidth, newHeight, config);
-    }
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
-    final Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toOrient, matrix, DEFAULT_PAINT);
-
+    applyMatrix(inBitmap, result, matrix);
     return result;
   }
 
@@ -279,49 +290,137 @@ public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifO
    * Crop the image to a circle and resize to the specified width/height.  The circle crop will
    * have the same width and height equal to the min-edge of the result image.
    *
-   * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped
-   *                 portion of toCrop into.
-   * @param toCrop   The Bitmap to resize.
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap   The Bitmap to resize.
    * @param destWidth    The width in pixels of the final Bitmap.
    * @param destHeight   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(Bitmap recycled, Bitmap toCrop, int destWidth, int destHeight) {
-    if (toCrop == null) {
-      return null;
+  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int destWidth, int destHeight) {
+    int destMinEdge = Math.min(destWidth, destHeight);
+    float radius = destMinEdge / 2f;
+
+    int srcWidth = inBitmap.getWidth();
+    int srcHeight = inBitmap.getHeight();
+
+    float scaleX = destMinEdge / (float) srcWidth;
+    float scaleY = destMinEdge / (float) srcHeight;
+    float maxScale = Math.max(scaleX, scaleY);
+
+    float scaledWidth = maxScale * srcWidth;
+    float scaledHeight = maxScale * srcHeight;
+    float left = (destMinEdge - scaledWidth) / 2f;
+    float top = (destMinEdge - scaledHeight) / 2f;
+
+    RectF destRect = new RectF(left, top, left + scaledWidth, top + scaledHeight);
+
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+
+    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
+    result.setHasAlpha(true);
+
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      // Draw a circle
+      canvas.drawCircle(radius, radius, radius, CIRCLE_CROP_SHAPE_PAINT);
+      // Draw the bitmap in the circle
+      canvas.drawBitmap(toTransform, null, destRect, CIRCLE_CROP_BITMAP_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
     }
 
-    Bitmap result = (recycled != null) ? recycled
-        : Bitmap.createBitmap(destWidth, destHeight, getSafeConfig(toCrop));
-    setAlphaIfAvailable(result, true /*hasAlpha*/);
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
 
-    int destMinEdge = Math.min(destWidth, destHeight);
-    float radius = destMinEdge / 2f;
-    Rect destRect = new Rect((destWidth - destMinEdge) / 2, (destHeight - destMinEdge) / 2,
-        destMinEdge, destMinEdge);
+    return result;
+  }
 
-    int srcWidth = toCrop.getWidth();
-    int srcHeight = toCrop.getHeight();
-    int srcMinEdge = Math.min(srcWidth, srcHeight);
-    Rect srcRect = new Rect((srcWidth - srcMinEdge) / 2, (srcHeight - srcMinEdge) / 2,
-        srcMinEdge, srcMinEdge);
+  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
+      @NonNull Bitmap maybeAlphaSafe) {
+    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+      return maybeAlphaSafe;
+    }
+
+    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
+        Bitmap.Config.ARGB_8888);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*pain*/);
 
-    Canvas canvas = new Canvas(result);
+    // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
+    // when we're finished with it.
+    return argbBitmap;
+  }
 
-    // Draw a circle
-    canvas.drawCircle(destRect.left + radius, destRect.top + radius, radius,
-        CIRCLE_CROP_SHAPE_PAINT);
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param width the width of the generated bitmap.
+   * @param height the height of the generated bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   */
+  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int width, int height, int roundingRadius) {
+    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
+    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+
+    result.setHasAlpha(true);
+
+    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
+        Shader.TileMode.CLAMP);
+    Paint paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setShader(shader);
+    RectF rect = new RectF(0, 0, result.getWidth(), result.getHeight());
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      canvas.drawRoundRect(rect, roundingRadius, roundingRadius, paint);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
 
-    // Draw the bitmap in the circle
-    canvas.drawBitmap(toCrop, srcRect, destRect, CIRCLE_CROP_BITMAP_PAINT);
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
 
     return result;
   }
 
+  // Avoids warnings in M+.
+  private static void clear(Canvas canvas) {
+    canvas.setBitmap(null);
+  }
+
   private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
+  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
+      Matrix matrix) {
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(targetBitmap);
+      canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+  }
+
   // Visible for testing.
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
@@ -353,4 +452,41 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
         // Do nothing.
     }
   }
+
+  private static final class NoLock implements Lock {
+
+    @Synthetic
+    NoLock() { }
+
+    @Override
+    public void lock() {
+      // do nothing
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+      // do nothing
+    }
+
+    @Override
+    public boolean tryLock() {
+      return true;
+    }
+
+    @Override
+    public boolean tryLock(long time, @NonNull TimeUnit unit) throws InterruptedException {
+      return true;
+    }
+
+    @Override
+    public void unlock() {
+      // do nothing
+    }
+
+    @NonNull
+    @Override
+    public Condition newCondition() {
+      throw new UnsupportedOperationException("Should not be called");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index a206c2d1c..98d9a0e59 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -4,14 +4,12 @@
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -31,9 +29,14 @@
   public static final long DEFAULT_FRAME = -1;
 
   /**
-   * A long indicating the target frame we should provide to
-   * {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} when extracting a video
-   * frame.
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
    */
   public static final Option<Long> TARGET_FRAME = Option.disk(
       "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
@@ -49,6 +52,33 @@ public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
         }
       });
 
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      null /*defaultValue*/,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+        @Override
+        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
   private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
       new MediaMetadataRetrieverFactory();
 
@@ -86,21 +116,27 @@ public boolean handles(ParcelFileDescriptor data, Options options) {
   @Override
   public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
       Options options) throws IOException {
-    long frame = options.get(TARGET_FRAME);
-    if (frame < 0 && frame != DEFAULT_FRAME) {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
       throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frame);
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
     }
+    Integer frameOption = options.get(FRAME_OPTION);
 
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
     final Bitmap result;
-    if (frame == DEFAULT_FRAME) {
-      result = mediaMetadataRetriever.getFrameAtTime();
-    } else {
-      result = mediaMetadataRetriever.getFrameAtTime(frame);
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
+      if (frameTimeMicros == DEFAULT_FRAME) {
+        result = mediaMetadataRetriever.getFrameAtTime();
+      } else if (frameOption == null) {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
+      } else {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+      }
+    } finally {
+      mediaMetadataRetriever.release();
     }
-    mediaMetadataRetriever.release();
     resource.close();
     return BitmapResource.obtain(result, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 815c14b8f..41315a302 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.bytes;
 
 import com.bumptech.glide.load.data.DataRewinder;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 4cea85519..163cbe50a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -1,21 +1,24 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a {@link
- * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
- * android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a
+ * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
+ * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
  *
  * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
  * class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
+    Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
@@ -25,11 +28,19 @@ public DrawableResource(T drawable) {
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
-    // Drawables contain temporary state related to how they're being displayed (alpha, color
-    // filter etc), so
-    // return a new copy each time. If we ever return the original drawable, it's temporary state
-    // may be changed
+    // Drawables contain temporary state related to how they're being displayed
+    // (alpha, color filter etc), so return a new copy each time.
+    // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
     return (T) drawable.getConstantState().newDrawable();
   }
+
+  @Override
+  public void initialize() {
+    if (drawable instanceof BitmapDrawable) {
+      ((BitmapDrawable) drawable).getBitmap().prepareToDraw();
+    } else if (drawable instanceof GifDrawable) {
+      ((GifDrawable) drawable).getFirstFrame().prepareToDraw();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 487421b71..ebf582b81 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,38 +1,123 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
  * Contains {@link Drawable} specific animation options.
  */
-public final class DrawableTransitionOptions extends TransitionOptions<DrawableTransitionOptions,
-    Drawable> {
+public final class DrawableTransitionOptions extends
+    TransitionOptions<DrawableTransitionOptions, Drawable> {
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
   public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
     return new DrawableTransitionOptions().crossFade(animationId, duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new DrawableTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static DrawableTransitionOptions with(
+      TransitionFactory<Drawable> transitionFactory) {
+    return new DrawableTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
   public DrawableTransitionOptions crossFade() {
-    return transition(new DrawableCrossFadeFactory());
+    return crossFade(new DrawableCrossFadeFactory.Builder());
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
   public DrawableTransitionOptions crossFade(int duration) {
-    return transition(new DrawableCrossFadeFactory(duration));
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
   public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return transition(new DrawableCrossFadeFactory(animationId, duration));
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transition(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return crossFade(builder.build());
   }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index 01c54c297..e932f3caf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -3,7 +3,6 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index 4cc540b0c..beeec792e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.file;
 
 import com.bumptech.glide.load.resource.SimpleResource;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index a6c11ca75..2b56d271e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -3,26 +3,26 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.Logs;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -44,35 +44,43 @@
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
+  private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
-  private final ByteArrayPool byteArrayPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getByteArrayPool());
+    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
-  public ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool) {
-    this(context, bitmapPool, byteArrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+  public ByteBufferGifDecoder(
+      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      ArrayPool arrayPool) {
+    this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
-  ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      GifHeaderParserPool parserPool, GifDecoderFactory gifDecoderFactory) {
-    this.context = context;
+  ByteBufferGifDecoder(
+      Context context,
+      List<ImageHeaderParser> parsers,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      GifHeaderParserPool parserPool,
+      GifDecoderFactory gifDecoderFactory) {
+    this.context = context.getApplicationContext();
+    this.parsers = parsers;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
     this.gifDecoderFactory = gifDecoderFactory;
-    this.provider = new GifBitmapProvider(bitmapPool);
+    this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
@@ -109,8 +117,8 @@ private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
         new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
             firstFrame);
 
-    if (Logs.isEnabled(Log.VERBOSE)) {
-      Logs.log(Log.VERBOSE, "Decoded gif from stream in " + LogTime.getElapsedMillis(startTime));
+    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
     }
 
     return new GifDrawableResource(gifDrawable);
@@ -124,7 +132,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Downsampling gif"
+      Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
           + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
@@ -136,7 +144,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
   static class GifDecoderFactory {
     public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
-      return new GifDecoder(provider, header, data, sampleSize);
+      return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 504e0dfe0..a9d231006 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -2,8 +2,10 @@
 
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 /**
@@ -12,11 +14,26 @@
  */
 public final class GifBitmapProvider implements GifDecoder.BitmapProvider {
   private final BitmapPool bitmapPool;
+  @Nullable private final ArrayPool arrayPool;
 
+  /**
+   * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed
+   * when requested.
+   */
   public GifBitmapProvider(BitmapPool bitmapPool) {
+    this(bitmapPool, null /* arrayPool */);
+  }
+
+  /**
+   * Constructs an instance with a shared array pool. Arrays will be reused where
+   * possible.
+   */
+  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
+    this.arrayPool = arrayPool;
   }
 
+  @NonNull
   @Override
   public Bitmap obtain(int width, int height, Bitmap.Config config) {
     return bitmapPool.getDirty(width, height, config);
@@ -24,8 +41,40 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
 
   @Override
   public void release(Bitmap bitmap) {
-    if (!bitmapPool.put(bitmap)) {
-      bitmap.recycle();
+    bitmapPool.put(bitmap);
+  }
+
+  @Override
+  public byte[] obtainByteArray(int size) {
+    if (arrayPool == null) {
+      return new byte[size];
+    }
+    return arrayPool.get(size, byte[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  @Override
+  public void release(byte[] bytes) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(bytes, byte[].class);
+  }
+
+  @Override
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
+    }
+    return arrayPool.get(size, int[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  @Override
+  public void release(int[] array) {
+    if (arrayPool == null) {
+      return;
     }
+    arrayPool.put(array, int[].class);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 0dfb13a94..5e6f98eed 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
-import android.annotation.TargetApi;
+import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -11,14 +12,13 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.nio.ByteBuffer;
 
 /**
@@ -58,11 +58,11 @@
    */
   private boolean isVisible = true;
   /**
-   * The number of times we've looped over all the frames in the gif.
+   * The number of times we've looped over all the frames in the GIF.
    */
   private int loopCount;
   /**
-   * The number of times to loop through the gif animation.
+   * The number of times to loop through the GIF animation.
    */
   private int maxLoopCount = LOOP_FOREVER;
 
@@ -87,25 +87,33 @@
    *                            height of the view or
    *                            {@link com.bumptech.glide.request.target.Target}
    *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode gif data.
-   * @param firstFrame          The decoded and transformed first frame of this gif.
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
   public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
       Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
       Bitmap firstFrame) {
-    this(new GifState(context, bitmapPool,
-        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
-            frameTransformation, firstFrame)));
+    this(
+        new GifState(
+            bitmapPool,
+            new GifFrameLoader(
+                // TODO(b/27524013): Factor out this call to Glide.get()
+                Glide.get(context),
+                gifDecoder,
+                targetFrameWidth,
+                targetFrameHeight,
+                frameTransformation,
+                firstFrame)));
   }
 
   GifDrawable(GifState state) {
     this.state = Preconditions.checkNotNull(state);
   }
 
-  // Visible for testing.
-  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(context, bitmapPool, frameLoader));
+  @VisibleForTesting
+  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
+    this(new GifState(bitmapPool, frameLoader));
     this.paint = paint;
   }
 
@@ -134,10 +142,27 @@ public int getFrameCount() {
     return state.frameLoader.getFrameCount();
   }
 
+  /**
+   * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
+   * is displayed.
+   */
+  public int getFrameIndex() {
+    return state.frameLoader.getCurrentIndex();
+  }
+
   private void resetLoopCount() {
     loopCount = 0;
   }
 
+  /**
+   * Starts the animation from the first frame. Can only be called while animation is not running.
+   */
+  public void startFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
+    state.frameLoader.setNextStartFromFirstFrame();
+    start();
+  }
+
   @Override
   public void start() {
     isStarted = true;
@@ -154,6 +179,8 @@ public void stop() {
   }
 
   private void startRunning() {
+    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
+        + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -171,6 +198,9 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
+    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
+        + " Ensure that you unset the Drawable from your View before changing the View's"
+        + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -252,10 +282,9 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
-  public void onFrameReady(int frameIndex) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
+  public void onFrameReady() {
+    if (getCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -263,7 +292,7 @@ public void onFrameReady(int frameIndex) {
 
     invalidateSelf();
 
-    if (frameIndex == state.frameLoader.getFrameCount() - 1) {
+    if (getFrameIndex() == getFrameCount() - 1) {
       loopCount++;
     }
 
@@ -297,7 +326,9 @@ public void setLoopCount(int loopCount) {
     }
 
     if (loopCount == LOOP_INTRINSIC) {
-      maxLoopCount = state.frameLoader.getLoopCount();
+      int intrinsicCount = state.frameLoader.getLoopCount();
+      maxLoopCount =
+          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;
     } else {
       maxLoopCount = loopCount;
     }
@@ -305,13 +336,11 @@ public void setLoopCount(int loopCount) {
 
   static class GifState extends ConstantState {
     static final int GRAVITY = Gravity.FILL;
-    final Context context;
     final BitmapPool bitmapPool;
     final GifFrameLoader frameLoader;
 
-    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
+    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
       this.bitmapPool = bitmapPool;
-      this.context = context.getApplicationContext();
       this.frameLoader = frameLoader;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index 44268ec8e..f2f842381 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 
@@ -32,7 +30,7 @@ public boolean encode(Resource<GifDrawable> data, File file, Options options) {
       success = true;
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to encode gif drawable data", e);
+        Log.w(TAG, "Failed to encode GIF drawable data", e);
       }
     }
     return success;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 6b8301462..d0275e023 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.resource.gif;
 
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
-public class GifDrawableResource extends DrawableResource<GifDrawable> {
+public class GifDrawableResource extends DrawableResource<GifDrawable>
+    implements Initializable {
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
@@ -25,4 +27,9 @@ public void recycle() {
     drawable.stop();
     drawable.recycle();
   }
+
+  @Override
+  public void initialize() {
+    drawable.getFirstFrame().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 1d78c736e..06b1a4fb4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,14 +2,12 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,30 +17,43 @@
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
-  private final BitmapPool bitmapPool;
 
-  public GifDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped, Glide.get(context).getBitmapPool());
+  public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(wrapped);
   }
 
   @Override
-  public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth,
-      int outHeight) {
+  public Resource<GifDrawable> transform(
+      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
     // displaying it to end up with the right dimensions. Since our transformations may arbitrarily
-    // modify the dimensions of our gif, here we create a stand in for a frame and pass it to the
+    // modify the dimensions of our GIF, here we create a stand in for a frame and pass it to the
     // transformation to see what the final transformed dimensions will be so that our drawable can
     // report the correct intrinsic width and height.
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap firstFrame = drawable.getFirstFrame();
     Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
-    Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
+    Resource<Bitmap> transformed = wrapped.transform(context, bitmapResource, outWidth, outHeight);
     if (!bitmapResource.equals(transformed)) {
       bitmapResource.recycle();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 1eb928d18..9ad656df5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -3,13 +3,11 @@
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -17,12 +15,13 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 import java.util.ArrayList;
@@ -32,12 +31,13 @@
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
   private final Handler handler;
-  private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  private final RequestManager requestManager;
+  @Synthetic final RequestManager requestManager;
+  private final BitmapPool bitmapPool;
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
+  private boolean startFromFirstFrame = false;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
@@ -46,26 +46,40 @@
   private Transformation<Bitmap> transformation;
 
   public interface FrameCallback {
-    void onFrameReady(int index);
+    void onFrameReady();
   }
 
-  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
-      Transformation<Bitmap> transformation, Bitmap firstFrame) {
-    this(context,
-        Glide.with(context),
+  public GifFrameLoader(
+      Glide glide,
+      GifDecoder gifDecoder,
+      int width,
+      int height,
+      Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this(
+        glide.getBitmapPool(),
+        Glide.with(glide.getContext()),
         gifDecoder,
         null /*handler*/,
-        getRequestBuilder(context, width, height), transformation, firstFrame);
+        getRequestBuilder(Glide.with(glide.getContext()), width, height),
+        transformation,
+        firstFrame);
   }
 
-  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
-      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  GifFrameLoader(
+      BitmapPool bitmapPool,
+      RequestManager requestManager,
+      GifDecoder gifDecoder,
+      Handler handler,
+      RequestBuilder<Bitmap> requestBuilder,
+      Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this.requestManager = requestManager;
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
-    this.context = context;
+    this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
 
@@ -77,7 +91,7 @@ public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int hei
   void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstFrame) {
     this.transformation = Preconditions.checkNotNull(transformation);
     this.firstFrame = Preconditions.checkNotNull(firstFrame);
-    requestBuilder = requestBuilder.apply(new RequestOptions().transform(context, transformation));
+    requestBuilder = requestBuilder.apply(new RequestOptions().transform(transformation));
   }
 
   Transformation<Bitmap> getFrameTransformation() {
@@ -121,6 +135,10 @@ int getSize() {
     return gifDecoder.getByteSize() + getFrameSize();
   }
 
+  int getCurrentIndex() {
+    return current != null ? current.index : -1;
+  }
+
   private int getFrameSize() {
     return Util.getBitmapByteSize(getCurrentFrame().getWidth(), getCurrentFrame().getHeight(),
         getCurrentFrame().getConfig());
@@ -135,7 +153,7 @@ int getFrameCount() {
   }
 
   int getLoopCount() {
-    return gifDecoder.getLoopCount();
+    return gifDecoder.getTotalIterationCount();
   }
 
   private void start() {
@@ -176,23 +194,33 @@ private void loadNextFrame() {
     if (!isRunning || isLoadPending) {
       return;
     }
+    if (startFromFirstFrame) {
+      gifDecoder.resetFrameIndex();
+      startFromFirstFrame = false;
+    }
     isLoadPending = true;
+    // Get the delay before incrementing the pointer because the delay indicates the amount of time
+    // we want to spend on the current frame.
+    int delay = gifDecoder.getNextDelay();
+    long targetTime = SystemClock.uptimeMillis() + delay;
 
     gifDecoder.advance();
-    long targetTime = SystemClock.uptimeMillis() + gifDecoder.getNextDelay();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
     requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
     if (firstFrame != null) {
-      if (!Glide.get(context).getBitmapPool().put(firstFrame)) {
-        firstFrame.recycle();
-      }
+      bitmapPool.put(firstFrame);
       firstFrame = null;
     }
   }
 
+  void setNextStartFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
+    startFromFirstFrame = true;
+  }
+
   // Visible for testing.
   void onFrameReady(DelayTarget delayTarget) {
     if (isCleared) {
@@ -208,7 +236,7 @@ void onFrameReady(DelayTarget delayTarget) {
       // concurrent modifications.
       for (int i = callbacks.size() - 1; i >= 0; i--) {
         FrameCallback cb = callbacks.get(i);
-        cb.onFrameReady(delayTarget.index);
+        cb.onFrameReady();
       }
       if (previous != null) {
         handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, previous).sendToTarget();
@@ -223,6 +251,9 @@ void onFrameReady(DelayTarget delayTarget) {
     public static final int MSG_DELAY = 1;
     public static final int MSG_CLEAR = 2;
 
+    @Synthetic
+    FrameLoaderCallback() { }
+
     @Override
     public boolean handleMessage(Message msg) {
       if (msg.what == MSG_DELAY) {
@@ -240,7 +271,7 @@ public boolean handleMessage(Message msg) {
   // Visible for testing.
   static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
-    private final int index;
+    @Synthetic final int index;
     private final long targetTime;
     private Bitmap resource;
 
@@ -262,9 +293,14 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
     }
   }
 
-  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
-    return Glide.with(context).asBitmap().apply(
-        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  private static RequestBuilder<Bitmap> getRequestBuilder(
+      RequestManager requestManager, int width, int height) {
+    return requestManager
+        .asBitmap()
+        .apply(
+            diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .skipMemoryCache(true)
+                .override(width, height));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index a644056aa..4e887ed11 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -26,8 +25,7 @@ public boolean handles(GifDecoder source, Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
-      Options options) {
+  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index 0bf790f3c..baf4abc43 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,20 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
-
-import com.bumptech.glide.Logs;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
@@ -22,6 +21,7 @@
  * the buffer to a wrapped decoder.
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
+  private static final String TAG = "StreamGifDecoder";
   /**
    * If set to {@code true}, disables this decoder
    * ({@link #handles(InputStream, Options)} will return {@code false}). Defaults to
@@ -30,11 +30,13 @@
   public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
       "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
+  private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ByteArrayPool byteArrayPool) {
+  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
+      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
@@ -42,7 +44,7 @@ public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecod
   @Override
   public boolean handles(InputStream source, Options options) throws IOException {
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
@@ -67,8 +69,8 @@ public boolean handles(InputStream source, Options options) throws IOException {
       }
       buffer.flush();
     } catch (IOException e) {
-      if (Logs.isEnabled(Log.WARN)) {
-        Logs.log(Log.WARN, "Error reading data from stream", e);
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Error reading data from stream", e);
       }
       return null;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index af4a0281b..5e8419a7c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
-
 import java.io.ByteArrayOutputStream;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index b3993cbb2..9fbbd4c05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,6 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 98e3f9790..94ff7864d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -4,7 +4,6 @@
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.nio.ByteBuffer;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e6c965436..ad1c55c6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -11,7 +11,7 @@
 public interface ResourceTranscoder<Z, R> {
 
   /**
-   * Transcodes the given resource to the new resource type and returns the wew resource.
+   * Transcodes the given resource to the new resource type and returns the new resource.
    *
    * @param toTranscode The resource to transcode.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index c0a0bdb42..b632c35ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -75,7 +76,7 @@
   private static final class Entry<Z, R> {
     private final Class<Z> fromClass;
     private final Class<R> toClass;
-    private final ResourceTranscoder<Z, R> transcoder;
+    @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
     Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index 177165f4e..fd88428e8 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.util.Util;
-
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index 3b130fd70..b226cd425 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -1,23 +1,16 @@
 package com.bumptech.glide.manager;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 
 /**
- * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
- * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
- * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
- * the required permission.
+ * A factory class that produces a functional
+ * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
  */
-public class ConnectivityMonitorFactory {
-  public ConnectivityMonitor build(Context context,
-      ConnectivityMonitor.ConnectivityListener listener) {
-    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-    if (hasPermission) {
-      return new DefaultConnectivityMonitor(context, listener);
-    } else {
-      return new NullConnectivityMonitor();
-    }
-  }
+public interface ConnectivityMonitorFactory {
+
+  @NonNull
+  ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index 945df9f96..d2967bffa 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -6,12 +6,16 @@
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import com.bumptech.glide.util.Synthetic;
 
+/**
+ * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
+ */
 class DefaultConnectivityMonitor implements ConnectivityMonitor {
   private final Context context;
-  private final ConnectivityListener listener;
+  @Synthetic final ConnectivityListener listener;
 
-  private boolean isConnected;
+  @Synthetic boolean isConnected;
   private boolean isRegistered;
 
   private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
@@ -50,7 +54,8 @@ private void unregister() {
     isRegistered = false;
   }
 
-  private boolean isConnected(Context context) {
+  @Synthetic
+  boolean isConnected(Context context) {
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
     NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
new file mode 100644
index 000000000..ab3713962
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.manager;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+
+/**
+ * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
+ * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
+ * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
+ * the required permission.
+ */
+public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+
+  @NonNull
+  public ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
+    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
+    if (hasPermission) {
+      return new DefaultConnectivityMonitor(context, listener);
+    } else {
+      return new NullConnectivityMonitor();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 41505a86e..5d811cc49 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.RequestManager;
-
 import java.util.Collections;
 import java.util.Set;
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 5a84cd246..53044cee1 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -11,7 +11,7 @@
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
-   * returning {@code true} if the listener was removed sucessfully, and {@code false} otherwise.
+   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise.
    *
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index b7569082f..af6d7f599 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -5,9 +5,11 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
-
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -21,17 +23,17 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragment extends Fragment {
+  private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
   private final HashSet<RequestManagerFragment> childRequestManagerFragments =
       new HashSet<>();
 
-  private RequestManager requestManager;
-  private RequestManagerFragment rootRequestManagerFragment;
-  private Fragment parentFragmentHint;
+  @Nullable private RequestManager requestManager;
+  @Nullable private RequestManagerFragment rootRequestManagerFragment;
+  @Nullable private Fragment parentFragmentHint;
 
   public RequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
@@ -59,6 +61,7 @@ ActivityFragmentLifecycle getLifecycle() {
   /**
    * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
    */
+  @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
@@ -142,7 +145,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getRequestManagerFragment(activity.getFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
@@ -159,7 +162,14 @@ private void unregisterFragmentWithRoot() {
   @Override
   public void onAttach(Activity activity) {
     super.onAttach(activity);
-    registerFragmentWithRoot(getActivity());
+    try {
+      registerFragmentWithRoot(activity);
+    } catch (IllegalStateException e) {
+      // OnAttach can be called after the activity is destroyed, see #497.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to register fragment with root", e);
+      }
+    }
   }
 
   @Override
@@ -189,6 +199,7 @@ public void onDestroy() {
 
   @Override
   public void onTrimMemory(int level) {
+    super.onTrimMemory(level);
     // If an activity is re-created, onTrimMemory may be called before a manager is ever put.
     // See #329.
     if (requestManager != null) {
@@ -198,6 +209,7 @@ public void onTrimMemory(int level) {
 
   @Override
   public void onLowMemory() {
+    super.onLowMemory();
     // If an activity is re-created, onLowMemory may be called before a manager is ever put.
     // See #329.
     if (requestManager != null) {
@@ -211,6 +223,10 @@ public String toString() {
   }
 
   private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    FragmentRequestManagerTreeNode() { }
+
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index e46936da8..b07a23677 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -6,17 +6,24 @@
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
-
+import android.view.View;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -29,14 +36,14 @@
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
-  /**
-   * The singleton instance of RequestManagerRetriever.
-   */
-  private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
-
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
   private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
 
+  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+  private static final String FRAGMENT_INDEX_KEY = "key";
+  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
+
   /**
    * The top application level RequestManager.
    */
@@ -60,16 +67,16 @@
    * Main thread handler to handle cleaning up pending fragment maps.
    */
   private final Handler handler;
+  private final RequestManagerFactory factory;
 
-  /**
-   * Retrieves and returns the RequestManagerRetriever singleton.
-   */
-  public static RequestManagerRetriever get() {
-    return INSTANCE;
-  }
+  // Objects used to find Fragments and Activities containing views.
+  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+  private final Bundle tempBundle = new Bundle();
 
   // Visible for testing.
-  RequestManagerRetriever() {
+  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+    this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
@@ -82,9 +89,11 @@ private RequestManager getApplicationManager(Context context) {
           // activity. However, in this case since the manager attached to the application will not
           // receive lifecycle events, we must force the manager to start resumed using
           // ApplicationLifecycle.
+
+          // TODO(b/27524013): Factor out this Glide.get() call.
+          Glide glide = Glide.get(context);
           applicationManager =
-              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode());
+              factory.build(glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
         }
       }
     }
@@ -114,15 +123,13 @@ public RequestManager get(FragmentActivity activity) {
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null);
+      return supportFragmentGet(activity, fm, null /*parentHint*/);
     }
   }
 
   public RequestManager get(Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
-    }
+    Preconditions.checkNotNull(fragment.getActivity(),
+          "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
@@ -131,14 +138,142 @@ public RequestManager get(Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public RequestManager get(Activity activity) {
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+    if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null);
+      return fragmentGet(activity, fm, null /*parentHint*/);
+    }
+  }
+
+  public RequestManager get(View view) {
+    if (Util.isOnBackgroundThread()) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    Preconditions.checkNotNull(view);
+    Preconditions.checkNotNull(view.getContext(),
+        "Unable to obtain a request manager for a view without a Context");
+    Activity activity = findActivity(view.getContext());
+    // The view might be somewhere else, like a service.
+    if (activity == null) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    // Support Fragments.
+    if (activity instanceof FragmentActivity) {
+      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+      if (fragment == null) {
+        return get(activity);
+      }
+      return get(fragment);
+    }
+
+    // Standard Fragments.
+    android.app.Fragment fragment = findFragment(view, activity);
+    if (fragment == null) {
+      return get(activity);
+    }
+    return get(fragment);
+  }
+
+  private static void findAllSupportFragmentsWithViews(
+      @Nullable Collection<Fragment> topLevelFragments,
+      Map<View, Fragment> result) {
+    if (topLevelFragments == null) {
+      return;
+    }
+    for (Fragment fragment : topLevelFragments) {
+      if (fragment.getView() == null) {
+        continue;
+      }
+      result.put(fragment.getView(), fragment);
+      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+    }
+  }
+
+  @Nullable
+  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+    tempViewToSupportFragment.clear();
+    findAllSupportFragmentsWithViews(
+        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+    Fragment result = null;
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+    while (!current.equals(activityRoot)) {
+      result = tempViewToSupportFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+
+    tempViewToSupportFragment.clear();
+    return result;
+  }
+
+  @Nullable
+  private android.app.Fragment findFragment(View target, Activity activity) {
+    tempViewToFragment.clear();
+    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+    android.app.Fragment result = null;
+
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+     while (!current.equals(activityRoot)) {
+      result = tempViewToFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+    tempViewToFragment.clear();
+    return result;
+  }
+
+  // TODO: Consider using an accessor class in the support library package to more directly retrieve
+  // non-support Fragments.
+  private void findAllFragmentsWithViews(
+      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+    int index = 0;
+    while (true) {
+      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+      android.app.Fragment fragment = null;
+      try {
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+      } catch (Exception e) {
+        // This generates log spam from FragmentManager anyway.
+      }
+      if (fragment == null) {
+        break;
+      }
+      if (fragment.getView() != null) {
+        result.put(fragment.getView(), fragment);
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    }
+  }
+
+  private Activity findActivity(Context context) {
+    if (context instanceof Activity) {
+      return (Activity) context;
+    } else if (context instanceof ContextWrapper) {
+      return findActivity(((ContextWrapper) context).getBaseContext());
+    } else {
+      return null;
     }
   }
 
@@ -180,14 +315,15 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
+  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
       android.app.Fragment parentHint) {
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -210,12 +346,15 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint) {
+  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
+      Fragment parentHint) {
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -239,10 +378,27 @@ public boolean handleMessage(Message message) {
         break;
       default:
         handled = false;
+        break;
     }
     if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
       Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
     }
     return handled;
   }
+
+  /**
+   * Used internally to create {@link RequestManager}s.
+   */
+  public interface RequestManagerFactory {
+    RequestManager build(
+        Glide glide, Lifecycle lifecycle, RequestManagerTreeNode requestManagerTreeNode);
+  }
+
+  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @Override
+    public RequestManager build(Glide glide, Lifecycle lifecycle,
+        RequestManagerTreeNode requestManagerTreeNode) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode);
+    }
+  };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 87f982947..38d341b3a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.RequestManager;
-
 import java.util.Set;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 48d5882a7..78a66c6a3 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 70cb3e3b0..a61b3af9b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -1,12 +1,14 @@
 package com.bumptech.glide.manager;
 
 import android.annotation.SuppressLint;
-import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-
+import android.util.Log;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -21,15 +23,16 @@
  * @see com.bumptech.glide.RequestManager
  */
 public class SupportRequestManagerFragment extends Fragment {
+  private static final String TAG = "SupportRMFragment";
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new SupportFragmentRequestManagerTreeNode();
   private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
       new HashSet<>();
 
-  private SupportRequestManagerFragment rootRequestManagerFragment;
-  private RequestManager requestManager;
-  private Fragment parentFragmentHint;
+  @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
+  @Nullable private RequestManager requestManager;
+  @Nullable private Fragment parentFragmentHint;
 
   public SupportRequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
@@ -57,6 +60,7 @@ ActivityFragmentLifecycle getLifecycle() {
   /**
    * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put.
    */
+  @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
@@ -131,7 +135,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(FragmentActivity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
@@ -146,9 +150,16 @@ private void unregisterFragmentWithRoot() {
   }
 
   @Override
-  public void onAttach(Activity activity) {
-    super.onAttach(activity);
-    registerFragmentWithRoot(getActivity());
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    try {
+      registerFragmentWithRoot(getActivity());
+    } catch (IllegalStateException e) {
+      // OnAttach can be called after the activity is destroyed, see #497.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to register fragment with root", e);
+      }
+    }
   }
 
   @Override
@@ -193,6 +204,10 @@ public String toString() {
   }
 
   private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    SupportFragmentRequestManagerTreeNode() { }
+
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 6c83dd896..64dd276db 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
new file mode 100644
index 000000000..9d40b969c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * Defines a set of dependencies and options to use when initializing Glide within an application.
+ *
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
+ * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ *
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with
+ * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ *
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
+ * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
+ * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ *
+ * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
+ * annotation processor, {@link AppGlideModule} implementations should override
+ * {@link #isManifestParsingEnabled()} and return {@code false}.
+ */
+public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
+  /**
+   * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
+   *
+   * <p>Implementations should return {@code false} after they and their dependencies have migrated
+   * to Glide's annotation processor.
+   *
+   * <p>Returns {@code true} by default.
+   */
+  public boolean isManifestParsingEnabled() {
+    return true;
+  }
+
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
new file mode 100644
index 000000000..923d364f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface AppliesOptions {
+  /**
+   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
+   * singleton is created.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context An Application {@link android.content.Context}.
+   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+   */
+  void applyOptions(Context context, GlideBuilder builder);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index 061856a6c..b8e2108e6 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -1,8 +1,5 @@
 package com.bumptech.glide.module;
 
-import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 
 /**
@@ -19,7 +16,7 @@
  *                      public class FlickrGlideModule implements GlideModule {
  *                          {@literal @}Override
  *                          public void applyOptions(Context context, GlideBuilder builder) {
- *                              buidler.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
+ *                              builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
  *                          }
  *
  *                          {@literal @}Override
@@ -53,28 +50,9 @@
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
  * instead providing their required dependencies in a single application module. </p>
+ *
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
+ * {@link AppGlideModule}.
  */
-public interface GlideModule {
-
-  /**
-   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
-   * singleton is created.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context An Application {@link android.content.Context}.
-   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
-   */
-  void applyOptions(Context context, GlideBuilder builder);
-
-  /**
-   * Lazily register components immediately after the Glide singleton is created but before any
-   * requests can be started.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context  An Application {@link android.content.Context}.
-   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
-   */
-  void registerComponents(Context context, Registry registry);
-}
+@Deprecated
+public interface GlideModule extends RegistersComponents, AppliesOptions { }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
new file mode 100644
index 000000000..f543d3729
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * Registers a set of components to use when initializing Glide within an app when
+ * Glide's annotation processor is used.
+ *
+ * <p>Any number of LibraryGlideModules can be contained within any library or application.
+ *
+ * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
+ * application conflict, {@link AppGlideModule}s can use the
+ * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
+ * the conflicting modules.
+ */
+public abstract class LibraryGlideModule implements RegistersComponents {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 7d9a755e5..9b0eb69a8 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-
+import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -11,6 +11,7 @@
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
 public final class ManifestParser {
+  private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
 
   private final Context context;
@@ -19,25 +20,43 @@ public ManifestParser(Context context) {
     this.context = context;
   }
 
+  @SuppressWarnings("deprecation")
   public List<GlideModule> parse() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Loading Glide modules");
+    }
     List<GlideModule> modules = new ArrayList<>();
     try {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
-      if (appInfo.metaData != null) {
-        for (String key : appInfo.metaData.keySet()) {
-          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
-            modules.add(parseModule(key));
+      if (appInfo.metaData == null) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got null app info metadata");
+        }
+        return modules;
+      }
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Got app info metadata: " + appInfo.metaData);
+      }
+      for (String key : appInfo.metaData.keySet()) {
+        if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+          modules.add(parseModule(key));
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Loaded Glide module: " + key);
           }
         }
       }
     } catch (PackageManager.NameNotFoundException e) {
       throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
     }
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Finished loading Glide modules");
+    }
 
     return modules;
   }
 
+  @SuppressWarnings("deprecation")
   private static GlideModule parseModule(String className) {
     Class<?> clazz;
     try {
@@ -49,9 +68,13 @@ private static GlideModule parseModule(String className) {
     Object module;
     try {
       module = clazz.newInstance();
-    } catch (InstantiationException | IllegalAccessException e) {
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
+              e);
+      // These can't be combined until API minimum is 19.
+    } catch (IllegalAccessException e) {
       throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-          e);
+              e);
     }
 
     if (!(module instanceof GlideModule)) {
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
new file mode 100644
index 000000000..1c6d8c9b8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface RegistersComponents {
+
+  /**
+   * Lazily register components immediately after the Glide singleton is created but before any
+   * requests can be started.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context  An Application {@link android.content.Context}.
+   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
+   */
+  void registerComponents(Context context, Registry registry);
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 6327df5be..29bd3af62 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Encoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -13,6 +14,7 @@
   private final List<Entry<?>> encoders = new ArrayList<>();
 
   @SuppressWarnings("unchecked")
+  @Nullable
   public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
     for (Entry<?> entry : encoders) {
       if (entry.handles(dataClass)) {
@@ -28,7 +30,7 @@
 
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    private final Encoder<T> encoder;
+    @Synthetic final Encoder<T> encoder;
 
     public Entry(Class<T> dataClass, Encoder<T> encoder) {
       this.dataClass = dataClass;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
new file mode 100644
index 000000000..af329320e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.provider;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
+ */
+public final class ImageHeaderParserRegistry {
+  private final List<ImageHeaderParser> parsers = new ArrayList<>();
+
+  public synchronized List<ImageHeaderParser> getParsers() {
+    return parsers;
+  }
+
+  public synchronized void add(ImageHeaderParser parser) {
+    parsers.add(parser);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index cd538df13..6cc5d9630 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
 import com.bumptech.glide.load.engine.LoadPath;
 import com.bumptech.glide.util.MultiClassKey;
-
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -26,6 +25,7 @@ public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> tra
   }
 
   @SuppressWarnings("unchecked")
+  @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
       Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
     MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 5c71f504e..076661dfa 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
 import com.bumptech.glide.util.MultiClassKey;
-
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -16,6 +15,7 @@
   private final ArrayMap<MultiClassKey, List<Class<?>>> registeredResourceClassCache =
       new ArrayMap<>();
 
+  @Nullable
   public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
     MultiClassKey key = resourceClassKeyRef.getAndSet(null);
     if (key == null) {
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index b56158351..877114e90 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.provider;
 
 import com.bumptech.glide.load.ResourceDecoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
- * into arbitrary resource types from highest priority decoders to loweset priority decoders.
+ * into arbitrary resource types from highest priority decoders to lowest priority decoders.
  */
 @SuppressWarnings("rawtypes")
 public class ResourceDecoderRegistry {
@@ -51,8 +51,8 @@
 
   private static class Entry<T, R> {
     private final Class<T> dataClass;
-    private final Class<R> resourceClass;
-    private final ResourceDecoder<T, R> decoder;
+    @Synthetic final Class<R> resourceClass;
+    @Synthetic final ResourceDecoder<T, R> decoder;
 
     public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index 3144221c9..e096cc759 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.ResourceEncoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -18,6 +19,7 @@
   }
 
   @SuppressWarnings("unchecked")
+  @Nullable
   public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
     int size = encoders.size();
     for (int i = 0; i < size; i++) {
@@ -32,14 +34,15 @@
 
   private static final class Entry<T> {
     private final Class<T> resourceClass;
-    private final ResourceEncoder<T> encoder;
+    @Synthetic final ResourceEncoder<T> encoder;
 
     Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
-    private boolean handles(Class<?> resourceClass) {
+    @Synthetic
+    boolean handles(Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
deleted file mode 100644
index 5bf5837e1..000000000
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ /dev/null
@@ -1,701 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Contains and exposes a variety of non type specific options that can be applied to a load in
- * Glide.
- *
- * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
- * attempted. To unlock, use {@link #clone()}. </p>
- *
- * @param <CHILD> The concrete and <em>final</em> subclass.
- */
-public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
-    implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TAG = 1 << 11;
-  private static final int TRANSFORMATION = 1 << 12;
-  private static final int RESOURCE_CLASS = 1 << 13;
-  private static final int FALLBACK = 1 << 14;
-  private static final int FALLBACK_ID = 1 << 15;
-  private static final int THEME = 1 << 16;
-
-  private int fields;
-
-  private float sizeMultiplier = 1f;
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  private Priority priority = Priority.NORMAL;
-  private Drawable errorPlaceholder;
-  private int errorId;
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = UNSET;
-  private int overrideWidth = UNSET;
-  private Key signature = EmptySignature.obtain();
-  private String tag;
-  private boolean isTransformationRequired;
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-
-  private Options options = new Options();
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  private Resources.Theme theme;
-
-  public final CHILD tag(String tag) {
-    this.tag = tag;
-    fields |= TAG;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public final CHILD sizeMultiplier(float sizeMultiplier) {
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public final CHILD diskCacheStrategy(DiskCacheStrategy strategy) {
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public final CHILD priority(Priority priority) {
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD placeholder(Drawable drawable) {
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public final CHILD placeholder(int resourceId) {
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD fallback(Drawable drawable) {
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public final CHILD fallback(int resourceId) {
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public final CHILD error(Drawable drawable) {
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD error(int resourceId) {
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public final CHILD theme(Resources.Theme theme) {
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public final CHILD skipMemoryCache(boolean skip) {
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public final CHILD override(int width, int height) {
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.StringSignature
-   */
-  public final CHILD signature(Key signature) {
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public final CHILD clone() {
-    try {
-      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      return (CHILD) result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public final <T> CHILD set(Option<T> option, T value) {
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD decode(Class<?> resourceClass) {
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public CHILD encodeFormat(Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, format);
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public CHILD encodeQuality(Integer quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  public CHILD format(DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  public CHILD frame(long frame) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frame);
-  }
-
-  public CHILD downsample(DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, strategy);
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop(android.content.Context)
-   */
-  public CHILD optionalCenterCrop(Context context) {
-    downsample(DownsampleStrategy.CENTER_OUTSIDE);
-    return optionalTransform(context, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop(android.content.Context)
-   */
-  public CHILD centerCrop(Context context) {
-    downsample(DownsampleStrategy.CENTER_OUTSIDE);
-    return transform(context, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter(android.content.Context)
-   */
-  public CHILD optionalFitCenter(Context context) {
-    downsample(DownsampleStrategy.CENTER_INSIDE);
-    return optionalTransform(context, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalFitCenter(android.content.Context)
-   */
-  public CHILD fitCenter(Context context) {
-    downsample(DownsampleStrategy.CENTER_INSIDE);
-    return transform(context, new FitCenter(context));
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #optionalTransform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD transform(Context context, Transformation<Bitmap> transformation) {
-    optionalTransform(context, transformation);
-    isTransformationRequired = true;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(context, transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(context, transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
-   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   */
-  public final <T> CHILD optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    fields |= TRANSFORMATION;
-    transformations.put(resourceClass, transformation);
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  public final CHILD dontTransform() {
-    fields &= ~TRANSFORMATION;
-    transformations.clear();
-    isTransformationRequired = false;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public final CHILD dontAnimate() {
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public final CHILD lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return (CHILD) this;
-  }
-
-  public final Options getOptions() {
-    return options;
-  }
-
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  public final CHILD apply(BaseRequestOptions<?> other) {
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, TAG)) {
-      tag = other.tag;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-
-    isTransformationRequired |= other.isTransformationRequired;
-    fields |= other.fields;
-    transformations.putAll(other.transformations);
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  public final String getTag() {
-    return tag;
-  }
-
-  @SuppressWarnings("unchecked")
-  private CHILD selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return (CHILD) this;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index aa485d357..063b96dd8 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.request;
 
 import com.bumptech.glide.request.target.Target;
-
 import java.util.concurrent.Future;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 018be8e2e..4ba29827f 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -2,11 +2,10 @@
 
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
-
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -22,13 +21,27 @@
  *
  * <pre>
  *     {@code
- *      RequestFutureTarget target = Glide.load("")...
- *     Object resource = target.get();
- *     // Do something with resource, and when finished:
- *     target.cancel(false);
+ *      FutureTarget<File> target = null;
+ *      RequestManager requestManager = Glide.with(context);
+ *      try {
+ *        target = requestManager
+ *           .downloadOnly()
+ *           .load(model)
+ *           .submit();
+ *        File downloadedFile = target.get();
+ *        // ... do something with the file (usually throws IOException)
+ *      } catch (ExecutionException | InterruptedException | IOException e) {
+ *        // ... bug reporting or recovery
+ *      } finally {
+ *        // make sure to cancel pending operations and free resources
+ *        if (target != null) {
+ *          target.cancel(true); // mayInterruptIfRunning
+ *        }
+ *      }
  *     }
  *     </pre>
- * The {@link #cancel(boolean)} call will make sure any resources used are recycled.
+ * The {@link #cancel(boolean)} call will cancel pending operations and
+ * make sure that any resources used are recycled.
  * </p>
  *
  * @param <R> The type of the resource that will be loaded.
@@ -44,8 +57,8 @@
   private final boolean assertBackgroundThread;
   private final Waiter waiter;
 
-  private R resource;
-  private Request request;
+  @Nullable private R resource;
+  @Nullable private Request request;
   private boolean isCancelled;
   private boolean resultReceived;
   private boolean loadFailed;
@@ -68,17 +81,15 @@ public RequestFutureTarget(Handler mainHandler, int width, int height) {
 
   @Override
   public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isCancelled) {
-      return true;
+    if (isDone()) {
+      return false;
     }
-
-    final boolean result = !isDone();
-    if (result) {
-      isCancelled = true;
-      waiter.notifyAll(this);
+    isCancelled = true;
+    waiter.notifyAll(this);
+    if (mayInterruptIfRunning) {
+      clearOnMainThread();
     }
-    clearOnMainThread();
-    return result;
+    return true;
   }
 
   @Override
@@ -114,15 +125,21 @@ public void getSize(SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing because we do not retain references to SizeReadyCallbacks.
+  }
+
   /**
    * {@inheritDoc}
    */
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
+  @Nullable
   public Request getRequest() {
     return request;
   }
@@ -165,7 +182,7 @@ public synchronized void onResourceReady(R resource, Transition<? super R> trans
 
   private synchronized R doGet(Long timeoutMillis)
       throws ExecutionException, InterruptedException, TimeoutException {
-    if (assertBackgroundThread) {
+    if (assertBackgroundThread && !isDone()) {
       Util.assertBackgroundThread();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index 92f031189..0644473d2 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.request;
 
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
 
 /**
@@ -30,13 +33,16 @@
    * <p> Note - if you want to reload this or any other model after an exception, you will need to
    * include all relevant builder calls (like centerCrop, placeholder etc). </p>
    *
+   * @param e               The maybe {@code null} exception containing information about why the
+   *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
-   * @param isFirstResource True if this exception is for the first resource to load.
-   * @return True if the listener has handled updating the target for the given exception, false to
-   * allow Glide's request to update the target.
+   * @param isFirstResource {@code true} if this exception is for the first resource to load.
+   * @return {@code true} if the listener has handled updating the target for the given exception,
+   *         {@code false} to allow Glide's request to update the target.
    */
-  boolean onLoadFailed(Object model, Target<R> target, boolean isFirstResource);
+  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
+      boolean isFirstResource);
 
   /**
    * Called when a load completes successfully, immediately after {@link
@@ -45,15 +51,15 @@
    * @param resource          The resource that was loaded for the target.
    * @param model             The specific model that was used to load the image.
    * @param target            The target the model was loaded into.
-   * @param isFromMemoryCache True if the load completed synchronously (useful for determining
-   *                          whether or not to run a transition)
-   * @param isFirstResource   True if this is the first resource to in this load to be loaded into
-   *                          the target. For example when loading a thumbnail and a fullsize image,
-   *                          this will be true for the first image to load and false for the
-   *                          second.
-   * @return True if the listener has handled setting the resource on the target (including any
-   * animations), false to allow Glide's request to update the target (again including animations).
+   * @param dataSource        The {@link DataSource} the resource was loaded from.
+   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
+   *                          loaded into the target. For example when loading a thumbnail and a
+   *                          full-sized image, this will be {@code true} for the first image to
+   *                          load and {@code false} for the second.
+   * @return {@code true} if the listener has handled setting the resource on the target,
+   *         {@code false} to allow Glide's request to update the target.
+   *         Setting the resource includes handling animations, be sure to take that into account.
    */
-  boolean onResourceReady(R resource, Object model, Target<R> target, boolean isFromMemoryCache,
+  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
       boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 319440019..e796c58cb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,120 +1,323 @@
 package com.bumptech.glide.request;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
- *
- * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
- * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ * Provides type independent options to customize loads with Glide.
  */
-@SuppressWarnings("PMD.UseUtilityClass")
-public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
+public class RequestOptions implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+
+  private static RequestOptions skipMemoryCacheTrueOptions;
+  private static RequestOptions skipMemoryCacheFalseOptions;
+  private static RequestOptions fitCenterOptions;
+  private static RequestOptions centerInsideOptions;
+  private static RequestOptions centerCropOptions;
+  private static RequestOptions circleCropOptions;
+  private static RequestOptions noTransformOptions;
+  private static RequestOptions noAnimationOptions;
+
+  private int fields;
+  private float sizeMultiplier = 1f;
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  private Priority priority = Priority.NORMAL;
+  private Drawable errorPlaceholder;
+  private int errorId;
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = RequestOptions.UNSET;
+  private int overrideWidth = RequestOptions.UNSET;
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  private Options options = new Options();
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   */
   public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
-  public static RequestOptions diskCacheStrategyOf(DiskCacheStrategy diskCacheStrategy) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   */
+  public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
   }
 
-  public static RequestOptions priorityOf(Priority priority) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
+   */
+  public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
 
-  public static RequestOptions placeholderOf(Drawable placeholder) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
+   */
+  public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
+   */
   public static RequestOptions placeholderOf(int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
-  public static RequestOptions errorOf(Drawable errorDrawable) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
+   */
+  public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
+   */
   public static RequestOptions errorOf(int errorId) {
     return new RequestOptions().error(errorId);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
+   */
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
-    return new RequestOptions().skipMemoryCache(skipMemoryCache);
+    if (skipMemoryCache) {
+      if (skipMemoryCacheTrueOptions == null) {
+        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoClone();
+      }
+      return skipMemoryCacheTrueOptions;
+    } else {
+      if (skipMemoryCacheFalseOptions == null) {
+        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoClone();
+      }
+      return skipMemoryCacheFalseOptions;
+    }
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
+   */
   public static RequestOptions overrideOf(int width, int height) {
     return new RequestOptions().override(width, height);
   }
 
-  public static RequestOptions signatureOf(Key signature) {
+  /**
+   * Returns a {@link RequestOptions} with {@link #override(int, int)} set where both the width and
+   * height are the given size.
+   */
+  public static RequestOptions overrideOf(int size) {
+    return overrideOf(size, size);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #signature} set.
+   */
+  public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
 
-  public static RequestOptions tagOf(String tag) {
-    return new RequestOptions().tag(tag);
+  /**
+   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
+   */
+  public static RequestOptions fitCenterTransform() {
+    if (fitCenterOptions == null) {
+      fitCenterOptions = new RequestOptions()
+          .fitCenter()
+          .autoClone();
+    }
+    return fitCenterOptions;
   }
 
-  public static RequestOptions fitCenterTransform(Context context) {
-    return new RequestOptions().fitCenter(context);
+  /**
+   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
+   */
+  public static RequestOptions centerInsideTransform() {
+    if (centerInsideOptions == null) {
+      centerInsideOptions = new RequestOptions()
+              .centerInside()
+              .autoClone();
+    }
+    return centerInsideOptions;
   }
 
-  public static RequestOptions centerCropTransform(Context context) {
-    return new RequestOptions().centerCrop(context);
+  /**
+   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
+   */
+  public static RequestOptions centerCropTransform() {
+    if (centerCropOptions == null) {
+      centerCropOptions = new RequestOptions()
+          .centerCrop()
+          .autoClone();
+    }
+    return centerCropOptions;
   }
 
-  public static RequestOptions bitmapTransform(Context context,
-      Transformation<Bitmap> transformation) {
-    return new RequestOptions().transform(context, transformation);
+  /**
+   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
+   */
+  public static RequestOptions circleCropTransform() {
+    if (circleCropOptions == null) {
+      circleCropOptions = new RequestOptions()
+          .circleCrop()
+          .autoClone();
+    }
+    return circleCropOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
+   *
+   * @deprecated Use {@link #bitmapTransform(Transformation)}.
+   */
+  @Deprecated
+  public static RequestOptions bitmapTransform(
+      Context context, @NonNull Transformation<Bitmap> transformation) {
+    return bitmapTransform(transformation);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
+   */
+  public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new RequestOptions().transform(transformation);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   *
+   * @deprecated use {@link #noTransformation()}
+   */
+  @Deprecated
   public static RequestOptions noTransform() {
-    return new RequestOptions().dontTransform();
+    return noTransformation();
   }
 
-  public static <T> RequestOptions option(Option<T> option, T value) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   */
+  public static RequestOptions noTransformation() {
+    if (noTransformOptions == null) {
+      noTransformOptions = new RequestOptions()
+          .dontTransform()
+          .autoClone();
+    }
+    return noTransformOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with the given {@link Option} set via
+   * {@link #set(Option, Object)}.
+   */
+  public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
   }
 
-  public static RequestOptions decodeTypeOf(Class<?> resourceClass) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
+   */
+  public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
 
-  public static RequestOptions formatOf(DecodeFormat format) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
+   */
+  public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
 
-  public static RequestOptions frameOf(int frame) {
-    return new RequestOptions().frame(frame);
+  /**
+   * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
+   */
+  public static RequestOptions frameOf(long frameTimeMicros) {
+    return new RequestOptions().frame(frameTimeMicros);
   }
 
-  public static RequestOptions downsampleOf(DownsampleStrategy strategy) {
+  /**
+   * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
+   */
+  public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
   }
 
   /**
-   * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link
-   * #encodeQuality(Integer)} called with the given quality.
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
+   * #encodeQuality(int)} called with the given quality.
    */
-  public static RequestOptions encodeQualityOf(Integer quality) {
+  public static RequestOptions encodeQualityOf(int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
 
   /**
-   * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
-  public static RequestOptions encodeFormatOf(Bitmap.CompressFormat format) {
+  public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
   }
 
@@ -123,6 +326,969 @@ public static RequestOptions encodeFormatOf(Bitmap.CompressFormat format) {
    * called.
    */
   public static RequestOptions noAnimation() {
-    return new RequestOptions().dontAnimate();
+    if (noAnimationOptions == null) {
+      noAnimationOptions = new RequestOptions()
+          .dontAnimate()
+          .autoClone();
+    }
+    return noAnimationOptions;
+  }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  public RequestOptions onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  public RequestOptions priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  public RequestOptions error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions error(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  public RequestOptions theme(Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  public RequestOptions skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  public RequestOptions override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  public RequestOptions override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  public RequestOptions signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public RequestOptions clone() {
+    try {
+      RequestOptions result = (RequestOptions) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (RequestOptions) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  public RequestOptions encodeQuality(int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler}.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   */
+  public RequestOptions format(@NonNull DecodeFormat format) {
+    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  public RequestOptions frame(long frameTimeMicros) {
+    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   */
+  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  public RequestOptions optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #centerCrop()}.
+   */
+  @Deprecated
+  public RequestOptions centerCrop(@SuppressWarnings("unused") Context context) {
+    return centerCrop();
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  public RequestOptions optionalFitCenter() {
+    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  public RequestOptions fitCenter() {
+    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   *
+   * @deprecated Use {@link #optionalCenterInside()}
+   */
+  @Deprecated
+  public RequestOptions optionalCenterInside(@SuppressWarnings("unused") Context context) {
+    return optionalCenterInside();
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  public RequestOptions optionalCenterInside() {
+    return optionalTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  public RequestOptions centerInside() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  public RequestOptions optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #circleCrop()}.
+   */
+  @Deprecated
+  public RequestOptions circleCrop(@SuppressWarnings("unused") Context context) {
+    return circleCrop();
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return optionalTransform(transformation);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation);
+    }
+
+    optionalTransform(transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context        Any {@link Context}.
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Class, Transformation)
+   *
+   * @deprecated Use {@link #optionalTransform(Transformation)}
+   */
+  @Deprecated
+  public RequestOptions optionalTransform(Context context, Transformation<Bitmap> transformation) {
+    return optionalTransform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(transformation);
+    }
+
+    optionalTransform(Bitmap.class, transformation);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    optionalTransform(BitmapDrawable.class,
+        new BitmapDrawableTransformation(transformation));
+    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
+      Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(resourceClass, transformation);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public <T> RequestOptions transform(
+      Class<T> resourceClass, Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation);
+    }
+
+    optionalTransform(resourceClass, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  public RequestOptions dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  public RequestOptions dontAnimate() {
+    if (isAutoCloneEnabled) {
+      return clone().dontAnimate();
+    }
+
+    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions apply(RequestOptions other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @SuppressWarnings("unchecked")
+  public RequestOptions lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return (RequestOptions) this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  public RequestOptions autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @SuppressWarnings("unchecked")
+  private RequestOptions selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return (RequestOptions) this;
+  }
+
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  public final Options getOptions() {
+    return options;
+  }
+
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
index 7969957ff..ed1ec1063 100644
--- a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.request;
 
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -14,7 +15,7 @@
    *
    * @param resource The loaded resource.
    */
-  void onResourceReady(Resource<?> resource);
+  void onResourceReady(Resource<?> resource, DataSource dataSource);
 
   /**
    * Called when a resource fails to load successfully.
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index f9d715e0b..9d06f3ffc 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -2,13 +2,14 @@
 
 import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
 import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
-import android.support.v4.util.Pools.SimplePool;
+import android.support.v7.content.res.AppCompatResources;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
@@ -17,7 +18,10 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
 
 /**
  * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given
@@ -27,10 +31,19 @@
  */
 public final class SingleRequest<R> implements Request,
     SizeReadyCallback,
-    ResourceCallback {
+    ResourceCallback,
+    FactoryPools.Poolable {
+  /** Tag for logging internal events, not generally suitable for public use. */
   private static final String TAG = "Request";
-  private static final Pools.Pool<SingleRequest<?>> REQUEST_POOL = new SimplePool<>(150);
-  private static final double TO_MEGABYTE = 1d / (1024d * 1024d);
+  /** Tag for logging externally useful events (request completion, timing etc). */
+  private static final String GLIDE_TAG = "Glide";
+  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.simple(150,
+      new FactoryPools.Factory<SingleRequest<?>>() {
+        @Override
+        public SingleRequest<?> create() {
+          return new SingleRequest<Object>();
+        }
+      });
 
   private enum Status {
     /**
@@ -68,12 +81,13 @@
   }
 
   private final String tag = String.valueOf(hashCode());
+  private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
   private RequestCoordinator requestCoordinator;
   private GlideContext glideContext;
   private Object model;
   private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
@@ -81,7 +95,6 @@
   private RequestListener<R> requestListener;
   private Engine engine;
   private TransitionFactory<? super R> animationFactory;
-  private boolean loadedFromMemoryCache;
   private Resource<R> resource;
   private Engine.LoadStatus loadStatus;
   private long startTime;
@@ -89,12 +102,15 @@
   private Drawable errorDrawable;
   private Drawable placeholderDrawable;
   private Drawable fallbackDrawable;
+  private int width;
+  private int height;
+  private static boolean shouldCallAppCompatResources = true;
 
   public static <R> SingleRequest<R> obtain(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -104,7 +120,7 @@
       Engine engine,
       TransitionFactory<? super R> animationFactory) {
     @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) REQUEST_POOL.acquire();
+        (SingleRequest<R>) POOL.acquire();
     if (request == null) {
       request = new SingleRequest<>();
     }
@@ -124,7 +140,8 @@
     return request;
   }
 
-  private SingleRequest() {
+  @Synthetic
+  SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
@@ -132,7 +149,7 @@ private void init(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -156,6 +173,11 @@ private void init(
     status = Status.PENDING;
   }
 
+  @Override
+  public StateVerifier getVerifier() {
+    return stateVerifier;
+  }
+
   @Override
   public void recycle() {
     glideContext = null;
@@ -168,19 +190,28 @@ public void recycle() {
     requestListener = null;
     requestCoordinator = null;
     animationFactory = null;
-    loadedFromMemoryCache = false;
     loadStatus = null;
     errorDrawable = null;
     placeholderDrawable = null;
     fallbackDrawable = null;
-    REQUEST_POOL.release(this);
+    width = -1;
+    height = -1;
+    POOL.release(this);
   }
 
   @Override
   public void begin() {
+    stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
-      onLoadFailed(new GlideException("Received null model"));
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+        width = overrideWidth;
+        height = overrideHeight;
+      }
+      // Only log at more verbose log levels if the user has set a fallback drawable, because
+      // fallback Drawables indicate the user expects null models occasionally.
+      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+      onLoadFailed(new GlideException("Received null model"), logLevel);
       return;
     }
 
@@ -209,6 +240,8 @@ public void begin() {
    * @see #clear()
    */
   void cancel() {
+    stateVerifier.throwIfRecycled();
+    target.removeCallback(this);
     status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
@@ -253,7 +286,7 @@ public void pause() {
     status = Status.PAUSED;
   }
 
-  private void releaseResource(Resource resource) {
+  private void releaseResource(Resource<?> resource) {
     engine.release(resource);
     this.resource = null;
   }
@@ -313,9 +346,30 @@ private Drawable getFallbackDrawable() {
     return fallbackDrawable;
   }
 
-  private Drawable loadDrawable(int resouceId) {
+  private Drawable loadDrawable(@DrawableRes int resourceId) {
+    if (shouldCallAppCompatResources) {
+      return loadDrawableV7(resourceId);
+    } else {
+      return loadDrawableBase(resourceId);
+    }
+  }
+
+  /**
+   * Tries to load the drawable thanks to AppCompatResources.<br>
+   * This allows to parse VectorDrawables on legacy devices if the appcompat v7 is in the classpath.
+   */
+  private Drawable loadDrawableV7(@DrawableRes int resourceId) {
+    try {
+      return AppCompatResources.getDrawable(glideContext, resourceId);
+    } catch (NoClassDefFoundError error) {
+      shouldCallAppCompatResources = false;
+      return loadDrawableBase(resourceId);
+    }
+  }
+
+  private Drawable loadDrawableBase(@DrawableRes int resourceId) {
     Resources resources = glideContext.getResources();
-    return ResourcesCompat.getDrawable(resources, resouceId, requestOptions.getTheme());
+    return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());
   }
 
   private void setErrorPlaceholder() {
@@ -323,9 +377,14 @@ private void setErrorPlaceholder() {
       return;
     }
 
-    Drawable error = model == null ? getFallbackDrawable() : getErrorDrawable();
+    Drawable error = null;
+    if (model == null) {
+      error = getFallbackDrawable();
+    }
+    // Either the model isn't null, or there was no fallback drawable set. Either way we should show
+    // the error Drawable.
     if (error == null) {
-      error = getPlaceholderDrawable();
+      error = getErrorDrawable();
     }
     target.onLoadFailed(error);
   }
@@ -335,6 +394,7 @@ private void setErrorPlaceholder() {
    */
   @Override
   public void onSizeReady(int width, int height) {
+    stateVerifier.throwIfRecycled();
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
@@ -344,19 +404,18 @@ public void onSizeReady(int width, int height) {
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
-    width = Math.round(sizeMultiplier * width);
-    height = Math.round(sizeMultiplier * height);
+    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
-    loadedFromMemoryCache = true;
     loadStatus = engine.load(
         glideContext,
         model,
         requestOptions.getSignature(),
-        width,
-        height,
+        this.width,
+        this.height,
         requestOptions.getResourceClass(),
         transcodeClass,
         priority,
@@ -365,13 +424,18 @@ public void onSizeReady(int width, int height) {
         requestOptions.isTransformationRequired(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
+        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getOnlyRetrieveFromCache(),
         this);
-    loadedFromMemoryCache = resource != null;
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
 
+  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+  }
+
   private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
@@ -395,7 +459,8 @@ private void notifyLoadSuccess() {
    */
   @SuppressWarnings("unchecked")
   @Override
-  public void onResourceReady(Resource<?> resource) {
+  public void onResourceReady(Resource<?> resource, DataSource dataSource) {
+    stateVerifier.throwIfRecycled();
     loadStatus = null;
     if (resource == null) {
       GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
@@ -424,36 +489,36 @@ public void onResourceReady(Resource<?> resource) {
       return;
     }
 
-    onResourceReady((Resource<R>) resource, (R) received);
+    onResourceReady((Resource<R>) resource, (R) received, dataSource);
   }
 
   /**
-   * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
+   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
    *
    * @param resource original {@link Resource}, never <code>null</code>
    * @param result   object returned by {@link Resource#get()}, checked for type and never
    *                 <code>null</code>
    */
-  private void onResourceReady(Resource<R> resource, R result) {
+  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
     // We must call isFirstReadyResource before setting status.
     boolean isFirstResource = isFirstReadyResource();
     status = Status.COMPLETE;
     this.resource = resource;
 
+    if (glideContext.getLogLevel() <= Log.DEBUG) {
+      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
+          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
+          + LogTime.getElapsedMillis(startTime) + " ms");
+    }
+
     if (requestListener == null
-        || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
-        isFirstResource)) {
+        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
       Transition<? super R> animation =
-          animationFactory.build(loadedFromMemoryCache, isFirstResource);
+          animationFactory.build(dataSource, isFirstResource);
       target.onResourceReady(result, animation);
     }
 
     notifyLoadSuccess();
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: " + (
-          resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
-    }
   }
 
   /**
@@ -461,18 +526,24 @@ private void onResourceReady(Resource<R> resource, R result) {
    */
   @Override
   public void onLoadFailed(GlideException e) {
-    if (Log.isLoggable(TAG, Log.DEBUG)) {
-      Log.d(TAG, "Load failed for: " + model, e);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        e.logRootCauses(TAG);
+    onLoadFailed(e, Log.WARN);
+  }
+
+  private void onLoadFailed(GlideException e, int maxLogLevel) {
+    stateVerifier.throwIfRecycled();
+    int logLevel = glideContext.getLogLevel();
+    if (logLevel <= maxLogLevel) {
+      Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
+      if (logLevel <= Log.INFO) {
+        e.logRootCauses(GLIDE_TAG);
       }
     }
 
     loadStatus = null;
     status = Status.FAILED;
     //TODO: what if this is a thumbnail request?
-    if (requestListener == null || !requestListener.onLoadFailed(model, target,
-        isFirstReadyResource())) {
+    if (requestListener == null
+        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {
       setErrorPlaceholder();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 2fef40691..996f41ad3 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request;
 
+import android.support.annotation.Nullable;
+
 /**
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
  * version of an image and the full size version of the image at the same time.
@@ -8,7 +10,7 @@
     Request {
   private Request full;
   private Request thumb;
-  private RequestCoordinator coordinator;
+  @Nullable private RequestCoordinator coordinator;
   private boolean isRunning;
 
   public ThumbnailRequestCoordinator() {
@@ -25,7 +27,7 @@ public void setRequests(Request full, Request thumb) {
   }
 
   /**
-   * Returns true if the request is either the request loading the fullsize image or if the request
+   * Returns true if the request is either the request loading the full size image or if the request
    * loading the full size image has not yet completed.
    *
    * @param request {@inheritDoc}
@@ -40,8 +42,8 @@ private boolean parentCanSetImage() {
   }
 
   /**
-   * Returns true if the request is the request loading the fullsize image and if neither the full
-   * nor the thumbnail image have completed sucessfully.
+   * Returns true if the request is the request loading the full size image and if neither the full
+   * nor the thumbnail image have completed successfully.
    *
    * @param request {@inheritDoc}.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 6928462ae..5259a5973 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -5,7 +5,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -17,7 +16,6 @@
  * for every subsequent load. </p>
  */
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
-
   private final int[] widgetIds;
   private final ComponentName componentName;
   private final RemoteViews remoteViews;
@@ -29,16 +27,16 @@
    * it.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param viewId      The id of the ImageView view that will load the image.
    * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
    * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, int... widgetIds) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -56,29 +54,30 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
    * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, ComponentName componentName) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -94,14 +93,14 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
+   * @param viewId        The id of the ImageView view that will load the image.
    * @param remoteViews   RemoteViews object which contains the ImageView that will load the
    *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId,
-      ComponentName componentName) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 1c3e2407a..792de64a3 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 
 /**
@@ -23,27 +23,28 @@
   private Request request;
 
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
+  @Nullable
   public Request getRequest() {
     return request;
   }
 
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadFailed(Drawable errorDrawable) {
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
new file mode 100644
index 000000000..c4b247964
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+/**
+ * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
+ */
+public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
+  public BitmapThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected Drawable getDrawable(Bitmap resource) {
+    return new BitmapDrawable(view.getResources(), resource);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index 18d4adc68..e9ab75e01 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -1,59 +1,20 @@
 package com.bumptech.glide.request.target;
 
-import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.view.ViewGroup;
+import android.support.annotation.Nullable;
 import android.widget.ImageView;
 
-import com.bumptech.glide.request.transition.Transition;
-
 /**
  * A target for display {@link Drawable} objects in {@link ImageView}s.
  */
 public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {
-  private Drawable resource;
 
   public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
   @Override
-  protected void setResource(Drawable resource) {
-    this.resource = resource;
+  protected void setResource(@Nullable Drawable resource) {
     view.setImageDrawable(resource);
   }
-
-  @Override
-  public void onResourceReady(Drawable resource, Transition<? super Drawable> transition) {
-    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-
-    // This is a dirty hack that tries to make loading square thumbnails and then square full
-    // images less costly by forcing both the smaller thumb and the larger version to have exactly
-    // the same intrinsic dimensions. If a drawable is replaced in an ImageView by another drawable
-    // with different intrinsic dimensions, the ImageView requests a layout. Scrolling rapidly while
-    // replacing thumbs with larger images triggers lots of these calls and causes significant
-    // amounts of jank.
-    if (!(resource instanceof Animatable) && layoutParams != null && layoutParams.width > 0
-        && layoutParams.height > 0) {
-      resource = new FixedSizeDrawable(resource, layoutParams.width, layoutParams.height);
-    }
-    super.onResourceReady(resource, transition);
-    if (resource instanceof Animatable) {
-      ((Animatable) resource).start();
-    }
-  }
-
-  @Override
-  public void onStart() {
-    if (resource instanceof Animatable) {
-      ((Animatable) resource).start();
-    }
-  }
-
-  @Override
-  public void onStop() {
-    if (resource instanceof Animatable) {
-      ((Animatable) resource).stop();
-    }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
new file mode 100644
index 000000000..416633f7c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+
+/**
+ * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
+ */
+public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
+  public DrawableThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected Drawable getDrawable(Drawable resource) {
+    return resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index f58eceda3..f5d978a22 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -10,8 +10,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with
@@ -81,7 +81,6 @@ public void setFilterBitmap(boolean filter) {
     wrapped.setFilterBitmap(filter);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public Callback getCallback() {
     return wrapped.getCallback();
@@ -196,8 +195,8 @@ public ConstantState getConstantState() {
 
   static class State extends ConstantState {
     private final ConstantState wrapped;
-    private final int width;
-    private final int height;
+    @Synthetic final int width;
+    @Synthetic final int height;
 
     State(State other) {
       this(other.wrapped, other.width, other.height);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index ebaa4b118..eb4fa50ab 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
 
 /**
@@ -15,6 +16,9 @@
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
+  @Nullable
+  private Animatable animatable;
+
   public ImageViewTarget(ImageView view) {
     super(view);
   }
@@ -24,6 +28,7 @@ public ImageViewTarget(ImageView view) {
    * using {@link android.widget.ImageView#getDrawable()}.
    */
   @Override
+  @Nullable
   public Drawable getCurrentDrawable() {
     return view.getDrawable();
   }
@@ -46,8 +51,9 @@ public void setDrawable(Drawable drawable) {
    * @param placeholder {@inheritDoc}
    */
   @Override
-  public void onLoadStarted(Drawable placeholder) {
-    setResource(null);
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
@@ -58,8 +64,9 @@ public void onLoadStarted(Drawable placeholder) {
    * @param errorDrawable {@inheritDoc}
    */
   @Override
-  public void onLoadFailed(Drawable errorDrawable) {
-    setResource(null);
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+    super.onLoadFailed(errorDrawable);
+    setResourceInternal(null);
     setDrawable(errorDrawable);
   }
 
@@ -70,19 +77,49 @@ public void onLoadFailed(Drawable errorDrawable) {
    * @param placeholder {@inheritDoc}
    */
   @Override
-  public void onLoadCleared(Drawable placeholder) {
-    setResource(null);
+  public void onLoadCleared(@Nullable Drawable placeholder) {
+    super.onLoadCleared(placeholder);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
-  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
-      setResource(resource);
+      setResourceInternal(resource);
+    } else {
+      maybeUpdateAnimatable(resource);
+    }
+  }
+
+  @Override
+  public void onStart() {
+    if (animatable != null) {
+      animatable.start();
+    }
+  }
+
+  @Override
+  public void onStop() {
+    if (animatable != null) {
+      animatable.stop();
     }
   }
 
-  protected abstract void setResource(Z resource);
+  private void setResourceInternal(@Nullable Z resource) {
+    maybeUpdateAnimatable(resource);
+    setResource(resource);
+  }
+
+  private void maybeUpdateAnimatable(@Nullable Z resource) {
+    if (resource instanceof Animatable) {
+      animatable = (Animatable) resource;
+      animatable.start();
+    } else {
+      animatable = null;
+    }
+  }
 
+  protected abstract void setResource(@Nullable Z resource);
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index ec889d0ad..481523111 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -6,7 +6,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -18,10 +17,10 @@
  * for every subsequent load. </p>
  */
 public class NotificationTarget extends SimpleTarget<Bitmap> {
-
   private final RemoteViews remoteViews;
   private final Context context;
   private final int notificationId;
+  private final String notificationTag;
   private final Notification notification;
   private final int viewId;
 
@@ -30,35 +29,58 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param notification   The Notification object that we want to update.
-   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
-      Notification notification, int notificationId) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+  public NotificationTarget(Context context,
+      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+    this(context, viewId, remoteViews, notification, notificationId, null);
   }
 
   /**
-   * Constructor using a Notification object and a notificationId to get a handle on the
-   * Notification in order to update it.
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the
+   * target width and height.
+   *
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
+   *                        May be {@code null}.
+   */
+  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
+      Notification notification, int notificationId, String notificationTag) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
+      notificationTag);
+  }
+
+  /**
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param width          Desired width of the bitmap that will be loaded.(Need to be manually put
-   *                       because of RemoteViews limitations.)
-   * @param height         Desired height of the bitmap that will be loaded. (Need to be manually
-   *                       put because of RemoteViews limitations.)
-   * @param notification   The Notification object that we want to update.
-   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param width           Desired width of the bitmap that will be loaded.(Need to be manually put
+   *                        because of RemoteViews limitations.)
+   * @param height          Desired height of the bitmap that will be loaded. (Need to be manually
+   *                        put because of RemoteViews limitations.)
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the
+   *                        Bitmap. May be {@code null}.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, Notification notification, int notificationId) {
+  public NotificationTarget(Context context, int width, int height, int viewId,
+      RemoteViews remoteViews, Notification notification, int notificationId,
+      String notificationTag) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
     this.notification =
@@ -67,6 +89,7 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
         Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
     this.viewId = viewId;
     this.notificationId = notificationId;
+    this.notificationTag = notificationTag;
   }
 
   /**
@@ -75,7 +98,7 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationId, this.notification);
+    manager.notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 1199c6870..fd1baf5b7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -5,7 +5,7 @@
 /**
  * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
- * Typicaly use cases look something like this:
+ * Typically use cases look something like this:
  * <pre>
  * <code>
  * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
@@ -64,4 +64,9 @@ public final void getSize(SizeReadyCallback cb) {
     }
     cb.onSizeReady(width, height);
   }
+
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing, we never retain a reference to the callback.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index acc9efa18..dbdbc4779 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
@@ -30,25 +30,33 @@
    * A lifecycle callback that is called when a load is started.
    *
    * <p> Note - This may not be called for every load, it is possible for example for loads to fail
-   * before the load starts (when the model object is null). </p>
+   * before the load starts (when the model object is null).
    *
    * <p> Note - This method may be called multiple times before any other lifecycle method is
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here. </p>
+   * restart may cause a call here.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
-  void onLoadStarted(Drawable placeholder);
+  void onLoadStarted(@Nullable Drawable placeholder);
 
   /**
    * A lifecycle callback that is called when a load fails.
    *
    * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null. </p>
+   * } if the model object is null.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
-  void onLoadFailed(Drawable errorDrawable);
+  void onLoadFailed(@Nullable Drawable errorDrawable);
 
   /**
    * The method that will be called when the resource load has finished.
@@ -60,9 +68,13 @@
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
    *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
+   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
-  void onLoadCleared(Drawable placeholder);
+  void onLoadCleared(@Nullable Drawable placeholder);
 
   /**
    * A method to retrieve the size of this target.
@@ -71,13 +83,21 @@
    */
   void getSize(SizeReadyCallback cb);
 
+  /**
+   * Removes the given callback from the pending set if it's still retained.
+   *
+   * @param cb The callback to remove.
+   */
+  void removeCallback(SizeReadyCallback cb);
+
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
    */
-  void setRequest(Request request);
+  void setRequest(@Nullable Request request);
 
   /**
    * Retrieves the current request for this target, should not be called outside of Glide.
    */
+  @Nullable
   Request getRequest();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
new file mode 100644
index 000000000..c3d658f9b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.request.target;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+/**
+ * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once
+ * image into an {@link android.widget.ImageView} with fixed dimensions.
+ *
+ * <p>Typically it makes sense
+ * to use this class when loading multiple images with the {@link
+ * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
+ * a scrolling list like ListView, GridView, or RecyclerView.
+ *
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on
+ * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
+ * {@link BitmapImageViewTarget} as alternatives.
+ *
+ * @param <T> The type of resource that will be displayed in the ImageView.
+ */
+public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
+
+  public ThumbnailImageViewTarget(ImageView view) {
+    super(view);
+  }
+
+  @Override
+  protected void setResource(@Nullable T resource) {
+    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+    Drawable result = getDrawable(resource);
+    if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {
+      result = new FixedSizeDrawable(result, layoutParams.width, layoutParams.height);
+    }
+
+    view.setImageDrawable(result);
+  }
+
+  protected abstract Drawable getDrawable(T resource);
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 12f3bba81..0dd3d4f2e 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,19 +1,15 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.graphics.Point;
+import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.Log;
-import android.view.Display;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
@@ -33,13 +29,15 @@
  * View#setTag(Object)} on a view, consider using {@link BaseTarget} or {@link SimpleTarget}
  * instead. </p>
  *
+ * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>
+ *
  * @param <T> The specific subclass of view wrapped by this target.
  * @param <Z> The resource type this target will receive.
  */
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
   private static boolean isTagUsedAtLeastOnce = false;
-  private static Integer tagId = null;
+  @Nullable private static Integer tagId = null;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
@@ -70,13 +68,24 @@ public void getSize(SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
+  @Override
+  public void onLoadCleared(Drawable placeholder) {
+    super.onLoadCleared(placeholder);
+    sizeDeterminer.clearCallbacksAndListener();
+  }
+
   /**
    * Stores the request using {@link View#setTag(Object)}.
    *
    * @param request {@inheritDoc}
    */
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     setTag(request);
   }
 
@@ -92,6 +101,7 @@ public void setRequest(Request request) {
    * com.bumptech.glide.request.Request}. </p>
    */
   @Override
+  @Nullable
   public Request getRequest() {
     Object tag = getTag();
     Request request = null;
@@ -111,7 +121,7 @@ public String toString() {
     return "Target for: " + view;
   }
 
-  private void setTag(Object tag) {
+  private void setTag(@Nullable Object tag) {
     if (tagId == null) {
       isTagUsedAtLeastOnce = true;
       view.setTag(tag);
@@ -120,6 +130,7 @@ private void setTag(Object tag) {
     }
   }
 
+  @Nullable
   private Object getTag() {
     if (tagId == null) {
       return view.getTag();
@@ -155,15 +166,14 @@ public static void setTagId(int tagId) {
   }
 
   private static class SizeDeterminer {
-    // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
 
-    private SizeDeterminerLayoutListener layoutListener;
-    private Point displayDimens;
+    @Nullable private SizeDeterminerLayoutListener layoutListener;
 
-    public SizeDeterminer(View view) {
+    SizeDeterminer(View view) {
       this.view = view;
     }
 
@@ -171,21 +181,49 @@ private void notifyCbs(int width, int height) {
       for (SizeReadyCallback cb : cbs) {
         cb.onSizeReady(width, height);
       }
-      cbs.clear();
     }
 
-    private void checkCurrentDimens() {
+    @Synthetic
+    void checkCurrentDimens() {
       if (cbs.isEmpty()) {
         return;
       }
 
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
         return;
       }
 
       notifyCbs(currentWidth, currentHeight);
+      clearCallbacksAndListener();
+    }
+
+    void getSize(SizeReadyCallback cb) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
+      }
+    }
+
+    void removeCallback(SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
+    void clearCallbacksAndListener() {
       // Keep a reference to the layout listener and remove it here
       // rather than having the observer remove itself because the observer
       // we add the listener to will be almost immediately merged into
@@ -197,86 +235,70 @@ private void checkCurrentDimens() {
         observer.removeOnPreDrawListener(layoutListener);
       }
       layoutListener = null;
+      cbs.clear();
     }
 
-    public void getSize(SizeReadyCallback cb) {
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
-        cb.onSizeReady(currentWidth, currentHeight);
-      } else {
-        // We want to notify callbacks in the order they were added and we only expect one or two
-        // callbacks to
-        // be added a time, so a List is a reasonable choice.
-        if (!cbs.contains(cb)) {
-          cbs.add(cb);
-        }
-        if (layoutListener == null) {
-          final ViewTreeObserver observer = view.getViewTreeObserver();
-          layoutListener = new SizeDeterminerLayoutListener(this);
-          observer.addOnPreDrawListener(layoutListener);
-        }
-      }
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isViewStateValid() && isSizeValid(width) && isSizeValid(height);
     }
 
-    private int getViewHeightOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getHeight())) {
-        return view.getHeight();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.height, true /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
+    private boolean isViewStateValid() {
+      // We consider the view state as valid if the view has
+      // non-null layout params and a non-zero layout width and height.
+      if (view.getLayoutParams() != null
+          && view.getLayoutParams().width > 0
+          && view.getLayoutParams().height > 0) {
+        return true;
       }
-    }
 
-    private int getViewWidthOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getWidth())) {
-        return view.getWidth();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.width, false /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+        return view.isLaidOut();
       }
+      return !view.isLayoutRequested();
     }
 
-    private int getSizeForParam(int param, boolean isHeight) {
-      if (param == LayoutParams.WRAP_CONTENT) {
-        Point displayDimens = getDisplayDimens();
-        return isHeight ? displayDimens.y : displayDimens.x;
-      } else {
-        return param;
-      }
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
+    }
+
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    @SuppressWarnings("deprecation")
-    private Point getDisplayDimens() {
-      if (displayDimens != null) {
-        return displayDimens;
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      int adjustedViewSize = viewSize - paddingSize;
+      if (isSizeValid(adjustedViewSize)) {
+        return adjustedViewSize;
       }
-      WindowManager windowManager =
-          (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-      Display display = windowManager.getDefaultDisplay();
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-        displayDimens = new Point();
-        display.getSize(displayDimens);
+
+      if (paramSize == PENDING_SIZE) {
+        return PENDING_SIZE;
+      }
+
+      if (paramSize == LayoutParams.WRAP_CONTENT) {
+        return SIZE_ORIGINAL;
+      } else if (paramSize > 0) {
+        return paramSize - paddingSize;
       } else {
-        displayDimens = new Point(display.getWidth(), display.getHeight());
+        return PENDING_SIZE;
       }
-      return displayDimens;
     }
 
     private boolean isSizeValid(int size) {
-      return size > 0 || size == LayoutParams.WRAP_CONTENT;
+      return size > 0 || size == SIZE_ORIGINAL;
     }
 
     private static class SizeDeterminerLayoutListener implements ViewTreeObserver
         .OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
new file mode 100644
index 000000000..012d2009b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
+ * Most commonly used with {@link DrawableCrossFadeFactory}.
+ *
+ * @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
+ *            be transitioned.
+ */
+public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
+  private final TransitionFactory<Drawable> realFactory;
+
+  public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
+    this.realFactory = realFactory;
+  }
+
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    Transition<Drawable> transition = realFactory.build(dataSource, isFirstResource);
+    return new BitmapGlideAnimation(transition);
+  }
+
+  /**
+   * Retrieve the Bitmap from a composite object.
+   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap
+   * via expensive drawing here, this method is called on the UI thread.</p>
+   *
+   * @param current composite object containing a Bitmap and some other information
+   * @return the Bitmap contained within {@code current}
+   */
+  protected abstract Bitmap getBitmap(R current);
+
+  private class BitmapGlideAnimation implements Transition<R> {
+    private final Transition<Drawable> transition;
+
+    public BitmapGlideAnimation(Transition<Drawable> transition) {
+      this.transition = transition;
+    }
+
+    @Override
+    public boolean transition(R current, ViewAdapter adapter) {
+      Resources resources = adapter.getView().getResources();
+      Drawable currentBitmap = new BitmapDrawable(resources, getBitmap(current));
+      return transition.transition(currentBitmap, adapter);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
new file mode 100644
index 000000000..a6982b5d5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+
+/**
+ * A {@link TransitionFactory} for {@link android.graphics.Bitmap}s that uses a Drawable transition
+ * factory to transition from an existing drawable already visible on the target to the new bitmap.
+ *
+ * @see BitmapContainerTransitionFactory
+ */
+public class BitmapTransitionFactory extends BitmapContainerTransitionFactory<Bitmap> {
+  public BitmapTransitionFactory(@NonNull TransitionFactory<Drawable> realFactory) {
+    super(realFactory);
+  }
+
+  @Override
+  @NonNull
+  protected Bitmap getBitmap(@NonNull Bitmap current) {
+    return current;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index db90cf3f5..f81f5c3d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -4,6 +4,7 @@
 import android.graphics.drawable.Drawable;
 import android.view.animation.AlphaAnimation;
 import android.view.animation.Animation;
+import com.bumptech.glide.load.DataSource;
 
 /**
  * A factory class that produces a new {@link Transition} that varies depending on whether or not
@@ -13,81 +14,146 @@
  * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
- * the memory cache this factory produces an {@link NoTransition}. </p>
+ * the memory cache this factory produces an {@link NoTransition}.
  */
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private static final int DEFAULT_DURATION_MS = 300;
   private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
   private DrawableCrossFadeTransition firstResourceTransition;
   private DrawableCrossFadeTransition secondResourceTransition;
 
-  public DrawableCrossFadeFactory() {
-    this(DEFAULT_DURATION_MS);
-  }
-
-  public DrawableCrossFadeFactory(int duration) {
-    this(new ViewAnimationFactory<Drawable>(
-        new DefaultViewTransitionAnimationFactory(duration)), duration);
-  }
-
-  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
-  }
-
-  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
-  }
-
-  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
+  protected DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory,
+      int duration, boolean isCrossFadeEnabled) {
     this.viewAnimationFactory = viewAnimationFactory;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
-  public Transition<Drawable> build(boolean isFromMemoryCache, boolean isFirstResource) {
-    if (isFromMemoryCache) {
+  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE) {
       return NoTransition.get();
     } else if (isFirstResource) {
-      return getFirstResourceTransition();
+      return getFirstResourceTransition(dataSource);
     } else {
-      return getSecondResourceTransition();
+      return getSecondResourceTransition(dataSource);
     }
   }
 
-
-  private Transition<Drawable> getFirstResourceTransition() {
+  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
       if (firstResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);
-          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        firstResourceTransition = buildTransition(dataSource, true /*isFirstResource*/);
       }
       return firstResourceTransition;
   }
 
-  private Transition<Drawable> getSecondResourceTransition() {
+  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
       if (secondResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);
-          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        secondResourceTransition = buildTransition(dataSource, false /*isFirstResource*/);
       }
       return secondResourceTransition;
   }
 
-  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private DrawableCrossFadeTransition buildTransition(DataSource dataSource,
+      boolean isFirstResource) {
+    Transition<Drawable> defaultAnimation =
+        viewAnimationFactory.build(dataSource, isFirstResource);
+    return new DrawableCrossFadeTransition(defaultAnimation, duration, isCrossFadeEnabled);
+  }
+
+  private static final class DefaultViewTransitionAnimationFactory implements
+      ViewTransition.ViewTransitionAnimationFactory {
 
-    private final int duration;
+    private final int durationMillis;
 
-    DefaultViewTransitionAnimationFactory(int duration) {
-      this.duration = duration;
+    DefaultViewTransitionAnimationFactory(int durationMillis) {
+      this.durationMillis = durationMillis;
     }
 
     @Override
     public Animation build(Context context) {
       AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(duration);
+      animation.setDuration(durationMillis);
       return animation;
     }
   }
+
+  /**
+   * A Builder for {@link DrawableCrossFadeFactory}.
+   */
+  public static class Builder {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private int durationMillis;
+    private ViewAnimationFactory<Drawable> factory;
+    private boolean isCrossFadeEnabled;
+
+    public Builder() {
+      this(DEFAULT_DURATION_MS);
+    }
+
+    /**
+     * @param durationMillis The duration of both the default animation when no previous Drawable
+     *     is present and the cross fade animation when a previous Drawable is present. This value
+     *     will not be used by the default animation if {@link #setDefaultAnimationId(int)},
+     *     {@link #setDefaultAnimation(Animation)}, or
+     *     {@link #setDefaultAnimationFactory(ViewAnimationFactory)} is called.
+     */
+    public Builder(int durationMillis) {
+      this.durationMillis = durationMillis;
+      factory = new ViewAnimationFactory<>(
+          new DefaultViewTransitionAnimationFactory(durationMillis));
+    }
+
+    /**
+     * Enables or disables animating the alpha of the {@link Drawable} the cross fade will animate
+     * from.
+     *
+     * <p>Defaults to {@code false}.
+     *
+     * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
+     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
+     *     alpha will remain at 100 throughout the animation. See
+     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     */
+    public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
+      this.isCrossFadeEnabled = isCrossFadeEnabled;
+      return this;
+    }
+
+    /**
+     * Sets the resource id of the {@link Animation} to use when no previous {@link Drawable} is
+     * available to animate from.
+     *
+     * <p>Defaults to a simple fade in.
+     */
+    public Builder setDefaultAnimationId(int animationId) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animationId));
+    }
+
+    /**
+     * Sets the {@link Animation} to use when no previous {@link Drawable} is available to animate
+     * from.
+     *
+     * <p>It is not safe to use the same {@link Animation} object for multiple animations
+     * simultaneously. Always pass in a new instance to this method.
+     */
+    public Builder setDefaultAnimation(Animation animation) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animation));
+    }
+
+    /**
+     * Sets the {@link ViewAnimationFactory} to use to generate animations to animate when no
+     * previous {@link Drawable} is available to animate from.
+     */
+    public Builder setDefaultAnimationFactory(ViewAnimationFactory<Drawable> factory) {
+      this.factory = factory;
+      return this;
+    }
+
+    public DrawableCrossFadeFactory build() {
+      return new DrawableCrossFadeFactory(factory, durationMillis, isCrossFadeEnabled);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 2cbca19c7..ee1ff46e2 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -13,17 +13,28 @@
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
   private final Transition<Drawable> defaultAnimation;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
 
   /**
    * Constructor that takes a default animation and a duration in milliseconds that the cross fade
    * animation should last.
    *
+   * @param defaultAnimation The {@link Transition} to use if there is no previous
+   *                         {@link Drawable} (either a placeholder or previous resource) to
+   *                         transition from.
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
+   *                         animating the new resource's alpha to 100. Otherwise, only animates
+   *                         the new resource's alpha to 100 while leaving the previous resource's
+   *                         alpha at 100. See
+   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
+  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration,
+      boolean isCrossFadeEnabled) {
     this.defaultAnimation = defaultAnimation;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   /**
@@ -43,7 +54,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
     if (previous != null) {
       TransitionDrawable transitionDrawable =
           new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(true);
+      transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
       transitionDrawable.startTransition(duration);
       adapter.setDrawable(transitionDrawable);
       return true;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 9fe88fca1..d5a1c1e33 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.request.transition;
 
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * A simple {@link Transition} that performs no actions.
  *
@@ -7,17 +10,20 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  private static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
   /**
    * A factory that always returns the same {@link NoTransition}.
+   *
+   * @param <R> the resource type that will be transitioned into a
+   * {@link com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
     @Override
-    public Transition<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
+    public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
       return (Transition<R>) NO_ANIMATION;
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
index c1384efc8..50debd7b9 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.transition;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 /**
@@ -30,6 +31,7 @@
      * Returns the current drawable being displayed in the view, or null if no such drawable exists
      * (or one cannot be retrieved).
      */
+    @Nullable
     Drawable getCurrentDrawable();
 
     /**
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
index 898793f86..727b508a7 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.transition;
 
+import com.bumptech.glide.load.DataSource;
+
 /**
  * A factory class that can produce different {@link Transition}s based on the state of the
  * request.
@@ -11,9 +13,9 @@
   /**
    * Returns a new {@link Transition}.
    *
-   * @param isFromMemoryCache True if this will be a transition for a resource that was loaded from
-   *                          the memory cache.
-   * @param isFirstResource   True if this is the first resource to be loaded into the target.
+   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded
+   *                        from.
+   * @param isFirstResource True if this is the first resource to be loaded into the target.
    */
-  Transition<R> build(boolean isFromMemoryCache, boolean isFirstResource);
+  Transition<R> build(DataSource dataSource, boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 29b2e8b1e..661c27715 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
+import com.bumptech.glide.load.DataSource;
 
 /**
  * A {@link TransitionFactory} that produces {@link ViewTransition}s.
@@ -31,12 +32,12 @@ public ViewAnimationFactory(int animationId) {
    * or isFirstImage is {@code false}, returns a {@link NoTransition} and otherwise returns a new
    * {@link ViewTransition}.
    *
-   * @param isFromMemoryCache {@inheritDoc}
+   * @param dataSource {@inheritDoc}
    * @param isFirstResource   {@inheritDoc}
    */
   @Override
-  public Transition<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-    if (isFromMemoryCache || !isFirstResource) {
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE || !isFirstResource) {
       return NoTransition.get();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java
index 0fc41c05c..ca8bdd548 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyAnimationFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.transition;
 
+import com.bumptech.glide.load.DataSource;
+
 /**
  * A {@link TransitionFactory} that produces ViewPropertyAnimations.
  *
@@ -20,8 +22,8 @@ public ViewPropertyAnimationFactory(ViewPropertyTransition.Animator animator) {
    * constructor.
    */
   @Override
-  public Transition<R> build(boolean isFromMemoryCache, boolean isFirstResource) {
-    if (isFromMemoryCache || !isFirstResource) {
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    if (dataSource == DataSource.MEMORY_CACHE || !isFirstResource) {
       return NoTransition.get();
     }
     if (animation == null) {
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 0764fe285..974dc0abd 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-
 import com.bumptech.glide.load.Key;
-
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -55,7 +53,7 @@ private static Key obtainVersionSignature(Context context) {
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new StringSignature(versionCode);
+    return new ObjectKey(versionCode);
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 56d4c474d..93f572c0f 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 37f15a62f..e14e1a573 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
-
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -32,6 +32,7 @@ public MediaStoreSignature(String mimeType, long dateModified, int orientation)
     this.orientation = orientation;
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -49,10 +50,9 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
+    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
       return false;
     }
-
     return true;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 0637bcada..50ccc9f3f 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -11,8 +10,8 @@
  * method to the {@link java.security.MessageDigest} in
  * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
  *
- * <p> The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
- * key. </p>
+ * <p>The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
+ * key.</p>
  */
 public final class ObjectKey implements Key {
   private final Object object;
diff --git a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java b/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
deleted file mode 100644
index 5492f2216..000000000
--- a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Preconditions;
-
-import java.security.MessageDigest;
-
-/**
- * A unique Signature that wraps a String.
- *
- * TODO: remove this and replace with ObjectKey.
- */
-public class StringSignature implements Key {
-  private final String signature;
-
-  public StringSignature(String signature) {
-    this.signature = Preconditions.checkNotNull(signature);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-
-    StringSignature that = (StringSignature) o;
-
-    return signature.equals(that.signature);
-  }
-
-  @Override
-  public int hashCode() {
-    return signature.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "StringSignature{"
-        + "signature='" + signature + '\''
-        + '}';
-  }
-
-  @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    messageDigest.update(signature.getBytes(CHARSET));
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 72204c4b4..788901575 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -112,6 +113,27 @@ public static InputStream toStream(ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
+  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+    ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
+
+    byte[] buffer = BUFFER_REF.getAndSet(null);
+    if (buffer == null) {
+      buffer = new byte[BUFFER_SIZE];
+    }
+
+    int n = -1;
+    while ((n = stream.read(buffer)) >= 0) {
+      outStream.write(buffer, 0, n);
+    }
+
+    BUFFER_REF.set(buffer);
+
+    byte[] bytes = outStream.toByteArray();
+
+    // Some resource decoders require a direct byte buffer. Prefer allocateDirect() over wrap()
+    return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
+  }
+
   private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
@@ -120,9 +142,9 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
   }
 
   static final class SafeArray {
-    private final int offset;
-    private final int limit;
-    private final byte[] data;
+    @Synthetic final int offset;
+    @Synthetic final int limit;
+    @Synthetic final byte[] data;
 
     public SafeArray(byte[] data, int offset, int limit) {
       this.data = data;
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index eac7dfec4..0f4803ace 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -2,7 +2,6 @@
 
 import android.text.TextUtils;
 import android.util.Log;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -52,7 +51,9 @@ public synchronized int available() throws IOException {
 
   @Override
   public synchronized int read() throws IOException {
-    return checkReadSoFarOrThrow(super.read());
+    int value = super.read();
+    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);
+    return value;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index c0b9a8940..b6c9e40d4 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import com.bumptech.glide.ListPreloader;
-
 import java.util.Arrays;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 383024d2a..0d47fd7d7 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.Nullable;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -93,6 +94,7 @@ public synchronized boolean contains(T key) {
    *
    * @param key The key to check.
    */
+  @Nullable
   public synchronized Y get(T key) {
     return cache.get(key);
   }
@@ -133,6 +135,7 @@ public synchronized Y put(T key, Y item) {
    *
    * @param key The key to remove the item at.
    */
+  @Nullable
   public synchronized Y remove(T key) {
     final Y value = cache.remove(key);
     if (value != null) {
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index de27683b6..18fd5e04e 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -3,6 +3,7 @@
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
+@SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
   private Class<?> second;
@@ -35,6 +36,7 @@ public String toString() {
     return "MultiClassKey{" + "first=" + first + ", second=" + second + '}';
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -52,10 +54,7 @@ public boolean equals(Object o) {
     if (!second.equals(that.second)) {
       return false;
     }
-    if (third == null && that.third != null) {
-      return false;
-    }
-    if (third != null && !third.equals(that.third)) {
+    if (!Util.bothNullOrEqual(third, that.third)) {
       return false;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 8356ab943..121ead84c 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import android.text.TextUtils;
-
 import java.util.Collection;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/util/Synthetic.java b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
new file mode 100644
index 000000000..0d1140b04
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.util;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that target's visibility can be relaxed to avoid synthetic methods.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
+public @interface Synthetic {
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 36cafde3a..ea66b1126 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,9 +4,7 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
-
 import com.bumptech.glide.request.target.Target;
-
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -37,6 +35,7 @@ public static String sha256BytesToHex(byte[] bytes) {
   // Taken from:
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
+  @SuppressWarnings("PMD.UseVarargs")
   private static String bytesToHex(byte[] bytes, char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
@@ -91,7 +90,7 @@ public static int getBitmapByteSize(int width, int height, Bitmap.Config config)
   }
 
   private static int getBytesPerPixel(Bitmap.Config config) {
-    // A bitmap by decoding a gif has null "config" in certain environments.
+    // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
     }
@@ -108,6 +107,7 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
+        break;
     }
     return bytesPerPixel;
   }
@@ -138,7 +138,7 @@ public static void assertMainThread() {
    */
   public static void assertBackgroundThread() {
     if (!isOnBackgroundThread()) {
-      throw new IllegalArgumentException("YOu must call this method on a background thread");
+      throw new IllegalArgumentException("You must call this method on a background thread");
     }
   }
 
@@ -150,7 +150,7 @@ public static boolean isOnMainThread() {
   }
 
   /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   * Returns {@code true} if called on a background thread, {@code false} otherwise.
    */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
@@ -170,12 +170,21 @@ public static boolean isOnBackgroundThread() {
    * <p> See #303 and #375. </p>
    */
   public static <T> List<T> getSnapshot(Collection<T> other) {
-      // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-      // be null. See #322.
-      List<T> result = new ArrayList<T>(other.size());
-      for (T item : other) {
-          result.add(item);
-      }
-      return result;
+    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
+    // be null. See #322.
+    List<T> result = new ArrayList<T>(other.size());
+    for (T item : other) {
+      result.add(item);
+    }
+    return result;
+  }
+
+  /**
+   * Null-safe equivalent of {@code a.equals(b)}.
+   *
+   * @see java.util.Objects#equals
+   */
+  public static boolean bothNullOrEqual(Object a, Object b) {
+    return a == null ? b == null : a.equals(b);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5677b391d..5f341a5b4 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.util;
 
 import android.view.View;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
-
 import java.util.Arrays;
 
 /**
@@ -40,7 +38,7 @@ public ViewPreloadSizeProvider() {
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
   public ViewPreloadSizeProvider(View view) {
-    setView(view);
+    this.viewTarget = new SizeViewTarget(view, this);
   }
 
   @Override
@@ -75,14 +73,13 @@ public void setView(View view) {
   }
 
   private static final class SizeViewTarget extends ViewTarget<View, Object> {
-
     public SizeViewTarget(View view, SizeReadyCallback callback) {
       super(view);
       getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition transition) {
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
       // Do nothing
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
new file mode 100644
index 000000000..23416d80d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -0,0 +1,166 @@
+package com.bumptech.glide.util.pool;
+
+import android.support.v4.util.Pools.Pool;
+import android.support.v4.util.Pools.SimplePool;
+import android.support.v4.util.Pools.SynchronizedPool;
+import android.util.Log;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provides implementations of {@link Pool} never return {@code null}, log when new instances are
+ * created, and that can use the {@link com.bumptech.glide.util.pool.FactoryPools.Poolable}
+ * interface to ensure objects aren't used while inside the pool.
+ */
+public final class FactoryPools {
+  private static final String TAG = "FactoryPools";
+  private static final int DEFAULT_POOL_SIZE = 20;
+  private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
+    @Override
+    public void reset(Object object) {
+      // Do nothing.
+    }
+  };
+
+  private FactoryPools() { }
+
+  /**
+   * Returns a non-thread safe {@link Pool} that never returns {@code null} from
+   * {@link Pool#acquire()} and that contains objects of the type created by the given
+   * {@link Factory} with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
+   * be used to create a new instance.
+   *
+   * @param <T> The type of object the pool will contains.
+   */
+  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+    return build(new SimplePool<T>(size), factory);
+  }
+
+  /**
+   * Returns a new thread safe {@link Pool} that never returns {@code null} from
+   * {@link Pool#acquire()} and that contains objects of the type created by the given
+   * {@link Factory} with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
+   * be used to create a new instance.
+   *
+   * @param <T> The type of object the pool will contains.
+   */
+  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+    return build(new SynchronizedPool<T>(size), factory);
+  }
+
+  /**
+   * Returns a new {@link Pool} that never returns {@code null} and that contains {@link List Lists}
+   * of a specific generic type with a standard maximum size of 20.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
+   * created.
+   *
+   * @param <T> The type of object that the {@link List Lists} will contain.
+   */
+  public static <T> Pool<List<T>> threadSafeList() {
+    return threadSafeList(DEFAULT_POOL_SIZE);
+  }
+
+  /**
+   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains
+   * {@link List Lists} of a specific generic type with the given maximum size.
+   *
+   * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
+   * created.
+   *
+   * @param <T> The type of object that the {@link List Lists} will contain.
+   */
+  public static <T> Pool<List<T>> threadSafeList(int size) {
+    return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
+      @Override
+      public List<T> create() {
+        return new ArrayList<>();
+      }
+    }, new Resetter<List<T>>() {
+      @Override
+      public void reset(List<T> object) {
+        object.clear();
+      }
+    });
+  }
+
+  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+    return build(pool, factory, FactoryPools.<T>emptyResetter());
+  }
+
+  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
+      Resetter<T> resetter) {
+    return new FactoryPool<>(pool, factory, resetter);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Resetter<T> emptyResetter() {
+    return (Resetter<T>) EMPTY_RESETTER;
+  }
+
+  /**
+   * Creates new instances of the given type.
+   *
+   * @param <T> The type of Object that will be created.
+   */
+  public interface Factory<T> {
+    T create();
+  }
+
+  /**
+   * Resets state when objects are returned to the pool.
+   *
+   * @param <T> The type of Object that will be reset.
+   */
+  public interface Resetter<T> {
+    void reset(T object);
+  }
+
+  /**
+   * Allows additional verification to catch errors caused by using objects while they are in
+   * an object pool.
+   */
+  public interface Poolable {
+    StateVerifier getVerifier();
+  }
+
+  private static final class FactoryPool<T> implements Pool<T> {
+    private final Factory<T> factory;
+    private final Resetter<T> resetter;
+    private final Pool<T> pool;
+
+    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+      this.pool = pool;
+      this.factory = factory;
+      this.resetter = resetter;
+    }
+
+    @Override
+    public T acquire() {
+      T result = pool.acquire();
+      if (result == null) {
+        result = factory.create();
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Created new " + result.getClass());
+        }
+      }
+      if (result instanceof Poolable) {
+        ((Poolable) result).getVerifier().setRecycled(false /*isRecycled*/);
+      }
+      return result;
+    }
+
+    @Override
+    public boolean release(T instance) {
+      if (instance instanceof Poolable) {
+        ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
+      }
+      resetter.reset(instance);
+      return pool.release(instance);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
new file mode 100644
index 000000000..7e6577dd3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -0,0 +1,77 @@
+package com.bumptech.glide.util.pool;
+
+import com.bumptech.glide.util.Synthetic;
+
+/**
+ * Verifies that the job is not in the recycled state.
+ */
+public abstract class StateVerifier {
+  private static final boolean DEBUG = false;
+
+  /**
+   * Creates a new {@link StateVerifier} instance.
+   */
+  public static StateVerifier newInstance() {
+    if (DEBUG) {
+      return new DebugStateVerifier();
+    } else {
+      return new DefaultStateVerifier();
+    }
+  }
+
+  private StateVerifier() { }
+
+  /**
+   * Throws an exception if we believe our object is recycled and inactive (i.e. is currently in an
+   * object pool).
+   */
+  public abstract void throwIfRecycled();
+
+  /**
+   * Sets whether or not our object is recycled.
+   */
+  abstract void setRecycled(boolean isRecycled);
+
+  private static class DefaultStateVerifier extends StateVerifier {
+    private volatile boolean isReleased;
+
+    @Synthetic
+    DefaultStateVerifier() { }
+
+    @Override
+    public void throwIfRecycled() {
+      if (isReleased) {
+        throw new IllegalStateException("Already released");
+      }
+    }
+
+    @Override
+    public void setRecycled(boolean isRecycled) {
+      this.isReleased = isRecycled;
+    }
+  }
+
+  private static class DebugStateVerifier extends StateVerifier {
+    // Keeps track of the stack trace where our state was set to recycled.
+    private volatile RuntimeException recycledAtStackTraceException;
+
+    @Synthetic
+    DebugStateVerifier() { }
+
+    @Override
+    public void throwIfRecycled() {
+      if (recycledAtStackTraceException != null) {
+        throw new IllegalStateException("Already released", recycledAtStackTraceException);
+      }
+    }
+
+    @Override
+    void setRecycled(boolean isRecycled) {
+      if (isRecycled) {
+        this.recycledAtStackTraceException = new RuntimeException("Released");
+      } else {
+        this.recycledAtStackTraceException = null;
+      }
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index c62e3d09d..c07352377 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Matchers.anyInt;
@@ -29,14 +30,16 @@
 import android.os.ParcelFileDescriptor;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
@@ -53,7 +56,15 @@
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -67,20 +78,10 @@
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.internal.ShadowExtractor;
 import org.robolectric.res.builder.RobolectricPackageManager;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.util.HashMap;
-import java.util.Map;
-
 /**
  * Tests for the {@link Glide} interface and singleton.
  */
@@ -89,7 +90,9 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
+@SuppressWarnings({"unchecked", "deprecation"})
 public class GlideTest {
+  @SuppressWarnings("rawtypes")
   private Target target = null;
   private ImageView imageView;
   private RequestManager requestManager;
@@ -98,8 +101,7 @@
   public void setUp() throws Exception {
     Glide.tearDown();
 
-    RobolectricPackageManager pm =
-        (RobolectricPackageManager) RuntimeEnvironment.application.getPackageManager();
+    RobolectricPackageManager pm = RuntimeEnvironment.getRobolectricPackageManager();
     ApplicationInfo info =
         pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
     info.metaData = new Bundle();
@@ -109,6 +111,7 @@ public void setUp() throws Exception {
     target = mock(Target.class);
     imageView = new ImageView(RuntimeEnvironment.application);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
     Handler bgHandler = mock(Handler.class);
@@ -123,7 +126,7 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
 
     Lifecycle lifecycle = mock(Lifecycle.class);
     RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
     requestManager.resumeRequests();
   }
 
@@ -139,8 +142,8 @@ public void testCanSetMemoryCategory() {
 
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder(getContext()).setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .createGlide();
+        new GlideBuilder().setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
+            .build(getContext());
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -153,8 +156,8 @@ public void testClearMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     glide.clearMemory();
 
@@ -168,8 +171,8 @@ public void testTrimMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     final int level = 123;
 
@@ -200,8 +203,8 @@ private void runTestFileDefaultLoader() {
     File file = new File("fake");
     mockUri(Uri.fromFile(file));
 
-    requestManager.asDrawable().load(file).into(target);
-    requestManager.asDrawable().load(file).into(imageView);
+    requestManager.load(file).into(target);
+    requestManager.load(file).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -213,8 +216,8 @@ private void runTestFileDefaultLoader() {
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
 
-    requestManager.asDrawable().load(url).into(target);
-    requestManager.asDrawable().load(url).into(imageView);
+    requestManager.load(url).into(target);
+    requestManager.load(url).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -263,8 +266,8 @@ private void runTestUriDefaultLoader() {
     Uri uri = Uri.parse("content://test/something");
     mockUri(uri);
 
-    requestManager.asDrawable().load(uri).into(target);
-    requestManager.asDrawable().load(uri).into(imageView);
+    requestManager.load(uri).into(target);
+    requestManager.load(uri).into(imageView);
 
     verify(target).onResourceReady(notNull(), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -324,20 +327,20 @@ private void runTestUriStringDefaultLoader() {
   }
 
   private void runTestStringDefaultLoader(String string) {
-    requestManager.asDrawable().load(string).listener(new RequestListener<Drawable>() {
+    requestManager.load(string).listener(new RequestListener<Drawable>() {
       @Override
-      public boolean onLoadFailed(Object model, Target target,
+      public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
           boolean isFirstResource) {
         throw new RuntimeException("Load failed");
       }
 
       @Override
-      public boolean onResourceReady(Drawable resource, Object model, Target target,
-          boolean isFromMemoryCache, boolean isFirstResource) {
+      public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
+          DataSource dataSource, boolean isFirstResource) {
         return false;
       }
     }).into(target);
-    requestManager.asDrawable().load(string).into(imageView);
+    requestManager.load(string).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -366,8 +369,8 @@ private void runTestIntegerDefaultLoader() {
     int integer = android.R.drawable.star_on;
     mockUri("android.resource://" + "android" + "/drawable/star_on");
 
-    requestManager.asDrawable().load(integer).into(target);
-    requestManager.asDrawable().load(integer).into(imageView);
+    requestManager.load(integer).into(target);
+    requestManager.load(integer).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -378,8 +381,8 @@ private void runTestIntegerDefaultLoader() {
   @Test
   public void testByteArrayDefaultLoader() {
     byte[] bytes = new byte[10];
-    requestManager.asDrawable().load(bytes).into(target);
-    requestManager.asDrawable().load(bytes).into(imageView);
+    requestManager.load(bytes).into(target);
+    requestManager.load(bytes).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
     verify(target).setRequest((Request) notNull());
@@ -391,7 +394,7 @@ public void testByteArrayDefaultLoader() {
   @Test(expected = Exception.class)
   public void testUnregisteredModelThrowsException() {
     Float unregistered = 0.5f;
-    requestManager.asDrawable().load(unregistered).into(target);
+    requestManager.load(unregistered).into(target);
   }
 
   @Test
@@ -399,7 +402,7 @@ public void testUnregisteredModelThrowsException() {
   public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
     registerMockStreamModelLoader(Float.class);
 
-    requestManager.asDrawable().load(0.5f).into(target);
+    requestManager.load(0.5f).into(target);
   }
 
   @Test
@@ -438,7 +441,9 @@ public void testReceivesBitmapBytes() {
   public void testReceivesThumbnails() {
     String full = mockUri("content://full");
     String thumb = mockUri("content://thumb");
-    requestManager.asDrawable().load(full).thumbnail(requestManager.asDrawable().load(thumb))
+    requestManager
+        .load(full)
+        .thumbnail(requestManager.load(thumb))
         .into(target);
 
     verify(target, times(2)).onResourceReady(isA(Drawable.class), isA(Transition.class));
@@ -446,74 +451,91 @@ public void testReceivesThumbnails() {
 
   @Test
   public void testReceivesRecursiveThumbnails() {
-    requestManager.asDrawable().load(mockUri("content://first")).thumbnail(
-        requestManager.asDrawable().load(mockUri("content://second")).thumbnail(
-            requestManager.asDrawable().load(mockUri("content://third"))
-                .thumbnail(requestManager.asDrawable().load(mockUri("content://fourth")))))
+    requestManager.load(mockUri("content://first")).thumbnail(
+        requestManager.load(mockUri("content://second")).thumbnail(
+            requestManager.load(mockUri("content://third")).thumbnail(
+                requestManager.load(mockUri("content://fourth")))))
         .into(target);
     verify(target, times(4)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testReceivesRecursiveThumbnailWithPercentage() {
-    requestManager.asDrawable().load(mockUri("content://first"))
-        .thumbnail(requestManager.asDrawable().load(mockUri("content://second")).thumbnail(0.5f))
+    requestManager.load(mockUri("content://first"))
+        .thumbnail(requestManager.load(mockUri("content://second")).thumbnail(0.5f))
         .into(target);
     verify(target, times(3)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.asDrawable().load((Double) null).into(target);
+    requestManager.load(null).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.asDrawable().load((Float) null).into(target);
+    requestManager.load(null).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.asDrawable().load((Double) null).into(target);
+    requestManager.load(null).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
-    String nullString = null;
-
     Drawable drawable = new ColorDrawable(Color.RED);
-    requestManager.asDrawable().load(nullString).apply(placeholderOf(drawable)).into(target);
+    requestManager
+        .load(null)
+        .apply(errorOf(drawable))
+        .into(target);
 
     verify(target).onLoadFailed(eq(drawable));
   }
 
   @Test
   public void testNullModelPrefersErrorDrawable() {
-    String nullString = null;
-
     Drawable placeholder = new ColorDrawable(Color.GREEN);
     Drawable error = new ColorDrawable(Color.RED);
 
-    requestManager.asDrawable().load(nullString).apply(placeholderOf(placeholder).error(error))
+    requestManager
+        .load(null)
+        .apply(placeholderOf(placeholder)
+            .error(error))
         .into(target);
 
     verify(target).onLoadFailed(eq(error));
   }
 
+  @Test
+  public void testNullModelPrefersFallbackDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.GREEN);
+    Drawable error = new ColorDrawable(Color.RED);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    requestManager
+        .load(null)
+        .apply(placeholderOf(placeholder)
+            .error(error)
+            .fallback(fallback))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(fallback));
+  }
+
   @Test
   public void testByteData() {
     byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
-    requestManager.asDrawable().load(data).into(target);
+    requestManager.load(data).into(target);
   }
 
   @Test
   public void testClone() throws IOException {
-    Target firstTarget = mock(Target.class);
+    Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
-    Target secondTarget = mock(Target.class);
+    Target<Drawable> secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
-    RequestBuilder<Drawable> firstRequest = Glide.with(getContext())
-        .asDrawable()
+    RequestBuilder<Drawable> firstRequest = requestManager
         .load(mockUri("content://first"));
 
     firstRequest.into(firstTarget);
@@ -522,15 +544,15 @@ public void testClone() throws IOException {
         .apply(placeholderOf(new ColorDrawable(Color.RED)))
         .into(secondTarget);
 
-    verify(firstTarget).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
-    verify(secondTarget).onResourceReady(notNull(), isA(Transition.class));
+    verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
+    verify(secondTarget).onResourceReady(notNull(Drawable.class), isA(Transition.class));
   }
 
   @SuppressWarnings("unchecked")
   private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
       throws Exception {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
-    doAnswer(new Util.CallDataReady(null))
+    doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
         .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     when(failFetcher.getDataClass()).thenReturn(failResource);
@@ -539,8 +561,7 @@ public void testClone() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
     when(failLoader.handles(isA(failModel))).thenReturn(true);
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(failLoader);
+    when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
     Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
   }
@@ -559,7 +580,7 @@ private String mockUri(Uri uri, InputStream is) {
     }
     ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
     ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) ShadowExtractor.extract(contentResolver);
+        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -578,8 +599,7 @@ private Context getContext() {
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(modelLoader);
+    when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
     Glide.get(RuntimeEnvironment.application).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
@@ -590,7 +610,7 @@ private Context getContext() {
     ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
     DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
     try {
-      doAnswer(new Util.CallDataReady(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0]))).when(fetcher)
           .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     } catch (Exception e) {
       // Do nothing.
@@ -633,15 +653,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     @Override
     public void applyOptions(Context context, GlideBuilder builder) {
       // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = mock(GlideExecutor.class);
-      doAnswer(new Answer<Void>() {
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-          Runnable runnable = (Runnable) invocation.getArguments()[0];
-          runnable.run();
-          return null;
-        }
-      }).when(executor).execute(isA(Runnable.class));
+      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
 
       DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
       when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
@@ -678,7 +690,7 @@ public void registerComponents(Context context, Registry registry) {
           .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
       when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
       ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
           .thenReturn(mockUrlLoader);
 
       registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
@@ -690,6 +702,7 @@ public void registerComponents(Context context, Registry registry) {
   // a different part of the test. Each one ends up with different registered uris, which causes
   // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue.
   @Implements(value = ContentResolver.class)
+  @SuppressWarnings("unused")
   public static class ShadowFileDescriptorContentResolver {
     private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR = new HashMap<>();
     private static final Map<Uri, InputStream> URI_TO_INPUT_STREAMS = new HashMap<>();
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index 34d04e635..f1b8b51e8 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.cast;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -7,11 +8,15 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.graphics.Bitmap;
-
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
-
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,19 +27,11 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ListPreloaderTest {
 
-  @Mock private RequestBuilder<Bitmap> request;
+  @Mock private RequestBuilder<Object> request;
   @Mock private RequestManager requestManager;
 
   @Before
@@ -71,11 +68,10 @@ public void testGetItemsIsCalledInOrderIncreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-
-      public int expectedPosition;
+      private int expectedPosition;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -85,7 +81,8 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       }
 
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition++;
         return mock(RequestBuilder.class);
@@ -129,10 +126,10 @@ public void testGetItemsIsCalledInOrderDecreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = toPreload - 1;
+      private int expectedPosition = toPreload - 1;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
@@ -145,7 +142,8 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       }
 
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition--;
         return mock(RequestBuilder.class);
@@ -249,7 +247,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      public int expectedPosition = (1 + 10) * 2;
+      private int expectedPosition = (1 + 10) * 2;
 
       @Override
       public List<Object> getPreloadItems(int position) {
@@ -257,15 +255,15 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition++;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
       }
     };
@@ -275,7 +273,7 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
 
     preloader.onScroll(null, 1, 10, 1 + 10 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
@@ -285,7 +283,7 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = objects.size() * 2 - 1;
+      private int expectedPosition = objects.size() * 2 - 1;
 
       @Override
       public List<Object> getPreloadItems(int position) {
@@ -293,15 +291,15 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition--;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
       }
     };
@@ -312,16 +310,17 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     preloader.onScroll(null, 3, 2, 3 + 2);
     preloader.onScroll(null, 2, 2, 3 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
-  private List<Integer> getTagetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
+  private <R> List<Integer> getTargetsSizes(
+      RequestBuilder<R> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
+    ArgumentCaptor<Target<R>> targetArgumentCaptor = cast(ArgumentCaptor.forClass(Target.class));
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
     verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target target : targetArgumentCaptor.getAllValues()) {
+    for (Target<R> target : targetArgumentCaptor.getAllValues()) {
       target.getSize(cb);
     }
     verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
@@ -341,7 +340,7 @@ public void testItemsArePreloadedWithGlide() {
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         loadedObjects.add(item);
         return super.getPreloadRequestBuilder(item);
       }
@@ -367,12 +366,13 @@ public ListPreloaderAdapter() {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Object item) {
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
       return mock(RequestBuilder.class);
     }
 
     @Override
-    public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+    public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
       return new int[] { 100, 100 };
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index fcbf4b3a5..5be7653f0 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -8,12 +8,11 @@
 import static org.mockito.Mockito.when;
 
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.BackgroundUtil;
-
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,19 +28,27 @@
 public class RequestBuilderTest {
   @Mock GlideContext glideContext;
   @Mock RequestManager requestManager;
+  private Glide glide;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    glide = Glide.get(RuntimeEnvironment.application);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new RequestBuilder(null /*context*/, requestManager, Object.class);
+    new RequestBuilder<>(null /*context*/, requestManager, Object.class);
   }
 
   @Test(expected = NullPointerException.class)
-  public void testThrowsWhenGlideAnimationFactoryIsNull() {
+  public void testThrowsWhenTransitionsOptionsIsNull() {
+    //noinspection ConstantConditions testing if @NonNull is enforced
     getNullModelRequest().transition(null);
   }
 
@@ -52,7 +59,7 @@ public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
 
   @Test
   public void testAddsNewRequestToRequestTracker() {
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     getNullModelRequest().into(target);
 
     verify(requestManager).track(eq(target), isA(Request.class));
@@ -61,7 +68,7 @@ public void testAddsNewRequestToRequestTracker() {
   @Test
   public void testRemovesPreviousRequestFromRequestTracker() {
     Request previous = mock(Request.class);
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     when(target.getRequest()).thenReturn(previous);
 
     getNullModelRequest().into(target);
@@ -69,12 +76,13 @@ public void testRemovesPreviousRequestFromRequestTracker() {
     verify(requestManager).clear(eq(target));
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullTarget() {
-    getNullModelRequest().into((Target) null);
+    //noinspection ConstantConditions testing if @NonNull is enforced
+    getNullModelRequest().into((Target<Object>) null);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullView() {
     getNullModelRequest().into((ImageView) null);
   }
@@ -93,7 +101,7 @@ public void runTest() throws Exception {
 
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
-    final Target target = mock(Target.class);
+    final Target<Object> target = mock(Target.class);
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
       public void runTest() throws Exception {
@@ -102,11 +110,13 @@ public void runTest() throws Exception {
     });
   }
 
-  private RequestBuilder getNullModelRequest() {
+  private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
         .thenReturn(mock(Target.class));
-    when(glideContext.getOptions()).thenReturn(new RequestOptions());
-    return new RequestBuilder(glideContext, requestManager, Object.class)
+    when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
+    when(requestManager.getDefaultRequestOptions())
+        .thenReturn((RequestOptions) new RequestOptions());
+    return new RequestBuilder<>(glide, requestManager, Object.class)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0e171262f..68551d56d 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
-
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -20,7 +19,6 @@
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -57,8 +55,13 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
           }
         });
     requestTracker = mock(RequestTracker.class);
-    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
-        requestTracker, factory);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index a8a46640a..9a23a4680 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -1,30 +1,33 @@
 package com.bumptech.glide.load;
 
+import static com.bumptech.glide.tests.Util.anyContext;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
 public class MultiTransformationTest {
 
   @Mock Transformation<Object> first;
@@ -32,10 +35,13 @@
   @Mock Resource<Object> initial;
   @Mock Resource<Object> firstTransformed;
   @Mock Resource<Object> secondTransformed;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+
+    context = RuntimeEnvironment.application;
   }
 
   @Test
@@ -44,32 +50,34 @@ public void testAppliesTransformationsInOrder() {
     final int height = 768;
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), eq(initial), eq(width), eq(height)))
+        .thenReturn(firstTransformed);
 
-    when(second.transform(eq(firstTransformed), eq(width), eq(height)))
+    when(second.transform(anyContext(), eq(firstTransformed), eq(width), eq(height)))
         .thenReturn(secondTransformed);
 
-    assertEquals(secondTransformed, transformation.transform(initial, width, height));
+    assertEquals(secondTransformed, transformation.transform(context, initial, width, height));
   }
 
   @Test
   public void testInitialResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
-    MultiTransformation<Object> transformation = new MultiTransformation(first);
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(initial, 123, 456);
+    transformation.transform(context, initial, 123, 456);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1111, 2222);
+    transformation.transform(context, initial, 1111, 2222);
 
     verify(initial, never()).recycle();
   }
@@ -77,35 +85,38 @@ public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformati
   @Test
   public void
   testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt()))
-        .thenReturn(mock(Resource.class));
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(mockResource());
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1, 2);
+    transformation.transform(context, initial, 1, 2);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testFinalResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(mock(Resource.class), 111, 222);
+    transformation.transform(context, mockResource(), 111, 222);
 
     verify(firstTransformed, never()).recycle();
   }
 
   @Test
   public void testIntermediateResourcesAreRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(secondTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(secondTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
 
-    transformation.transform(mock(Resource.class), 233, 454);
+    transformation.transform(context, mockResource(), 233, 454);
 
     verify(firstTransformed).recycle();
   }
@@ -118,7 +129,7 @@ public void testEquals() throws NoSuchAlgorithmException {
 
     doAnswer(new Util.WriteDigest("second")).when(second)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(new MultiTransformation<>(first),
-        new MultiTransformation<>(second));
+    KeyAssertions.assertDifferent(
+        new MultiTransformation<>(first), new MultiTransformation<>(second));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
index 99d4d0adc..bac793e3b 100644
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load;
 
 import com.google.common.testing.EqualsTester;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -33,4 +32,4 @@ public void testEquals() {
         ).testEquals();
   }
 
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index d803e76c2..77c6a93f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -2,23 +2,22 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifOrientationStreamTest {
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
@@ -28,7 +27,7 @@ private InputStream openOrientationExample(boolean isLandscape, int item) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
@@ -37,14 +36,13 @@ public void testIncludesGivenExifOrientation() throws IOException {
       for (int j = 0; j < 8; j++) {
         InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
         InputStream wrapped = new ExifOrientationStream(toWrap, i);
-        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
 
         toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
         wrapped = new ExifOrientationStream(toWrap, i);
-        parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index 0b3c1f5c2..ae3982203 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -9,9 +9,8 @@
 import android.content.res.AssetFileDescriptor;
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,8 +19,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
@@ -70,4 +67,4 @@ public void testDoesNothingOnCancel() throws Exception {
     fetcher.cancel();
     verify(expected, never()).close();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 678b9460a..94fd216bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,10 +10,16 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,14 +30,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
  * behavior (connection/disconnection/options) should go in
@@ -55,7 +53,7 @@ public void setUp() throws IOException {
     defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
     HttpURLConnection.setFollowRedirects(false);
     mockWebServer = new MockWebServer();
-    mockWebServer.play();
+    mockWebServer.start();
 
     streamCaptor = ArgumentCaptor.forClass(InputStream.class);
   }
@@ -80,7 +78,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -91,7 +89,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -120,7 +118,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -137,9 +135,9 @@ public void testHandlesUpToFiveRedirects() throws Exception {
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -176,7 +174,7 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -204,7 +202,7 @@ public void testSetsReadTimeout() throws Exception {
     MockWebServer tempWebServer = new MockWebServer();
     tempWebServer.enqueue(
         new MockResponse().setBody("test").throttleBody(1, TIMEOUT_TIME_MS, TimeUnit.MILLISECONDS));
-    tempWebServer.play();
+    tempWebServer.start();
 
     try {
       getFetcher().loadData(Priority.HIGH, callback);
@@ -233,11 +231,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private HttpUrlFetcher getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private HttpUrlFetcher getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
         HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 3645035a3..7ad707409 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -9,7 +9,11 @@
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,12 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUrlFetcherTest {
@@ -116,4 +114,4 @@ public void testClosesStreamBeforeDisconnectingConnection() throws IOException {
     order.verify(stream).close();
     order.verify(urlConnection).disconnect();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af261f814..b5980ac6b 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -8,9 +8,10 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.Priority;
-
+import java.io.Closeable;
+import java.io.FileNotFoundException;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,10 +21,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.Closeable;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LocalUriFetcherTest {
@@ -64,7 +61,7 @@ public void testHandlesExceptionOnClose() throws Exception {
     final Closeable closeable = mock(Closeable.class);
 
     public TestLocalUriFetcher(Context context, Uri uri) {
-      super(context, uri);
+      super(context.getContentResolver(), uri);
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index c23921ad0..5b03e0f83 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -6,9 +6,9 @@
 import static org.mockito.Mockito.when;
 
 import android.content.res.AssetManager;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,9 +17,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamAssetPathFetcherTest {
@@ -64,4 +61,4 @@ public void testDoesNothingOnCancel() throws Exception {
     fetcher.cancel();
     verify(expected, never()).close();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 0975a2c12..4ceec4c8f 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -7,21 +7,17 @@
 
 import android.net.Uri;
 import android.provider.MediaStore;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbFetcherTest {
@@ -38,12 +34,12 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+    fetcher = new ThumbFetcher(uri, opener);
   }
 
   @Test
   public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.LOW, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
@@ -51,7 +47,7 @@ public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
 
   @Test
   public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.HIGH, callback);
 
@@ -63,4 +59,4 @@ public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception
   public void testDoesNotThrowIfCleanupWithNullInputStream() {
     fetcher.cleanup();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index d3d082243..50535836c 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -8,13 +8,20 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.content.ContentResolver;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +31,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.fakes.RoboCursor;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbnailStreamOpenerTest {
@@ -41,43 +43,41 @@ public void setUp() {
 
   @Test
   public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(new MatrixCursor(new String[1]));
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
     cursor.addRow(new Object[] { "" });
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(cursor);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.exists(eq(harness.file))).thenReturn(false);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.length(eq(harness.file))).thenReturn(0L);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testClosesCursor() throws FileNotFoundException {
-    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    harness.get().open(harness.uri);
     assertTrue(harness.cursor.isClosed());
   }
 
@@ -86,27 +86,33 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     InputStream expected = new ByteArrayInputStream(new byte[0]);
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .registerInputStream(harness.uri, expected);
-    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertEquals(expected, harness.get().open(harness.uri));
   }
 
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    ThumbFetcher.VideoThumbnailQuery query =
+        new ThumbFetcher.VideoThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
   }
 
   @Test
-  public void testImageQueryReturnsImageCurosr() {
+  public void testImageQueryReturnsImageCursor() {
     Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    ThumbFetcher.ImageThumbnailQuery query =
+        new ThumbFetcher.ImageThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
+  }
+
+  private static ContentResolver getContentResolver() {
+    return RuntimeEnvironment.application.getContentResolver();
   }
 
   private static class Harness {
@@ -115,18 +121,21 @@ public void testImageQueryReturnsImageCurosr() {
     Uri uri = Uri.fromFile(file);
     ThumbnailQuery query = mock(ThumbnailQuery.class);
     FileService service = mock(FileService.class);
-    ByteArrayPool byteArrayPool = new LruByteArrayPool();
+    ArrayPool byteArrayPool = new LruArrayPool();
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
-      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
       when(service.length(eq(file))).thenReturn(1L);
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      parsers.add(new DefaultImageHeaderParser());
+      return new ThumbnailStreamOpener(
+          parsers, service, query, byteArrayPool, getContentResolver());
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index b9790640b..81687fa35 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data.resource;
 
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -10,12 +11,11 @@
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.tests.ContentResolverShadow;
-
+import java.io.FileNotFoundException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,7 +24,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
@@ -38,21 +38,36 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsFileDescriptor() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    final Uri uri = Uri.parse("file://nothing");
+  public void testLoadResource_returnsFileDescriptor() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
     shadow.registerFileDescriptor(uri, assetFileDescriptor);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
 
+  @Test
+  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
+
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index ee8f8d922..a7fb2d580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -1,15 +1,19 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.isNotNull;
 import static org.mockito.Mockito.verify;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
-
+import com.bumptech.glide.tests.ContentResolverShadow;
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,11 +22,10 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class StreamLocalUriFetcherTest {
   @Mock DataFetcher.DataCallback<InputStream> callback;
 
@@ -32,11 +35,32 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsInputStream() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+  public void testLoadResource_returnsInputStream() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+    shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
   }
+
+  @Test
+  public void testLoadResource_withNullInputStream_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
+
+    shadow.registerInputStream(uri, null /*inputStream*/);
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 35a67441d..01c767634 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -6,7 +6,9 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util.WriteDigest;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +16,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class DataCacheKeyTest {
 
@@ -65,4 +63,4 @@ public void testSameIfIdAndSignatureAreTheSame()
 
     KeyAssertions.assertSame(first, second);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index d5ba400f5..6a740e638 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
@@ -15,11 +18,13 @@
 
 import android.os.Handler;
 import android.support.v4.util.Pools;
-
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
-
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,9 +36,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLooper;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineJobTest {
@@ -48,17 +50,17 @@ public void setUp() {
   public void testOnResourceReadyPassedToCallbacks() throws Exception {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.cb).onResourceReady(eq(harness.engineResource));
+    verify(harness.cb).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
   }
 
   @Test
   public void testListenerNotifiedJobCompleteOnOnResourceReady() {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
 
@@ -69,9 +71,9 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
   public void testNotifiesAllCallbacksOnReady() {
     MultiCbHarness harness = new MultiCbHarness();
     harness.job.start(harness.decodeJob);
-    harness.job.onResourceReady(harness.resource);
+    harness.job.onResourceReady(harness.resource, harness.dataSource);
     for (ResourceCallback cb : harness.cbs) {
-      verify(cb).onResourceReady(eq(harness.engineResource));
+      verify(cb).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
     }
   }
 
@@ -90,7 +92,7 @@ public void testNotifiesAllCallbacksOnException() {
   public void testAcquiresResourceOncePerCallback() {
     MultiCbHarness harness = new MultiCbHarness();
     harness.job.start(harness.decodeJob);
-    harness.job.onResourceReady(harness.resource);
+    harness.job.onResourceReady(harness.resource, harness.dataSource);
 
     // Acquired once and then released while notifying.
     InOrder order = inOrder(harness.engineResource);
@@ -105,7 +107,7 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -113,10 +115,10 @@ public void testResourceIsCacheableWhenIsCacheableOnReady() {
     harness.isCacheable = true;
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(any(Resource.class), eq(harness.isCacheable));
+    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
   }
 
   @Test
@@ -124,10 +126,10 @@ public void testResourceIsCacheableWhenNotIsCacheableOnReady() {
     harness.isCacheable = false;
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(any(Resource.class), eq(harness.isCacheable));
+    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
   }
 
   @Test
@@ -145,10 +147,10 @@ public void testOnResourceReadyNotDeliveredAfterCancel() {
     job.start(harness.decodeJob);
     job.cancel();
 
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.cb, never()).onResourceReady(eq(harness.resource));
+    verify(harness.cb, never()).onResourceReady(anyResource(), isADataSource());
   }
 
   @Test
@@ -176,7 +178,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @SuppressWarnings("unchecked")
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
-    EngineJob job = harness.getJob();
+    EngineJob<Object> job = harness.getJob();
     job.addCallback(mock(ResourceCallback.class));
     job.removeCallback(harness.cb);
 
@@ -187,7 +189,7 @@ public void removingSomeCallbacksDoesNotCancelRunner() {
   public void testResourceIsAcquiredOncePerConsumerAndOnceForCache() {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     // Once while notifying and once for single callback.
     verify(harness.engineResource, times(2)).acquire();
@@ -197,7 +199,7 @@ public void testResourceIsAcquiredOncePerConsumerAndOnceForCache() {
   public void testDoesNotNotifyCancelledIfCompletes() {
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
   }
@@ -218,7 +220,7 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
@@ -229,7 +231,7 @@ public void testReleasesResourceIfCancelledOnReady() {
 
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
     job.cancel();
     shadowLooper.runOneTask();
 
@@ -241,7 +243,7 @@ public void testDoesNotAcquireOnceForMemoryCacheIfNotCacheable() {
     harness.isCacheable = false;
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     verify(harness.engineResource, times(2)).acquire();
   }
@@ -252,31 +254,31 @@ public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceRe
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
-    }).when(existingCallback).onResourceReady(any(Resource.class));
+    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());
 
     job.addCallback(existingCallback);
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
-    verify(newCallback).onResourceReady(eq(harness.engineResource));
+    verify(newCallback).onResourceReady(eq(harness.engineResource), eq(harness.dataSource));
   }
 
   @Test
   public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
     harness = new EngineJobHarness();
-    final EngineJob job = harness.getJob();
+    final EngineJob<Object> job = harness.getJob();
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
@@ -295,19 +297,19 @@ public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlrea
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
-    }).when(cb).onResourceReady(any(Resource.class));
+    }).when(cb).onResourceReady(anyResource(), isADataSource());
 
     job.addCallback(cb);
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
-    verify(cb, times(1)).onResourceReady(any(Resource.class));
+    verify(cb, times(1)).onResourceReady(anyResource(), isADataSource());
   }
 
   @Test
@@ -316,9 +318,9 @@ public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBe
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
@@ -338,19 +340,19 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
-    }).when(harness.cb).onResourceReady(any(Resource.class));
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
 
     job.addCallback(notYetCalled);
     job.start(harness.decodeJob);
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
-    verify(notYetCalled, never()).onResourceReady(any(Resource.class));
+    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());
   }
 
   @Test
@@ -359,18 +361,18 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
-    }).when(harness.cb).onResourceReady(any(Resource.class));
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
 
     job.addCallback(notYetCalled);
     job.start(harness.decodeJob);
 
-    job.onResourceReady(harness.resource);
+    job.onResourceReady(harness.resource, harness.dataSource);
 
     // Once for notifying, once for called.
     verify(harness.engineResource, times(2)).acquire();
@@ -383,9 +385,9 @@ public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalled
     final ResourceCallback called = mock(ResourceCallback.class);
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -396,7 +398,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(notYetCalled, never()).onResourceReady(any(Resource.class));
+    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());
   }
 
   @Test
@@ -411,39 +413,67 @@ public void testCancelsDecodeJobOnCancel() {
   @Test
   public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
     EngineJob<Object> job = harness.getJob();
+    harness.diskCacheService.shutdownNow();
     job.reschedule(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
+    EngineJob<Object> job = harness.getJob();
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
+    harness.diskCacheService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
   }
 
   @Test
-  public void testSubmitsDecodeJobToDiskCacheServiceOnStart() {
+  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart() {
     EngineJob<Object> job = harness.getJob();
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    EngineJob<Object> job = harness.getJob();
+
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.diskCacheService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
     Key key = mock(Key.class);
-    Resource<Object> resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     int numCbs = 10;
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     EngineJob<Object> job;
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
+          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -459,19 +489,23 @@ public MultiCbHarness() {
     Key key = mock(Key.class);
     Handler mainHandler = new Handler();
     ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     public EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      EngineJob<Object> result = new EngineJob<>(
+          diskCacheService, sourceService, sourceUnlimitedService, listener, pool, factory)
+          .init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
index e2c13d0e7..0e691225f 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -11,7 +11,10 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,11 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-
 /**
  * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
  * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
@@ -44,9 +42,10 @@ public void setUp() {
     String id = "testId";
     int width = 1;
     int height = 2;
-    Class resourceClass = Object.class;
-    Class transcodeClass = Integer.class;
+    Class<?> resourceClass = Object.class;
+    Class<?> transcodeClass = Integer.class;
     Key signature = mock(Key.class);
+    @SuppressWarnings("unchecked")
     Transformation<Object> transformation = mock(Transformation.class);
     Options options = new Options();
 
@@ -99,9 +98,9 @@ public void testDiffersIfSignatureDiffers()
       throws UnsupportedEncodingException, NoSuchAlgorithmException {
     EngineKey first = harness.build();
     Key signature = mock(Key.class);
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
         digest.update("signature".getBytes("UTF-8"));
         return null;
@@ -135,7 +134,7 @@ public void testDiffersIfTranscodeClassDiffers()
   public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
     EngineKey first = harness.build();
 
-    Transformation<Object> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
     harness.transformation = other;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index 1f328c03d..c4a05be94 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -10,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.Key;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,10 +25,9 @@
   private Key cacheKey = mock(Key.class);
   private Resource<Object> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
-    resource = mock(Resource.class);
+    resource = mockResource();
     engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
     listener = mock(EngineResource.ResourceListener.class);
     engineResource.setResourceListener(cacheKey, listener);
@@ -146,9 +145,9 @@ public void testThrowsIfWrappedResourceIsNull() {
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mock(Resource.class), true);
+    engineResource = new EngineResource<>(mockResource(), true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mock(Resource.class), false);
+    engineResource = new EngineResource<>(mockResource(), false);
     assertFalse(engineResource.isCacheable());
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 5e50072ac..6a5cb537c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -18,16 +21,20 @@
 
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,12 +43,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
+@SuppressWarnings("unchecked")
 public class EngineTest {
   private EngineTestHarness harness;
 
@@ -93,7 +97,6 @@ public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
   }
 
   @Test
-  @SuppressWarnings("unchecked")
   public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
     harness.doLoad();
 
@@ -119,7 +122,7 @@ public void testResourceIsReturnedFromActiveResourcesIfPresent() {
 
     harness.doLoad();
 
-    verify(harness.cb).onResourceReady(eq(harness.resource));
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
   @Test
@@ -128,7 +131,7 @@ public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
 
     harness.doLoad();
 
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class));
+    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
   }
 
   @Test
@@ -171,13 +174,13 @@ public void testNullLoadStatusIsReturnedIfResourceIsActive() {
   @Test
   public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource other = mock(EngineResource.class);
+    EngineResource<?> other = mock(EngineResource.class);
     harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
 
     harness.doLoad();
 
-    verify(harness.cb).onResourceReady(eq(harness.resource));
-    verify(harness.cb, never()).onResourceReady(eq(other));
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
   }
 
   @Test
@@ -198,7 +201,7 @@ public void testCacheIsCheckedIfMemoryCacheable() {
 
     harness.doLoad();
 
-    verify(harness.cb).onResourceReady(eq(harness.resource));
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
   @Test
@@ -217,28 +220,28 @@ public void testResourceIsReturnedFromCacheIfPresent() {
 
     harness.doLoad();
 
-    verify(harness.cb).onResourceReady(eq(harness.resource));
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
   }
 
   @Test
   public void testHandlesNonEngineResourcesFromCacheIfPresent() {
     final Object expected = new Object();
-    Resource fromCache = mock(Resource.class);
+    @SuppressWarnings("rawtypes") Resource fromCache = mockResource();
     when(fromCache.get()).thenReturn(expected);
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource resource = (Resource) invocationOnMock.getArguments()[0];
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
         assertEquals(expected, resource.get());
         return null;
       }
-    }).when(harness.cb).onResourceReady(any(Resource.class));
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
 
     harness.doLoad();
 
-    verify(harness.cb).onResourceReady(any(Resource.class));
+    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
   }
 
   @Test
@@ -307,7 +310,7 @@ public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
     harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
 
     WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertEquals(harness.resource, resourceRef.get());
+    assertThat(harness.resource).isEqualTo(resourceRef.get());
   }
 
   @Test
@@ -346,19 +349,18 @@ public void testResourceIsAddedToCacheOnReleased() {
     final Object expected = new Object();
     when(harness.resource.isCacheable()).thenReturn(true);
     when(harness.resource.get()).thenReturn(expected);
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
         assertEquals(expected, resource.get());
         return null;
       }
-    }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+    }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
 
     harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
 
-
-    verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+    verify(harness.cache).put(eq(harness.cacheKey), anyResource());
   }
 
   @Test
@@ -415,10 +417,23 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
 
   @Test
   public void testFactoryIsGivenNecessaryArguments() {
-    boolean isMemoryCacheable = true;
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(isMemoryCacheable));
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(true) /*useUnlimitedSourceGeneratorPool*/);
   }
 
   @Test
@@ -430,7 +445,7 @@ public void testReleaseReleasesEngineResource() {
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mock(Resource.class));
+    harness.engine.release(mockResource());
   }
 
   @Test(expected = RuntimeException.class)
@@ -443,13 +458,13 @@ public void runTest() throws Exception {
     });
   }
 
-  @SuppressWarnings("unchecked")
   private static class EngineTestHarness {
     EngineKey cacheKey = mock(EngineKey.class);
     EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
+    @SuppressWarnings("rawtypes")
     EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob> jobs = new HashMap<>();
+    Map<Key, EngineJob<?>> jobs = new HashMap<>();
     Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
 
     int width = 100;
@@ -457,7 +472,7 @@ public void runTest() throws Exception {
 
     Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
-    EngineJob job;
+    EngineJob<?> job;
     Engine engine;
     Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
     Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
@@ -467,6 +482,8 @@ public void runTest() throws Exception {
     Options options = new Options();
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -474,26 +491,32 @@ public EngineTestHarness() {
 
       job = mock(EngineJob.class);
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),
-          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,
-          decodeJobFactory, resourceRecycler);
+      engine = new Engine(cache, mock(DiskCache.Factory.class),
+          GlideExecutor.newDiskCacheExecutor(),
+          MockGlideExecutor.newMainThreadExecutor(),
+          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+          jobs, keyFactory, activeResources,
+          engineJobFactory, decodeJobFactory, resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean()))
+          .thenReturn((EngineJob<Object>) job);
       return engine.load(glideContext,
           model,
           signature,
           width,
           height,
-          Object.class,
-          Object.class,
+          Object.class /*resourceClass*/,
+          Object.class /*transcodeClass*/,
           Priority.HIGH,
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
           options,
           isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          onlyRetrieveFromCache,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
index 12ec0d4f8..b2d467fac 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -7,19 +7,17 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.StringSignature;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class ResourceCacheKeyTest {
 
@@ -42,7 +40,7 @@ public void testDifferIfSourceKeyDiffers()
     mutateAndAssertDifferent(new FactoryMutation() {
       @Override
       public void mutate(Factory factory) {
-        factory.sourceKey = new StringSignature("secondKey");
+        factory.sourceKey = new ObjectKey("secondKey");
       }
     });
   }
@@ -52,7 +50,7 @@ public void testDiffersIfSignatureDiffers() {
     mutateAndAssertDifferent(new FactoryMutation() {
       @Override
       public void mutate(Factory factory) {
-        factory.signature = new StringSignature("secondSignature");
+        factory.signature = new ObjectKey("secondSignature");
       }
     });
   }
@@ -116,8 +114,8 @@ private void mutateAndAssertDifferent(FactoryMutation mutation) {
   }
 
   static class Factory {
-    Key sourceKey = new StringSignature("sourceKey");
-    Key signature = new StringSignature("signature");
+    Key sourceKey = new ObjectKey("sourceKey");
+    Key signature = new ObjectKey("signature");
     int width = 100;
     int height = 100;
     Transformation<?> transformation = mock(Transformation.class);
@@ -134,4 +132,4 @@ ResourceCacheKey build() {
           resourceClass, options);
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
index bc78d1ed7..80405ffc9 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.os.Looper;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +28,7 @@ public void setUp() {
 
   @Test
   public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
-    Resource resource = mock(Resource.class);
+    Resource<?> resource = mockResource();
     Shadows.shadowOf(Looper.getMainLooper()).pause();
     recycler.recycle(resource);
     verify(resource).recycle();
@@ -37,11 +36,11 @@ public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
 
   @Test
   public void testDoesNotRecycleChildResourceSynchronously() {
-    Resource parent = mock(Resource.class);
-    final Resource child = mock(Resource.class);
-    doAnswer(new Answer() {
+    Resource<?> parent = mockResource();
+    final Resource<?> child = mockResource();
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         recycler.recycle(child);
         return null;
       }
@@ -58,4 +57,4 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     verify(child).recycle();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
index a24f670c6..5ee47b04b 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -6,12 +6,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -71,4 +68,4 @@ public void testInitSetsAttributes() {
 
     assertEquals(key, other);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 9fc1f1eb2..234b0f0e3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -4,7 +4,6 @@
 import static org.junit.Assert.assertNull;
 
 import android.graphics.Bitmap;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..4f6016cf3
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,114 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final Class<byte[]> ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() throws Exception {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(ADAPTER.getArrayLength((byte[]) array) >= size);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
+        ARRAY_CLASS);
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> T createArray(Class<T> type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return (T) array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 6db6062dd..2b515c771 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,7 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -13,7 +13,11 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,12 +26,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LruBitmapPoolTest {
@@ -102,18 +100,18 @@ public void testEvictedBitmapsAreRecycled() {
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesHalfOfBitmaps() {
-    testTrimMemory(MAX_SIZE, TRIM_MEMORY_BACKGROUND, MAX_SIZE / 2);
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
-    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_BACKGROUND, 0);
+  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
   }
 
   @Test
-  public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_MODERATE, TRIM_MEMORY_COMPLETE }) {
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
+    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
index c56ff320e..2242dcf03 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
index 129f4ecd9..6175eb2bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
@@ -6,10 +6,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -59,4 +57,4 @@ public void testInitSetsSize() {
 
     assertEquals(key, other);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index a1ecd5953..29b03a1ec 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -6,7 +6,9 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.Util;
-
+import java.io.File;
+import java.io.IOException;
+import java.security.MessageDigest;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +16,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DiskLruCacheWrapperTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 57ce35ebb..3e3451e81 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -14,7 +14,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.util.LruCache;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 61918f223..00ffc8295 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
 import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.eq;
@@ -9,23 +10,23 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.content.ComponentCallbacks2;
-
+import android.os.Build;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
-
+import java.security.MessageDigest;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.security.MessageDigest;
-
 @RunWith(JUnit4.class)
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruResourceCacheTest {
   private static class TrimClearMemoryCacheHarness {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = mock(Resource.class);
-    Resource second = mock(Resource.class);
+    Resource<?> first = mockResource();
+    Resource<?> second = mockResource();
 
     ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
 
@@ -39,30 +40,30 @@ public TrimClearMemoryCacheHarness() {
   }
 
   @Test
-  public void testTrimMemoryModerate() {
+  public void testTrimMemoryBackground() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
 
     verify(harness.listener).onResourceRemoved(eq(harness.first));
     verify(harness.listener).onResourceRemoved(eq(harness.second));
   }
 
   @Test
-  public void testTrimMemoryComplete() {
+  public void testTrimMemoryModerate() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener).onResourceRemoved(harness.second);
   }
 
   @Test
-  public void testTrimMemoryBackground() {
+  public void testTrimMemoryUiHidden() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener, never()).onResourceRemoved(harness.second);
@@ -71,7 +72,7 @@ public void testTrimMemoryBackground() {
   @Test
   public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource resource = mock(Resource.class);
+    Resource<?> resource = mockResource();
     when(resource.getSize()).thenReturn(200);
 
     ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
@@ -85,17 +86,17 @@ public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
   @Test
   public void testSizeIsBasedOnResource() {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = getResource(50);
+    Resource<?> first = getResource(50);
     MockKey firstKey = new MockKey();
     resourceCache.put(firstKey, first);
-    Resource second = getResource(50);
+    Resource<?> second = getResource(50);
     MockKey secondKey = new MockKey();
     resourceCache.put(secondKey, second);
 
     assertTrue(resourceCache.contains(firstKey));
     assertTrue(resourceCache.contains(secondKey));
 
-    Resource third = getResource(50);
+    Resource<?> third = getResource(50);
     MockKey thirdKey = new MockKey();
     resourceCache.put(thirdKey, third);
 
@@ -104,8 +105,8 @@ public void testSizeIsBasedOnResource() {
     assertTrue(resourceCache.contains(thirdKey));
   }
 
-  private Resource getResource(int size) {
-    Resource resource = mock(Resource.class);
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
     when(resource.getSize()).thenReturn(size);
     return resource;
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 3d3bb983c..98c4b8371 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -4,14 +4,12 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
-
+import com.bumptech.glide.load.engine.cache.MemorySizeCalculatorTest.LowRamActivityManager;
 import com.bumptech.glide.tests.Util;
-
+import com.google.common.collect.Range;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,10 +18,13 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowActivityManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 19, shadows = LowRamActivityManager.class)
 public class MemorySizeCalculatorTest {
   private MemorySizeHarness harness;
   private int initialSdkVersion;
@@ -31,6 +32,7 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
+    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -67,7 +69,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat((float) memoryCacheSize)
+    assertThat(memoryCacheSize)
         .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
@@ -136,12 +138,13 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);
+    LowRamActivityManager activityManager =
+        (LowRamActivityManager) Shadow.extract(harness.activityManager);
+    Util.setSdkVersionInt(19);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
+    activityManager.setIsLowRam(true);
 
-    Util.setSdkVersionInt(10);
-
-    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();
+    int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
   }
 
@@ -161,7 +164,7 @@ private int getLargeEnoughMemoryClass() {
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
     float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
-    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;
+    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
     ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
     MemorySizeCalculator.ScreenDimensions screenDimensions =
@@ -176,7 +179,7 @@ public MemorySizeCalculator getCalculator() {
           .setMaxSizeMultiplier(sizeMultiplier)
           .setActivityManager(activityManager)
           .setScreenDimensions(screenDimensions)
-          .setByteArrayPoolSize(byteArrayPoolSizeBytes)
+          .setArrayPoolSize(byteArrayPoolSizeBytes)
           .build();
     }
 
@@ -184,4 +187,19 @@ public int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
+
+  @Implements(ActivityManager.class)
+  public static final class LowRamActivityManager extends ShadowActivityManager {
+
+    private boolean isLowRam;
+
+    void setIsLowRam(boolean isLowRam) {
+      this.isLowRam = isLowRam;
+    }
+
+    @Implementation
+    public boolean isLowRamDevice() {
+      return isLowRam;
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 738bcd951..207ccaf9b 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -3,17 +3,15 @@
 import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.load.Key;
-
+import java.security.MessageDigest;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class SafeKeyGeneratorTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 1a6f5d9cd..fa9dba251 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,15 +2,14 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -19,7 +18,7 @@
   @Test
   public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
-    GlideExecutor executor = new GlideExecutor(1);
+    GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
       executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
         @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..af0dce220
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.load.engine.executor;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+public final class MockGlideExecutor {
+
+  private MockGlideExecutor() { }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
+
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
+        "mock-unlimited-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index 151d27f11..d00b03193 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.prefill;
 
+import static com.bumptech.glide.tests.Util.anyResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Matchers.any;
@@ -7,55 +8,54 @@
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillRunnerTest {
-  private BitmapPreFillRunner.Clock clock;
-  private BitmapPool pool;
-  private MemoryCache cache;
+  @Mock BitmapPreFillRunner.Clock clock;
+  @Mock BitmapPool pool;
+  @Mock MemoryCache cache;
+  @Mock Handler mainHandler;
   private List<Bitmap> addedBitmaps = new ArrayList<>();
-  private Handler mainHandler;
 
   @Before
   public void setUp() {
-    clock = mock(BitmapPreFillRunner.Clock.class);
+    MockitoAnnotations.initMocks(this);
 
-    pool = mock(BitmapPool.class);
-    when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));
-    cache = mock(MemoryCache.class);
-    when(cache.put(any(Key.class), any(Resource.class)))
+    doAnswer(new AddBitmapPoolAnswer(addedBitmaps)).when(pool).put(any(Bitmap.class));
+    when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new CreateBitmap());
+    when(cache.put(any(Key.class), anyResource()))
         .thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
-    mainHandler = mock(Handler.class);
   }
 
   private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
@@ -129,7 +129,7 @@ public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerTh
   public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
     BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
     handler.run();
-    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
   }
 
   @Test
@@ -205,7 +205,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache).put(any(Key.class), any(Resource.class));
+    verify(cache).put(any(Key.class), anyResource());
     verify(pool, never()).put(any(Bitmap.class));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -224,7 +224,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // verify(pool).put(eq(bitmap));
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -243,7 +243,7 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     //verify(pool).put(eq(bitmap));
     //assertThat(addedBitmaps).containsExactly(bitmap);
@@ -268,13 +268,14 @@ public void testDoesAGetFromPoolBeforeAddingForEachSize() {
     getHandler(allocationOrder).run();
 
     InOrder firstOrder = inOrder(pool);
-    firstOrder.verify(pool).get(eq(first.getWidth()), eq(first.getHeight()), eq(first.getConfig()));
+    firstOrder.verify(pool).getDirty(eq(first.getWidth()), eq(first.getHeight()),
+        eq(first.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // firstOrder.verify(pool).put(eq(first));
 
     InOrder secondOrder = inOrder(pool);
     secondOrder.verify(pool)
-        .get(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
+        .getDirty(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // secondOrder.verify(pool).put(eq(second));
   }
@@ -293,12 +294,13 @@ public void testDoesNotGetMoreThanOncePerSize() {
     getHandler(allocationOrder).run();
 
     InOrder order = inOrder(pool);
-    order.verify(pool).get(eq(bitmap.getWidth()), eq(bitmap.getHeight()), eq(bitmap.getConfig()));
+    order.verify(pool).getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()),
+        eq(bitmap.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
-  private static class AddBitmapPoolAnswer implements Answer<Boolean> {
+  private static class AddBitmapPoolAnswer implements Answer<Void> {
     private List<Bitmap> bitmaps;
 
     public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
@@ -306,7 +308,7 @@ public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
     }
 
     @Override
-    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+    public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
       bitmaps.add(bitmap);
       return null;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index 6d95e845b..6349da7e1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -4,31 +4,31 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import com.google.common.collect.Range;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillerTest {
@@ -45,15 +45,16 @@
   private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
   private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
 
-  private BitmapPool pool;
+  @Mock BitmapPool pool;
+  @Mock MemoryCache cache;
   private BitmapPreFiller bitmapPreFiller;
-  private MemoryCache cache;
 
   @Before
   public void setUp() {
-    pool = mock(BitmapPool.class);
+    MockitoAnnotations.initMocks(this);
     when(pool.getMaxSize()).thenReturn(poolSize);
-    cache = mock(MemoryCache.class);
+    when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new CreateBitmap());
     when(cache.getMaxSize()).thenReturn(cacheSize);
 
     bitmapPreFiller = new BitmapPreFiller(cache, pool, DecodeFormat.DEFAULT);
@@ -265,7 +266,8 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     bitmapPreFiller.preFill(builder);
 
     InOrder order = inOrder(builder);
-    order.verify(builder).setConfig(Bitmap.Config.RGB_565);
+    order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
 
@@ -280,4 +282,4 @@ public void testDoesNotSetConfigOnBuildersIfConfigIsAlreadySet() {
 
     verify(builder, never()).setConfig(any(Bitmap.Config.class));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
index 6116bd821..bd14089f4 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -2,10 +2,8 @@
 
 import static org.junit.Assert.assertEquals;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -73,4 +71,4 @@ public void testEquality() {
         .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1))
         .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)).testEquals();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 18681da1d..1dd269502 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -8,10 +8,8 @@
 
 import android.content.res.AssetManager;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -44,4 +42,4 @@ public void testHandlesAssetUris() {
     assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
         new Options()).fetcher);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index 580bc669d..e17ecc6b9 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,7 +9,7 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,8 +17,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
@@ -52,7 +50,7 @@ public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
   }
 
   @Test
-  public void testFetcherRetrunsDataClassFromConverter() {
+  public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
     assertEquals(Object.class,
         loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
new file mode 100644
index 000000000..6665f0720
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.support.annotation.Nullable;
+import android.util.Base64;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Tests for the {@link DataUrlLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DataUrlLoaderTest {
+
+  // A valid base64-encoded PNG (a small "Google" logo).
+  @SuppressWarnings("SpellCheckingInspection")
+  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
+      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
+      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
+      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
+      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
+      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
+      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
+      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
+      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
+      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
+      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
+      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
+      + "AASUVORK5CYII=";
+
+  private static final String INVALID_URL_WRONG_SCHEME1 = "test";
+  private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
+  private static final String INVALID_URL_WRONG_SCHEME3 = "data:text";
+  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOT_BASE64";
+  private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
+
+  @Mock
+  private MultiModelLoaderFactory multiFactory;
+  private DataUrlLoader<InputStream> dataUrlLoader;
+  private DataFetcher<InputStream> fetcher;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    options = new Options();
+    dataUrlLoader = (DataUrlLoader<InputStream>) factory.build(multiFactory);
+    fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
+
+  }
+
+  @Test
+  public void testHandleDataUri() {
+    assertTrue(dataUrlLoader.handles(VALID_PNG));
+  }
+
+  @Test
+  public void testHandleFalseDataUri() {
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME1));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME2));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME3));
+  }
+
+  @Test
+  public void testDecode() throws IOException {
+    byte[] expected = Base64
+        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
+    assertEquals(result.length, ((ByteArrayInputStream) callback.data).read(result));
+    assertTrue(Arrays.equals(result, expected));
+    assertNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeInvalidScheme() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeMissingComma() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeWrongEncoding() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  private class CallBack implements DataFetcher.DataCallback<Object> {
+
+    public Object data;
+    public Exception exception;
+
+    @Override
+    public void onDataReady(@Nullable Object data) {
+      this.data = data;
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) {
+      this.exception = e;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index b5fe26ec5..2548b0e59 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -4,15 +4,13 @@
 import static org.mockito.Mockito.mock;
 
 import com.google.common.testing.EqualsTester;
-
+import java.net.MalformedURLException;
+import java.net.URL;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.net.MalformedURLException;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GlideUrlTest {
@@ -115,4 +113,4 @@ public void testEquals() throws MalformedURLException {
             new GlideUrl(new URL(url), otherHeaders)
         ).testEquals();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 3ad1d856e..907acb6ae 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -4,208 +4,354 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
-
+import com.google.common.testing.EqualsTester;
+import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LazyHeadersTest {
+  private static final String DEFAULT_USER_AGENT = "default_user_agent";
+  private static final String DEFAULT_USER_AGENT_PROPERTY = "http.agent";
+  private String initialUserAgent;
 
-    @Test
-    public void testIncludesEagerHeaders() {
-        Map<String, String> headers = new Builder()
-            .addHeader("key", "value")
-            .build()
-            .getHeaders();
-        assertThat(headers).containsEntry("key", "value");
-        assertThat(headers).hasSize(1);
-    }
+  @Before
+  public void setUp() {
+    initialUserAgent = System.getProperty(DEFAULT_USER_AGENT_PROPERTY);
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, DEFAULT_USER_AGENT);
+  }
 
-    @Test
-    public void testIncludesLazyHeaders() {
-        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
-        when(factory.buildHeader()).thenReturn("value");
-        Map<String, String> headers = new Builder()
-            .addHeader("key", factory)
-            .build()
-            .getHeaders();
-
-        assertThat(headers).hasSize(1);
-        assertThat(headers).containsEntry("key", "value");
+  @After
+  public void tearDown() {
+    if (initialUserAgent != null) {
+      System.setProperty(DEFAULT_USER_AGENT_PROPERTY, initialUserAgent);
     }
+  }
 
-    @Test
-    public void testMultipleEagerValuesAreSeparatedByCommas() {
-        Map<String, String> headers = new Builder()
-            .addHeader("key", "first")
-            .addHeader("key", "second")
-            .build()
-            .getHeaders();
+  @Test
+  public void testIncludesEagerHeaders() {
+    Map<String, String> headers = new Builder()
+        .addHeader("key", "value")
+        .build()
+        .getHeaders();
+    assertThat(headers).containsEntry("key", "value");
+  }
 
-        assertThat(headers).hasSize(1);
-        assertThat(headers).containsEntry("key", "first,second");
-    }
+  @Test
+  public void testIncludesLazyHeaders() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("value");
+    Map<String, String> headers = new Builder()
+        .addHeader("key", factory)
+        .build()
+        .getHeaders();
 
-    @Test
-    public void testMultipleLazyValuesAreSeparatedByCommas() {
-        LazyHeaderFactory first = mock(LazyHeaderFactory.class);
-        when(first.buildHeader()).thenReturn("first");
-        LazyHeaderFactory second = mock(LazyHeaderFactory.class);
-        when(second.buildHeader()).thenReturn("second");
-
-        Map<String, String> headers = new Builder()
-            .addHeader("key", first)
-            .addHeader("key", second)
-            .build()
-            .getHeaders();
-        assertThat(headers).hasSize(1);
-        assertThat(headers).containsEntry("key", "first,second");
-    }
+    assertThat(headers).containsEntry("key", "value");
+  }
 
-    @Test
-    public void testMixedEagerAndLazyValuesAreIncluded() {
-        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
-        when(factory.buildHeader()).thenReturn("first");
-        Map<String, String> headers = new Builder()
-            .addHeader("key", factory)
-            .addHeader("key", "second")
-            .build()
-            .getHeaders();
-
-        assertThat(headers).hasSize(1);
-        assertThat(headers).containsEntry("key", "first,second");
-
-        headers = new Builder()
-            .addHeader("key", "second")
-            .addHeader("key", factory)
-            .build()
-            .getHeaders();
-
-        assertThat(headers).hasSize(1);
-        assertThat(headers).containsEntry("key", "second,first");
-    }
+  @Test
+  public void testMultipleEagerValuesAreSeparatedByCommas() {
+    Map<String, String> headers = new Builder()
+        .addHeader("key", "first")
+        .addHeader("key", "second")
+        .build()
+        .getHeaders();
 
-    @Test
-    public void testCanAddMultipleKeys() {
-        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
-        when(factory.buildHeader()).thenReturn("lazy");
-        Map<String, String> headers = new Builder()
-            .addHeader("first", factory)
-            .addHeader("second", "eager")
-            .build()
-            .getHeaders();
-
-        assertThat(headers).hasSize(2);
-        assertThat(headers).containsEntry("first", "lazy");
-        assertThat(headers).containsEntry("second", "eager");
-    }
+    assertThat(headers).containsEntry("key", "first,second");
+  }
 
-    @Test
-    public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
-        Builder builder = new Builder();
-        builder.addHeader("key", "firstValue");
-        LazyHeaders first = builder.build();
+  @Test
+  public void testMultipleLazyValuesAreSeparatedByCommas() {
+    LazyHeaderFactory first = mock(LazyHeaderFactory.class);
+    when(first.buildHeader()).thenReturn("first");
+    LazyHeaderFactory second = mock(LazyHeaderFactory.class);
+    when(second.buildHeader()).thenReturn("second");
 
-        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
-        when(factory.buildHeader()).thenReturn("otherValue");
-        builder.addHeader("key", "secondValue");
-        builder.addHeader("otherKey", factory);
-        LazyHeaders second = builder.build();
+    Map<String, String> headers = new Builder()
+        .addHeader("key", first)
+        .addHeader("key", second)
+        .build()
+        .getHeaders();
+    assertThat(headers).containsEntry("key", "first,second");
+  }
 
-        assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());
+  @Test
+  public void testMixedEagerAndLazyValuesAreIncluded() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("first");
+    Map<String, String> headers = new Builder()
+        .addHeader("key", factory)
+        .addHeader("key", "second")
+        .build()
+        .getHeaders();
 
-        assertThat(first.getHeaders()).hasSize(1);
-        assertThat(first.getHeaders()).containsEntry("key", "firstValue");
+    assertThat(headers).containsEntry("key", "first,second");
 
-        assertThat(second.getHeaders()).hasSize(2);
-        assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
-        assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
-    }
+    headers = new Builder()
+        .addHeader("key", "second")
+        .addHeader("key", factory)
+        .build()
+        .getHeaders();
 
-    @Test
-    public void testEquals() {
-        LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
-        LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
-        new EqualsTester()
-            .addEqualityGroup(
-                new Builder().build(),
-                new Builder().build()
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("key", "value").build(),
-                new Builder().addHeader("key", "value").build()
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("key", "value").addHeader("key", "value").build()
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("key", firstLazyFactory).build(),
-                new Builder().addHeader("key", firstLazyFactory).build()
-            )
-            .addEqualityGroup(
-                new Builder()
-                    .addHeader("key", firstLazyFactory)
-                    .addHeader("key", firstLazyFactory)
-                    .build()
-            )
-            .addEqualityGroup(
-                new Builder()
-                    .addHeader("firstKey", "value")
-                    .addHeader("secondKey", firstLazyFactory)
-                    .build(),
-                new Builder()
-                    .addHeader("secondKey", firstLazyFactory)
-                    .addHeader("firstKey", "value")
-                    .build()
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("key", "secondValue")
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("secondKey", "value")
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("key", secondLazyFactory)
-            )
-            .addEqualityGroup(
-                new Builder().addHeader("secondKey", firstLazyFactory)
-            )
-            .addEqualityGroup(
-                new Builder()
-                    .addHeader("firstKey", "firstValue")
-                    .addHeader("secondKey", "secondValue")
-                    .build(),
-                new Builder()
-                    .addHeader("firstKey", "firstValue")
-                    .addHeader("secondKey", "secondValue")
-                    .build(),
-                new Builder()
-                    .addHeader("secondKey", "secondValue")
-                    .addHeader("firstKey", "firstValue")
-                    .build()
-            )
-            .addEqualityGroup(
-                new Builder()
-                    .addHeader("firstKey", firstLazyFactory)
-                    .addHeader("secondKey", secondLazyFactory)
-                    .build(),
-                new Builder()
-                    .addHeader("firstKey", firstLazyFactory)
-                    .addHeader("secondKey", secondLazyFactory)
-                    .build(),
-                new Builder()
-                    .addHeader("secondKey", secondLazyFactory)
-                    .addHeader("firstKey", firstLazyFactory)
-                    .build()
-            )
-            .testEquals();
-    }
-}
\ No newline at end of file
+    assertThat(headers).containsEntry("key", "second,first");
+  }
+
+  @Test
+  public void testCanAddMultipleKeys() {
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("lazy");
+    Map<String, String> headers = new Builder()
+        .addHeader("first", factory)
+        .addHeader("second", "eager")
+        .build()
+        .getHeaders();
+
+    assertThat(headers).containsEntry("first", "lazy");
+    assertThat(headers).containsEntry("second", "eager");
+  }
+
+  @Test
+  public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "firstValue");
+    builder.addHeader("otherKey", "otherValue");
+    LazyHeaders first = builder.build();
+
+    LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+    when(factory.buildHeader()).thenReturn("otherValue");
+    builder.addHeader("key", "secondValue");
+    builder.setHeader("otherKey", factory);
+    LazyHeaders second = builder.build();
+
+    assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());
+
+    assertThat(first.getHeaders()).containsEntry("key", "firstValue");
+    assertThat(first.getHeaders()).containsEntry("otherKey", "otherValue");
+
+    assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
+    assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
+  }
+
+  @Test
+  public void testSetHeaderReplacesExistingHeaders() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", "third");
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("key", "third");
+  }
+
+  @Test
+  public void testSetHeaderWithNullStringRemovesExistingHeader() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("key");
+  }
+
+  @Test
+  public void testSetHeaderWithNullLazyHeaderFactoryRemovesExistingHeader() {
+    Builder builder = new Builder();
+    builder.addHeader("key", "first")
+        .addHeader("key", "second")
+        .setHeader("key", (LazyHeaderFactory) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("key");
+  }
+
+  @Test
+  public void testAddingEncodingHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.addHeader("Accept-Encoding", "false");
+
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false");
+
+    builder.addHeader("Accept-Encoding", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false,true");
+  }
+
+  @Test
+  public void testRemovingAndAddingEncodingHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.setHeader("Accept-Encoding", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("Accept-Encoding");
+
+    builder.addHeader("Accept-Encoding", "false");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false");
+
+    builder.addHeader("Accept-Encoding", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("Accept-Encoding", "false,true");
+  }
+
+  @Test
+  public void testAddingUserAgentHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.addHeader("User-Agent", "false");
+
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false");
+
+    builder.addHeader("User-Agent", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
+  }
+
+  @Test
+  public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
+    Builder builder = new Builder();
+    builder.setHeader("User-Agent", (String) null);
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("User-Agent");
+
+    builder.addHeader("User-Agent", "false");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false");
+
+    builder.addHeader("User-Agent", "true");
+    headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
+  }
+
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
+    Builder builder = new Builder();
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "value";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("test", "value");
+  }
+
+  @Test
+  public void testEquals() {
+    LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
+    LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
+    new EqualsTester()
+        .addEqualityGroup(
+            new Builder().build(),
+            new Builder().build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "value").build(),
+            new Builder().addHeader("key", "value").build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "value").addHeader("key", "value").build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", firstLazyFactory).build(),
+            new Builder().addHeader("key", firstLazyFactory).build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("key", firstLazyFactory)
+                .addHeader("key", firstLazyFactory)
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", "value")
+                .addHeader("secondKey", firstLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("secondKey", firstLazyFactory)
+                .addHeader("firstKey", "value")
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", "secondValue")
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("secondKey", "value")
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("key", secondLazyFactory)
+        )
+        .addEqualityGroup(
+            new Builder().addHeader("secondKey", firstLazyFactory)
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", "firstValue")
+                .addHeader("secondKey", "secondValue")
+                .build(),
+            new Builder()
+                .addHeader("firstKey", "firstValue")
+                .addHeader("secondKey", "secondValue")
+                .build(),
+            new Builder()
+                .addHeader("secondKey", "secondValue")
+                .addHeader("firstKey", "firstValue")
+                .build()
+        )
+        .addEqualityGroup(
+            new Builder()
+                .addHeader("firstKey", firstLazyFactory)
+                .addHeader("secondKey", secondLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("firstKey", firstLazyFactory)
+                .addHeader("secondKey", secondLazyFactory)
+                .build(),
+            new Builder()
+                .addHeader("secondKey", secondLazyFactory)
+                .addHeader("firstKey", firstLazyFactory)
+                .build()
+        )
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
index b4e09b25c..041f67992 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 
 import com.google.common.testing.EqualsTester;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -52,4 +51,4 @@ public void testCanSetAndGetMultipleResultsWithDifferentDimensionsForSameObject(
     assertEquals(firstResult, cache.get(model, firstWidth, firstHeight));
     assertEquals(secondResult, cache.get(model, secondWidth, secondHeight));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 65491d6b1..b6acd775c 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,17 +1,17 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
-
+import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
-import com.bumptech.glide.load.engine.ExceptionListPool;
-
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -21,12 +21,8 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class MultiModelLoaderFactoryTest {
@@ -39,18 +35,18 @@
 
   @Rule public ExpectedException exception = ExpectedException.none();
 
-  private ExceptionListPool exceptionListPool;
+  private Pool<List<Exception>> exceptionListPool;
   private MultiModelLoaderFactory multiFactory;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    exceptionListPool = new ExceptionListPool();
+    exceptionListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
-            multiModelLoaderFactory);
-    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
-    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
+        multiModelLoaderFactory);
+    when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
 
   @Test
@@ -101,11 +97,10 @@ public void testReplace_addsModelLoaderForModelAndDataClasses() {
     assertThat(modelLoader).isEqualTo(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> firstOtherFactory = mock(ModelLoaderFactory.class);
-    ModelLoaderFactory<String, String> secondOtherFactory = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> firstOtherFactory = mockFactory();
+    ModelLoaderFactory<String, String> secondOtherFactory = mockFactory();
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
@@ -125,10 +120,9 @@ public void testReplace_removesPreviouslyRegisteredFactories_withModelAndDataCla
     assertThat(modelLoaders).containsExactly(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> other = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> other = mockFactory();
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -270,16 +264,15 @@ public void testBuild_respectsPrependOrder() {
     assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
   }
 
-  @SuppressWarnings("unchecked")
   private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
       Class<Y> dataClass) {
-    ArgumentCaptor<List> captor = ArgumentCaptor.forClass(List.class);
+    ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
     verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
 
-    List<ModelLoader> captured = captor.getValue();
+    List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader modelLoader : captured) {
+    for (ModelLoader<X, Y> modelLoader : captured) {
       result.add(modelLoader);
     }
     return result;
@@ -293,12 +286,11 @@ public void testBuild_respectsPrependOrder() {
     return registerFactoryFor(modelClass, dataClass, false /*append*/);
   }
 
-  @SuppressWarnings("unchecked")
-  private <X, Y> ModelLoader<X, Y> registerFactoryFor(Class<X> modelClass, Class<Y> dataClass,
-      boolean append) {
-    ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
-    ModelLoader<X, Y> loader = mock(ModelLoader.class);
-    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+  private <X, Y> ModelLoader<X, Y> registerFactoryFor(
+      Class<X> modelClass, Class<Y> dataClass, boolean append) {
+    ModelLoaderFactory<X, Y> factory = mockFactory();
+    @SuppressWarnings("unchecked") ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
     } else {
@@ -307,7 +299,9 @@ public void testBuild_respectsPrependOrder() {
     return loader;
   }
 
-  private static Context anyContext() {
-    return any(Context.class);
+  @SuppressWarnings("unchecked")
+  private static <X, Y> ModelLoaderFactory<X, Y> mockFactory() {
+    return mock(ModelLoaderFactory.class);
   }
-}
\ No newline at end of file
+}
+
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index 492e029dc..a5038c23a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -11,11 +11,9 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -44,7 +42,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     options = new Options();
 
-    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+    loader = new ResourceLoader<>(RuntimeEnvironment.application.getResources(), uriLoader);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 7986221a4..3eecb3718 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -3,9 +3,11 @@
 import static org.junit.Assert.assertEquals;
 
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -14,10 +16,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamEncoderTest {
@@ -26,7 +24,7 @@
 
   @Before
   public void setUp() {
-    encoder = new StreamEncoder(new LruByteArrayPool());
+    encoder = new StreamEncoder(new LruArrayPool());
     file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
   }
 
@@ -45,4 +43,4 @@ public void testWritesDataFromInputStreamToOutputStream() throws IOException {
 
     assertEquals(fakeData, new String(data));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index d8cd64909..42bc40545 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -9,12 +9,12 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,9 +24,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
  */
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 47fcd5457..846ed783c 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -2,28 +2,22 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link UriLoader} class.
  */
@@ -43,13 +37,13 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
-    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+    loader = new UriLoader<>(factory);
   }
 
   @Test
   public void testHandlesFileUris() throws IOException {
     Uri fileUri = Uri.fromFile(new File("f"));
-    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
     assertEquals(localUriFetcher,
@@ -59,7 +53,7 @@ public void testHandlesFileUris() throws IOException {
   @Test
   public void testHandlesResourceUris() throws IOException {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
     assertEquals(localUriFetcher,
@@ -69,14 +63,10 @@ public void testHandlesResourceUris() throws IOException {
   @Test
   public void testHandlesContentUris() {
     Uri contentUri = Uri.parse("content://com.bumptech.glide");
-    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
     assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
         options).fetcher);
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 0edbdf3c2..0c87d5f1b 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -15,7 +15,7 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,8 +26,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BaseGlideUrlLoaderTest {
@@ -101,9 +99,9 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
     int width = 400;
     int height = 500;
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
         assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
         return null;
@@ -147,4 +145,4 @@ public boolean handles(Object model) {
       return true;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 35dc69180..92efc86ce 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,15 +7,15 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
 public class HttpGlideUrlLoaderTest {
   private HttpGlideUrlLoader loader;
   private GlideUrl model;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index ba7b6ef94..92dae6dbb 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -5,11 +5,11 @@
 import static org.mockito.Mockito.verify;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import java.io.InputStream;
+import java.net.MalformedURLException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,9 +18,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-import java.net.MalformedURLException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUriLoaderTest {
@@ -71,4 +68,4 @@ public void testHandlesMostlyInvalidHttpUris() {
         .buildLoadData(eq(new GlideUrl(mostlyInvalidHttpUri.toString())), eq(IMAGE_SIDE),
             eq(IMAGE_SIDE), eq(OPTIONS));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index a20a7b2db..78b851f22 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -10,12 +10,12 @@
 @RunWith(JUnit4.class)
 public class SimpleResourceTest {
   private Anything object;
-  private SimpleResource resource;
+  private SimpleResource<?> resource;
 
   @Before
   public void setUp() {
     object = new Anything();
-    resource = new SimpleResource(object);
+    resource = new SimpleResource<>(object);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index 37f5ebed0..d5dc77761 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -1,39 +1,48 @@
 package com.bumptech.glide.load.resource;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 
+import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
 
+  private Application app;
+
+  @Before
+  public void setUp() {
+    app = RuntimeEnvironment.application;
+  }
+
   @Test
   public void testReturnsGivenResource() {
-    Resource resource = mock(Resource.class);
-    UnitTransformation transformation = UnitTransformation.get();
-    assertEquals(resource, transformation.transform(resource, 10, 10));
+    Resource<Object> resource = mockResource();
+    UnitTransformation<Object> transformation = UnitTransformation.get();
+    assertEquals(resource, transformation.transform(app, resource, 10, 10));
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
     KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
 
-    Transformation<Object> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
     KeyAssertions.assertDifferent(UnitTransformation.get(), other);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index 15d6e505b..c65b03707 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -8,9 +8,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index 78ba2efc9..b5fa17830 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.anyContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
@@ -9,15 +10,19 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +35,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapDrawableTransformationTest {
@@ -44,32 +46,41 @@
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
     when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
-    transformation = new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool,
-        wrapped);
+    transformation = new BitmapDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Object>() {
+    when(wrapped.transform(
+        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @SuppressWarnings("unchecked")
           @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return invocation.getArguments()[0];
+          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+            return (Resource<Bitmap>) invocation.getArguments()[1];
           }
         });
 
-    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,
-        outWidth, outHeight);
+    Resource<BitmapDrawable> transformed =
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed).isEqualTo(drawableResourceToTransform);
   }
@@ -80,13 +91,13 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
     int outHeight = 555;
 
     Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
-    Resource<Bitmap> transformedBitmapResource = mock(Resource.class);
+    Resource<Bitmap> transformedBitmapResource = Util.mockResource();
     when(transformedBitmapResource.get()).thenReturn(transformedBitmap);
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
         .thenReturn(transformedBitmapResource);
 
     Resource<BitmapDrawable> transformed =
-        transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);
   }
@@ -95,16 +106,16 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
   public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
     int outWidth = 332;
     int outHeight = 111;
-    Resource<Bitmap> transformed = mock(Resource.class);
+    Resource<Bitmap> transformed = Util.mockResource();
     when(transformed.get())
         .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));
-    when(wrapped.transform(any(Resource.class), anyInt(), anyInt()))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
         .thenReturn(transformed);
 
-    transformation.transform(drawableResourceToTransform, outWidth, outHeight);
-    ArgumentCaptor<Resource> captor = ArgumentCaptor.forClass(Resource.class);
+    transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
+    ArgumentCaptor<Resource<Bitmap>> captor = Util.cast(ArgumentCaptor.forClass(Resource.class));
 
-    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));
+    verify(wrapped).transform(anyContext(), captor.capture(), eq(outWidth), eq(outHeight));
 
     assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);
   }
@@ -113,13 +124,11 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, wrapped));
+    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
 
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, other));
+    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 60e3e3db7..876a2bdef 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-
+import android.os.Build;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -21,16 +23,9 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.File;
-import java.io.IOException;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -62,6 +57,7 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
   }
 
   @Test
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
@@ -107,9 +103,8 @@ private static void assertContains(String string, String expected) {
     assertThat(string).contains(expected);
   }
 
-  @SuppressWarnings("unchecked")
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = mockResource();
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     Options options = new Options();
     File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
@@ -137,21 +132,4 @@ public void tearDown() {
       file.delete();
     }
   }
-
-  @Implements(Bitmap.class)
-  public static class AlphaShadowBitmap extends ShadowBitmap {
-    private boolean hasAlpha;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index bd4da38d2..cb567b21f 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -1,19 +1,14 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.os.Build;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -58,24 +53,6 @@ public void testPutsBitmapInPoolOnRecycle() {
     verify(harness.bitmapPool).put(eq(harness.bitmap));
   }
 
-  @Test
-  public void testBitmapIsNotRecycledIfAcceptedByPool() {
-    when(harness.bitmapPool.put(eq(harness.bitmap))).thenReturn(true);
-
-    harness.resource.recycle();
-
-    assertFalse(harness.bitmap.isRecycled());
-  }
-
-  @Test
-  public void testRecyclesBitmapIfRejectedByPool() {
-    when(harness.bitmapPool.put(eq(harness.bitmap))).thenReturn(false);
-
-    harness.resource.recycle();
-
-    assertTrue(harness.bitmap.isRecycled());
-  }
-
   @Test(expected = NullPointerException.class)
   public void testThrowsIfBitmapIsNull() {
     new BitmapResource(null, mock(BitmapPool.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index 0d7000c43..d7d22f0c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -3,68 +3,82 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
-
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapTransformationTest {
 
   @Mock
   private BitmapPool bitmapPool;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
       @Override
-      protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
         return toTransform;
       }
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertEquals(resource, transformation.transform(resource, 1, 1));
+    assertEquals(resource, transformation.transform(context, resource, 1, 1));
   }
 
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
       @Override
-      protected Bitmap transform(BitmapPool pool, Bitmap bitmap, int outWidth, int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
+          int outHeight) {
         return transformed;
       }
     };
 
     Resource<Bitmap> resource = mockResource(1, 2);
-    assertNotSame(resource, transformation.transform(resource, 100, 100));
+    assertNotSame(resource, transformation.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -72,12 +86,13 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
       @Override
-      protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
         assertEquals(bitmapPool, pool);
         assertEquals(resource.get(), toTransform);
         assertEquals(expectedWidth, outWidth);
@@ -86,57 +101,58 @@ protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, in
       }
     };
 
-    transformation.transform(resource, expectedWidth, expectedHeight);
+    transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
       @Override
-      protected Bitmap transform(BitmapPool bitmapPool, Bitmap toTransform, int outWidth,
-          int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
         return null;
       }
     };
-    transformation.transform(mock(Resource.class), -1, 100);
+    transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
       @Override
-      protected Bitmap transform(BitmapPool bitmapPool, Bitmap toTransform, int outWidth,
-          int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
         return null;
       }
 
     };
-    transformation.transform(mock(Resource.class), 100, -1);
+    transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) {  }
 
       @Override
-      protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
+          int outWidth, int outHeight) {
         return null;
       }
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertNull(transform.transform(resource, 100, 100));
+    assertNull(transform.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -145,7 +161,7 @@ public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
 
     int expectedWidth = 200;
     Resource<Bitmap> resource = mockResource(expectedWidth, 300);
-    transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+    transform.transform(context, resource, Target.SIZE_ORIGINAL, 500);
 
     assertEquals(expectedWidth, transform.givenWidth);
   }
@@ -156,15 +172,14 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
 
     int expectedHeight = 500;
     Resource<Bitmap> resource = mockResource(123, expectedHeight);
-    transform.transform(resource, 444, expectedHeight);
+    transform.transform(context, resource, 444, expectedHeight);
 
     assertEquals(expectedHeight, transform.givenHeight);
   }
 
-  @SuppressWarnings("unchecked")
   private Resource<Bitmap> mockResource(int width, int height) {
     Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = Util.mockResource();
     when(resource.get()).thenReturn(bitmap);
     return resource;
   }
@@ -173,12 +188,9 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     int givenWidth;
     int givenHeight;
 
-    public SizeTrackingTransform() {
-      super(bitmapPool);
-    }
-
     @Override
-    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+    protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+        int outHeight) {
       givenWidth = outWidth;
       givenHeight = outHeight;
       return null;
@@ -187,4 +199,4 @@ protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, in
     @Override
     public void updateDiskCacheKey(MessageDigest messageDigest) { }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 267f7409a..a421660e0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -6,41 +6,45 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isNull;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class CenterCropTest {
   @Mock Resource<Bitmap> resource;
   @Mock BitmapPool pool;
+  @Mock Transformation<Bitmap> transformation;
 
   private CenterCrop centerCrop;
   private int bitmapWidth;
   private int bitmapHeight;
   private Bitmap bitmap;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -50,14 +54,25 @@ public void setUp() {
     bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    centerCrop = new CenterCrop(pool);
+    when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+
+    centerCrop = new CenterCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testDoesNotPutNullBitmapAcquiredFromPool() {
+    reset(pool);
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
 
-    centerCrop.transform(resource, 100, 100);
+    centerCrop.transform(context, resource, 100, 100);
 
     verify(pool, never()).put(any(Bitmap.class));
   }
@@ -65,32 +80,21 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+    centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
-  @Test
-  public void testDoesPutNonNullBitmapAcquiredFromPoolWhenUnused() {
-    Bitmap fromPool =
-        Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
-    when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(fromPool);
-
-    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
-
-    verify(pool).put(eq(fromPool));
-  }
-
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerCrop.transform(resource, 50, 50);
+    centerCrop.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
@@ -99,7 +103,7 @@ public void testDoesNotRecycleGivenResource() {
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
     Shadows.shadowOf(bitmap).setConfig(null);
 
-    centerCrop.transform(resource, 10, 10);
+    centerCrop.transform(context, resource, 10, 10);
 
     verify(pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
     verify(pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
@@ -110,14 +114,13 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
     int expectedWidth = 75;
     int expectedHeight = 74;
 
-    Resource<Bitmap> resource = mock(Resource.class);
     for (int[] dimens : new int[][] { new int[] { 800, 200 }, new int[] { 450, 100 },
         new int[] { 78, 78 } }) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -129,14 +132,13 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
     int expectedWidth = 100;
     int expectedHeight = 100;
 
-    Resource<Bitmap> resource = mock(Resource.class);
     for (int[] dimens : new int[][] { new int[] { 50, 90 }, new int[] { 150, 2 },
         new int[] { 78, 78 } }) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -145,11 +147,10 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop(pool));
+    KeyAssertions.assertSame(centerCrop, new CenterCrop());
 
-    Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerCrop, other);
+    KeyAssertions.assertDifferent(centerCrop, transformation);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
new file mode 100644
index 000000000..ebb4129a8
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -0,0 +1,127 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+public class CenterInsideTest {
+
+  @Mock Resource<Bitmap> resource;
+  @Mock Transformation<Bitmap> transformation;
+  private CenterInside centerInside;
+  private int bitmapWidth;
+  private int bitmapHeight;
+  private Application context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    context = RuntimeEnvironment.application;
+    BitmapPool pool = new BitmapPoolAdapter();
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+
+    centerInside = new CenterInside();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfSmallerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(context, resource, 150, 150);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsNewResourceIfLargerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(context, resource, 50, 50);
+
+    assertNotEquals(resource, result);
+  }
+
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    centerInside.transform(context, resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(centerInside, new CenterInside());
+
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(centerInside, transformation);
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index de6aa6c0e..740472103 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -1,17 +1,21 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Rect;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import com.bumptech.glide.tests.Util;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +35,16 @@
   @Before
   public void setup() {
     MockitoAnnotations.initMocks(this);
-    circleCrop = new CircleCrop(RuntimeEnvironment.application);
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+    Context context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    circleCrop = new CircleCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -83,20 +96,18 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
     }
   }
 
-  @TargetApi(12)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
-    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    int minEdge = Math.min(width, height);
+    float radius = minEdge / 2f;
+
+    Bitmap result = Bitmap.createBitmap(minEdge, minEdge, Bitmap.Config.ARGB_8888);
     result.setHasAlpha(true);
     Canvas canvas = new Canvas(result);
     Paint paint = new Paint();
+    paint.setAntiAlias(true);
     paint.setColor(Color.RED);
 
-    int minEdge = Math.min(width, height);
-    float radius = minEdge / 2f;
-    int left = (width - minEdge) / 2;
-    int top = (height - minEdge) / 2;
-
-    canvas.drawCircle(left + radius, top + radius, radius, paint);
+    canvas.drawCircle(radius, radius, radius, paint);
     return result;
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..40b9bfb7a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,402 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    DefaultImageHeaderParser parser =
+        new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+        (byte) 0xE5,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    protected SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    protected PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    protected PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
index f68d1e556..c6a624025 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -91,11 +91,11 @@ public void testAtLeast_withSourceGreaterInOneDimension_returnsScaleFactorOfSmal
 
   @Test
   public void testCenterInside_scalesImageToFitWithinRequestedBounds() {
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 200, 300, 300))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300))
         .isEqualTo(300 / 200f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(270, 480, 724, 440))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440))
         .isEqualTo(440 / 480f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index e25fcd87f..4cbfc7e49 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -8,36 +8,45 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.os.Build;
 import android.util.DisplayMetrics;
-
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
+import com.bumptech.glide.tests.Util;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Matchers;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
 public class DownsamplerTest {
   @Mock private BitmapPool bitmapPool;
-  @Mock private ByteArrayPool byteArrayPool;
+  @Mock private ArrayPool byteArrayPool;
   private Downsampler downsampler;
   private Options options;
+  private int initialSdkVersion;
 
   @Before
   public void setUp() throws Exception {
@@ -45,9 +54,20 @@ public void setUp() throws Exception {
     options = new Options();
     DisplayMetrics displayMetrics =
         RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt()))
-        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+    when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
+        .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
   }
 
   @Test
@@ -108,7 +128,7 @@ public void testCalculateScaling_withAtLeast() {
 
   @Test
   public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_INSIDE;
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
     runScaleTest(100, 100, 100, 100, strategy, 100, 100);
     runScaleTest(200, 200, 100, 100, strategy, 100, 100);
     runScaleTest(400, 400, 100, 100, strategy, 100, 100);
@@ -148,9 +168,34 @@ public void testCalculateScaling_withNone() {
     runScaleTest(87, 78, 100, 100, strategy, 87, 78);
   }
 
+  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
+  @Test
+  public void testCalculateScaling_withWbmp() {
+    Util.setSdkVersionInt(23);
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
+    BitmapFactory.Options options = new BitmapFactory.Options();
+
+    options.outMimeType = "image/vnd.wap.wbmp";
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
+    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
+  }
+
   private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
       int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
+    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
+        expectedHeight, new BitmapFactory.Options());
+  }
+
+  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
+      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
+      BitmapFactory.Options options) {
     Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
         options);
     assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
@@ -177,4 +222,14 @@ private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compress
     bitmap.compress(compressFormat, 100, os);
     return new ByteArrayInputStream(os.toByteArray());
   }
+
+  // Robolectric doesn't implement getAllocationByteCount correctly.
+  @Implements(Bitmap.class)
+  public static class AllocationSizeBitmap extends ShadowBitmap {
+
+    @Implementation
+    public int getAllocationByteCount() {
+      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 6e88d6388..65b073205 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -2,41 +2,49 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
-
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
 public class FitCenterTest {
 
-  @Mock BitmapPool pool;
   @Mock Resource<Bitmap> resource;
+  @Mock Transformation<Bitmap> transformation;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -46,47 +54,57 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    fitCenter = new FitCenter(pool);
-  }
+    BitmapPool pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
 
-  @Test
-  public void testDoesNotPutNullBitmapAcquiredFromPool() {
-    when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
 
-    fitCenter.transform(resource, 100, 100);
+    fitCenter = new FitCenter();
+  }
 
-    verify(pool, never()).put(any(Bitmap.class));
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+    fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    fitCenter.transform(resource, 50, 50);
+    fitCenter.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter(pool));
+    KeyAssertions.assertSame(fitCenter, new FitCenter());
 
-    Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(fitCenter, other);
+    KeyAssertions.assertDifferent(fitCenter, transformation);
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index dc6a6ac85..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private LruByteArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(-1, parser.getOrientation());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    ImageHeaderParser parser =
-        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
-    assertEquals(ImageType.PNG, parser.getType());
-  }
-
-  private interface ParserTestCase {
-    void run(ImageHeaderParser parser) throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruByteArrayPool());
-    test.run(parser);
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruByteArrayPool());
-    test.run(parser);
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index 22b548b5c..3260f51ae 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -7,19 +7,18 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RecyclableBufferedInputStreamTest {
@@ -29,7 +28,7 @@
 
   private RecyclableBufferedInputStream stream;
   private byte[] data;
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   @Before
   public void setUp() {
@@ -38,7 +37,7 @@ public void setUp() {
       data[i] = (byte) i;
     }
 
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
     InputStream wrapped = new ByteArrayInputStream(data);
     stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);
   }
@@ -288,4 +287,4 @@ public void testResetThrowsIfMarkIsInvalid() throws IOException {
     stream.read();
     stream.reset();
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index f2642757f..ae6264663 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -3,25 +3,27 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.media.ExifInterface;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
-
+import com.google.common.collect.Range;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
@@ -34,14 +36,22 @@
     TransformationUtilsTest.AlphaShadowBitmap.class })
 public class TransformationUtilsTest {
 
+  @Mock BitmapPool bitmapPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Util.CreateBitmap());
+  }
+
   @Test
   public void testFitCenterWithWideBitmap() {
     final int maxSide = 500;
 
     Bitmap wide = Bitmap.createBitmap(2000, 100, Bitmap.Config.ARGB_8888);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(wide, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, wide, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(wide, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -53,8 +63,7 @@ public void testFitCenterWithSmallWideBitmap() {
 
     Bitmap smallWide = Bitmap.createBitmap(400, 40, Bitmap.Config.ARGB_8888);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(smallWide, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallWide, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(smallWide, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -66,8 +75,7 @@ public void testFitCenterWithTallBitmap() {
 
     Bitmap tall = Bitmap.createBitmap(65, 3000, Bitmap.Config.ARGB_8888);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(tall, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, tall, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(tall, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -79,8 +87,7 @@ public void testFitCenterWithSmallTallBitmap() {
 
     Bitmap smallTall = Bitmap.createBitmap(10, 400, Bitmap.Config.ARGB_8888);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(smallTall, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallTall, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(smallTall, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -91,9 +98,7 @@ public void testFitCenterWithSquareBitmap() {
     final int maxSide = 500;
 
     Bitmap square = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888);
-
-    Bitmap transformed =
-        TransformationUtils.fitCenter(square, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, square, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(square, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -105,8 +110,7 @@ public void testFitCenterWithTooSmallSquareBitmap() {
 
     Bitmap smallSquare = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(smallSquare, mock(BitmapPool.class), maxSide, maxSide);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, smallSquare, maxSide, maxSide);
 
     assertHasOriginalAspectRatio(smallSquare, transformed);
     assertBitmapFitsExactlyWithinBounds(maxSide, transformed);
@@ -117,8 +121,7 @@ public void testFitCenterWithTooSmallSquareBitmap() {
   public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
     Bitmap toTransform = Bitmap.createBitmap(1230, 1640, Bitmap.Config.RGB_565);
 
-    Bitmap transformed =
-        TransformationUtils.fitCenter(toTransform, mock(BitmapPool.class), 1075, 1366);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toTransform, 1075, 1366);
 
     assertEquals(1024, transformed.getWidth());
     assertEquals(1366, transformed.getHeight());
@@ -127,8 +130,8 @@ public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
   @Test
   public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
     Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-    Bitmap transformed =
-        TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight());
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(),
+        toFit.getHeight());
     assertTrue(toFit == transformed);
   }
 
@@ -136,7 +139,7 @@ public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
   public void testFitCenterReturnsGivenBitmapIfGivenBitmapWidthMatchesExactly() {
     Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
     Bitmap transformed =
-        TransformationUtils.fitCenter(toFit, null, toFit.getWidth(), toFit.getHeight() * 2);
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(), toFit.getHeight() * 2);
     assertTrue(toFit == transformed);
   }
 
@@ -144,22 +147,15 @@ public void testFitCenterReturnsGivenBitmapIfGivenBitmapWidthMatchesExactly() {
   public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
     Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
     Bitmap transformed =
-        TransformationUtils.fitCenter(toFit, null, toFit.getWidth() * 2, toFit.getHeight());
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth() * 2, toFit.getHeight());
     assertTrue(toFit == transformed);
   }
 
-  @Test
-  public void testCenterCropReturnsNullIfGivenBitmapIsNull() {
-    Bitmap transformed =
-        TransformationUtils.centerCrop(null /*recycled*/, null /*toCrop*/, 100, 100);
-    assertNull(transformed);
-  }
-
   @Test
   public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDimensions() {
     Bitmap toCrop = Bitmap.createBitmap(200, 300, Bitmap.Config.ARGB_8888);
     Bitmap transformed = TransformationUtils
-        .centerCrop(null /*recycled*/, toCrop, toCrop.getWidth(), toCrop.getHeight());
+        .centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
 
     // Robolectric incorrectly implements equals() for Bitmaps, we want the original object not
     // just an equivalent.
@@ -170,7 +166,7 @@ public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDime
   public void testFitCenterHandlesBitmapsWithNullConfigs() {
     Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     Shadows.shadowOf(toFit).setConfig(null);
-    Bitmap transformed = TransformationUtils.fitCenter(toFit, mock(BitmapPool.class), 50, 50);
+    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, 50, 50);
     assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
   }
 
@@ -179,12 +175,15 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888)))
+        .thenReturn(toReuse);
 
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils
-        .centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -196,12 +195,14 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
+    reset(bitmapPool);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888))).thenReturn(toReuse);
 
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils
-        .centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -213,8 +214,8 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils
-        .centerCrop(null, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
@@ -224,7 +225,7 @@ public void testCenterCropHandlesBitmapsWithNullConfigs() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     Shadows.shadowOf(toTransform).setConfig(null);
 
-    Bitmap transformed = TransformationUtils.centerCrop(null /*recycled*/, toTransform, 50, 50);
+    Bitmap transformed = TransformationUtils.centerCrop(bitmapPool, toTransform, 50, 50);
 
     assertEquals(Bitmap.Config.ARGB_8888, transformed.getConfig());
   }
@@ -235,8 +236,8 @@ public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha(
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils
-        .centerCrop(null, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -246,15 +247,15 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
+    reset(bitmapPool);
     when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
         .thenReturn(toReuse);
 
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils
-        .fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -266,15 +267,15 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
+    reset(bitmapPool);
     when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig())))
         .thenReturn(toReuse);
 
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils
-        .fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
+        toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -283,12 +284,11 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
   @Test
   public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool pool = mock(BitmapPool.class);
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils
-        .fitCenter(toTransform, pool, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
@@ -296,12 +296,11 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
   @Test
   public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool pool = mock(BitmapPool.class);
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils
-        .fitCenter(toTransform, pool, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
+        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -351,60 +350,45 @@ public void testRotateImage() {
     assertTrue(toRotate == zero);
 
     Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertThat(Shadows.shadowOf(ninety).getDescription()).contains("rotate=90.0");
     assertEquals(toRotate.getWidth(), toRotate.getHeight());
   }
 
   @Test
   public void testRotateImageExifReturnsGivenBitmapIfRotationIsNormal() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
     Bitmap toRotate = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
     // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
-    // not just an
-    // identical Bitmap, but our original Bitmap object back.
+    // not just an identical Bitmap, but our original Bitmap object back.
     Bitmap rotated =
-        TransformationUtils.rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_NORMAL);
+        TransformationUtils.rotateImageExif(bitmapPool, toRotate, ExifInterface.ORIENTATION_NORMAL);
     assertTrue(toRotate == rotated);
   }
 
   @Test
   public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
-    // not just an
-    // identical Bitmap, but our original Bitmap object back.
-    Bitmap rotated = TransformationUtils
-        .rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_UNDEFINED);
+    // not just an identical Bitmap, but our original Bitmap object back.
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
+        ExifInterface.ORIENTATION_UNDEFINED);
     assertTrue(toRotate == rotated);
   }
 
   @Test
   public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
     Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
     // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
-    // not just an
-    // identical Bitmap, but our original Bitmap object back.
-    Bitmap rotated = TransformationUtils.rotateImageExif(toRotate, bitmapPool, -1);
+    // not just an identical Bitmap, but our original Bitmap object back.
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate, -1);
     assertTrue(toRotate == rotated);
   }
 
-  @Test
-  public void testRotateImageExifHandlesEmptyBitmapPool() {
-    Bitmap toRotate = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_4444);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    assertNotNull(TransformationUtils
-        .rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_ROTATE_90));
-  }
-
   @Test
   public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     Shadows.shadowOf(toRotate).setConfig(null);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    Bitmap rotated = TransformationUtils
-        .rotateImageExif(toRotate, bitmapPool, ExifInterface.ORIENTATION_ROTATE_180);
+    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
+        ExifInterface.ORIENTATION_ROTATE_180);
     assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
   }
 
@@ -455,8 +439,6 @@ public void testInitializeMatrixSetsRotateOnRotation() {
   @Implements(Bitmap.class)
   public static class AlphaShadowBitmap extends ShadowBitmap {
 
-    private boolean hasAlpha;
-
     @Implementation
     public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       // Robolectric doesn't match the framework behavior with null configs, so we have to do so
@@ -464,15 +446,5 @@ public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       Preconditions.checkNotNull("Config must not be null");
       return ShadowBitmap.createBitmap(width, height, config);
     }
-
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
index b1716d3ac..4b034d2fc 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
@@ -10,11 +10,11 @@
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import java.io.FileDescriptor;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,9 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.FileDescriptor;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class VideoBitmapDecoderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index d6b4eee69..6537c6d43 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -9,9 +9,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -107,4 +105,4 @@ public int getOpacity() {
       return 0;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index 8935855c7..b1b5f3130 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,15 +4,13 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class FileDecoderTest {
 
@@ -32,4 +30,4 @@ public void testReturnsGivenFileAsResource() throws IOException {
 
     assertEquals(expected, decoded.get());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
index 17a67ab32..6cc0c5775 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertEquals;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class FileResourceTest {
 
@@ -25,4 +24,4 @@ public void setUp() {
   public void testReturnsGivenFile() {
     assertEquals(file, resource.get());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index f403e3080..8c78f1de1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -12,11 +12,16 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,13 +32,11 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
@@ -57,9 +60,18 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
     options = new Options();
-    decoder = new ByteBufferGifDecoder(RuntimeEnvironment.application, bitmapPool,
-        new LruByteArrayPool(), parserPool, decoderFactory);
+    decoder =
+        new ByteBufferGifDecoder(
+            RuntimeEnvironment.application,
+            parsers,
+            bitmapPool,
+            new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
+            parserPool,
+            decoderFactory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 56e3b27d6..3d764e22d 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -22,14 +22,14 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
-
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -41,12 +41,9 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.util.HashSet;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
@@ -77,10 +74,11 @@ public void setUp() {
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
+    when(frameLoader.getCurrentIndex()).thenReturn(0);
     drawable.setCallback(cb);
     initialSdkVersion = Build.VERSION.SDK_INT;
   }
@@ -96,14 +94,14 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     drawable.draw(canvas);
 
     BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) ShadowExtractor.extract(canvas);
+        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
   @Test
   public void testDoesDrawCurrentFrameIfOneIsAvailable() {
     Canvas canvas = mock(Canvas.class);
-    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    Bitmap currentFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
 
     drawable.draw(canvas);
@@ -185,7 +183,7 @@ public void testReturnsTrueFromIsRunningWhenRunning() {
   @Test
   public void testInvalidatesSelfWhenFrameReady() {
     drawable.setIsRunning(true);
-    drawable.onFrameReady(0);
+    drawable.onFrameReady();
 
     verify(cb).invalidateDrawable(eq(drawable));
   }
@@ -194,36 +192,25 @@ public void testInvalidatesSelfWhenFrameReady() {
   public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
-    drawable.onFrameReady(0);
+    drawable.onFrameReady();
 
     verify(frameLoader).unsubscribe(eq(drawable));
   }
 
   @Test
-  public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testStopsWhenCurrentFrameFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
-    drawable.onFrameReady(0);
+    drawable.onFrameReady();
 
     assertFalse(drawable.isRunning());
   }
 
   @Test
-  public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
-    Util.setSdkVersionInt(10);
-
-    drawable.setIsRunning(true);
-    drawable.setCallback(null);
-    drawable.onFrameReady(0);
-
-    assertTrue(drawable.isRunning());
-  }
-
-  @Test
-  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
-    drawable.onFrameReady(0);
+    drawable.onFrameReady();
 
     verify(frameLoader).unsubscribe(eq(drawable));
   }
@@ -291,6 +278,24 @@ public void testReturnsFrameCountFromDecoder() {
     assertEquals(expected, drawable.getFrameCount());
   }
 
+  @Test
+  public void testReturnsDefaultFrameIndex() {
+    final int expected = -1;
+
+    when(frameLoader.getCurrentIndex()).thenReturn(expected);
+
+    assertEquals(expected, drawable.getFrameIndex());
+  }
+
+  @Test
+  public void testReturnsNonDefaultFrameIndex() {
+    final int expected = 100;
+
+    when(frameLoader.getCurrentIndex()).thenReturn(expected);
+
+    assertEquals(expected, drawable.getFrameIndex());
+  }
+
   @Test
   public void testRecycleCallsClearOnFrameManager() {
     drawable.recycle();
@@ -353,7 +358,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -369,6 +374,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
   @Test
@@ -384,7 +390,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -400,7 +406,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -410,17 +416,21 @@ public void testCallingStartResetsLoopCounter() {
     drawable.setVisible(true, true);
     drawable.start();
 
-    drawable.onFrameReady(0);
-    drawable.onFrameReady(1);
+    drawable.onFrameReady();
+    when(frameLoader.getCurrentIndex()).thenReturn(1);
+    drawable.onFrameReady();
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     drawable.start();
 
-    drawable.onFrameReady(0);
-    drawable.onFrameReady(1);
+    when(frameLoader.getCurrentIndex()).thenReturn(0);
+    drawable.onFrameReady();
+    when(frameLoader.getCurrentIndex()).thenReturn(1);
+    drawable.onFrameReady();
 
     // 4 onFrameReady(), 2 start()
     verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -434,6 +444,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     drawable.start();
 
     runLoops(initialLoopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     final int newLoopCount = 2;
 
@@ -445,6 +456,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     int numStarts = 2;
     int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
     verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test(expected = IllegalArgumentException.class)
@@ -453,7 +465,7 @@ public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
   }
 
   @Test
-  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {
     final int frameCount = 3;
     final int loopCount = 2;
     when(frameLoader.getLoopCount()).thenReturn(loopCount);
@@ -465,15 +477,33 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
+  @Test
+  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {
+    final int frameCount = 3;
+    final int loopCount = 40;
+    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
+  }
+
+
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
     drawable.setVisible(true, true);
     drawable.start();
     when(frameLoader.getCurrentFrame()).thenReturn(bitmap);
-    drawable.onFrameReady(1);
+    drawable.onFrameReady();
     drawable.recycle();
     Canvas canvas = mock(Canvas.class);
     drawable.draw(canvas);
@@ -521,6 +551,7 @@ public void testSetColorFilterSetsColorFilterOnPaint() {
 
   @Test
   public void testReturnsCurrentTransformationInGetFrameTransformation() {
+    @SuppressWarnings("unchecked")
     Transformation<Bitmap> newTransformation = mock(Transformation.class);
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable.setFrameTransformation(newTransformation, bitmap);
@@ -541,7 +572,10 @@ private void verifyRanLoops(int loopCount, int frameCount) {
   private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
-        drawable.onFrameReady(frame);
+        when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+            drawable.isRunning());
+        drawable.onFrameReady();
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index 120ad07a1..f73dc91a5 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.bumptech.glide.tests.Util.mockResource;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -8,44 +10,55 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifDrawableTransformationTest {
   @Mock Transformation<Bitmap> wrapped;
   @Mock BitmapPool bitmapPool;
 
-  GifDrawableTransformation transformation;
+  private GifDrawableTransformation transformation;
+  private Context context;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    transformation = new GifDrawableTransformation(wrapped, bitmapPool);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    transformation = new GifDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
+  @SuppressWarnings("unchecked")
   public void testSetsTransformationAsFrameTransformation() {
-    Resource<GifDrawable> resource = mock(Resource.class);
+    Resource<GifDrawable> resource = mockResource();
     GifDrawable gifDrawable = mock(GifDrawable.class);
     Transformation<Bitmap> unitTransformation = UnitTransformation.get();
     when(gifDrawable.getFrameTransformation()).thenReturn(unitTransformation);
@@ -59,11 +72,12 @@ public void testSetsTransformationAsFrameTransformation() {
     final int width = 123;
     final int height = 456;
     Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> expectedResource = mock(Resource.class);
+    Resource<Bitmap> expectedResource = mockResource();
     when(expectedResource.get()).thenReturn(expectedBitmap);
-    when(wrapped.transform(isA(Resource.class), anyInt(), anyInt())).thenReturn(expectedResource);
+    when(wrapped.transform(any(Context.class), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
+        .thenReturn(expectedResource);
 
-    transformation.transform(resource, width, height);
+    transformation.transform(context, resource, width, height);
 
     verify(gifDrawable).setFrameTransformation(isA(Transformation.class), eq(expectedBitmap));
   }
@@ -72,11 +86,11 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped, bitmapPool));
+    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
 
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other, bitmapPool));
+    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 759a88013..0ad477634 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -13,25 +13,26 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
-
+import com.google.common.testing.EqualsTester;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,9 +43,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.nio.ByteBuffer;
-import java.util.UUID;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
@@ -71,8 +69,29 @@ public void setUp() {
 
     requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
 
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
-        requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(handler);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @NonNull
+  private GifFrameLoader createGifFrameLoader(Handler handler) {
+    Glide glide = getGlideSingleton();
+    return new GifFrameLoader(
+        glide.getBitmapPool(),
+        requestManager,
+        gifDecoder,
+        handler,
+        requestBuilder,
+        transformation,
+        firstFrame);
+  }
+
+  private static Glide getGlideSingleton() {
+    return Glide.get(RuntimeEnvironment.application);
   }
 
   @SuppressWarnings("unchecked")
@@ -100,7 +119,7 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
     loader.subscribe(callback);
 
-    verify(requestBuilder).into(isA(Target.class));
+    verify(requestBuilder).into(aTarget());
   }
 
   @Test
@@ -109,8 +128,8 @@ public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingL
 
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
-    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
-    order.verify(requestBuilder).into(isA(Target.class));
+    order.verify(requestBuilder).apply(isA(RequestOptions.class));
+    order.verify(requestBuilder).into(aTarget());
   }
 
   @Test
@@ -133,14 +152,14 @@ public void testStartDoesNotStartIfAlreadyRunning() {
     loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(isA(Target.class));
+    verify(requestBuilder, never()).into(aTarget());
   }
 
   @Test
@@ -149,7 +168,7 @@ public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
@@ -160,7 +179,7 @@ public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
     loader.onFrameReady(mock(DelayTarget.class));
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
@@ -168,14 +187,13 @@ public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
     loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
   public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -192,9 +210,8 @@ public void testOnFrameReadyClearsPreviousFrame() {
 
   @Test
   public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
-     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
-        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null.
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -229,9 +246,8 @@ public void testDelayTargetSetsResourceOnResourceReady() {
 
   @Test
   public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-    // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null;
+    loader = createGifFrameLoader(null);
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Request request = mock(Request.class);
@@ -262,4 +278,9 @@ public void testFrameSignatureEquality() {
         new GifFrameLoader.FrameSignature(first))
         .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
   }
+
+  @SuppressWarnings("unchecked")
+  private static Target<Bitmap> aTarget() {
+    return isA(Target.class);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 2a4c28460..18c379433 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -6,19 +6,16 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameResourceDecoderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index bd4efeda5..f6d4eba4c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -2,10 +2,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +20,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamGifDecoderTest {
@@ -32,7 +34,10 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruByteArrayPool());
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 41fea2adc..9d8e2b1b1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.Resource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,19 +47,18 @@ public void testUsesGivenFormat() {
   }
 
   @Test
-  public void testBitampResourceIsRecycled() {
+  public void testBitmapResourceIsRecycled() {
     harness.getTranscodedDescription();
 
     verify(harness.bitmapResource).recycle();
   }
 
-  @SuppressWarnings("unchecked")
   private static class BitmapBytesTranscoderHarness {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
     final String description = "TestDescription";
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mock(Resource.class);
+    Resource<Bitmap> bitmapResource = mockResource();
 
     public BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index cb975b03f..62689518a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +30,7 @@ public void setUp() {
   @Test
   public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = mockResource();
     when(resource.get()).thenReturn(expected);
 
     Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 70e2a185a..1f6d4fd8f 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -1,30 +1,28 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertArrayEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
+import java.nio.ByteBuffer;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-
 @RunWith(JUnit4.class)
 public class GifDrawableBytesTranscoderTest {
   private GifDrawableBytesTranscoder transcoder;
   private GifDrawable gifDrawable;
   private Resource<GifDrawable> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     gifDrawable = mock(GifDrawable.class);
-    resource = mock(Resource.class);
+    resource = mockResource();
     when(resource.get()).thenReturn(gifDrawable);
     transcoder = new GifDrawableBytesTranscoder();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
index 2219e7720..28db86bbe 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -4,13 +4,12 @@
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Mockito.mock;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class TranscoderRegistryTest {
   private TranscoderRegistry factories;
@@ -26,8 +25,9 @@ public void testReturnsUnitDecoderIfClassesAreIdentical() {
   }
 
   @Test
-  public void testCanRegisterAndRetreiveResouceTranscoder() {
-    ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
+  public void testCanRegisterAndRetrieveResourceTranscoder() {
+    @SuppressWarnings("unchecked")
+    ResourceTranscoder<File, String> transcoder = mock(ResourceTranscoder.class);
     factories.register(File.class, String.class, transcoder);
 
     assertEquals(transcoder, factories.get(File.class, String.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index 19a33cfb9..a1d8eb507 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.load.engine.Resource;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -14,7 +13,7 @@
 
   @Test
   public void testReturnsTheGivenResource() {
-    Resource resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
 
     assertEquals(resource, unitTranscoder.transcode(resource));
diff --git a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
rename to library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index d1a14b0a1..e78445533 100644
--- a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -13,12 +13,12 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-public class ConnectivityMonitorFactoryTest {
+public class DefaultConnectivityMonitorFactoryTest {
   private ConnectivityMonitorFactory factory;
 
   @Before
   public void setUp() {
-    factory = new ConnectivityMonitorFactory();
+    factory = new DefaultConnectivityMonitorFactory();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 9a3a3a37d..32fa7111b 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -12,7 +12,7 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
-
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +24,6 @@
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DefaultConnectivityMonitorTest {
@@ -146,4 +144,4 @@ public void broadcast() {
       ShadowApplication.getInstance().sendBroadcast(connected);
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index b1feae1f1..570026f5d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -1,6 +1,10 @@
 package com.bumptech.glide.manager;
 
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Build;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
@@ -11,20 +15,19 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 
 /**
  * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
  */
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     ViewPager viewPager = new ViewPager(this);
     viewPager.setId(View.generateViewId());
-    setContentView(viewPager, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-        ViewGroup.LayoutParams.MATCH_PARENT));
+    setContentView(viewPager, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
     viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
index 3f2cc976d..df8bce1ae 100644
--- a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -4,15 +4,14 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LifecycleTest {
@@ -123,4 +122,4 @@ public void testNotifiesMultipleListeners() {
       verify(lifecycleListener).onDestroy();
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 1d863c384..3e3372e8e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -9,17 +9,15 @@
 
 import android.app.Activity;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -167,7 +165,7 @@ private void runTest(TestCase testCase) {
 
     ActivityFragmentLifecycle getFragmentLifecycle();
 
-    ActivityController getController();
+    ActivityController<?> getController();
 
     void onLowMemory();
 
@@ -218,7 +216,7 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -276,7 +274,7 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return supportController;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 0dd3828d3..97884942a 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -9,6 +9,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
@@ -16,12 +17,10 @@
 import android.os.Looper;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -31,8 +30,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
@@ -44,7 +43,7 @@
 
   @Before
   public void setUp() {
-    retriever = new RequestManagerRetriever();
+    retriever = new RequestManagerRetriever(null /*factory*/);
 
     harnesses =
         new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
@@ -205,7 +204,7 @@ public void testThrowsIfFragmentNotAttached() {
     retriever.get(fragment);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfSupportFragmentNotAttached() {
     Fragment fragment = new Fragment();
     retriever.get(fragment);
@@ -213,14 +212,14 @@ public void testThrowsIfSupportFragmentNotAttached() {
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfActivityDestroyed() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentActivityDestroyed() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
@@ -232,7 +231,7 @@ public void testThrowsIfGivenNullContext() {
 
   @Test
   public void testChecksIfContextIsFragmentActivity() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -240,7 +239,7 @@ public void testChecksIfContextIsFragmentActivity() {
 
   @Test
   public void testChecksIfContextIsActivity() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -248,9 +247,9 @@ public void testChecksIfContextIsActivity() {
 
   @Test
   public void testHandlesContextWrappersForActivities() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
-    ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());
+    ContextWrapper contextWrapper = new ContextWrapper(harness.getController().get());
 
     assertEquals(requestManager, retriever.get(contextWrapper));
   }
@@ -306,16 +305,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
-    Activity activity = mock(Activity.class);
-    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
-    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(activity));
-  }
-
-  @Test
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -326,19 +316,7 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
   }
 
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
-    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-    android.app.Fragment fragment = new android.app.Fragment();
-
-    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
-    android.app.Fragment spyFragment = Mockito.spy(fragment);
-    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(spyFragment));
-  }
-
-  @Test
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -352,14 +330,13 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
   }
 
   private interface RetrieverHarness {
+    ActivityController<?> getController();
 
-    public ActivityController getController();
-
-    public RequestManager doGet();
+    RequestManager doGet();
 
-    public boolean hasFragmentWithTag(String tag);
+    boolean hasFragmentWithTag(String tag);
 
-    public void addFragmentWithTag(String tag, RequestManager manager);
+    void addFragmentWithTag(String tag, RequestManager manager);
   }
 
   public class DefaultRetrieverHarness implements RetrieverHarness {
@@ -378,7 +355,7 @@ public DefaultRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -421,7 +398,7 @@ public SupportRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 7aa49fcf5..889cd2ba2 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -65,7 +64,7 @@ public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturn
   }
 
   @Test
-  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void testClearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
     tracker.clearRemoveAndRecycle(request);
@@ -355,4 +354,4 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       return null;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 2d0af965c..3c7648274 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,10 +9,9 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,10 +20,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
@@ -155,4 +153,4 @@ public int hashCode() {
       return super.hashCode();
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
deleted file mode 100644
index 4ece015f0..000000000
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Transformation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class BaseRequestOptionsTest {
-
-  private TestOptions options;
-
-  @Before
-  public void setUp() {
-    options = new TestOptions();
-  }
-
-  @Test
-  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {
-    TestOptions other = new TestOptions();
-    other.transform(Object.class, mock(Transformation.class));
-    options.apply(other);
-    assertThat(options.isTransformationSet()).isTrue();
-  }
-
-  private static class TestOptions extends BaseRequestOptions<TestOptions> {
-    // Empty.
-  }
-}
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index 0087de11e..cc3c11cd0 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -13,9 +13,11 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
-
 import com.bumptech.glide.request.target.SizeReadyCallback;
-
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +26,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestFutureTargetTest {
@@ -79,17 +76,17 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
     future.cancel(true);
 
     verify(handler).post(eq(future));
   }
 
   @Test
-  public void testClearsOnMainThreadWhenClearCalled() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
     future.cancel(false);
 
-    verify(handler).post(eq(future));
+    verify(handler, never()).post(eq(future));
   }
 
   @Test
@@ -207,12 +204,20 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
     future.get();
   }
 
+  @Test
+  public void testGetSucceedsOnMainThreadIfDone()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.onResourceReady(new Object(), null);
+    future.get();
+  }
+
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         Thread.currentThread().interrupt();
         return null;
       }
@@ -224,9 +229,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.onLoadFailed(null);
         return null;
       }
@@ -237,9 +242,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = CancellationException.class)
   public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.cancel(false);
         return null;
       }
@@ -289,9 +294,9 @@ public void testDoesNotNotifyAllOnSecondCancel() {
   public void testReturnsResourceIfReceivedWhileWaiting()
       throws ExecutionException, InterruptedException {
     final Object expected = new Object();
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.onResourceReady(expected, null);
         return null;
       }
@@ -351,4 +356,4 @@ public void testDoesNotWaitIfGivenTimeOutEqualToZero() throws InterruptedExcepti
 
     verify(waiter, never()).waitForTimeout(eq(future), anyLong());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
new file mode 100644
index 000000000..23233e174
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.graphics.Bitmap;
+import com.bumptech.glide.load.Transformation;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RequestOptionsTest {
+
+  private RequestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new RequestOptions();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    RequestOptions other = new RequestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+@Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(transformation);
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index c10e64bdf..9d5457dff 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request;
 
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -7,6 +9,7 @@
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -17,9 +20,9 @@
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
@@ -31,7 +34,10 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,13 +46,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("rawtypes")
 public class SingleRequestTest {
   private RequestHarness harness;
 
@@ -54,26 +56,29 @@
    * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
    * Both are in the middle of the hierarchy having multiple descendants and ancestors.
    */
-  @SuppressWarnings("unchecked")
   private static class RequestHarness {
     Engine engine = mock(Engine.class);
     Number model = 123456;
+    @SuppressWarnings("unchecked")
     Target<List> target = mock(Target.class);
-    Resource<List> resource = mock(Resource.class);
+    Resource<List> resource = mockResource();
     RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
     Drawable placeholderDrawable = null;
     Drawable errorDrawable = null;
     Drawable fallbackDrawable = null;
+    @SuppressWarnings("unchecked")
     RequestListener<List> requestListener = mock(RequestListener.class);
+    @SuppressWarnings("unchecked")
     TransitionFactory<List> factory = mock(TransitionFactory.class);
     int overrideWidth = -1;
     int overrideHeight = -1;
-    List result = new ArrayList();
+    List<?> result = new ArrayList<>();
     GlideContext glideContext = mock(GlideContext.class);
     Key signature = mock(Key.class);
     Priority priority = Priority.HIGH;
+    boolean useUnlimitedSourceGeneratorsPool = false;
 
-    Map<Class<?>, Transformation<?>>  transformations = new HashMap<Class<?>, Transformation<?>>();
+    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
 
     public RequestHarness() {
       when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
@@ -88,7 +93,8 @@ public RequestHarness() {
         .fallback(fallbackDrawable)
         .override(overrideWidth, overrideHeight)
         .priority(priority)
-        .signature(signature);
+        .signature(signature)
+        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest
           .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
               priority, target, requestListener, requestCoordinator, engine, factory);
@@ -111,11 +117,11 @@ public void testIsNotCompleteBeforeReceivingResource() {
   public void testCanHandleNullResources() {
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(null);
+    request.onResourceReady(null, DataSource.LOCAL);
 
     assertTrue(request.isFailed());
-    verify(harness.requestListener)
-        .onLoadFailed(any(Number.class), eq(harness.target), anyBoolean());
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
+        eq(harness.target), anyBoolean());
   }
 
   @Test
@@ -123,12 +129,12 @@ public void testCanHandleEmptyResources() {
     SingleRequest<List> request = harness.getRequest();
     when(harness.resource.get()).thenReturn(null);
 
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
 
     assertTrue(request.isFailed());
     verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener)
-        .onLoadFailed(any(Number.class), eq(harness.target), anyBoolean());
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean());
   }
 
   @Test
@@ -137,19 +143,19 @@ public void testCanHandleNonConformingResources() {
     when(((Resource) (harness.resource)).get())
         .thenReturn("Invalid mocked String, this should be a List");
 
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     assertTrue(request.isFailed());
     verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener)
-        .onLoadFailed(any(Number.class), eq(harness.target), anyBoolean());
+    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean());
   }
 
   @Test
   public void testIsNotFailedAfterClear() {
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(null);
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
     request.clear();
 
     assertFalse(request.isFailed());
@@ -185,7 +191,7 @@ public void testIsNotPausedAfterBeginningWhilePaused() {
   public void testIsNotFailedAfterBegin() {
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(null);
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
     request.begin();
 
     assertFalse(request.isFailed());
@@ -195,7 +201,7 @@ public void testIsNotFailedAfterBegin() {
   public void testIsCompleteAfterReceivingResource() {
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
 
     assertTrue(request.isComplete());
   }
@@ -203,7 +209,7 @@ public void testIsCompleteAfterReceivingResource() {
   @Test
   public void testIsNotCompleteAfterClear() {
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
     request.clear();
 
     assertFalse(request.isComplete());
@@ -241,7 +247,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     harness.requestCoordinator = requestCoordinator;
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(requestCoordinator).canSetImage(eq(request));
   }
@@ -272,7 +278,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -291,7 +297,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -307,7 +313,7 @@ public void testEngineLoadCancelledOnCancel() {
   public void testResourceIsRecycledOnClear() {
     SingleRequest<List> request = harness.getRequest();
 
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
     request.clear();
 
     verify(harness.engine).release(eq(harness.resource));
@@ -348,7 +354,7 @@ public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    harness.placeholderDrawable = placeholder;
+    harness.errorDrawable = placeholder;
     harness.target = target;
     harness.model = null;
     SingleRequest<List> request = harness.getRequest();
@@ -411,7 +417,7 @@ public void testIsRunningAfterRunCalled() {
   public void testIsNotRunningAfterComplete() {
     SingleRequest<List> request = harness.getRequest();
     request.begin();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
 
     assertFalse(request.isRunning());
   }
@@ -438,31 +444,31 @@ public void testIsNotRunningAfterClear() {
   public void testCallsTargetOnResourceReadyIfNoRequestListener() {
     harness.requestListener = null;
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
 
-    verify(harness.target).onResourceReady(eq(harness.result), any(Transition.class));
+    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
   }
 
   @Test
   public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
     SingleRequest<List> request = harness.getRequest();
     when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), anyBoolean(),
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
             anyBoolean())).thenReturn(false);
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
 
-    verify(harness.target).onResourceReady(eq(harness.result), any(Transition.class));
+    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
   }
 
   @Test
   public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
     SingleRequest<List> request = harness.getRequest();
     when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), anyBoolean(),
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
             anyBoolean())).thenReturn(true);
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.REMOTE);
 
-    verify(harness.target, never()).onResourceReady(any(List.class), any(Transition.class));
+    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());
   }
 
   @Test
@@ -477,8 +483,8 @@ public void testCallsTargetOnExceptionIfNoRequestListener() {
   @Test
   public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
     SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onLoadFailed(any(Number.class), eq(harness.target), anyBoolean()))
+    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean()))
         .thenReturn(false);
     request.onLoadFailed(new GlideException("test"));
 
@@ -488,8 +494,8 @@ public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
   @Test
   public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
     SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onLoadFailed(any(Number.class), eq(harness.target), anyBoolean()))
+    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(harness.target), anyBoolean()))
         .thenReturn(true);
 
     request.onLoadFailed(new GlideException("test"));
@@ -500,30 +506,30 @@ public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
   @Test
   public void testRequestListenerIsCalledWithResourceResult() {
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), anyBoolean(),
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
             anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithModel() {
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(any(List.class), eq(harness.model), any(Target.class), anyBoolean(),
+        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),
             anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithTarget() {
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), anyBoolean(),
+        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
             anyBoolean());
   }
 
@@ -535,11 +541,12 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
-            request.onResourceReady(harness.resource);
+            request.onResourceReady(harness.resource, DataSource.MEMORY_CACHE);
             return null;
           }
         });
@@ -547,8 +554,8 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     request.begin();
     request.onSizeReady(100, 100);
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), eq(true),
-            anyBoolean());
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -556,21 +563,21 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
   testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
     SingleRequest<List> request = harness.getRequest();
     request.onSizeReady(100, 100);
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
 
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), eq(false),
-            anyBoolean());
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
     harness.requestCoordinator = null;
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), anyBoolean(),
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
             eq(true));
   }
 
@@ -578,10 +585,10 @@ public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator
   public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
     SingleRequest<List> request = harness.getRequest();
     when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), anyBoolean(),
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
             eq(true));
   }
 
@@ -590,19 +597,19 @@ public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturns
   testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
     SingleRequest<List> request = harness.getRequest();
     when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), any(Target.class), anyBoolean(),
-            eq(false));
+        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
+            isADataSource(), eq(false));
   }
 
   @Test
   public void testTargetIsCalledWithAnimationFromFactory() {
     SingleRequest<List> request = harness.getRequest();
-    Transition<List> transition = mock(Transition.class);
-    when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(transition);
-    request.onResourceReady(harness.resource);
+    Transition<List> transition = mockTransition();
+    when(harness.factory.build(any(DataSource.class), anyBoolean())).thenReturn(transition);
+    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
 
     verify(harness.target).onResourceReady(eq(harness.result), eq(transition));
   }
@@ -649,7 +656,8 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -671,7 +679,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -679,13 +687,13 @@ public void testCanReRunCancelledRequests() {
     request.cancel();
     request.begin();
 
-    verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(Transition.class));
+    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());
   }
 
   @Test
   public void testResourceOnlyReceivesOneGetOnResourceReady() {
     SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource);
+    request.onResourceReady(harness.resource, DataSource.LOCAL);
 
     verify(harness.resource, times(1)).get();
   }
@@ -700,7 +708,65 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = true;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = false;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  // TODO do we want to move these to Util?
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> mockTransition() {
+    return mock(Transition.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<List> isAListTarget() {
+    return isA(Target.class);
+  }
+
+  private static GlideException isAGlideException() {
+    return isA(GlideException.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> anyTransition() {
+    return any(Transition.class);
   }
 
   private static class CallResourceCallback implements Answer {
@@ -716,7 +782,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
       ResourceCallback cb =
           (ResourceCallback) invocationOnMock.getArguments()[invocationOnMock.getArguments().length
               - 1];
-      cb.onResourceReady(resource);
+      cb.onResourceReady(resource, DataSource.REMOTE);
       return null;
     }
   }
@@ -769,6 +835,11 @@ public void onResourceReady(List resource, Transition<? super List> transition)
     public void getSize(SizeReadyCallback cb) {
     }
 
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
     @Override
     public void setRequest(Request request) {
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index ad07d32c6..4ec3ed752 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.ComponentName;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,21 +18,20 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
     .UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
-
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
   private int viewId;
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) ShadowExtractor
+    shadowManager = (UpdateShadowAppWidgetManager) Shadow
         .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
@@ -43,7 +41,7 @@ public void setUp() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -55,7 +53,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName()
   public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -68,7 +66,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -80,7 +78,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -91,39 +89,39 @@ public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithWidgetIds() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithComponentName() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId, 1
-    /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId,
-        mock(ComponentName.class));
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (int[]) null /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsWhenGivenEmptyWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (ComponentName) null);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);
   }
 
   @Implements(AppWidgetManager.class)
@@ -144,4 +142,4 @@ public void updateAppWidget(ComponentName componentName, RemoteViews views) {
       updatedRemoteViews = views;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
index 59b0427cf..31e0bb5c6 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -5,7 +5,6 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,4 +31,4 @@ public void testSetsBitmapOnViewInSetResource() {
     target.setResource(bitmap);
     assertEquals(bitmap, ((BitmapDrawable) view.getDrawable()).getBitmap());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index 238151560..d0967ce08 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -8,7 +8,6 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,7 +40,7 @@ public void testReturnsTargetForBitmapDrawables() {
     BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
         Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
 
-    Target target = factory.buildTarget(view, BitmapDrawable.class);
+    Target<BitmapDrawable> target = factory.buildTarget(view, BitmapDrawable.class);
     target.onResourceReady(drawable, null);
     assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index 25fe2a622..eeb0b1fcf 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -12,9 +12,7 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -74,7 +72,7 @@ public void testSetsDrawableOnLoadCleared() {
 
   @Test
   public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
     Drawable resource = new ColorDrawable(Color.GRAY);
     target.onResourceReady(resource, animation);
@@ -85,7 +83,7 @@ public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
   @Test
   public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
     Drawable resource = new ColorDrawable(Color.RED);
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(eq(resource), eq(target))).thenReturn(true);
     target.onResourceReady(resource, animation);
 
@@ -97,7 +95,7 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     Drawable placeholder = new ColorDrawable(Color.BLACK);
     view.setImageDrawable(placeholder);
 
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
@@ -116,4 +114,4 @@ protected void setResource(Drawable resource) {
       this.resource = resource;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index 4dddd7b6c..eae33c7e4 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,36 +18,37 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
     .UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
-
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
   private int viewId;
   private Notification notification;
   private int notificationId;
+  private String notificationTag;
   private NotificationTarget target;
 
   @Before
   public void setUp() {
     NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
         .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) ShadowExtractor.extract(notificationManager);
+    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
     notification = mock(Notification.class);
     notificationId = 456;
+    notificationTag = "tag";
 
 
     target =
-        new NotificationTarget(RuntimeEnvironment.application, remoteViews, viewId, 100 /*width*/,
-            100 /*height*/, notification, notificationId);
+        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+            viewId, remoteViews, notification, notificationId, notificationTag);
   }
 
   @Test
@@ -64,38 +64,43 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
     /*glideAnimation*/);
 
     assertEquals(notificationId, shadowManager.updatedNotificationId);
+    assertEquals(notificationTag, shadowManager.updatedNotificationTag);
     assertEquals(notification, shadowManager.updatedNotification);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, mock(RemoteViews.class), 123 /*viewId*/,
-        100 /*width*/, 100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, null /*remoteViews*/, 123 /*viewId*/,
-        100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Implements(NotificationManager.class)
   public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
     int updatedNotificationId;
+    String updatedNotificationTag;
     Notification updatedNotification;
 
     @Implementation
-    public void notify(int notificationId, Notification notification) {
+    public void notify(String notificationTag, int notificationId, Notification notification) {
+      updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
       updatedNotification = notification;
     }
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index 4e69598d9..e5e397f41 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -6,7 +6,6 @@
 
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,4 +45,4 @@ public void testClearsTargetInOnResourceReady() {
 
     verify(requestManager).clear(eq(target));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 1363b4057..14e1362f7 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -3,7 +3,6 @@
 import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -63,4 +62,4 @@ public void onResourceReady(Object resource, Transition<? super Object> transiti
       }
     };
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 3debccfcd..a31adc29c 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -13,50 +13,56 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.view.View;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
-
+import com.bumptech.glide.tests.Util;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.shadows.ShadowDisplay;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
+@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
     ViewTargetTest.PreDrawShadowViewTreeObserver.class })
 public class ViewTargetTest {
   private View view;
-  private ViewTarget target;
+  private ViewTarget<View, Object> target;
   private SizedShadowView shadowView;
   private PreDrawShadowViewTreeObserver shadowObserver;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
 
   @Before
   public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
 
-    shadowView = (SizedShadowView) ShadowExtractor.extract(view);
-    shadowObserver =
-        (PreDrawShadowViewTreeObserver) ShadowExtractor.extract(view.getViewTreeObserver());
+    shadowView = Shadow.extract(view);
+    shadowObserver = Shadow.extract(view.getViewTreeObserver());
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(sdkVersion);
   }
 
   @Test
@@ -77,8 +83,6 @@ public void testThrowsIfViewTagIsNotRequestObject() {
 
   @Test
   public void testCanSetAndRetrieveRequest() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     assertEquals(request, target.getRequest());
@@ -86,8 +90,6 @@ public void testCanSetAndRetrieveRequest() {
 
   @Test
   public void testRetrievesRequestFromPreviousTargetForView() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     ViewTarget<View, Object> second = new TestViewTarget(view);
@@ -98,10 +100,11 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    shadowView.setWidth(dimens);
-    shadowView.setHeight(dimens);
+    shadowView
+        .setWidth(dimens)
+        .setHeight(dimens)
+        .setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
@@ -112,117 +115,84 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
     int dimens = 444;
     LayoutParams layoutParams = new LayoutParams(dimens, dimens);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
   }
 
-  private void setDisplayDimens(Integer width, Integer height) {
-    WindowManager windowManager =
-        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
-    if (width != null) {
-      shadowDisplay.setWidth(width);
-    }
-
-    if (height != null) {
-      shadowDisplay.setHeight(height);
-    }
-  }
-
-  private void setDisplayWidth(int width) {
-    setDisplayDimens(width, null);
-  }
-
-  private void setDisplayHeight(int height) {
-    setDisplayDimens(null, height);
-  }
-
   @Test
-  public void testBothParamsWrapContent() {
+  public void getSize_withBothWrapContent_returnsSizeOriginal() {
     LayoutParams layoutParams =
         new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    int width = 123;
-    int height = 456;
-    setDisplayDimens(width, height);
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithValidHeight() {
-    int displayWidth = 500;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndValidHeight_usesSizeOriginalWidthValidHeight() {
     int height = 100;
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithValidWidth() {
-    int displayHeight = 700;
-    setDisplayHeight(displayHeight);
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndSizeOriginalHeight() {
     int width = 100;
     LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithMatchParentHeight() {
-    int displayWidth = 1234;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int height = 32;
-    shadowView.setHeight(height);
+    shadowView
+        .setHeight(height)
+        .setIsLaidOut(true);
 
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithMatchParentWidth() {
-    int displayHeight = 5812;
-    setDisplayHeight(displayHeight);
-
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndSizeOriginalHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
-    shadowView.setWidth(width);
+    shadowView
+        .setWidth(width)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
@@ -230,15 +200,16 @@ public void testMatchParentWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
     int height = 45;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -246,13 +217,14 @@ public void testMatchParentWidthAndHeight() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 12;
     int height = 32;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -267,8 +239,10 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
     }
 
     int width = 100, height = 111;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     InOrder order = inOrder((Object[]) cbs);
@@ -279,11 +253,11 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
 
   @Test
   public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     target.getSize(cb);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
@@ -304,6 +278,7 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
     target.getSize(cb1);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
@@ -320,7 +295,6 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
 
   @Test
   public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -330,13 +304,13 @@ public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 689;
     int height = 354;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -344,11 +318,11 @@ public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutP
 
   @Test
   public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     LayoutParams layoutParams = new LayoutParams(1234, 4123);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -366,6 +340,7 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
     int height = 875;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -375,13 +350,13 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
 
   @Test
   public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 1;
     int height = 2;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.setIsAlive(false);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -393,8 +368,81 @@ public void testThrowsIfGivenNullView() {
     new TestViewTarget(null);
   }
 
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    view.setLayoutParams(new LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    shadowView.setIsLaidOut(true);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(10, 10))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_zeroWidthHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(0, 0))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSizeReady() {
+    Util.setSdkVersionInt(18);
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(true);
+
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
+  public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
@@ -442,13 +490,33 @@ public void fireOnPreDrawListeners() {
   public static class SizedShadowView extends ShadowView {
     private int width;
     private int height;
+    private LayoutParams layoutParams;
+    private boolean isLaidOut;
+    private boolean isLayoutRequested;
 
-    public void setWidth(int width) {
+    public SizedShadowView setWidth(int width) {
       this.width = width;
+      return this;
     }
 
-    public void setHeight(int height) {
+    public SizedShadowView setHeight(int height) {
       this.height = height;
+      return this;
+    }
+
+    public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
+      this.layoutParams = layoutParams;
+      return this;
+    }
+
+    public SizedShadowView setIsLaidOut(boolean isLaidOut) {
+      this.isLaidOut = isLaidOut;
+      return this;
+    }
+
+    @Implementation
+    public void requestLayout() {
+      isLayoutRequested = true;
     }
 
     @Implementation
@@ -460,6 +528,21 @@ public int getWidth() {
     public int getHeight() {
       return height;
     }
+
+    @Implementation
+    public boolean isLaidOut() {
+      return isLaidOut;
+    }
+
+    @Implementation
+    public boolean isLayoutRequested() {
+      return isLayoutRequested;
+    }
+
+    @Implementation
+    public LayoutParams getLayoutParams() {
+      return layoutParams;
+    }
   }
 
   private static class TestViewTarget extends ViewTarget<View, Object> {
@@ -479,7 +562,7 @@ public void onLoadFailed(Drawable errorDrawable) {
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition transition) {
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
 
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index 62bd959ab..98d37cb3d 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -5,7 +5,7 @@
 import static org.mockito.Mockito.mock;
 
 import android.graphics.drawable.Drawable;
-
+import com.bumptech.glide.load.DataSource;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,24 +22,25 @@
   @Before
   public void setUp() {
     ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/,
+        false /*isCrossFadeEnabled*/);
   }
 
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
     assertEquals(NoTransition.<Drawable>get(),
-        factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
     assertNotEquals(NoTransition.<Drawable>get(),
-        factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
 
   @Test
-  public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
+  public void testReturnsAnimationIfNotFromMemoryCacheAndNotIsFirstResource() {
     assertNotEquals(NoTransition.<Drawable>get(),
-        factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 78861713d..6ade60e8b 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -14,7 +14,6 @@
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -73,7 +72,7 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
     Transition<Drawable> defaultAnimation = mock(Transition.class);
     int duration = 200;
     DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration);
+        new DrawableCrossFadeTransition(defaultAnimation, duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
index 54ebaff3c..bdfef1c41 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
@@ -11,7 +11,6 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
index 52f429f4e..2b50c15d8 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
@@ -11,7 +11,6 @@
 
 import android.view.View;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
index 511735e61..831a9d047 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Mockito.mock;
 
+import com.bumptech.glide.load.DataSource;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,18 +24,18 @@ public void setUp() {
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
     assertEquals(NoTransition.get(),
-        factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/));
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsNoAnimationIfNotFirstResource() {
     assertEquals(NoTransition.get(),
-        factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/));
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
     assertNotEquals(NoTransition.get(),
-        factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/));
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
index f4d0eb7f3..6f1cb4ec5 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -11,7 +11,7 @@
 import android.content.Context;
 import android.view.View;
 import android.view.animation.Animation;
-
+import com.bumptech.glide.load.DataSource;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,18 +23,18 @@
 @Config(manifest = Config.NONE)
 public class ViewTransitionAnimationFactoryTest {
   private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
-  private ViewAnimationFactory factory;
+  private ViewAnimationFactory<Object> factory;
 
   @Before
   public void setUp() {
     viewTransitionAnimationFactory = mock(ViewTransition.ViewTransitionAnimationFactory.class);
-    factory = new ViewAnimationFactory(viewTransitionAnimationFactory);
+    factory = new ViewAnimationFactory<>(viewTransitionAnimationFactory);
   }
 
   @Test
   public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
     Transition<Object> animation =
-        factory.build(true /*isFromMemoryCache*/, true /*isFirstResource*/);
+        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
     assertEquals(NoTransition.get(), animation);
     verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
   }
@@ -42,7 +42,7 @@ public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
   @Test
   public void testFactoryReturnsNoAnimationIfNotFirstResource() {
     Transition<Object> animation =
-        factory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);
+        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/);
     assertEquals(NoTransition.get(), animation);
     verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
   }
@@ -50,7 +50,7 @@ public void testFactoryReturnsNoAnimationIfNotFirstResource() {
   @Test
   public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstResource() {
     Transition<Object> transition =
-        factory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);
+        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/);
 
     Animation animation = mock(Animation.class);
     when(viewTransitionAnimationFactory.build(any(Context.class))).thenReturn(animation);
@@ -62,4 +62,4 @@ public void testFactoryReturnsActualAnimationIfNotIsFromMemoryCacheAndIsFirstRes
 
     verify(view).startAnimation(eq(animation));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 2d92de3d4..95eaca505 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -3,24 +3,23 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifTest {
 
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   private InputStream open(String imageName) throws IOException {
     return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
@@ -30,7 +29,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
           expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -47,13 +46,13 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
   public void testIssue387() throws IOException {
     InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+    assertThat(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool)).isEqualTo(6);
   }
 
   @Test
@@ -73,11 +72,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES], byte[].class);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
index db9243466..7a55e9990 100644
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -4,7 +4,8 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -12,9 +13,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ApplicationVersionSignatureTest {
@@ -37,4 +35,4 @@ public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
     Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
     KeyAssertions.assertSame(first, second);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
index 00fa20ef8..7f465fb23 100644
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class MediaStoreSignatureTest {
 
@@ -47,4 +45,4 @@ public void testSignaturesAreTheSameIfAllArgsAreTheSame()
 
     KeyAssertions.assertSame(first, second);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
index d0d3222f9..21570323c 100644
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.security.NoSuchAlgorithmException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class ObjectKeyTest {
 
@@ -17,4 +15,4 @@ public void testEquals() throws NoSuchAlgorithmException {
     KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
     KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
deleted file mode 100644
index 1d68b8196..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class StringSignatureTest {
-
-  @Test
-  public void testStringSignatureIsNotEqualIfStringDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("first");
-    StringSignature second = new StringSignature("second");
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testStringSignatureIsEqualIfStringIsTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("signature");
-    StringSignature second = new StringSignature("signature");
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
index aa6adc361..326096bad 100644
--- a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -3,29 +3,32 @@
 import android.content.ContentResolver;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
-
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowContentResolver;
-
+import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
 
 @Implements(ContentResolver.class)
-public class ContentResolverShadow extends ShadowContentResolver {
-  private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+public class ContentResolverShadow {
+  private final Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+  private final Map<Uri, InputStream> inputStreamMap = new HashMap<>();
 
   public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
     fileDescriptorMap.put(uri, fileDescriptor);
   }
 
+  public void registerInputStream(Uri uri, InputStream inputStream) {
+    inputStreamMap.put(uri, inputStream);
+  }
+
+  @Implementation
+  public InputStream openInputStream(Uri uri) {
+    return inputStreamMap.get(uri);
+  }
+
   @Implementation
   public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
-    AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
-    if (fileDescriptor != null) {
-      return fileDescriptor;
-    } else {
-      return null;
-    }
+    return fileDescriptorMap.get(uri);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index f0ed18b27..ddd9d06b8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.tests;
 
 import android.util.Log;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLog;
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index c41e4a6f7..7b94a888c 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -4,7 +4,6 @@
 
 import android.os.Looper;
 import android.os.MessageQueue;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLooper;
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
index 80d7dc3a9..5ee17790a 100644
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
@@ -2,10 +2,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.testing.EqualsTester;
-
 import com.bumptech.glide.load.Key;
-
+import com.google.common.testing.EqualsTester;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index 42c77539d..e80796ba2 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -1,16 +1,17 @@
 package com.bumptech.glide.tests;
 
 import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.RETURNS_DEFAULTS;
+import static org.mockito.Mockito.mock;
 
+import android.content.Context;
+import android.graphics.Bitmap;
 import android.os.Build;
-
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.util.ReflectionHelpers;
-
+import com.bumptech.glide.load.engine.Resource;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -18,15 +19,52 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.security.MessageDigest;
+import org.mockito.ArgumentCaptor;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.util.ReflectionHelpers;
 
+// FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class clazz) {
+  public static String getExpectedClassId(Class<?> clazz) {
     return clazz.getSimpleName() + "." + clazz.getPackage().getName();
   }
 
-  public static void assertClassHasValidId(Class clazz, String id) {
-    assertEquals(getExpectedClassId(clazz), id);
+  /**
+   * Gives the proper generic type to the {@link ArgumentCaptor}.
+   * Only useful when the captor's {@code T} is also a generic type.
+   * Without this it's really ugly to have a properly typed captor object.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> ArgumentCaptor<T> cast(ArgumentCaptor<?> captor) {
+    return (ArgumentCaptor<T>) captor;
+  }
+
+  public static DataSource isADataSource() {
+    return isA(DataSource.class);
+  }
+
+  public static Context anyContext() {
+    return any(Context.class);
+  }
+
+  /**
+   * Creates a Mockito argument matcher to be used in verify.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> anyResource() {
+    return any(Resource.class);
+  }
+
+  /**
+   * Creates a Mockito mock object.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> mockResource() {
+    return mock(Resource.class);
   }
 
   public static boolean isWindows() {
@@ -112,4 +150,15 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       return null;
     }
   }
+
+  public static class CreateBitmap implements Answer<Bitmap> {
+
+    @Override
+    public Bitmap answer(InvocationOnMock invocation) throws Throwable {
+      int width = (Integer) invocation.getArguments()[0];
+      int height = (Integer) invocation.getArguments()[1];
+      Bitmap.Config config = (Bitmap.Config) invocation.getArguments()[2];
+      return Bitmap.createBitmap(width, height, config);
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
new file mode 100644
index 000000000..007e5a26b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ByteBufferUtilTest {
+  private static final int BUFFER_SIZE = 16384;
+
+  @Test
+  public void testFromStream_small() throws IOException {
+    testFromStream(4);
+  }
+
+  @Test
+  public void testFromStream_empty() throws IOException {
+    testFromStream(0);
+  }
+
+  @Test
+  public void testFromStream_bufferAndAHalf() throws IOException {
+    testFromStream(BUFFER_SIZE + BUFFER_SIZE / 2);
+  }
+
+  @Test
+  public void testFromStream_massive() throws IOException {
+    testFromStream(12 * BUFFER_SIZE + 12345);
+  }
+
+  /**
+   * All tests are basically the same thing but with different amounts of data.
+   */
+  private void testFromStream(int dataLength) throws IOException {
+    byte[] bytes = createByteData(dataLength);
+    InputStream byteStream = new ByteArrayInputStream(bytes);
+    ByteBuffer byteBuffer = ByteBufferUtil.fromStream(byteStream);
+    assertByteBufferContents(byteBuffer, bytes);
+    byteStream.close();
+  }
+
+  private byte[] createByteData(int size) {
+    byte[] bytes = new byte[size];
+
+    // Put some arbitrary bytes in there.
+    for (int i = 0; i < size; i++) {
+      bytes[i] = (byte) (i % 4);
+    }
+
+    return bytes;
+  }
+
+  private void assertByteBufferContents(ByteBuffer buffer, byte[] expectedBytes) {
+    assertEquals(expectedBytes.length, buffer.limit());
+    for (int i = 0; i < expectedBytes.length; i++) {
+      assertEquals(expectedBytes[i], buffer.get(i));
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 28b0f7afe..848321fe1 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -6,6 +6,9 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,9 +17,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ContentLengthInputStreamTest {
@@ -72,7 +72,7 @@ public void testAvailable_handlesReadValueOfZero() throws IOException {
     when(wrapped.read()).thenReturn(0);
 
     assertThat(is.read()).isEqualTo(0);
-    assertThat(is.available()).isEqualTo(contentLength);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
   }
 
   @Test
@@ -131,4 +131,27 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
     is.read(new byte[10], 0, 0);
   }
-}
\ No newline at end of file
+
+  @Test
+  public void testRead_readWithZeroes_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner = new ByteArrayInputStream(new byte[] {0, 0, 0});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(-1);
+  }
+
+  @Test
+  public void testRead_readWithHighValues_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner =
+        new ByteArrayInputStream(new byte[] {(byte) 0xF0, (byte) 0xA0, (byte) 0xFF});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0xF0);
+    assertThat(is.read()).isEqualTo(0xA0);
+    assertThat(is.read()).isEqualTo(0xFF);
+    assertThat(is.read()).isEqualTo(-1);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
index dbe5e6db7..913432b92 100644
--- a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
@@ -12,17 +12,15 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketTimeoutException;
-
 @RunWith(JUnit4.class)
 public class ExceptionCatchingInputStreamTest {
 
@@ -172,4 +170,4 @@ public void testCanObtainNewStreamFromPool() throws IOException {
     int read = fromPool.read();
     assertEquals(1, read);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
index 3b7f64a4b..89cab6985 100644
--- a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -21,4 +21,4 @@ public void testReturnsGivenSize() {
 
     assertThat(size).asList().containsExactly(width, height);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 18ffacd80..1e18b4203 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -3,14 +3,13 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class MarkEnforcingInputStreamTest {
@@ -167,4 +166,4 @@ public void testReturnsMarkLimitAsAvailable_whenMarkIsSet_withMarkLessThanStream
 
     assertEquals(expected, is.available());
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
index 886dbb7a4..92d16e95b 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -71,4 +70,4 @@ public void testReturnsLargestSizeForNullConfig() {
     int size = Util.getBitmapByteSize(width, height, null);
     assertEquals(width * height * 4, size);
   }
-}
\ No newline at end of file
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 7f58f1df7..014cdaa19 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -5,7 +5,6 @@
 
 import android.view.View;
 import android.view.ViewGroup;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -47,6 +46,7 @@ public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
     int height = 456;
     provider.onSizeReady(width, height);
     view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+    view.layout(0, 0, 1, 1);
 
     provider.setView(view);
 
@@ -59,6 +59,7 @@ public void testCanObtainFixedSizeFromView() {
     int width = 123;
     int height = 456;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider.setView(view);
 
@@ -82,10 +83,11 @@ public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
     int width = 100;
     int height = 200;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider = new ViewPreloadSizeProvider<>(view);
 
     int[] size = provider.getPreloadSize(new Object(), 0, 0);
     assertThat(size).asList().containsExactly(width, height);
   }
-}
\ No newline at end of file
+}
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
new file mode 100644
index 000000000..94799a5c2
--- /dev/null
+++ b/samples/contacturi/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    compile project(':library')
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.samples.contacturi'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode 1
+        versionName '1.0'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.contacturi/.MainActivity'
+}
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..ecfd4c859
--- /dev/null
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.bumptech.glide.samples.contacturi" >
+
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@android:drawable/sym_def_app_icon"
+        android:label="@string/app_name"
+        android:theme="@style/Theme.AppCompat" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
new file mode 100644
index 000000000..14dec10a2
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.contacturi;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Contact Uri sample.
+ */
+@GlideModule
+public class ContactUriModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
new file mode 100644
index 000000000..74aedca6b
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.samples.contacturi;
+
+import static android.os.Build.VERSION;
+import static android.os.Build.VERSION_CODES;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract.Contacts;
+import android.view.View;
+import android.widget.ImageView;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * An activity that demonstrates loading photos using
+ * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
+ * It works by making the user to choose a contact when presses a button,
+ * and after he chooses a contact with photo,
+ * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ */
+public class MainActivity extends Activity {
+  private static final int REQUEST_CONTACT = 1;
+
+  private ImageView imageViewContact;
+  private ImageView imageViewLookup;
+  private ImageView imageViewPhoto;
+  private ImageView imageViewDisplayPhoto;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    imageViewContact = (ImageView) findViewById(R.id.image_contact);
+    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
+    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
+
+    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+        startActivityForResult(intent, REQUEST_CONTACT);
+      }
+    });
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+    if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
+      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      try {
+        if (cursor != null && cursor.moveToFirst()) {
+          final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
+          showContact(contactId);
+        }
+      } finally {
+        if (cursor != null) {
+          cursor.close();
+        }
+      }
+      return;
+    }
+    super.onActivityResult(requestCode, resultCode, data);
+  }
+
+  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+  private void showContact(long id) {
+    GlideRequests glideRequests = GlideApp.with(this);
+    RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
+
+    Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
+    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);
+
+    Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
+    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);
+
+    Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
+    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
+
+    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
+      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+    }
+  }
+}
diff --git a/samples/contacturi/src/main/res/layout/activity_main.xml b/samples/contacturi/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..fe9510388
--- /dev/null
+++ b/samples/contacturi/src/main/res/layout/activity_main.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:fitsSystemWindows="true"
+        android:padding="@dimen/activity_horizontal_margin"
+        tools:context="com.bumptech.glide.samples.contacturi.MainActivity">
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        <Button
+                android:id="@+id/button_pick_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/pick_contact"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_contact"/>
+        <ImageView
+                android:id="@+id/image_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_contact"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_lookup"/>
+        <ImageView
+                android:id="@+id/image_lookup"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_lookup"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_photo"/>
+        <ImageView
+                android:id="@+id/image_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_display_photo"/>
+        <ImageView
+                android:id="@+id/image_display_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_display_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/contacturi/src/main/res/values/dimens.xml b/samples/contacturi/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..47c822467
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/samples/contacturi/src/main/res/values/strings.xml b/samples/contacturi/src/main/res/values/strings.xml
new file mode 100644
index 000000000..63bdff591
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/strings.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ContactUri Sample</string>
+    <string name="pick_contact">Pick Contact</string>
+    <string name="image_contact">Image based on contact Uri, best size on latest Android</string>
+    <string name="image_lookup">Image based on lookup Uri, same as contact Uri</string>
+    <string name="image_photo">Image based on photo Uri, thumbnail sized, usually 96x96px</string>
+    <string name="image_display_photo">Image based on display photo Uri, possibly 512x512px</string>
+</resources>
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index 85128997d..a0233b7a8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -2,9 +2,15 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
+    annotationProcessor project(':annotation:compiler')
+
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
 }
 
 android {
@@ -17,7 +23,7 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
new file mode 100644
index 000000000..5c710c8c7
--- /dev/null
+++ b/samples/flickr/lint.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+</lint>
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index b869526c7..9be7824f6 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -6,10 +6,6 @@
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
-    <uses-sdk android:minSdkVersion="10"
-      android:targetSdkVersion="19" />
-
-
     <application
         android:label="@string/app_name"
         android:icon="@android:drawable/sym_def_app_icon"
@@ -28,10 +24,5 @@
         </activity>
 
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index e965d395e..cae1eaf14 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,25 +1,25 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ * Register {@link FlickrModelLoader} for the Flickr sample app.
  */
-public class FlickrGlideModule implements GlideModule {
+@GlideModule
+public class FlickrGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 708f68e3a..cf7ea32c0 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -11,7 +9,6 @@
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 import java.util.List;
 
@@ -29,8 +26,7 @@
     private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
 
     @Override
-    public ModelLoader<Photo, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
           modelCache);
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index c9ecf2f86..57f3c23cf 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -1,35 +1,32 @@
 package com.bumptech.glide.samples.flickr;
 
-import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.priorityOf;
+import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;
 
 import android.content.Intent;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.GridView;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
-
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
- * A fragment that shows square image thumbnails whose size is determined by the framgent's
+ * A fragment that shows square image thumbnails whose size is determined by the fragment's
  * arguments in a grid pattern.
  */
 public class FlickrPhotoGrid extends Fragment implements PhotoViewer {
@@ -42,11 +39,12 @@
   private PhotoAdapter adapter;
   private List<Photo> currentPhotos;
   private int photoSize;
-  private GridView grid;
+  private RecyclerView grid;
   private boolean thumbnail;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbnailRequest;
-  private RequestBuilder<Drawable> preloadRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbnailRequest;
+  private GlideRequest<Drawable> preloadRequest;
+  private GridLayoutManager layoutManager;
 
   public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
     FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
@@ -65,33 +63,55 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = Glide.with(this)
+    fullRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withCrossFade(R.anim.fade_in, 150))
-        .apply(centerCropTransform(getActivity()));
+        .centerCrop()
+        .transition(withNoTransition());
 
-    thumbnailRequest = Glide.with(this)
+    thumbnailRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withCrossFade(R.anim.fade_in, 150))
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .centerCrop(getActivity())
-            .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE));
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .centerCrop()
+        .override(Api.SQUARE_THUMB_SIZE)
+        .transition(withNoTransition());
 
     preloadRequest =
-        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;
+        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
-    grid = (GridView) result.findViewById(R.id.images);
-    grid.setColumnWidth(photoSize);
+    final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
+    int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
+    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    layoutManager = new GridLayoutManager(getActivity(), spanCount);
+    grid.setLayoutManager(layoutManager);
+
+    grid.addItemDecoration(new RecyclerView.ItemDecoration() {
+      @Override
+      public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
+          RecyclerView.State state) {
+        outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
+      }
+    });
+    grid.setRecyclerListener(new RecyclerView.RecyclerListener() {
+      @Override
+      public void onViewRecycled(RecyclerView.ViewHolder holder) {
+        PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
+        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+      }
+    });
+
+    int heightCount = getResources().getDisplayMetrics().heightPixels / photoSize;
+    grid.getRecycledViewPool().setMaxRecycledViews(0, spanCount * heightCount * 2);
+    grid.setItemViewCacheSize(0);
     adapter = new PhotoAdapter();
     grid.setAdapter(adapter);
 
-    final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
-        new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
-    final ListPreloader<Photo> preloader = new ListPreloader<Photo>(Glide.with(this), adapter,
+    FixedPreloadSizeProvider<Photo> preloadSizeProvider =
+        new FixedPreloadSizeProvider<>(photoSize, photoSize);
+    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
         preloadSizeProvider, args.getInt(PRELOAD_KEY));
-    grid.setOnScrollListener(preloader);
+    grid.addOnScrollListener(preloader);
 
     if (currentPhotos != null) {
       adapter.setPhotos(currentPhotos);
@@ -99,7 +119,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
 
     if (savedInstanceState != null) {
       int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
-      grid.setSelection(index);
+      grid.scrollToPosition(index);
     }
 
     return result;
@@ -109,7 +129,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   public void onSaveInstanceState(Bundle outState) {
     super.onSaveInstanceState(outState);
     if (grid != null) {
-      int index = grid.getFirstVisiblePosition();
+      int index = layoutManager.findFirstVisibleItemPosition();
       outState.putInt(STATE_POSITION_INDEX, index);
     }
   }
@@ -122,10 +142,10 @@ public void onPhotosUpdated(List<Photo> photos) {
     }
   }
 
-  private class PhotoAdapter extends BaseAdapter implements
+  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder> implements
       ListPreloader.PreloadModelProvider<Photo> {
-    private List<Photo> photos = new ArrayList<Photo>(0);
     private final LayoutInflater inflater;
+    private List<Photo> photos = Collections.emptyList();
 
     public PhotoAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
@@ -137,46 +157,44 @@ public void setPhotos(List<Photo> photos) {
     }
 
     @Override
-    public int getCount() {
-      return photos.size();
-    }
-
-    @Override
-    public Object getItem(int i) {
-      return photos.get(i);
+    public int getItemViewType(int position) {
+      return 0;
     }
 
     @Override
-    public long getItemId(int i) {
-      return 0;
+    public PhotoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = inflater.inflate(R.layout.flickr_photo_grid_item, parent, false);
+      ViewGroup.LayoutParams params = view.getLayoutParams();
+      params.width = photoSize;
+      params.height = photoSize;
+      return new PhotoViewHolder(view);
     }
 
     @Override
-    public View getView(int position, View view, ViewGroup container) {
+    public void onBindViewHolder(PhotoViewHolder holder, int position) {
       final Photo current = photos.get(position);
-      final ImageView imageView;
-      if (view == null) {
-        imageView = (ImageView) inflater.inflate(R.layout.flickr_photo_grid_item, container, false);
-        ViewGroup.LayoutParams params = imageView.getLayoutParams();
-        params.width = photoSize;
-        params.height = photoSize;
-      } else {
-        imageView = (ImageView) view;
-      }
 
       fullRequest.load(current)
           .thumbnail(thumbnail ? thumbnailRequest.load(current) : null)
-          .into(imageView);
+          .into(holder.imageView);
 
-      imageView.setOnClickListener(new View.OnClickListener() {
+      holder.imageView.setOnClickListener(new View.OnClickListener() {
         @Override
         public void onClick(View view) {
           Intent intent = FullscreenActivity.getIntent(getActivity(), current);
           startActivity(intent);
         }
       });
+    }
+
+    @Override
+    public long getItemId(int i) {
+      return RecyclerView.NO_ID;
+    }
 
-      return imageView;
+    @Override
+    public int getItemCount() {
+      return photos.size();
     }
 
     @Override
@@ -185,8 +203,17 @@ public void onClick(View view) {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return preloadRequest.load(item);
     }
   }
+
+  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+    private final ImageView imageView;
+
+    public PhotoViewHolder(View itemView) {
+      super(itemView);
+      imageView = (ImageView) itemView;
+    }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 07ca4249a..701710e04 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 
 import android.content.Intent;
 import android.graphics.Color;
@@ -10,23 +8,21 @@
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
 import android.widget.ImageView;
-import android.widget.ListView;
 import android.widget.TextView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -38,10 +34,11 @@
   private static final String STATE_POSITION_OFFSET = "state_position_offset";
   private FlickrPhotoListAdapter adapter;
   private List<Photo> currentPhotos;
-  private ListView list;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbRequest;
+  private RecyclerView list;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbRequest;
   private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
+  private LinearLayoutManager layoutManager;
 
   public static FlickrPhotoList newInstance() {
     return new FlickrPhotoList();
@@ -59,34 +56,48 @@ public void onPhotosUpdated(List<Photo> photos) {
   public View onCreateView(LayoutInflater inflater, ViewGroup container,
       Bundle savedInstanceState) {
     final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
-    list = (ListView) result.findViewById(R.id.flickr_photo_list);
+
+    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    layoutManager = new LinearLayoutManager(getActivity());
+    list.setLayoutManager(layoutManager);
     adapter = new FlickrPhotoListAdapter();
     list.setAdapter(adapter);
 
-    preloadSizeProvider = new ViewPreloadSizeProvider<Photo>();
-    ListPreloader<Photo> preloader = new ListPreloader<Photo>(Glide.with(this), adapter,
-        preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
-    list.setOnScrollListener(preloader);
+    preloadSizeProvider = new ViewPreloadSizeProvider<>();
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            GlideApp.with(this), adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
+    list.addOnScrollListener(preloader);
+    list.setItemViewCacheSize(0);
 
     if (currentPhotos != null) {
       adapter.setPhotos(currentPhotos);
     }
 
-    fullRequest = Glide.with(FlickrPhotoList.this)
+    final GlideRequests glideRequests = GlideApp.with(this);
+    fullRequest = glideRequests
         .asDrawable()
-        .apply(centerCropTransform(getActivity())
-            .placeholder(new ColorDrawable(Color.GRAY)));
+        .centerCrop()
+        .placeholder(new ColorDrawable(Color.GRAY));
 
-    thumbRequest = Glide.with(FlickrPhotoList.this)
+    thumbRequest = glideRequests
         .asDrawable()
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE))
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .override(Api.SQUARE_THUMB_SIZE)
         .transition(withCrossFade());
 
+    list.setRecyclerListener(new RecyclerView.RecyclerListener() {
+      @Override
+      public void onViewRecycled(RecyclerView.ViewHolder holder) {
+        PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
+        glideRequests.clear(vh.imageView);
+      }
+    });
+
     if (savedInstanceState != null) {
       int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
       int offset = savedInstanceState.getInt(STATE_POSITION_OFFSET);
-      list.setSelectionFromTop(index, offset);
+      layoutManager.scrollToPositionWithOffset(index, offset);
     }
 
     return result;
@@ -96,7 +107,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   public void onSaveInstanceState(Bundle outState) {
     super.onSaveInstanceState(outState);
     if (list != null) {
-      int index = list.getFirstVisiblePosition();
+      int index = layoutManager.findFirstVisibleItemPosition();
       View topView = list.getChildAt(0);
       int offset = topView != null ? topView.getTop() : 0;
       outState.putInt(STATE_POSITION_INDEX, index);
@@ -104,20 +115,10 @@ public void onSaveInstanceState(Bundle outState) {
     }
   }
 
-  private static class ViewHolder {
-    private final TextView titleText;
-    private final ImageView imageView;
-
-    public ViewHolder(ImageView imageView, TextView titleText) {
-      this.imageView = imageView;
-      this.titleText = titleText;
-    }
-  }
-
-  private class FlickrPhotoListAdapter extends BaseAdapter
+  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
       implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
-    private List<Photo> photos = new ArrayList<Photo>(0);
+    private List<Photo> photos = Collections.emptyList();
 
     public FlickrPhotoListAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
@@ -129,40 +130,21 @@ public void setPhotos(List<Photo> photos) {
     }
 
     @Override
-    public int getCount() {
-      return photos.size();
-    }
-
-    @Override
-    public Object getItem(int i) {
-      return null;
+    public PhotoTitleViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = inflater.inflate(R.layout.flickr_photo_list_item, parent, false);
+      PhotoTitleViewHolder vh = new PhotoTitleViewHolder(view);
+      preloadSizeProvider.setView(vh.imageView);
+      return vh;
     }
 
     @Override
-    public long getItemId(int i) {
-      return 0;
-    }
-
-    @Override
-    public View getView(int position, View view, ViewGroup container) {
+    public void onBindViewHolder(PhotoTitleViewHolder holder, int position) {
       final Photo current = photos.get(position);
-      final ViewHolder viewHolder;
-      if (view == null) {
-        view = inflater.inflate(R.layout.flickr_photo_list_item, container, false);
-        final ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
-        TextView titleView = (TextView) view.findViewById(R.id.title_view);
-        viewHolder = new ViewHolder(imageView, titleView);
-        view.setTag(viewHolder);
-        preloadSizeProvider.setView(imageView);
-      } else {
-        viewHolder = (ViewHolder) view.getTag();
-      }
-
       fullRequest.load(current)
           .thumbnail(thumbRequest.load(current))
-          .into(viewHolder.imageView);
+          .into(holder.imageView);
 
-      viewHolder.imageView.setOnClickListener(new View.OnClickListener() {
+      holder.imageView.setOnClickListener(new View.OnClickListener() {
         @Override
         public void onClick(View view) {
           Intent intent = FullscreenActivity.getIntent(getActivity(), current);
@@ -170,8 +152,17 @@ public void onClick(View view) {
         }
       });
 
-      viewHolder.titleText.setText(current.getTitle());
-      return view;
+      holder.titleView.setText(current.getTitle());
+    }
+
+    @Override
+    public long getItemId(int i) {
+      return RecyclerView.NO_ID;
+    }
+
+    @Override
+    public int getItemCount() {
+      return photos.size();
     }
 
     @Override
@@ -180,8 +171,19 @@ public void onClick(View view) {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
+
+  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+    private final TextView titleView;
+    private final ImageView imageView;
+
+    public PhotoTitleViewHolder(View itemView) {
+      super(itemView);
+      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
+      titleView = (TextView) itemView.findViewById(R.id.title_view);
+    }
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index f57cef225..47cbadb89 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -12,28 +12,27 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.app.FragmentTransaction;
+import android.support.v4.view.MenuItemCompat;
 import android.support.v4.view.ViewPager;
-import android.support.v7.app.ActionBar;
-import android.support.v7.app.ActionBarActivity;
+import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
 import android.util.Log;
-import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.inputmethod.EditorInfo;
-import android.widget.Button;
-import android.widget.EditText;
+import android.widget.SearchView;
 import android.widget.TextView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
+import com.bumptech.glide.samples.flickr.api.Query;
+import com.bumptech.glide.samples.flickr.api.RecentQuery;
+import com.bumptech.glide.samples.flickr.api.SearchQuery;
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -45,21 +44,22 @@
  * An activity that allows users to search for images on Flickr and that contains a series of
  * fragments that display retrieved image thumbnails.
  */
-public class FlickrSearchActivity extends ActionBarActivity {
+public class FlickrSearchActivity extends AppCompatActivity
+    implements SearchView.OnQueryTextListener {
   private static final String TAG = "FlickrSearchActivity";
-  private static final String STATE_SEARCH_STRING = "state_search_string";
+  private static final String STATE_QUERY = "state_search_string";
 
-  private EditText searchText;
+  private final QueryListener queryListener = new QueryListener();
   private View searching;
   private TextView searchTerm;
-  private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
-  private List<Photo> currentPhotos = new ArrayList<Photo>();
+  private Set<PhotoViewer> photoViewers = new HashSet<>();
+  private List<Photo> currentPhotos = new ArrayList<>();
   private View searchLoading;
-  private String currentSearchString;
-  private final SearchListener searchListener = new SearchListener();
   private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
   private HandlerThread backgroundThread;
   private Handler backgroundHandler;
+  private SearchView searchView;
+  private Query currentQuery;
 
   private enum Page {
     SMALL,
@@ -87,90 +87,80 @@ public void onAttachFragment(Fragment fragment) {
     }
   }
 
+  @Override
+  public boolean onCreateOptionsMenu(Menu menu) {
+    MenuInflater menuInflater = getMenuInflater();
+    menuInflater.inflate(R.menu.search_activity, menu);
+
+    searchView =
+        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));
+    searchView.setSubmitButtonEnabled(true);
+    searchView.setIconified(false);
+    searchView.setOnQueryTextListener(this);
+
+    return true;
+  }
+
+  @Override
+  public boolean onQueryTextSubmit(String query) {
+    executeSearch(query);
+    searchView.setQuery("", false /*submit*/);
+    return true;
+  }
+
+  @Override
+  public boolean onQueryTextChange(String newText) {
+    return false;
+  }
+
   /**
    * Called when the activity is first created.
    */
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
+    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+        .detectAll()
+        .penaltyLog()
+        .build());
+
     backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
     backgroundThread.start();
     backgroundHandler = new Handler(backgroundThread.getLooper());
 
     setContentView(R.layout.flickr_search_activity);
-    StrictMode
-        .setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
     searching = findViewById(R.id.searching);
     searchLoading = findViewById(R.id.search_loading);
     searchTerm = (TextView) findViewById(R.id.search_term);
 
-    searchText = (EditText) findViewById(R.id.search_text);
-    searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
-      @Override
-      public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
-        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
-          executeSearch();
-          return true;
-        }
-        return false;
-      }
-    });
-
-    final Button search = (Button) findViewById(R.id.search);
-    search.setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View view) {
-        executeSearch();
-      }
-    });
-
-    final ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
-    pager.setPageMargin(50);
-    pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
-      @Override
-      public void onPageScrolled(int i, float v, int i2) {
-      }
-
-      @Override
-      public void onPageSelected(int position) {
-        getSupportActionBar().getTabAt(position).select();
-      }
-
-      @Override
-      public void onPageScrollStateChanged(int i) {
-      }
-    });
-
-
-    final ActionBar actionBar = getSupportActionBar();
-    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
-
-    for (Page page : Page.values()) {
-      final int textId = PAGE_TO_TITLE.get(page);
-      actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
-    }
-
+    Resources res = getResources();
+    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
+    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));
     pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
 
-    Api.get(this).registerSearchListener(searchListener);
+    Api.get(this).registerSearchListener(queryListener);
     if (savedInstanceState != null) {
-      String savedSearchString = savedInstanceState.getString(STATE_SEARCH_STRING);
-      if (!TextUtils.isEmpty(savedSearchString)) {
-        executeSearch(savedSearchString);
+      Query savedQuery = savedInstanceState.getParcelable(STATE_QUERY);
+      if (savedQuery != null) {
+        executeQuery(savedQuery);
       }
+    } else {
+      executeQuery(RecentQuery.get());
     }
 
-    final Resources res = getResources();
     int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
     int mediumGridSize = res.getDimensionPixelSize(R.dimen.medium_photo_side);
     int listHeightSize = res.getDimensionPixelSize(R.dimen.flickr_list_item_height);
     int screenWidth = getScreenWidth();
 
-    // Weight values determined experimentally by measuring the number of incurred GCs while
-    // scrolling through the various photo grids/lists.
-    Glide.get(this).preFillBitmapPool(new PreFillType.Builder(smallGridSize).setWeight(1),
-        new PreFillType.Builder(mediumGridSize).setWeight(1),
-        new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
+    if (savedInstanceState == null) {
+      // Weight values determined experimentally by measuring the number of incurred GCs while
+      // scrolling through the various photo grids/lists.
+      GlideApp.get(this).preFillBitmapPool(
+          new PreFillType.Builder(smallGridSize).setWeight(1),
+          new PreFillType.Builder(mediumGridSize).setWeight(1),
+          new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
+    }
   }
 
   private int getScreenWidth() {
@@ -180,15 +170,15 @@ private int getScreenWidth() {
   @Override
   protected void onSaveInstanceState(Bundle outState) {
     super.onSaveInstanceState(outState);
-    if (!TextUtils.isEmpty(currentSearchString)) {
-      outState.putString(STATE_SEARCH_STRING, currentSearchString);
+    if (currentQuery != null) {
+      outState.putParcelable(STATE_QUERY, currentQuery);
     }
   }
 
   @Override
   protected void onDestroy() {
     super.onDestroy();
-    Api.get(this).unregisterSearchListener(searchListener);
+    Api.get(this).unregisterSearchListener(queryListener);
     if (backgroundThumbnailFetcher != null) {
       backgroundThumbnailFetcher.cancel();
       backgroundThumbnailFetcher = null;
@@ -201,60 +191,38 @@ protected void onDestroy() {
   @Override
   public void onTrimMemory(int level) {
     super.onTrimMemory(level);
-    Glide.get(this).trimMemory(level);
+    GlideApp.get(this).trimMemory(level);
   }
 
   @Override
   public void onLowMemory() {
     super.onLowMemory();
-    Glide.get(this).clearMemory();
-  }
-
-  private void executeSearch() {
-    String searchString = searchText.getText().toString();
-    searchText.getText().clear();
-    executeSearch(searchString);
+    GlideApp.get(this).clearMemory();
   }
 
   private void executeSearch(String searchString) {
-    currentSearchString = searchString;
+    Query query = TextUtils.isEmpty(searchString) ? null : new SearchQuery(searchString);
+    executeQuery(query);
+  }
 
-    if (TextUtils.isEmpty(searchString)) {
+  private void executeQuery(Query query) {
+    currentQuery = query;
+    if (query == null) {
+      queryListener.onSearchCompleted(null, Collections.<Photo>emptyList());
       return;
     }
 
     searching.setVisibility(View.VISIBLE);
     searchLoading.setVisibility(View.VISIBLE);
-    searchTerm.setText(getString(R.string.searching_for, currentSearchString));
-
-    Api.get(this).search(currentSearchString);
-  }
-
-  private static class TabListener implements ActionBar.TabListener {
-    private final ViewPager pager;
-
-    public TabListener(ViewPager pager) {
-      this.pager = pager;
-    }
-
-    @Override
-    public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
-      pager.setCurrentItem(tab.getPosition());
-    }
+    searchTerm.setText(getString(R.string.searching_for, currentQuery.getDescription()));
 
-    @Override
-    public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
-    }
-
-    @Override
-    public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
-    }
+    Api.get(this).query(currentQuery);
   }
 
-  private class SearchListener implements Api.SearchListener {
+  private class QueryListener implements Api.QueryListener {
     @Override
-    public void onSearchCompleted(String searchString, List<Photo> photos) {
-      if (!TextUtils.equals(currentSearchString, searchString)) {
+    public void onSearchCompleted(Query query, List<Photo> photos) {
+      if (!isCurrentQuery(query)) {
         return;
       }
 
@@ -278,9 +246,13 @@ public void onSearchCompleted(String searchString, List<Photo> photos) {
       currentPhotos = photos;
     }
 
+    private boolean isCurrentQuery(Query query) {
+      return currentQuery != null && currentQuery.equals(query);
+    }
+
     @Override
-    public void onSearchFailed(String searchString, Exception e) {
-      if (!TextUtils.equals(currentSearchString, searchString)) {
+    public void onSearchFailed(Query query, Exception e) {
+      if (!isCurrentQuery(query)) {
         return;
       }
 
@@ -289,7 +261,7 @@ public void onSearchFailed(String searchString, Exception e) {
       }
       searching.setVisibility(View.VISIBLE);
       searchLoading.setVisibility(View.INVISIBLE);
-      searchTerm.setText(getString(R.string.search_failed, currentSearchString));
+      searchTerm.setText(getString(R.string.search_failed, currentQuery.getDescription()));
     }
   }
 
@@ -312,13 +284,13 @@ public void setPrimaryItem(ViewGroup container, int position, Object object) {
       super.setPrimaryItem(container, position, object);
       if (position != mLastPosition) {
         if (mLastPosition >= 0) {
-          Glide.with(mLastFragment).pauseRequests();
+          GlideApp.with(mLastFragment).pauseRequests();
         }
         Fragment current = (Fragment) object;
         mLastPosition = position;
         mLastFragment = current;
         if (current.isAdded()) {
-          Glide.with(current).resumeRequests();
+          GlideApp.with(current).resumeRequests();
         }
       }
     }
@@ -328,11 +300,18 @@ public int getCount() {
       return Page.values().length;
     }
 
+    @Override
+    public CharSequence getPageTitle(int position) {
+      Page page = Page.values()[position];
+      int titleId = PAGE_TO_TITLE.get(page);
+      return getString(titleId);
+    }
+
     private Fragment pageToFragment(int position) {
       Page page = Page.values()[position];
       if (page == Page.SMALL) {
         int pageSize = getPageSize(R.dimen.small_photo_side);
-        return FlickrPhotoGrid.newInstance(pageSize, 30, false /*thumbnail*/);
+        return FlickrPhotoGrid.newInstance(pageSize, 15, false /*thumbnail*/);
       } else if (page == Page.MEDIUM) {
         int pageSize = getPageSize(R.dimen.medium_photo_side);
         return FlickrPhotoGrid.newInstance(pageSize, 10, true /*thumbnail*/);
@@ -370,11 +349,10 @@ public void run() {
           return;
         }
 
-        // TODO: Calling asDrawable (or Bitmap/Gif) and then downloadOnly is weird.
-        FutureTarget<File> futureTarget = Glide.with(context)
-            .asDrawable()
+        FutureTarget<File> futureTarget = GlideApp.with(context)
+            .downloadOnly()
             .load(photo)
-            .downloadOnly(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
@@ -387,7 +365,7 @@ public void run() {
             Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
           }
         }
-        futureTarget.cancel(true /*mayInterruptIfRunning*/);
+        GlideApp.with(context).clear(futureTarget);
       }
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index b30e68c0b..ba3095dc2 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-
 import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
 
 import android.content.Context;
@@ -8,8 +7,6 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 /**
@@ -31,10 +28,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    Glide.with(this)
-        .asDrawable()
-        .apply(fitCenterTransform(this))
-        .load(photo)
-        .into(fullscreenView);
+    GlideApp.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index b91230272..19776b359 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.util.List;
 
 /**
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
new file mode 100644
index 000000000..5988e6bf8
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -0,0 +1,30 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.content.Context;
+import android.support.v7.widget.AppCompatImageView;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+/**
+ * An always square {@link ImageView}.
+ */
+public final class SquareImageView extends AppCompatImageView {
+
+  public SquareImageView(Context context) {
+    super(context);
+  }
+
+  public SquareImageView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
+    super(context, attrs, defStyleAttr);
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, widthMeasureSpec);
+  }
+}
+
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 726ef9fcb..4ef7f0bde 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -1,23 +1,13 @@
 package com.bumptech.glide.samples.flickr.api;
 
 import android.content.Context;
-import android.text.TextUtils;
-import android.util.Log;
 import android.util.SparseArray;
-
 import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
 import com.android.volley.toolbox.StringRequest;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.util.LruCache;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
@@ -38,6 +28,8 @@
   private static final int MAX_URLS_TO_CACHE = 2000;
   private static final LruCache<UrlCacheKey, String> CACHED_URLS =
       new LruCache<>(MAX_URLS_TO_CACHE);
+  private static final int MAX_ITEMS_PER_PAGE = 300;
+  private static final String PER_PAGE = "&per_page=" + MAX_ITEMS_PER_PAGE;
 
   private static final SparseArray<String> EDGE_TO_SIZE_KEY = new SparseArray<String>() {
     {
@@ -51,7 +43,8 @@
     }
   };
   private static final List<Integer> SORTED_SIZE_KEYS =
-      new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
+      new ArrayList<>(EDGE_TO_SIZE_KEY.size());
+
 
   static {
     for (int i = 0; i < EDGE_TO_SIZE_KEY.size(); i++) {
@@ -114,10 +107,6 @@ private static String getUrlForMethod(String method) {
     return String.format(SIGNED_API_URL, method);
   }
 
-  private static String getSearchUrl(String text) {
-    return getUrlForMethod("flickr.photos.search") + "&text=" + text + "&per_page=300";
-  }
-
   private static String getPhotoUrl(Photo photo, String sizeKey) {
     UrlCacheKey entry = new UrlCacheKey(photo, sizeKey);
     String result = CACHED_URLS.get(entry);
@@ -128,25 +117,33 @@ private static String getPhotoUrl(Photo photo, String sizeKey) {
     return result;
   }
 
+  static String getSearchUrl(String text) {
+    return getUrlForMethod("flickr.photos.search") + "&text=" + text + PER_PAGE;
+  }
+
+  static String getRecentUrl() {
+    return getUrlForMethod("flickr.photos.getRecent" + PER_PAGE);
+  }
+
   /**
    * An interface for listening for search results from the Flickr API.
    */
-  public interface SearchListener {
+  public interface QueryListener {
     /**
      * Called when a search completes successfully.
      *
-     * @param searchString The term that was searched for.
-     * @param photos       A list of images that were found for the given search term.
+     * @param query  The query used to obtain the results.
+     * @param photos A list of images that were found for the given search term.
      */
-    public void onSearchCompleted(String searchString, List<Photo> photos);
+    void onSearchCompleted(Query query, List<Photo> photos);
 
     /**
      * Called when a search fails.
      *
-     * @param searchString The term that was searched for.
-     * @param e            The exception that caused the search to fail.
+     * @param query The query we attempted to obtain results for.
+     * @param e     The exception that caused the search to fail.
      */
-    public void onSearchFailed(String searchString, Exception e);
+    void onSearchFailed(Query query, Exception e);
   }
 
   public static Api get(Context context) {
@@ -157,75 +154,56 @@ public static Api get(Context context) {
   }
 
   private final RequestQueue requestQueue;
-  private final Set<SearchListener> searchListeners = new HashSet<SearchListener>();
-  private SearchResult lastSearchResult;
+  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private QueryResult lastQueryResult;
 
   protected Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
+    QueryListener queryListener = new QueryListener() {
+      @Override
+      public void onSearchCompleted(Query query, List<Photo> photos) {
+        lastQueryResult = new QueryResult(query, photos);
+      }
+
+      @Override
+      public void onSearchFailed(Query query, Exception e) {
+        lastQueryResult = null;
+      }
+    };
+    queryListeners.add(queryListener);
   }
 
-  public void registerSearchListener(SearchListener searchListener) {
-    searchListeners.add(searchListener);
+  public void registerSearchListener(QueryListener queryListener) {
+    queryListeners.add(queryListener);
   }
 
-  public void unregisterSearchListener(SearchListener searchListener) {
-    searchListeners.remove(searchListener);
+  public void unregisterSearchListener(QueryListener queryListener) {
+    queryListeners.remove(queryListener);
   }
 
-  public void search(final String text) {
-    if (lastSearchResult != null && TextUtils.equals(lastSearchResult.searchString, text)) {
-      for (SearchListener listener : searchListeners) {
-        listener.onSearchCompleted(lastSearchResult.searchString, lastSearchResult.results);
+  public void query(Query query) {
+    if (lastQueryResult != null && lastQueryResult.query.equals(query)) {
+      for (QueryListener listener : queryListeners) {
+        listener.onSearchCompleted(lastQueryResult.query, lastQueryResult.results);
       }
       return;
     }
 
-    StringRequest request =
-        new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
-          @Override
-          public void onResponse(String response) {
-            try {
-              // Cut out initial flickJsonApi(
-              JSONObject searchResults =
-                  new JSONObject(response.substring(14, response.length() - 1));
-              JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
-              List<Photo> results = new ArrayList<Photo>(photos.length());
-              for (int i = 0; i < photos.length(); i++) {
-                results.add(new Photo(photos.getJSONObject(i)));
-              }
-              lastSearchResult = new SearchResult(text, results);
-              for (SearchListener listener : searchListeners) {
-                listener.onSearchCompleted(text, results);
-              }
-            } catch (JSONException e) {
-              for (SearchListener listener : searchListeners) {
-                listener.onSearchFailed(text, e);
-              }
-              if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Search failed response=" + response, e);
-              }
-            }
-          }
-        }, new Response.ErrorListener() {
-          @Override
-          public void onErrorResponse(VolleyError error) {
-            for (SearchListener listener : searchListeners) {
-              listener.onSearchFailed(text, error);
-            }
-          }
-        });
+    FlickrQueryResponseListener responseListener
+        = new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
+    StringRequest request = new StringRequest(Request.Method.GET, query.getUrl(),
+        responseListener, responseListener);
     request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
         DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
     requestQueue.add(request);
   }
 
-  private static class SearchResult {
-    private final String searchString;
+  private static class QueryResult {
+    private final Query query;
     private final List<Photo> results;
 
-    public SearchResult(String searchString, List<Photo> results) {
-
-      this.searchString = searchString;
+    public QueryResult(Query query, List<Photo> results) {
+      this.query = query;
       this.results = results;
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
new file mode 100644
index 000000000..5bd75a67c
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -0,0 +1,50 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+import java.util.Collection;
+import java.util.List;
+import org.json.JSONException;
+
+/**
+ * Handles photo list responses and errors from Flickr API calls.
+ */
+final class FlickrQueryResponseListener implements Response.Listener<String>,
+    Response.ErrorListener {
+  private final PhotoJsonStringParser parser;
+  private final Query query;
+  private final Collection<Api.QueryListener> listeners;
+
+  FlickrQueryResponseListener(PhotoJsonStringParser parser, Query query,
+      Collection<Api.QueryListener> listeners) {
+    this.parser = parser;
+    this.query = query;
+    this.listeners = listeners;
+  }
+
+  @Override
+  public void onResponse(String response) {
+    try {
+      notifySuccess(parser.parse(response));
+    } catch (JSONException e) {
+      notifyFailed(e);
+    }
+  }
+
+  @Override
+  public void onErrorResponse(VolleyError error) {
+    notifyFailed(error);
+  }
+
+  private void notifySuccess(List<Photo> results) {
+    for (Api.QueryListener listener : listeners) {
+      listener.onSearchCompleted(query, results);
+    }
+  }
+
+  private void notifyFailed(Exception e) {
+    for (Api.QueryListener listener : listeners) {
+      listener.onSearchFailed(query, e);
+    }
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 36cb19ab6..8ff5f5b9a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -2,7 +2,6 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -91,6 +90,7 @@ public String toString() {
     return getPartialUrl();
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
new file mode 100644
index 000000000..8345e0392
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Parses a list of {@link Photo} objects from a Flickr API response string containing JSON data.
+ */
+final class PhotoJsonStringParser {
+  private static final int FLICKR_API_PREFIX_LENGTH = 14;
+
+  List<Photo> parse(String response) throws JSONException {
+    JSONObject searchResults =
+        new JSONObject(response.substring(FLICKR_API_PREFIX_LENGTH, response.length() - 1));
+    JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
+    List<Photo> results = new ArrayList<>(photos.length());
+    for (int i = 0, size = photos.length(); i < size; i++) {
+      results.add(new Photo(photos.getJSONObject(i)));
+    }
+
+    return results;
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java
new file mode 100644
index 000000000..877f5aa14
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Query.java
@@ -0,0 +1,11 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcelable;
+
+/** An interface representing a query in Flickr's API that returns a list of photos. */
+public interface Query extends Parcelable {
+  /** A user facing description of the query. */
+  String getDescription();
+  /** The url to use to execute the query. */
+  String getUrl();
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
new file mode 100644
index 000000000..2858df855
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -0,0 +1,45 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcel;
+
+/** Query using Flickr's recent API. */
+public final class RecentQuery implements Query {
+  public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
+    @Override
+    public RecentQuery createFromParcel(Parcel source) {
+      return RECENT_QUERY;
+    }
+
+    @Override
+    public RecentQuery[] newArray(int size) {
+      return new RecentQuery[size];
+    }
+  };
+  private static final RecentQuery RECENT_QUERY = new RecentQuery();
+
+  public static RecentQuery get() {
+    return RECENT_QUERY;
+  }
+
+  private RecentQuery() {
+    // Singleton.
+  }
+
+  @Override
+  public String getDescription() {
+    return "Recent";
+  }
+
+  @Override
+  public String getUrl() {
+    return Api.getRecentUrl();
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) { }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
new file mode 100644
index 000000000..0d36aaf24
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.samples.flickr.api;
+
+import android.os.Parcel;
+
+/** Wraps a search query string. */
+public final class SearchQuery implements Query {
+  public static final Creator<SearchQuery> CREATOR = new Creator<SearchQuery>() {
+    @Override
+    public SearchQuery createFromParcel(Parcel source) {
+      return new SearchQuery(source);
+    }
+
+    @Override
+    public SearchQuery[] newArray(int size) {
+      return new SearchQuery[size];
+    }
+  };
+
+  private final String queryString;
+
+  public SearchQuery(String queryString) {
+    this.queryString = queryString;
+  }
+
+  private SearchQuery(Parcel in) {
+    queryString = in.readString();
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(queryString);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public String getDescription() {
+    return queryString;
+  }
+
+  @Override
+  public String getUrl() {
+    return Api.getSearchUrl(queryString);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof SearchQuery) {
+      SearchQuery other = (SearchQuery) o;
+      return queryString.equals(other.queryString);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return queryString.hashCode();
+  }
+}
diff --git a/samples/flickr/src/main/res/anim/fade_in.xml b/samples/flickr/src/main/res/anim/fade_in.xml
deleted file mode 100644
index 14a8bd19c..000000000
--- a/samples/flickr/src/main/res/anim/fade_in.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<alpha xmlns:android="http://schemas.android.com/apk/res/android"
-       android:interpolator="@android:anim/linear_interpolator"
-       android:fromAlpha="0.0"
-       android:toAlpha="1.0"
-       android:duration="150"
-    />
-
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
index f756a4c31..dd069be64 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml
@@ -1,14 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<GridView xmlns:android="http://schemas.android.com/apk/res/android"
-          android:id="@+id/images"
-          android:cacheColorHint="#00000000"
-          android:fadingEdge="none"
-          android:scrollingCache="false"
-          android:numColumns="auto_fit"
-          android:horizontalSpacing="10dp"
-          android:verticalSpacing="10dp"
-          android:gravity="center"
-          android:layout_gravity="center"
-          android:stretchMode="columnWidth"
-          android:layout_width="fill_parent"
-          android:layout_height="fill_parent"/>
+<android.support.v7.widget.RecyclerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingTop="10dp"
+    android:id="@+id/flickr_photo_grid" />
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
index f7642db0b..5a53ad9fd 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-
-<ImageView xmlns:android="http://schemas.android.com/apk/res/android"
-           android:scaleType="centerCrop"
-           android:layout_width="fill_parent"
-           android:layout_height="fill_parent"
-           android:contentDescription="@string/image_description"/>
+<com.bumptech.glide.samples.flickr.SquareImageView
+       xmlns:android="http://schemas.android.com/apk/res/android"
+       android:scaleType="centerCrop"
+       android:layout_width="fill_parent"
+       android:layout_height="fill_parent"
+       android:contentDescription="@string/image_description"/>
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_list.xml b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
index 9f19722de..13723e059 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_list.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_list.xml
@@ -1,10 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-
-<ListView xmlns:android="http://schemas.android.com/apk/res/android"
-          android:id="@+id/flickr_photo_list"
-          android:layout_width="fill_parent"
-          android:layout_height="fill_parent"
-          android:cacheColorHint="#00000000"
-          android:scrollingCache="false">
-</ListView>
+<android.support.v7.widget.RecyclerView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:id="@+id/flickr_photo_list" />
 
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
index 5491ec04c..8c5bc8cb6 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_list_item.xml
@@ -22,4 +22,4 @@
         android:layout_margin="10dp"
         android:gravity="center"
         android:textSize="16sp"/>
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/samples/flickr/src/main/res/layout/flickr_search_activity.xml b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
index bfd035308..a4b216c7e 100644
--- a/samples/flickr/src/main/res/layout/flickr_search_activity.xml
+++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml
@@ -1,73 +1,41 @@
 <?xml version="1.0" encoding="utf-8"?>
 <merge xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <LinearLayout
-        android:orientation="vertical"
+    <android.support.v4.view.ViewPager
+        android:id="@+id/view_pager"
         android:layout_width="fill_parent"
         android:layout_height="fill_parent">
 
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:layout_margin="10dp"
-            android:orientation="horizontal">
-
-            <EditText
-                android:id="@+id/search_text"
-                android:layout_width="0dp"
+        <android.support.v4.view.PagerTabStrip
+                android:id="@+id/pager_tab_strip"
+                android:layout_width="match_parent"
                 android:layout_height="wrap_content"
-                android:layout_marginRight="10dp"
-                android:layout_marginEnd="10dp"
-                android:layout_weight="1"
-                android:cursorVisible="true"
-                android:textSize="16sp"
-                android:singleLine="true"
-                android:inputType="text"
-                android:imeOptions="actionSearch"/>
-
-            <Button
-                android:id="@+id/search"
-                android:layout_width="wrap_content"
-                android:minWidth="50dp"
-                android:layout_height="40dp"
-                android:text="@string/search"/>
-        </LinearLayout>
-
-        <FrameLayout
-            android:layout_width="fill_parent"
-            android:layout_height="0dp"
-            android:layout_weight="1">
-
-            <android.support.v4.view.ViewPager
-                android:id="@+id/view_pager"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent"/>
+                android:layout_gravity="top" />
 
-            <LinearLayout
-                android:id="@+id/searching"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent"
-                android:background="@color/translucent_black"
-                android:visibility="invisible"
-                android:layout_gravity="center"
-                android:gravity="center"
-                android:orientation="vertical">
+    </android.support.v4.view.ViewPager>
 
-                <TextView
-                    android:id="@+id/search_term"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:gravity="center"
-                    android:textSize="16sp"
-                    android:layout_marginBottom="10dp"/>
+    <LinearLayout
+        android:id="@+id/searching"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:background="@color/translucent_black"
+        android:visibility="invisible"
+        android:layout_gravity="center"
+        android:gravity="center"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/search_term"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:textSize="16sp"
+            android:layout_marginBottom="10dp"/>
 
-                <ProgressBar
-                    android:id="@+id/search_loading"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:indeterminate="true"/>
-            </LinearLayout>
-        </FrameLayout>
+        <ProgressBar
+            android:id="@+id/search_loading"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:indeterminate="true"/>
     </LinearLayout>
 </merge>
-
diff --git a/samples/flickr/src/main/res/menu/search_activity.xml b/samples/flickr/src/main/res/menu/search_activity.xml
new file mode 100644
index 000000000..23c1dfa0a
--- /dev/null
+++ b/samples/flickr/src/main/res/menu/search_activity.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto">
+<item android:id="@+id/search"
+      android:title="@string/search"
+      android:icon="@android:drawable/ic_menu_search"
+      app:showAsAction="collapseActionView|ifRoom"
+      app:actionViewClass="android.widget.SearchView" />
+</menu>
diff --git a/samples/flickr/src/main/res/values/colors.xml b/samples/flickr/src/main/res/values/colors.xml
index f2cb7a7f5..c9e3de8f5 100644
--- a/samples/flickr/src/main/res/values/colors.xml
+++ b/samples/flickr/src/main/res/values/colors.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <color name="translucent_black">#B0000000</color>
-</resources>
\ No newline at end of file
+</resources>
diff --git a/samples/flickr/src/main/res/values/dimens.xml b/samples/flickr/src/main/res/values/dimens.xml
index 89db175df..0f5cf0099 100644
--- a/samples/flickr/src/main/res/values/dimens.xml
+++ b/samples/flickr/src/main/res/values/dimens.xml
@@ -3,4 +3,7 @@
     <dimen name="medium_photo_side">110dp</dimen>
     <dimen name="small_photo_side">55dp</dimen>
     <dimen name="flickr_list_item_height">170dp</dimen>
-</resources>
\ No newline at end of file
+    <dimen name="grid_margin">5dp</dimen>
+    <dimen name="page_margin">8dp</dimen>
+</resources>
+
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index a81072972..9f1cce8bc 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -2,20 +2,24 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName "1.0"
+        versionName '1.0'
     }
 
     compileOptions {
@@ -26,5 +30,5 @@ android {
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
-    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.gallery/.MainActivity'
 }
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
new file mode 100644
index 000000000..5c710c8c7
--- /dev/null
+++ b/samples/gallery/lint.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+</lint>
diff --git a/samples/gallery/src/main/AndroidManifest.xml b/samples/gallery/src/main/AndroidManifest.xml
index 45c77627e..41c16f292 100644
--- a/samples/gallery/src/main/AndroidManifest.xml
+++ b/samples/gallery/src/main/AndroidManifest.xml
@@ -1,12 +1,13 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide.samples.gallery"
-          android:versionCode="1"
-          android:versionName="1.0">
-  <uses-sdk android:minSdkVersion="19"
-    android:targetSdkVersion="19" />
+          package="com.bumptech.glide.samples.gallery">
+
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-  <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">
+
+  <application
+          android:label="@string/app_name"
+          android:icon="@android:drawable/sym_def_app_icon"
+          android:allowBackup="false">
     <activity android:name=".MainActivity"
               android:label="@string/app_name">
       <intent-filter>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
new file mode 100644
index 000000000..e5d4888ab
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.gallery;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Gallery sample.
+ */
+@GlideModule
+public final class GalleryModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
new file mode 100644
index 000000000..30933931c
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.samples.gallery;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+import java.util.List;
+
+/**
+ * Displays media store data in a recycler view.
+ */
+public class HorizontalGalleryFragment extends Fragment
+    implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {
+
+  private RecyclerView recyclerView;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    getLoaderManager().initLoader(R.id.loader_id_media_store_data, null, this);
+  }
+
+  @Override
+  public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    View result = inflater.inflate(R.layout.recycler_view, container, false);
+    recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
+    GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
+    layoutManager.setOrientation(RecyclerView.HORIZONTAL);
+    recyclerView.setLayoutManager(layoutManager);
+    recyclerView.setHasFixedSize(true);
+
+    return result;
+  }
+
+  @Override
+  public Loader<List<MediaStoreData>> onCreateLoader(int i, Bundle bundle) {
+    return new MediaStoreDataLoader(getActivity());
+  }
+
+  @Override
+  public void onLoadFinished(Loader<List<MediaStoreData>> loader,
+      List<MediaStoreData> mediaStoreData) {
+    GlideRequests glideRequests = GlideApp.with(this);
+    RecyclerAdapter adapter =
+        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
+    RecyclerViewPreloader<MediaStoreData> preloader =
+        new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
+    recyclerView.addOnScrollListener(preloader);
+    recyclerView.setAdapter(adapter);
+  }
+
+  @Override
+  public void onLoaderReset(Loader<List<MediaStoreData>> loader) {
+    // Do nothing.
+  }
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index 6ce32bcff..f600840b1 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -2,27 +2,17 @@
 
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.MemoryCategory;
 
 /**
- * Displays a {@link com.bumptech.glide.samples.gallery.RecyclerViewFragment}.
+ * Displays a {@link HorizontalGalleryFragment}.
  */
 public class MainActivity extends FragmentActivity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.fragment_container);
-        Glide.get(this).setMemoryCategory(MemoryCategory.HIGH);
-
-        if (savedInstanceState == null) {
-            RecyclerViewFragment fragment = new RecyclerViewFragment();
-            getSupportFragmentManager()
-                    .beginTransaction()
-                    .replace(R.id.fragment_container, fragment)
-                    .commit();
-        }
+        setContentView(R.layout.main_activity);
+        GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
     }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index e8d2bb95c..efe2366d5 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -6,7 +6,6 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.support.v4.content.AsyncTaskLoader;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 1b26904ad..2486badfd 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -1,13 +1,8 @@
 package com.bumptech.glide.samples.gallery;
 
-import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
-import static com.bumptech.glide.request.RequestOptions.signatureOf;
-
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -16,44 +11,39 @@
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import android.widget.ImageView;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
-
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
  */
-class RecyclerAdapter extends RecyclerView.Adapter
+class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ListViewHolder>
     implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
     ListPreloader.PreloadModelProvider<MediaStoreData> {
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
-  private final RequestBuilder<Drawable> requestBuilder;
+  private final GlideRequest<Drawable> requestBuilder;
 
   private int[] actualDimensions;
 
-  RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
+  RecyclerAdapter(Context context, List<MediaStoreData> data, GlideRequests glideRequests) {
     this.data = data;
-    requestBuilder = requestManager
-        .asDrawable()
-        .apply(fitCenterTransform(context));
+    requestBuilder = glideRequests.asDrawable().fitCenter();
 
     setHasStableIds(true);
 
-    screenWidth = getWidth(context);
+    screenWidth = getScreenWidth(context);
   }
 
   @Override
-  public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
-    final View view = LayoutInflater.from(viewGroup.getContext())
-        .inflate(R.layout.recycler_item, viewGroup, false);
+  public ListViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+    LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());
+    final View view = inflater.inflate(R.layout.recycler_item, viewGroup, false);
     view.getLayoutParams().width = screenWidth;
 
     if (actualDimensions == null) {
@@ -73,19 +63,17 @@ public boolean onPreDraw() {
   }
 
   @Override
-  public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+  public void onBindViewHolder(ListViewHolder viewHolder, int position) {
     MediaStoreData current = data.get(position);
 
-    final ListViewHolder vh = (ListViewHolder) viewHolder;
-
     Key signature =
         new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
 
     requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(current.uri)
-        .into(vh.image);
+        .into(viewHolder.image);
   }
 
   @Override
@@ -109,12 +97,12 @@ public int getItemViewType(int position) {
   }
 
   @Override
-  public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(item.uri);
   }
 
@@ -124,21 +112,13 @@ public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
   }
 
   // Display#getSize(Point)
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
   @SuppressWarnings("deprecation")
-  private static int getWidth(Context context) {
+  private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
     Display display = wm.getDefaultDisplay();
-
-    final int result;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-      Point size = new Point();
-      display.getSize(size);
-      result = size.x;
-    } else {
-      result = display.getWidth();
-    }
-    return result;
+    Point size = new Point();
+    display.getSize(size);
+    return size.x;
   }
 
   /**
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerViewFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerViewFragment.java
deleted file mode 100644
index a07e5099d..000000000
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerViewFragment.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.bumptech.glide.samples.gallery;
-
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.support.v7.widget.GridLayoutManager;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AbsListView;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.ListPreloader;
-import com.bumptech.glide.RequestManager;
-
-import java.util.List;
-
-/**
- * Displays media store data in a recycler view.
- */
-public class RecyclerViewFragment extends Fragment
-    implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {
-
-  private RecyclerView recyclerView;
-
-  @Override
-  public void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    getLoaderManager().initLoader(R.id.loader_id_media_store_data, null, this);
-  }
-
-  @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    View result = inflater.inflate(R.layout.recycler_view, container, false);
-    recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
-    GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
-    layoutManager.setOrientation(RecyclerView.HORIZONTAL);
-    recyclerView.setLayoutManager(layoutManager);
-    recyclerView.setHasFixedSize(true);
-
-    return result;
-  }
-
-  @Override
-  public Loader<List<MediaStoreData>> onCreateLoader(int i, Bundle bundle) {
-    return new MediaStoreDataLoader(getActivity());
-  }
-
-  @Override
-  public void onLoadFinished(Loader<List<MediaStoreData>> loader,
-      List<MediaStoreData> mediaStoreData) {
-    RequestManager requestManager = Glide.with(this);
-    RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);
-    ListPreloader<MediaStoreData> preloader =
-        new ListPreloader<>(requestManager, adapter, adapter, 3);
-    RecyclerViewPreloaderListener recyclerViewPreloaderListener =
-        new RecyclerViewPreloaderListener(preloader);
-    recyclerView.addOnScrollListener(recyclerViewPreloaderListener);
-    recyclerView.setAdapter(adapter);
-  }
-
-  @Override
-  public void onLoaderReset(Loader<List<MediaStoreData>> loader) {
-    // Do nothing.
-  }
-
-  private static class RecyclerViewPreloaderListener extends RecyclerView.OnScrollListener {
-    private final AbsListView.OnScrollListener scrollListener;
-    private int lastFirstVisible = -1;
-    private int lastVisibleCount = -1;
-    private int lastItemCount = -1;
-
-    public RecyclerViewPreloaderListener(AbsListView.OnScrollListener scrollListener) {
-      this.scrollListener = scrollListener;
-    }
-
-    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
-      // Adapter the recycler view scroll listener interface to match ListView's.
-      LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
-      int firstVisible = layoutManager.findFirstVisibleItemPosition();
-      int visibleCount = Math.abs(firstVisible - layoutManager.findLastVisibleItemPosition());
-      int itemCount = recyclerView.getAdapter().getItemCount();
-      if (firstVisible != lastFirstVisible || visibleCount != lastVisibleCount
-          || itemCount != lastItemCount) {
-        scrollListener.onScroll(null, firstVisible, visibleCount, itemCount);
-        lastFirstVisible = firstVisible;
-        lastFirstVisible = visibleCount;
-        lastItemCount = itemCount;
-      }
-    }
-  }
-}
diff --git a/samples/gallery/src/main/res/drawable-hdpi/ic_launcher.png b/samples/gallery/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5b..000000000
Binary files a/samples/gallery/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/gallery/src/main/res/drawable-ldpi/ic_launcher.png b/samples/gallery/src/main/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 99238729d..000000000
Binary files a/samples/gallery/src/main/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/samples/gallery/src/main/res/drawable-mdpi/ic_launcher.png b/samples/gallery/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047dfa..000000000
Binary files a/samples/gallery/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/gallery/src/main/res/drawable-xhdpi/ic_launcher.png b/samples/gallery/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760f..000000000
Binary files a/samples/gallery/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/samples/gallery/src/main/res/layout/fragment_container.xml b/samples/gallery/src/main/res/layout/fragment_container.xml
deleted file mode 100644
index 0c944f35d..000000000
--- a/samples/gallery/src/main/res/layout/fragment_container.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-   android:id="@+id/fragment_container"
-   android:layout_width="match_parent"
-   android:layout_height="match_parent" />
diff --git a/samples/gallery/src/main/res/layout/main.xml b/samples/gallery/src/main/res/layout/main.xml
deleted file mode 100644
index 9c0faaf51..000000000
--- a/samples/gallery/src/main/res/layout/main.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-  android:id="@+id/fragment_container"
-  android:layout_width="match_parent"
-  android:layout_height="match_parent" />
-
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
new file mode 100644
index 000000000..18c1a634f
--- /dev/null
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <fragment
+            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:id="@+id/horizontal_gallery_fragment"/>
+</merge>
diff --git a/samples/gallery/src/main/res/layout/media_page.xml b/samples/gallery/src/main/res/layout/media_page.xml
deleted file mode 100644
index 0b6f53495..000000000
--- a/samples/gallery/src/main/res/layout/media_page.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <ImageView
-    android:id="@+id/media_view"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" />
-  <ImageView
-    android:id="@+id/play_button"
-    android:layout_width="wrap_content"
-    android:layout_height="wrap_content"
-    android:layout_gravity="center"
-    android:src="@android:drawable/ic_media_play" />
-</FrameLayout>
\ No newline at end of file
diff --git a/samples/gallery/src/main/res/layout/one_up.xml b/samples/gallery/src/main/res/layout/one_up.xml
deleted file mode 100644
index d0a5dc40d..000000000
--- a/samples/gallery/src/main/res/layout/one_up.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent">
-  <android.support.v4.view.ViewPager
-    android:id="@+id/media_pager"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" />
-</FrameLayout>
\ No newline at end of file
diff --git a/samples/gallery/src/main/res/layout/recycler_item.xml b/samples/gallery/src/main/res/layout/recycler_item.xml
index 39c20e669..84eb858dd 100644
--- a/samples/gallery/src/main/res/layout/recycler_item.xml
+++ b/samples/gallery/src/main/res/layout/recycler_item.xml
@@ -4,4 +4,5 @@
    android:paddingLeft="5dp"
    android:paddingRight="5dp"
    android:layout_width="match_parent"
-   android:layout_height="match_parent"/>
+   android:layout_height="match_parent"
+   android:contentDescription="@string/image_content_description"/>
diff --git a/samples/gallery/src/main/res/values/ids.xml b/samples/gallery/src/main/res/values/ids.xml
index f8f388e7d..6187e3ee6 100644
--- a/samples/gallery/src/main/res/values/ids.xml
+++ b/samples/gallery/src/main/res/values/ids.xml
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
   <item type="id" name="loader_id_media_store_data" />
-</resources>
\ No newline at end of file
+</resources>
diff --git a/samples/gallery/src/main/res/values/strings.xml b/samples/gallery/src/main/res/values/strings.xml
index 467ca3b81..c1e016007 100644
--- a/samples/gallery/src/main/res/values/strings.xml
+++ b/samples/gallery/src/main/res/values/strings.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
   <string name="app_name">gallery</string>
+  <string name="image_content_description">Photo</string>
 </resources>
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 5f69cc909..e2931ad27 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -2,7 +2,12 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
-    compile 'com.google.code.gson:gson:2.3'
+    compile(project(':integration:recyclerview')) {
+        transitive = false
+    }
+    compile 'com.google.code.gson:gson:2.4'
+    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
@@ -11,10 +16,10 @@ android {
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
-        minSdkVersion 14
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
new file mode 100644
index 000000000..95a2ab036
--- /dev/null
+++ b/samples/giphy/lint.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+</lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index e5f73a261..8d3ac29ac 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -3,8 +3,6 @@
           package="com.bumptech.glide.samples.giphy">
 
     <uses-permission android:name="android.permission.INTERNET"/>
-    <uses-sdk android:minSdkVersion="10"
-      android:targetSdkVersion="19" />
 
     <application
         android:allowBackup="true"
@@ -22,10 +20,5 @@
             </intent-filter>
         </activity>
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 25530c572..921dc0db6 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.samples.giphy;
 
-import com.google.gson.Gson;
-
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-
+import com.google.gson.Gson;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -22,11 +20,11 @@
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
   private static final String BASE_URL = "https://api.giphy.com/";
-  private static final String SEARCH_PATH = "/v1/gifs/search";
-  private static final String TRENDING_PATH = "/v1/gifs/trending";
+  private static final String SEARCH_PATH = "v1/gifs/search";
+  private static final String TRENDING_PATH = "v1/gifs/trending";
   private final Handler bgHandler;
   private final Handler mainHandler;
-  private final HashSet<Monitor> monitors = new HashSet<Monitor>();
+  private final HashSet<Monitor> monitors = new HashSet<>();
 
   private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
@@ -154,7 +152,7 @@ public String toString() {
    */
   public static class GifResult {
     public String id;
-    // Page url not gif url
+    // Page url not GIF url
     public String url;
     public GifUrlSet images;
 
@@ -171,13 +169,13 @@ public String toString() {
    */
   public static class GifUrlSet {
     public GifImage original;
-    public GifImage fixed_width_downsampled;
-    public GifImage fixed_height_downsampled;
+    public GifImage fixed_width;
+    public GifImage fixed_height;
 
     @Override
     public String toString() {
-      return "GifUrlSet{" + "original=" + original + ", fixed_width_downsampled="
-          + fixed_width_downsampled + ", fixed_height_downsampled=" + fixed_height_downsampled
+      return "GifUrlSet{" + "original=" + original + ", fixed_width="
+          + fixed_width + ", fixed_height=" + fixed_height
           + '}';
     }
   }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index 72b2234f2..fd796461e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -2,8 +2,6 @@
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 
-import com.google.gson.Gson;
-
 import android.app.Activity;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -14,12 +12,14 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
+import com.google.gson.Gson;
 
 /**
  * An {@link android.app.Activity} for displaying full size original GIFs.
@@ -62,21 +62,22 @@ public void onClick(View view) {
     });
 
     RequestBuilder<Drawable> thumbnailRequest = Glide.with(this)
-        .asDrawable()
-        .apply(decodeTypeOf(Bitmap.class))
-        .load(result);
+        .load(result)
+        .apply(decodeTypeOf(Bitmap.class));
 
-    Glide.with(this).asDrawable().thumbnail(thumbnailRequest).load(result.images.original.url)
+    Glide.with(this)
+        .load(result.images.original.url)
+        .thumbnail(thumbnailRequest)
         .listener(new RequestListener<Drawable>() {
           @Override
-          public boolean onLoadFailed(Object model, Target<Drawable> target,
+          public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
               boolean isFirstResource) {
             return false;
           }
 
           @Override
           public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
-              boolean isFromMemoryCache, boolean isFirstResource) {
+              DataSource dataSource, boolean isFirstResource) {
             if (resource instanceof GifDrawable) {
               gifDrawable = (GifDrawable) resource;
             } else {
@@ -84,6 +85,7 @@ public boolean onResourceReady(Drawable resource, Object model, Target<Drawable>
             }
             return false;
           }
-        }).into(gifView);
+        })
+        .into(gifView);
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 7bc9bab9c..999600314 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,24 +1,24 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
-
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ * Configures Glide for the Giphy sample app.
  */
-public class GiphyGlideModule implements GlideModule {
+@GlideModule
+public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index d2c93ab6c..184e976ea 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide.samples.giphy;
 
-import android.content.Context;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
-
 import java.io.InputStream;
 
 /**
@@ -31,8 +28,7 @@ public boolean handles(Api.GifResult model) {
 
 
     @Override
-    public ModelLoader<Api.GifResult, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
@@ -48,9 +44,9 @@ public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
 
   @Override
   protected String getUrl(Api.GifResult model, int width, int height, Options options) {
-    Api.GifImage fixedHeight = model.images.fixed_height_downsampled;
+    Api.GifImage fixedHeight = model.images.fixed_height;
     int fixedHeightDifference = getDifference(fixedHeight, width, height);
-    Api.GifImage fixedWidth = model.images.fixed_width_downsampled;
+    Api.GifImage fixedWidth = model.images.fixed_width;
     int fixedWidthDifference = getDifference(fixedWidth, width, height);
     if (fixedHeightDifference < fixedWidthDifference && !TextUtils.isEmpty(fixedHeight.url)) {
       return fixedHeight.url;
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index f679ba69f..3321f9ab7 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -7,19 +7,17 @@
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
-import android.util.Log;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
 import android.widget.ImageView;
-import android.widget.ListView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -27,8 +25,6 @@
  * Giphy's api.
  */
 public class MainActivity extends Activity implements Api.Monitor {
-  private static final String TAG = "GiphyActivity";
-
   private GifAdapter adapter;
 
   @Override
@@ -39,28 +35,29 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
 
     Glide.with(this)
-        .asDrawable()
         .load(R.raw.large_giphy_logo)
         .into(giphyLogoView);
 
-    ListView gifList = (ListView) findViewById(R.id.gif_list);
+    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
+    gifList.setLayoutManager(layoutManager);
 
     RequestBuilder<Drawable> gifItemRequest = Glide.with(this).asDrawable();
 
     ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
-        new ViewPreloadSizeProvider<Api.GifResult>();
+        new ViewPreloadSizeProvider<>();
     adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
     gifList.setAdapter(adapter);
-    ListPreloader<Api.GifResult> preloader =
-        new ListPreloader<Api.GifResult>(Glide.with(this), adapter, preloadSizeProvider, 2);
-    gifList.setOnScrollListener(preloader);
+    RecyclerViewPreloader<Api.GifResult> preloader =
+        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);
+    gifList.addOnScrollListener(preloader);
   }
 
   @Override
   protected void onStart() {
     super.onStart();
     Api.get().addMonitor(this);
-    if (adapter.getCount() == 0) {
+    if (adapter.getItemCount() == 0) {
       Api.get().getTrending();
     }
   }
@@ -76,8 +73,8 @@ public void onSearchComplete(Api.SearchResult result) {
     adapter.setResults(result.data);
   }
 
-  private static class GifAdapter extends BaseAdapter implements ListPreloader
-      .PreloadModelProvider<Api.GifResult> {
+  private static class GifAdapter extends RecyclerView.Adapter<GifViewHolder>
+      implements ListPreloader.PreloadModelProvider<Api.GifResult> {
     private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
     private final Activity activity;
@@ -103,38 +100,21 @@ public void setResults(Api.GifResult[] results) {
     }
 
     @Override
-    public int getCount() {
-      return results.length;
-    }
-
-    @Override
-    public Api.GifResult getItem(int i) {
-      return results[i];
+    public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      View view = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);
+      return new GifViewHolder(view);
     }
 
     @Override
-    public long getItemId(int i) {
-      return 0;
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);
-      }
-
+    public void onBindViewHolder(GifViewHolder holder, int position) {
       final Api.GifResult result = results[position];
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "load result: " + result);
-      }
-      final ImageView gifView = (ImageView) convertView.findViewById(R.id.gif_view);
-      gifView.setOnClickListener(new View.OnClickListener() {
+      holder.gifView.setOnClickListener(new View.OnClickListener() {
         @Override
         public void onClick(View view) {
           ClipboardManager clipboard =
               (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
           ClipData clip =
-              ClipData.newPlainText("giphy_url", result.images.fixed_height_downsampled.url);
+              ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
           clipboard.setPrimaryClip(clip);
 
           Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
@@ -142,23 +122,38 @@ public void onClick(View view) {
         }
       });
 
-      requestBuilder.load(result).into(gifView);
+      requestBuilder.load(result).into(holder.gifView);
 
-      preloadSizeProvider.setView(gifView);
+      preloadSizeProvider.setView(holder.gifView);
+    }
 
-      return convertView;
+    @Override
+    public long getItemId(int i) {
+      return 0;
+    }
+
+    @Override
+    public int getItemCount() {
+      return results.length;
     }
 
     @Override
     public List<Api.GifResult> getPreloadItems(int position) {
-      List<Api.GifResult> items = new ArrayList<Api.GifResult>(1);
-      items.add(getItem(position));
-      return items;
+      return Collections.singletonList(results[position]);
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
+
+  private static class GifViewHolder extends RecyclerView.ViewHolder {
+    private final ImageView gifView;
+
+    public GifViewHolder(View itemView) {
+      super(itemView);
+      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
+    }
+  }
 }
diff --git a/samples/giphy/src/main/res/layout/activity_main.xml b/samples/giphy/src/main/res/layout/activity_main.xml
index 629745ecb..332705305 100644
--- a/samples/giphy/src/main/res/layout/activity_main.xml
+++ b/samples/giphy/src/main/res/layout/activity_main.xml
@@ -2,24 +2,18 @@
               xmlns:tools="http://schemas.android.com/tools"
               android:layout_width="match_parent"
               android:layout_height="match_parent"
-              android:paddingLeft="@dimen/activity_horizontal_margin"
-              android:paddingRight="@dimen/activity_horizontal_margin"
-              android:paddingTop="@dimen/activity_vertical_margin"
-              android:paddingBottom="@dimen/activity_vertical_margin"
+              android:layout_margin="@dimen/activity_margin"
               android:orientation="vertical"
               tools:context=".MainActivity">
-
     <ImageView
         android:id="@+id/giphy_logo_view"
         android:layout_width="100dp"
         android:layout_height="50dp"
         android:layout_gravity="center_horizontal"
-        android:contentDescription="@string/giphy_logo_description"
-        />
-
-    <ListView
+        android:contentDescription="@string/giphy_logo_description" />
+    <android.support.v7.widget.RecyclerView
         android:id="@+id/gif_list"
-        android:layout_width="match_parent"
         android:layout_height="0dp"
+        android:layout_width="match_parent"
         android:layout_weight="1"/>
 </LinearLayout>
diff --git a/samples/giphy/src/main/res/values-w820dp/dimens.xml b/samples/giphy/src/main/res/values-w820dp/dimens.xml
deleted file mode 100644
index 63fc81644..000000000
--- a/samples/giphy/src/main/res/values-w820dp/dimens.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
-         (such as screen margins) for screens with more than 820dp of available width. This
-         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
-    <dimen name="activity_horizontal_margin">64dp</dimen>
-</resources>
diff --git a/samples/giphy/src/main/res/values/dimens.xml b/samples/giphy/src/main/res/values/dimens.xml
index 47c822467..e641ba457 100644
--- a/samples/giphy/src/main/res/values/dimens.xml
+++ b/samples/giphy/src/main/res/values/dimens.xml
@@ -1,5 +1,3 @@
 <resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="activity_margin">16dp</dimen>
 </resources>
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 973afa473..e244935ea 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,7 +1,9 @@
 apply plugin: 'com.android.application'
 
-repositories {
-    mavenCentral()
+dependencies {
+    compile project(':library')
+    annotationProcessor project(':annotation:compiler')
+    compile 'com.caverock:androidsvg:1.2.1'
 }
 
 android {
@@ -23,11 +25,6 @@ android {
     }
 }
 
-dependencies {
-    compile project(':library')
-    compile 'com.caverock:androidsvg:1.2.1'
-}
-
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
     commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity'
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
new file mode 100644
index 000000000..95a2ab036
--- /dev/null
+++ b/samples/svg/lint.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+</lint>
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 9eb410d93..7328e723d 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -8,9 +8,6 @@
         android:allowBackup="true"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
-        <meta-data
-            android:name="com.bumptech.glide.samples.svg.SvgModule"
-            android:value="GlideModule"/>
         <activity
             android:name=".MainActivity"
             android:label="@string/app_name">
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index 0587c01f7..f60b46461 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.svg;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 
 import android.app.Activity;
 import android.content.ContentResolver;
@@ -12,10 +11,8 @@
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
-
 import java.io.File;
 
 /**
@@ -36,10 +33,10 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = Glide.with(this)
+    requestBuilder = GlideApp.with(this)
         .as(PictureDrawable.class)
-        .apply(placeholderOf(R.drawable.image_loading)
-            .error(R.drawable.image_error))
+        .placeholder(R.drawable.image_loading)
+        .error(R.drawable.image_error)
         .transition(withCrossFade())
         .listener(new SvgSoftwareLayerSetter());
   }
@@ -52,9 +49,10 @@ protected void onStart() {
 
   public void clearCache(View v) {
     Log.w(TAG, "clearing cache");
-    Glide.with(this).clear(imageViewRes);
-    Glide.with(this).clear(imageViewNet);
-    Glide.get(this).clearMemory();
+    GlideRequests glideRequests = GlideApp.with(this);
+    glideRequests.clear(imageViewRes);
+    glideRequests.clear(imageViewNet);
+    GlideApp.get(this).clearMemory();
     File cacheDir = Glide.getPhotoCacheDir(this);
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index b3cfcbfe0..372fbefb6 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,26 +2,26 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.caverock.androidsvg.SVG;
-
 import java.io.InputStream;
 
 /**
  * Module for the SVG sample app.
  */
-public class SvgModule implements GlideModule {
-  @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
-  }
-
+@GlideModule
+public class SvgModule extends AppGlideModule {
   @Override
   public void registerComponents(Context context, Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
+
+  // Disable manifest parsing to avoid adding similar modules twice.
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return false;
+  }
 }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index 5c7095db9..a28a21b7c 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.samples.svg;
 
-import android.annotation.TargetApi;
 import android.graphics.drawable.PictureDrawable;
-import android.os.Build;
 import android.widget.ImageView;
-
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.ImageViewTarget;
 import com.bumptech.glide.request.target.Target;
@@ -14,26 +13,21 @@
  * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
  * a hardware backed {@link android.graphics.Canvas Canvas}.
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
-  public boolean onLoadFailed(Object model, Target<PictureDrawable> target,
+  public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
       boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
   @Override
   public boolean onResourceReady(PictureDrawable resource, Object model,
-      Target<PictureDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
+      Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
   }
 }
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
new file mode 100755
index 000000000..a8646613b
--- /dev/null
+++ b/scripts/update_javadocs.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+set -e
+set -o pipefail
+
+TEMP_DIR="/tmp/tmp_glide_javadoc"
+JAVADOC_GH_PAGES_DIR="javadocs"
+
+if [[ -z "$1" ]]; 
+then
+  echo "You must supply a target version"
+  echo "Usage ./scripts/update_javadocs.sh <400>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]];
+then 
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+
+if [ -e "$JAVADOC_GH_PAGES_DIR" ];
+then 
+  echo "javadocs directory exists locally, remove first."
+  exit 1
+fi
+
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
+then 
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
+then 
+  echo "Origin and gh-pages are not up to date"
+  git rev-list gh-pages...origin/gh-pages --pretty
+  exit 1
+fi
+
+git checkout master
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
+./gradlew clean releaseJavadocJar javadoc
+rm -rf $TEMP_DIR
+cp -r glide/build/docs/javadoc $TEMP_DIR
+git checkout gh-pages
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf $TEMP_DIR
+git add "${JAVADOC_GH_PAGES_DIR}/$1" 
+git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git log -1 --pretty=%B
+echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index ec5af0341..c35434caa 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,6 +15,10 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
+ * Local test with (..._REPOSITORY_URL properties must be full paths):
+ * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
+ * For faster runs add: -x check
+ * 
  */
 
 apply plugin: 'maven'
@@ -29,20 +33,20 @@ def isReleaseBuild() {
 
 def getReleaseRepositoryUrl() {
     return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+            : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
     return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-            : "https://oss.sonatype.org/content/repositories/snapshots/"
+            : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
 def getRepositoryUsername() {
-    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME')?NEXUS_USERNAME:"")
+    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : '')
 }
 
 def getRepositoryPassword() {
-    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD')?NEXUS_PASSWORD:"")
+    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : '')
 }
 
 afterEvaluate { project ->
@@ -51,6 +55,11 @@ afterEvaluate { project ->
     uploadArchives {
         repositories {
             mavenDeployer {
+                // allow uploading through FTP protocol with the following command:
+                // gradle uploadArchives -PSNAPSHOT_REPOSITORY_URL=ftp://host/repo/path -PUSERNAME=uname -PPASSWORD=passwd
+                configuration = configurations.create('deployerJars')
+                configuration.dependencies.add dependencies.create('org.apache.maven.wagon:wagon-ftp:2.2')
+
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
                 pom.groupId = GROUP
@@ -78,14 +87,14 @@ afterEvaluate { project ->
 
                     licenses {
                         license {
-                            name = "Simplified BSD License"
-                            url = "http://www.opensource.org/licenses/bsd-license"
-                            distribution = "repo"
+                            name = 'Simplified BSD License'
+                            url = 'http://www.opensource.org/licenses/bsd-license'
+                            distribution = 'repo'
                         }
                         license {
-                            name = "The Apache Software License, Version 2.0"
-                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
-                            distribution = "repo"
+                            name = 'The Apache Software License, Version 2.0'
+                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                            distribution = 'repo'
                         }
                     }
 
@@ -102,25 +111,25 @@ afterEvaluate { project ->
     }
 
     signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }
         sign configurations.archives
     }
 
-    if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-        def releaseVariants = project.android.libraryVariants.findAll { variant ->
-            variant.buildType.name.equalsIgnoreCase("release")
-        }
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
-        def androidSdkDirectory = project.android.sdkDirectory
+    if (isAndroidProject) {
+        def releaseVariants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('release')
+        }
 
-        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJava) {
+        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJavaWithJavac) {
             source = releaseVariants.collect { it.javaCompile.source }
             classpath = files(releaseVariants.collect { files(it.javaCompile.classpath.files,
                     project.android.bootClasspath) })
 
             options {
-                links("http://docs.oracle.com/javase/7/docs/api/")
-                linksOffline("http://d.android.com/reference", "${androidSdkDirectory}/docs/reference")
+                links('http://docs.oracle.com/javase/7/docs/api/')
+                linksOffline('http://d.android.com/reference', "${android.sdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
@@ -128,24 +137,45 @@ afterEvaluate { project ->
         }
 
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+            classifier = 'javadoc'
             from androidJavadocs.destinationDir
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
         task androidSourcesJar(type: Jar) {
+            classifier = 'sources'
             from project.android.sourceSets.main.java.source
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
-    }
 
-    artifacts {
-        if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-            archives androidSourcesJar {
-                classifier "sources"
-            }
-            archives androidJavadocsJar {
-                classifier "javadoc"
-            }
+        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
+            from compileReleaseJavaWithJavac.destinationDir
+            exclude '**/R.class'
+            exclude '**/BuildConfig.class'
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
+        }
+
+        artifacts {
+            archives androidLibraryJar
+            archives androidSourcesJar
+            archives androidJavadocsJar
+        }
+    } else if (project.plugins.hasPlugin('java')) {
+        task sourcesJar(type: Jar, dependsOn: classes) {
+            classifier = 'sources'
+            from sourceSets.main.allSource
+        }
+
+        task javadocsJar(type: Jar, dependsOn: javadoc) {
+            classifier = 'javadoc'
+            from javadoc.destinationDir
+        }
+
+        artifacts {
+            archives sourcesJar
+            archives javadocsJar
         }
     }
+    logger.info("Published artifacts in ${configurations.archives}:")
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
 }
diff --git a/settings.gradle b/settings.gradle
index 575e72c6c..650b0e229 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,9 @@
+exec {
+    commandLine "git", "submodule", "update", "--init", "--recursive"
+}
 include ':library'
+include ':annotation'
+include ':annotation:compiler'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
@@ -6,10 +11,13 @@ include ':samples:flickr'
 include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
+include ':samples:contacturi'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':integration:okhttp3'
 include ':integration:gifencoder'
+include ':integration:recyclerview'
 include ':testutil'
 
 rootProject.name = 'glide-parent'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index d311d940f..54f7cbaf9 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -17,7 +17,7 @@ private TestResourceUtil() {
    * @param subPath   The sub-path under androidTest/resources where the desired resource is
    *                  located. Should not be prefixed with a '/'
    */
-  public static InputStream openResource(Class testClass, String subPath) {
+  public static InputStream openResource(Class<?> testClass, String subPath) {
     return testClass.getResourceAsStream("/" + subPath);
   }
 }
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 2d4ab7b5b..9c93de9e5 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -14,7 +14,7 @@ private TestUtil() {
     // Utility class.
   }
 
-  public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
+  public static byte[] resourceToBytes(Class<?> testClass, String resourceName) throws IOException {
     return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
   }
 
@@ -33,7 +33,7 @@ private TestUtil() {
   }
 
   public static String isToString(InputStream is) throws IOException {
-    return new String(isToBytes(is));
+    return new String(isToBytes(is), "utf-8");
   }
 
   public static void assertStreamOf(String expected, InputStream result) throws IOException {
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 847e0dad0..273f119c6 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e
+Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index a59032681..16e6d54fb 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,12 +1,13 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 
 dependencies {
+    compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
+
     testCompile project(':testutil')
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
@@ -19,3 +20,5 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
new file mode 100644
index 000000000..9ada85d40
--- /dev/null
+++ b/third_party/gif_decoder/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide GIF Decoder Library
+POM_ARTIFACT_ID=gifdecoder
+POM_PACKAGING=aar
+POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index cfd8b8a41..257cd98f0 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,137 +1,33 @@
 package com.bumptech.glide.gifdecoder;
 
-/**
- * Copyright (c) 2013 Xcellent Creations, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
-import android.util.Log;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
+import android.support.annotation.IntDef;
+import android.support.annotation.NonNull;
 import java.io.InputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames for animation
- * purposes.  Image data can be read from either and InputStream source or a byte[].
- *
- * This class is optimized for running animations with the frames, there are no methods to get
- * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
- * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
- * in the animation sequence.
- *
- * The animation must be manually moved forward using {@link #advance()} before requesting the next
- * frame.  This method must also be called before you request the first frame or an error will
- * occur.
- *
- * Implementation adapted from sample code published in Lyons. (2004). <em>Java for
- * Programmers</em>, republished under the MIT Open Source License
+ * Shared interface for GIF decoders.
  */
-public class GifDecoder {
-  private static final String TAG = GifDecoder.class.getSimpleName();
+public interface GifDecoder {
+  /** File read status: No errors. */
+  int STATUS_OK = 0;
+  /** File read status: Error decoding file (may be partially decoded). */
+  int STATUS_FORMAT_ERROR = 1;
+  /** File read status: Unable to open source. */
+  int STATUS_OPEN_ERROR = 2;
+  /** Unable to fully decode the current frame. */
+  int STATUS_PARTIAL_DECODE = 3;
+  /** The total iteration count which means repeat forever. */
+  int TOTAL_ITERATION_COUNT_FOREVER = 0;
 
-  /**
-   * File read status: No errors.
-   */
-  public static final int STATUS_OK = 0;
-  /**
-   * File read status: Error decoding file (may be partially decoded).
-   */
-  public static final int STATUS_FORMAT_ERROR = 1;
-  /**
-   * File read status: Unable to open source.
-   */
-  public static final int STATUS_OPEN_ERROR = 2;
-  /**
-   * Unable to fully decode the current frame.
-   */
-  public static final int STATUS_PARTIAL_DECODE = 3;
-  /**
-   * max decoder pixel stack size.
-   */
-  private static final int MAX_STACK_SIZE = 4096;
-
-  /**
-   * GIF Disposal Method meaning take no action.
-   */
-  private static final int DISPOSAL_UNSPECIFIED = 0;
-  /**
-   * GIF Disposal Method meaning leave canvas from previous frame.
-   */
-  private static final int DISPOSAL_NONE = 1;
-  /**
-   * GIF Disposal Method meaning clear canvas to background color.
-   */
-  private static final int DISPOSAL_BACKGROUND = 2;
-  /**
-   * GIF Disposal Method meaning clear canvas to frame before last.
-   */
-  private static final int DISPOSAL_PREVIOUS = 3;
-
-  private static final int NULL_CODE = -1;
-
-  private static final int INITIAL_FRAME_POINTER = -1;
-
-  private static final int BYTES_PER_INTEGER = 4;
-
-  // We can't tell if a gif has transparency to decode a partial frame on top of a previous
-  // frame, or if the final frame will actually have transparent pixels, so we must always use a
-  // format that supports  transparency. We can't use ARGB_4444 because of framework issues drawing
-  // onto ARGB_4444 Bitmaps using Canvas.
-  private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
-
-  // Global File Header values and parsing flags.
-  // Active color table.
-  private int[] act;
-
-  // Raw GIF data from input source.
-  private ByteBuffer rawData;
-
-  // Raw data read working array.
-  private final byte[] block = new byte[256];
-
-  private GifHeaderParser parser;
-
-  // LZW decoder working arrays.
-  private short[] prefix;
-  private byte[] suffix;
-  private byte[] pixelStack;
-  private byte[] mainPixels;
-  private int[] mainScratch;
-
-  private int framePointer;
-  private GifHeader header;
-  private BitmapProvider bitmapProvider;
-  private Bitmap previousImage;
-  private boolean savePrevious;
-  private int status;
-  private int sampleSize;
-  private int downsampledHeight;
-  private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  /** Android Lint annotation for status codes that can be used with a GIF decoder. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {STATUS_OK, STATUS_FORMAT_ERROR, STATUS_OPEN_ERROR, STATUS_PARTIAL_DECODE})
+  @interface GifDecodeStatus {
+  }
 
   /**
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
@@ -139,48 +35,49 @@
    */
   public interface BitmapProvider {
     /**
-     * Returns an {@link Bitmap} with exactly the given dimensions and config, or null if no such
-     * {@link Bitmap} could be obtained.
+     * Returns an {@link Bitmap} with exactly the given dimensions and config.
      *
      * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
      * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
      * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
      *               android.graphics.Bitmap}.
      */
+    @NonNull
     Bitmap obtain(int width, int height, Bitmap.Config config);
 
     /**
      * Releases the given Bitmap back to the pool.
      */
     void release(Bitmap bitmap);
-  }
 
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
-    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
-  }
+    /**
+     * Returns a byte array used for decoding and generating the frame bitmap.
+     *
+     * @param size the size of the byte array to obtain
+     */
+    byte[] obtainByteArray(int size);
 
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
-      int sampleSize) {
-    this(provider);
-    setData(gifHeader, rawData, sampleSize);
-  }
+    /**
+     * Releases the given byte array back to the pool.
+     */
+    void release(byte[] bytes);
 
-  public GifDecoder(BitmapProvider provider) {
-    this.bitmapProvider = provider;
-    header = new GifHeader();
-  }
+    /**
+     * Returns an int array used for decoding/generating the frame bitmaps.
+     */
+    int[] obtainIntArray(int size);
 
-  public int getWidth() {
-    return header.width;
+    /**
+     * Release the given array back to the pool.
+     */
+    void release(int[] array);
   }
 
-  public int getHeight() {
-    return header.height;
-  }
+  int getWidth();
 
-  public ByteBuffer getData() {
-    return rawData;
-  }
+  int getHeight();
+
+  ByteBuffer getData();
 
   /**
    * Returns the current status of the decoder.
@@ -189,16 +86,13 @@ public ByteBuffer getData() {
    * was decoded successfully and/or completely. Format and open failures persist across frames.
    * </p>
    */
-  public int getStatus() {
-    return status;
-  }
+  @GifDecodeStatus
+  int getStatus();
 
   /**
    * Move the animation frame counter forward.
    */
-  public void advance() {
-    framePointer = (framePointer + 1) % header.frameCount;
-  }
+  void advance();
 
   /**
    * Gets display duration for specified frame.
@@ -206,130 +100,95 @@ public void advance() {
    * @param n int index of frame.
    * @return delay in milliseconds.
    */
-  public int getDelay(int n) {
-    int delay = -1;
-    if ((n >= 0) && (n < header.frameCount)) {
-      delay = header.frames.get(n).delay;
-    }
-    return delay;
-  }
+  int getDelay(int n);
 
   /**
    * Gets display duration for the upcoming frame in ms.
    */
-  public int getNextDelay() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      return -1;
-    }
-
-    return getDelay(framePointer);
-  }
+  int getNextDelay();
 
   /**
    * Gets the number of frames read from file.
    *
    * @return frame count.
    */
-  public int getFrameCount() {
-    return header.frameCount;
-  }
+  int getFrameCount();
 
   /**
    * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
    *
    * @return frame index.
    */
-  public int getCurrentFrameIndex() {
-    return framePointer;
-  }
+  int getCurrentFrameIndex();
 
-  public void resetFrameIndex() {
-    framePointer = -1;
-  }
+  /**
+   * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
+   * decode any frames.
+   */
+  void resetFrameIndex();
 
   /**
-   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely.
    *
-   * @return iteration count if one was specified, else 1.
+   * @deprecated Use {@link #getNetscapeLoopCount()} instead.
+   *             This method cannot distinguish whether the loop count is 1 or doesn't exist.
+   * @return loop count if one was specified, else 1.
    */
-  public int getLoopCount() {
-    return header.loopCount;
-  }
+  @Deprecated
+  int getLoopCount();
+
+  /**
+   * Gets the "Netscape" loop count, if any.
+   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <br>
+   * Use {@link #getTotalIterationCount()}
+   * to know how many times the animation sequence should be displayed.
+   *
+   * @return loop count if one was specified,
+   *         else -1 ({@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}).
+   */
+  int getNetscapeLoopCount();
+
+  /**
+   * Gets the total count
+   * which represents how many times the animation sequence should be displayed.
+   * A count of 0 ({@link #TOTAL_ITERATION_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <p>
+   *     The total count is calculated as follows by using {@link #getNetscapeLoopCount()}.
+   *     This behavior is the same as most web browsers.
+   *     <table border='1'>
+   *         <tr class='tableSubHeadingColor'><th>{@code getNetscapeLoopCount()}</th>
+   *             <th>The total count</th></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}</td>
+   *             <td>{@link #TOTAL_ITERATION_COUNT_FOREVER}</td></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}</td>
+   *             <td>{@code 1}</td></tr>
+   *         <tr><td>{@code n (n > 0)}</td>
+   *             <td>{@code n + 1}</td></tr>
+   *     </table>
+   * </p>
+   *
+   * @see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=592735#c5">Discussion about
+   *      the iteration count of animated GIFs (Chromium Issue 592735)</a>
+   *
+   * @return total iteration count calculated from "Netscape" loop count.
+   */
+  int getTotalIterationCount();
 
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
    */
-  public int getByteSize() {
-    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
-  }
+  int getByteSize();
 
   /**
    * Get the next frame in the animation sequence.
    *
    * @return Bitmap representation of frame.
    */
-  public synchronized Bitmap getNextFrame() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
-            + framePointer);
-      }
-      status = STATUS_FORMAT_ERROR;
-    }
-    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to decode frame, status=" + status);
-      }
-      return null;
-    }
-    status = STATUS_OK;
-
-    GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
-    int previousIndex = framePointer - 1;
-    if (previousIndex >= 0) {
-      previousFrame = header.frames.get(previousIndex);
-    }
-
-    final int savedBgColor = header.bgColor;
-
-    // Set the appropriate color table.
-    if (currentFrame.lct == null) {
-      act = header.gct;
-    } else {
-      act = currentFrame.lct;
-      if (header.bgIndex == currentFrame.transIndex) {
-        header.bgColor = 0;
-      }
-    }
-
-    int save = 0;
-    if (currentFrame.transparency) {
-      save = act[currentFrame.transIndex];
-      // Set transparent color if specified.
-      act[currentFrame.transIndex] = 0;
-    }
-    if (act == null) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "No Valid Color Table");
-      }
-      // No color table defined.
-      status = STATUS_FORMAT_ERROR;
-      return null;
-    }
-
-    // Transfer pixel data to image.
-    Bitmap result = setPixels(currentFrame, previousFrame);
-
-    // Reset the transparent pixel in the color table
-    if (currentFrame.transparency) {
-      act[currentFrame.transIndex] = save;
-    }
-    header.bgColor = savedBgColor;
-
-    return result;
-  }
+  Bitmap getNextFrame();
 
   /**
    * Reads GIF image from stream.
@@ -337,97 +196,16 @@ public synchronized Bitmap getNextFrame() {
    * @param is containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public int read(InputStream is, int contentLength) {
-    if (is != null) {
-      try {
-        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-        int nRead;
-        byte[] data = new byte[16384];
-        while ((nRead = is.read(data, 0, data.length)) != -1) {
-          buffer.write(data, 0, nRead);
-        }
-        buffer.flush();
-
-        read(buffer.toByteArray());
-      } catch (IOException e) {
-        Log.w(TAG, "Error reading data from stream", e);
-      }
-    } else {
-      status = STATUS_OPEN_ERROR;
-    }
-
-    try {
-      if (is != null) {
-        is.close();
-      }
-    } catch (IOException e) {
-      Log.w(TAG, "Error closing stream", e);
-    }
-
-    return status;
-  }
+  @GifDecodeStatus
+  int read(InputStream is, int contentLength);
 
-  public void clear() {
-    header = null;
-    mainPixels = null;
-    mainScratch = null;
-    if (previousImage != null) {
-      bitmapProvider.release(previousImage);
-    }
-    previousImage = null;
-    rawData = null;
-    isFirstFrameTransparent = false;
-  }
+  void clear();
 
-  public synchronized void setData(GifHeader header, byte[] data) {
-    setData(header, ByteBuffer.wrap(data));
-  }
+  void setData(GifHeader header, byte[] data);
 
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
-    setData(header, buffer, 1);
-  }
+  void setData(GifHeader header, ByteBuffer buffer);
 
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
-    if (sampleSize <= 0) {
-      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
-    }
-    // Make sure sample size is a power of 2.
-    sampleSize = Integer.highestOneBit(sampleSize);
-    this.status = STATUS_OK;
-    this.header = header;
-    isFirstFrameTransparent = false;
-    framePointer = INITIAL_FRAME_POINTER;
-    // Initialize the raw data buffer.
-    rawData = buffer.asReadOnlyBuffer();
-    rawData.position(0);
-    rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-    // No point in specially saving an old frame if we're never going to use it.
-    savePrevious = false;
-    for (GifFrame frame : header.frames) {
-      if (frame.dispose == DISPOSAL_PREVIOUS) {
-        savePrevious = true;
-        break;
-      }
-    }
-
-    this.sampleSize = sampleSize;
-    // Now that we know the size, init scratch arrays.
-    // TODO: Find a way to avoid this entirely or at least downsample it
-    // (either should be possible).
-    mainPixels = new byte[header.width * header.height];
-    mainScratch = new int[(header.width / sampleSize) * (header.height / sampleSize)];
-    downsampledWidth = header.width / sampleSize;
-    downsampledHeight = header.height / sampleSize;
-  }
-
-  private GifHeaderParser getHeaderParser() {
-    if (parser == null) {
-      parser = new GifHeaderParser();
-    }
-    return parser;
-  }
+  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -435,355 +213,7 @@ private GifHeaderParser getHeaderParser() {
    * @param data containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public synchronized int read(byte[] data) {
-    this.header = getHeaderParser().setData(data).parseHeader();
-    if (data != null) {
-      setData(header, data);
-    }
-
-    return status;
-  }
-
-  /**
-   * Creates new frame image from current data (and previous frames as specified by their
-   * disposition codes).
-   */
-  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-    // Final location of blended pixels.
-    final int[] dest = mainScratch;
-
-    // fill in starting image contents based on last image's dispose code
-    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
-      // mainScratch and therefore so will our dest array.
-      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-        // Start with a canvas filled with the background color
-        int c = 0;
-        if (!currentFrame.transparency) {
-          c = header.bgColor;
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
-        }
-        Arrays.fill(dest, c);
-      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-        // Start with the previous frame
-        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-            downsampledHeight);
-      }
-    }
-
-    // Decode pixels for this frame  into the global pixels[] scratch.
-    decodeBitmapData(currentFrame);
-
-    int downsampledIH = currentFrame.ih / sampleSize;
-    int downsampledIY = currentFrame.iy / sampleSize;
-    int downsampledIW = currentFrame.iw / sampleSize;
-    int downsampledIX = currentFrame.ix / sampleSize;
-    // Copy each source line to the appropriate place in the destination.
-    int pass = 1;
-    int inc = 8;
-    int iline = 0;
-    boolean isFirstFrame = framePointer == 0;
-    for (int i = 0; i < downsampledIH; i++) {
-      int line = i;
-      if (currentFrame.interlace) {
-        if (iline >= downsampledIH) {
-          pass++;
-          switch (pass) {
-            case 2:
-              iline = 4;
-              break;
-            case 3:
-              iline = 2;
-              inc = 4;
-              break;
-            case 4:
-              iline = 1;
-              inc = 2;
-              break;
-            default:
-              break;
-          }
-        }
-        line = iline;
-        iline += inc;
-      }
-      line += downsampledIY;
-      if (line < downsampledHeight) {
-        int k = line * downsampledWidth;
-        // Start of line in dest.
-        int dx = k + downsampledIX;
-        // End of dest line.
-        int dlim = dx + downsampledIW;
-        if (k + downsampledWidth < dlim) {
-          // Past dest edge.
-          dlim = k + downsampledWidth;
-        }
-        // Start of line in source.
-        int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
-          if (averageColor != 0) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
-        }
-      }
-    }
-
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
-    }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
-  }
-
-  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
-      int currentFrameIw) {
-    int alphaSum = 0;
-    int redSum = 0;
-    int greenSum = 0;
-    int blueSum = 0;
-
-    int totalAdded = 0;
-    // Find the pixels in the current row.
-    for (int i = positionInMainPixels;
-        i < positionInMainPixels + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    // Find the pixels in the next row.
-    for (int i = positionInMainPixels + currentFrameIw;
-        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    if (totalAdded == 0) {
-      return 0;
-    } else {
-      return ((alphaSum / totalAdded) << 24)
-          | ((redSum / totalAdded) << 16)
-          | ((greenSum / totalAdded) << 8)
-          | (blueSum / totalAdded);
-     }
-  }
-
-  /**
-   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-   */
-  private void decodeBitmapData(GifFrame frame) {
-    if (frame != null) {
-      // Jump to the frame start position.
-      rawData.position(frame.bufferFrameStart);
-    }
-
-    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
-        i, datum,
-        dataSize, first, top, bi, pi;
-
-    if (mainPixels == null || mainPixels.length < npix) {
-      // Allocate new pixel array.
-      mainPixels = new byte[npix];
-    }
-    if (prefix == null) {
-      prefix = new short[MAX_STACK_SIZE];
-    }
-    if (suffix == null) {
-      suffix = new byte[MAX_STACK_SIZE];
-    }
-    if (pixelStack == null) {
-      pixelStack = new byte[MAX_STACK_SIZE + 1];
-    }
-
-    // Initialize GIF data stream decoder.
-    dataSize = read();
-    clear = 1 << dataSize;
-    endOfInformation = clear + 1;
-    available = clear + 2;
-    oldCode = NULL_CODE;
-    codeSize = dataSize + 1;
-    codeMask = (1 << codeSize) - 1;
-    for (code = 0; code < clear; code++) {
-      // XXX ArrayIndexOutOfBoundsException.
-      prefix[code] = 0;
-      suffix[code] = (byte) code;
-    }
-
-    // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
-        // Read a new data block.
-        count = readBlock();
-        if (count <= 0) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-        bi = 0;
-      }
-
-      datum += (((int) block[bi]) & 0xff) << bits;
-      bits += 8;
-      bi++;
-      count--;
-
-      while (bits >= codeSize) {
-        // Get the next code.
-        code = datum & codeMask;
-        datum >>= codeSize;
-        bits -= codeSize;
-
-        // Interpret the code.
-        if (code == clear) {
-          // Reset decoder.
-          codeSize = dataSize + 1;
-          codeMask = (1 << codeSize) - 1;
-          available = clear + 2;
-          oldCode = NULL_CODE;
-          continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
-          oldCode = code;
-          first = code;
-          continue;
-        }
-        inCode = code;
-        if (code >= available) {
-          pixelStack[top++] = (byte) first;
-          code = oldCode;
-        }
-        while (code >= clear) {
-          pixelStack[top++] = suffix[code];
-          code = prefix[code];
-        }
-        first = ((int) suffix[code]) & 0xff;
-        pixelStack[top++] = (byte) first;
-
-        // Add a new string to the string table.
-        if (available < MAX_STACK_SIZE) {
-          prefix[available] = (short) oldCode;
-          suffix[available] = (byte) first;
-          available++;
-          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
-            codeMask += available;
-          }
-        }
-        oldCode = inCode;
+  @GifDecodeStatus
+  int read(byte[] data);
 
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
-      }
-    }
-
-    // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = 0;
-    }
-  }
-
-  /**
-   * Reads a single byte from the input stream.
-   */
-  private int read() {
-    int curByte = 0;
-    try {
-      curByte = rawData.get() & 0xFF;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-    }
-    return curByte;
-  }
-
-  /**
-   * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer".
-   */
-  private int readBlock() {
-    int blockSize = read();
-    int n = 0;
-    if (blockSize > 0) {
-      try {
-        int count;
-        while (n < blockSize) {
-          count = blockSize - n;
-          rawData.get(block, n, count);
-
-          n += count;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
-    }
-    return n;
-  }
-
-  private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    if (result == null) {
-      result = Bitmap.createBitmap(downsampledWidth, downsampledHeight, config);
-    }
-    setAlpha(result);
-    return result;
-  }
-
-  @TargetApi(12)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= 12) {
-      bitmap.setHasAlpha(true);
-    }
-  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 6da8c9e40..0a26cb756 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -1,9 +1,57 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Inner model class housing metadata for each frame.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 class GifFrame {
+  /**
+   * GIF Disposal Method meaning take no action.
+   * <p><b>GIF89a</b>: <i>No disposal specified.
+   * The decoder is not required to take any action.</i></p>
+   */
+  public static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   * <p><b>GIF89a</b>: <i>Do not dispose.
+   * The graphic is to be left in place.</i></p>
+   */
+  public static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   * <p><b>GIF89a</b>: <i>Restore to background color.
+   * The area used by the graphic must be restored to the background color.</i></p>
+   */
+  public static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   * <p><b>GIF89a</b>: <i>Restore to previous.
+   * The decoder is required to restore the area overwritten by the graphic
+   * with what was there prior to rendering the graphic.</i></p>
+   */
+  public static final int DISPOSAL_PREVIOUS = 3;
+
+  /**
+   * <p><b>GIF89a</b>:
+   * <i>Indicates the way in which the graphic is to be treated after being displayed.</i></p>
+   * Disposal methods 0-3 are defined, 4-7 are reserved for future use.
+   *
+   * @see #DISPOSAL_UNSPECIFIED
+   * @see #DISPOSAL_NONE
+   * @see #DISPOSAL_BACKGROUND
+   * @see #DISPOSAL_PREVIOUS
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
+  @interface GifDisposalMethod {
+  }
+
   int ix, iy, iw, ih;
   /**
    * Control Flag.
@@ -16,13 +64,14 @@
   /**
    * Disposal Method.
    */
+  @GifDisposalMethod
   int dispose;
   /**
    * Transparency Index.
    */
   int transIndex;
   /**
-   * Delay, in ms, to next frame.
+   * Delay, in milliseconds, to next frame.
    */
   int delay;
   /**
@@ -32,5 +81,6 @@
   /**
    * Local Color Table.
    */
+  @ColorInt
   int[] lct;
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 5b57212ec..d43f7cca7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -8,34 +9,46 @@
  * metadata like width and height that can be used to decode each individual frame of the GIF. Can
  * be shared by one or more {@link com.bumptech.glide.gifdecoder.GifDecoder}s to play the same
  * animated GIF in multiple views.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeader {
 
+  /** The "Netscape" loop count which means loop forever. */
+  public static final int NETSCAPE_LOOP_COUNT_FOREVER = 0;
+  /** Indicates that this header has no "Netscape" loop count. */
+  public static final int NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST = -1;
+
+  @ColorInt
   int[] gct = null;
+  @GifDecoder.GifDecodeStatus
   int status = GifDecoder.STATUS_OK;
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<GifFrame>();
-  // Logical screen size.
-  // Full image width.
+  List<GifFrame> frames = new ArrayList<>();
+  /** Logical screen size: Full image width. */
   int width;
-  // Full image height.
+  /** Logical screen size: Full image height. */
   int height;
 
   // 1 : global color table flag.
   boolean gctFlag;
-  // 2-4 : color resolution.
-  // 5 : gct sort flag.
-  // 6-8 : gct size.
+  /**
+   * Size of Global Color Table.
+   * The value is already computed to be a regular number, this field doesn't store the exponent.
+   */
   int gctSize;
-  // Background color index.
+  /** Background color index into the Global/Local color table. */
   int bgIndex;
-  // Pixel aspect ratio.
+  /**
+   * Pixel aspect ratio.
+   * Factor used to compute an approximation of the aspect ratio of the pixel in the original image.
+   */
   int pixelAspect;
-  //TODO: this is set both during reading the header and while decoding frames...
+  @ColorInt
   int bgColor;
-  int loopCount;
+  int loopCount = NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
 
   public int getHeight() {
     return height;
@@ -52,6 +65,7 @@ public int getNumFrames() {
   /**
    * Global status code of GIF data parsing.
    */
+  @GifDecoder.GifDecodeStatus
   public int getStatus() {
     return status;
   }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 2036b6cab..05662c04e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.gifdecoder;
 
 import static com.bumptech.glide.gifdecoder.GifDecoder.STATUS_FORMAT_ERROR;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
 import android.util.Log;
-
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -11,15 +12,112 @@
 
 /**
  * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data
- * representing animated gifs.
+ * representing animated GIFs.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
   public static final String TAG = "GifHeaderParser";
 
-  // The minimum frame delay in hundredths of a second.
-  static final int MIN_FRAME_DELAY = 3;
-  // The default frame delay in hundredths of a second for GIFs with frame delays less than the
-  // minimum.
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  /** Identifies the beginning of an Image Descriptor. */
+  private static final int IMAGE_SEPARATOR = 0x2C;
+  /** Identifies the beginning of an extension block. */
+  private static final int EXTENSION_INTRODUCER = 0x21;
+  /** This block is a single-field block indicating the end of the GIF Data Stream. */
+  private static final int TRAILER = 0x3B;
+  // Possible labels that identify the current extension block.
+  private static final int LABEL_GRAPHIC_CONTROL_EXTENSION = 0xF9;
+  private static final int LABEL_APPLICATION_EXTENSION = 0xFF;
+  private static final int LABEL_COMMENT_EXTENSION = 0xFE;
+  private static final int LABEL_PLAIN_TEXT_EXTENSION = 0x01;
+
+  // Graphic Control Extension packed field masks
+
+  private static final int GCE_MASK_RESERVED_BITS = 0b11100000;
+  /**
+   * Mask (bits 4-2) to extract Disposal Method of the current frame.
+   *
+   * @see GifFrame.GifDisposalMethod possible values
+   */
+  private static final int GCE_MASK_DISPOSAL_METHOD = 0b00011100;
+  /**
+   * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
+   */
+  private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
+  private static final int GCE_MASK_USER_INPUT_FLAG = 0b00000010;
+  /**
+   * Mask (bit 0) to extract Transparent Color Flag of the current frame.
+   * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
+   * in the Transparent Index field.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Transparent Index is not given.</li>
+   * <li>1 - Transparent Index is given.</li>
+   * </ul>
+   */
+  private static final int GCE_MASK_TRANSPARENT_COLOR_FLAG = 0b00000001;
+
+  // Image Descriptor packed field masks (describing Local Color Table)
+
+  /**
+   * Mask (bit 7) to extract Local Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Local Color Table
+   * immediately following this Image Descriptor.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_FLAG = 0b10000000;
+  /**
+   * Mask (bit 6) to extract Interlace Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates if the image is interlaced.
+   * An image is interlaced in a four-pass interlace pattern.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Image is not interlaced.</li>
+   * <li>1 - Image is interlaced.</li>
+   * </ul>
+   */
+  private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
+  private static final int DESCRIPTOR_MASK_SORT_FLAG = 0b00100000;
+  private static final int DESCRIPTOR_MASK_RESERVED = 0b00011000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Local Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * This value should be 0 if there is no Local Color Table specified.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_SIZE = 0b00000111;
+
+  // Logical Screen Descriptor packed field masks (describing Global Color Table)
+
+  /**
+   * Mask (bit 7) to extract Global Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Global Color Table
+   * immediately following this Image Descriptor.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - No Global Color Table follows, the Background Color Index field is meaningless.</li>
+   * <li>1 - A Global Color Table will immediately follow,
+   * the Background Color Index field is meaningful.</li>
+   * </ul>
+   */
+  private static final int LSD_MASK_GCT_FLAG = 0b10000000;
+  private static final int LSD_MASK_COLOR_RESOLUTION = 0b01110000;
+  private static final int LSD_MASK_SORT_FLAG = 0b00001000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Global Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * Even if there is no Global Color Table specified, set this field according to the above
+   * formula so that decoders can choose the best graphics mode to display the stream in.</i></p>
+   */
+  private static final int LSD_MASK_GCT_SIZE = 0b00000111;
+
+  /** The minimum frame delay in hundredths of a second. */
+  static final int MIN_FRAME_DELAY = 2;
+  /**
+   * The default frame delay in hundredths of a second.
+   * This is used for GIFs with frame delays less than the minimum.
+   */
   static final int DEFAULT_FRAME_DELAY = 10;
 
   private static final int MAX_BLOCK_SIZE = 256;
@@ -79,39 +177,53 @@ public GifHeader parseHeader() {
     return header;
   }
 
+  /**
+   * Determines if the GIF is animated by trying to read in the first 2 frames
+   * This method re-parses the data even if the header has already been read.
+   */
+  public boolean isAnimated() {
+    readHeader();
+    if (!err()) {
+      readContents(2 /* maxFrames */);
+    }
+    return header.frameCount > 1;
+  }
+
   /**
    * Main file parser. Reads GIF content blocks.
    */
   private void readContents() {
+    readContents(Integer.MAX_VALUE /* maxFrames */);
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames
+   */
+  private void readContents(int maxFrames) {
     // Read GIF file content blocks.
     boolean done = false;
-    while (!(done || err())) {
+    while (!(done || err() || header.frameCount > maxFrames)) {
       int code = read();
       switch (code) {
-        // Image separator.
-        case 0x2C:
-          // The graphics control extension is optional, but will always come first if it exists.
-          // If one did
-          // exist, there will be a non-null current frame which we should use. However if one
-          // did not exist,
-          // the current frame will be null and we must create it here. See issue #134.
+        case IMAGE_SEPARATOR:
+          // The Graphic Control Extension is optional, but will always come first if it exists.
+          // If one did exist, there will be a non-null current frame which we should use.
+          // However if one did not exist, the current frame will be null
+          // and we must create it here. See issue #134.
           if (header.currentFrame == null) {
             header.currentFrame = new GifFrame();
           }
           readBitmap();
           break;
-        // Extension.
-        case 0x21:
-          code = read();
-          switch (code) {
-            // Graphics control extension.
-            case 0xf9:
+        case EXTENSION_INTRODUCER:
+          int extensionLabel = read();
+          switch (extensionLabel) {
+            case LABEL_GRAPHIC_CONTROL_EXTENSION:
               // Start a new frame.
               header.currentFrame = new GifFrame();
               readGraphicControlExt();
               break;
-            // Application extension.
-            case 0xff:
+            case LABEL_APPLICATION_EXTENSION:
               readBlock();
               String app = "";
               for (int i = 0; i < 11; i++) {
@@ -124,24 +236,22 @@ private void readContents() {
                 skip();
               }
               break;
-            // Comment extension.
-            case 0xfe:
+            case LABEL_COMMENT_EXTENSION:
               skip();
               break;
-            // Plain text extension.
-            case 0x01:
+            case LABEL_PLAIN_TEXT_EXTENSION:
               skip();
               break;
-            // Uninteresting extension.
             default:
+              // Uninteresting extension.
               skip();
           }
           break;
-        // Terminator.
-        case 0x3b:
+        case TRAILER:
+          // This block is a single-field block indicating the end of the GIF Data Stream.
           done = true;
           break;
-        // Bad byte, but keep going and see what happens break;
+        // Bad byte, but keep going and see what happens
         case 0x00:
         default:
           header.status = STATUS_FORMAT_ERROR;
@@ -150,20 +260,31 @@ private void readContents() {
   }
 
   /**
-   * Reads Graphics Control Extension values.
+   * Reads Graphic Control Extension values.
    */
   private void readGraphicControlExt() {
     // Block size.
     read();
-    // Packed fields.
+    /*
+     * Graphic Control Extension packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  1  |     |     | | |
+     *
+     * Reserved                    3 Bits
+     * Disposal Method             3 Bits
+     * User Input Flag             1 Bit
+     * Transparent Color Flag      1 Bit
+     */
     int packed = read();
     // Disposal method.
-    header.currentFrame.dispose = (packed & 0x1c) >> 2;
-    if (header.currentFrame.dispose == 0) {
+    //noinspection WrongConstant field has to be extracted from packed value
+    header.currentFrame.dispose = (packed & GCE_MASK_DISPOSAL_METHOD) >> GCE_DISPOSAL_METHOD_SHIFT;
+    if (header.currentFrame.dispose == DISPOSAL_UNSPECIFIED) {
       // Elect to keep old image if discretionary.
-      header.currentFrame.dispose = 1;
+      header.currentFrame.dispose = DISPOSAL_NONE;
     }
-    header.currentFrame.transparency = (packed & 1) != 0;
+    header.currentFrame.transparency = (packed & GCE_MASK_TRANSPARENT_COLOR_FLAG) != 0;
     // Delay in milliseconds.
     int delayInHundredthsOfASecond = readShort();
     // TODO: consider allowing -1 to indicate show forever.
@@ -187,16 +308,23 @@ private void readBitmap() {
     header.currentFrame.iw = readShort();
     header.currentFrame.ih = readShort();
 
+    /*
+     * Image Descriptor packed field:
+     *     7 6 5 4 3 2 1 0
+     *    +---------------+
+     * 9  | | | |   |     |
+     *
+     * Local Color Table Flag     1 Bit
+     * Interlace Flag             1 Bit
+     * Sort Flag                  1 Bit
+     * Reserved                   2 Bits
+     * Size of Local Color Table  3 Bits
+     */
     int packed = read();
-    // 1 - local color table flag interlace
-    boolean lctFlag = (packed & 0x80) != 0;
-    int lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
-    // 3 - sort flag
-    // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
-    // table size
-    header.currentFrame.interlace = (packed & 0x40) != 0;
+    boolean lctFlag = (packed & DESCRIPTOR_MASK_LCT_FLAG) != 0;
+    int lctSize = (int) Math.pow(2, (packed & DESCRIPTOR_MASK_LCT_SIZE) + 1);
+    header.currentFrame.interlace = (packed & DESCRIPTOR_MASK_INTERLACE_FLAG) != 0;
     if (lctFlag) {
-      // Read table.
       header.currentFrame.lct = readColorTable(lctSize);
     } else {
       // No local color table.
@@ -226,8 +354,8 @@ private void readNetscapeExt() {
       readBlock();
       if (block[0] == 1) {
         // Loop count sub-block.
-        int b1 = ((int) block[1]) & 0xff;
-        int b2 = ((int) block[2]) & 0xff;
+        int b1 = ((int) block[1]) & MASK_INT_LOWEST_BYTE;
+        int b2 = ((int) block[2]) & MASK_INT_LOWEST_BYTE;
         header.loopCount = (b2 << 8) | b1;
       }
     } while ((blockSize > 0) && !err());
@@ -260,14 +388,20 @@ private void readLSD() {
     // Logical screen size.
     header.width = readShort();
     header.height = readShort();
-    // Packed fields
+    /*
+     * Logical Screen Descriptor packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  4  | |     | |     |
+     *
+     * Global Color Table Flag     1 Bit
+     * Color Resolution            3 Bits
+     * Sort Flag                   1 Bit
+     * Size of Global Color Table  3 Bits
+     */
     int packed = read();
-    // 1 : global color table flag.
-    header.gctFlag = (packed & 0x80) != 0;
-    // 2-4 : color resolution.
-    // 5 : gct sort flag.
-    // 6-8 : gct size.
-    header.gctSize = 2 << (packed & 7);
+    header.gctFlag = (packed & LSD_MASK_GCT_FLAG) != 0;
+    header.gctSize = (int) Math.pow(2, (packed & LSD_MASK_GCT_SIZE) + 1);
     // Background color index.
     header.bgIndex = read();
     // Pixel aspect ratio
@@ -277,13 +411,13 @@ private void readLSD() {
   /**
    * Reads color table as 256 RGB integer values.
    *
-   * @param ncolors int number of colors to read.
+   * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
-  private int[] readColorTable(int ncolors) {
-    int nbytes = 3 * ncolors;
+  private int[] readColorTable(int nColors) {
+    int nBytes = 3 * nColors;
     int[] tab = null;
-    byte[] c = new byte[nbytes];
+    byte[] c = new byte[nBytes];
 
     try {
       rawData.get(c);
@@ -293,11 +427,11 @@ private void readLSD() {
       tab = new int[MAX_BLOCK_SIZE];
       int i = 0;
       int j = 0;
-      while (i < ncolors) {
-        int r = ((int) c[j++]) & 0xff;
-        int g = ((int) c[j++]) & 0xff;
-        int b = ((int) c[j++]) & 0xff;
-        tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+      while (i < nColors) {
+        int r = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int g = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int b = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        tab[i++] = 0xFF000000 | (r << 16) | (g << 8) | b;
       }
     } catch (BufferUnderflowException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -326,7 +460,8 @@ private void skip() {
     int blockSize;
     do {
       blockSize = read();
-      rawData.position(rawData.position() + blockSize);
+      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());
+      rawData.position(newPosition);
     } while (blockSize > 0);
   }
 
@@ -362,13 +497,13 @@ private int readBlock() {
    * Reads a single byte from the input stream.
    */
   private int read() {
-    int curByte = 0;
+    int currByte = 0;
     try {
-      curByte = rawData.get() & 0xFF;
+      currByte = rawData.get() & MASK_INT_LOWEST_BYTE;
     } catch (Exception e) {
       header.status = STATUS_FORMAT_ERROR;
     }
-    return curByte;
+    return currByte;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
new file mode 100644
index 000000000..80825fb09
--- /dev/null
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -0,0 +1,786 @@
+package com.bumptech.glide.gifdecoder;
+
+/*
+ * Copyright (c) 2013 Xcellent Creations, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_BACKGROUND;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_PREVIOUS;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
+
+import android.graphics.Bitmap;
+import android.support.annotation.ColorInt;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
+ *
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
+ *
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
+ *
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
+ */
+public class StandardGifDecoder implements GifDecoder {
+  private static final String TAG = StandardGifDecoder.class.getSimpleName();
+
+  /** Maximum pixel stack size for decoding LZW compressed data. */
+  private static final int MAX_STACK_SIZE = 4 * 1024;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;
+
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  @ColorInt
+  private static final int COLOR_TRANSPARENT_BLACK = 0x00000000;
+
+  // Global File Header values and parsing flags.
+  /**
+   * Active color table.
+   * Maximum size is 256, see GifHeaderParser.readColorTable
+   */
+  @ColorInt
+  private int[] act;
+  /** Private color table that can be modified if needed. */
+  @ColorInt
+  private final int[] pct = new int[256];
+
+  /** Raw GIF data from input source. */
+  private ByteBuffer rawData;
+
+  /** Raw data read working array. */
+  private byte[] block;
+
+  private static final int WORK_BUFFER_SIZE = 16 * 1024;
+  /**
+   * Temporary buffer for block reading.
+   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
+   */
+  @Nullable private byte[] workBuffer;
+  private int workBufferSize = 0;
+  private int workBufferPosition = 0;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  @ColorInt
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private GifDecoder.BitmapProvider bitmapProvider;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  @GifDecodeStatus
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  private boolean isFirstFrameTransparent;
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  @Override
+  public int getWidth() {
+    return header.width;
+  }
+
+  @Override
+  public int getHeight() {
+    return header.height;
+  }
+
+  @Override
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  @Override
+  public int getStatus() {
+    return status;
+  }
+
+  @Override
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  @Override
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  @Override
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
+
+    return getDelay(framePointer);
+  }
+
+  @Override
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  @Override
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  @Override
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  @Override
+  public int getLoopCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    return header.loopCount;
+  }
+
+  @Override
+  public int getNetscapeLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getTotalIterationCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_FOREVER) {
+      return TOTAL_ITERATION_COUNT_FOREVER;
+    }
+    return header.loopCount + 1;
+  }
+
+  @Override
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  @Override
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame"
+            + ", frameCount=" + header.frameCount
+            + ", framePointer=" + framePointer
+        );
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame = null;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    }
+
+    // Set the appropriate color table.
+    act = currentFrame.lct != null ? currentFrame.lct : header.gct;
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No valid color table found for frame #" + framePointer);
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
+
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      // Prepare local copy of color table ("pct = act"), see #1068
+      System.arraycopy(act, 0, pct, 0, act.length);
+      // Forget about act reference from shared header object, use copied version
+      act = pct;
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = COLOR_TRANSPARENT_BLACK;
+    }
+
+    // Transfer pixel data to image.
+    return setPixels(currentFrame, previousFrame);
+  }
+
+  @Override
+  public int read(InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16 * 1024];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
+    }
+
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
+    }
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = false;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+    if (workBuffer != null) {
+      bitmapProvider.release(workBuffer);
+    }
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
+    }
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    isFirstFrameTransparent = false;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
+    }
+
+    this.sampleSize = sampleSize;
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO Find a way to avoid this entirely or at least downsample it (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
+  }
+
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
+    }
+    return parser;
+  }
+
+  @Override
+  @GifDecodeStatus
+  public synchronized int read(byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
+    }
+
+    return status;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // clear all pixels when meet first frame
+    if (previousFrame == null) {
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        @ColorInt int c = COLOR_TRANSPARENT_BLACK;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
+            c = COLOR_TRANSPARENT_BLACK;
+          }
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
+        }
+        // The area used by the graphic must be restored to the background color.
+        int downsampledIH = previousFrame.ih / sampleSize;
+        int downsampledIY = previousFrame.iy / sampleSize;
+        int downsampledIW = previousFrame.iw / sampleSize;
+        int downsampledIX = previousFrame.ix / sampleSize;
+        int topLeft = downsampledIY * downsampledWidth + downsampledIX;
+        int bottomLeft = topLeft + downsampledIH * downsampledWidth;
+        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {
+          int right = left + downsampledIW;
+          for (int pointer = left; pointer < right; pointer++) {
+            dest[pointer] = c;
+          }
+        }
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
+
+    // Decode pixels for this frame into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
+        }
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
+        }
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+        while (dx < dlim) {
+          // Map color and insert in destination.
+          @ColorInt int averageColor;
+          if (sampleSize == 1) {
+            int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
+            averageColor = act[currentColorIndex];
+          } else {
+            // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
+            // current color index above, even with a sample size of 1.
+            averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+          }
+          if (averageColor != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = averageColor;
+          } else if (!isFirstFrameTransparent && isFirstFrame) {
+            isFirstFrameTransparent = true;
+          }
+          sx += sampleSize;
+          dx++;
+        }
+      }
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  @ColorInt
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+         i < positionInMainPixels + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+         i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return COLOR_TRANSPARENT_BLACK;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+    }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    workBufferSize = 0;
+    workBufferPosition = 0;
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
+    }
+
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum, dataSize, first, top, bi, pi;
+
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
+    }
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
+    }
+
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
+    }
+
+    // Decode GIF pixel stream.
+    datum = bits = count = first = top = pi = bi = 0;
+    for (i = 0; i < npix; ) {
+      // Load bytes until there are enough bits for a code.
+      if (count == 0) {
+        // Read a new data block.
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
+      bits += 8;
+      bi++;
+      count--;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
+        }
+
+        if (code > available) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+
+        if (code == endOfInformation) {
+          break;
+        }
+
+        if (oldCode == NULL_CODE) {
+          pixelStack[top++] = suffix[code];
+          oldCode = code;
+          first = code;
+          continue;
+        }
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top++] = (byte) first;
+          code = oldCode;
+        }
+        while (code >= clear) {
+          pixelStack[top++] = suffix[code];
+          code = prefix[code];
+        }
+        first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
+        pixelStack[top++] = (byte) first;
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          available++;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            codeSize++;
+            codeMask += available;
+          }
+        }
+        oldCode = inCode;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi++] = pixelStack[--top];
+          i++;
+        }
+      }
+    }
+
+    // Clear missing pixels.
+    for (i = pi; i < npix; i++) {
+      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
+    }
+  }
+
+  /**
+   * Reads the next chunk for the intermediate work buffer.
+   */
+  private void readChunkIfNeeded() {
+    if (workBufferSize > workBufferPosition) {
+      return;
+    }
+    if (workBuffer == null) {
+      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
+    }
+    workBufferPosition = 0;
+    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
+    rawData.get(workBuffer, 0, workBufferSize);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    try {
+      readChunkIfNeeded();
+      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
+    } catch (Exception e) {
+      status = STATUS_FORMAT_ERROR;
+      return 0;
+    }
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize > 0) {
+      try {
+        if (block == null) {
+          block = bitmapProvider.obtainByteArray(255);
+        }
+        final int remaining = workBufferSize - workBufferPosition;
+        if (remaining >= blockSize) {
+          // Block can be read from the current work buffer.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
+          workBufferPosition += blockSize;
+        } else if (rawData.remaining() + remaining >= blockSize) {
+          // Block can be read in two passes.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
+          workBufferPosition = workBufferSize;
+          readChunkIfNeeded();
+          final int secondHalfRemaining = blockSize - remaining;
+          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
+          workBufferPosition += secondHalfRemaining;
+        } else {
+          status = STATUS_FORMAT_ERROR;
+        }
+      } catch (Exception e) {
+        Log.w(TAG, "Error Reading Block", e);
+        status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    result.setHasAlpha(true);
+    return result;
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index cf1b61bbe..13a581303 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -2,19 +2,23 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-
-import java.io.IOException;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
 
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
@@ -36,7 +40,7 @@ public void testCanDecodeFramesFromTestGif() throws IOException {
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap bitmap = decoder.getNextFrame();
@@ -49,17 +53,47 @@ public void testFrameIndexStartsAtNegativeOne() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  public void testTotalIterationCountIsOneIfNetscapeLoopCountDoesntExist() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(1, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsForeverIfNetscapeLoopCountIsForever() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_FOREVER;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsTwoIfNetscapeLoopCountIsOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = 1;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(2, decoder.getTotalIterationCount());
+  }
+
   @Test
   public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     assertEquals(0, decoder.getCurrentFrameIndex());
@@ -70,7 +104,7 @@ public void testAdvanceWrapsIndexBackToZero() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 2;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -83,7 +117,7 @@ public void testSettingDataResetsFramePointer() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -93,8 +127,68 @@ public void testSettingDataResetsFramePointer() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  /**
+   * Preserve generated bitmap data for checking.
+   */
+  @Implements(Bitmap.class)
+  public static class CustomShadowBitmap extends ShadowBitmap {
+
+    private int[] pixels;
+
+    @Implementation
+    public void setPixels(int[] pixels, int offset, int stride,
+        int x, int y, int width, int height) {
+      this.pixels = new int[pixels.length];
+      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
+    }
+
+    public int[] getPixels() {
+      return pixels;
+    }
+  }
+
   private static class MockProvider implements GifDecoder.BitmapProvider {
 
+    @NonNull
     @Override
     public Bitmap obtain(int width, int height, Bitmap.Config config) {
       Bitmap result = Bitmap.createBitmap(width, height, config);
@@ -106,5 +200,26 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
     public void release(Bitmap bitmap) {
       // Do nothing.
     }
+
+    @Override
+    public byte[] obtainByteArray(int size) {
+      return new byte[size];
+    }
+
+    @Override
+    public void release(byte[] bytes) {
+      // Do nothing.
+    }
+
+    @Override
+    public int[] obtainIntArray(int size) {
+      return new int[size];
+    }
+
+    @Override
+    public void release(int[] array) {
+      // Do Nothing
+    }
+
   }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 4f7e3c8e6..55dfa41a4 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -4,19 +4,18 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
  */
@@ -66,6 +65,58 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
     assertEquals(GifDecoder.STATUS_OK, header.status);
   }
 
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIsZero() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_0.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_FOREVER, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_1() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_1.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x0F()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_255.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(255, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x10()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_256.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(256, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0xFF()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_65535.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(65535, header.loopCount);
+  }
+
+  @Test
+  public void testLoopCountReturnsMinusOneWithoutNetscapeIterationCount()
+          throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_netscape_iteration.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST, header.loopCount);
+  }
+
   @Test
   public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
@@ -214,9 +265,52 @@ public void testCanParseMultipleFrames() {
     assertEquals(expectedFrames, header.frames.size());
   }
 
+  @Test
+  public void testIsAnimatedMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int numFrames = 3;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < numFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    assertTrue(parser.isAnimated());
+  }
+
+  @Test
+  public void testIsNotAnimatedOneFrame() {
+    final int lzwMinCodeSize = 2;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    assertFalse(parser.isAnimated());
+  }
+
+
   @Test(expected = IllegalStateException.class)
   public void testThrowsIfParseHeaderCalledBeforeSetData() {
     GifHeaderParser parser = new GifHeaderParser();
     parser.parseHeader();
   }
-}
\ No newline at end of file
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
index 680f49d09..f09e8596e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertArrayEquals;
 
+import java.nio.ByteBuffer;
+import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
  */
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif
new file mode 100644
index 000000000..3dd7c1cb6
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif
new file mode 100644
index 000000000..480dc8c64
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif
new file mode 100644
index 000000000..62a489ea2
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif
new file mode 100644
index 000000000..c0443cd42
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif
new file mode 100644
index 000000000..b976157c3
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif
new file mode 100644
index 000000000..f67b1b6bf
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif
new file mode 100644
index 000000000..3c64b1d65
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif
new file mode 100644
index 000000000..158e329ba
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif differ
diff --git a/third_party/gif_encoder/README.third_party b/third_party/gif_encoder/README.third_party
index 981a8a04d..40fafebcb 100644
--- a/third_party/gif_encoder/README.third_party
+++ b/third_party/gif_encoder/README.third_party
@@ -4,7 +4,7 @@ License: Notice
 License File: LICENSE
 
 Description:
-Android port of a gif encoder.
+Android port of a GIF encoder.
 
 See also:
 http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index aa1123f67..7bb25acab 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -5,7 +5,6 @@
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.util.Log;
-
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -22,6 +21,7 @@
  *     e.setDelay(1000);   // 1 frame per sec
  *     e.addFrame(image1);
  *     e.addFrame(image2);
+ *     e.addFrame(image3, 100, 100);    // set position of the frame
  *     e.finish();
  * </pre>
  *
@@ -38,13 +38,18 @@
 public class AnimatedGifEncoder {
     private static final String TAG = "AnimatedGifEncoder";
 
-    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index
+    // automatically.
     private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
     private int width; // image size
 
     private int height;
 
+    private int fixedWidth;   // set by setSize()
+
+    private int fixedHeight;
+
     private Integer transparent = null; // transparent color if given
 
     private int transIndex; // transparent index in color table
@@ -140,28 +145,52 @@ public void setTransparent(int color) {
      * Adds next GIF frame. The frame is not written immediately, but is actually
      * deferred until the next frame is received so that timing data can be
      * inserted. Invoking <code>finish()</code> flushes all frames. If
-     * <code>setSize</code> was not invoked, the size of the first image is used
-     * for all subsequent frames.
+     * <code>setSize</code> was invoked, the size is used for all subsequent frames.
+     * Otherwise, the actual size of the image is used for each frames.
      *
      * @param im
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
     public boolean addFrame(Bitmap im) {
+        return addFrame(im, 0, 0);
+    }
+
+    /**
+     * Adds next GIF frame to the specified position. The frame is not written immediately, but is
+     * actually deferred until the next frame is received so that timing data can be inserted.
+     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the
+     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for
+     * each frame.
+     *
+     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame
+     *
+     * @param im
+     *          BufferedImage containing frame to write.
+     * @param x
+     *          Column number, in pixels, of the left edge of the image, with respect to the left
+     *          edge of the Logical Screen.
+     * @param y
+     *          Row number, in pixels, of the top edge of the image with respect to the top edge of
+     *          the Logical Screen.
+     * @return true if successful.
+     */
+    public boolean addFrame(Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
         boolean ok = true;
         try {
-            if (!sizeSet) {
-                // use first frame's size
-                setSize(im.getWidth(), im.getHeight());
+            if (sizeSet) {
+                setFrameSize(fixedWidth, fixedHeight);
+            } else {
+                setFrameSize(im.getWidth(), im.getHeight());
             }
             image = im;
             getImagePixels(); // convert to correct format if necessary
             analyzePixels(); // build color table & map pixels
             if (firstFrame) {
-                writeLSD(); // logical screen descriptior
+                writeLSD(); // logical screen descriptor
                 writePalette(); // global color table
                 if (repeat >= 0) {
                     // use NS app extension to indicate reps
@@ -169,7 +198,7 @@ public boolean addFrame(Bitmap im) {
                 }
             }
             writeGraphicCtrlExt(); // write graphic control extension
-            writeImageDesc(); // image descriptor
+            writeImageDesc(x, y); // image descriptor
             if (!firstFrame) {
                 writePalette(); // local color table
             }
@@ -192,7 +221,7 @@ public boolean finish() {
         boolean ok = true;
         started = false;
         try {
-            out.write(0x3b); // gif trailer
+            out.write(0x3b); // GIF trailer
             out.flush();
             if (closeStream) {
                 out.close();
@@ -243,8 +272,8 @@ public void setQuality(int quality) {
     }
 
     /**
-     * Sets the GIF frame size. The default size is the size of the first frame
-     * added if this method is not invoked.
+     * Sets the fixed GIF frame size for all the frames.
+     * This should be called before start.
      *
      * @param w
      *          int frame width.
@@ -252,15 +281,33 @@ public void setQuality(int quality) {
      *          int frame width.
      */
     public void setSize(int w, int h) {
-        if (started && !firstFrame)
+        if (started) {
             return;
+        }
+
+        fixedWidth = w;
+        fixedHeight = h;
+        if (fixedWidth < 1) {
+            fixedWidth = 320;
+        }
+        if (fixedHeight < 1) {
+            fixedHeight = 240;
+        }
+
+        sizeSet = true;
+    }
+
+    /**
+     * Sets current GIF frame size.
+     *
+     * @param w
+     *          int frame width.
+     * @param h
+     *          int frame width.
+     */
+    private void setFrameSize(int w, int h) {
         width = w;
         height = h;
-        if (width < 1)
-            width = 320;
-        if (height < 1)
-            height = 240;
-        sizeSet = true;
     }
 
     /**
@@ -400,11 +447,12 @@ private void getImagePixels() {
         }
 
         double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
-        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
-        // See issue #214.
+        // Assume images with greater where more than n% of the pixels are transparent actually have
+        // transparency. See issue #214.
         hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage
+                + "% transparent pixels");
         }
     }
 
@@ -442,10 +490,10 @@ private void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    private void writeImageDesc() throws IOException {
+    private void writeImageDesc(int x, int y) throws IOException {
         out.write(0x2c); // image separator
-        writeShort(0); // image position x,y = 0,0
-        writeShort(0);
+        writeShort(x); // image position
+        writeShort(y);
         writeShort(width); // image size
         writeShort(height);
         // packed fields
diff --git a/third_party/gradle.properties b/third_party/gradle.properties
new file mode 100644
index 000000000..d01cfd2be
--- /dev/null
+++ b/third_party/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-thirdparty
