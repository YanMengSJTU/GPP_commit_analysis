diff --git a/gradle.properties b/gradle.properties
index 0efa4743f..4174d64da 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -28,7 +28,7 @@ MOCKITO_VERSION=1.9.5
 MOCKITO_ANDROID_VERSION=2.11.0
 ROBOLECTRIC_VERSION=3.3.2
 MOCKWEBSERVER_VERSION=3.0.0-RC1
-TRUTH_VERSION=0.26
+TRUTH_VERSION=0.36
 JSR_305_VERSION=3.0.2
 AUTO_SERVICE_VERSION=1.0-rc3
 JAVAPOET_VERSION=1.9.0
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
index 201bec6c4..a6d25c58a 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -3,9 +3,9 @@
 import static com.bumptech.glide.test.Matchers.anyDrawable;
 import static com.bumptech.glide.test.Matchers.anyTarget;
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
@@ -52,7 +52,7 @@ public void setUp() {
     // Some emulators only have a single resize thread, so waiting on a latch will block them
     // forever.
     Glide.init(context,
-        new GlideBuilder().setResizeExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
   }
 
   @Test
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
index acb2c6832..e71ee33c4 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -8,9 +8,8 @@
 import android.support.annotation.NonNull;
 import android.support.test.InstrumentationRegistry;
 import android.support.v4.content.res.ResourcesCompat;
-import com.google.common.truth.FailureStrategy;
+import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
-import com.google.common.truth.SubjectFactory;
 import com.google.common.truth.Truth;
 
 /**
@@ -20,17 +19,17 @@
 @SuppressWarnings({"WeakerAccess", "unused"})
 public final class BitmapSubject extends Subject<BitmapSubject, Bitmap> {
 
-  private static final SubjectFactory<BitmapSubject, Bitmap> FACTORY =
-      new SubjectFactory<BitmapSubject, Bitmap>() {
+  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =
+      new Subject.Factory<BitmapSubject, Bitmap>() {
         @Override
-        public BitmapSubject getSubject(@NonNull FailureStrategy fs, @NonNull Bitmap that) {
-          return new BitmapSubject(fs, that);
+        public BitmapSubject createSubject(
+            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {
+          return new BitmapSubject(metadata, actual);
         }
       };
 
-  private BitmapSubject(FailureStrategy failureStrategy,
-      Bitmap subject) {
-    super(failureStrategy, subject);
+  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {
+    super(failureMetadata, subject);
   }
 
   public static BitmapSubject assertThat(Drawable drawable) {
@@ -45,8 +44,8 @@ public static BitmapSubject assertThat(Bitmap bitmap) {
   }
 
   @Override
-  protected String getDisplaySubject() {
-    return getDisplayString(getSubject());
+  protected String actualCustomStringRepresentation() {
+    return getDisplayString(actual());
   }
 
   private static String getDisplayString(Bitmap bitmap) {
@@ -65,19 +64,19 @@ public void sameAs(@DrawableRes int resourceId) {
   }
 
   public void isMutable()  {
-    if (!getSubject().isMutable()) {
+    if (!actual().isMutable()) {
       fail("is mutable");
     }
   }
 
   public void isImmutable() {
-    if (getSubject().isMutable()) {
+    if (actual().isMutable()) {
       fail("is immutable");
     }
   }
 
   public void isNotRecycled() {
-    if (getSubject().isRecycled()) {
+    if (actual().isRecycled()) {
       fail("is not recycled");
     }
   }
@@ -91,7 +90,7 @@ public void sameAs(Drawable other) {
   }
 
   public void sameAs(Bitmap other) {
-    if (!getSubject().sameAs(other)) {
+    if (!actual().sameAs(other)) {
       fail("is the same as " + getDisplayString(other));
     }
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index 67187a287..d7de5c40d 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.test;
 
-
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.Nullable;
 import android.support.test.InstrumentationRegistry;
 import android.widget.ImageView;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.target.DrawableImageViewTarget;
@@ -52,7 +52,7 @@ public void clearOnMainThread(final ImageView imageView) {
     runOnMainThread(new Runnable() {
       @Override
       public void run() {
-        GlideApp.with(InstrumentationRegistry.getTargetContext())
+        Glide.with(InstrumentationRegistry.getTargetContext())
             .clear(imageView);
       }
     });
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
index 81d1f021f..de7fbf088 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.test;
 
-import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.any;
 
 import android.graphics.drawable.Drawable;
 import com.bumptech.glide.request.target.Target;
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index e9defbbe7..a9455e321 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -38,7 +38,7 @@
 
     <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
     <Match>
-      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />
       <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
     </Match>
 
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 7acd5525c..3c3fc3e85 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -204,7 +204,6 @@ public static synchronized void init(Context context, GlideBuilder builder) {
   public static synchronized void tearDown() {
     if (glide != null) {
       glide.engine.shutdown();
-      glide.engine.clearDiskCache();
     }
     glide = null;
   }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 05ebfdfcf..f08630240 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -45,6 +45,7 @@
   private RequestOptions defaultRequestOptions = new RequestOptions();
   @Nullable
   private RequestManagerFactory requestManagerFactory;
+  private GlideExecutor animationExecutor;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -116,32 +117,60 @@ public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * Sets the {@link GlideExecutor} to use when retrieving
    * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
+   *
+   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
    */
+  @Deprecated
   public GlideBuilder setResizeExecutor(GlideExecutor service) {
+    return setSourceExecutor(service);
+  }
+
+  /**
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   */
+  public GlideBuilder setSourceExecutor(GlideExecutor service) {
     this.sourceExecutor = service;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage,
+   * jank, and performance, even on high end devices.
    *
-   * @param service The ExecutorService to use.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options
+   * for the disk cache executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
    * @return This builder.
-   * @see #setResizeExecutor(GlideExecutor)
+   * @see #setSourceExecutor(GlideExecutor)
    * @see GlideExecutor
    */
   public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
@@ -149,6 +178,23 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
     return this;
   }
 
+  /**
+   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly
+   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s.
+   *
+   * <p>Defaults to one or two threads, depending on the number of cores available.
+   *
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify
+   * options for the animation executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
+   * @return This builder.
+   */
+  public GlideBuilder setAnimationExecutor(GlideExecutor service) {
+    this.animationExecutor = service;
+    return this;
+  }
+
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
@@ -299,6 +345,10 @@ public Glide build(Context context) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
+    if (animationExecutor == null) {
+      animationExecutor = GlideExecutor.newAnimationExecutor();
+    }
+
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3b5e05710..db08be0ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -320,6 +320,7 @@ public void clearDiskCache() {
   @VisibleForTesting
   public void shutdown() {
     engineJobFactory.shutdown();
+    diskCacheProvider.clearDiskCacheIfCreated();
   }
 
   /**
@@ -348,6 +349,14 @@ public void cancel() {
       this.factory = factory;
     }
 
+    @VisibleForTesting
+    synchronized void clearDiskCacheIfCreated() {
+      if (diskCache == null) {
+        return;
+      }
+      diskCache.clear();
+    }
+
     @Override
     public DiskCache getDiskCache() {
       if (diskCache == null) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index bd70f82ff..57fecd893 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -6,61 +6,64 @@
 import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import com.bumptech.glide.util.Synthetic;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.concurrent.BlockingQueue;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
+import java.util.concurrent.TimeoutException;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public final class GlideExecutor extends ThreadPoolExecutor {
-
+public final class GlideExecutor implements ExecutorService {
   /**
    * The default thread name prefix for executors used to load/decode/transform data not found in
    * cache.
    */
-  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  private static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+
   /**
    * The default thread name prefix for executors used to load/decode/transform data found in
    * Glide's cache.
    */
-  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+
   /**
    * The default thread count for executors used to load/decode/transform data found in Glide's
    * cache.
    */
-  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+  private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
 
   private static final String TAG = "GlideExecutor";
-  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
-  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
-  // Don't use more than four threads when automatically determining thread count..
-  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
-  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
-  // value more than once.
-  private static volatile int bestThreadCount;
-  private final boolean executeSynchronously;
 
   /**
    * The default thread name prefix for executors from unlimited thread pool used to
    * load/decode/transform data not found in cache.
    */
   private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+
+  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+
   /**
    * The default keep alive time for threads in our cached thread pools in milliseconds.
    */
   private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
 
-  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
+
+  private final ExecutorService delegate;
 
   /**
    * Returns a new fixed thread pool with the default thread count returned from
@@ -72,8 +75,10 @@
    * <p>Disk cache executors do not allow network operations on their threads.
    */
   public static GlideExecutor newDiskCacheExecutor() {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
@@ -88,10 +93,14 @@ public static GlideExecutor newDiskCacheExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newDiskCacheExecutor(
           UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
@@ -106,10 +115,18 @@ public static GlideExecutor newDiskCacheExecutor(
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newDiskCacheExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
   }
 
   /**
@@ -122,7 +139,9 @@ public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newSourceExecutor() {
-    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
         UncaughtThrowableStrategy.DEFAULT);
   }
 
@@ -139,10 +158,14 @@ public static GlideExecutor newSourceExecutor() {
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static GlideExecutor newSourceExecutor(
-          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newSourceExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
   /**
@@ -157,10 +180,18 @@ public static GlideExecutor newSourceExecutor(
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public static GlideExecutor newSourceExecutor(int threadCount, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
-        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newSourceExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
   }
 
   /**
@@ -178,16 +209,22 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newUnlimitedSourceExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
+    return new GlideExecutor(new ThreadPoolExecutor(
+        0,
+        Integer.MAX_VALUE,
         KEEP_ALIVE_TIME_MS,
-        SOURCE_UNLIMITED_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        false /*preventNetworkOperations*/,
-        false /*executeSynchronously*/,
-        new SynchronousQueue<Runnable>());
+        TimeUnit.MILLISECONDS,
+        new SynchronousQueue<Runnable>(),
+        new DefaultThreadFactory(
+            SOURCE_UNLIMITED_EXECUTOR_NAME,
+            UncaughtThrowableStrategy.DEFAULT,
+            false)));
   }
 
+  /**
+   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * number of available cores to use when loading frames of animations.
+   */
   public static GlideExecutor newAnimationExecutor() {
     int bestThreadCount = calculateBestThreadCount();
     // We don't want to add a ton of threads running animations in parallel with our source and
@@ -196,141 +233,130 @@ public static GlideExecutor newAnimationExecutor() {
     // with more cores, two threads can provide better performance if lots of GIFs are showing at
     // once.
     int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
-    return new GlideExecutor(
-        /*corePoolSize=*/ 0,
-        maximumPoolSize,
-        KEEP_ALIVE_TIME_MS,
-        ANIMATION_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT,
-        /*preventNetworkOperations=*/ true,
-        /*executeSynchronously=*/ false,
-        new PriorityBlockingQueue<Runnable>());
+
+    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
+  }
+
+  /**
+   * Returns a new cached thread pool with the given thread count and
+   * {@link UncaughtThrowableStrategy} to use when loading frames of animations.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newAnimationExecutor(
+      int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+     return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0 /* corePoolSize */,
+            threadCount,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(
+                ANIMATION_EXECUTOR_NAME,
+                uncaughtThrowableStrategy,
+                true)));
   }
 
   @VisibleForTesting
-  GlideExecutor(int poolSize, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        poolSize /* corePoolSize */,
-        poolSize /* maximumPoolSize */,
-        0 /* keepAliveTimeInMs */,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously);
+  GlideExecutor(ExecutorService delegate) {
+    this.delegate = delegate;
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously) {
-    this(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        name,
-        uncaughtThrowableStrategy,
-        preventNetworkOperations,
-        executeSynchronously,
-        new PriorityBlockingQueue<Runnable>());
+  @Override
+  public void execute(@NonNull Runnable command) {
+    delegate.execute(command);
   }
 
-  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
-      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
-    super(
-        corePoolSize,
-        maximumPoolSize,
-        keepAliveTimeInMs,
-        TimeUnit.MILLISECONDS,
-        queue,
-        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
-    this.executeSynchronously = executeSynchronously;
+  @NonNull
+  @Override
+  public Future<?> submit(@NonNull Runnable task) {
+    return delegate.submit(task);
   }
 
+  @NonNull
   @Override
-  public void execute(Runnable command) {
-    if (executeSynchronously) {
-      command.run();
-    } else {
-      super.execute(command);
-    }
+  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
   }
 
   @NonNull
   @Override
-  public Future<?> submit(Runnable task) {
-    return maybeWait(super.submit(task));
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
   }
 
-  private <T> Future<T> maybeWait(Future<T> future) {
-    if (executeSynchronously) {
-      boolean interrupted = false;
-      try {
-        while (!future.isDone()) {
-          try {
-            future.get();
-          } catch (ExecutionException e) {
-            throw new RuntimeException(e);
-          } catch (InterruptedException e) {
-            interrupted = true;
-          }
-        }
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    }
-    return future;
+  @NonNull
+  @Override
+  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
+  }
+
+  @Override
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public <T> Future<T> submit(@NonNull Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
   }
 
   @NonNull
   @Override
-  public <T> Future<T> submit(Runnable task, T result) {
-    return maybeWait(super.submit(task, result));
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
   }
 
   @Override
-  public <T> Future<T> submit(Callable<T> task) {
-    return maybeWait(super.submit(task));
+  public boolean awaitTermination(long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
   }
 
   /**
    * Determines the number of cores available on the device.
-   *
-   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
-   * be the number of available cores depending on the device's current state. See
-   * http://goo.gl/8H670N.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static int calculateBestThreadCount() {
     if (bestThreadCount == 0) {
-      // We override the current ThreadPolicy to allow disk reads.
-      // This shouldn't actually do disk-IO and accesses a device file.
-      // See: https://github.com/bumptech/glide/issues/1170
-      ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
-      File[] cpus = null;
-      try {
-        File cpuInfo = new File(CPU_LOCATION);
-        final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-        cpus = cpuInfo.listFiles(new FilenameFilter() {
-          @Override
-          public boolean accept(File file, String s) {
-            return cpuNamePattern.matcher(s).matches();
-          }
-        });
-      } catch (Throwable t) {
-        if (Log.isLoggable(TAG, Log.ERROR)) {
-          Log.e(TAG, "Failed to calculate accurate cpu count", t);
-        }
-      } finally {
-        StrictMode.setThreadPolicy(originalPolicy);
-      }
-
-      int cpuCount = cpus != null ? cpus.length : 0;
-      int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
       bestThreadCount =
-          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());
     }
     return bestThreadCount;
   }
@@ -343,6 +369,8 @@ public boolean accept(File file, String s) {
     /**
      * Silently catches and ignores the uncaught {@link Throwable}s.
      */
+    // Public API.
+    @SuppressWarnings("unused")
     UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
       @Override
       public void handle(Throwable t) {
@@ -363,6 +391,8 @@ public void handle(Throwable t) {
     /**
      * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
+    // Public API.
+    @SuppressWarnings("unused")
     UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
       @Override
       public void handle(Throwable t) {
@@ -383,6 +413,9 @@ public void handle(Throwable t) {
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
+    private static final int DEFAULT_PRIORITY = android.os.Process.THREAD_PRIORITY_BACKGROUND
+        + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
+
     private final String name;
     @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
     @Synthetic final boolean preventNetworkOperations;
@@ -400,9 +433,7 @@ public synchronized Thread newThread(@NonNull Runnable runnable) {
       final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(
-              android.os.Process.THREAD_PRIORITY_BACKGROUND
-              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
+          android.os.Process.setThreadPriority(DEFAULT_PRIORITY);
           if (preventNetworkOperations) {
             StrictMode.setThreadPolicy(
                 new ThreadPolicy.Builder()
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
new file mode 100644
index 000000000..8dc69bdeb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.util.Log;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.regex.Pattern;
+
+/**
+ * Compatibility methods for {@link java.lang.Runtime}.
+ */
+final class RuntimeCompat {
+  private static final String TAG = "GlideRuntimeCompat";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+
+  private RuntimeCompat() {
+    // Utility class.
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   */
+  static int availableProcessors() {
+    int cpus = Runtime.getRuntime().availableProcessors();
+    if (Build.VERSION.SDK_INT < 17) {
+      cpus = Math.max(getCoreCountPre17(), cpus);
+    }
+    return cpus;
+  }
+
+  /**
+   * Determines the number of cores available on the device (pre-v17).
+   *
+   * <p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,
+   * which may not be the number of available cores depending on the device's current state. See
+   * https://stackoverflow.com/a/30150409.
+   *
+   * @return the maximum number of processors available to the VM; never smaller than one
+   */
+  @SuppressWarnings("PMD")
+  private static int getCoreCountPre17() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    File[] cpus = null;
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+    return Math.max(1, cpus != null ? cpus.length : 0);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index d9ed0b3f7..e1f331783 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -423,7 +423,7 @@ public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
-    harness.diskCacheService.shutdownNow();
+    harness.sourceService.shutdownNow();
     job.start(harness.decodeJob);
 
     verify(harness.decodeJob).run();
@@ -466,8 +466,8 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     final EngineJob<Object> job;
     final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    final GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     final DataSource dataSource = DataSource.LOCAL;
@@ -503,8 +503,8 @@ public MultiCbHarness() {
     final EngineJobListener listener = mock(EngineJobListener.class);
     final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
-    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
-    final GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
     final boolean useAnimationPool = false;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 904dbaa16..755d89c68 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -556,8 +556,8 @@ Engine getEngine() {
                 mock(DiskCache.Factory.class),
                 GlideExecutor.newDiskCacheExecutor(),
                 MockGlideExecutor.newMainThreadExecutor(),
-                MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-                MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
                 jobs,
                 keyFactory,
                 activeResources,
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
index af0dce220..94ef1782c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -1,24 +1,116 @@
 package com.bumptech.glide.load.engine.executor;
 
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
 /**
  * Creates mock {@link GlideExecutor}s.
  */
+@VisibleForTesting
 public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
 
-  private MockGlideExecutor() { }
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
 
   public static GlideExecutor newMainThreadExecutor() {
-    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
+    return newTestExecutor(new DirectExecutorService());
   }
 
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
   public static GlideExecutor newMainThreadUnlimitedExecutor() {
-    return new GlideExecutor(0 /* corePoolSize */,
-        Integer.MAX_VALUE /* maximumPoolSize */,
-        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
-        "mock-unlimited-glide-executor",
-        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
-        true /*runAllOnMainThread*/);
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 9278795fb..9b7373834 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -10,6 +10,8 @@
 import android.support.annotation.NonNull;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.RecyclerListener;
+import android.support.v7.widget.RecyclerView.ViewHolder;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
@@ -53,6 +55,15 @@ protected void onCreate(Bundle savedInstanceState) {
     RecyclerViewPreloader<Api.GifResult> preloader =
         new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
+    gifList.setRecyclerListener(new RecyclerListener() {
+      @Override
+      public void onViewRecycled(ViewHolder holder) {
+        // This is an optimization to reduce the memory usage of RecyclerView's recycled view pool
+        // and good practice when using Glide with RecyclerView.
+        GifViewHolder gifViewHolder = (GifViewHolder) holder;
+        GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+      }
+    });
   }
 
   @Override
@@ -124,7 +135,9 @@ public void onClick(View view) {
         }
       });
 
-      requestBuilder.load(result).into(holder.gifView);
+      // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
+      // but that are currently off screen.
+      requestBuilder.load(result).into(holder.gifView).clearOnDetach();
 
       preloadSizeProvider.setView(holder.gifView);
     }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index 3d5d38b8e..d0356882b 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -32,6 +32,7 @@
 import android.graphics.Bitmap.Config;
 import android.support.annotation.ColorInt;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -94,15 +95,6 @@
   /** Raw data read working array. */
   private byte[] block;
 
-  private static final int WORK_BUFFER_SIZE = 16 * 1024;
-  /**
-   * Temporary buffer for block reading.
-   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
-   */
-  private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
   private GifHeaderParser parser;
 
   // LZW decoder working arrays.
@@ -122,7 +114,8 @@
   private int sampleSize;
   private int downsampledHeight;
   private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  @Nullable
+  private Boolean isFirstFrameTransparent;
   @NonNull
   private Bitmap.Config bitmapConfig = Config.ARGB_8888;
 
@@ -253,6 +246,10 @@ public synchronized Bitmap getNextFrame() {
     }
     status = STATUS_OK;
 
+    if (block == null) {
+      block = bitmapProvider.obtainByteArray(255);
+    }
+
     GifFrame currentFrame = header.frames.get(framePointer);
     GifFrame previousFrame = null;
     int previousIndex = framePointer - 1;
@@ -331,13 +328,10 @@ public void clear() {
     }
     previousImage = null;
     rawData = null;
-    isFirstFrameTransparent = false;
+    isFirstFrameTransparent = null;
     if (block != null) {
       bitmapProvider.release(block);
     }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
   }
 
   @Override
@@ -359,7 +353,6 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     sampleSize = Integer.highestOneBit(sampleSize);
     this.status = STATUS_OK;
     this.header = header;
-    isFirstFrameTransparent = false;
     framePointer = INITIAL_FRAME_POINTER;
     // Initialize the raw data buffer.
     rawData = buffer.asReadOnlyBuffer();
@@ -478,6 +471,76 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     // Decode pixels for this frame into the global pixels[] scratch.
     decodeBitmapData(currentFrame);
 
+    if (currentFrame.interlace || sampleSize != 1) {
+      copyCopyIntoScratchRobust(currentFrame);
+    } else {
+      copyIntoScratchFast(currentFrame);
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private void copyIntoScratchFast(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih;
+    int downsampledIY = currentFrame.iy;
+    int downsampledIW = currentFrame.iw;
+    int downsampledIX = currentFrame.ix;
+    // Copy each source line to the appropriate place in the destination.
+    boolean isFirstFrame = framePointer == 0;
+    int width = this.downsampledWidth;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    byte transparentColorIndex = -1;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i + downsampledIY;
+      int k = line * width;
+      // Start of line in dest.
+      int dx = k + downsampledIX;
+      // End of dest line.
+      int dlim = dx + downsampledIW;
+      if (k + width < dlim) {
+        // Past dest edge.
+        dlim = k + width;
+      }
+      // Start of line in source.
+      int sx = i * currentFrame.iw;
+
+      while (dx < dlim) {
+        byte byteCurrentColorIndex = mainPixels[sx];
+        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;
+        if (currentColorIndex != transparentColorIndex) {
+          int color = act[currentColorIndex];
+          if (color != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = color;
+          } else {
+            transparentColorIndex = byteCurrentColorIndex;
+          }
+        }
+        ++sx;
+        ++dx;
+      }
+    }
+
+    isFirstFrameTransparent =
+        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;
+  }
+
+  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
+    int[] dest = mainScratch;
     int downsampledIH = currentFrame.ih / sampleSize;
     int downsampledIY = currentFrame.iy / sampleSize;
     int downsampledIW = currentFrame.iw / sampleSize;
@@ -487,6 +550,13 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
     int inc = 8;
     int iline = 0;
     boolean isFirstFrame = framePointer == 0;
+    int sampleSize = this.sampleSize;
+    int downsampledWidth = this.downsampledWidth;
+    int downsampledHeight = this.downsampledHeight;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    @Nullable
+    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;
     for (int i = 0; i < downsampledIH; i++) {
       int line = i;
       if (currentFrame.interlace) {
@@ -512,6 +582,7 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         iline += inc;
       }
       line += downsampledIY;
+      boolean isNotDownsampling = sampleSize == 1;
       if (line < downsampledHeight) {
         int k = line * downsampledWidth;
         // Start of line in dest.
@@ -524,45 +595,47 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
         }
         // Start of line in source.
         int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          @ColorInt int averageColor;
-          if (sampleSize == 1) {
+        if (isNotDownsampling) {
+          int averageColor;
+          while (dx < dlim) {
             int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
             averageColor = act[currentColorIndex];
-          } else {
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (
+                isFirstFrameTransparent == null && isFirstFrame && !isFirstFrameTransparent) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        } else {
+          int averageColor;
+          int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+          while (dx < dlim) {
+            // Map color and insert in destination.
             // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
             // current color index above, even with a sample size of 1.
             averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && !isFirstFrameTransparent) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
           }
-          if (averageColor != COLOR_TRANSPARENT_BLACK) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
         }
       }
     }
 
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
+    if (this.isFirstFrameTransparent == null) {
+      this.isFirstFrameTransparent = isFirstFrameTransparent == null
+          ? false : isFirstFrameTransparent;
     }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
   }
 
+
   @ColorInt
   private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
       int currentFrameIw) {
@@ -614,8 +687,6 @@ private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPix
    * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
    */
   private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
     if (frame != null) {
       // Jump to the frame start position.
       rawData.position(frame.bufferFrameStart);
@@ -629,15 +700,19 @@ private void decodeBitmapData(GifFrame frame) {
       // Allocate new pixel array.
       mainPixels = bitmapProvider.obtainByteArray(npix);
     }
+    byte[] mainPixels = this.mainPixels;
     if (prefix == null) {
       prefix = new short[MAX_STACK_SIZE];
     }
+    short[] prefix = this.prefix;
     if (suffix == null) {
       suffix = new byte[MAX_STACK_SIZE];
     }
+    byte[] suffix = this.suffix;
     if (pixelStack == null) {
       pixelStack = new byte[MAX_STACK_SIZE + 1];
     }
+    byte[] pixelStack = this.pixelStack;
 
     // Initialize GIF data stream decoder.
     dataSize = readByte();
@@ -647,18 +722,18 @@ private void decodeBitmapData(GifFrame frame) {
     oldCode = NULL_CODE;
     codeSize = dataSize + 1;
     codeMask = (1 << codeSize) - 1;
+
     for (code = 0; code < clear; code++) {
       // XXX ArrayIndexOutOfBoundsException.
       prefix[code] = 0;
       suffix[code] = (byte) code;
     }
-
+    byte[] block = this.block;
     // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
+    i = datum = bits = count = first = top = pi = bi = 0;
+    while (i < npix) {
         // Read a new data block.
+      if (count == 0) {
         count = readBlock();
         if (count <= 0) {
           status = STATUS_PARTIAL_DECODE;
@@ -669,8 +744,8 @@ private void decodeBitmapData(GifFrame frame) {
 
       datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
       bits += 8;
-      bi++;
-      count--;
+      ++bi;
+      --count;
 
       while (bits >= codeSize) {
         // Get the next code.
@@ -686,87 +761,64 @@ private void decodeBitmapData(GifFrame frame) {
           available = clear + 2;
           oldCode = NULL_CODE;
           continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
+        } else if (code == endOfInformation) {
           break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
+        } else if (oldCode == NULL_CODE) {
+          pixelStack[top] = suffix[code];
+          ++top;
           oldCode = code;
           first = code;
           continue;
         }
+
         inCode = code;
         if (code >= available) {
-          pixelStack[top++] = (byte) first;
+          pixelStack[top] = (byte) first;
+          ++top;
           code = oldCode;
         }
+
         while (code >= clear) {
-          pixelStack[top++] = suffix[code];
+          pixelStack[top] = suffix[code];
+          ++top;
           code = prefix[code];
         }
         first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
-        pixelStack[top++] = (byte) first;
+
+        mainPixels[pi] = (byte) first;
+        ++pi;
+        ++i;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi] = pixelStack[--top];
+          ++pi;
+          ++i;
+        }
 
         // Add a new string to the string table.
         if (available < MAX_STACK_SIZE) {
           prefix[available] = (short) oldCode;
           suffix[available] = (byte) first;
-          available++;
+          ++available;
           if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
+            ++codeSize;
             codeMask += available;
           }
         }
         oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
       }
     }
 
     // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
+    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);
   }
 
   /**
    * Reads a single byte from the input stream.
    */
   private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
+    return rawData.get() & MASK_INT_LOWEST_BYTE;
   }
 
   /**
@@ -776,37 +828,15 @@ private int readByte() {
    */
   private int readBlock() {
     int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
+    if (blockSize <= 0) {
+      return blockSize;
     }
+    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));
     return blockSize;
   }
 
   private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
+    Bitmap.Config config = isFirstFrameTransparent == null || isFirstFrameTransparent
         ? Bitmap.Config.ARGB_8888 : bitmapConfig;
     Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
     result.setHasAlpha(true);
