diff --git a/README.md b/README.md
index a7931876c..0247ae4f4 100644
--- a/README.md
+++ b/README.md
@@ -63,7 +63,7 @@ public void onCreate(Bundle savedInstanceState) {
 
     ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);
+    Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
 // For a list:
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 0a8543bf8..eaad8c6d1 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -3,8 +3,11 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,9 +17,11 @@
  * Fetches an {@link InputStream} using the okhttp library.
  */
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+    private static final String CONTENT_LENGTH_HEADER = "Content-Length";
     private final OkHttpClient client;
     private final GlideUrl url;
     private InputStream stream;
+    private ResponseBody responseBody;
 
     public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
         this.client = client;
@@ -28,26 +33,36 @@ public InputStream loadData(Priority priority) throws Exception {
         Request.Builder requestBuilder = new Request.Builder()
                 .url(url.toStringUrl());
         for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
-          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+            requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
         }
         Request request = requestBuilder.build();
 
-        stream = client.newCall(request)
-                .execute()
-                .body()
-                .byteStream();
+        Response response = client.newCall(request).execute();
+        responseBody = response.body();
+        if (!response.isSuccessful()) {
+            throw new IOException("Request failed with code: " + response.code());
+        }
+
+        String contentLength = response.header(CONTENT_LENGTH_HEADER);
+        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         return stream;
     }
 
     @Override
     public void cleanup() {
-        if (stream == null) {
-            return;
+        if (stream != null) {
+            try {
+                stream.close();
+            } catch (IOException e) {
+                // Ignored
+            }
         }
-        try {
-            stream.close();
-        } catch (IOException e) {
-            // Ignored
+        if (responseBody != null) {
+            try {
+                responseBody.close();
+            } catch (IOException e) {
+                // Ignored.
+            }
         }
     }
 
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
new file mode 100644
index 000000000..01720eccf
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.load.data;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.testutil.TestResourceUtil;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class ExifOrientationStreamTest {
+  private InputStream openOrientationExample(boolean isLandscape, int item) {
+    String filePrefix = isLandscape ? "Landscape" : "Portrait";
+    return TestResourceUtil.openResource(getClass(),
+        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
+  }
+
+  @Test
+  public void testIncludesGivenExifOrientation() throws IOException {
+    for (int i = 0; i < 8; i++) {
+      for (int j = 0; j < 8; j++) {
+        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
+        InputStream wrapped = new ExifOrientationStream(toWrap, i);
+        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
+        assertThat(parser.getOrientation()).isEqualTo(i);
+
+        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
+        wrapped = new ExifOrientationStream(toWrap, i);
+        parser = new ImageHeaderParser(wrapped);
+        assertThat(parser.getOrientation()).isEqualTo(i);
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 49066f823..c0ad2153f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -15,8 +15,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -24,7 +25,8 @@
 import java.net.HttpURLConnection;
 import java.net.URL;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class HttpUrlFetcherTest {
     private HttpURLConnection urlConnection;
     private HttpUrlFetcher fetcher;
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
index 325f3fc4c..e4861f80f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java
@@ -2,6 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -38,10 +39,11 @@ public void setUp() {
     public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
         InputStream expected = new ByteArrayInputStream(new byte[0]);
 
-        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(expected);
+        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(
+            expected);
 
         InputStream result = harness.get().loadData(Priority.LOW);
-        assertEquals(expected, result);
+        assertNotNull(result);
     }
 
     @Test
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
index 2ddadbd9a..d52e7133f 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java
@@ -38,14 +38,14 @@ public void setUp() {
 
     @Test
     public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
+        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
         assertNull(harness.get()
                 .open(Robolectric.application, harness.uri));
     }
 
     @Test
     public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(
+        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(
                 new MatrixCursor(new String[1]));
         assertNull(harness.get()
                 .open(Robolectric.application, harness.uri));
@@ -55,7 +55,7 @@ public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
     public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
         MatrixCursor cursor = new MatrixCursor(new String[1]);
         cursor.addRow(new Object[]{ "" });
-        when(harness.query.query(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
+        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
         assertNull(harness.get()
                 .open(Robolectric.application, harness.uri));
     }
@@ -93,7 +93,7 @@ public void testVideoQueryReturnsVideoCursor() {
         MediaStoreThumbFetcher.VideoThumbnailQuery query = new MediaStoreThumbFetcher.VideoThumbnailQuery();
         TestCursor testCursor = new SimpleTestCursor();
         Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
-        assertEquals(testCursor, query.query(Robolectric.application, harness.uri));
+        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
     }
 
     @Test
@@ -102,7 +102,7 @@ public void testImageQueryReturnsImageCurosr() {
         MediaStoreThumbFetcher.ImageThumbnailQuery query = new MediaStoreThumbFetcher.ImageThumbnailQuery();
         TestCursor testCursor = new SimpleTestCursor();
         Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
-        assertEquals(testCursor, query.query(Robolectric.application, harness.uri));
+        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
     }
 
     private static class Harness {
@@ -114,7 +114,7 @@ public void testImageQueryReturnsImageCurosr() {
 
         public Harness() {
             cursor.addRow(new String[] { file.getAbsolutePath() });
-            when(query.query(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
+            when(query.queryPath(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
             when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
             when(service.exists(eq(file))).thenReturn(true);
             when(service.length(eq(file))).thenReturn(1L);
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java
new file mode 100644
index 000000000..a4f15ecb4
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -0,0 +1,211 @@
+package com.bumptech.glide.load.model;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.testing.EqualsTester;
+
+import com.bumptech.glide.load.model.LazyHeaders.Builder;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Map;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class LazyHeadersTest {
+
+    @Test
+    public void testIncludesEagerHeaders() {
+        Map<String, String> headers = new Builder()
+            .addHeader("key", "value")
+            .build()
+            .getHeaders();
+        assertThat(headers).containsEntry("key", "value");
+        assertThat(headers).hasSize(1);
+    }
+
+    @Test
+    public void testIncludesLazyHeaders() {
+        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+        when(factory.buildHeader()).thenReturn("value");
+        Map<String, String> headers = new Builder()
+            .addHeader("key", factory)
+            .build()
+            .getHeaders();
+
+        assertThat(headers).hasSize(1);
+        assertThat(headers).containsEntry("key", "value");
+    }
+
+    @Test
+    public void testMultipleEagerValuesAreSeparatedByCommas() {
+        Map<String, String> headers = new Builder()
+            .addHeader("key", "first")
+            .addHeader("key", "second")
+            .build()
+            .getHeaders();
+
+        assertThat(headers).hasSize(1);
+        assertThat(headers).containsEntry("key", "first,second");
+    }
+
+    @Test
+    public void testMultipleLazyValuesAreSeparatedByCommas() {
+        LazyHeaderFactory first = mock(LazyHeaderFactory.class);
+        when(first.buildHeader()).thenReturn("first");
+        LazyHeaderFactory second = mock(LazyHeaderFactory.class);
+        when(second.buildHeader()).thenReturn("second");
+
+        Map<String, String> headers = new Builder()
+            .addHeader("key", first)
+            .addHeader("key", second)
+            .build()
+            .getHeaders();
+        assertThat(headers).hasSize(1);
+        assertThat(headers).containsEntry("key", "first,second");
+    }
+
+    @Test
+    public void testMixedEagerAndLazyValuesAreIncluded() {
+        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+        when(factory.buildHeader()).thenReturn("first");
+        Map<String, String> headers = new Builder()
+            .addHeader("key", factory)
+            .addHeader("key", "second")
+            .build()
+            .getHeaders();
+
+        assertThat(headers).hasSize(1);
+        assertThat(headers).containsEntry("key", "first,second");
+
+        headers = new Builder()
+            .addHeader("key", "second")
+            .addHeader("key", factory)
+            .build()
+            .getHeaders();
+
+        assertThat(headers).hasSize(1);
+        assertThat(headers).containsEntry("key", "second,first");
+    }
+
+    @Test
+    public void testCanAddMultipleKeys() {
+        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+        when(factory.buildHeader()).thenReturn("lazy");
+        Map<String, String> headers = new Builder()
+            .addHeader("first", factory)
+            .addHeader("second", "eager")
+            .build()
+            .getHeaders();
+
+        assertThat(headers).hasSize(2);
+        assertThat(headers).containsEntry("first", "lazy");
+        assertThat(headers).containsEntry("second", "eager");
+    }
+
+    @Test
+    public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
+        Builder builder = new Builder();
+        builder.addHeader("key", "firstValue");
+        LazyHeaders first = builder.build();
+
+        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
+        when(factory.buildHeader()).thenReturn("otherValue");
+        builder.addHeader("key", "secondValue");
+        builder.addHeader("otherKey", factory);
+        LazyHeaders second = builder.build();
+
+        assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());
+
+        assertThat(first.getHeaders()).hasSize(1);
+        assertThat(first.getHeaders()).containsEntry("key", "firstValue");
+
+        assertThat(second.getHeaders()).hasSize(2);
+        assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
+        assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
+    }
+
+    @Test
+    public void testEquals() {
+        LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
+        LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
+        new EqualsTester()
+            .addEqualityGroup(
+                new Builder().build(),
+                new Builder().build()
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("key", "value").build(),
+                new Builder().addHeader("key", "value").build()
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("key", "value").addHeader("key", "value").build()
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("key", firstLazyFactory).build(),
+                new Builder().addHeader("key", firstLazyFactory).build()
+            )
+            .addEqualityGroup(
+                new Builder()
+                    .addHeader("key", firstLazyFactory)
+                    .addHeader("key", firstLazyFactory)
+                    .build()
+            )
+            .addEqualityGroup(
+                new Builder()
+                    .addHeader("firstKey", "value")
+                    .addHeader("secondKey", firstLazyFactory)
+                    .build(),
+                new Builder()
+                    .addHeader("secondKey", firstLazyFactory)
+                    .addHeader("firstKey", "value")
+                    .build()
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("key", "secondValue")
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("secondKey", "value")
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("key", secondLazyFactory)
+            )
+            .addEqualityGroup(
+                new Builder().addHeader("secondKey", firstLazyFactory)
+            )
+            .addEqualityGroup(
+                new Builder()
+                    .addHeader("firstKey", "firstValue")
+                    .addHeader("secondKey", "secondValue")
+                    .build(),
+                new Builder()
+                    .addHeader("firstKey", "firstValue")
+                    .addHeader("secondKey", "secondValue")
+                    .build(),
+                new Builder()
+                    .addHeader("secondKey", "secondValue")
+                    .addHeader("firstKey", "firstValue")
+                    .build()
+            )
+            .addEqualityGroup(
+                new Builder()
+                    .addHeader("firstKey", firstLazyFactory)
+                    .addHeader("secondKey", secondLazyFactory)
+                    .build(),
+                new Builder()
+                    .addHeader("firstKey", firstLazyFactory)
+                    .addHeader("secondKey", secondLazyFactory)
+                    .build(),
+                new Builder()
+                    .addHeader("secondKey", secondLazyFactory)
+                    .addHeader("firstKey", firstLazyFactory)
+                    .build()
+            )
+            .testEquals();
+    }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
index f82d085cd..3316145a7 100644
--- a/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import static org.junit.Assert.assertEquals;
 
@@ -7,13 +8,16 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
 public class ImageHeaderParserTest {
 
     private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK = new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a,
@@ -84,10 +88,82 @@ public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOExcep
         assertEquals(-1, parser.getOrientation());
     }
 
+    // Test for #387.
+    @Test
+    public void testHandlesPartialReads() throws IOException {
+        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+        ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is));
+        assertThat(parser.getOrientation()).isEqualTo(6);
+    }
+
+    // Test for #387.
+    @Test
+    public void testHandlesPartialSkips() throws IOException {
+        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+        ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is));
+        assertThat(parser.getOrientation()).isEqualTo(6);
+    }
+
+    @Test
+    public void testHandlesSometimesZeroSkips() throws IOException {
+        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+        ImageHeaderParser parser = new ImageHeaderParser(new SometimesZeroSkipInputStream(is));
+        assertEquals(ImageType.PNG, parser.getType());
+    }
+
     private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
         byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
         System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
         result[result.length - 1] = (byte) bitDepth;
         return result;
     }
+
+    private static class SometimesZeroSkipInputStream extends FilterInputStream {
+        boolean returnZeroFlag = true;
+
+        protected SometimesZeroSkipInputStream(InputStream in) {
+            super(in);
+        }
+
+        @Override
+        public long skip(long byteCount) throws IOException {
+            if (returnZeroFlag) {
+                return 0;
+            }
+            returnZeroFlag = !returnZeroFlag;
+            return super.skip(byteCount);
+        }
+    }
+
+    private static class PartialSkipInputStream extends FilterInputStream {
+
+        protected PartialSkipInputStream(InputStream in) {
+            super(in);
+        }
+
+        @Override
+        public long skip(long byteCount) throws IOException {
+            long toActuallySkip = byteCount / 2;
+            if (byteCount == 1) {
+                toActuallySkip = 1;
+            }
+            return super.skip(toActuallySkip);
+        }
+    }
+
+    private static class PartialReadInputStream extends FilterInputStream {
+
+        protected PartialReadInputStream(InputStream in) {
+            super(in);
+        }
+
+        @Override
+        public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+            int toActuallyRead = byteCount / 2;
+            if (byteCount == 1) {
+                toActuallyRead = 1;
+            }
+            return super.read(buffer, byteOffset, toActuallyRead);
+        }
+    }
 }
\ No newline at end of file
diff --git a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
index 69ff5fb6c..d933e2757 100644
--- a/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.resize.load;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -41,6 +42,12 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
         }
     }
 
+    @Test
+    public void testIssue387() throws IOException {
+        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+        assertThat(new ImageHeaderParser(is).getOrientation()).isEqualTo(6);
+    }
+
     @Test
     public void testLandscape() throws IOException {
         for (int i = 1; i <= 8; i++) {
diff --git a/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
new file mode 100644
index 000000000..01f1fe73b
--- /dev/null
+++ b/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -0,0 +1,134 @@
+package com.bumptech.glide.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, emulateSdk = 18)
+public class ContentLengthInputStreamTest {
+  @Mock InputStream wrapped;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength()
+      throws IOException {
+    int value = 123356;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));
+
+    assertThat(is.available()).isEqualTo(value);
+  }
+
+  @Test
+  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
+      throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
+    int expected = 1234;
+    when(wrapped.available()).thenReturn(expected);
+
+    assertThat(is.available()).isEqualTo(expected);
+  }
+
+  @Test
+  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    int expected = 567;
+    when(wrapped.available()).thenReturn(expected);
+
+    assertThat(is.available()).isEqualTo(expected);
+  }
+
+  @Test
+  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {
+    int contentLength = 999;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(1);
+
+    assertThat(is.read()).isEqualTo(1);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
+  }
+
+  @Test
+  public void testAvailable_handlesReadValueOfZero() throws IOException {
+    int contentLength = 999;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(0);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.available()).isEqualTo(contentLength);
+  }
+
+  @Test
+  public void testAvailable_withReadBytes_returnsContentLengthOffsetByNumberOfBytes()
+      throws IOException {
+    int contentLength = 678;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    int read = 100;
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(read);
+
+    assertThat(is.read(new byte[500], 0, 0)).isEqualTo(read);
+    assertThat(is.available()).isEqualTo(contentLength - read);
+  }
+
+  @Test
+  public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
+      throws IOException {
+    int contentLength = 1;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read()).thenReturn(-1);
+
+    try {
+      is.read();
+      fail("Failed to throw expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
+      throws IOException {
+    int contentLength = 2;
+    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+
+    try {
+      is.read(new byte[10], 0, 0);
+      fail("Failed to throw expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    when(wrapped.read()).thenReturn(-1);
+    is.read();
+  }
+
+  @Test
+  public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow()
+      throws IOException {
+    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
+    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    is.read(new byte[10], 0, 0);
+  }
+}
\ No newline at end of file
diff --git a/library/src/androidTest/resources/issue387_rotated_jpeg.jpg b/library/src/androidTest/resources/issue387_rotated_jpeg.jpg
new file mode 100644
index 000000000..5852dac00
Binary files /dev/null and b/library/src/androidTest/resources/issue387_rotated_jpeg.jpg differ
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
new file mode 100644
index 000000000..1fe41b572
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -0,0 +1,133 @@
+package com.bumptech.glide.load.data;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
+ * image data.
+ *
+ * <p>This class assumes that the wrapped stream contains an image format that can contain
+ * exif information and performs no verification. </p>
+ */
+public class ExifOrientationStream extends FilterInputStream {
+    /** Allow two bytes for the file format. */
+    private static final int SEGMENT_START_POSITION = 2;
+    private static final byte[] EXIF_SEGMENT = new byte[] {
+        /** segment start id. */
+        (byte) 0xFF,
+        /** segment type. */
+        (byte) 0xE1,
+        /** segmentLength. */
+        0x00,
+        (byte) 0x1C,
+        /** exif identifier. */
+        0x45,
+        0x78,
+        0x69,
+        0x66,
+        0x00,
+        0x00,
+        /** mototorola byte order (big endian). */
+        (byte) 0x4D,
+        (byte) 0x4D,
+        /** filler? */
+        0x00,
+        0x00,
+        /** first id offset. */
+        0x00,
+        0x00,
+        0x00,
+        0x08,
+        /** tagCount. */
+        0x00,
+        0x01,
+        /** exif tag type. */
+        0x01,
+        0x12,
+        /** 2 byte format. */
+        0x00,
+        0x02,
+        /** component count. */
+        0x00,
+        0x00,
+        0x00,
+        0x01,
+        /** 2 byte orientation value, the first byte of which is always 0. */
+        0x00,
+    };
+    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
+    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
+    private final byte orientation;
+    private int position;
+
+    public ExifOrientationStream(InputStream in, int orientation) {
+        super(in);
+        if (orientation < -1 || orientation > 8) {
+            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
+        }
+        this.orientation = (byte) orientation;
+    }
+
+    @Override
+    public boolean markSupported() {
+        return false;
+    }
+
+    @Override
+    public void mark(int readlimit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int read() throws IOException {
+        final int result;
+        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
+            result = super.read();
+        } else if (position == ORIENTATION_POSITION) {
+            result = orientation;
+        } else {
+            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
+        }
+        if (result != -1) {
+            position++;
+        }
+        return result;
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int read;
+        if (position > ORIENTATION_POSITION) {
+            read = super.read(buffer, byteOffset, byteCount);
+        } else if (position == ORIENTATION_POSITION) {
+            buffer[byteOffset] = orientation;
+            read = 1;
+        } else if (position < SEGMENT_START_POSITION) {
+            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
+        } else {
+            read = Math.min(ORIENTATION_POSITION - position, byteCount);
+            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
+                read);
+        }
+        if (read > 0) {
+            position += read;
+        }
+        return read;
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long skipped = super.skip(byteCount);
+        if (skipped > 0) {
+            position += skipped;
+        }
+        return skipped;
+    }
+
+    @Override
+    public void reset() throws IOException {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 8ea527416..af265b069 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -4,6 +4,7 @@
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -16,6 +17,7 @@
  * A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.
  */
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
+    private static final String CONTENT_LENGTH = "Content-Length";
     private static final int MAXIMUM_REDIRECTS = 5;
     private static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultHttpUrlConnectionFactory();
 
@@ -72,7 +74,8 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, M
         }
         final int statusCode = urlConnection.getResponseCode();
         if (statusCode / 100 == 2) {
-            stream = urlConnection.getInputStream();
+            String contentLength = urlConnection.getHeaderField(CONTENT_LENGTH);
+            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
             return stream;
         } else if (statusCode / 100 == 3) {
             String redirectUrlString = urlConnection.getHeaderField("Location");
diff --git a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
index b9b622a11..ea4a97e3c 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java
@@ -6,8 +6,10 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.text.TextUtils;
+import android.util.Log;
 
 import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -22,6 +24,7 @@
  * {@link android.provider.MediaStore.Video.Thumbnails}.
  */
 public class MediaStoreThumbFetcher implements DataFetcher<InputStream> {
+    private static final String TAG = "MediaStoreThumbFetcher";
     private static final int MINI_WIDTH = 512;
     private static final int MINI_HEIGHT = 384;
     private static final ThumbnailStreamOpenerFactory DEFAULT_FACTORY = new ThumbnailStreamOpenerFactory();
@@ -54,14 +57,35 @@ public InputStream loadData(Priority priority) throws Exception {
         ThumbnailStreamOpener fetcher = factory.build(mediaStoreUri, width, height);
 
         if (fetcher != null) {
-            inputStream = fetcher.open(context, mediaStoreUri);
+            inputStream = openThumbInputStream(fetcher);
         }
 
-        if (inputStream != null) {
-            return inputStream;
-        } else {
-            return defaultFetcher.loadData(priority);
+        if (inputStream == null) {
+            inputStream = defaultFetcher.loadData(priority);
         }
+
+        return inputStream;
+    }
+
+    private InputStream openThumbInputStream(ThumbnailStreamOpener fetcher) {
+        InputStream result = null;
+        try {
+            result = fetcher.open(context, mediaStoreUri);
+        } catch (FileNotFoundException e) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+                Log.d(TAG, "Failed to find thumbnail file", e);
+            }
+        }
+
+        int orientation = -1;
+        if (result != null) {
+            orientation = fetcher.getOrientation(context, mediaStoreUri);
+        }
+
+        if (orientation != -1) {
+            result = new ExifOrientationStream(result, orientation);
+        }
+        return result;
     }
 
     @Override
@@ -111,7 +135,7 @@ public File get(String path) {
     }
 
     interface ThumbnailQuery {
-        Cursor query(Context context, Uri uri);
+        Cursor queryPath(Context context, Uri uri);
     }
 
     static class ThumbnailStreamOpener {
@@ -128,20 +152,36 @@ public ThumbnailStreamOpener(FileService service, ThumbnailQuery query) {
             this.query = query;
         }
 
+        public int getOrientation(Context context, Uri uri) {
+            int orientation = -1;
+            InputStream is = null;
+            try {
+                is = context.getContentResolver().openInputStream(uri);
+                orientation = new ImageHeaderParser(is).getOrientation();
+            } catch (IOException e) {
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                    Log.d(TAG, "Failed to open uri: " + uri, e);
+                }
+            } finally {
+                if (is != null) {
+                    try {
+                        is.close();
+                    } catch (IOException e) {
+                        // Ignored.
+                    }
+                }
+            }
+            return orientation;
+        }
+
         public InputStream open(Context context, Uri uri) throws FileNotFoundException {
             Uri thumbnailUri = null;
             InputStream inputStream = null;
 
-            final Cursor cursor = query.query(context, uri);
+            final Cursor cursor = query.queryPath(context, uri);
             try {
                 if (cursor != null && cursor.moveToFirst()) {
-                    String path = cursor.getString(0);
-                    if (!TextUtils.isEmpty(path)) {
-                        File file = service.get(path);
-                        if (service.exists(file) && service.length(file) > 0) {
-                            thumbnailUri = Uri.fromFile(file);
-                        }
-                    }
+                    thumbnailUri = parseThumbUri(cursor);
                 }
             } finally {
                 if (cursor != null) {
@@ -153,29 +193,57 @@ public InputStream open(Context context, Uri uri) throws FileNotFoundException {
             }
             return inputStream;
         }
+
+        private Uri parseThumbUri(Cursor cursor) {
+            Uri result = null;
+            String path = cursor.getString(0);
+            if (!TextUtils.isEmpty(path)) {
+                File file = service.get(path);
+                if (service.exists(file) && service.length(file) > 0) {
+                    result = Uri.fromFile(file);
+                }
+            }
+            return result;
+        }
     }
 
     static class ImageThumbnailQuery implements ThumbnailQuery {
+        private static final String[] PATH_PROJECTION = {
+            MediaStore.Images.Thumbnails.DATA,
+        };
+        private static final String PATH_SELECTION =
+            MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
+            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
         @Override
-        public Cursor query(Context context, Uri uri) {
-            String id = uri.getLastPathSegment();
-            return context.getContentResolver().query(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, new String[] {
-                            MediaStore.Images.Thumbnails.DATA
-                    }, MediaStore.Images.Thumbnails.IMAGE_ID + " = ? AND " + MediaStore.Images.Thumbnails.KIND + " = ?",
-                    new String[] { id, String.valueOf(MediaStore.Images.Thumbnails.MINI_KIND) }, null);
+        public Cursor queryPath(Context context, Uri uri) {
+            String imageId = uri.getLastPathSegment();
+            return context.getContentResolver().query(
+                MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
+                PATH_PROJECTION,
+                PATH_SELECTION,
+                new String[] { imageId },
+                null /*sortOrder*/);
         }
     }
 
     static class VideoThumbnailQuery implements ThumbnailQuery {
+        private static final String[] PATH_PROJECTION = {
+            MediaStore.Video.Thumbnails.DATA
+        };
+        private static final String PATH_SELECTION =
+            MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
+            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
         @Override
-        public Cursor query(Context context, Uri uri) {
-            String id = uri.getLastPathSegment();
-            return context.getContentResolver().query(MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI, new String[] {
-                    MediaStore.Video.Thumbnails.DATA
-            }, MediaStore.Video.Thumbnails.VIDEO_ID + " = ? AND " + MediaStore.Video.Thumbnails.KIND + " = ?",
-                    new String[] { id, String.valueOf(MediaStore.Video.Thumbnails.MINI_KIND) }, null);
+        public Cursor queryPath(Context context, Uri uri) {
+            String videoId = uri.getLastPathSegment();
+            return context.getContentResolver().query(
+                MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
+                PATH_PROJECTION,
+                PATH_SELECTION,
+                new String[] { videoId },
+                null /*sortOrder*/);
         }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 9356b5cac..06265e66b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -9,6 +9,7 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.provider.DataLoadProvider;
@@ -322,6 +323,9 @@ public DiskCache getDiskCache() {
                     if (diskCache == null) {
                         diskCache = factory.build();
                     }
+                    if (diskCache == null) {
+                        diskCache = new DiskCacheAdapter();
+                    }
                 }
             }
             return diskCache;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java
deleted file mode 100644
index e5ec6f9bb..000000000
--- a/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.bumptech.glide.load.model;
-
-import android.text.TextUtils;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * A wrapper class for a set of headers to be included in a Glide request.
- */
-public final class BasicHeaders implements Headers {
-
-    private final Map<String, Set<String>> headers;
-    private volatile Map<String, String> combinedHeaders;
-
-    BasicHeaders(Map<String, Set<String>> headers) {
-        this.headers = Collections.unmodifiableMap(headers);
-    }
-
-    public Map<String, String> getHeaders() {
-        if (combinedHeaders == null) {
-            synchronized (this) {
-                if (combinedHeaders == null) {
-                    this.combinedHeaders = generateCombinedHeaders();
-                }
-            }
-        }
-
-        return combinedHeaders;
-    }
-
-    private Map<String, String> generateCombinedHeaders() {
-        Map<String, String> combinedHeaders = new HashMap<String, String>();
-        for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {
-            combinedHeaders.put(entry.getKey(), TextUtils.join(",", entry.getValue()));
-        }
-        return Collections.unmodifiableMap(combinedHeaders);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o instanceof BasicHeaders) {
-            BasicHeaders other = (BasicHeaders) o;
-            return headers.equals(other.headers);
-        }
-        return false;
-    }
-
-    @Override
-    public int hashCode() {
-        return headers.hashCode();
-    }
-
-    /**
-     * Builder class for {@link Headers}.
-     */
-    public static final class Builder {
-        private final Map<String, Set<String>> headers = new HashMap<String, Set<String>>();
-
-        public void addHeader(String key, String value) {
-            if (headers.containsKey(key)) {
-                headers.get(key).add(value);
-            } else {
-                Set<String> values = new HashSet<String>();
-                values.add(value);
-                headers.put(key, values);
-            }
-        }
-
-        public BasicHeaders build() {
-            return new BasicHeaders(headers);
-        }
-    }
-}
\ No newline at end of file
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
index 52e778735..bae0f304c 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Headers.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import java.util.Collections;
 import java.util.Map;
 
 /**
@@ -9,7 +10,12 @@
 public interface Headers {
 
     /** An empty Headers object that can be used if users don't want to provide headers. */
-    Headers NONE = new BasicHeaders.Builder().build();
+    Headers NONE = new Headers() {
+        @Override
+        public Map<String, String> getHeaders() {
+            return Collections.emptyMap();
+        }
+    };
 
     Map<String, String> getHeaders();
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 2a5231b57..c4f81bed2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,28 +1,26 @@
 package com.bumptech.glide.load.model;
 
-import android.text.TextUtils;
-
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * A wrapper class for a set of headers to be included in a Glide request, allowing headers to be
  * constructed lazily.
  *
- * <p> Should be used instead of BasicHeaders when constructing headers requires I/O. </p>
+ * <p> Ideally headers are constructed once and then re-used for multiple loads, rather then being
+ * constructed individually for each load. </p>
+ *
+ * <p> This class is thread safe. </p>
  */
 public final class LazyHeaders implements Headers {
-    private final Map<String, Set<String>> eagerHeaders;
-    private final Map<String, Set<LazyHeaderFactory>> lazyHeaders;
+    private final Map<String, List<LazyHeaderFactory>> headers;
     private volatile Map<String, String> combinedHeaders;
 
-    LazyHeaders(Map<String, Set<String>> eagerHeaders,
-        Map<String, Set<LazyHeaderFactory>> lazyHeaders) {
-        this.eagerHeaders = Collections.unmodifiableMap(eagerHeaders);
-        this.lazyHeaders = Collections.unmodifiableMap(lazyHeaders);
+    LazyHeaders(Map<String, List<LazyHeaderFactory>> headers) {
+        this.headers = Collections.unmodifiableMap(headers);
     }
 
     @Override
@@ -40,20 +38,18 @@
 
     private Map<String, String> generateHeaders() {
         Map<String, String> combinedHeaders = new HashMap<String, String>();
-        Set<String> combinedKeys = new HashSet<String>(eagerHeaders.keySet());
-        combinedKeys.addAll(lazyHeaders.keySet());
 
-        for (String key : combinedKeys) {
-            Set<String> values = new HashSet<String>();
-            if (eagerHeaders.containsKey(key)) {
-                values.addAll(eagerHeaders.get(key));
-            }
-            if (lazyHeaders.containsKey(key)) {
-                for (LazyHeaderFactory factory : lazyHeaders.get(key)) {
-                    values.add(factory.buildHeader());
+        for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
+            StringBuilder sb = new StringBuilder();
+            List<LazyHeaderFactory> factories = entry.getValue();
+            for (int i = 0; i < factories.size(); i++) {
+                LazyHeaderFactory factory = factories.get(i);
+                sb.append(factory.buildHeader());
+                if (i != factories.size() - 1) {
+                    sb.append(',');
                 }
             }
-            combinedHeaders.put(key, TextUtils.join(",", values));
+            combinedHeaders.put(entry.getKey(), sb.toString());
         }
 
         return combinedHeaders;
@@ -61,74 +57,123 @@
 
     @Override
     public String toString() {
-        Set<String> combinedKeys = new HashSet<String>(eagerHeaders.keySet());
-        combinedKeys.addAll(lazyHeaders.keySet());
-
-        StringBuilder stringBuilder = new StringBuilder();
-        for (String key : combinedKeys) {
-            stringBuilder.append(key)
-                .append(": ");
-            if (eagerHeaders.containsKey(key)) {
-                stringBuilder.append(TextUtils.join(",", eagerHeaders.get(key)));
-            }
-            if (lazyHeaders.containsKey(key)) {
-                for (LazyHeaderFactory factory : lazyHeaders.get(key)) {
-                    stringBuilder.append(factory.toString());
-                    stringBuilder.append(',');
-                }
-            }
-            stringBuilder.append('\n');
-        }
-        return stringBuilder.toString();
+        return "LazyHeaders{"
+            + "headers=" + headers
+            + '}';
     }
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
+        if (o instanceof LazyHeaders) {
+            LazyHeaders other = (LazyHeaders) o;
+            return headers.equals(other.headers);
         }
-
-        LazyHeaders otherHeaders = (LazyHeaders) o;
-        return eagerHeaders.equals(otherHeaders.eagerHeaders)
-            && lazyHeaders.equals(otherHeaders.lazyHeaders);
+        return false;
     }
 
     @Override
     public int hashCode() {
-        return eagerHeaders.hashCode() + 31 * lazyHeaders.hashCode();
+        return headers.hashCode();
     }
 
     /**
-     * Builder class for {@link BasicHeaders}.
+     * Builder class for {@link LazyHeaders}.
+     *
+     * <p> This class is not thread safe. </p>
      */
     public static final class Builder {
-        private final Map<String, Set<String>> eagerHeaders = new HashMap<String, Set<String>>();
-        private final Map<String, Set<LazyHeaderFactory>> lazyHeaders =
-            new HashMap<String, Set<LazyHeaderFactory>>();
-
-        public void addHeader(String key, String value) {
-            Set<String> values = eagerHeaders.get(key);
-            if (values == null) {
-                values = new HashSet<String>();
-                eagerHeaders.put(key, values);
-            }
-            values.add(value);
+        private boolean copyOnModify;
+        private Map<String, List<LazyHeaderFactory>> headers =
+            new HashMap<String, List<LazyHeaderFactory>>();
+
+        /**
+         * Adds a value for the given header and returns this builder.
+         *
+         * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+         * (ie an oauth token). </p>
+         *
+         * @see #addHeader(String, LazyHeaderFactory)
+
+         */
+        public Builder addHeader(String key, String value) {
+            return addHeader(key, new StringHeaderFactory(value));
         }
 
-        public void addHeader(String key, LazyHeaderFactory factory) {
-            Set<LazyHeaderFactory> factories = lazyHeaders.get(key);
+        /**
+         * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
+         * key lazily on a background thread.
+         *
+         * <p> Headers may have multiple values whose order is defined by the order in which
+         * this method is called. </p>
+         *
+         * <p> This class does not prevent you from adding the same value to a given key multiple
+         * times </p>
+         */
+        public Builder addHeader(String key, LazyHeaderFactory factory) {
+            if (copyOnModify) {
+                copyOnModify = false;
+                headers = copyHeaders();
+            }
+
+            List<LazyHeaderFactory> factories = headers.get(key);
             if (factories == null) {
-                factories = new HashSet<LazyHeaderFactory>();
-                lazyHeaders.put(key, factories);
+                factories = new ArrayList<LazyHeaderFactory>();
+                headers.put(key, factories);
             }
             factories.add(factory);
+            return this;
         }
 
+        /**
+         * Returns a new immutable {@link LazyHeaders} object.
+         */
         public LazyHeaders build() {
-          return new LazyHeaders(eagerHeaders, lazyHeaders);
+          copyOnModify = true;
+          return new LazyHeaders(headers);
+        }
+
+        private Map<String, List<LazyHeaderFactory>> copyHeaders() {
+            Map<String, List<LazyHeaderFactory>> result =
+                  new HashMap<String, List<LazyHeaderFactory>>(headers.size());
+            for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
+                result.put(entry.getKey(), new ArrayList<LazyHeaderFactory>(entry.getValue()));
+            }
+            return result;
+        }
+    }
+
+    static final class StringHeaderFactory implements LazyHeaderFactory {
+
+        private final String value;
+
+        StringHeaderFactory(String value) {
+            this.value = value;
+        }
+
+        @Override
+        public String buildHeader() {
+            return value;
+        }
+
+        @Override
+        public String toString() {
+            return "StringHeaderFactory{"
+                + "value='" + value + '\''
+                + '}';
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof StringHeaderFactory) {
+                StringHeaderFactory other = (StringHeaderFactory) o;
+                return value.equals(other.value);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return value.hashCode();
         }
     }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 56eca774a..9519466cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -208,6 +208,9 @@ private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBuffere
         Bitmap.Config config = getConfig(is, decodeFormat);
         options.inSampleSize = sampleSize;
         options.inPreferredConfig = config;
+        if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
+            options.inDither = true;
+        }
         if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) && shouldUsePool(is)) {
             int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
             int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
index 217870e0d..02679c506 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
@@ -23,7 +23,7 @@
     /**
      * The format of the image data including whether or not the image may include transparent pixels.
      */
-    public static enum ImageType {
+    public enum ImageType {
         /** GIF type. */
         GIF(true),
         /** JPG type. */
@@ -171,18 +171,25 @@ public int getOrientation() throws IOException {
             segmentLength = streamReader.getUInt16() - 2;
 
             if (segmentType != EXIF_SEGMENT_TYPE) {
-                if (segmentLength != streamReader.skip(segmentLength)) {
+                long skipped = streamReader.skip(segmentLength);
+                if (skipped != segmentLength) {
                     if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Unable to skip enough data for type=" + segmentType);
+                        Log.d(TAG, "Unable to skip enough data"
+                            + ", type: " + segmentType
+                            + ", wanted to skip: " + segmentLength
+                            + ", but actually skipped: " + skipped);
                     }
                     return null;
                 }
             } else {
                 byte[] segmentData = new byte[segmentLength];
-
-                if (segmentLength != streamReader.read(segmentData)) {
+                int read = streamReader.read(segmentData);
+                if (read != segmentLength) {
                     if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Unable to read segment data for type=" + segmentType + " length=" + segmentLength);
+                        Log.d(TAG, "Unable to read segment data"
+                            + ", type: " + segmentType
+                            + ", length: " + segmentLength
+                            + ", actually read: " + read);
                     }
                     return null;
                 } else {
@@ -229,7 +236,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
             // 12 is max format code.
             if (formatCode < 1 || formatCode > 12) {
                 if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Got invalid format code = " + formatCode);
+                    Log.d(TAG, "Got invalid format code=" + formatCode);
                 }
                 continue;
             }
@@ -244,7 +251,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
             }
 
             if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode =" + formatCode
+                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
                         + " componentCount=" + componentCount);
             }
 
@@ -332,11 +339,38 @@ public short getUInt8() throws IOException {
         }
 
         public long skip(long total) throws IOException {
-            return is.skip(total);
+            if (total < 0) {
+                return 0;
+            }
+
+            long toSkip = total;
+            while (toSkip > 0) {
+                long skipped = is.skip(toSkip);
+                if (skipped > 0) {
+                    toSkip -= skipped;
+                } else {
+                    // Skip has no specific contract as to what happens when you reach the end of
+                    // the stream. To differentiate between temporarily not having more data and
+                    // having finished the stream, we read a single byte when we fail to skip any
+                    // amount of data.
+                    int testEofByte = is.read();
+                    if (testEofByte == -1) {
+                        break;
+                    } else {
+                        toSkip--;
+                    }
+                }
+            }
+            return total - toSkip;
         }
 
         public int read(byte[] buffer) throws IOException {
-            return is.read(buffer);
+            int toRead = buffer.length;
+            int read;
+            while (toRead > 0 && ((read = is.read(buffer, buffer.length - toRead, toRead)) != -1)) {
+                toRead -= read;
+            }
+            return buffer.length - toRead;
         }
 
         public int getByte() throws IOException {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 49d074988..14897350e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -17,7 +17,7 @@
  */
 public final class TransformationUtils {
     private static final String TAG = "TransformationUtils";
-    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
+    public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
 
     private TransformationUtils() {
         // Utility class.
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index f91270cd2..aaf01e50e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import com.bumptech.glide.util.Util;
+
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
@@ -10,7 +12,7 @@
  */
 class ActivityFragmentLifecycle implements Lifecycle {
     private final Set<LifecycleListener> lifecycleListeners =
-            Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>()));
+            Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
     private boolean isStarted;
     private boolean isDestroyed;
 
@@ -44,21 +46,21 @@ public void addListener(LifecycleListener listener) {
 
     void onStart() {
         isStarted = true;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
+        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
             lifecycleListener.onStart();
         }
     }
 
     void onStop() {
         isStarted = false;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
+        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
             lifecycleListener.onStop();
         }
     }
 
     void onDestroy() {
         isDestroyed = true;
-        for (LifecycleListener lifecycleListener : lifecycleListeners) {
+        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
             lifecycleListener.onDestroy();
         }
     }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 621579025..0ade50531 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.request.Request;
+import com.bumptech.glide.util.Util;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -64,7 +65,7 @@ public boolean isPaused() {
      */
     public void pauseRequests() {
         isPaused = true;
-        for (Request request : getSnapshot()) {
+        for (Request request : Util.getSnapshot(requests)) {
             if (request.isRunning()) {
                 request.pause();
                 pendingRequests.add(request);
@@ -77,7 +78,7 @@ public void pauseRequests() {
      */
     public void resumeRequests() {
         isPaused = false;
-        for (Request request : getSnapshot()) {
+        for (Request request : Util.getSnapshot(requests)) {
             if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
                 request.begin();
             }
@@ -89,7 +90,7 @@ public void resumeRequests() {
      * Cancels all requests and clears their resources.
      */
     public void clearRequests() {
-        for (Request request : getSnapshot()) {
+        for (Request request : Util.getSnapshot(requests)) {
             request.clear();
         }
         pendingRequests.clear();
@@ -99,7 +100,7 @@ public void clearRequests() {
      * Restarts failed requests and cancels and restarts in progress requests.
      */
     public void restartRequests() {
-        for (Request request : getSnapshot()) {
+        for (Request request : Util.getSnapshot(requests)) {
             if (!request.isComplete() && !request.isCancelled()) {
                 // Ensure the request will be restarted in onResume.
                 request.pause();
@@ -111,17 +112,4 @@ public void restartRequests() {
             }
         }
     }
-
-    // Avoids a ConcurrentModificationException when requests are started by another request completing. See #303.
-    private List<Request> getSnapshot() {
-        // toArray creates a new ArrayList internally and this way we can guarantee entries will not be
-        // null. See #322.
-        List<Request> result = new ArrayList<Request>(requests.size());
-        // We could also just call new ArrayList<Request>(requests) but that actually creates two new ArrayLists because
-        // that constructor in ArrayList calls toArray().
-        for (Request request : requests) {
-            result.add(request);
-        }
-        return result;
-    }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
index b92c547aa..604bd9699 100644
--- a/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java
@@ -493,14 +493,17 @@ public void onResourceReady(Resource<?> resource) {
      * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
      */
     private void onResourceReady(Resource<?> resource, R result) {
+        // We must call isFirstReadyResource before setting status.
+        boolean isFirstResource = isFirstReadyResource();
+        status = Status.COMPLETE;
+        this.resource = resource;
+
         if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
-                isFirstReadyResource())) {
-            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstReadyResource());
+                isFirstResource)) {
+            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);
             target.onResourceReady(result, animation);
         }
 
-        status = Status.COMPLETE;
-        this.resource = resource;
         notifyLoadSuccess();
 
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index e7b58a878..93657d11a 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -220,7 +220,9 @@ private synchronized R doGet(Long timeoutMillis) throws ExecutionException, Inte
      */
     @Override
     public void run() {
-        request.clear();
+        if (request != null) {
+            request.clear();
+        }
     }
 
     /**
diff --git a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
index 5bd3305f3..1d258489c 100644
--- a/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java
@@ -23,14 +23,15 @@
     private static final int DEFAULT_DURATION_MS = 300;
     private final ViewAnimationFactory<T> animationFactory;
     private final int duration;
-    private DrawableCrossFadeViewAnimation<T> animation;
+    private DrawableCrossFadeViewAnimation<T> firstResourceAnimation;
+    private DrawableCrossFadeViewAnimation<T> secondResourceAnimation;
 
     public DrawableCrossFadeFactory() {
         this(DEFAULT_DURATION_MS);
     }
 
     public DrawableCrossFadeFactory(int duration) {
-        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory()), duration);
+        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory(duration)), duration);
     }
 
     public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
@@ -50,22 +51,43 @@ public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
     public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
         if (isFromMemoryCache) {
             return NoAnimation.get();
+        } else if (isFirstResource) {
+            return getFirstResourceAnimation();
+        } else {
+            return getSecondResourceAnimation();
         }
+    }
 
-        if (animation == null) {
-            GlideAnimation<T> defaultAnimation = animationFactory.build(false, isFirstResource);
-            animation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
+    private GlideAnimation<T> getFirstResourceAnimation() {
+        if (firstResourceAnimation == null) {
+            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
+                true /*isFirstResource*/);
+            firstResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
         }
+        return firstResourceAnimation;
+    }
 
-        return animation;
+    private GlideAnimation<T> getSecondResourceAnimation() {
+        if (secondResourceAnimation == null) {
+            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
+                false /*isFirstResource*/);
+            secondResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
+        }
+        return secondResourceAnimation;
     }
 
     private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {
 
+        private final int duration;
+
+        DefaultAnimationFactory(int duration) {
+            this.duration = duration;
+        }
+
         @Override
         public Animation build() {
             AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-            animation.setDuration(DEFAULT_DURATION_MS / 2);
+            animation.setDuration(duration);
             return animation;
         }
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
new file mode 100644
index 000000000..605aa2bbb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -0,0 +1,74 @@
+package com.bumptech.glide.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Uses the content length as the basis for the return value of {@link #available()} and verifies
+ * that at least content length bytes are returned from the various read methods.
+ */
+public final class ContentLengthInputStream extends FilterInputStream {
+  private static final String TAG = "ContentLengthStream";
+  private static final int UNKNOWN = -1;
+
+  private final int contentLength;
+  private int readSoFar;
+
+  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
+  }
+
+  private static int parseContentLength(String contentLengthHeader) {
+    int result = UNKNOWN;
+    if (!TextUtils.isEmpty(contentLengthHeader)) {
+      try {
+        result = Integer.parseInt(contentLengthHeader);
+      } catch (NumberFormatException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
+        }
+      }
+    }
+    return result;
+  }
+
+  ContentLengthInputStream(InputStream in, int contentLength) {
+    super(in);
+    this.contentLength = contentLength;
+  }
+
+  @Override
+  public synchronized int available() throws IOException {
+    return Math.max(contentLength - readSoFar, in.available());
+ }
+
+  @Override
+  public synchronized int read() throws IOException {
+    return checkReadSoFarOrThrow(super.read());
+  }
+
+  @Override
+  public int read(byte[] buffer) throws IOException {
+    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
+  }
+
+  @Override
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
+  }
+
+  private int checkReadSoFarOrThrow(int read) throws IOException {
+    if (read >= 0) {
+      readSoFar += read;
+    } else if (contentLength - readSoFar > 0) {
+      throw new IOException("Failed to read all expected data"
+          + ", expected: " + contentLength
+          + ", but read: " + readSoFar);
+    }
+    return read;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index b2dff176b..5ea55ac20 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -8,6 +8,9 @@
 import com.bumptech.glide.request.target.Target;
 
 import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -157,9 +160,25 @@ public static boolean isOnBackgroundThread() {
     }
 
     /**
-     * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
+     * Returns a {@link java.util.Queue} of the given size using Glide's preferred implementation.
      */
     public static <T> Queue<T> createQueue(int size) {
         return new ArrayDeque<T>(size);
     }
+
+    /**
+     * Returns a copy of the given list that is safe to iterate over and perform actions that may
+     * modify the original list.
+     *
+     * <p> See #303 and #375. </p>
+     */
+    public static <T> List<T> getSnapshot(Collection<T> other) {
+        // toArray creates a new ArrayList internally and this way we can guarantee entries will not
+        // be null. See #322.
+        List<T> result = new ArrayList<T>(other.size());
+        for (T item : other) {
+            result.add(item);
+        }
+        return result;
+    }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 34dff7198..ff3e1460e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -67,6 +67,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         thumbnailRequest = Glide.with(this)
                 .from(Photo.class)
                 .diskCacheStrategy(DiskCacheStrategy.SOURCE)
+                .crossFade(R.anim.fade_in, 150)
                 .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
