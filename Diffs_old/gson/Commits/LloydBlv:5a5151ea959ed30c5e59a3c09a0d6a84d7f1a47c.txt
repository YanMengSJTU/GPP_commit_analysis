diff --git a/gson/src/main/java/com/google/gson/annotations/DataWrapper.java b/gson/src/main/java/com/google/gson/annotations/DataWrapper.java
new file mode 100644
index 000000000..83ab25ee9
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/DataWrapper.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.annotations;
+
+import java.lang.annotation.*;
+
+/**
+ * An annotation that indicates this member should be serialized to JSON with
+ * omitting the provided name value as its root json field name.
+ *
+ * <p>Here is an example of how this annotation is meant to be used:</p>
+ * <pre>
+ * public class MyClass {
+ *   &#64DataWrapper("name") String a;
+ *   &#64DataWrapper(value="name1", alternate={"name2", "name3"}) String b;
+ *   String c;
+ *
+ *   public MyClass(String a, String b, String c) {
+ *     this.a = a;
+ *     this.b = b;
+ *     this.c = c;
+ *   }
+ * }
+ * </pre>
+ *
+ * <p>The following shows the output that is generated when serializing an instance of the
+ * above example class:</p>
+ * <pre>
+ * MyClass target = new MyClass("v1", "v2", "v3");
+ * Gson gson = new Gson();
+ * String json = gson.toJson(target);
+ * System.out.println(json);
+ *
+ * ===== OUTPUT =====
+ * { "data": { "name":"v1","name1":"v2","c":"v3" } }
+ * </pre>
+ *
+ * <p>NOTE: The value you specify in this annotation must be a valid JSON field name.</p>
+ * While deserializing, all values specified in the annotation will be deserialized into the field.
+ * For example:
+ * <pre>
+ *   MyClass target = gson.fromJson(" "data": { 'name1':'v1' }", MyClass.class);
+ *   assertEquals("v1", target.b);
+ *   target = gson.fromJson("{'name2':'v2'}", MyClass.class);
+ *   assertEquals("v2", target.b);
+ *   target = gson.fromJson("{'name3':'v3'}", MyClass.class);
+ *   assertEquals("v3", target.b);
+ * </pre>
+ * Note that MyClass.b is now deserialized from either name1, name2 or name3.
+ *
+ * @see com.google.gson.FieldNamingPolicy
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD, ElementType.METHOD})
+public @interface DataWrapper {
+
+  /**
+   * @return the desired name of the field when it is serialized or deserialized
+   */
+  String value() default "data";
+  /**
+   * @return the alternative names of the field when it is deserialized
+   */
+  String[] alternate() default {};
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 777e7dee3..f014f1e5a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.annotations.DataWrapper;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.annotations.SerializedName;
 import com.google.gson.internal.$Gson$Types;
@@ -108,6 +109,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+
     TypeAdapter<?> mapped = null;
     if (annotation != null) {
       mapped = jsonAdapterFactory.getTypeAdapter(
@@ -117,7 +119,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     if (mapped == null) mapped = context.getAdapter(fieldType);
 
     final TypeAdapter<?> typeAdapter = mapped;
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize, field.isAnnotationPresent(DataWrapper.class)) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
@@ -183,11 +185,12 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     final String name;
     final boolean serialized;
     final boolean deserialized;
-
-    protected BoundField(String name, boolean serialized, boolean deserialized) {
+    final boolean isDataWrapper;
+    protected BoundField(String name, boolean serialized, boolean deserialized, final boolean isDataWrapper) {
       this.name = name;
       this.serialized = serialized;
       this.deserialized = deserialized;
+      this.isDataWrapper = isDataWrapper;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
@@ -213,13 +216,23 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
 
       try {
         in.beginObject();
+
         while (in.hasNext()) {
           String name = in.nextName();
           BoundField field = boundFields.get(name);
+
+          if (field != null && field.isDataWrapper) {
+            in.beginObject();
+            in.nextName();
+          }
           if (field == null || !field.deserialized) {
             in.skipValue();
           } else {
             field.read(in, instance);
+
+            if (field.isDataWrapper) {
+              in.endObject();
+            }
           }
         }
       } catch (IllegalStateException e) {
