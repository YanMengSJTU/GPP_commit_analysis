diff --git a/CHANGELOG.md b/CHANGELOG.md
index dcff3d863..75d3ec2dd 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,22 @@
 Change Log
 ==========
 
+## Version 2.8
+_2016-10-26_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.7...gson-parent-2.8.0)
+ * New: `TypeToken.getParameterized()` and `TypeToken.getArray()` make it easier to
+   register or look up a `TypeAdapter`.
+ * New: `@JsonAdapter(nullSafe=true)` to specify that a custom type adapter handles null.
+
+## Version 2.7
+_2016-06-14_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.6.2...gson-parent-2.7)
+ * Added support for JsonSerializer/JsonDeserializer in @JsonAdapter annotation
+ * Exposing Gson properties excluder(), fieldNamingStrategy(), serializeNulls(), htmlSafe()
+ * Added JsonObject.size() method
+ * Added JsonWriter.value(Boolean value) method
+ * Using ArrayDeque, ConcurrentHashMap, and other JDK 1.6 features
+ * Better error reporting
+ * Plenty of other bug fixes
+
 ## Version 2.6.2
 _2016-02-26_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.6.1...gson-parent-2.6.2)
  * Fixed an NPE bug with @JsonAdapter annotation
diff --git a/README.md b/README.md
index 302716080..6007ee1c5 100644
--- a/README.md
+++ b/README.md
@@ -30,6 +30,7 @@ Please use the [google-gson Google group](http://groups.google.com/group/google-
 
 ###*Gson-related Content Created by Third Parties*
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
+  * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
 
 ###*License*
 
diff --git a/UserGuide.md b/UserGuide.md
index 964bfe44a..91f9be6c3 100644
--- a/UserGuide.md
+++ b/UserGuide.md
@@ -62,7 +62,7 @@ Note: Delete the `disabled_` prefix to run these tests. We use this prefix to pr
 
 ## <a name="TOC-Gson-Users"></a>Gson Users
 
-Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details [here](https://sites.google.com/site/gson/gson-users).
+Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.
 
 ## <a name="TOC-Using-Gson"></a>Using Gson
 
@@ -79,7 +79,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.6.2</version>
+      <version>2.8.0</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>
@@ -307,7 +307,7 @@ You can also find source code for some commonly used classes such as JodaTime at
 Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
 Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:
 
-* Json Serialiers: Need to define custom serialization for an object
+* Json Serializers: Need to define custom serialization for an object
 * Json Deserializers: Needed to define custom deserialization for a type
 
 * Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
@@ -655,7 +655,7 @@ In addition Gson's object model and data binding, you can use Gson to read from
 
 ## <a name="TOC-Issues-in-Designing-Gson"></a>Issues in Designing Gson
 
-See the [Gson design document](https://sites.google.com/site/gson/gson-design-document "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
+See the [Gson design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
 
 ## <a name="TOC-Future-Enhancements-to-Gson"></a>Future Enhancements to Gson
 
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
index a1d8fe1ae..5db375b8b 100644
--- a/examples/android-proguard-example/proguard.cfg
+++ b/examples/android-proguard-example/proguard.cfg
@@ -13,4 +13,10 @@
 # Application classes that will be serialized/deserialized over Gson
 -keep class com.google.gson.examples.android.model.** { *; }
 
+# Prevent proguard from stripping interface information from TypeAdapterFactory,
+# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
+-keep class * implements com.google.gson.TypeAdapterFactory
+-keep class * implements com.google.gson.JsonSerializer
+-keep class * implements com.google.gson.JsonDeserializer
+
 ##---------------End: proguard configuration for Gson  ----------
diff --git a/extras/pom.xml b/extras/pom.xml
index 41e6c9c9b..1c5e76c39 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -40,9 +40,14 @@
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.3.1</version>
+      <version>2.7</version>
       <scope>compile</scope>
     </dependency>
+    <dependency>
+      <groupId>javax.annotation</groupId>
+      <artifactId>jsr250-api</artifactId>
+      <version>1.0</version>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -86,16 +91,16 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.2</version>
+        <version>3.5.1</version>
         <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
+          <source>1.6</source>
+          <target>1.6</target>
         </configuration>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>2.5</version>
+        <version>3.0.2</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -113,7 +118,7 @@
       <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
+         <version>3.0.1</version>
          <executions>
            <execution>
              <id>attach-sources</id>
@@ -127,7 +132,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.1</version>
+         <version>2.10.4</version>
          <executions>
            <execution>
              <id>attach-javadocs</id>
@@ -147,7 +152,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.9</version>
+         <version>2.10</version>
          <configuration>
            <downloadSources>true</downloadSources>
            <downloadJavadocs>true</downloadJavadocs>
diff --git a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
new file mode 100644
index 000000000..6d02b958c
--- /dev/null
+++ b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+public class PostConstructAdapterFactory implements TypeAdapterFactory {
+    // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+        for (Class<?> t = type.getRawType(); t != Object.class; t = t.getSuperclass()) {
+            for (Method m : t.getDeclaredMethods()) {
+                if (m.isAnnotationPresent(PostConstruct.class)) {
+                    m.setAccessible(true);
+                    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+                    return new PostConstructAdapter<T>(delegate, m);
+                }
+            }
+        }
+        return null;
+    }
+
+    final static class PostConstructAdapter<T> extends TypeAdapter<T> {
+        private final TypeAdapter<T> delegate;
+        private final Method method;
+
+        public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
+            this.delegate = delegate;
+            this.method = method;
+        }
+
+        @Override public T read(JsonReader in) throws IOException {
+            T result = delegate.read(in);
+            if (result != null) {
+                try {
+                    method.invoke(result);
+                } catch (IllegalAccessException e) {
+                    throw new AssertionError();
+                } catch (InvocationTargetException e) {
+                    if (e.getCause() instanceof RuntimeException) throw (RuntimeException) e.getCause();
+                    throw new RuntimeException(e.getCause());
+                }
+            }
+            return result;
+        }
+
+        @Override public void write(JsonWriter out, T value) throws IOException {
+            delegate.write(out, value);
+        }
+    }
+}
\ No newline at end of file
diff --git a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
index f9ee32b4a..bc0569cbd 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
@@ -97,7 +97,7 @@
  * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
  * name to the {@link #of} factory method. If you don't supply an explicit type
  * field name, {@code "type"} will be used. <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
  *       = RuntimeTypeAdapterFactory.of(Shape.class, "type");
  * }</pre>
  * Next register all of your subtypes. Every subtype must be explicitly
@@ -108,14 +108,14 @@
  *   shapeAdapter.registerSubtype(Circle.class, "Circle");
  *   shapeAdapter.registerSubtype(Diamond.class, "Diamond");
  * }</pre>
- * Finally, register the type adapter in your application's GSON builder:
+ * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapter(Shape.class, shapeAdapter)
+ *       .registerTypeAdapterFactory(shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
  *       .registerSubtype(Rectangle.class)
  *       .registerSubtype(Circle.class)
  *       .registerSubtype(Diamond.class);
diff --git a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
new file mode 100644
index 000000000..1c934b11e
--- /dev/null
+++ b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import junit.framework.TestCase;
+
+public class PostConstructAdapterFactoryTest extends TestCase {
+    public void test() throws Exception {
+        Gson gson = new GsonBuilder()
+                .registerTypeAdapterFactory(new PostConstructAdapterFactory())
+                .create();
+        gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
+        try {
+            gson.fromJson("{\"bread\": \"cheesey bread\", \"cheese\": \"swiss\"}", Sandwich.class);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("too cheesey", expected.getMessage());
+        }
+    }
+
+    static class Sandwich {
+        String bread;
+        String cheese;
+
+        @PostConstruct void validate() {
+            if (bread.equals("cheesey bread") && cheese != null) {
+                throw new IllegalArgumentException("too cheesey");
+            }
+        }
+    }
+}
diff --git a/gson/pom.xml b/gson/pom.xml
index 5aa2de52b..e3fd6a389 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.6.3-SNAPSHOT</version>
+    <version>2.8.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 81700e638..35b803054 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -24,7 +24,6 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
 
 import com.google.gson.internal.bind.util.ISO8601Utils;
 
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 9fbf44a5d..e97b16279 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -134,6 +134,7 @@
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
   private final boolean lenient;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
@@ -245,10 +246,11 @@ public Gson() {
     // type adapters for composite and user-defined types
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
-    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
+    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);
+    factories.add(jsonAdapterFactory);
     factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(new ReflectiveTypeAdapterFactory(
-        constructorConstructor, fieldNamingStrategy, excluder));
+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
 
     this.factories = Collections.unmodifiableList(factories);
   }
@@ -486,12 +488,13 @@ static void checkValidFloatingPoint(double value) {
    * @since 2.2
    */
   public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {
-    boolean skipPastFound = false;
-    // Skip past if and only if the specified factory is present in the factories.
-    // This is useful because the factories created through JsonAdapter annotations are not
-    // registered in this list.
-    if (!factories.contains(skipPast)) skipPastFound = true;
+    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via
+    // our @JsonAdapter annotation.
+    if (!factories.contains(skipPast)) {
+      skipPast = jsonAdapterFactory;
+    }
 
+    boolean skipPastFound = false;
     for (TypeAdapterFactory factory : factories) {
       if (!skipPastFound) {
         if (factory == skipPast) {
@@ -719,7 +722,7 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
   }
 
   /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
+   * Returns a new JSON reader configured for the settings on this Gson instance.
    */
   public JsonReader newJsonReader(Reader reader) {
     JsonReader jsonReader = new JsonReader(reader);
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 78c7a177a..621019189 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -132,6 +132,15 @@ private JsonElement createJsonElement(Object value) {
     return members.entrySet();
   }
 
+  /**
+   * Returns the number of key/value pairs in the object.
+   *
+   * @return the number of key/value pairs in the object.
+   */
+  public int size() {
+    return members.size();
+  }
+
   /**
    * Convenience method to check if a member with the specified name is present in this object.
    *
diff --git a/gson/src/main/java/com/google/gson/annotations/Expose.java b/gson/src/main/java/com/google/gson/annotations/Expose.java
index 1b9c70df0..b66dc4f27 100644
--- a/gson/src/main/java/com/google/gson/annotations/Expose.java
+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -57,6 +58,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Expose {
diff --git a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
index 2ee3e682d..a98b27a1a 100644
--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
+++ b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
@@ -94,4 +94,7 @@
   /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
   Class<?> value();
 
+  /** false, to be able to handle {@code null} values within the adapter, default value is true. */
+  boolean nullSafe() default true;
+
 }
diff --git a/gson/src/main/java/com/google/gson/annotations/SerializedName.java b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
index 363b95a35..9e8e4b8d4 100644
--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java
+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -76,6 +77,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.METHOD})
 public @interface SerializedName {
diff --git a/gson/src/main/java/com/google/gson/annotations/Since.java b/gson/src/main/java/com/google/gson/annotations/Since.java
index 541f154b6..c6b218252 100644
--- a/gson/src/main/java/com/google/gson/annotations/Since.java
+++ b/gson/src/main/java/com/google/gson/annotations/Since.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -50,6 +51,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Since {
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/gson/annotations/Until.java
index 4648b8a2a..676a4b959 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/gson/annotations/Until.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -54,6 +55,7 @@
  * @author Joel Leitch
  * @since 1.3
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Until {
diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java
index 74956d777..ac99910a9 100644
--- a/gson/src/main/java/com/google/gson/internal/Streams.java
+++ b/gson/src/main/java/com/google/gson/internal/Streams.java
@@ -72,7 +72,6 @@ public static void write(JsonElement element, JsonWriter writer) throws IOExcept
     TypeAdapters.JSON_ELEMENT.write(writer, element);
   }
 
-  @SuppressWarnings("resource")
   public static Writer writerForAppendable(Appendable appendable) {
     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
   }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index b52e15734..7cfb910a6 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -17,6 +17,8 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.Gson;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
@@ -30,7 +32,6 @@
  * @since 2.3
  */
 public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {
-
   private final ConstructorConstructor constructorConstructor;
 
   public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {
@@ -40,33 +41,42 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
   @SuppressWarnings("unchecked")
   @Override
   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {
-    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);
+    Class<? super T> rawType = targetType.getRawType();
+    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);
     if (annotation == null) {
       return null;
     }
     return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);
   }
 
-  @SuppressWarnings("unchecked") // Casts guarded by conditionals.
-  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
-      TypeToken<?> fieldType, JsonAdapter annotation) {
-    Class<?> value = annotation.value();
+  @SuppressWarnings({ "unchecked", "rawtypes" }) // Casts guarded by conditionals.
+  TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
+      TypeToken<?> type, JsonAdapter annotation) {
+    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();
+
     TypeAdapter<?> typeAdapter;
-    if (TypeAdapter.class.isAssignableFrom(value)) {
-      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;
-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();
-    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {
-      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;
-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))
-          .construct()
-          .create(gson, fieldType);
+    if (instance instanceof TypeAdapter) {
+      typeAdapter = (TypeAdapter<?>) instance;
+    } else if (instance instanceof TypeAdapterFactory) {
+      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);
+    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {
+      JsonSerializer<?> serializer = instance instanceof JsonSerializer
+          ? (JsonSerializer) instance
+          : null;
+      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer
+          ? (JsonDeserializer) instance
+          : null;
+      typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);
     } else {
       throw new IllegalArgumentException(
-          "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.");
+          "@JsonAdapter value must be TypeAdapter, TypeAdapterFactory, "
+              + "JsonSerializer or JsonDeserializer reference.");
     }
-    if (typeAdapter != null) {
+
+    if (typeAdapter != null && annotation.nullSafe()) {
       typeAdapter = typeAdapter.nullSafe();
     }
+
     return typeAdapter;
   }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
index 6a8362805..012123156 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
@@ -25,9 +25,7 @@
 import com.google.gson.stream.JsonToken;
 import java.io.IOException;
 import java.io.Reader;
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -47,35 +45,57 @@
   };
   private static final Object SENTINEL_CLOSED = new Object();
 
-  private final List<Object> stack = new ArrayList<Object>();
+  /*
+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+   */
+  private Object[] stack = new Object[32];
+  private int stackSize = 0;
+
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
 
   public JsonTreeReader(JsonElement element) {
     super(UNREADABLE_READER);
-    stack.add(element);
+    push(element);
   }
 
   @Override public void beginArray() throws IOException {
     expect(JsonToken.BEGIN_ARRAY);
     JsonArray array = (JsonArray) peekStack();
-    stack.add(array.iterator());
+    push(array.iterator());
+    pathIndices[stackSize - 1] = 0;
   }
 
   @Override public void endArray() throws IOException {
     expect(JsonToken.END_ARRAY);
     popStack(); // empty iterator
     popStack(); // array
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public void beginObject() throws IOException {
     expect(JsonToken.BEGIN_OBJECT);
     JsonObject object = (JsonObject) peekStack();
-    stack.add(object.entrySet().iterator());
+    push(object.entrySet().iterator());
   }
 
   @Override public void endObject() throws IOException {
     expect(JsonToken.END_OBJECT);
     popStack(); // empty iterator
     popStack(); // object
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public boolean hasNext() throws IOException {
@@ -84,19 +104,19 @@ public JsonTreeReader(JsonElement element) {
   }
 
   @Override public JsonToken peek() throws IOException {
-    if (stack.isEmpty()) {
+    if (stackSize == 0) {
       return JsonToken.END_DOCUMENT;
     }
 
     Object o = peekStack();
     if (o instanceof Iterator) {
-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;
       Iterator<?> iterator = (Iterator<?>) o;
       if (iterator.hasNext()) {
         if (isObject) {
           return JsonToken.NAME;
         } else {
-          stack.add(iterator.next());
+          push(iterator.next());
           return peek();
         }
       } else {
@@ -127,16 +147,19 @@ public JsonTreeReader(JsonElement element) {
   }
 
   private Object peekStack() {
-    return stack.get(stack.size() - 1);
+    return stack[stackSize - 1];
   }
 
   private Object popStack() {
-    return stack.remove(stack.size() - 1);
+    Object result = stack[--stackSize];
+    stack[stackSize] = null;
+    return result;
   }
 
   private void expect(JsonToken expected) throws IOException {
     if (peek() != expected) {
-      throw new IllegalStateException("Expected " + expected + " but was " + peek());
+      throw new IllegalStateException(
+          "Expected " + expected + " but was " + peek() + locationString());
     }
   }
 
@@ -144,72 +167,101 @@ private void expect(JsonToken expected) throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    return (String) entry.getKey();
+    String result = (String) entry.getKey();
+    pathNames[stackSize - 1] = result;
+    push(entry.getValue());
+    return result;
   }
 
   @Override public String nextString() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
-      throw new IllegalStateException("Expected " + JsonToken.STRING + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.STRING + " but was " + token + locationString());
+    }
+    String result = ((JsonPrimitive) popStack()).getAsString();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
-    return ((JsonPrimitive) popStack()).getAsString();
+    return result;
   }
 
   @Override public boolean nextBoolean() throws IOException {
     expect(JsonToken.BOOLEAN);
-    return ((JsonPrimitive) popStack()).getAsBoolean();
+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
+    return result;
   }
 
   @Override public void nextNull() throws IOException {
     expect(JsonToken.NULL);
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public double nextDouble() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     double result = ((JsonPrimitive) peekStack()).getAsDouble();
     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
       throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
     }
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public long nextLong() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     long result = ((JsonPrimitive) peekStack()).getAsLong();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public int nextInt() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     int result = ((JsonPrimitive) peekStack()).getAsInt();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public void close() throws IOException {
-    stack.clear();
-    stack.add(SENTINEL_CLOSED);
+    stack = new Object[] { SENTINEL_CLOSED };
+    stackSize = 1;
   }
 
   @Override public void skipValue() throws IOException {
     if (peek() == JsonToken.NAME) {
       nextName();
+      pathNames[stackSize - 2] = "null";
     } else {
       popStack();
+      pathNames[stackSize - 1] = "null";
     }
+    pathIndices[stackSize - 1]++;
   }
 
   @Override public String toString() {
@@ -220,7 +272,45 @@ public void promoteNameToValue() throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    stack.add(new JsonPrimitive((String)entry.getKey()));
+    push(entry.getValue());
+    push(new JsonPrimitive((String) entry.getKey()));
+  }
+
+  private void push(Object newTop) {
+    if (stackSize == stack.length) {
+      Object[] newStack = new Object[stackSize * 2];
+      int[] newPathIndices = new int[stackSize * 2];
+      String[] newPathNames = new String[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
+      stack = newStack;
+      pathIndices = newPathIndices;
+      pathNames = newPathNames;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  @Override public String getPath() {
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0; i < stackSize; i++) {
+      if (stack[i] instanceof JsonArray) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('[').append(pathIndices[i]).append(']');
+        }
+      } else if (stack[i] instanceof JsonObject) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+        }
+      }
+    }
+    return result.toString();
+  }
+
+  private String locationString() {
+    return " at path " + getPath();
   }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index b47aaac41..34e97664e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -41,8 +41,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
-
 /**
  * Type adapter that reflects over the fields and methods of a class.
  */
@@ -50,12 +48,15 @@
   private final ConstructorConstructor constructorConstructor;
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {
+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
     this.constructorConstructor = constructorConstructor;
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.excluder = excluder;
+    this.jsonAdapterFactory = jsonAdapterFactory;
   }
 
   public boolean excludeField(Field f, boolean serialize) {
@@ -104,14 +105,23 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+    TypeAdapter<?> mapped = null;
+    if (annotation != null) {
+      mapped = jsonAdapterFactory.getTypeAdapter(
+          constructorConstructor, context, fieldType, annotation);
+    }
+    final boolean jsonAdapterPresent = mapped != null;
+    if (mapped == null) mapped = context.getAdapter(fieldType);
+
+    final TypeAdapter<?> typeAdapter = mapped;
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
-        TypeAdapter t =
-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());
+        TypeAdapter t = jsonAdapterPresent ? typeAdapter
+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
@@ -129,15 +139,6 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     };
   }
 
-  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {
-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
-    if (annotation != null) {
-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);
-      if (adapter != null) return adapter;
-    }
-    return gson.getAdapter(fieldType);
-  }
-
   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
     if (raw.isInterface()) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index 7e52c27d2..2bf37ad0a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -15,14 +15,15 @@
  */
 package com.google.gson.internal.bind;
 
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
 
 final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
   private final Gson context;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 23ab8a134..31beb5d6d 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -368,6 +368,7 @@ public Number read(JsonReader in) throws IOException {
         in.nextNull();
         return null;
       case NUMBER:
+      case STRING:
         return new LazilyParsedNumber(in.nextString());
       default:
         throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
@@ -805,7 +806,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
           constantToName.put(constant, name);
         }
       } catch (NoSuchFieldException e) {
-        throw new AssertionError("Missing field in " + classOfT.getName(), e);
+        throw new AssertionError(e);
       }
     }
     @Override public T read(JsonReader in) throws IOException {
diff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
index e16e8e6dc..3fb8af2bc 100644
--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java
+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
@@ -302,4 +302,19 @@ private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
   public static <T> TypeToken<T> get(Class<T> type) {
     return new TypeToken<T>(type);
   }
+
+  /**
+   * Gets type literal for the parameterized type represented by applying {@code typeArguments} to
+   * {@code rawType}.
+   */
+  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {
+    return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
+  }
+
+  /**
+   * Gets type literal for the array type whose elements are all instances of {@code componentType}.
+   */
+  public static TypeToken<?> getArray(Type componentType) {
+    return new TypeToken<Object>($Gson$Types.arrayOf(componentType));
+  }
 }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 7a5e9cbb6..9c55c4367 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -347,8 +347,7 @@ public void beginArray() throws IOException {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
     }
   }
 
@@ -366,8 +365,7 @@ public void endArray() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_ARRAY but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
     }
   }
 
@@ -384,8 +382,7 @@ public void beginObject() throws IOException {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
     }
   }
 
@@ -404,8 +401,7 @@ public void endObject() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_OBJECT but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
     }
   }
 
@@ -790,8 +786,7 @@ public String nextName() throws IOException {
     } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
       result = nextQuotedValue('"');
     } else {
-      throw new IllegalStateException("Expected a name but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a name but was " + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathNames[stackSize - 1] = result;
@@ -827,8 +822,7 @@ public String nextString() throws IOException {
       result = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else {
-      throw new IllegalStateException("Expected a string but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a string but was " + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathIndices[stackSize - 1]++;
@@ -856,8 +850,7 @@ public boolean nextBoolean() throws IOException {
       pathIndices[stackSize - 1]++;
       return false;
     }
-    throw new IllegalStateException("Expected a boolean but was " + peek()
-        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    throw new IllegalStateException("Expected a boolean but was " + peek() + locationString());
   }
 
   /**
@@ -876,8 +869,7 @@ public void nextNull() throws IOException {
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
     } else {
-      throw new IllegalStateException("Expected null but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected null but was " + peek() + locationString());
     }
   }
 
@@ -910,15 +902,14 @@ public double nextDouble() throws IOException {
     } else if (p == PEEKED_UNQUOTED) {
       peekedString = nextUnquotedValue();
     } else if (p != PEEKED_BUFFERED) {
-      throw new IllegalStateException("Expected a double but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a double but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new MalformedJsonException("JSON forbids NaN and infinities: " + result
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new MalformedJsonException(
+          "JSON forbids NaN and infinities: " + result + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -966,16 +957,14 @@ public long nextLong() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected a long but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a long but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new NumberFormatException("Expected a long but was " + peekedString
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new NumberFormatException("Expected a long but was " + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -1172,8 +1161,7 @@ public int nextInt() throws IOException {
     if (p == PEEKED_LONG) {
       result = (int) peekedLong;
       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new NumberFormatException("Expected an int but was " + peekedLong
-            + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+        throw new NumberFormatException("Expected an int but was " + peekedLong + locationString());
       }
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
@@ -1198,16 +1186,14 @@ public int nextInt() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected an int but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected an int but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new NumberFormatException("Expected an int but was " + peekedString
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new NumberFormatException("Expected an int but was " + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -1315,14 +1301,6 @@ private boolean fillBuffer(int minimum) throws IOException {
     return false;
   }
 
-  int getLineNumber() {
-    return lineNumber + 1;
-  }
-
-  int getColumnNumber() {
-    return pos - lineStart + 1;
-  }
-
   /**
    * Returns the next character in the stream that is neither whitespace nor a
    * part of a comment. When this returns, the returned character is always at
@@ -1412,8 +1390,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
       }
     }
     if (throwOnEof) {
-      throw new EOFException("End of input"
-          + " at line " + getLineNumber() + " column " + getColumnNumber());
+      throw new EOFException("End of input" + locationString());
     } else {
       return -1;
     }
@@ -1465,8 +1442,13 @@ private boolean skipTo(String toFind) throws IOException {
   }
 
   @Override public String toString() {
-    return getClass().getSimpleName()
-        + " at line " + getLineNumber() + " column " + getColumnNumber();
+    return getClass().getSimpleName() + locationString();
+  }
+
+  private String locationString() {
+    int line = lineNumber + 1;
+    int column = pos - lineStart + 1;
+    return " at line " + line + " column " + column + " path " + getPath();
   }
 
   /**
@@ -1561,8 +1543,11 @@ private char readEscapeCharacter() throws IOException {
     case '\'':
     case '"':
     case '\\':
+    case '/':	
+    	return escaped;
     default:
-      return escaped;
+    	// throw error when none of the above cases are matched
+    	throw syntaxError("Invalid escape sequence");
     }
   }
 
@@ -1571,8 +1556,7 @@ private char readEscapeCharacter() throws IOException {
    * with this reader's content.
    */
   private IOException syntaxError(String message) throws IOException {
-    throw new MalformedJsonException(message
-        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    throw new MalformedJsonException(message + locationString());
   }
 
   /**
@@ -1615,9 +1599,8 @@ private void consumeNonExecutePrefix() throws IOException {
         } else if (p == PEEKED_UNQUOTED_NAME) {
           reader.peeked = PEEKED_UNQUOTED;
         } else {
-          throw new IllegalStateException("Expected a name but was " + reader.peek() + " "
-              + " at line " + reader.getLineNumber() + " column " + reader.getColumnNumber()
-              + " path " + reader.getPath());
+          throw new IllegalStateException(
+              "Expected a name but was " + reader.peek() + reader.locationString());
         }
       }
     };
diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java
index 9423a24d2..32d9d3608 100644
--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java
+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java
@@ -158,6 +158,20 @@ public void testEqualsNonEmptyObject() {
     assertFalse(b.equals(a));
   }
 
+  public void testSize() {
+    JsonObject o = new JsonObject();
+    assertEquals(0, o.size());
+
+    o.add("Hello", new JsonPrimitive(1));
+    assertEquals(1, o.size());
+
+    o.add("Hi", new JsonPrimitive(1));
+    assertEquals(2, o.size());
+
+    o.remove("Hello");
+    assertEquals(1, o.size());
+  }
+
   public void testDeepCopy() {
     JsonObject original = new JsonObject();
     JsonArray firstEntry = new JsonArray();
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
index 4c745ec2a..706fe60f8 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
@@ -16,6 +16,10 @@
 
 package com.google.gson.functional;
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.TypeAdapter;
@@ -24,7 +28,7 @@
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
+
 import junit.framework.TestCase;
 
 /**
@@ -63,7 +67,6 @@ public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {
         @Override public void write(JsonWriter out, Part part) throws IOException {
           throw new AssertionError();
         }
-
         @Override public Part read(JsonReader in) throws IOException {
           throw new AssertionError();
         }
@@ -220,4 +223,84 @@ private GadgetWithOptionalPart(Part part) {
       this.part = part;
     }
   }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithOptionalPart(new Part("foo")));
+    assertEquals("{\"part\":\"PartJsonFieldAnnotationAdapter\"}", json);
+    GadgetWithOptionalPart gadget = gson.fromJson("{'part':'foo'}", GadgetWithOptionalPart.class);
+    assertEquals("PartJsonFieldAnnotationAdapter", gadget.part.name);
+  }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithPrimitivePart(42));
+    assertEquals("{\"part\":\"42\"}", json);
+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);
+    assertEquals(42, gadget.part);
+  }
+
+  private static final class GadgetWithPrimitivePart {
+    @JsonAdapter(LongToStringTypeAdapterFactory.class)
+    final long part;
+
+    private GadgetWithPrimitivePart(long part) {
+      this.part = part;
+    }
+  }
+
+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {
+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {
+      @Override public void write(JsonWriter out, Long value) throws IOException {
+        out.value(value.toString());
+      }
+      @Override public Long read(JsonReader in) throws IOException {
+        return in.nextLong();
+      }
+    };
+    @SuppressWarnings("unchecked")
+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      Class<?> cls = type.getRawType();
+      if (Long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      } else if (long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      }
+      throw new IllegalStateException("Non-long field of type " + type
+          + " annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)");
+    }
+  }
+
+  public void testFieldAnnotationWorksForParameterizedType() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Gizmo2(Arrays.asList(new Part("Part"))));
+    assertEquals("{\"part\":\"GizmoPartTypeAdapterFactory\"}", json);
+    Gizmo2 computer = gson.fromJson("{'part':'Part'}", Gizmo2.class);
+    assertEquals("GizmoPartTypeAdapterFactory", computer.part.get(0).name);
+  }
+
+  private static final class Gizmo2 {
+    @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)
+    List<Part> part;
+    Gizmo2(List<Part> part) {
+      this.part = part;
+    }
+  }
+
+  private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      return new TypeAdapter<T>() {
+        @Override public void write(JsonWriter out, T value) throws IOException {
+          out.value("GizmoPartTypeAdapterFactory");
+        }
+        @SuppressWarnings("unchecked")
+        @Override public T read(JsonReader in) throws IOException {
+          in.nextString();
+          return (T) Arrays.asList(new Part("GizmoPartTypeAdapterFactory"));
+        }
+      };
+    }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
new file mode 100644
index 000000000..8ab4e128a
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.functional;
+
+import java.lang.reflect.Type;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.annotations.JsonAdapter;
+
+import junit.framework.TestCase;
+
+/**
+ * Functional tests for the {@link JsonAdapter} annotation on fields where the value is of
+ * type {@link JsonSerializer} or {@link JsonDeserializer}.
+ */
+public final class JsonAdapterSerializerDeserializerTest extends TestCase {
+
+  public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Computer(new User("Inderjeet Singh"), null, new User("Jesse Wilson")));
+    assertEquals("{\"user1\":\"UserSerializer\",\"user3\":\"UserSerializerDeserializer\"}", json);
+    Computer computer = gson.fromJson("{'user2':'Jesse Wilson','user3':'Jake Wharton'}", Computer.class);
+    assertEquals("UserSerializer", computer.user2.name);
+    assertEquals("UserSerializerDeserializer", computer.user3.name);
+  }
+
+  private static final class Computer {
+    @JsonAdapter(UserSerializer.class) final User user1;
+    @JsonAdapter(UserDeserializer.class) final User user2;
+    @JsonAdapter(UserSerializerDeserializer.class) final User user3;
+    Computer(User user1, User user2, User user3) {
+      this.user1 = user1;
+      this.user2 = user2;
+      this.user3 = user3;
+    }
+  }
+
+  private static final class User {
+    public final String name;
+    private User(String name) {
+      this.name = name;
+    }
+  }
+
+  private static final class UserSerializer implements JsonSerializer<User> {
+    @Override
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializer");
+    }
+  }
+
+  private static final class UserDeserializer implements JsonDeserializer<User> {
+    @Override
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User("UserSerializer");
+    }
+  }
+
+  private static final class UserSerializerDeserializer implements JsonSerializer<User>, JsonDeserializer<User> {
+    @Override
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializerDeserializer");
+    }
+    @Override
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User("UserSerializerDeserializer");
+    }
+  }
+
+  public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Computer2(new User2("Inderjeet Singh")));
+    assertEquals("{\"user\":\"UserSerializerDeserializer2\"}", json);
+    Computer2 computer = gson.fromJson("{'user':'Inderjeet Singh'}", Computer2.class);
+    assertEquals("UserSerializerDeserializer2", computer.user.name);
+  }
+
+  private static final class Computer2 {
+    final User2 user;
+    Computer2(User2 user) {
+      this.user = user;
+    }
+  }
+
+  @JsonAdapter(UserSerializerDeserializer2.class)
+  private static final class User2 {
+    public final String name;
+    private User2(String name) {
+      this.name = name;
+    }
+  }
+
+  private static final class UserSerializerDeserializer2 implements JsonSerializer<User2>, JsonDeserializer<User2> {
+    @Override
+    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializerDeserializer2");
+    }
+    @Override
+    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User2("UserSerializerDeserializer2");
+    }
+  }
+
+  public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {
+    Container c = new Container("Foo", 10);
+    Gson gson = new Gson();
+    String json = gson.toJson(c);
+    assertTrue(json.contains("\"a\":\"BaseStringAdapter\""));
+    assertTrue(json.contains("\"b\":\"BaseIntegerAdapter\""));
+  }
+
+  private static final class Container {
+    @JsonAdapter(BaseStringAdapter.class) Base<String> a;
+    @JsonAdapter(BaseIntegerAdapter.class) Base<Integer> b;
+    Container(String a, int b) {
+      this.a = new Base<String>(a);
+      this.b = new Base<Integer>(b);
+    }
+  }
+
+  private static final class Base<T> {
+    @SuppressWarnings("unused")
+    T value;
+    Base(T value) {
+      this.value = value;
+    }
+  }
+
+  private static final class BaseStringAdapter implements JsonSerializer<Base<String>> {
+    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("BaseStringAdapter");
+    }
+  }
+
+  private static final class BaseIntegerAdapter implements JsonSerializer<Base<Integer>> {
+    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("BaseIntegerAdapter");
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index bb28ed1ec..9da983a3b 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -158,6 +158,11 @@ public void testNumberDeserialization() {
     assertEquals(1L, actual.longValue());
   }
 
+  public void testNumberAsStringDeserialization() {
+    Number value = gson.fromJson("\"18\"", Number.class);
+    assertEquals(18, value.intValue());
+  }
+
   public void testPrimitiveDoubleAutoboxedSerialization() {
     assertEquals("-122.08234335", gson.toJson(-122.08234335));
     assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));
diff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index 7959fc860..1284e2c9b 100644
--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -45,7 +45,7 @@
    * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}
    * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.
    */
-  public void testSubclassesAutomaticallySerialzed() throws Exception {
+  public void testSubclassesAutomaticallySerialized() throws Exception {
     Shape shape = new Circle(25);
     String json = gson.toJson(shape);
     shape = gson.fromJson(json, Shape.class);
diff --git a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
index 7dda9d47d..40572716b 100644
--- a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.RandomAccess;
 import java.util.Set;
 import junit.framework.TestCase;
@@ -79,4 +80,26 @@ public void testIsAssignableFromWithNestedWildcards() throws Exception {
     // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false
     assertFalse(TypeToken.get(b).isAssignableFrom(a));
   }
+
+  public void testArrayFactory() {
+    TypeToken<?> expectedStringArray = new TypeToken<String[]>() {};
+    assertEquals(expectedStringArray, TypeToken.getArray(String.class));
+
+    TypeToken<?> expectedListOfStringArray = new TypeToken<List<String>[]>() {};
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertEquals(expectedListOfStringArray, TypeToken.getArray(listOfString));
+  }
+
+  public void testParameterizedFactory() {
+    TypeToken<?> expectedListOfString = new TypeToken<List<String>>() {};
+    assertEquals(expectedListOfString, TypeToken.getParameterized(List.class, String.class));
+
+    TypeToken<?> expectedMapOfStringToString = new TypeToken<Map<String, String>>() {};
+    assertEquals(expectedMapOfStringToString, TypeToken.getParameterized(Map.class, String.class, String.class));
+
+    TypeToken<?> expectedListOfListOfListOfString = new TypeToken<List<List<List<String>>>>() {};
+    Type listOfString = TypeToken.getParameterized(List.class, String.class).getType();
+    Type listOfListOfString = TypeToken.getParameterized(List.class, listOfString).getType();
+    assertEquals(expectedListOfListOfListOfString, TypeToken.getParameterized(List.class, listOfListOfString));
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
index 50661664c..c0b269172 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
@@ -16,15 +16,35 @@
 
 package com.google.gson.stream;
 
+import com.google.gson.JsonElement;
+import com.google.gson.internal.Streams;
+import com.google.gson.internal.bind.JsonTreeReader;
 import java.io.IOException;
 import java.io.StringReader;
-import junit.framework.TestCase;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-@SuppressWarnings("resource")
-public class JsonReaderPathTest extends TestCase {
-  public void testPath() throws IOException {
-    JsonReader reader = new JsonReader(
-        new StringReader("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}"));
+import static junit.framework.Assert.assertEquals;
+import static org.junit.Assume.assumeTrue;
+
+@RunWith(Parameterized.class)
+public class JsonReaderPathTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { Factory.STRING_READER },
+        new Object[] { Factory.OBJECT_READER }
+    );
+  }
+
+  @Parameterized.Parameter
+  public Factory factory;
+
+  @Test public void path() throws IOException {
+    JsonReader reader = factory.create("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}");
     assertEquals("$", reader.getPath());
     reader.beginObject();
     assertEquals("$.", reader.getPath());
@@ -62,8 +82,8 @@ public void testPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testObjectPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+  @Test public void objectPath() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1,\"b\":2}");
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -102,8 +122,8 @@ public void testObjectPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testArrayPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2]"));
+  @Test public void arrayPath() throws IOException {
+    JsonReader reader = factory.create("[1,2]");
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -132,8 +152,10 @@ public void testArrayPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[][]"));
+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {
+    assumeTrue(factory == Factory.STRING_READER);
+
+    JsonReader reader = factory.create("[][]");
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -143,24 +165,25 @@ public void testMultipleTopLevelValuesInOneDocument() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testSkipArrayElements() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2,3]"));
+  @Test public void skipArrayElements() throws IOException {
+    JsonReader reader = factory.create("[1,2,3]");
     reader.beginArray();
     reader.skipValue();
     reader.skipValue();
     assertEquals("$[2]", reader.getPath());
   }
 
-  public void testSkipObjectNames() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1}"));
+  @Test public void skipObjectNames() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1}");
     reader.beginObject();
     reader.skipValue();
     assertEquals("$.null", reader.getPath());
   }
 
-  public void testSkipObjectValues() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+  @Test public void skipObjectValues() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1,\"b\":2}");
     reader.beginObject();
+    assertEquals("$.", reader.getPath());
     reader.nextName();
     reader.skipValue();
     assertEquals("$.null", reader.getPath());
@@ -168,15 +191,15 @@ public void testSkipObjectValues() throws IOException {
     assertEquals("$.b", reader.getPath());
   }
 
-  public void testSkipNestedStructures() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[1,2,3],4]"));
+  @Test public void skipNestedStructures() throws IOException {
+    JsonReader reader = factory.create("[[1,2,3],4]");
     reader.beginArray();
     reader.skipValue();
     assertEquals("$[1]", reader.getPath());
   }
 
-  public void testArrayOfObjects() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[{},{},{}]"));
+  @Test public void arrayOfObjects() throws IOException {
+    JsonReader reader = factory.create("[{},{},{}]");
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginObject();
@@ -195,8 +218,8 @@ public void testArrayOfObjects() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testArrayOfArrays() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[],[],[]]"));
+  @Test public void arrayOfArrays() throws IOException {
+    JsonReader reader = factory.create("[[],[],[]]");
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginArray();
@@ -214,4 +237,20 @@ public void testArrayOfArrays() throws IOException {
     reader.endArray();
     assertEquals("$", reader.getPath());
   }
+
+  enum Factory {
+    STRING_READER {
+      @Override public JsonReader create(String data) {
+        return new JsonReader(new StringReader(data));
+      }
+    },
+    OBJECT_READER {
+      @Override public JsonReader create(String data) {
+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));
+        return new JsonTreeReader(element);
+      }
+    };
+
+    abstract JsonReader create(String data);
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
index 48279dacb..d6b7a838f 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
@@ -174,6 +174,21 @@ public void testHelloWorld() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
+  public void testInvalidJsonInput() throws IOException {
+    String json = "{\n"
+        + "   \"h\\ello\": true,\n"
+        + "   \"foo\": [\"world\"]\n"
+        + "}";
+
+    JsonReader reader = new JsonReader(reader(json));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+  
   public void testNulls() {
     try {
       new JsonReader(null);
diff --git a/pom.xml b/pom.xml
index 6240af44e..9e5c435fc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.6.3-SNAPSHOT</version>
+  <version>2.8.1-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>
@@ -51,7 +51,7 @@
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>3.8.2</version>
+        <version>4.12</version>
         <scope>test</scope>
       </dependency>
     </dependencies>
@@ -77,9 +77,6 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-jar-plugin</artifactId>
-          <configuration>
-            <useDefaultManifestFile>true</useDefaultManifestFile>
-          </configuration>
         </plugin>
       </plugins>
     </pluginManagement>
diff --git a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
index ff44779f1..4fba080d6 100644
--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
@@ -262,8 +262,8 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
           String jsonFieldName =
               getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());
 
-          if (jsonObject.has(jsonFieldName)) {
-            JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          if (jsonElement != null && !jsonElement.isJsonNull()) {
             // Do not reuse jsonFieldName here, it might have a custom value
             Object fieldValue;
             if (fieldDescriptor.getType() == ENUM_TYPE) {
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
index f90899e1c..69b877e60 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
@@ -66,4 +66,11 @@ public void testDeserializeProto() {
     assertEquals("foo", proto.getMsg());
     assertEquals(3, proto.getCount());
   }
+
+  public void testDeserializeWithExplicitNullValue() {
+    SimpleProto proto = gson.fromJson("{msg:'foo',count:null}", SimpleProto.class);
+    assertEquals("foo", proto.getMsg());
+    assertEquals(0, proto.getCount());
+  }
+
 }
