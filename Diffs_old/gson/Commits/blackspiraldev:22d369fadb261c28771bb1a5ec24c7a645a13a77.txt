diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
deleted file mode 100644
index 81700e638..000000000
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.lang.reflect.Type;
-import java.sql.Timestamp;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import com.google.gson.internal.bind.util.ISO8601Utils;
-
-/**
- * This type adapter supports three subclasses of date: Date, Timestamp, and
- * java.sql.Date.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
-
-  // TODO: migrate to streaming adapter
-
-  private final DateFormat enUsFormat;
-  private final DateFormat localFormat;
-
-  DefaultDateTypeAdapter() {
-    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
-  }
-
-  DefaultDateTypeAdapter(String datePattern) {
-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
-  }
-
-  DefaultDateTypeAdapter(int style) {
-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
-  }
-
-  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
-  }
-
-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {
-    this.enUsFormat = enUsFormat;
-    this.localFormat = localFormat;
-  }
-
-  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
-  // See issue 162
-  @Override
-  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
-    synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(src);
-      return new JsonPrimitive(dateFormatAsString);
-    }
-  }
-
-  @Override
-  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
-      throws JsonParseException {
-    if (!(json instanceof JsonPrimitive)) {
-      throw new JsonParseException("The date should be a string value");
-    }
-    Date date = deserializeToDate(json);
-    if (typeOfT == Date.class) {
-      return date;
-    } else if (typeOfT == Timestamp.class) {
-      return new Timestamp(date.getTime());
-    } else if (typeOfT == java.sql.Date.class) {
-      return new java.sql.Date(date.getTime());
-    } else {
-      throw new IllegalArgumentException(getClass() + " cannot deserialize to " + typeOfT);
-    }
-  }
-
-  private Date deserializeToDate(JsonElement json) {
-    synchronized (localFormat) {
-      try {
-      	return localFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
-      try {
-        return enUsFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
-      try {
-        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));
-      } catch (ParseException e) {
-        throw new JsonSyntaxException(json.getAsString(), e);
-      }
-    }
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(DefaultDateTypeAdapter.class.getSimpleName());
-    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');
-    return sb.toString();
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
deleted file mode 100644
index 561af1985..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.bind.util.ISO8601Utils;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.util.Date;
-import java.util.Locale;
-
-/**
- * Adapter for Date. Although this class appears stateless, it is not.
- * DateFormat captures its time zone and locale when it is created, which gives
- * this class state. DateFormat isn't thread safe either, so this class has
- * to synchronize its read and write methods.
- */
-public final class DateTypeAdapter extends TypeAdapter<Date> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;
-    }
-  };
-
-  private final DateFormat enUsFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);
-  private final DateFormat localFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);
-
-  @Override public Date read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
-    return deserializeToDate(in.nextString());
-  }
-
-  private synchronized Date deserializeToDate(String json) {
-    try {
-      return localFormat.parse(json);
-    } catch (ParseException ignored) {
-    }
-    try {
-      return enUsFormat.parse(json);
-    } catch (ParseException ignored) {
-    }
-    try {
-    	return ISO8601Utils.parse(json, new ParsePosition(0));
-    } catch (ParseException e) {
-      throw new JsonSyntaxException(json, e);
-    }
-  }
-
-  @Override public synchronized void write(JsonWriter out, Date value) throws IOException {
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-    String dateFormatAsString = enUsFormat.format(value);
-    out.value(dateFormatAsString);
-  }
-  
-  
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
deleted file mode 100644
index 5f9f0395d..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * This writer creates a JsonElement.
- */
-public final class JsonTreeWriter extends JsonWriter {
-  private static final Writer UNWRITABLE_WRITER = new Writer() {
-    @Override public void write(char[] buffer, int offset, int counter) {
-      throw new AssertionError();
-    }
-    @Override public void flush() throws IOException {
-      throw new AssertionError();
-    }
-    @Override public void close() throws IOException {
-      throw new AssertionError();
-    }
-  };
-  /** Added to the top of the stack when this writer is closed to cause following ops to fail. */
-  private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive("closed");
-
-  /** The JsonElements and JsonArrays under modification, outermost to innermost. */
-  private final List<JsonElement> stack = new ArrayList<JsonElement>();
-
-  /** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */
-  private String pendingName;
-
-  /** the JSON element constructed by this writer. */
-  private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;
-
-  public JsonTreeWriter() {
-    super(UNWRITABLE_WRITER);
-  }
-
-  /**
-   * Returns the top level object produced by this writer.
-   */
-  public JsonElement get() {
-    if (!stack.isEmpty()) {
-      throw new IllegalStateException("Expected one JSON element but was " + stack);
-    }
-    return product;
-  }
-
-  private JsonElement peek() {
-    return stack.get(stack.size() - 1);
-  }
-
-  private void put(JsonElement value) {
-    if (pendingName != null) {
-      if (!value.isJsonNull() || getSerializeNulls()) {
-        JsonObject object = (JsonObject) peek();
-        object.add(pendingName, value);
-      }
-      pendingName = null;
-    } else if (stack.isEmpty()) {
-      product = value;
-    } else {
-      JsonElement element = peek();
-      if (element instanceof JsonArray) {
-        ((JsonArray) element).add(value);
-      } else {
-        throw new IllegalStateException();
-      }
-    }
-  }
-
-  @Override public JsonWriter beginArray() throws IOException {
-    JsonArray array = new JsonArray();
-    put(array);
-    stack.add(array);
-    return this;
-  }
-
-  @Override public JsonWriter endArray() throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonArray) {
-      stack.remove(stack.size() - 1);
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter beginObject() throws IOException {
-    JsonObject object = new JsonObject();
-    put(object);
-    stack.add(object);
-    return this;
-  }
-
-  @Override public JsonWriter endObject() throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonObject) {
-      stack.remove(stack.size() - 1);
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter name(String name) throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonObject) {
-      pendingName = name;
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter value(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter nullValue() throws IOException {
-    put(JsonNull.INSTANCE);
-    return this;
-  }
-
-  @Override public JsonWriter value(boolean value) throws IOException {
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(double value) throws IOException {
-    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {
-      throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
-    }
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(long value) throws IOException {
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(Number value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-
-    if (!isLenient()) {
-      double d = value.doubleValue();
-      if (Double.isNaN(d) || Double.isInfinite(d)) {
-        throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
-      }
-    }
-
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public void close() throws IOException {
-    if (!stack.isEmpty()) {
-      throw new IOException("Incomplete document");
-    }
-    stack.add(SENTINEL_CLOSED);
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
deleted file mode 100644
index 5ec244f29..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-
-/**
- * Adapter for java.sql.Date. Although this class appears stateless, it is not.
- * DateFormat captures its time zone and locale when it is created, which gives
- * this class state. DateFormat isn't thread safe either, so this class has
- * to synchronize its read and write methods.
- */
-public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      return typeToken.getRawType() == java.sql.Date.class
-          ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;
-    }
-  };
-
-  private final DateFormat format = new SimpleDateFormat("MMM d, yyyy");
-
-  @Override
-  public synchronized java.sql.Date read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
-    try {
-      final long utilDate = format.parse(in.nextString()).getTime();
-      return new java.sql.Date(utilDate);
-    } catch (ParseException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-
-  @Override
-  public synchronized void write(JsonWriter out, java.sql.Date value) throws IOException {
-    out.value(value == null ? null : format.format(value));
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
deleted file mode 100644
index 55d4b2f69..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.sql.Time;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-/**
- * Adapter for Time. Although this class appears stateless, it is not.
- * DateFormat captures its time zone and locale when it is created, which gives
- * this class state. DateFormat isn't thread safe either, so this class has
- * to synchronize its read and write methods.
- */
-public final class TimeTypeAdapter extends TypeAdapter<Time> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;
-    }
-  };
-
-  private final DateFormat format = new SimpleDateFormat("hh:mm:ss a");
-
-  @Override public synchronized Time read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
-    try {
-      Date date = format.parse(in.nextString());
-      return new Time(date.getTime());
-    } catch (ParseException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-
-  @Override public synchronized void write(JsonWriter out, Time value) throws IOException {
-    out.value(value == null ? null : format.format(value));
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
deleted file mode 100644
index 7e52c27d2..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal.bind;
-
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-
-final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
-  private final Gson context;
-  private final TypeAdapter<T> delegate;
-  private final Type type;
-
-  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
-    this.context = context;
-    this.delegate = delegate;
-    this.type = type;
-  }
-
-  @Override
-  public T read(JsonReader in) throws IOException {
-    return delegate.read(in);
-  }
-
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  @Override
-  public void write(JsonWriter out, T value) throws IOException {
-    // Order of preference for choosing type adapters
-    // First preference: a type adapter registered for the runtime type
-    // Second preference: a type adapter registered for the declared type
-    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
-    // Fourth preference: reflective type adapter for the declared type
-
-    TypeAdapter chosen = delegate;
-    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
-    if (runtimeType != type) {
-      TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
-      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for the runtime type, so we will use that
-        chosen = runtimeTypeAdapter;
-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for Base class, so we prefer it over the
-        // reflective type adapter for the runtime type
-        chosen = delegate;
-      } else {
-        // Use the type adapter for runtime type
-        chosen = runtimeTypeAdapter;
-      }
-    }
-    chosen.write(out, value);
-  }
-
-  /**
-   * Finds a compatible runtime type if it is more specific
-   */
-  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
-    if (value != null
-        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
-      type = value.getClass();
-    }
-    return type;
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
deleted file mode 100644
index 0d6d013c1..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ /dev/null
@@ -1,928 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import java.io.IOException;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Calendar;
-import java.util.Currency;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicIntegerArray;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.LazilyParsedNumber;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-
-/**
- * Type adapters for basic types.
- */
-public final class TypeAdapters {
-  private TypeAdapters() {
-    throw new UnsupportedOperationException();
-  }
-
-  @SuppressWarnings("rawtypes")
-  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {
-    @Override
-    public void write(JsonWriter out, Class value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-      } else {
-        throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
-            + value.getName() + ". Forgot to register a type adapter?");
-      }
-    }
-    @Override
-    public Class read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else {
-        throw new UnsupportedOperationException(
-            "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
-      }
-    }
-  };
-  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
-
-  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {
-    @Override public BitSet read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-
-      BitSet bitset = new BitSet();
-      in.beginArray();
-      int i = 0;
-      JsonToken tokenType = in.peek();
-      while (tokenType != JsonToken.END_ARRAY) {
-        boolean set;
-        switch (tokenType) {
-        case NUMBER:
-          set = in.nextInt() != 0;
-          break;
-        case BOOLEAN:
-          set = in.nextBoolean();
-          break;
-        case STRING:
-          String stringValue = in.nextString();
-          try {
-            set = Integer.parseInt(stringValue) != 0;
-          } catch (NumberFormatException e) {
-            throw new JsonSyntaxException(
-                "Error: Expecting: bitset number value (1, 0), Found: " + stringValue);
-          }
-          break;
-        default:
-          throw new JsonSyntaxException("Invalid bitset value type: " + tokenType);
-        }
-        if (set) {
-          bitset.set(i);
-        }
-        ++i;
-        tokenType = in.peek();
-      }
-      in.endArray();
-      return bitset;
-    }
-
-    @Override public void write(JsonWriter out, BitSet src) throws IOException {
-      if (src == null) {
-        out.nullValue();
-        return;
-      }
-
-      out.beginArray();
-      for (int i = 0; i < src.length(); i++) {
-        int value = (src.get(i)) ? 1 : 0;
-        out.value(value);
-      }
-      out.endArray();
-    }
-  };
-
-  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
-
-  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
-    @Override
-    public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else if (in.peek() == JsonToken.STRING) {
-        // support strings for compatibility with GSON 1.7
-        return Boolean.parseBoolean(in.nextString());
-      }
-      return in.nextBoolean();
-    }
-    @Override
-    public void write(JsonWriter out, Boolean value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
-      out.value(value);
-    }
-  };
-
-  /**
-   * Writes a boolean as a string. Useful for map keys, where booleans aren't
-   * otherwise permitted.
-   */
-  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {
-    @Override public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return Boolean.valueOf(in.nextString());
-    }
-
-    @Override public void write(JsonWriter out, Boolean value) throws IOException {
-      out.value(value == null ? "null" : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory BOOLEAN_FACTORY
-      = newFactory(boolean.class, Boolean.class, BOOLEAN);
-
-  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        int intValue = in.nextInt();
-        return (byte) intValue;
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory BYTE_FACTORY
-      = newFactory(byte.class, Byte.class, BYTE);
-
-  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return (short) in.nextInt();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory SHORT_FACTORY
-      = newFactory(short.class, Short.class, SHORT);
-
-  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return in.nextInt();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-  public static final TypeAdapterFactory INTEGER_FACTORY
-      = newFactory(int.class, Integer.class, INTEGER);
-
-  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {
-    @Override public AtomicInteger read(JsonReader in) throws IOException {
-      try {
-        return new AtomicInteger(in.nextInt());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {
-      out.value(value.get());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =
-      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);
-
-  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {
-    @Override public AtomicBoolean read(JsonReader in) throws IOException {
-      return new AtomicBoolean(in.nextBoolean());
-    }
-    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {
-      out.value(value.get());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =
-      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);
-
-  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {
-    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {
-        List<Integer> list = new ArrayList<Integer>();
-        in.beginArray();
-        while (in.hasNext()) {
-          try {
-            int integer = in.nextInt();
-            list.add(integer);
-          } catch (NumberFormatException e) {
-            throw new JsonSyntaxException(e);
-          }
-        }
-        in.endArray();
-        int length = list.size();
-        AtomicIntegerArray array = new AtomicIntegerArray(length);
-        for (int i = 0; i < length; ++i) {
-          array.set(i, list.get(i));
-        }
-        return array;
-    }
-    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {
-      out.beginArray();
-      for (int i = 0, length = value.length(); i < length; i++) {
-        out.value(value.get(i));
-      }
-      out.endArray();
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =
-      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);
-
-  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return in.nextLong();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return (float) in.nextDouble();
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return in.nextDouble();
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      JsonToken jsonToken = in.peek();
-      switch (jsonToken) {
-      case NULL:
-        in.nextNull();
-        return null;
-      case NUMBER:
-        return new LazilyParsedNumber(in.nextString());
-      default:
-        throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);
-
-  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {
-    @Override
-    public Character read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String str = in.nextString();
-      if (str.length() != 1) {
-        throw new JsonSyntaxException("Expecting character, got: " + str);
-      }
-      return str.charAt(0);
-    }
-    @Override
-    public void write(JsonWriter out, Character value) throws IOException {
-      out.value(value == null ? null : String.valueOf(value));
-    }
-  };
-
-  public static final TypeAdapterFactory CHARACTER_FACTORY
-      = newFactory(char.class, Character.class, CHARACTER);
-
-  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {
-    @Override
-    public String read(JsonReader in) throws IOException {
-      JsonToken peek = in.peek();
-      if (peek == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      /* coerce booleans to strings for backwards compatibility */
-      if (peek == JsonToken.BOOLEAN) {
-        return Boolean.toString(in.nextBoolean());
-      }
-      return in.nextString();
-    }
-    @Override
-    public void write(JsonWriter out, String value) throws IOException {
-      out.value(value);
-    }
-  };
-  
-  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {
-    @Override public BigDecimal read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return new BigDecimal(in.nextString());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-
-    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {
-      out.value(value);
-    }
-  };
-  
-  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {
-    @Override public BigInteger read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return new BigInteger(in.nextString());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-
-    @Override public void write(JsonWriter out, BigInteger value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);
-
-  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {
-    @Override
-    public StringBuilder read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return new StringBuilder(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, StringBuilder value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =
-    newFactory(StringBuilder.class, STRING_BUILDER);
-
-  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {
-    @Override
-    public StringBuffer read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return new StringBuffer(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, StringBuffer value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =
-    newFactory(StringBuffer.class, STRING_BUFFER);
-
-  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {
-    @Override
-    public URL read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String nextString = in.nextString();
-      return "null".equals(nextString) ? null : new URL(nextString);
-    }
-    @Override
-    public void write(JsonWriter out, URL value) throws IOException {
-      out.value(value == null ? null : value.toExternalForm());
-    }
-  };
-
-  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);
-
-  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {
-    @Override
-    public URI read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        String nextString = in.nextString();
-        return "null".equals(nextString) ? null : new URI(nextString);
-      } catch (URISyntaxException e) {
-        throw new JsonIOException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, URI value) throws IOException {
-      out.value(value == null ? null : value.toASCIIString());
-    }
-  };
-
-  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);
-
-  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {
-    @Override
-    public InetAddress read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      // regrettably, this should have included both the host name and the host address
-      return InetAddress.getByName(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, InetAddress value) throws IOException {
-      out.value(value == null ? null : value.getHostAddress());
-    }
-  };
-
-  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =
-    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);
-
-  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {
-    @Override
-    public UUID read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return java.util.UUID.fromString(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, UUID value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);
-
-  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {
-    @Override
-    public Currency read(JsonReader in) throws IOException {
-      return Currency.getInstance(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, Currency value) throws IOException {
-      out.value(value.getCurrencyCode());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);
-
-  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      if (typeToken.getRawType() != Timestamp.class) {
-        return null;
-      }
-
-      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);
-      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {
-        @Override public Timestamp read(JsonReader in) throws IOException {
-          Date date = dateTypeAdapter.read(in);
-          return date != null ? new Timestamp(date.getTime()) : null;
-        }
-
-        @Override public void write(JsonWriter out, Timestamp value) throws IOException {
-          dateTypeAdapter.write(out, value);
-        }
-      };
-    }
-  };
-
-  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {
-    private static final String YEAR = "year";
-    private static final String MONTH = "month";
-    private static final String DAY_OF_MONTH = "dayOfMonth";
-    private static final String HOUR_OF_DAY = "hourOfDay";
-    private static final String MINUTE = "minute";
-    private static final String SECOND = "second";
-
-    @Override
-    public Calendar read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return  null;
-      }
-      in.beginObject();
-      int year = 0;
-      int month = 0;
-      int dayOfMonth = 0;
-      int hourOfDay = 0;
-      int minute = 0;
-      int second = 0;
-      while (in.peek() != JsonToken.END_OBJECT) {
-        String name = in.nextName();
-        int value = in.nextInt();
-        if (YEAR.equals(name)) {
-          year = value;
-        } else if (MONTH.equals(name)) {
-          month = value;
-        } else if (DAY_OF_MONTH.equals(name)) {
-          dayOfMonth = value;
-        } else if (HOUR_OF_DAY.equals(name)) {
-          hourOfDay = value;
-        } else if (MINUTE.equals(name)) {
-          minute = value;
-        } else if (SECOND.equals(name)) {
-          second = value;
-        }
-      }
-      in.endObject();
-      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);
-    }
-
-    @Override
-    public void write(JsonWriter out, Calendar value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
-      out.beginObject();
-      out.name(YEAR);
-      out.value(value.get(Calendar.YEAR));
-      out.name(MONTH);
-      out.value(value.get(Calendar.MONTH));
-      out.name(DAY_OF_MONTH);
-      out.value(value.get(Calendar.DAY_OF_MONTH));
-      out.name(HOUR_OF_DAY);
-      out.value(value.get(Calendar.HOUR_OF_DAY));
-      out.name(MINUTE);
-      out.value(value.get(Calendar.MINUTE));
-      out.name(SECOND);
-      out.value(value.get(Calendar.SECOND));
-      out.endObject();
-    }
-  };
-
-  public static final TypeAdapterFactory CALENDAR_FACTORY =
-    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);
-
-  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {
-    @Override
-    public Locale read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String locale = in.nextString();
-      StringTokenizer tokenizer = new StringTokenizer(locale, "_");
-      String language = null;
-      String country = null;
-      String variant = null;
-      if (tokenizer.hasMoreElements()) {
-        language = tokenizer.nextToken();
-      }
-      if (tokenizer.hasMoreElements()) {
-        country = tokenizer.nextToken();
-      }
-      if (tokenizer.hasMoreElements()) {
-        variant = tokenizer.nextToken();
-      }
-      if (country == null && variant == null) {
-        return new Locale(language);
-      } else if (variant == null) {
-        return new Locale(language, country);
-      } else {
-        return new Locale(language, country, variant);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Locale value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);
-
-  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {
-    @Override public JsonElement read(JsonReader in) throws IOException {
-      switch (in.peek()) {
-      case STRING:
-        return new JsonPrimitive(in.nextString());
-      case NUMBER:
-        String number = in.nextString();
-        return new JsonPrimitive(new LazilyParsedNumber(number));
-      case BOOLEAN:
-        return new JsonPrimitive(in.nextBoolean());
-      case NULL:
-        in.nextNull();
-        return JsonNull.INSTANCE;
-      case BEGIN_ARRAY:
-        JsonArray array = new JsonArray();
-        in.beginArray();
-        while (in.hasNext()) {
-          array.add(read(in));
-        }
-        in.endArray();
-        return array;
-      case BEGIN_OBJECT:
-        JsonObject object = new JsonObject();
-        in.beginObject();
-        while (in.hasNext()) {
-          object.add(in.nextName(), read(in));
-        }
-        in.endObject();
-        return object;
-      case END_DOCUMENT:
-      case NAME:
-      case END_OBJECT:
-      case END_ARRAY:
-      default:
-        throw new IllegalArgumentException();
-      }
-    }
-
-    @Override public void write(JsonWriter out, JsonElement value) throws IOException {
-      if (value == null || value.isJsonNull()) {
-        out.nullValue();
-      } else if (value.isJsonPrimitive()) {
-        JsonPrimitive primitive = value.getAsJsonPrimitive();
-        if (primitive.isNumber()) {
-          out.value(primitive.getAsNumber());
-        } else if (primitive.isBoolean()) {
-          out.value(primitive.getAsBoolean());
-        } else {
-          out.value(primitive.getAsString());
-        }
-
-      } else if (value.isJsonArray()) {
-        out.beginArray();
-        for (JsonElement e : value.getAsJsonArray()) {
-          write(out, e);
-        }
-        out.endArray();
-
-      } else if (value.isJsonObject()) {
-        out.beginObject();
-        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
-          out.name(e.getKey());
-          write(out, e.getValue());
-        }
-        out.endObject();
-
-      } else {
-        throw new IllegalArgumentException("Couldn't write " + value.getClass());
-      }
-    }
-  };
-
-  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY
-      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
-
-  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
-    private final Map<String, T> nameToConstant = new HashMap<String, T>();
-    private final Map<T, String> constantToName = new HashMap<T, String>();
-
-    public EnumTypeAdapter(Class<T> classOfT) {
-      try {
-        for (T constant : classOfT.getEnumConstants()) {
-          String name = constant.name();
-          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
-          if (annotation != null) {
-            name = annotation.value();
-            for (String alternate : annotation.alternate()) {
-              nameToConstant.put(alternate, constant);
-            }
-          }
-          nameToConstant.put(name, constant);
-          constantToName.put(constant, name);
-        }
-      } catch (NoSuchFieldException e) {
-        throw new AssertionError("Missing field in " + classOfT.getName(), e);
-      }
-    }
-    @Override public T read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return nameToConstant.get(in.nextString());
-    }
-
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      out.value(value == null ? null : constantToName.get(value));
-    }
-  }
-
-  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      Class<? super T> rawType = typeToken.getRawType();
-      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {
-        return null;
-      }
-      if (!rawType.isEnum()) {
-        rawType = rawType.getSuperclass(); // handle anonymous subclasses
-      }
-      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);
-    }
-  };
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        Class<? super T> rawType = typeToken.getRawType();
-        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + boxed.getName()
-            + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,
-      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        Class<? super T> rawType = typeToken.getRawType();
-        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + base.getName()
-            + "+" + sub.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  /**
-   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
-   * that the deserialized type matches the type requested.
-   */
-  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(
-      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked")
-      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
-        final Class<? super T2> requestedType = typeToken.getRawType();
-        if (!clazz.isAssignableFrom(requestedType)) {
-          return null;
-        }
-        return (TypeAdapter<T2>) new TypeAdapter<T1>() {
-          @Override public void write(JsonWriter out, T1 value) throws IOException {
-            typeAdapter.write(out, value);
-          }
-
-          @Override public T1 read(JsonReader in) throws IOException {
-            T1 result = typeAdapter.read(in);
-            if (result != null && !requestedType.isInstance(result)) {
-              throw new JsonSyntaxException("Expected a " + requestedType.getName()
-                  + " but was " + result.getClass().getName());
-            }
-            return result;
-          }
-        };
-      }
-      @Override public String toString() {
-        return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
deleted file mode 100644
index c931b0906..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
+++ /dev/null
@@ -1,352 +0,0 @@
-package com.google.gson.internal.bind.util;
-
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.util.*;
-
-/**
- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
- * highly suitable if you (un)serialize lots of date objects.
- * 
- * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
- * 
- * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
- */
-//Date parsing code from Jackson databind ISO8601Utils.java
-// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
-public class ISO8601Utils
-{
-    /**
-     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
-     * 
-     * @since 2.7
-     */
-    private static final String UTC_ID = "UTC";
-    /**
-     * The UTC timezone, prefetched to avoid more lookups.
-     * 
-     * @since 2.7
-     */
-    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
-
-    /*
-    /**********************************************************
-    /* Formatting
-    /**********************************************************
-     */
-
-    /**
-     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
-     * 
-     * @param date the date to format
-     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'
-     */
-    public static String format(Date date) {
-        return format(date, false, TIMEZONE_UTC);
-    }
-
-    /**
-     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)
-     * 
-     * @param date the date to format
-     * @param millis true to include millis precision otherwise false
-     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'
-     */
-    public static String format(Date date, boolean millis) {
-        return format(date, millis, TIMEZONE_UTC);
-    }
-
-    /**
-     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-     * 
-     * @param date the date to format
-     * @param millis true to include millis precision otherwise false
-     * @param tz timezone to use for the formatting (UTC will produce 'Z')
-     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-     */
-    public static String format(Date date, boolean millis, TimeZone tz) {
-        Calendar calendar = new GregorianCalendar(tz, Locale.US);
-        calendar.setTime(date);
-
-        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
-        int capacity = "yyyy-MM-ddThh:mm:ss".length();
-        capacity += millis ? ".sss".length() : 0;
-        capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length();
-        StringBuilder formatted = new StringBuilder(capacity);
-
-        padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
-        formatted.append('-');
-        padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
-        formatted.append('-');
-        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
-        formatted.append('T');
-        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
-        formatted.append(':');
-        padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
-        formatted.append(':');
-        padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
-        if (millis) {
-            formatted.append('.');
-            padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
-        }
-
-        int offset = tz.getOffset(calendar.getTimeInMillis());
-        if (offset != 0) {
-            int hours = Math.abs((offset / (60 * 1000)) / 60);
-            int minutes = Math.abs((offset / (60 * 1000)) % 60);
-            formatted.append(offset < 0 ? '-' : '+');
-            padInt(formatted, hours, "hh".length());
-            formatted.append(':');
-            padInt(formatted, minutes, "mm".length());
-        } else {
-            formatted.append('Z');
-        }
-
-        return formatted.toString();
-    }
-
-    /*
-    /**********************************************************
-    /* Parsing
-    /**********************************************************
-     */
-
-    /**
-     * Parse a date from ISO-8601 formatted string. It expects a format
-     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
-     * 
-     * @param date ISO string to parse in the appropriate format.
-     * @param pos The position to start parsing from, updated to where parsing stopped.
-     * @return the parsed date
-     * @throws ParseException if the date is not in the appropriate format
-     */
-    public static Date parse(String date, ParsePosition pos) throws ParseException {
-        Exception fail = null;
-        try {
-            int offset = pos.getIndex();
-
-            // extract year
-            int year = parseInt(date, offset, offset += 4);
-            if (checkOffset(date, offset, '-')) {
-                offset += 1;
-            }
-
-            // extract month
-            int month = parseInt(date, offset, offset += 2);
-            if (checkOffset(date, offset, '-')) {
-                offset += 1;
-            }
-
-            // extract day
-            int day = parseInt(date, offset, offset += 2);
-            // default time value
-            int hour = 0;
-            int minutes = 0;
-            int seconds = 0;
-            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
-
-            // if the value has no time component (and no time zone), we are done
-            boolean hasT = checkOffset(date, offset, 'T');
-            
-            if (!hasT && (date.length() <= offset)) {
-                Calendar calendar = new GregorianCalendar(year, month - 1, day);
-
-                pos.setIndex(offset);
-                return calendar.getTime();
-            }
-
-            if (hasT) {
-
-                // extract hours, minutes, seconds and milliseconds
-                hour = parseInt(date, offset += 1, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-
-                minutes = parseInt(date, offset, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-                // second and milliseconds can be optional
-                if (date.length() > offset) {
-                    char c = date.charAt(offset);
-                    if (c != 'Z' && c != '+' && c != '-') {
-                        seconds = parseInt(date, offset, offset += 2);
-                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
-                        // milliseconds can be optional in the format
-                        if (checkOffset(date, offset, '.')) {
-                            offset += 1;
-                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
-                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
-                            int fraction = parseInt(date, offset, parseEndOffset);
-                            // compensate for "missing" digits
-                            switch (parseEndOffset - offset) { // number of digits parsed
-                            case 2:
-                                milliseconds = fraction * 10;
-                                break;
-                            case 1:
-                                milliseconds = fraction * 100;
-                                break;
-                            default:
-                                milliseconds = fraction;
-                            }
-                            offset = endOffset;
-                        }
-                    }
-                }
-            }
-
-            // extract timezone
-            if (date.length() <= offset) {
-                throw new IllegalArgumentException("No time zone indicator");
-            }
-
-            TimeZone timezone = null;
-            char timezoneIndicator = date.charAt(offset);
-
-            if (timezoneIndicator == 'Z') {
-                timezone = TIMEZONE_UTC;
-                offset += 1;
-            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
-                String timezoneOffset = date.substring(offset);
-
-                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
-                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00";
-
-                offset += timezoneOffset.length();
-                // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
-                if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
-                    timezone = TIMEZONE_UTC;
-                } else {
-                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
-                    //    not sure why, but that's the way it looks. Further, Javadocs for
-                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
-                    //    custom timezones... odd.
-                    String timezoneId = "GMT" + timezoneOffset;
-//                    String timezoneId = "UTC" + timezoneOffset;
-
-                    timezone = TimeZone.getTimeZone(timezoneId);
-
-                    String act = timezone.getID();
-                    if (!act.equals(timezoneId)) {
-                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
-                         *    one without. If so, don't sweat.
-                         *   Yes, very inefficient. Hopefully not hit often.
-                         *   If it becomes a perf problem, add 'loose' comparison instead.
-                         */
-                        String cleaned = act.replace(":", "");
-                        if (!cleaned.equals(timezoneId)) {
-                            throw new IndexOutOfBoundsException("Mismatching time zone indicator: "+timezoneId+" given, resolves to "
-                                    +timezone.getID());
-                        }
-                    }
-                }
-            } else {
-                throw new IndexOutOfBoundsException("Invalid time zone indicator '" + timezoneIndicator+"'");
-            }
-
-            Calendar calendar = new GregorianCalendar(timezone);
-            calendar.setLenient(false);
-            calendar.set(Calendar.YEAR, year);
-            calendar.set(Calendar.MONTH, month - 1);
-            calendar.set(Calendar.DAY_OF_MONTH, day);
-            calendar.set(Calendar.HOUR_OF_DAY, hour);
-            calendar.set(Calendar.MINUTE, minutes);
-            calendar.set(Calendar.SECOND, seconds);
-            calendar.set(Calendar.MILLISECOND, milliseconds);
-
-            pos.setIndex(offset);
-            return calendar.getTime();
-            // If we get a ParseException it'll already have the right message/offset.
-            // Other exception types can convert here.
-        } catch (IndexOutOfBoundsException e) {
-            fail = e;
-        } catch (NumberFormatException e) {
-            fail = e;
-        } catch (IllegalArgumentException e) {
-            fail = e;
-        }
-        String input = (date == null) ? null : ('"' + date + "'");
-        String msg = fail.getMessage();
-        if (msg == null || msg.isEmpty()) {
-            msg = "("+fail.getClass().getName()+")";
-        }
-        ParseException ex = new ParseException("Failed to parse date [" + input + "]: " + msg, pos.getIndex());
-        ex.initCause(fail);
-        throw ex;
-    }
-
-    /**
-     * Check if the expected character exist at the given offset in the value.
-     * 
-     * @param value the string to check at the specified offset
-     * @param offset the offset to look for the expected character
-     * @param expected the expected character
-     * @return true if the expected character exist at the given offset
-     */
-    private static boolean checkOffset(String value, int offset, char expected) {
-        return (offset < value.length()) && (value.charAt(offset) == expected);
-    }
-
-    /**
-     * Parse an integer located between 2 given offsets in a string
-     * 
-     * @param value the string to parse
-     * @param beginIndex the start index for the integer in the string
-     * @param endIndex the end index for the integer in the string
-     * @return the int
-     * @throws NumberFormatException if the value is not a number
-     */
-    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
-        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
-            throw new NumberFormatException(value);
-        }
-        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
-        int i = beginIndex;
-        int result = 0;
-        int digit;
-        if (i < endIndex) {
-            digit = Character.digit(value.charAt(i++), 10);
-            if (digit < 0) {
-                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-            }
-            result = -digit;
-        }
-        while (i < endIndex) {
-            digit = Character.digit(value.charAt(i++), 10);
-            if (digit < 0) {
-                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-            }
-            result *= 10;
-            result -= digit;
-        }
-        return -result;
-    }
-
-    /**
-     * Zero pad a number to a specified length
-     * 
-     * @param buffer buffer to use for padding
-     * @param value the integer value to pad if necessary.
-     * @param length the length of the string we should zero pad
-     */
-    private static void padInt(StringBuilder buffer, int value, int length) {
-        String strValue = Integer.toString(value);
-        for (int i = length - strValue.length(); i > 0; i--) {
-            buffer.append('0');
-        }
-        buffer.append(strValue);
-    }
-
-    /**
-     * Returns the index of the first character in the string that is not a digit, starting at offset.
-     */
-    private static int indexOfNonDigit(String string, int offset) {
-        for (int i = offset; i < string.length(); i++) {
-            char c = string.charAt(i);
-            if (c < '0' || c > '9') return i;
-        }
-        return string.length();
-    }
-
-}
diff --git a/gson/src/main/java/com/google/gson/package-info.java b/gson/src/main/java/com/google/gson/package-info.java
deleted file mode 100644
index 428e280cf..000000000
--- a/gson/src/main/java/com/google/gson/package-info.java
+++ /dev/null
@@ -1,11 +0,0 @@
-/**
- * This package provides the {@link com.google.gson.Gson} class to convert Json to Java and
- * vice-versa.
- *
- * <p>The primary class to use is {@link com.google.gson.Gson} which can be constructed with
- * {@code new Gson()} (using default settings) or by using {@link com.google.gson.GsonBuilder}
- * (to configure various options such as using versioning and so on).</p>
- *
- * @author Inderjeet Singh, Joel Leitch
- */
-package com.google.gson;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
deleted file mode 100644
index 9bf2d22a6..000000000
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ /dev/null
@@ -1,644 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.stream;
-
-import java.io.Closeable;
-import java.io.Flushable;
-import java.io.IOException;
-import java.io.Writer;
-
-import static com.google.gson.stream.JsonScope.DANGLING_NAME;
-import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;
-import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;
-import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;
-import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;
-import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;
-import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;
-
-/**
- * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
- * encoded value to a stream, one token at a time. The stream includes both
- * literal values (strings, numbers, booleans and nulls) as well as the begin
- * and end delimiters of objects and arrays.
- *
- * <h3>Encoding JSON</h3>
- * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
- * document must contain one top-level array or object. Call methods on the
- * writer as you walk the structure's contents, nesting arrays and objects as
- * necessary:
- * <ul>
- *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.
- *       Write each of the array's elements with the appropriate {@link #value}
- *       methods or by nesting other arrays and objects. Finally close the array
- *       using {@link #endArray()}.
- *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.
- *       Write each of the object's properties by alternating calls to
- *       {@link #name} with the property's value. Write property values with the
- *       appropriate {@link #value} method or by nesting other objects or arrays.
- *       Finally close the object using {@link #endObject()}.
- * </ul>
- *
- * <h3>Example</h3>
- * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
- * [
- *   {
- *     "id": 912345678901,
- *     "text": "How do I stream JSON in Java?",
- *     "geo": null,
- *     "user": {
- *       "name": "json_newb",
- *       "followers_count": 41
- *      }
- *   },
- *   {
- *     "id": 912345678902,
- *     "text": "@json_newb just use JsonWriter!",
- *     "geo": [50.454722, -104.606667],
- *     "user": {
- *       "name": "jesse",
- *       "followers_count": 2
- *     }
- *   }
- * ]}</pre>
- * This code encodes the above structure: <pre>   {@code
- *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
- *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
- *     writer.setIndent("    ");
- *     writeMessagesArray(writer, messages);
- *     writer.close();
- *   }
- *
- *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {
- *     writer.beginArray();
- *     for (Message message : messages) {
- *       writeMessage(writer, message);
- *     }
- *     writer.endArray();
- *   }
- *
- *   public void writeMessage(JsonWriter writer, Message message) throws IOException {
- *     writer.beginObject();
- *     writer.name("id").value(message.getId());
- *     writer.name("text").value(message.getText());
- *     if (message.getGeo() != null) {
- *       writer.name("geo");
- *       writeDoublesArray(writer, message.getGeo());
- *     } else {
- *       writer.name("geo").nullValue();
- *     }
- *     writer.name("user");
- *     writeUser(writer, message.getUser());
- *     writer.endObject();
- *   }
- *
- *   public void writeUser(JsonWriter writer, User user) throws IOException {
- *     writer.beginObject();
- *     writer.name("name").value(user.getName());
- *     writer.name("followers_count").value(user.getFollowersCount());
- *     writer.endObject();
- *   }
- *
- *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {
- *     writer.beginArray();
- *     for (Double value : doubles) {
- *       writer.value(value);
- *     }
- *     writer.endArray();
- *   }}</pre>
- *
- * <p>Each {@code JsonWriter} may be used to write a single JSON stream.
- * Instances of this class are not thread safe. Calls that would result in a
- * malformed JSON string will fail with an {@link IllegalStateException}.
- *
- * @author Jesse Wilson
- * @since 1.6
- */
-public class JsonWriter implements Closeable, Flushable {
-
-  /*
-   * From RFC 7159, "All Unicode characters may be placed within the
-   * quotation marks except for the characters that must be escaped:
-   * quotation mark, reverse solidus, and the control characters
-   * (U+0000 through U+001F)."
-   *
-   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
-   * newline characters. This prevents eval() from failing with a syntax
-   * error. http://code.google.com/p/google-gson/issues/detail?id=341
-   */
-  private static final String[] REPLACEMENT_CHARS;
-  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;
-  static {
-    REPLACEMENT_CHARS = new String[128];
-    for (int i = 0; i <= 0x1f; i++) {
-      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
-    }
-    REPLACEMENT_CHARS['"'] = "\\\"";
-    REPLACEMENT_CHARS['\\'] = "\\\\";
-    REPLACEMENT_CHARS['\t'] = "\\t";
-    REPLACEMENT_CHARS['\b'] = "\\b";
-    REPLACEMENT_CHARS['\n'] = "\\n";
-    REPLACEMENT_CHARS['\r'] = "\\r";
-    REPLACEMENT_CHARS['\f'] = "\\f";
-    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
-    HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
-    HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
-    HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
-    HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
-    HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
-  }
-
-  /** The output data, containing at most one top-level array or object. */
-  private final Writer out;
-
-  private int[] stack = new int[32];
-  private int stackSize = 0;
-  {
-    push(EMPTY_DOCUMENT);
-  }
-
-  /**
-   * A string containing a full set of spaces for a single level of
-   * indentation, or null for no pretty printing.
-   */
-  private String indent;
-
-  /**
-   * The name/value separator; either ":" or ": ".
-   */
-  private String separator = ":";
-
-  private boolean lenient;
-
-  private boolean htmlSafe;
-
-  private String deferredName;
-
-  private boolean serializeNulls = true;
-
-  /**
-   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
-   * For best performance, ensure {@link Writer} is buffered; wrapping in
-   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
-   */
-  public JsonWriter(Writer out) {
-    if (out == null) {
-      throw new NullPointerException("out == null");
-    }
-    this.out = out;
-  }
-
-  /**
-   * Sets the indentation string to be repeated for each level of indentation
-   * in the encoded document. If {@code indent.isEmpty()} the encoded document
-   * will be compact. Otherwise the encoded document will be more
-   * human-readable.
-   *
-   * @param indent a string containing only whitespace.
-   */
-  public final void setIndent(String indent) {
-    if (indent.length() == 0) {
-      this.indent = null;
-      this.separator = ":";
-    } else {
-      this.indent = indent;
-      this.separator = ": ";
-    }
-  }
-
-  /**
-   * Configure this writer to relax its syntax rules. By default, this writer
-   * only emits well-formed JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
-   * to lenient permits the following:
-   * <ul>
-   *   <li>Top-level values of any type. With strict writing, the top-level
-   *       value must be an object or an array.
-   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
-   *       Double#isInfinite() infinities}.
-   * </ul>
-   */
-  public final void setLenient(boolean lenient) {
-    this.lenient = lenient;
-  }
-
-  /**
-   * Returns true if this writer has relaxed syntax rules.
-   */
-  public boolean isLenient() {
-    return lenient;
-  }
-
-  /**
-   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
-   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
-   * {@code &} and {@code =} before writing them to the stream. Without this
-   * setting, your XML/HTML encoder should replace these characters with the
-   * corresponding escape sequences.
-   */
-  public final void setHtmlSafe(boolean htmlSafe) {
-    this.htmlSafe = htmlSafe;
-  }
-
-  /**
-   * Returns true if this writer writes JSON that's safe for inclusion in HTML
-   * and XML documents.
-   */
-  public final boolean isHtmlSafe() {
-    return htmlSafe;
-  }
-
-  /**
-   * Sets whether object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-  public final void setSerializeNulls(boolean serializeNulls) {
-    this.serializeNulls = serializeNulls;
-  }
-
-  /**
-   * Returns true if object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-  public final boolean getSerializeNulls() {
-    return serializeNulls;
-  }
-
-  /**
-   * Begins encoding a new array. Each call to this method must be paired with
-   * a call to {@link #endArray}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter beginArray() throws IOException {
-    writeDeferredName();
-    return open(EMPTY_ARRAY, "[");
-  }
-
-  /**
-   * Ends encoding the current array.
-   *
-   * @return this writer.
-   */
-  public JsonWriter endArray() throws IOException {
-    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
-  }
-
-  /**
-   * Begins encoding a new object. Each call to this method must be paired
-   * with a call to {@link #endObject}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter beginObject() throws IOException {
-    writeDeferredName();
-    return open(EMPTY_OBJECT, "{");
-  }
-
-  /**
-   * Ends encoding the current object.
-   *
-   * @return this writer.
-   */
-  public JsonWriter endObject() throws IOException {
-    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
-  }
-
-  /**
-   * Enters a new scope by appending any necessary whitespace and the given
-   * bracket.
-   */
-  private JsonWriter open(int empty, String openBracket) throws IOException {
-    beforeValue();
-    push(empty);
-    out.write(openBracket);
-    return this;
-  }
-
-  /**
-   * Closes the current scope by appending any necessary whitespace and the
-   * given bracket.
-   */
-  private JsonWriter close(int empty, int nonempty, String closeBracket)
-      throws IOException {
-    int context = peek();
-    if (context != nonempty && context != empty) {
-      throw new IllegalStateException("Nesting problem.");
-    }
-    if (deferredName != null) {
-      throw new IllegalStateException("Dangling name: " + deferredName);
-    }
-
-    stackSize--;
-    if (context == nonempty) {
-      newline();
-    }
-    out.write(closeBracket);
-    return this;
-  }
-
-  private void push(int newTop) {
-    if (stackSize == stack.length) {
-      int[] newStack = new int[stackSize * 2];
-      System.arraycopy(stack, 0, newStack, 0, stackSize);
-      stack = newStack;
-    }
-    stack[stackSize++] = newTop;
-  }
-
-  /**
-   * Returns the value on the top of the stack.
-   */
-  private int peek() {
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    return stack[stackSize - 1];
-  }
-
-  /**
-   * Replace the value on the top of the stack with the given value.
-   */
-  private void replaceTop(int topOfStack) {
-    stack[stackSize - 1] = topOfStack;
-  }
-
-  /**
-   * Encodes the property name.
-   *
-   * @param name the name of the forthcoming value. May not be null.
-   * @return this writer.
-   */
-  public JsonWriter name(String name) throws IOException {
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    if (deferredName != null) {
-      throw new IllegalStateException();
-    }
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    deferredName = name;
-    return this;
-  }
-
-  private void writeDeferredName() throws IOException {
-    if (deferredName != null) {
-      beforeName();
-      string(deferredName);
-      deferredName = null;
-    }
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  public JsonWriter value(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    string(value);
-    return this;
-  }
-
-  /**
-   * Writes {@code value} directly to the writer without quoting or
-   * escaping.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  public JsonWriter jsonValue(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    out.append(value);
-    return this;
-  }
-
-  /**
-   * Encodes {@code null}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter nullValue() throws IOException {
-    if (deferredName != null) {
-      if (serializeNulls) {
-        writeDeferredName();
-      } else {
-        deferredName = null;
-        return this; // skip the name and the value
-      }
-    }
-    beforeValue();
-    out.write("null");
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter value(boolean value) throws IOException {
-    writeDeferredName();
-    beforeValue();
-    out.write(value ? "true" : "false");
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
-  public JsonWriter value(double value) throws IOException {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
-    }
-    writeDeferredName();
-    beforeValue();
-    out.append(Double.toString(value));
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter value(long value) throws IOException {
-    writeDeferredName();
-    beforeValue();
-    out.write(Long.toString(value));
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
-  public JsonWriter value(Number value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-
-    writeDeferredName();
-    String string = value.toString();
-    if (!lenient
-        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
-    }
-    beforeValue();
-    out.append(string);
-    return this;
-  }
-
-  /**
-   * Ensures all buffered data is written to the underlying {@link Writer}
-   * and flushes that writer.
-   */
-  public void flush() throws IOException {
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    out.flush();
-  }
-
-  /**
-   * Flushes and closes this writer and the underlying {@link Writer}.
-   *
-   * @throws IOException if the JSON document is incomplete.
-   */
-  public void close() throws IOException {
-    out.close();
-
-    int size = stackSize;
-    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
-      throw new IOException("Incomplete document");
-    }
-    stackSize = 0;
-  }
-
-  private void string(String value) throws IOException {
-    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
-    out.write("\"");
-    int last = 0;
-    int length = value.length();
-    for (int i = 0; i < length; i++) {
-      char c = value.charAt(i);
-      String replacement;
-      if (c < 128) {
-        replacement = replacements[c];
-        if (replacement == null) {
-          continue;
-        }
-      } else if (c == '\u2028') {
-        replacement = "\\u2028";
-      } else if (c == '\u2029') {
-        replacement = "\\u2029";
-      } else {
-        continue;
-      }
-      if (last < i) {
-        out.write(value, last, i - last);
-      }
-      out.write(replacement);
-      last = i + 1;
-    }
-    if (last < length) {
-      out.write(value, last, length - last);
-    }
-    out.write("\"");
-  }
-
-  private void newline() throws IOException {
-    if (indent == null) {
-      return;
-    }
-
-    out.write("\n");
-    for (int i = 1, size = stackSize; i < size; i++) {
-      out.write(indent);
-    }
-  }
-
-  /**
-   * Inserts any necessary separators and whitespace before a name. Also
-   * adjusts the stack to expect the name's value.
-   */
-  private void beforeName() throws IOException {
-    int context = peek();
-    if (context == NONEMPTY_OBJECT) { // first in object
-      out.write(',');
-    } else if (context != EMPTY_OBJECT) { // not in an object!
-      throw new IllegalStateException("Nesting problem.");
-    }
-    newline();
-    replaceTop(DANGLING_NAME);
-  }
-
-  /**
-   * Inserts any necessary separators and whitespace before a literal value,
-   * inline array, or inline object. Also adjusts the stack to expect either a
-   * closing bracket or another element.
-   */
-  @SuppressWarnings("fallthrough")
-  private void beforeValue() throws IOException {
-    switch (peek()) {
-    case NONEMPTY_DOCUMENT:
-      if (!lenient) {
-        throw new IllegalStateException(
-            "JSON must have only one top-level value.");
-      }
-      // fall-through
-    case EMPTY_DOCUMENT: // first in document
-      replaceTop(NONEMPTY_DOCUMENT);
-      break;
-
-    case EMPTY_ARRAY: // first in array
-      replaceTop(NONEMPTY_ARRAY);
-      newline();
-      break;
-
-    case NONEMPTY_ARRAY: // another in array
-      out.append(',');
-      newline();
-      break;
-
-    case DANGLING_NAME: // value for name
-      out.append(separator);
-      replaceTop(NONEMPTY_OBJECT);
-      break;
-
-    default:
-      throw new IllegalStateException("Nesting problem.");
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/ExclusionStrategy.java b/gson/src/main/java/com/google/stripped/gson/ExclusionStrategy.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/ExclusionStrategy.java
rename to gson/src/main/java/com/google/stripped/gson/ExclusionStrategy.java
index 6a3f43fb5..4adecb7e7 100644
--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java
+++ b/gson/src/main/java/com/google/stripped/gson/ExclusionStrategy.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 /**
  * A strategy (or policy) definition that is used to decide whether or not a field or top-level
diff --git a/gson/src/main/java/com/google/gson/FieldAttributes.java b/gson/src/main/java/com/google/stripped/gson/FieldAttributes.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/FieldAttributes.java
rename to gson/src/main/java/com/google/stripped/gson/FieldAttributes.java
index bcabff14a..d12937f83 100644
--- a/gson/src/main/java/com/google/gson/FieldAttributes.java
+++ b/gson/src/main/java/com/google/stripped/gson/FieldAttributes.java
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
+
+import com.google.stripped.gson.internal.$Gson$Preconditions;
 
-import com.google.gson.internal.$Gson$Preconditions;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/stripped/gson/FieldNamingPolicy.java
similarity index 96%
rename from gson/src/main/java/com/google/gson/FieldNamingPolicy.java
rename to gson/src/main/java/com/google/stripped/gson/FieldNamingPolicy.java
index 3b325a4fd..5c1d1cf14 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ b/gson/src/main/java/com/google/stripped/gson/FieldNamingPolicy.java
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Field;
 import java.util.Locale;
 
 /**
  * An enumeration that defines a few standard naming conventions for JSON field names.
- * This enumeration should be used in conjunction with {@link com.google.gson.GsonBuilder}
- * to configure a {@link com.google.gson.Gson} instance to properly translate Java field
+ * This enumeration should be used in conjunction with {@link GsonBuilder}
+ * to configure a {@link Gson} instance to properly translate Java field
  * names into the desired JSON field names.
  *
  * @author Inderjeet Singh
diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/stripped/gson/FieldNamingStrategy.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/FieldNamingStrategy.java
rename to gson/src/main/java/com/google/stripped/gson/FieldNamingStrategy.java
index 9be453ad1..2c3b5ee51 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
+++ b/gson/src/main/java/com/google/stripped/gson/FieldNamingStrategy.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Field;
 
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/stripped/gson/Gson.java
similarity index 59%
rename from gson/src/main/java/com/google/gson/Gson.java
rename to gson/src/main/java/com/google/stripped/gson/Gson.java
index 106d24854..35343993e 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/stripped/gson/Gson.java
@@ -14,46 +14,29 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
 import java.lang.reflect.Type;
-import java.math.BigDecimal;
-import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicLongArray;
-
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.Primitives;
-import com.google.gson.internal.Streams;
-import com.google.gson.internal.bind.ArrayTypeAdapter;
-import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
-import com.google.gson.internal.bind.DateTypeAdapter;
-import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
-import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.internal.bind.JsonTreeWriter;
-import com.google.gson.internal.bind.MapTypeAdapterFactory;
-import com.google.gson.internal.bind.ObjectTypeAdapter;
-import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
-import com.google.gson.internal.bind.SqlDateTypeAdapter;
-import com.google.gson.internal.bind.TimeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import com.google.gson.stream.MalformedJsonException;
+
+import com.google.stripped.gson.internal.ConstructorConstructor;
+import com.google.stripped.gson.internal.Excluder;
+import com.google.stripped.gson.internal.Primitives;
+import com.google.stripped.gson.annotations.Expose;
+import com.google.stripped.gson.annotations.Since;
+import com.google.stripped.gson.internal.bind.*;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+import com.google.stripped.gson.stream.MalformedJsonException;
 
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
@@ -93,7 +76,7 @@
  * <p>See the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a>
  * for a more complete set of examples.</p>
  *
- * @see com.google.gson.reflect.TypeToken
+ * @see TypeToken
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -139,14 +122,6 @@
     }
   };
 
-  final JsonSerializationContext serializationContext = new JsonSerializationContext() {
-    @Override public JsonElement serialize(Object src) {
-      return toJsonTree(src);
-    }
-    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
-      return toJsonTree(src, typeOfSrc);
-    }
-  };
 
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
@@ -168,10 +143,10 @@
    *   ignores the millisecond portion of the date during serialization. You can change
    *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
    *   {@link GsonBuilder#setDateFormat(String)}. </li>
-   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.
+   *   <li>By default, Gson ignores the {@link Expose} annotation.
    *   You can enable Gson to serialize/deserialize only those fields marked with this annotation
    *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>
-   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
+   *   <li>By default, Gson ignores the {@link Since} annotation. You
    *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
    *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
    *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
@@ -219,37 +194,6 @@ public Gson() {
     factories.add(TypeAdapters.STRING_FACTORY);
     factories.add(TypeAdapters.INTEGER_FACTORY);
     factories.add(TypeAdapters.BOOLEAN_FACTORY);
-    factories.add(TypeAdapters.BYTE_FACTORY);
-    factories.add(TypeAdapters.SHORT_FACTORY);
-    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);
-    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));
-    factories.add(TypeAdapters.newFactory(double.class, Double.class,
-            doubleAdapter(serializeSpecialFloatingPointValues)));
-    factories.add(TypeAdapters.newFactory(float.class, Float.class,
-            floatAdapter(serializeSpecialFloatingPointValues)));
-    factories.add(TypeAdapters.NUMBER_FACTORY);
-    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);
-    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);
-    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));
-    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));
-    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);
-    factories.add(TypeAdapters.CHARACTER_FACTORY);
-    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);
-    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
-    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
-    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
-    factories.add(TypeAdapters.URL_FACTORY);
-    factories.add(TypeAdapters.URI_FACTORY);
-    factories.add(TypeAdapters.UUID_FACTORY);
-    factories.add(TypeAdapters.CURRENCY_FACTORY);
-    factories.add(TypeAdapters.LOCALE_FACTORY);
-    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
-    factories.add(TypeAdapters.BIT_SET_FACTORY);
-    factories.add(DateTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.CALENDAR_FACTORY);
-    factories.add(TimeTypeAdapter.FACTORY);
-    factories.add(SqlDateTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.TIMESTAMP_FACTORY);
     factories.add(ArrayTypeAdapter.FACTORY);
     factories.add(TypeAdapters.CLASS_FACTORY);
 
@@ -264,123 +208,6 @@ public Gson() {
     this.factories = Collections.unmodifiableList(factories);
   }
 
-  private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
-    if (serializeSpecialFloatingPointValues) {
-      return TypeAdapters.DOUBLE;
-    }
-    return new TypeAdapter<Number>() {
-      @Override public Double read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return in.nextDouble();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        double doubleValue = value.doubleValue();
-        checkValidFloatingPoint(doubleValue);
-        out.value(value);
-      }
-    };
-  }
-
-  private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {
-    if (serializeSpecialFloatingPointValues) {
-      return TypeAdapters.FLOAT;
-    }
-    return new TypeAdapter<Number>() {
-      @Override public Float read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return (float) in.nextDouble();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        float floatValue = value.floatValue();
-        checkValidFloatingPoint(floatValue);
-        out.value(value);
-      }
-    };
-  }
-
-  static void checkValidFloatingPoint(double value) {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
-      throw new IllegalArgumentException(value
-          + " is not a valid double value as per JSON specification. To override this"
-          + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
-    }
-  }
-
-  private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {
-    if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {
-      return TypeAdapters.LONG;
-    }
-    return new TypeAdapter<Number>() {
-      @Override public Number read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return in.nextLong();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        out.value(value.toString());
-      }
-    };
-  }
-
-  private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
-    return new TypeAdapter<AtomicLong>() {
-      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {
-        longAdapter.write(out, value.get());
-      }
-      @Override public AtomicLong read(JsonReader in) throws IOException {
-        Number value = longAdapter.read(in);
-        return new AtomicLong(value.longValue());
-      }
-    }.nullSafe();
-  }
-
-  private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {
-    return new TypeAdapter<AtomicLongArray>() {
-      @Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {
-        out.beginArray();
-        for (int i = 0, length = value.length(); i < length; i++) {
-          longAdapter.write(out, value.get(i));
-        }
-        out.endArray();
-      }
-      @Override public AtomicLongArray read(JsonReader in) throws IOException {
-        List<Long> list = new ArrayList<Long>();
-        in.beginArray();
-        while (in.hasNext()) {
-            long value = longAdapter.read(in).longValue();
-            list.add(value);
-        }
-        in.endArray();
-        int length = list.size();
-        AtomicLongArray array = new AtomicLongArray(length);
-        for (int i = 0; i < length; ++i) {
-          array.set(i, list.get(i));
-        }
-        return array;
-      }
-    }.nullSafe();
-  }
-
   /**
    * Returns the type adapter for {@code} type.
    *
@@ -425,7 +252,7 @@ static void checkValidFloatingPoint(double value) {
       threadCalls.remove(type);
 
       if (requiresThreadLocalCleanup) {
-        calls.remove();
+        calls.set(null);
       }
     }
   }
@@ -513,205 +340,6 @@ static void checkValidFloatingPoint(double value) {
     return getAdapter(TypeToken.get(type));
   }
 
-  /**
-   * This method serializes the specified object into its equivalent representation as a tree of
-   * {@link JsonElement}s. This method should be used when the specified object is not a generic
-   * type. This method uses {@link Class#getClass()} to get the type for the specified object, but
-   * the {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJsonTree(Object, Type)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @return Json representation of {@code src}.
-   * @since 1.4
-   */
-  public JsonElement toJsonTree(Object src) {
-    if (src == null) {
-      return JsonNull.INSTANCE;
-    }
-    return toJsonTree(src, src.getClass());
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
-   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
-   * instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return Json representation of {@code src}
-   * @since 1.4
-   */
-  public JsonElement toJsonTree(Object src, Type typeOfSrc) {
-    JsonTreeWriter writer = new JsonTreeWriter();
-    toJson(src, typeOfSrc, writer);
-    return writer.get();
-  }
-
-  /**
-   * This method serializes the specified object into its equivalent Json representation.
-   * This method should be used when the specified object is not a generic type. This method uses
-   * {@link Class#getClass()} to get the type for the specified object, but the
-   * {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
-   * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @return Json representation of {@code src}.
-   */
-  public String toJson(Object src) {
-    if (src == null) {
-      return toJson(JsonNull.INSTANCE);
-    }
-    return toJson(src, src.getClass());
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent Json representation. This method must be used if the specified object is a generic
-   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
-   * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return Json representation of {@code src}
-   */
-  public String toJson(Object src, Type typeOfSrc) {
-    StringWriter writer = new StringWriter();
-    toJson(src, typeOfSrc, writer);
-    return writer.toString();
-  }
-
-  /**
-   * This method serializes the specified object into its equivalent Json representation.
-   * This method should be used when the specified object is not a generic type. This method uses
-   * {@link Class#getClass()} to get the type for the specified object, but the
-   * {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJson(Object, Type, Appendable)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @param writer Writer to which the Json representation needs to be written
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.2
-   */
-  public void toJson(Object src, Appendable writer) throws JsonIOException {
-    if (src != null) {
-      toJson(src, src.getClass(), writer);
-    } else {
-      toJson(JsonNull.INSTANCE, writer);
-    }
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent Json representation. This method must be used if the specified object is a generic
-   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @param writer Writer to which the Json representation of src needs to be written.
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.2
-   */
-  public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {
-    try {
-      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
-      toJson(src, typeOfSrc, jsonWriter);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
-
-  /**
-   * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to
-   * {@code writer}.
-   * @throws JsonIOException if there was a problem writing to the writer
-   */
-  @SuppressWarnings("unchecked")
-  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
-    TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
-    boolean oldLenient = writer.isLenient();
-    writer.setLenient(true);
-    boolean oldHtmlSafe = writer.isHtmlSafe();
-    writer.setHtmlSafe(htmlSafe);
-    boolean oldSerializeNulls = writer.getSerializeNulls();
-    writer.setSerializeNulls(serializeNulls);
-    try {
-      ((TypeAdapter<Object>) adapter).write(writer, src);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } finally {
-      writer.setLenient(oldLenient);
-      writer.setHtmlSafe(oldHtmlSafe);
-      writer.setSerializeNulls(oldSerializeNulls);
-    }
-  }
-
-  /**
-   * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
-   *
-   * @param jsonElement root of a tree of {@link JsonElement}s
-   * @return JSON String representation of the tree
-   * @since 1.4
-   */
-  public String toJson(JsonElement jsonElement) {
-    StringWriter writer = new StringWriter();
-    toJson(jsonElement, writer);
-    return writer.toString();
-  }
-
-  /**
-   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.
-   *
-   * @param jsonElement root of a tree of {@link JsonElement}s
-   * @param writer Writer to which the Json representation needs to be written
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.4
-   */
-  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {
-    try {
-      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
-      toJson(jsonElement, jsonWriter);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
-   */
-  public JsonWriter newJsonWriter(Writer writer) throws IOException {
-    if (generateNonExecutableJson) {
-      writer.write(JSON_NON_EXECUTABLE_PREFIX);
-    }
-    JsonWriter jsonWriter = new JsonWriter(writer);
-    if (prettyPrinting) {
-      jsonWriter.setIndent("  ");
-    }
-    jsonWriter.setSerializeNulls(serializeNulls);
-    return jsonWriter;
-  }
 
   /**
    * Returns a new JSON writer configured for the settings on this Gson instance.
@@ -722,27 +350,6 @@ public JsonReader newJsonReader(Reader reader) {
     return jsonReader;
   }
 
-  /**
-   * Writes the JSON for {@code jsonElement} to {@code writer}.
-   * @throws JsonIOException if there was a problem writing to the writer
-   */
-  public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {
-    boolean oldLenient = writer.isLenient();
-    writer.setLenient(true);
-    boolean oldHtmlSafe = writer.isHtmlSafe();
-    writer.setHtmlSafe(htmlSafe);
-    boolean oldSerializeNulls = writer.getSerializeNulls();
-    writer.setSerializeNulls(serializeNulls);
-    try {
-      Streams.write(jsonElement, writer);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } finally {
-      writer.setLenient(oldLenient);
-      writer.setHtmlSafe(oldHtmlSafe);
-      writer.setSerializeNulls(oldSerializeNulls);
-    }
-  }
 
   /**
    * This method deserializes the specified Json into an object of the specified class. It is not
@@ -775,7 +382,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the string from which the object is to be deserialized
    * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+   * {@link TypeToken} class. For example, to get the type for
    * {@code Collection<Foo>}, you should use:
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
@@ -828,7 +435,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the reader producing Json from which the object is to be deserialized
    * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+   * {@link TypeToken} class. For example, to get the type for
    * {@code Collection<Foo>}, you should use:
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
@@ -927,7 +534,7 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
    * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
    * be deserialized
    * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+   * {@link TypeToken} class. For example, to get the type for
    * {@code Collection<Foo>}, you should use:
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
@@ -961,12 +568,6 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {
       return delegate.read(in);
     }
 
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      if (delegate == null) {
-        throw new IllegalStateException();
-      }
-      delegate.write(out, value);
-    }
   }
 
   @Override
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/stripped/gson/GsonBuilder.java
similarity index 91%
rename from gson/src/main/java/com/google/gson/GsonBuilder.java
rename to gson/src/main/java/com/google/stripped/gson/GsonBuilder.java
index b258e22fa..4abde0686 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/stripped/gson/GsonBuilder.java
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
-import com.google.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonReader;
 import java.lang.reflect.Type;
-import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,18 +26,11 @@
 import java.util.List;
 import java.util.Map;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.reflect.TypeToken;
-
-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
-import static com.google.gson.Gson.DEFAULT_LENIENT;
-import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+import com.google.stripped.gson.internal.$Gson$Preconditions;
+import com.google.stripped.gson.internal.Excluder;
+import com.google.stripped.gson.annotations.Expose;
+import com.google.stripped.gson.internal.bind.TypeAdapters;
+import com.google.stripped.gson.reflect.TypeToken;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -83,16 +75,16 @@
   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();
-  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
+  private boolean serializeNulls = Gson.DEFAULT_SERIALIZE_NULLS;
   private String datePattern;
   private int dateStyle = DateFormat.DEFAULT;
   private int timeStyle = DateFormat.DEFAULT;
-  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
-  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;
-  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
-  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
-  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
-  private boolean lenient = DEFAULT_LENIENT;
+  private boolean complexMapKeySerialization = Gson.DEFAULT_COMPLEX_MAP_KEYS;
+  private boolean serializeSpecialFloatingPointValues = Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+  private boolean escapeHtmlChars = Gson.DEFAULT_ESCAPE_HTML;
+  private boolean prettyPrinting = Gson.DEFAULT_PRETTY_PRINT;
+  private boolean generateNonExecutableJson = Gson.DEFAULT_JSON_NON_EXECUTABLE;
+  private boolean lenient = Gson.DEFAULT_LENIENT;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -147,7 +139,7 @@ public GsonBuilder generateNonExecutableJson() {
 
   /**
    * Configures Gson to exclude all fields from consideration for serialization or deserialization
-   * that do not have the {@link com.google.gson.annotations.Expose} annotation.
+   * that do not have the {@link Expose} annotation.
    *
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    */
@@ -563,7 +555,6 @@ public Gson create() {
     factories.addAll(this.factories);
     Collections.reverse(factories);
     factories.addAll(this.hierarchyFactories);
-    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
@@ -571,19 +562,4 @@ public Gson create() {
         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
   }
 
-  private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
-      List<TypeAdapterFactory> factories) {
-    DefaultDateTypeAdapter dateTypeAdapter;
-    if (datePattern != null && !"".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);
-    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);
-    } else {
-      return;
-    }
-
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/InstanceCreator.java b/gson/src/main/java/com/google/stripped/gson/InstanceCreator.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/InstanceCreator.java
rename to gson/src/main/java/com/google/stripped/gson/InstanceCreator.java
index d5096a07a..4b62889b7 100644
--- a/gson/src/main/java/com/google/gson/InstanceCreator.java
+++ b/gson/src/main/java/com/google/stripped/gson/InstanceCreator.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Type;
 
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/stripped/gson/JsonArray.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/JsonArray.java
rename to gson/src/main/java/com/google/stripped/gson/JsonArray.java
index 19299d14e..e8a49d89b 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonArray.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
diff --git a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java b/gson/src/main/java/com/google/stripped/gson/JsonDeserializationContext.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/JsonDeserializationContext.java
rename to gson/src/main/java/com/google/stripped/gson/JsonDeserializationContext.java
index 00c750543..63e024f35 100644
--- a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonDeserializationContext.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Type;
 
diff --git a/gson/src/main/java/com/google/gson/JsonDeserializer.java b/gson/src/main/java/com/google/stripped/gson/JsonDeserializer.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/JsonDeserializer.java
rename to gson/src/main/java/com/google/stripped/gson/JsonDeserializer.java
index 0589eb284..4b9966fc2 100644
--- a/gson/src/main/java/com/google/gson/JsonDeserializer.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonDeserializer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Type;
 
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/stripped/gson/JsonElement.java
similarity index 95%
rename from gson/src/main/java/com/google/gson/JsonElement.java
rename to gson/src/main/java/com/google/stripped/gson/JsonElement.java
index d9cd91846..6136e5155 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonElement.java
@@ -14,12 +14,8 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
-import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
@@ -312,19 +308,4 @@ public short getAsShort() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
 
-  /**
-   * Returns a String representation of this element.
-   */
-  @Override
-  public String toString() {
-    try {
-      StringWriter stringWriter = new StringWriter();
-      JsonWriter jsonWriter = new JsonWriter(stringWriter);
-      jsonWriter.setLenient(true);
-      Streams.write(this, jsonWriter);
-      return stringWriter.toString();
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/JsonIOException.java b/gson/src/main/java/com/google/stripped/gson/JsonIOException.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/JsonIOException.java
rename to gson/src/main/java/com/google/stripped/gson/JsonIOException.java
index dfeccd8ed..835836cee 100644
--- a/gson/src/main/java/com/google/gson/JsonIOException.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonIOException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.google.stripped.gson;
 
 /**
  * This exception is raised when Gson was unable to read an input stream
diff --git a/gson/src/main/java/com/google/gson/JsonNull.java b/gson/src/main/java/com/google/stripped/gson/JsonNull.java
similarity index 93%
rename from gson/src/main/java/com/google/gson/JsonNull.java
rename to gson/src/main/java/com/google/stripped/gson/JsonNull.java
index 56883369e..383a3973a 100755
--- a/gson/src/main/java/com/google/gson/JsonNull.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonNull.java
@@ -1,63 +1,62 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-/**
- * A class representing a Json {@code null} value.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.2
- */
-public final class JsonNull extends JsonElement {
-  /**
-   * singleton for JsonNull
-   *
-   * @since 1.8
-   */
-  public static final JsonNull INSTANCE = new JsonNull();
-
-  /**
-   * Creates a new JsonNull object.
-   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
-   */
-  @Deprecated
-  public JsonNull() {
-    // Do nothing
-  }
-
-  @Override
-  JsonNull deepCopy() {
-    return INSTANCE;
-  }
-
-  /**
-   * All instances of JsonNull have the same hash code since they are indistinguishable
-   */
-  @Override
-  public int hashCode() {
-    return JsonNull.class.hashCode();
-  }
-
-  /**
-   * All instances of JsonNull are the same
-   */
-  @Override
-  public boolean equals(Object other) {
-    return this == other || other instanceof JsonNull;
-  }
-}
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.stripped.gson;
+
+/**
+ * A class representing a Json {@code null} value.
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ * @since 1.2
+ */
+public final class JsonNull extends JsonElement {
+  /**
+   * singleton for JsonNull
+   *
+   * @since 1.8
+   */
+  public static final JsonNull INSTANCE = new JsonNull();
+
+  /**
+   * Creates a new JsonNull object.
+   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
+   */
+  public JsonNull() {
+    // Do nothing
+  }
+
+  @Override
+  JsonNull deepCopy() {
+    return INSTANCE;
+  }
+
+  /**
+   * All instances of JsonNull have the same hash code since they are indistinguishable
+   */
+  @Override
+  public int hashCode() {
+    return JsonNull.class.hashCode();
+  }
+
+  /**
+   * All instances of JsonNull are the same
+   */
+  @Override
+  public boolean equals(Object other) {
+    return this == other || other instanceof JsonNull;
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/stripped/gson/JsonObject.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/JsonObject.java
rename to gson/src/main/java/com/google/stripped/gson/JsonObject.java
index 78c7a177a..bb04163fa 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonObject.java
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
-import com.google.gson.internal.LinkedTreeMap;
+import com.google.stripped.gson.internal.LinkedTreeMap;
 
 import java.util.Map;
 import java.util.Set;
diff --git a/gson/src/main/java/com/google/gson/JsonParseException.java b/gson/src/main/java/com/google/stripped/gson/JsonParseException.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/JsonParseException.java
rename to gson/src/main/java/com/google/stripped/gson/JsonParseException.java
index 084f66127..73c7b9348 100644
--- a/gson/src/main/java/com/google/gson/JsonParseException.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonParseException.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 /**
  * This exception is raised if there is a serious issue that occurs during parsing of a Json
diff --git a/gson/src/main/java/com/google/gson/JsonParser.java b/gson/src/main/java/com/google/stripped/gson/JsonParser.java
similarity index 90%
rename from gson/src/main/java/com/google/gson/JsonParser.java
rename to gson/src/main/java/com/google/stripped/gson/JsonParser.java
index a8ae337ba..340998c12 100755
--- a/gson/src/main/java/com/google/gson/JsonParser.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonParser.java
@@ -1,93 +1,93 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-
-import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.MalformedJsonException;
-
-/**
- * A parser to parse Json into a parse tree of {@link JsonElement}s
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.3
- */
-public final class JsonParser {
-
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param json JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
-   */
-  public JsonElement parse(String json) throws JsonSyntaxException {
-    return parse(new StringReader(json));
-  }
-
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param json JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
-   */
-  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
-    try {
-      JsonReader jsonReader = new JsonReader(json);
-      JsonElement element = parse(jsonReader);
-      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
-        throw new JsonSyntaxException("Did not consume the entire document.");
-      }
-      return element;
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (NumberFormatException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-
-  /**
-   * Returns the next value from the JSON stream as a parse tree.
-   *
-   * @throws JsonParseException if there is an IOException or if the specified
-   *     text is not valid JSON
-   * @since 1.6
-   */
-  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
-    boolean lenient = json.isLenient();
-    json.setLenient(true);
-    try {
-      return Streams.parse(json);
-    } catch (StackOverflowError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
-    } catch (OutOfMemoryError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
-    } finally {
-      json.setLenient(lenient);
-    }
-  }
-}
+/*
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.stripped.gson;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+
+import com.google.stripped.gson.internal.Streams;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+import com.google.stripped.gson.stream.MalformedJsonException;
+
+/**
+ * A parser to parse Json into a parse tree of {@link JsonElement}s
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ * @since 1.3
+ */
+public final class JsonParser {
+
+  /**
+   * Parses the specified JSON string into a parse tree
+   *
+   * @param json JSON text
+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+   * @throws JsonParseException if the specified text is not valid JSON
+   * @since 1.3
+   */
+  public JsonElement parse(String json) throws JsonSyntaxException {
+    return parse(new StringReader(json));
+  }
+
+  /**
+   * Parses the specified JSON string into a parse tree
+   *
+   * @param json JSON text
+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+   * @throws JsonParseException if the specified text is not valid JSON
+   * @since 1.3
+   */
+  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
+    try {
+      JsonReader jsonReader = new JsonReader(json);
+      JsonElement element = parse(jsonReader);
+      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
+        throw new JsonSyntaxException("Did not consume the entire document.");
+      }
+      return element;
+    } catch (MalformedJsonException e) {
+      throw new JsonSyntaxException(e);
+    } catch (IOException e) {
+      throw new JsonIOException(e);
+    } catch (NumberFormatException e) {
+      throw new JsonSyntaxException(e);
+    }
+  }
+
+  /**
+   * Returns the next value from the JSON stream as a parse tree.
+   *
+   * @throws JsonParseException if there is an IOException or if the specified
+   *     text is not valid JSON
+   * @since 1.6
+   */
+  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
+    boolean lenient = json.isLenient();
+    json.setLenient(true);
+    try {
+      return Streams.parse(json);
+    } catch (StackOverflowError e) {
+      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+    } catch (OutOfMemoryError e) {
+      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+    } finally {
+      json.setLenient(lenient);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/stripped/gson/JsonPrimitive.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/JsonPrimitive.java
rename to gson/src/main/java/com/google/stripped/gson/JsonPrimitive.java
index e2443d435..8c7667bcc 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonPrimitive.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.LazilyParsedNumber;
+import com.google.stripped.gson.internal.$Gson$Preconditions;
+import com.google.stripped.gson.internal.LazilyParsedNumber;
 
 /**
  * A class representing a Json primitive value. A primitive value
diff --git a/gson/src/main/java/com/google/gson/JsonSerializationContext.java b/gson/src/main/java/com/google/stripped/gson/JsonSerializationContext.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/JsonSerializationContext.java
rename to gson/src/main/java/com/google/stripped/gson/JsonSerializationContext.java
index ca3ec4f90..e1ff556b5 100644
--- a/gson/src/main/java/com/google/gson/JsonSerializationContext.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonSerializationContext.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Type;
 
diff --git a/gson/src/main/java/com/google/gson/JsonSerializer.java b/gson/src/main/java/com/google/stripped/gson/JsonSerializer.java
similarity index 96%
rename from gson/src/main/java/com/google/gson/JsonSerializer.java
rename to gson/src/main/java/com/google/stripped/gson/JsonSerializer.java
index a60500336..0275d6a74 100644
--- a/gson/src/main/java/com/google/gson/JsonSerializer.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonSerializer.java
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.lang.reflect.Type;
 
 /**
  * Interface representing a custom serializer for Json. You should write a custom serializer, if
  * you are not happy with the default serialization done by Gson. You will also need to register
- * this serializer through {@link com.google.gson.GsonBuilder#registerTypeAdapter(Type, Object)}.
+ * this serializer through {@link GsonBuilder#registerTypeAdapter(Type, Object)}.
  *
  * <p>Let us look at example where defining a serializer will be useful. The {@code Id} class
  * defined below has two fields: {@code clazz} and {@code value}.</p>
diff --git a/gson/src/main/java/com/google/gson/JsonStreamParser.java b/gson/src/main/java/com/google/stripped/gson/JsonStreamParser.java
similarity index 93%
rename from gson/src/main/java/com/google/gson/JsonStreamParser.java
rename to gson/src/main/java/com/google/stripped/gson/JsonStreamParser.java
index f0438db32..cffea4e04 100644
--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonStreamParser.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.google.stripped.gson;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -22,10 +22,10 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.MalformedJsonException;
+import com.google.stripped.gson.internal.Streams;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+import com.google.stripped.gson.stream.MalformedJsonException;
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
diff --git a/gson/src/main/java/com/google/gson/JsonSyntaxException.java b/gson/src/main/java/com/google/stripped/gson/JsonSyntaxException.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/JsonSyntaxException.java
rename to gson/src/main/java/com/google/stripped/gson/JsonSyntaxException.java
index 17c1d3d3a..7fe07738d 100644
--- a/gson/src/main/java/com/google/gson/JsonSyntaxException.java
+++ b/gson/src/main/java/com/google/stripped/gson/JsonSyntaxException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.google.stripped.gson;
 
 /**
  * This exception is raised when Gson attempts to read (or write) a malformed
diff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/stripped/gson/LongSerializationPolicy.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/LongSerializationPolicy.java
rename to gson/src/main/java/com/google/stripped/gson/LongSerializationPolicy.java
index 7b732bab7..f7da4b96d 100644
--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
+++ b/gson/src/main/java/com/google/stripped/gson/LongSerializationPolicy.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
 /**
  * Defines the expected format for a {@code long} or {@code Long} type when its serialized.
diff --git a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java b/gson/src/main/java/com/google/stripped/gson/TreeTypeAdapter.java
similarity index 88%
rename from gson/src/main/java/com/google/gson/TreeTypeAdapter.java
rename to gson/src/main/java/com/google/stripped/gson/TreeTypeAdapter.java
index 5b7305edc..2af760fec 100644
--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/stripped/gson/TreeTypeAdapter.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
+
+import com.google.stripped.gson.internal.$Gson$Preconditions;
+import com.google.stripped.gson.internal.Streams;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Streams;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 
 /**
@@ -58,19 +58,6 @@
     return deserializer.deserialize(value, typeToken.getType(), gson.deserializationContext);
   }
 
-  @Override public void write(JsonWriter out, T value) throws IOException {
-    if (serializer == null) {
-      delegate().write(out, value);
-      return;
-    }
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-    JsonElement tree = serializer.serialize(value, typeToken.getType(), gson.serializationContext);
-    Streams.write(tree, out);
-  }
-
   private TypeAdapter<T> delegate() {
     TypeAdapter<T> d = delegate;
     return d != null
diff --git a/gson/src/main/java/com/google/gson/TypeAdapter.java b/gson/src/main/java/com/google/stripped/gson/TypeAdapter.java
similarity index 76%
rename from gson/src/main/java/com/google/gson/TypeAdapter.java
rename to gson/src/main/java/com/google/stripped/gson/TypeAdapter.java
index 4646d271d..38d75d69f 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapter.java
+++ b/gson/src/main/java/com/google/stripped/gson/TypeAdapter.java
@@ -14,18 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
+
+import com.google.stripped.gson.internal.bind.JsonTreeReader;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
 
-import com.google.gson.internal.bind.JsonTreeWriter;
-import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
 
 /**
  * Converts Java objects to and from JSON.
@@ -118,29 +115,6 @@
 //
 public abstract class TypeAdapter<T> {
 
-  /**
-   * Writes one JSON value (an array, object, string, number, boolean or null)
-   * for {@code value}.
-   *
-   * @param value the Java object to write. May be null.
-   */
-  public abstract void write(JsonWriter out, T value) throws IOException;
-
-  /**
-   * Converts {@code value} to a JSON document and writes it to {@code out}.
-   * Unlike Gson's similar {@link Gson#toJson(JsonElement, Appendable) toJson}
-   * method, this write is strict. Create a {@link
-   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
-   * writing.
-   *
-   * @param value the Java object to convert. May be null.
-   * @since 2.2
-   */
-  public final void toJson(Writer out, T value) throws IOException {
-    JsonWriter writer = new JsonWriter(out);
-    write(writer, value);
-  }
 
   /**
    * This wrapper method is used to make a type adapter null tolerant. In general, a
@@ -184,13 +158,7 @@ public final void toJson(Writer out, T value) throws IOException {
    */
   public final TypeAdapter<T> nullSafe() {
     return new TypeAdapter<T>() {
-      @Override public void write(JsonWriter out, T value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-        } else {
-          TypeAdapter.this.write(out, value);
-        }
-      }
+
       @Override public T read(JsonReader reader) throws IOException {
         if (reader.peek() == JsonToken.NULL) {
           reader.nextNull();
@@ -201,42 +169,6 @@ public final void toJson(Writer out, T value) throws IOException {
     };
   }
 
-  /**
-   * Converts {@code value} to a JSON document. Unlike Gson's similar {@link
-   * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link
-   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
-   * writing.
-   *
-   * @param value the Java object to convert. May be null.
-   * @since 2.2
-   */
-  public final String toJson(T value) {
-    StringWriter stringWriter = new StringWriter();
-    try {
-      toJson(stringWriter, value);
-    } catch (IOException e) {
-      throw new AssertionError(e); // No I/O writing to a StringWriter.
-    }
-    return stringWriter.toString();
-  }
-
-  /**
-   * Converts {@code value} to a JSON tree.
-   *
-   * @param value the Java object to convert. May be null.
-   * @return the converted JSON tree. May be {@link JsonNull}.
-   * @since 2.2
-   */
-  public final JsonElement toJsonTree(T value) {
-    try {
-      JsonTreeWriter jsonWriter = new JsonTreeWriter();
-      write(jsonWriter, value);
-      return jsonWriter.get();
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
 
   /**
    * Reads one JSON value (an array, object, string, number, boolean or null)
diff --git a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java b/gson/src/main/java/com/google/stripped/gson/TypeAdapterFactory.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/TypeAdapterFactory.java
rename to gson/src/main/java/com/google/stripped/gson/TypeAdapterFactory.java
index e12a72dcc..c72713f35 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/stripped/gson/TypeAdapterFactory.java
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.stripped.gson;
 
-import com.google.gson.reflect.TypeToken;
+import com.google.stripped.gson.reflect.TypeToken;
 
 /**
  * Creates type adapters for set of related types. Type adapter factories are
@@ -80,7 +80,7 @@
  * mapping from lowercase name to enum value is computed eagerly.
  *
  * <p>As with type adapters, factories must be <i>registered</i> with a {@link
- * com.google.gson.GsonBuilder} for them to take effect: <pre>   {@code
+ * GsonBuilder} for them to take effect: <pre>   {@code
  *
  *  GsonBuilder builder = new GsonBuilder();
  *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());
diff --git a/gson/src/main/java/com/google/gson/annotations/Expose.java b/gson/src/main/java/com/google/stripped/gson/annotations/Expose.java
similarity index 91%
rename from gson/src/main/java/com/google/gson/annotations/Expose.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/Expose.java
index 1b9c70df0..c7b094af4 100644
--- a/gson/src/main/java/com/google/gson/annotations/Expose.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/Expose.java
@@ -14,7 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson.annotations;
+package com.google.stripped.gson.annotations;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.GsonBuilder;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -25,9 +28,9 @@
  * An annotation that indicates this member should be exposed for JSON
  * serialization or deserialization.
  *
- * <p>This annotation has no effect unless you build {@link com.google.gson.Gson}
- * with a {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#excludeFieldsWithoutExposeAnnotation()}
+ * <p>This annotation has no effect unless you build {@link Gson}
+ * with a {@link GsonBuilder} and invoke
+ * {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}
  * method.</p>
  *
  * <p>Here is an example of how this annotation is meant to be used:
diff --git a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java b/gson/src/main/java/com/google/stripped/gson/annotations/JsonAdapter.java
similarity index 92%
rename from gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/JsonAdapter.java
index 2ee3e682d..19e98d4c1 100644
--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/JsonAdapter.java
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package com.google.gson.annotations;
+package com.google.stripped.gson.annotations;
 
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.GsonBuilder;
+import com.google.stripped.gson.TypeAdapterFactory;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -72,7 +73,7 @@
  * </pre>
  *
  * It's possible to specify different type adapters on a field, that
- * field's type, and in the {@link com.google.gson.GsonBuilder}. Field
+ * field's type, and in the {@link GsonBuilder}. Field
  * annotations take precedence over {@code GsonBuilder}-registered type
  * adapters, which in turn take precedence over annotated types.
  *
diff --git a/gson/src/main/java/com/google/gson/annotations/SerializedName.java b/gson/src/main/java/com/google/stripped/gson/annotations/SerializedName.java
similarity index 88%
rename from gson/src/main/java/com/google/gson/annotations/SerializedName.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/SerializedName.java
index 363b95a35..87d2cecf0 100644
--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/SerializedName.java
@@ -14,7 +14,11 @@
  * limitations under the License.
  */
 
-package com.google.gson.annotations;
+package com.google.stripped.gson.annotations;
+
+import com.google.stripped.gson.FieldNamingPolicy;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.GsonBuilder;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -25,10 +29,10 @@
  * An annotation that indicates this member should be serialized to JSON with
  * the provided name value as its field name.
  *
- * <p>This annotation will override any {@link com.google.gson.FieldNamingPolicy}, including
- * the default field naming policy, that may have been set on the {@link com.google.gson.Gson}
+ * <p>This annotation will override any {@link FieldNamingPolicy}, including
+ * the default field naming policy, that may have been set on the {@link Gson}
  * instance.  A different naming policy can set using the {@code GsonBuilder} class.  See
- * {@link com.google.gson.GsonBuilder#setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)}
+ * {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}
  * for more information.</p>
  *
  * <p>Here is an example of how this annotation is meant to be used:</p>
@@ -71,7 +75,7 @@
  * </pre>
  * Note that MyClass.b is now deserialized from either name1, name2 or name3.
  *
- * @see com.google.gson.FieldNamingPolicy
+ * @see FieldNamingPolicy
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
diff --git a/gson/src/main/java/com/google/gson/annotations/Since.java b/gson/src/main/java/com/google/stripped/gson/annotations/Since.java
similarity index 87%
rename from gson/src/main/java/com/google/gson/annotations/Since.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/Since.java
index 541f154b6..55909892f 100644
--- a/gson/src/main/java/com/google/gson/annotations/Since.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/Since.java
@@ -14,7 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson.annotations;
+package com.google.stripped.gson.annotations;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.GsonBuilder;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -26,9 +29,9 @@
  * This annotation is useful to manage versioning of your Json classes for a web-service.
  *
  * <p>
- * This annotation has no effect unless you build {@link com.google.gson.Gson} with a
- * {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#setVersion(double)} method.
+ * This annotation has no effect unless you build {@link Gson} with a
+ * {@link GsonBuilder} and invoke
+ * {@link GsonBuilder#setVersion(double)} method.
  *
  * <p>Here is an example of how this annotation is meant to be used:</p>
  * <pre>
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/stripped/gson/annotations/Until.java
similarity index 89%
rename from gson/src/main/java/com/google/gson/annotations/Until.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/Until.java
index 4648b8a2a..365b678be 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/Until.java
@@ -14,7 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson.annotations;
+package com.google.stripped.gson.annotations;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.GsonBuilder;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -28,9 +31,9 @@
  * is useful to manage versioning of your JSON classes for a web-service.
  *
  * <p>
- * This annotation has no effect unless you build {@link com.google.gson.Gson} with a
- * {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#setVersion(double)} method.
+ * This annotation has no effect unless you build {@link Gson} with a
+ * {@link GsonBuilder} and invoke
+ * {@link GsonBuilder#setVersion(double)} method.
  *
  * <p>Here is an example of how this annotation is meant to be used:</p>
  * <pre>
diff --git a/gson/src/main/java/com/google/gson/annotations/package-info.java b/gson/src/main/java/com/google/stripped/gson/annotations/package-info.java
similarity index 59%
rename from gson/src/main/java/com/google/gson/annotations/package-info.java
rename to gson/src/main/java/com/google/stripped/gson/annotations/package-info.java
index 1c461fd68..59a8298cd 100644
--- a/gson/src/main/java/com/google/gson/annotations/package-info.java
+++ b/gson/src/main/java/com/google/stripped/gson/annotations/package-info.java
@@ -1,6 +1,6 @@
 /**
- * This package provides annotations that can be used with {@link com.google.gson.Gson}.
+ * This package provides annotations that can be used with {@link com.google.stripped.gson.Gson}.
  * 
  * @author Inderjeet Singh, Joel Leitch
  */
-package com.google.gson.annotations;
\ No newline at end of file
+package com.google.stripped.gson.annotations;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java b/gson/src/main/java/com/google/stripped/gson/internal/$Gson$Preconditions.java
similarity index 93%
rename from gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
rename to gson/src/main/java/com/google/stripped/gson/internal/$Gson$Preconditions.java
index f0e7d3fac..4d4ded1cd 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/$Gson$Preconditions.java
@@ -1,49 +1,49 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-/**
- * A simple utility class used to check method Preconditions.
- *
- * <pre>
- * public long divideBy(long value) {
- *   Preconditions.checkArgument(value != 0);
- *   return this.value / value;
- * }
- * </pre>
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class $Gson$Preconditions {
-  private $Gson$Preconditions() {
-    throw new UnsupportedOperationException();
-  }
-
-  public static <T> T checkNotNull(T obj) {
-    if (obj == null) {
-      throw new NullPointerException();
-    }
-    return obj;
-  }
-
-  public static void checkArgument(boolean condition) {
-    if (!condition) {
-      throw new IllegalArgumentException();
-    }
-  }
-}
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.stripped.gson.internal;
+
+/**
+ * A simple utility class used to check method Preconditions.
+ *
+ * <pre>
+ * public long divideBy(long value) {
+ *   Preconditions.checkArgument(value != 0);
+ *   return this.value / value;
+ * }
+ * </pre>
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+public final class $Gson$Preconditions {
+  private $Gson$Preconditions() {
+    throw new UnsupportedOperationException();
+  }
+
+  public static <T> T checkNotNull(T obj) {
+    if (obj == null) {
+      throw new NullPointerException();
+    }
+    return obj;
+  }
+
+  public static void checkArgument(boolean condition) {
+    if (!condition) {
+      throw new IllegalArgumentException();
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/stripped/gson/internal/$Gson$Types.java
similarity index 96%
rename from gson/src/main/java/com/google/gson/internal/$Gson$Types.java
rename to gson/src/main/java/com/google/stripped/gson/internal/$Gson$Types.java
index 017e27cee..0716fb79e 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/$Gson$Types.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.io.Serializable;
 import java.lang.reflect.Array;
@@ -31,9 +31,6 @@
 import java.util.NoSuchElementException;
 import java.util.Properties;
 
-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
-
 /**
  * Static methods for working with types.
  *
@@ -128,7 +125,7 @@ public static Type canonicalize(Type type) {
       // Neal isn't either but suspects some pathological case related
       // to nested classes exists.
       Type rawType = parameterizedType.getRawType();
-      checkArgument(rawType instanceof Class);
+      $Gson$Preconditions.checkArgument(rawType instanceof Class);
       return (Class<?>) rawType;
 
     } else if (type instanceof GenericArrayType) {
@@ -267,7 +264,7 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
    * @param supertype a superclass of, or interface implemented by, this.
    */
   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    checkArgument(supertype.isAssignableFrom(contextRawType));
+    $Gson$Preconditions.checkArgument(supertype.isAssignableFrom(contextRawType));
     return resolve(context, contextRawType,
         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
   }
@@ -431,7 +428,7 @@ private static int indexOf(Object[] array, Object toFind) {
   }
 
   static void checkNotPrimitive(Type type) {
-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
+    $Gson$Preconditions.checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
   }
 
   private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
@@ -445,14 +442,14 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
         Class<?> rawTypeAsClass = (Class<?>) rawType;
         boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())
             || rawTypeAsClass.getEnclosingClass() == null;
-        checkArgument(ownerType != null || isStaticOrTopLevelClass);
+        $Gson$Preconditions.checkArgument(ownerType != null || isStaticOrTopLevelClass);
       }
 
       this.ownerType = ownerType == null ? null : canonicalize(ownerType);
       this.rawType = canonicalize(rawType);
       this.typeArguments = typeArguments.clone();
       for (int t = 0; t < this.typeArguments.length; t++) {
-        checkNotNull(this.typeArguments[t]);
+        $Gson$Preconditions.checkNotNull(this.typeArguments[t]);
         checkNotPrimitive(this.typeArguments[t]);
         this.typeArguments[t] = canonicalize(this.typeArguments[t]);
       }
@@ -536,18 +533,18 @@ public Type getGenericComponentType() {
     private final Type lowerBound;
 
     public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      checkArgument(lowerBounds.length <= 1);
-      checkArgument(upperBounds.length == 1);
+      $Gson$Preconditions.checkArgument(lowerBounds.length <= 1);
+      $Gson$Preconditions.checkArgument(upperBounds.length == 1);
 
       if (lowerBounds.length == 1) {
-        checkNotNull(lowerBounds[0]);
+        $Gson$Preconditions.checkNotNull(lowerBounds[0]);
         checkNotPrimitive(lowerBounds[0]);
-        checkArgument(upperBounds[0] == Object.class);
+        $Gson$Preconditions.checkArgument(upperBounds[0] == Object.class);
         this.lowerBound = canonicalize(lowerBounds[0]);
         this.upperBound = Object.class;
 
       } else {
-        checkNotNull(upperBounds[0]);
+        $Gson$Preconditions.checkNotNull(upperBounds[0]);
         checkNotPrimitive(upperBounds[0]);
         this.lowerBound = null;
         this.upperBound = canonicalize(upperBounds[0]);
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/stripped/gson/internal/ConstructorConstructor.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
rename to gson/src/main/java/com/google/stripped/gson/internal/ConstructorConstructor.java
index 6fc9f2d3e..dfa10fa47 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/ConstructorConstructor.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -38,9 +38,9 @@
 import java.util.concurrent.ConcurrentNavigableMap;
 import java.util.concurrent.ConcurrentSkipListMap;
 
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonIOException;
-import com.google.gson.reflect.TypeToken;
+import com.google.stripped.gson.InstanceCreator;
+import com.google.stripped.gson.JsonIOException;
+import com.google.stripped.gson.reflect.TypeToken;
 
 /**
  * Returns a function that can construct an instance of a requested type.
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/stripped/gson/internal/Excluder.java
similarity index 90%
rename from gson/src/main/java/com/google/gson/internal/Excluder.java
rename to gson/src/main/java/com/google/stripped/gson/internal/Excluder.java
index bef790406..793fba8ad 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/Excluder.java
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
-
-import com.google.gson.ExclusionStrategy;
-import com.google.gson.FieldAttributes;
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.Expose;
-import com.google.gson.annotations.Since;
-import com.google.gson.annotations.Until;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+package com.google.stripped.gson.internal;
+
+import com.google.stripped.gson.ExclusionStrategy;
+import com.google.stripped.gson.FieldAttributes;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.annotations.Expose;
+import com.google.stripped.gson.annotations.Since;
+import com.google.stripped.gson.annotations.Until;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -129,13 +129,6 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
         return delegate().read(in);
       }
 
-      @Override public void write(JsonWriter out, T value) throws IOException {
-        if (skipSerialize) {
-          out.nullValue();
-          return;
-        }
-        delegate().write(out, value);
-      }
 
       private TypeAdapter<T> delegate() {
         TypeAdapter<T> d = delegate;
diff --git a/gson/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java b/gson/src/main/java/com/google/stripped/gson/internal/JsonReaderInternalAccess.java
similarity index 91%
rename from gson/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java
rename to gson/src/main/java/com/google/stripped/gson/internal/JsonReaderInternalAccess.java
index bbd472040..f31675222 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/JsonReaderInternalAccess.java
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
+
+import com.google.stripped.gson.stream.JsonReader;
 
-import com.google.gson.stream.JsonReader;
 import java.io.IOException;
 
 /**
diff --git a/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java b/gson/src/main/java/com/google/stripped/gson/internal/LazilyParsedNumber.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
rename to gson/src/main/java/com/google/stripped/gson/internal/LazilyParsedNumber.java
index 3669af7b5..1c398ddc6 100644
--- a/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/LazilyParsedNumber.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.io.ObjectStreamException;
 import java.math.BigDecimal;
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java b/gson/src/main/java/com/google/stripped/gson/internal/LinkedHashTreeMap.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
rename to gson/src/main/java/com/google/stripped/gson/internal/LinkedHashTreeMap.java
index b2707c50d..f82cb2f1f 100644
--- a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/LinkedHashTreeMap.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.io.ObjectStreamException;
 import java.io.Serializable;
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java b/gson/src/main/java/com/google/stripped/gson/internal/LinkedTreeMap.java
similarity index 99%
rename from gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
rename to gson/src/main/java/com/google/stripped/gson/internal/LinkedTreeMap.java
index 80462742e..72fbbd584 100644
--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/LinkedTreeMap.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.io.ObjectStreamException;
 import java.io.Serializable;
diff --git a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java b/gson/src/main/java/com/google/stripped/gson/internal/ObjectConstructor.java
similarity index 95%
rename from gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
rename to gson/src/main/java/com/google/stripped/gson/internal/ObjectConstructor.java
index 6ef20607f..801d6417b 100644
--- a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/ObjectConstructor.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 /**
  * Defines a generic object construction factory.  The purpose of this class
diff --git a/gson/src/main/java/com/google/gson/internal/Primitives.java b/gson/src/main/java/com/google/stripped/gson/internal/Primitives.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/internal/Primitives.java
rename to gson/src/main/java/com/google/stripped/gson/internal/Primitives.java
index a98f6242a..250b9d595 100644
--- a/gson/src/main/java/com/google/gson/internal/Primitives.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/Primitives.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 
 import java.lang.reflect.Type;
diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/stripped/gson/internal/Streams.java
similarity index 82%
rename from gson/src/main/java/com/google/gson/internal/Streams.java
rename to gson/src/main/java/com/google/stripped/gson/internal/Streams.java
index 74956d777..a63209b89 100644
--- a/gson/src/main/java/com/google/gson/internal/Streams.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/Streams.java
@@ -14,17 +14,17 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
+
+import com.google.stripped.gson.JsonElement;
+import com.google.stripped.gson.JsonIOException;
+import com.google.stripped.gson.JsonNull;
+import com.google.stripped.gson.JsonParseException;
+import com.google.stripped.gson.JsonSyntaxException;
+import com.google.stripped.gson.internal.bind.TypeAdapters;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.MalformedJsonException;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import com.google.gson.stream.MalformedJsonException;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Writer;
@@ -65,13 +65,6 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
     }
   }
 
-  /**
-   * Writes the JSON element to the writer, recursively.
-   */
-  public static void write(JsonElement element, JsonWriter writer) throws IOException {
-    TypeAdapters.JSON_ELEMENT.write(writer, element);
-  }
-
   @SuppressWarnings("resource")
   public static Writer writerForAppendable(Appendable appendable) {
     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/stripped/gson/internal/UnsafeAllocator.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
rename to gson/src/main/java/com/google/stripped/gson/internal/UnsafeAllocator.java
index fce0be379..94c7f3ead 100644
--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/UnsafeAllocator.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.google.stripped.gson.internal;
 
 import java.io.ObjectInputStream;
 import java.io.ObjectStreamClass;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/ArrayTypeAdapter.java
similarity index 76%
rename from gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/ArrayTypeAdapter.java
index 3fb7c0568..4e2e73994 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/ArrayTypeAdapter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.stripped.gson.internal.bind;
 
 import java.io.IOException;
 import java.lang.reflect.Array;
@@ -23,14 +23,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.internal.$Gson$Types;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
 
 /**
  * Adapt an array of objects.
@@ -80,18 +79,5 @@ public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class
     return array;
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public void write(JsonWriter out, Object array) throws IOException {
-    if (array == null) {
-      out.nullValue();
-      return;
-    }
 
-    out.beginArray();
-    for (int i = 0, length = Array.getLength(array); i < length; i++) {
-      E value = (E) Array.get(array, i);
-      componentTypeAdapter.write(out, value);
-    }
-    out.endArray();
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/CollectionTypeAdapterFactory.java
similarity index 77%
rename from gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/CollectionTypeAdapterFactory.java
index 1d57844a4..3415e048e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -14,18 +14,18 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.stripped.gson.internal.bind;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.internal.$Gson$Types;
+import com.google.stripped.gson.internal.ConstructorConstructor;
+import com.google.stripped.gson.internal.ObjectConstructor;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
 
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.Collection;
@@ -85,18 +85,5 @@ public Adapter(Gson context, Type elementType,
       in.endArray();
       return collection;
     }
-
-    @Override public void write(JsonWriter out, Collection<E> collection) throws IOException {
-      if (collection == null) {
-        out.nullValue();
-        return;
-      }
-
-      out.beginArray();
-      for (E element : collection) {
-        elementTypeAdapter.write(out, element);
-      }
-      out.endArray();
-    }
   }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
similarity index 87%
rename from gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 3801cfd4d..76005226e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.stripped.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.JsonAdapter;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.reflect.TypeToken;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.annotations.JsonAdapter;
+import com.google.stripped.gson.internal.ConstructorConstructor;
+import com.google.stripped.gson.reflect.TypeToken;
 
 /**
  * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/JsonTreeReader.java
similarity index 94%
rename from gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/JsonTreeReader.java
index 6a8362805..904448302 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/JsonTreeReader.java
@@ -14,15 +14,16 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
-
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
+package com.google.stripped.gson.internal.bind;
+
+import com.google.stripped.gson.JsonArray;
+import com.google.stripped.gson.JsonElement;
+import com.google.stripped.gson.JsonNull;
+import com.google.stripped.gson.JsonObject;
+import com.google.stripped.gson.JsonPrimitive;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/MapTypeAdapterFactory.java
similarity index 75%
rename from gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/MapTypeAdapterFactory.java
index 1682aad04..51e5a7ecb 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/MapTypeAdapterFactory.java
@@ -14,27 +14,24 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.stripped.gson.internal.bind;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.JsonElement;
+import com.google.stripped.gson.JsonPrimitive;
+import com.google.stripped.gson.JsonSyntaxException;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.internal.$Gson$Types;
+import com.google.stripped.gson.internal.ConstructorConstructor;
+import com.google.stripped.gson.internal.JsonReaderInternalAccess;
+import com.google.stripped.gson.internal.ObjectConstructor;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.JsonReaderInternalAccess;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.internal.Streams;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -60,7 +57,7 @@
  * But GSON is unable to deserialize this value because the JSON string name is
  * just the {@link Object#toString() toString()} of the map key. Attempting to
  * convert the above JSON to an object fails with a parse exception:
- * <pre>com.google.gson.JsonParseException: Expecting object found: "(5,6)"
+ * <pre>JsonParseException: Expecting object found: "(5,6)"
  *   at com.google.gson.JsonObjectDeserializationVisitor.visitFieldUsingCustomHandler
  *   at com.google.gson.ObjectNavigator.navigateClassFields
  *   ...</pre>
@@ -195,52 +192,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
       return map;
     }
 
-    @Override public void write(JsonWriter out, Map<K, V> map) throws IOException {
-      if (map == null) {
-        out.nullValue();
-        return;
-      }
-
-      if (!complexMapKeySerialization) {
-        out.beginObject();
-        for (Map.Entry<K, V> entry : map.entrySet()) {
-          out.name(String.valueOf(entry.getKey()));
-          valueTypeAdapter.write(out, entry.getValue());
-        }
-        out.endObject();
-        return;
-      }
-
-      boolean hasComplexKeys = false;
-      List<JsonElement> keys = new ArrayList<JsonElement>(map.size());
-
-      List<V> values = new ArrayList<V>(map.size());
-      for (Map.Entry<K, V> entry : map.entrySet()) {
-        JsonElement keyElement = keyTypeAdapter.toJsonTree(entry.getKey());
-        keys.add(keyElement);
-        values.add(entry.getValue());
-        hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject();
-      }
 
-      if (hasComplexKeys) {
-        out.beginArray();
-        for (int i = 0; i < keys.size(); i++) {
-          out.beginArray(); // entry array
-          Streams.write(keys.get(i), out);
-          valueTypeAdapter.write(out, values.get(i));
-          out.endArray();
-        }
-        out.endArray();
-      } else {
-        out.beginObject();
-        for (int i = 0; i < keys.size(); i++) {
-          JsonElement keyElement = keys.get(i);
-          out.name(keyToString(keyElement));
-          valueTypeAdapter.write(out, values.get(i));
-        }
-        out.endObject();
-      }
-    }
 
     private String keyToString(JsonElement keyElement) {
       if (keyElement.isJsonPrimitive()) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/ObjectTypeAdapter.java
similarity index 71%
rename from gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/ObjectTypeAdapter.java
index ec42e0482..c9e7baff6 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/ObjectTypeAdapter.java
@@ -14,16 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.stripped.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.LinkedTreeMap;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.internal.LinkedTreeMap;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -76,10 +75,10 @@
       return in.nextString();
 
     case NUMBER:
-      return in.nextDouble();
+      return Integer.valueOf(in.nextInt());
 
     case BOOLEAN:
-      return in.nextBoolean();
+      return Boolean.valueOf(in.nextBoolean());
 
     case NULL:
       in.nextNull();
@@ -90,20 +89,5 @@
     }
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public void write(JsonWriter out, Object value) throws IOException {
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-
-    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
-    if (typeAdapter instanceof ObjectTypeAdapter) {
-      out.beginObject();
-      out.endObject();
-      return;
-    }
 
-    typeAdapter.write(out, value);
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/ReflectiveTypeAdapterFactory.java
similarity index 80%
rename from gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
rename to gson/src/main/java/com/google/stripped/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index c87cdbf16..5398c2a0f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -14,24 +14,24 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
-
-import com.google.gson.FieldNamingStrategy;
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.JsonAdapter;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.internal.Primitives;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+package com.google.stripped.gson.internal.bind;
+
+import com.google.stripped.gson.FieldNamingStrategy;
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.JsonSyntaxException;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.annotations.JsonAdapter;
+import com.google.stripped.gson.annotations.SerializedName;
+import com.google.stripped.gson.internal.$Gson$Types;
+import com.google.stripped.gson.internal.ConstructorConstructor;
+import com.google.stripped.gson.internal.Excluder;
+import com.google.stripped.gson.internal.ObjectConstructor;
+import com.google.stripped.gson.internal.Primitives;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
@@ -40,7 +40,7 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
+import static com.google.stripped.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -104,13 +104,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
       final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
-      @Override void write(JsonWriter writer, Object value)
-          throws IOException, IllegalAccessException {
-        Object fieldValue = field.get(value);
-        TypeAdapter t =
-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());
-        t.write(writer, fieldValue);
-      }
+
       @Override void read(JsonReader reader, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
@@ -184,7 +178,7 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
       this.deserialized = deserialized;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
-    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
+
     abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;
   }
 
@@ -225,24 +219,5 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
       return instance;
     }
 
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
-
-      out.beginObject();
-      try {
-        for (BoundField boundField : boundFields.values()) {
-          if (boundField.writeField(value)) {
-            out.name(boundField.name);
-            boundField.write(out, value);
-          }
-        }
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-      out.endObject();
-    }
   }
 }
diff --git a/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
new file mode 100644
index 000000000..7b4ac68c6
--- /dev/null
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.stripped.gson.internal.bind;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.stream.JsonReader;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
+final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
+  private final Gson context;
+  private final TypeAdapter<T> delegate;
+  private final Type type;
+
+  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
+    this.context = context;
+    this.delegate = delegate;
+    this.type = type;
+  }
+
+  @Override
+  public T read(JsonReader in) throws IOException {
+    return delegate.read(in);
+  }
+
+  @SuppressWarnings({"rawtypes", "unchecked"})
+
+  /**
+   * Finds a compatible runtime type if it is more specific
+   */
+  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
+    if (value != null
+        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
+      type = value.getClass();
+    }
+    return type;
+  }
+}
diff --git a/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapters.java
new file mode 100644
index 000000000..65e506cd3
--- /dev/null
+++ b/gson/src/main/java/com/google/stripped/gson/internal/bind/TypeAdapters.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.stripped.gson.internal.bind;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+import java.util.Map;
+
+import com.google.stripped.gson.Gson;
+import com.google.stripped.gson.JsonArray;
+import com.google.stripped.gson.JsonElement;
+import com.google.stripped.gson.JsonNull;
+import com.google.stripped.gson.JsonObject;
+import com.google.stripped.gson.JsonPrimitive;
+import com.google.stripped.gson.JsonSyntaxException;
+import com.google.stripped.gson.TypeAdapter;
+import com.google.stripped.gson.TypeAdapterFactory;
+import com.google.stripped.gson.annotations.SerializedName;
+import com.google.stripped.gson.internal.LazilyParsedNumber;
+import com.google.stripped.gson.reflect.TypeToken;
+import com.google.stripped.gson.stream.JsonReader;
+import com.google.stripped.gson.stream.JsonToken;
+
+/**
+ * Type adapters for basic types.
+ */
+public final class TypeAdapters {
+  private TypeAdapters() {
+    throw new UnsupportedOperationException();
+  }
+
+  @SuppressWarnings("rawtypes")
+  public static final TypeAdapter<Class> CLASS         = new TypeAdapter<Class>()
+  {
+
+    @Override
+    public Class read(JsonReader in) throws IOException
+    {
+      if (in.peek() == JsonToken.NULL)
+      {
+        in.nextNull();
+        return null;
+      }
+      else
+      {
+        throw new UnsupportedOperationException(
+                "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
+      }
+    }
+  };
+
+  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
+
+
+
+  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
+    @Override
+    public Boolean read(JsonReader in) throws IOException {
+      if (in.peek() == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      } else if (in.peek() == JsonToken.STRING) {
+        // support strings for compatibility with GSON 1.7
+        return Boolean.parseBoolean(in.nextString());
+      }
+      return in.nextBoolean();
+    }
+
+  };
+
+  /**
+   * Writes a boolean as a string. Useful for map keys, where booleans aren't
+   * otherwise permitted.
+   */
+  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {
+    @Override public Boolean read(JsonReader in) throws IOException {
+      if (in.peek() == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+      return Boolean.valueOf(in.nextString());
+    }
+
+
+  };
+
+  public static final TypeAdapterFactory BOOLEAN_FACTORY
+      = newFactory(boolean.class, Boolean.class, BOOLEAN);
+
+  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {
+    @Override
+    public Number read(JsonReader in) throws IOException {
+      if (in.peek() == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+      try {
+        return in.nextInt();
+      } catch (NumberFormatException e) {
+        throw new JsonSyntaxException(e);
+      }
+    }
+
+  };
+  public static final TypeAdapterFactory INTEGER_FACTORY
+      = newFactory(int.class, Integer.class, INTEGER);
+
+
+  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {
+    @Override
+    public String read(JsonReader in) throws IOException {
+      JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+      /* coerce booleans to strings for backwards compatibility */
+      if (peek == JsonToken.BOOLEAN) {
+        return Boolean.toString(in.nextBoolean());
+      }
+      return in.nextString();
+    }
+
+  };
+
+  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);
+
+  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {
+    @Override public JsonElement read(JsonReader in) throws IOException {
+      switch (in.peek()) {
+      case STRING:
+        return new JsonPrimitive(in.nextString());
+      case NUMBER:
+        String number = in.nextString();
+        return new JsonPrimitive(new LazilyParsedNumber(number));
+      case BOOLEAN:
+        return new JsonPrimitive(in.nextBoolean());
+      case NULL:
+        in.nextNull();
+        return JsonNull.INSTANCE;
+      case BEGIN_ARRAY:
+        JsonArray array = new JsonArray();
+        in.beginArray();
+        while (in.hasNext()) {
+          array.add(read(in));
+        }
+        in.endArray();
+        return array;
+      case BEGIN_OBJECT:
+        JsonObject object = new JsonObject();
+        in.beginObject();
+        while (in.hasNext()) {
+          object.add(in.nextName(), read(in));
+        }
+        in.endObject();
+        return object;
+      case END_DOCUMENT:
+      case NAME:
+      case END_OBJECT:
+      case END_ARRAY:
+      default:
+        throw new IllegalArgumentException();
+      }
+    }
+
+  };
+
+  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY
+      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
+
+  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
+    private final Map<String, T> nameToConstant = new HashMap<String, T>();
+    private final Map<T, String> constantToName = new HashMap<T, String>();
+
+    public EnumTypeAdapter(Class<T> classOfT) {
+      try {
+        for (T constant : classOfT.getEnumConstants()) {
+          String name = constant.name();
+          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
+          if (annotation != null) {
+            name = annotation.value();
+            for (String alternate : annotation.alternate()) {
+              nameToConstant.put(alternate, constant);
+            }
+          }
+          nameToConstant.put(name, constant);
+          constantToName.put(constant, name);
+        }
+      } catch (NoSuchFieldException e) {
+        AssertionError assertionError = new AssertionError("Missing field in " + classOfT.getName());
+        assertionError.initCause(e);
+        throw assertionError;
+      }
+    }
+    @Override public T read(JsonReader in) throws IOException {
+      if (in.peek() == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+      return nameToConstant.get(in.nextString());
+    }
+
+  }
+
+  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+      Class<? super T> rawType = typeToken.getRawType();
+      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {
+        return null;
+      }
+      if (!rawType.isEnum()) {
+        rawType = rawType.getSuperclass(); // handle anonymous subclasses
+      }
+      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);
+    }
+  };
+
+  public static <TT> TypeAdapterFactory newFactory(
+      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {
+    return new TypeAdapterFactory() {
+      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
+      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;
+      }
+    };
+  }
+
+  public static <TT> TypeAdapterFactory newFactory(
+      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {
+    return new TypeAdapterFactory() {
+      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
+      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;
+      }
+      @Override public String toString() {
+        return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]";
+      }
+    };
+  }
+
+  public static <TT> TypeAdapterFactory newFactory(
+      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {
+    return new TypeAdapterFactory() {
+      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
+      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+        Class<? super T> rawType = typeToken.getRawType();
+        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;
+      }
+      @Override public String toString() {
+        return "Factory[type=" + boxed.getName()
+            + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]";
+      }
+    };
+  }
+
+  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,
+      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {
+    return new TypeAdapterFactory() {
+      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
+      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+        Class<? super T> rawType = typeToken.getRawType();
+        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;
+      }
+      @Override public String toString() {
+        return "Factory[type=" + base.getName()
+            + "+" + sub.getName() + ",adapter=" + typeAdapter + "]";
+      }
+    };
+  }
+
+  /**
+   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
+   * that the deserialized type matches the type requested.
+   */
+  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(
+      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
+    return new TypeAdapterFactory() {
+      @SuppressWarnings("unchecked")
+      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
+        final Class<? super T2> requestedType = typeToken.getRawType();
+        if (!clazz.isAssignableFrom(requestedType)) {
+          return null;
+        }
+        return (TypeAdapter<T2>) new TypeAdapter<T1>() {
+
+          @Override public T1 read(JsonReader in) throws IOException {
+            T1 result = typeAdapter.read(in);
+            if (result != null && !requestedType.isInstance(result)) {
+              throw new JsonSyntaxException("Expected a " + requestedType.getName()
+                  + " but was " + result.getClass().getName());
+            }
+            return result;
+          }
+        };
+      }
+      @Override public String toString() {
+        return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";
+      }
+    };
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/package-info.java b/gson/src/main/java/com/google/stripped/gson/internal/package-info.java
similarity index 85%
rename from gson/src/main/java/com/google/gson/internal/package-info.java
rename to gson/src/main/java/com/google/stripped/gson/internal/package-info.java
index b5139b6de..d25c1ff52 100644
--- a/gson/src/main/java/com/google/gson/internal/package-info.java
+++ b/gson/src/main/java/com/google/stripped/gson/internal/package-info.java
@@ -4,4 +4,4 @@
  *
  * @author Inderjeet Singh, Joel Leitch, Jesse Wilson
  */
-package com.google.gson.internal;
\ No newline at end of file
+package com.google.stripped.gson.internal;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/stripped/gson/package-info.java b/gson/src/main/java/com/google/stripped/gson/package-info.java
new file mode 100644
index 000000000..c850250bc
--- /dev/null
+++ b/gson/src/main/java/com/google/stripped/gson/package-info.java
@@ -0,0 +1,11 @@
+/**
+ * This package provides the {@link com.google.stripped.gson.Gson} class to convert Json to Java and
+ * vice-versa.
+ *
+ * <p>The primary class to use is {@link com.google.stripped.gson.Gson} which can be constructed with
+ * {@code new Gson()} (using default settings) or by using {@link com.google.stripped.gson.GsonBuilder}
+ * (to configure various options such as using versioning and so on).</p>
+ *
+ * @author Inderjeet Singh, Joel Leitch
+ */
+package com.google.stripped.gson;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/stripped/gson/reflect/TypeToken.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/reflect/TypeToken.java
rename to gson/src/main/java/com/google/stripped/gson/reflect/TypeToken.java
index e16e8e6dc..35e2f4119 100644
--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java
+++ b/gson/src/main/java/com/google/stripped/gson/reflect/TypeToken.java
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package com.google.gson.reflect;
+package com.google.stripped.gson.reflect;
+
+import com.google.stripped.gson.internal.$Gson$Types;
+import com.google.stripped.gson.internal.$Gson$Preconditions;
 
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.$Gson$Preconditions;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -107,7 +108,6 @@ public final Type getType() {
    * @deprecated this implementation may be inconsistent with javac for types
    *     with wildcards.
    */
-  @Deprecated
   public boolean isAssignableFrom(Class<?> cls) {
     return isAssignableFrom((Type) cls);
   }
@@ -118,7 +118,6 @@ public boolean isAssignableFrom(Class<?> cls) {
    * @deprecated this implementation may be inconsistent with javac for types
    *     with wildcards.
    */
-  @Deprecated
   public boolean isAssignableFrom(Type from) {
     if (from == null) {
       return false;
@@ -148,7 +147,6 @@ public boolean isAssignableFrom(Type from) {
    * @deprecated this implementation may be inconsistent with javac for types
    *     with wildcards.
    */
-  @Deprecated
   public boolean isAssignableFrom(TypeToken<?> token) {
     return isAssignableFrom(token.getType());
   }
diff --git a/gson/src/main/java/com/google/gson/reflect/package-info.java b/gson/src/main/java/com/google/stripped/gson/reflect/package-info.java
similarity index 77%
rename from gson/src/main/java/com/google/gson/reflect/package-info.java
rename to gson/src/main/java/com/google/stripped/gson/reflect/package-info.java
index e666c4311..83be38160 100644
--- a/gson/src/main/java/com/google/gson/reflect/package-info.java
+++ b/gson/src/main/java/com/google/stripped/gson/reflect/package-info.java
@@ -3,4 +3,4 @@
  *  
  * @author Inderjeet Singh, Joel Leitch
  */
-package com.google.gson.reflect;
\ No newline at end of file
+package com.google.stripped.gson.reflect;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/stripped/gson/stream/JsonReader.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/stream/JsonReader.java
rename to gson/src/main/java/com/google/stripped/gson/stream/JsonReader.java
index 838355cb4..1747ce7f8 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/stripped/gson/stream/JsonReader.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.google.stripped.gson.stream;
 
-import com.google.gson.internal.JsonReaderInternalAccess;
-import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.stripped.gson.internal.JsonReaderInternalAccess;
+import com.google.stripped.gson.internal.bind.JsonTreeReader;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
@@ -771,7 +771,7 @@ private boolean isLiteral(char c) throws IOException {
   }
 
   /**
-   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
+   * Returns the next token, a {@link JsonToken#NAME property name}, and
    * consumes it.
    *
    * @throws java.io.IOException if the next token in the stream is not a property
@@ -799,7 +799,7 @@ public String nextName() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
+   * Returns the {@link JsonToken#STRING string} value of the next token,
    * consuming it. If the next token is a number, this method will return its
    * string form.
    *
@@ -836,7 +836,7 @@ public String nextString() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
+   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,
    * consuming it.
    *
    * @throws IllegalStateException if the next token is not a boolean or if
@@ -882,7 +882,7 @@ public void nextNull() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
+   * Returns the {@link JsonToken#NUMBER double} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as a double using {@link Double#parseDouble(String)}.
    *
@@ -927,7 +927,7 @@ public double nextDouble() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
+   * Returns the {@link JsonToken#NUMBER long} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as a long. If the next token's numeric value cannot be exactly
    * represented by a Java {@code long}, this method throws.
@@ -1149,7 +1149,7 @@ private void skipUnquotedValue() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
+   * Returns the {@link JsonToken#NUMBER int} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as an int. If the next token's numeric value cannot be exactly
    * represented by a Java {@code int}, this method throws.
diff --git a/gson/src/main/java/com/google/gson/stream/JsonScope.java b/gson/src/main/java/com/google/stripped/gson/stream/JsonScope.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/stream/JsonScope.java
rename to gson/src/main/java/com/google/stripped/gson/stream/JsonScope.java
index da6913727..d9d9931ba 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonScope.java
+++ b/gson/src/main/java/com/google/stripped/gson/stream/JsonScope.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.google.stripped.gson.stream;
 
 /**
  * Lexical scoping elements within a JSON reader or writer.
diff --git a/gson/src/main/java/com/google/gson/stream/JsonToken.java b/gson/src/main/java/com/google/stripped/gson/stream/JsonToken.java
similarity index 98%
rename from gson/src/main/java/com/google/gson/stream/JsonToken.java
rename to gson/src/main/java/com/google/stripped/gson/stream/JsonToken.java
index f1025b3f4..9012b6e2e 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonToken.java
+++ b/gson/src/main/java/com/google/stripped/gson/stream/JsonToken.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.google.stripped.gson.stream;
 
 /**
  * A structure, name or value type in a JSON-encoded string.
diff --git a/gson/src/main/java/com/google/gson/stream/MalformedJsonException.java b/gson/src/main/java/com/google/stripped/gson/stream/MalformedJsonException.java
similarity index 97%
rename from gson/src/main/java/com/google/gson/stream/MalformedJsonException.java
rename to gson/src/main/java/com/google/stripped/gson/stream/MalformedJsonException.java
index 9da70ebcc..51aa6d3cb 100644
--- a/gson/src/main/java/com/google/gson/stream/MalformedJsonException.java
+++ b/gson/src/main/java/com/google/stripped/gson/stream/MalformedJsonException.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.google.stripped.gson.stream;
 
 import java.io.IOException;
 
