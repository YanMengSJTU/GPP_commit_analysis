diff --git a/gson/src/main/java/com/google/gson/DateFormatPolicy.java b/gson/src/main/java/com/google/gson/DateFormatPolicy.java
deleted file mode 100644
index 4ab7ec01f..000000000
--- a/gson/src/main/java/com/google/gson/DateFormatPolicy.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.util.Date;
-
-public enum DateFormatPolicy {
-
-  
-  EN_US
-  },
-
-  /**
-   * Using this naming policy with Gson will ensure that the first "letter" of the Java
-   * field name is capitalized when serialized to its JSON form.
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> SomeFieldName</li>
-   *   <li>_someFieldName ---> _SomeFieldName</li>
-   * </ul>
-   */
-  UPPER_CAMEL_CASE() {
-    @Override public String translateName(Field f) {
-      return upperCaseFirstLetter(f.getName());
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will ensure that the first "letter" of the Java
-   * field name is capitalized when serialized to its JSON form and the words will be
-   * separated by a space.
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> Some Field Name</li>
-   *   <li>_someFieldName ---> _Some Field Name</li>
-   * </ul>
-   *
-   * @since 1.4
-   */
-  UPPER_CAMEL_CASE_WITH_SPACES() {
-    @Override public String translateName(Field f) {
-      return upperCaseFirstLetter(separateCamelCase(f.getName(), " "));
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will modify the Java Field name from its camel cased
-   * form to a lower case field name where each word is separated by an underscore (_).
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> some_field_name</li>
-   *   <li>_someFieldName ---> _some_field_name</li>
-   *   <li>aStringField ---> a_string_field</li>
-   *   <li>aURL ---> a_u_r_l</li>
-   * </ul>
-   */
-  LOWER_CASE_WITH_UNDERSCORES() {
-    @Override public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will modify the Java Field name from its camel cased
-   * form to a lower case field name where each word is separated by a dash (-).
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> some-field-name</li>
-   *   <li>_someFieldName ---> _some-field-name</li>
-   *   <li>aStringField ---> a-string-field</li>
-   *   <li>aURL ---> a-u-r-l</li>
-   * </ul>
-   * Using dashes in JavaScript is not recommended since dash is also used for a minus sign in
-   * expressions. This requires that a field named with dashes is always accessed as a quoted
-   * property like {@code myobject['my-field']}. Accessing it as an object field
-   * {@code myobject.my-field} will result in an unintended javascript expression.
-   * @since 1.4
-   */
-  LOWER_CASE_WITH_DASHES() {
-    @Override public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
-    }
-  };
-  
-	@Override
-	public String format(Date date) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-}
diff --git a/gson/src/main/java/com/google/gson/DateFormatType.java b/gson/src/main/java/com/google/gson/DateFormatType.java
new file mode 100644
index 000000000..fbf34b15d
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/DateFormatType.java
@@ -0,0 +1,5 @@
+package com.google.gson;
+
+public enum DateFormatType {
+	EN_US, LOCAL, ISO_8601, CUSTOM;
+}
diff --git a/gson/src/main/java/com/google/gson/DateFormatter.java b/gson/src/main/java/com/google/gson/DateFormatter.java
index acf3e3e16..c1b64b775 100644
--- a/gson/src/main/java/com/google/gson/DateFormatter.java
+++ b/gson/src/main/java/com/google/gson/DateFormatter.java
@@ -3,7 +3,7 @@
 import java.text.ParseException;
 import java.util.Date;
 
-public interface DateFormatter {
+interface DateFormatter {
 
 	String format(Date date);
 	Date parse(String dateAsString) throws ParseException;
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 81700e638..625001109 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -23,6 +23,8 @@
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.EnumMap;
+import java.util.EnumSet;
 import java.util.Locale;
 import java.util.TimeZone;
 
@@ -38,41 +40,65 @@
 final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
 
   // TODO: migrate to streaming adapter
-
+	
+	private final EnumMap<DateFormatType, DateFormatter> dateFormats;
+	private final DateFormatType outputDateFormatType;
+	
   private final DateFormat enUsFormat;
   private final DateFormat localFormat;
 
   DefaultDateTypeAdapter() {
+    this(DateFormatType.EN_US);
+  }
+  
+  DefaultDateTypeAdapter(DateFormatType outputFormat) {
     this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT),
+        outputFormat);
   }
 
   DefaultDateTypeAdapter(String datePattern) {
-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+    this(new SimpleDateFormat(datePattern, Locale.US),
+    		new SimpleDateFormat(datePattern),
+    		DateFormatType.EN_US);
+  }
+  
+  DefaultDateTypeAdapter(DateFormat dateFormat) {
+  	this(DateFormatType.CUSTOM);
+    dateFormats.put(DateFormatType.CUSTOM, new SimpleDateFormatter(dateFormat));
   }
 
   DefaultDateTypeAdapter(int style) {
-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+    this(DateFormat.getDateInstance(style, Locale.US),
+    		DateFormat.getDateInstance(style),
+    		DateFormatType.EN_US);
   }
 
   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
     this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+        DateFormat.getDateTimeInstance(dateStyle, timeStyle),
+        DateFormatType.EN_US);
   }
 
-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {
+  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat, DateFormatType outputFormat) {
+  	dateFormats = new EnumMap<DateFormatType, DateFormatter>(DateFormatType.class);
+  	SimpleDateFormatter usFormatter = new SimpleDateFormatter(enUsFormat);
+  	dateFormats.put(DateFormatType.EN_US, usFormatter);
+  	
+  	// Set Custom to US to prevent null pointer
+  	dateFormats.put(DateFormatType.CUSTOM, usFormatter);
+  	dateFormats.put(DateFormatType.LOCAL, new SimpleDateFormatter(localFormat));
+  	dateFormats.put(DateFormatType.ISO_8601, ISO8601DateFormater.getInstance());
+  	
+  	outputDateFormatType = outputFormat;
     this.enUsFormat = enUsFormat;
     this.localFormat = localFormat;
   }
 
-  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
-  // See issue 162
   @Override
   public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
-    synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(src);
-      return new JsonPrimitive(dateFormatAsString);
-    }
+  	String dateFormatAsString = dateFormats.get(outputDateFormatType).format(src);
+  	return new JsonPrimitive(dateFormatAsString);
   }
 
   @Override
@@ -94,19 +120,20 @@ public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationConte
   }
 
   private Date deserializeToDate(JsonElement json) {
-    synchronized (localFormat) {
-      try {
-      	return localFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
-      try {
-        return enUsFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {}
-      try {
-        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));
-      } catch (ParseException e) {
-        throw new JsonSyntaxException(json.getAsString(), e);
-      }
-    }
+  	String jsonString = json.getAsString();
+  	
+  	ParseException parseExc = null; // Hopefully will not be used
+  	
+  	for(DateFormatter dateFormatter : dateFormats.values() )
+  	{
+  		try{
+  			return dateFormatter.parse(jsonString);
+  		} catch (ParseException e) {
+  			parseExc = e;
+  		}
+  	}
+  	
+  	throw new JsonSyntaxException(jsonString, parseExc);
   }
 
   @Override
diff --git a/gson/src/main/java/com/google/gson/ISO8601DateFormatter.java b/gson/src/main/java/com/google/gson/ISO8601DateFormatter.java
index 865402c34..4b0b7dfa1 100644
--- a/gson/src/main/java/com/google/gson/ISO8601DateFormatter.java
+++ b/gson/src/main/java/com/google/gson/ISO8601DateFormatter.java
@@ -6,8 +6,12 @@
 
 import com.google.gson.internal.bind.util.ISO8601Utils;
 
-final class ISO8601DateFormat implements DateFormatter
+final class ISO8601DateFormater implements DateFormatter
 {
+	private ISO8601DateFormater(){};
+	
+	private final static ISO8601DateFormater INSTANCE = new ISO8601DateFormater();
+	
 	@Override
 	public String format(Date date) {
 		return ISO8601Utils.format(date, true);
@@ -18,4 +22,9 @@ public Date parse(String dateAsString) throws ParseException {
 		return ISO8601Utils.parse(dateAsString, new ParsePosition(0));
 	}
 	
+	public static ISO8601DateFormater getInstance()
+	{
+		return INSTANCE;
+	}
+	
 }
diff --git a/gson/src/main/java/com/google/gson/SimpleDateFormatter.java b/gson/src/main/java/com/google/gson/SimpleDateFormatter.java
index bd6dd56ec..c21078d41 100644
--- a/gson/src/main/java/com/google/gson/SimpleDateFormatter.java
+++ b/gson/src/main/java/com/google/gson/SimpleDateFormatter.java
@@ -9,9 +9,12 @@
 	private final DateFormat dateFormat;
 	
 	SimpleDateFormatter(DateFormat dateFormat) {
-    this.dateFormat = dateFormat;
+		// Clone to prevent object from change
+    this.dateFormat = (DateFormat) dateFormat.clone();
   }
 
+//These methods need to be synchronized since JDK DateFormat classes are not thread-safe
+ // See issue 162
 	@Override
 	public String format(Date date) {
 		synchronized (dateFormat) {
diff --git a/gson/src/main/java/com/google/gson/wip2.java b/gson/src/main/java/com/google/gson/wip2.java
index b45b01f0b..2d1a13bea 100644
--- a/gson/src/main/java/com/google/gson/wip2.java
+++ b/gson/src/main/java/com/google/gson/wip2.java
@@ -1,28 +1,52 @@
 package com.google.gson;
 
 import java.text.SimpleDateFormat;
+import java.util.Arrays;
 import java.util.Date;
+import java.util.EnumMap;
+import java.util.TimeZone;
 
 public class wip2 {
 
-    public static void main(String[] args) {
-	Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").create();
-	String json = "{'date': \"2015-11-19\"}";//  "{'date': \"2015-11-19T18:33:51Z\"}"; 
-	MyDateJson datDate = gson.fromJson(json, MyDateJson.class);
-	Date date = datDate.getDate();
-    }
-    
-    private class MyDateJson
-    {
-	private Date date;
-
-	public Date getDate() {
-	    return date;
+	public static void main(String[] args) {
+		/*Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").create();
+		String json = "{'date': \"2015-11-19\"}";// "{'date':
+																						 // \"2015-11-19T18:33:51Z\"}";
+		MyDateJson datDate = gson.fromJson(json, MyDateJson.class);
+		Date date = datDate.getDate();*/
+		Date date = new Date();
+		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
+		SimpleDateFormatter formatter = new SimpleDateFormatter(format);
+		String formattedDate = formatter.format(date);
+		format.setTimeZone(TimeZone.getTimeZone("UTC"));
+		String formattedDate2 = formatter.format(date);
+		
+		boolean equal = formattedDate.equals(formattedDate2);
+		
+		String[] str = {"a", "b"};
+		String[] str2 = {"aa", "bb"};
+		
+		EnumMap<Letters, String> emap = new EnumMap<Letters, String>(Letters.class);
+		emap.put(Letters.A, "yo");
+		String yo = emap.get(Letters.A);
+	}
+	
+	public enum Letters
+	{
+		A,
+		B;
 	}
 
-	public void setDate(Date date) {
-	    this.date = date;
+	private class MyDateJson {
+		private Date date;
+
+		public Date getDate() {
+			return date;
+		}
+
+		public void setDate(Date date) {
+			this.date = date;
+		}
 	}
-    }
 
 }
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
index d414e9c8c..23191ea84 100644
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
@@ -61,6 +61,113 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
       Locale.setDefault(defaultLocale);
     }
   }
+  
+  public void testOutputFormattedWithCustomDateFormat()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateFormat);
+    try {
+    	assertFormatted("1970-01-01", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
+  
+  public void testOutputFormattedWithCustomDateFormatDifferentTimeZone()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX");
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateFormat);
+    try {
+    	assertFormatted("1969-12-31T16:00:00-08", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
+  
+  public void testOutputFormattedWithIsoFormat()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(DateFormatType.ISO_8601);
+    try {
+    	assertFormatted("1970-01-01T00:00:00.000Z", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
+  
+  public void testOutputFormattedWithCustomFranceFormatter()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.FRANCE);
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateFormat);
+    try {
+    	// Can parse US
+    	assertParsed("Jan 1, 1970 12:00:00 AM", dateTypeAdapter);
+    	// Can parse FR
+    	assertParsed("1 janv. 1970 00:00:00", dateTypeAdapter);
+    	// Formats as FR
+    	assertFormatted("1 janv. 1970 00:00:00", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
+  
+  public void testOutputFormattedUsWithDateTypeFormatCustomAndNoFormatter()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(DateFormatType.CUSTOM);
+    try {
+    	assertFormatted("Jan 1, 1970 12:00:00 AM", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
+
+  public void testCanParseUsFormatWithCustomDateFormatter()
+  {
+  	TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+    Locale defaultLocale = Locale.getDefault();
+    Locale.setDefault(Locale.US);
+    
+    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssX");
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles"));
+  	DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateFormat);
+    try {
+    	assertParsed("Jan 1, 1970 12:00:00 AM", dateTypeAdapter);
+    } finally {
+      TimeZone.setDefault(defaultTimeZone);
+      Locale.setDefault(defaultLocale);
+    }
+  }
 
   public void testParsingDatesFormattedWithSystemLocale() {
     TimeZone defaultTimeZone = TimeZone.getDefault();
diff --git a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
index 2dccf4b61..0ee9f9a39 100755
--- a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.gson.functional;
 
+import java.util.Date;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -56,7 +57,7 @@ public void testSingleThreadSerialization() {
    */
   public void testSingleThreadDeserialization() { 
     for (int i = 0; i < 10; i++) { 
-      gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class); 
+      gson.fromJson(MyObjectAsJson, MyObject.class); 
     } 
   } 
 
@@ -91,11 +92,15 @@ public void run() {
     assertFalse(failed.get());
   }
 
+  public void testMultiThreadDeserializationMyObject() throws InterruptedException
+  {
+  	testMultiThreadDeserialization(MyObjectAsJson, MyObject.class);
+  }
   /**
    * Source-code based on
    * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081
    */
-  public void testMultiThreadDeserialization() throws InterruptedException {
+  private <T> void testMultiThreadDeserialization(final String json, final Class<T> objectClass) throws InterruptedException {
     final CountDownLatch startLatch = new CountDownLatch(1);
     final CountDownLatch finishedLatch = new CountDownLatch(10);
     final AtomicBoolean failed = new AtomicBoolean(false);
@@ -106,7 +111,7 @@ public void run() {
           try {
             startLatch.await();
             for (int i = 0; i < 10; i++) {
-              gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class); 
+              gson.fromJson(json, objectClass); 
             }
           } catch (Throwable t) {
             failed.set(true);
@@ -121,6 +126,8 @@ public void run() {
     assertFalse(failed.get());
   }
   
+  private static final String MyObjectAsJson = "{'a':'hello','b':'world','i':1}";
+  
   @SuppressWarnings("unused")
   private static class MyObject {
     String a;
@@ -137,4 +144,23 @@ public MyObject(String a, String b, int i) {
       this.i = i;
     }
   }
+  
+  // ISO and US formats
+  private static final String MyObjectWithDateAsJson = "{'a':'1970-01-01T00:00:00.000Z','b':'Jan 1, 1970 12:00:00 AM','i':'Jan 1, 1970 12:00:00 AM'}";
+  
+  private static class MyObjectWithDate {
+    Date a;
+    Date b;
+    Date i;
+
+    MyObjectWithDate() {
+      this(new Date(0), new Date(0), new Date(0));
+    }
+
+    public MyObjectWithDate(Date a, Date b, Date i) {
+      this.a = a;
+      this.b = b;
+      this.i = i;
+    }
+  }
 }
