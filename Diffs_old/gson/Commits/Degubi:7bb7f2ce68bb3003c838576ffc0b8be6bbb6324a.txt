diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 2579862c5..5174e9c8b 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -103,9 +103,6 @@
 	final boolean generateNonExecutableJson;
 	final boolean htmlSafe;
 	final boolean prettyPrinting;
-	final String datePattern;
-	final int dateStyle;
-	final int timeStyle;
 	final List<TypeAdapterFactory> builderFactories;
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
@@ -113,8 +110,7 @@
 			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
 			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
 			boolean prettyPrinting,
-			String datePattern, int dateStyle,
-			int timeStyle, List<TypeAdapterFactory> builderFactories,
+			List<TypeAdapterFactory> builderFactories,
 			List<TypeAdapterFactory> builderHierarchyFactories,
 			List<TypeAdapterFactory> factoriesToBeAdded) {
 		this.excluder = excluder;
@@ -125,9 +121,6 @@
 		this.generateNonExecutableJson = generateNonExecutableGson;
 		this.htmlSafe = htmlSafe;
 		this.prettyPrinting = prettyPrinting;
-		this.datePattern = datePattern;
-		this.dateStyle = dateStyle;
-		this.timeStyle = timeStyle;
 		this.builderFactories = builderFactories;
 		this.builderHierarchyFactories = builderHierarchyFactories;
 
@@ -177,9 +170,10 @@
 		factories.add(ArrayTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.CLASS_FACTORY);
 		factories.add(LocalTimeAdapter.factory);
+		factories.add(LocalDateAdapter.factory);
 		factories.add(LocalDateTimeAdapter.factory);
 		factories.add(InstantTypeAdapter.factory);
-
+		
 		// type adapters for composite and user-defined types
 		factories.add(new CollectionTypeAdapterFactory(instanceCreators));
 		factories.add(new MapTypeAdapterFactory(instanceCreators, complexMapKeySerialization));
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index b9d716ab0..22c229794 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -70,9 +70,6 @@
   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();
   private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
-  private String datePattern;
-  private int dateStyle = DateFormat.DEFAULT;
-  private int timeStyle = DateFormat.DEFAULT;
   private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
   private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
@@ -101,9 +98,6 @@
     this.generateNonExecutableJson = gson.generateNonExecutableJson;
     this.escapeHtmlChars = gson.htmlSafe;
     this.prettyPrinting = gson.prettyPrinting;
-    this.datePattern = gson.datePattern;
-    this.dateStyle = gson.dateStyle;
-    this.timeStyle = gson.timeStyle;
     this.factories.addAll(gson.builderFactories);
     this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
   }
@@ -352,70 +346,6 @@ public GsonBuilder disableHtmlEscaping() {
     return this;
   }
 
-  /**
-   * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can
-   * call this method or {@link #setDateFormat(int)} multiple times, but only the last invocation
-   * will be used to decide the serialization format.
-   *
-   * <p>The date format will be used to serialize and deserialize {@link java.util.Date}, {@link
-   * java.sql.Timestamp} and {@link java.sql.Date}.
-   *
-   * <p>Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}
-   * class. See the documentation in {@link java.text.SimpleDateFormat} for more information on
-   * valid date and time patterns.</p>
-   *
-   * @param pattern the pattern that dates will be serialized/deserialized to/from
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.2
-   */
-  public GsonBuilder setDateFormat(String pattern) {
-    // TODO(Joel): Make this fail fast if it is an invalid date format
-    this.datePattern = pattern;
-    return this;
-  }
-
-  /**
-   * Configures Gson to to serialize {@code Date} objects according to the style value provided.
-   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
-   * invocation will be used to decide the serialization format.
-   *
-   * <p>Note that this style value should be one of the predefined constants in the
-   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
-   * information on the valid style constants.</p>
-   *
-   * @param style the predefined date style that date objects will be serialized/deserialized
-   * to/from
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.2
-   */
-  public GsonBuilder setDateFormat(int style) {
-    this.dateStyle = style;
-    this.datePattern = null;
-    return this;
-  }
-
-  /**
-   * Configures Gson to to serialize {@code Date} objects according to the style value provided.
-   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
-   * invocation will be used to decide the serialization format.
-   *
-   * <p>Note that this style value should be one of the predefined constants in the
-   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
-   * information on the valid style constants.</p>
-   *
-   * @param dateStyle the predefined date style that date objects will be serialized/deserialized
-   * to/from
-   * @param timeStyle the predefined style for the time portion of the date objects
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.2
-   */
-  public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {
-    this.dateStyle = dateStyle;
-    this.timeStyle = timeStyle;
-    this.datePattern = null;
-    return this;
-  }
-
   /**
    * Configures Gson for custom serialization or deserialization. This method combines the
    * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a
@@ -507,35 +437,9 @@ public Gson build() {
     Collections.reverse(hierarchyFactories);
     factories.addAll(hierarchyFactories);
 
-    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
-
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
-        datePattern, dateStyle, timeStyle,
         this.factories, this.hierarchyFactories, factories);
   }
-
-  @SuppressWarnings("unchecked")
-  private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
-      List<TypeAdapterFactory> factories) {
-    DefaultDateTypeAdapter dateTypeAdapter;
-    TypeAdapter<Timestamp> timestampTypeAdapter;
-    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;
-    if (datePattern != null && !"".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);
-      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);
-      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);
-    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);
-      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);
-      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);
-    } else {
-      return;
-    }
-
-    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));
-    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
-    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/JavaVersion.java b/gson/src/main/java/com/google/gson/internal/JavaVersion.java
deleted file mode 100644
index fab1b7c27..000000000
--- a/gson/src/main/java/com/google/gson/internal/JavaVersion.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-/**
- * Utility to check the major Java version of the current JVM.
- */
-public final class JavaVersion {
-  // Oracle defines naming conventions at http://www.oracle.com/technetwork/java/javase/versioning-naming-139433.html
-  // However, many alternate implementations differ. For example, Debian used 9-debian as the version string
-
-  private static final int majorJavaVersion = determineMajorJavaVersion();
-
-  private static int determineMajorJavaVersion() {
-    String javaVersion = System.getProperty("java.version");
-    return getMajorJavaVersion(javaVersion);
-  }
-
-  // Visible for testing only
-  static int getMajorJavaVersion(String javaVersion) {
-    int version = parseDotted(javaVersion);
-    if (version == -1) {
-      version = extractBeginningInt(javaVersion);
-    }
-    if (version == -1) {
-      return 6;  // Choose minimum supported JDK version as default
-    }
-    return version;
-  }
-
-  // Parses both legacy 1.8 style and newer 9.0.4 style 
-  private static int parseDotted(String javaVersion) {
-    try {
-      String[] parts = javaVersion.split("[._]");
-      int firstVer = Integer.parseInt(parts[0]);
-      if (firstVer == 1 && parts.length > 1) {
-        return Integer.parseInt(parts[1]);
-      } else {
-        return firstVer;
-      }
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-
-  private static int extractBeginningInt(String javaVersion) {
-    try {
-      StringBuilder num = new StringBuilder();
-      for (int i = 0; i < javaVersion.length(); ++i) {
-        char c = javaVersion.charAt(i);
-        if (Character.isDigit(c)) {
-          num.append(c);
-        } else {
-          break;
-        }
-      }
-      return Integer.parseInt(num.toString());
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-
-  /**
-   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
-   */
-  public static int getMajorJavaVersion() {
-    return majorJavaVersion;
-  }
-
-  /**
-   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
-   */
-  public static boolean isJava9OrLater() {
-    return majorJavaVersion >= 9;
-  }
-
-  private JavaVersion() { }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
deleted file mode 100644
index beb527c9e..000000000
--- a/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal;
-
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Locale;
-
-/**
- * Provides DateFormats for US locale with patterns which were the default ones before Java 9.
- */
-public class PreJava9DateFormatProvider {
-
-  /**
-   * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below.
-   */
-  public static DateFormat getUSDateFormat(int style) {
-    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);
-  }
-
-  /**
-   * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}
-   * in Java 8 or below.
-   */
-  public static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {
-    String pattern = getDatePartOfDateTimePattern(dateStyle) + " " + getTimePartOfDateTimePattern(timeStyle);
-    return new SimpleDateFormat(pattern, Locale.US);
-  }
-
-  private static String getDateFormatPattern(int style) {
-    switch (style) {
-    case DateFormat.SHORT:
-      return "M/d/yy";
-    case DateFormat.MEDIUM:
-      return "MMM d, y";
-    case DateFormat.LONG:
-      return "MMMM d, y";
-    case DateFormat.FULL:
-      return "EEEE, MMMM d, y";
-    default:
-      throw new IllegalArgumentException("Unknown DateFormat style: " + style);
-    }
-  }
-
-  private static String getDatePartOfDateTimePattern(int dateStyle) {
-    switch (dateStyle) {
-    case DateFormat.SHORT:
-      return "M/d/yy";
-    case DateFormat.MEDIUM:
-      return "MMM d, yyyy";
-    case DateFormat.LONG:
-      return "MMMM d, yyyy";
-    case DateFormat.FULL:
-      return "EEEE, MMMM d, yyyy";
-    default:
-      throw new IllegalArgumentException("Unknown DateFormat style: " + dateStyle);
-    }
-  }
-
-  private static String getTimePartOfDateTimePattern(int timeStyle) {
-    switch (timeStyle) {
-    case DateFormat.SHORT:
-      return "h:mm a";
-    case DateFormat.MEDIUM:
-      return "h:mm:ss a";
-    case DateFormat.FULL:
-    case DateFormat.LONG:
-      return "h:mm:ss a z";
-    default:
-      throw new IllegalArgumentException("Unknown DateFormat style: " + timeStyle);
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
deleted file mode 100644
index 5b38247e0..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import java.io.IOException;
-import java.sql.Timestamp;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import com.google.gson.*;
-import com.google.gson.internal.JavaVersion;
-import com.google.gson.internal.PreJava9DateFormatProvider;
-import com.google.gson.internal.bind.util.ISO8601Utils;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-
-/**
- * This type adapter supports three subclasses of date: Date, Timestamp, and
- * java.sql.Date.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
-
-  private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
-
-  private final Class<? extends Date> dateType;
-
-  /**
-   * List of 1 or more different date formats used for de-serialization attempts.
-   * The first of them is used for serialization as well.
-   */
-  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
-
-  public DefaultDateTypeAdapter(Class<? extends Date> dateType) {
-    this.dateType = verifyDateType(dateType);
-    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
-    if (!Locale.getDefault().equals(Locale.US)) {
-      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
-    }
-    if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
-    }
-  }
-
-  public DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
-    this.dateType = verifyDateType(dateType);
-    dateFormats.add(new SimpleDateFormat(datePattern, Locale.US));
-    if (!Locale.getDefault().equals(Locale.US)) {
-      dateFormats.add(new SimpleDateFormat(datePattern));
-    }
-  }
-
-  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
-    this.dateType = verifyDateType(dateType);
-    dateFormats.add(DateFormat.getDateInstance(style, Locale.US));
-    if (!Locale.getDefault().equals(Locale.US)) {
-      dateFormats.add(DateFormat.getDateInstance(style));
-    }
-    if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
-    }
-  }
-
-  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(Date.class, dateStyle, timeStyle);
-  }
-
-  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {
-    this.dateType = verifyDateType(dateType);
-    dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US));
-    if (!Locale.getDefault().equals(Locale.US)) {
-      dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
-    }
-    if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
-    }
-  }
-
-  private static Class<? extends Date> verifyDateType(Class<? extends Date> dateType) {
-    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {
-      throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType);
-    }
-    return dateType;
-  }
-
-  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
-  // See issue 162
-  @Override
-  public void write(JsonWriter out, Date value) throws IOException {
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-    synchronized(dateFormats) {
-      String dateFormatAsString = dateFormats.get(0).format(value);
-      out.value(dateFormatAsString);
-    }
-  }
-
-  @Override
-  public Date read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
-    Date date = deserializeToDate(in.nextString());
-    if (dateType == Date.class) {
-      return date;
-    } else if (dateType == Timestamp.class) {
-      return new Timestamp(date.getTime());
-    } else if (dateType == java.sql.Date.class) {
-      return new java.sql.Date(date.getTime());
-    } else {
-      // This must never happen: dateType is guarded in the primary constructor
-      throw new AssertionError();
-    }
-  }
-
-  private Date deserializeToDate(String s) {
-    synchronized (dateFormats) {
-      for (DateFormat dateFormat : dateFormats) {
-        try {
-          return dateFormat.parse(s);
-        } catch (ParseException ignored) {}
-      }
-      try {
-        return ISO8601Utils.parse(s, new ParsePosition(0));
-      } catch (ParseException e) {
-        throw new JsonSyntaxException(s, e);
-      }
-    }
-  }
-
-  @Override
-  public String toString() {
-    DateFormat defaultFormat = dateFormats.get(0);
-    if (defaultFormat instanceof SimpleDateFormat) {
-      return SIMPLE_NAME + '(' + ((SimpleDateFormat) defaultFormat).toPattern() + ')';
-    } else {
-      return SIMPLE_NAME + '(' + defaultFormat.getClass().getSimpleName() + ')';
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
new file mode 100644
index 000000000..5cb218fc6
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
@@ -0,0 +1,37 @@
+package com.google.gson.internal.bind;
+
+import java.io.*;
+import java.time.*;
+
+import com.google.gson.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+
+public class LocalDateAdapter extends TypeAdapter<LocalDate>{
+
+	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
+		
+		@Override
+		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+			return type.getRawType() == LocalDate.class ? (TypeAdapter<T>) new LocalDateAdapter() : null;
+		}
+	};
+	
+	@Override
+	public void write(JsonWriter out, LocalDate value) throws IOException {
+		if(value == null) {
+			out.nullValue();
+		}else{
+			out.value(value.toString());
+		}
+	}
+
+	@Override
+	public LocalDate read(JsonReader in) throws IOException {
+		if (in.peek() == JsonToken.NULL) {
+			in.nextNull();
+			return null;
+		}
+		return LocalDate.parse(in.nextString());
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
deleted file mode 100644
index 99ec679a7..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
+++ /dev/null
@@ -1,352 +0,0 @@
-package com.google.gson.internal.bind.util;
-
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.util.*;
-
-/**
- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
- * highly suitable if you (un)serialize lots of date objects.
- * 
- * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
- * 
- * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
- */
-//Date parsing code from Jackson databind ISO8601Utils.java
-// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
-public class ISO8601Utils
-{
-    /**
-     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
-     * 
-     * @since 2.7
-     */
-    private static final String UTC_ID = "UTC";
-    /**
-     * The UTC timezone, prefetched to avoid more lookups.
-     * 
-     * @since 2.7
-     */
-    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
-
-    /*
-    /**********************************************************
-    /* Formatting
-    /**********************************************************
-     */
-
-    /**
-     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
-     * 
-     * @param date the date to format
-     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'
-     */
-    public static String format(Date date) {
-        return format(date, false, TIMEZONE_UTC);
-    }
-
-    /**
-     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)
-     * 
-     * @param date the date to format
-     * @param millis true to include millis precision otherwise false
-     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'
-     */
-    public static String format(Date date, boolean millis) {
-        return format(date, millis, TIMEZONE_UTC);
-    }
-
-    /**
-     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-     * 
-     * @param date the date to format
-     * @param millis true to include millis precision otherwise false
-     * @param tz timezone to use for the formatting (UTC will produce 'Z')
-     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-     */
-    public static String format(Date date, boolean millis, TimeZone tz) {
-        Calendar calendar = new GregorianCalendar(tz, Locale.US);
-        calendar.setTime(date);
-
-        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
-        int capacity = "yyyy-MM-ddThh:mm:ss".length();
-        capacity += millis ? ".sss".length() : 0;
-        capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length();
-        StringBuilder formatted = new StringBuilder(capacity);
-
-        padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
-        formatted.append('-');
-        padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
-        formatted.append('-');
-        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
-        formatted.append('T');
-        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
-        formatted.append(':');
-        padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
-        formatted.append(':');
-        padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
-        if (millis) {
-            formatted.append('.');
-            padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
-        }
-
-        int offset = tz.getOffset(calendar.getTimeInMillis());
-        if (offset != 0) {
-            int hours = Math.abs((offset / (60 * 1000)) / 60);
-            int minutes = Math.abs((offset / (60 * 1000)) % 60);
-            formatted.append(offset < 0 ? '-' : '+');
-            padInt(formatted, hours, "hh".length());
-            formatted.append(':');
-            padInt(formatted, minutes, "mm".length());
-        } else {
-            formatted.append('Z');
-        }
-
-        return formatted.toString();
-    }
-
-    /*
-    /**********************************************************
-    /* Parsing
-    /**********************************************************
-     */
-
-    /**
-     * Parse a date from ISO-8601 formatted string. It expects a format
-     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
-     * 
-     * @param date ISO string to parse in the appropriate format.
-     * @param pos The position to start parsing from, updated to where parsing stopped.
-     * @return the parsed date
-     * @throws ParseException if the date is not in the appropriate format
-     */
-    public static Date parse(String date, ParsePosition pos) throws ParseException {
-        Exception fail = null;
-        try {
-            int offset = pos.getIndex();
-
-            // extract year
-            int year = parseInt(date, offset, offset += 4);
-            if (checkOffset(date, offset, '-')) {
-                offset += 1;
-            }
-
-            // extract month
-            int month = parseInt(date, offset, offset += 2);
-            if (checkOffset(date, offset, '-')) {
-                offset += 1;
-            }
-
-            // extract day
-            int day = parseInt(date, offset, offset += 2);
-            // default time value
-            int hour = 0;
-            int minutes = 0;
-            int seconds = 0;
-            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
-
-            // if the value has no time component (and no time zone), we are done
-            boolean hasT = checkOffset(date, offset, 'T');
-            
-            if (!hasT && (date.length() <= offset)) {
-                Calendar calendar = new GregorianCalendar(year, month - 1, day);
-
-                pos.setIndex(offset);
-                return calendar.getTime();
-            }
-
-            if (hasT) {
-
-                // extract hours, minutes, seconds and milliseconds
-                hour = parseInt(date, offset += 1, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-
-                minutes = parseInt(date, offset, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-                // second and milliseconds can be optional
-                if (date.length() > offset) {
-                    char c = date.charAt(offset);
-                    if (c != 'Z' && c != '+' && c != '-') {
-                        seconds = parseInt(date, offset, offset += 2);
-                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
-                        // milliseconds can be optional in the format
-                        if (checkOffset(date, offset, '.')) {
-                            offset += 1;
-                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
-                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
-                            int fraction = parseInt(date, offset, parseEndOffset);
-                            // compensate for "missing" digits
-                            switch (parseEndOffset - offset) { // number of digits parsed
-                            case 2:
-                                milliseconds = fraction * 10;
-                                break;
-                            case 1:
-                                milliseconds = fraction * 100;
-                                break;
-                            default:
-                                milliseconds = fraction;
-                            }
-                            offset = endOffset;
-                        }
-                    }
-                }
-            }
-
-            // extract timezone
-            if (date.length() <= offset) {
-                throw new IllegalArgumentException("No time zone indicator");
-            }
-
-            TimeZone timezone = null;
-            char timezoneIndicator = date.charAt(offset);
-
-            if (timezoneIndicator == 'Z') {
-                timezone = TIMEZONE_UTC;
-                offset += 1;
-            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
-                String timezoneOffset = date.substring(offset);
-
-                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
-                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00";
-
-                offset += timezoneOffset.length();
-                // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
-                if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
-                    timezone = TIMEZONE_UTC;
-                } else {
-                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
-                    //    not sure why, but that's the way it looks. Further, Javadocs for
-                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
-                    //    custom timezones... odd.
-                    String timezoneId = "GMT" + timezoneOffset;
-//                    String timezoneId = "UTC" + timezoneOffset;
-
-                    timezone = TimeZone.getTimeZone(timezoneId);
-
-                    String act = timezone.getID();
-                    if (!act.equals(timezoneId)) {
-                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
-                         *    one without. If so, don't sweat.
-                         *   Yes, very inefficient. Hopefully not hit often.
-                         *   If it becomes a perf problem, add 'loose' comparison instead.
-                         */
-                        String cleaned = act.replace(":", "");
-                        if (!cleaned.equals(timezoneId)) {
-                            throw new IndexOutOfBoundsException("Mismatching time zone indicator: "+timezoneId+" given, resolves to "
-                                    +timezone.getID());
-                        }
-                    }
-                }
-            } else {
-                throw new IndexOutOfBoundsException("Invalid time zone indicator '" + timezoneIndicator+"'");
-            }
-
-            Calendar calendar = new GregorianCalendar(timezone);
-            calendar.setLenient(false);
-            calendar.set(Calendar.YEAR, year);
-            calendar.set(Calendar.MONTH, month - 1);
-            calendar.set(Calendar.DAY_OF_MONTH, day);
-            calendar.set(Calendar.HOUR_OF_DAY, hour);
-            calendar.set(Calendar.MINUTE, minutes);
-            calendar.set(Calendar.SECOND, seconds);
-            calendar.set(Calendar.MILLISECOND, milliseconds);
-
-            pos.setIndex(offset);
-            return calendar.getTime();
-            // If we get a ParseException it'll already have the right message/offset.
-            // Other exception types can convert here.
-        } catch (IndexOutOfBoundsException e) {
-            fail = e;
-        } catch (NumberFormatException e) {
-            fail = e;
-        } catch (IllegalArgumentException e) {
-            fail = e;
-        }
-        String input = (date == null) ? null : ('"' + date + '"');
-        String msg = fail.getMessage();
-        if (msg == null || msg.isEmpty()) {
-            msg = "("+fail.getClass().getName()+")";
-        }
-        ParseException ex = new ParseException("Failed to parse date [" + input + "]: " + msg, pos.getIndex());
-        ex.initCause(fail);
-        throw ex;
-    }
-
-    /**
-     * Check if the expected character exist at the given offset in the value.
-     * 
-     * @param value the string to check at the specified offset
-     * @param offset the offset to look for the expected character
-     * @param expected the expected character
-     * @return true if the expected character exist at the given offset
-     */
-    private static boolean checkOffset(String value, int offset, char expected) {
-        return (offset < value.length()) && (value.charAt(offset) == expected);
-    }
-
-    /**
-     * Parse an integer located between 2 given offsets in a string
-     * 
-     * @param value the string to parse
-     * @param beginIndex the start index for the integer in the string
-     * @param endIndex the end index for the integer in the string
-     * @return the int
-     * @throws NumberFormatException if the value is not a number
-     */
-    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
-        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
-            throw new NumberFormatException(value);
-        }
-        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
-        int i = beginIndex;
-        int result = 0;
-        int digit;
-        if (i < endIndex) {
-            digit = Character.digit(value.charAt(i++), 10);
-            if (digit < 0) {
-                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-            }
-            result = -digit;
-        }
-        while (i < endIndex) {
-            digit = Character.digit(value.charAt(i++), 10);
-            if (digit < 0) {
-                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-            }
-            result *= 10;
-            result -= digit;
-        }
-        return -result;
-    }
-
-    /**
-     * Zero pad a number to a specified length
-     * 
-     * @param buffer buffer to use for padding
-     * @param value the integer value to pad if necessary.
-     * @param length the length of the string we should zero pad
-     */
-    private static void padInt(StringBuilder buffer, int value, int length) {
-        String strValue = Integer.toString(value);
-        for (int i = length - strValue.length(); i > 0; i--) {
-            buffer.append('0');
-        }
-        buffer.append(strValue);
-    }
-
-    /**
-     * Returns the index of the first character in the string that is not a digit, starting at offset.
-     */
-    private static int indexOfNonDigit(String string, int offset) {
-        for (int i = offset; i < string.length(); i++) {
-            char c = string.charAt(i);
-            if (c < '0' || c > '9') return i;
-        }
-        return string.length();
-    }
-
-}
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
deleted file mode 100644
index b95666737..000000000
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.io.IOException;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import com.google.gson.internal.JavaVersion;
-import com.google.gson.internal.bind.*;
-import junit.framework.TestCase;
-
-/**
- * A simple unit test for the {@link DefaultDateTypeAdapter} class.
- *
- * @author Joel Leitch
- */
-public class DefaultDateTypeAdapterTest extends TestCase {
-
-  public void testFormattingInEnUs() {
-    assertFormattingAlwaysEmitsUsLocale(Locale.US);
-  }
-
-  public void testFormattingInFr() {
-    assertFormattingAlwaysEmitsUsLocale(Locale.FRANCE);
-  }
-
-  private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(locale);
-    try {
-      String afterYearSep = JavaVersion.isJava9OrLater() ? ", " : " ";
-      String afterYearLongSep = JavaVersion.isJava9OrLater() ? " at " : " ";
-      String utcFull = JavaVersion.isJava9OrLater() ? "Coordinated Universal Time" : "UTC";
-      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
-              new DefaultDateTypeAdapter(Date.class));
-      assertFormatted("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
-      assertFormatted(String.format("1/1/70%s12:00 AM", afterYearSep),
-          new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
-          new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertFormatted(String.format("January 1, 1970%s12:00:00 AM UTC", afterYearLongSep),
-          new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertFormatted(String.format("Thursday, January 1, 1970%s12:00:00 AM %s", afterYearLongSep, utcFull),
-          new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  public void testParsingDatesFormattedWithSystemLocale() throws Exception {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.FRANCE);
-    try {
-      String afterYearSep = JavaVersion.isJava9OrLater() ? " à " : " ";
-      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
-              new DefaultDateTypeAdapter(Date.class));
-      assertParsed("01/01/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
-      assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
-      assertParsed("01/01/70 00:00",
-          new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
-          new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertParsed(String.format("1 janvier 1970%s00:00:00 UTC", afterYearSep),
-          new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed(JavaVersion.isJava9OrLater() ?
-                      "jeudi 1 janvier 1970 à 00:00:00 Coordinated Universal Time" :
-                      "jeudi 1 janvier 1970 00 h 00 UTC",
-          new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  public void testParsingDatesFormattedWithUsLocale() throws Exception {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.US);
-    try {
-      assertParsed("Jan 1, 1970 0:00:00 AM", new DefaultDateTypeAdapter(Date.class));
-      assertParsed("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
-      assertParsed("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
-      assertParsed("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
-      assertParsed("1/1/70 0:00 AM",
-          new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertParsed("Jan 1, 1970 0:00:00 AM",
-          new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertParsed("January 1, 1970 0:00:00 AM UTC",
-          new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed("Thursday, January 1, 1970 0:00:00 AM UTC",
-          new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  public void testFormatUsesDefaultTimezone() throws Exception {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.US);
-    try {
-      String afterYearSep = JavaVersion.isJava9OrLater() ? ", " : " ";
-      assertFormatted(String.format("Dec 31, 1969%s4:00:00 PM", afterYearSep),
-              new DefaultDateTypeAdapter(Date.class));
-      assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter(Date.class));
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  public void testDateDeserializationISO8601() throws Exception {
-    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
-    assertParsed("1970-01-01T00:00:00.000Z", adapter);
-    assertParsed("1970-01-01T00:00Z", adapter);
-    assertParsed("1970-01-01T00:00:00+00:00", adapter);
-    assertParsed("1970-01-01T01:00:00+01:00", adapter);
-    assertParsed("1970-01-01T01:00:00+01", adapter);
-  }
-  
-  public void testDateSerialization() throws Exception {
-    int dateStyle = DateFormat.LONG;
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle);
-    DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);
-    Date currentDate = new Date();
-
-    String dateString = dateTypeAdapter.toJson(currentDate);
-    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
-  }
-
-  public void testDatePattern() throws Exception {
-    String pattern = "yyyy-MM-dd";
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, pattern);
-    DateFormat formatter = new SimpleDateFormat(pattern);
-    Date currentDate = new Date();
-
-    String dateString = dateTypeAdapter.toJson(currentDate);
-    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
-  }
-
-  public void testInvalidDatePattern() throws Exception {
-    try {
-      new DefaultDateTypeAdapter(Date.class, "I am a bad Date pattern....");
-      fail("Invalid date pattern should fail.");
-    } catch (IllegalArgumentException expected) { }
-  }
-
-  public void testNullValue() throws Exception {
-    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
-    assertNull(adapter.fromJson("null"));
-    assertEquals("null", adapter.toJson(null));
-  }
-
-  public void testUnexpectedToken() throws Exception {
-    try {
-      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
-      adapter.fromJson("{}");
-      fail("Unexpected token should fail.");
-    } catch (IllegalStateException expected) { }
-  }
-
-  private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {
-    assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));
-  }
-
-  private void assertParsed(String date, DefaultDateTypeAdapter adapter) throws IOException {
-    assertEquals(date, new Date(0), adapter.fromJson(toLiteral(date)));
-    assertEquals("ISO 8601", new Date(0), adapter.fromJson(toLiteral("1970-01-01T00:00:00Z")));
-  }
-
-  private static String toLiteral(String s) {
-    return '"' + s + '"';
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 94de28ed2..3c92cc338 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -47,8 +47,7 @@
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, null, DateFormat.DEFAULT,
-        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        true, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
@@ -60,8 +59,7 @@ public void testOverridesDefaultExcluder() {
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, null, DateFormat.DEFAULT,
-        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        true, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
     Gson clone = original.rebuild()
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
deleted file mode 100644
index 8a8969871..000000000
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ /dev/null
@@ -1,628 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.functional;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.internal.JavaVersion;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Type;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.URI;
-import java.net.URL;
-import java.sql.Time;
-import java.sql.Timestamp;
-import java.text.DateFormat;
-import java.time.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Properties;
-import java.util.Set;
-import java.util.TimeZone;
-import java.util.TreeSet;
-import java.util.UUID;
-
-import junit.framework.TestCase;
-
-/**
- * Functional test for Json serialization and deserialization for common classes for which default
- * support is provided in Gson. The tests for Map types are available in {@link MapTest}.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public class DefaultTypeAdaptersTest extends TestCase {
-	private Gson gson;
-	private TimeZone oldTimeZone;
-
-	@Override
-	protected void setUp() throws Exception {
-		super.setUp();
-		this.oldTimeZone = TimeZone.getDefault();
-		TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
-		Locale.setDefault(Locale.US);
-		gson = Gson.newGson();
-	}
-
-	@Override
-	protected void tearDown() throws Exception {
-		TimeZone.setDefault(oldTimeZone);
-		super.tearDown();
-	}
-
-	public void testClassSerialization() {
-		try {
-			gson.toJson(String.class);
-		} catch (UnsupportedOperationException expected) {}
-		// Override with a custom type adapter for class.
-		gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
-		assertEquals("\"java.lang.String\"", gson.toJson(String.class));
-	}
-
-	public void testClassDeserialization() {
-		try {
-			gson.fromJson("String.class", String.class.getClass());
-		} catch (UnsupportedOperationException expected) {}
-		// Override with a custom type adapter for class.
-		gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
-		assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
-	}
-
-	public void testUrlSerialization() throws Exception {
-		String urlValue = "http://google.com/";
-		URL url = new URL(urlValue);
-		assertEquals("\"http://google.com/\"", gson.toJson(url));
-	}
-
-	public void testUrlDeserialization() {
-		String urlValue = "http://google.com/";
-		String json = "'http:\\/\\/google.com\\/'";
-		URL target = gson.fromJson(json, URL.class);
-		assertEquals(urlValue, target.toExternalForm());
-
-		gson.fromJson('"' + urlValue + '"', URL.class);
-		assertEquals(urlValue, target.toExternalForm());
-	}
-
-	public void testUrlNullSerialization() throws Exception {
-		ClassWithUrlField target = new ClassWithUrlField();
-		assertEquals("{}", gson.toJson(target));
-	}
-
-	public void testUrlNullDeserialization() {
-		String json = "{}";
-		ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);
-		assertNull(target.url);
-	}
-
-	private static class ClassWithUrlField {
-		URL url;
-	}
-
-	public void testUriSerialization() throws Exception {
-		String uriValue = "http://google.com/";
-		URI uri = new URI(uriValue);
-		assertEquals("\"http://google.com/\"", gson.toJson(uri));
-	}
-
-	public void testUriDeserialization() {
-		String uriValue = "http://google.com/";
-		String json = '"' + uriValue + '"';
-		URI target = gson.fromJson(json, URI.class);
-		assertEquals(uriValue, target.toASCIIString());
-	}
-
-	public void testNullSerialization() throws Exception {
-		testNullSerializationAndDeserialization(Boolean.class);
-		testNullSerializationAndDeserialization(Byte.class);
-		testNullSerializationAndDeserialization(Short.class);
-		testNullSerializationAndDeserialization(Integer.class);
-		testNullSerializationAndDeserialization(Long.class);
-		testNullSerializationAndDeserialization(Double.class);
-		testNullSerializationAndDeserialization(Float.class);
-		testNullSerializationAndDeserialization(Number.class);
-		testNullSerializationAndDeserialization(Character.class);
-		testNullSerializationAndDeserialization(String.class);
-		testNullSerializationAndDeserialization(StringBuilder.class);
-		testNullSerializationAndDeserialization(StringBuffer.class);
-		testNullSerializationAndDeserialization(BigDecimal.class);
-		testNullSerializationAndDeserialization(BigInteger.class);
-		testNullSerializationAndDeserialization(TreeSet.class);
-		testNullSerializationAndDeserialization(ArrayList.class);
-		testNullSerializationAndDeserialization(HashSet.class);
-		testNullSerializationAndDeserialization(Properties.class);
-		testNullSerializationAndDeserialization(URL.class);
-		testNullSerializationAndDeserialization(URI.class);
-		testNullSerializationAndDeserialization(UUID.class);
-		testNullSerializationAndDeserialization(Locale.class);
-		testNullSerializationAndDeserialization(InetAddress.class);
-		testNullSerializationAndDeserialization(BitSet.class);
-		testNullSerializationAndDeserialization(Date.class);
-		testNullSerializationAndDeserialization(GregorianCalendar.class);
-		testNullSerializationAndDeserialization(Calendar.class);
-		testNullSerializationAndDeserialization(Time.class);
-		testNullSerializationAndDeserialization(Timestamp.class);
-		testNullSerializationAndDeserialization(java.sql.Date.class);
-		testNullSerializationAndDeserialization(Enum.class);
-		testNullSerializationAndDeserialization(Class.class);
-	}
-
-	private void testNullSerializationAndDeserialization(Class<?> c) {
-		assertEquals("null", gson.toJson(null, c));
-		assertEquals(null, gson.fromJson("null", c));
-	}
-
-	public void testUuidSerialization() throws Exception {
-		String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
-		UUID uuid = UUID.fromString(uuidValue);
-		assertEquals('"' + uuidValue + '"', gson.toJson(uuid));
-	}
-
-	public void testUuidDeserialization() {
-		String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
-		String json = '"' + uuidValue + '"';
-		UUID target = gson.fromJson(json, UUID.class);
-		assertEquals(uuidValue, target.toString());
-	}
-
-	public void testLocaleSerializationWithLanguage() {
-		Locale target = new Locale("en");
-		assertEquals("\"en\"", gson.toJson(target));
-	}
-
-	public void testLocaleDeserializationWithLanguage() {
-		String json = "\"en\"";
-		Locale locale = gson.fromJson(json, Locale.class);
-		assertEquals("en", locale.getLanguage());
-	}
-
-	public void testLocaleSerializationWithLanguageCountry() {
-		Locale target = Locale.CANADA_FRENCH;
-		assertEquals("\"fr_CA\"", gson.toJson(target));
-	}
-
-	public void testLocaleDeserializationWithLanguageCountry() {
-		String json = "\"fr_CA\"";
-		Locale locale = gson.fromJson(json, Locale.class);
-		assertEquals(Locale.CANADA_FRENCH, locale);
-	}
-
-	public void testLocaleSerializationWithLanguageCountryVariant() {
-		Locale target = new Locale("de", "DE", "EURO");
-		String json = gson.toJson(target);
-		assertEquals("\"de_DE_EURO\"", json);
-	}
-
-	public void testLocaleDeserializationWithLanguageCountryVariant() {
-		String json = "\"de_DE_EURO\"";
-		Locale locale = gson.fromJson(json, Locale.class);
-		assertEquals("de", locale.getLanguage());
-		assertEquals("DE", locale.getCountry());
-		assertEquals("EURO", locale.getVariant());
-	}
-
-	public void testBigDecimalFieldSerialization() {
-		ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21");
-		String json = gson.toJson(target);
-		String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));
-		assertEquals(target.value, new BigDecimal(actual));
-	}
-
-	public void testBigDecimalFieldDeserialization() {
-		ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21");
-		String json = expected.getExpectedJson();
-		ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);
-		assertEquals(expected.value, actual.value);
-	}
-
-	public void testBadValueForBigDecimalDeserialization() {
-		try {
-			gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class);
-			fail("Exponent of a BigDecimal must be an integer value.");
-		} catch (JsonParseException expected) { }
-	}
-
-	public void testBigIntegerFieldSerialization() {
-		ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324");
-		String json = gson.toJson(target);
-		assertEquals(target.getExpectedJson(), json);
-	}
-
-	public void testBigIntegerFieldDeserialization() {
-		ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697");
-		String json = expected.getExpectedJson();
-		ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);
-		assertEquals(expected.value, actual.value);
-	}
-
-	public void testOverrideBigIntegerTypeAdapter() throws Exception {
-		gson = Gson.newBuilder()
-				.registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class))
-				.build();
-		assertEquals("\"123\"", gson.toJson(new BigInteger("123"), BigInteger.class));
-		assertEquals(new BigInteger("123"), gson.fromJson("\"123\"", BigInteger.class));
-	}
-
-	public void testOverrideBigDecimalTypeAdapter() throws Exception {
-		gson = Gson.newBuilder()
-				.registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class))
-				.build();
-		assertEquals("\"1.1\"", gson.toJson(new BigDecimal("1.1"), BigDecimal.class));
-		assertEquals(new BigDecimal("1.1"), gson.fromJson("\"1.1\"", BigDecimal.class));
-	}
-
-	public void testSetSerialization() throws Exception {
-		Gson gson = Gson.newGson();
-		HashSet<String> s = new HashSet<String>();
-		s.add("blah");
-		String json = gson.toJson(s);
-		assertEquals("[\"blah\"]", json);
-
-		json = gson.toJson(s, Set.class);
-		assertEquals("[\"blah\"]", json);
-	}
-
-	public void testBitSetSerialization() throws Exception {
-		Gson gson = Gson.newGson();
-		BitSet bits = new BitSet();
-		bits.set(1);
-		bits.set(3, 6);
-		bits.set(9);
-		String json = gson.toJson(bits);
-		assertEquals("[0,1,0,1,1,1,0,0,0,1]", json);
-	}
-
-	public void testBitSetDeserialization() throws Exception {
-		BitSet expected = new BitSet();
-		expected.set(0);
-		expected.set(2, 6);
-		expected.set(8);
-
-		Gson gson = Gson.newGson();
-		String json = gson.toJson(expected);
-		assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-		json = "[1,0,1,1,1,1,0,0,1,0,0,0]";
-		assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-		json = "[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\"]";
-		assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-		json = "[true,false,true,true,true,true,false,false,true,false,false]";
-		assertEquals(expected, gson.fromJson(json, BitSet.class));
-	}
-
-	public void testDefaultDateDeserialization() {
-		String json = "'2009-12-03T01:18:02'";
-		LocalDateTime extracted = gson.fromJson(json, LocalDateTime.class);
-
-		assertEquals(LocalDateTime.of(2009, Month.DECEMBER, 3, 1, 18, 2), extracted);
-	}
-
-	public void testDefaultJavaSqlDateSerialization() {
-		Instant instant = Instant.ofEpochMilli(1259875082000L);
-		String json = gson.toJson(instant);
-		assertEquals("\"2009-12-03T21:18:02Z\"", json);
-	}
-
-	public void testDefaultJavaSqlDateDeserialization() {
-		String json = "\"2009-12-03T21:18:02Z\"";
-		Instant extracted = gson.fromJson(json, Instant.class);
-		assertEquals(extracted, Instant.ofEpochMilli(1259875082000L));
-	}
-
-	public void testDateSerializationWithPattern() throws Exception {
-		String pattern = "yyyy-MM-dd";
-		Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
-		Date now = new Date(1315806903103L);
-		String json = gson.toJson(now);
-		assertEquals("\"2011-09-11\"", json);
-	}
-
-	@SuppressWarnings("deprecation")
-	public void testDateDeserializationWithPattern() throws Exception {
-		String pattern = "yyyy-MM-dd";
-		Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
-		Date now = new Date(1315806903103L);
-		String json = gson.toJson(now);
-		Date extracted = gson.fromJson(json, Date.class);
-		assertEquals(now.getYear(), extracted.getYear());
-		assertEquals(now.getMonth(), extracted.getMonth());
-		assertEquals(now.getDay(), extracted.getDay());
-	}
-
-	public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {
-		String pattern = "yyyy-MM-dd";
-		Gson gson = Gson.newBuilder()
-				.setDateFormat(pattern)
-				.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
-					public Date deserialize(JsonElement json, Type typeOfT,
-							JsonDeserializationContext context)
-									throws JsonParseException {
-						return new Date(1315806903103L);
-					}
-				})
-				.build();
-
-		Date now = new Date(1315806903103L);
-		String json = gson.toJson(now);
-		assertEquals("\"2011-09-11\"", json);
-	}
-
-	// http://code.google.com/p/google-gson/issues/detail?id=230
-	public void testDateSerializationInCollection() throws Exception {
-		Type listOfDates = new TypeToken<List<Date>>() {}.getType();
-		TimeZone defaultTimeZone = TimeZone.getDefault();
-		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-		Locale defaultLocale = Locale.getDefault();
-		Locale.setDefault(Locale.US);
-		try {
-			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-			List<Date> dates = Arrays.asList(new Date(0));
-			String json = gson.toJson(dates, listOfDates);
-			assertEquals("[\"1970-01-01\"]", json);
-			assertEquals(0L, gson.<List<Date>>fromJson("[\"1970-01-01\"]", listOfDates).get(0).getTime());
-		} finally {
-			TimeZone.setDefault(defaultTimeZone);
-			Locale.setDefault(defaultLocale);
-		}
-	}
-
-	// http://code.google.com/p/google-gson/issues/detail?id=230
-	public void testTimestampSerialization() throws Exception {
-		TimeZone defaultTimeZone = TimeZone.getDefault();
-		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-		Locale defaultLocale = Locale.getDefault();
-		Locale.setDefault(Locale.US);
-		try {
-			Timestamp timestamp = new Timestamp(0L);
-			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-			String json = gson.toJson(timestamp, Timestamp.class);
-			assertEquals("\"1970-01-01\"", json);
-			assertEquals(0, gson.fromJson("\"1970-01-01\"", Timestamp.class).getTime());
-		} finally {
-			TimeZone.setDefault(defaultTimeZone);
-			Locale.setDefault(defaultLocale);
-		}
-	}
-
-	// http://code.google.com/p/google-gson/issues/detail?id=230
-	public void testSqlDateSerialization() throws Exception {
-		TimeZone defaultTimeZone = TimeZone.getDefault();
-		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-		Locale defaultLocale = Locale.getDefault();
-		Locale.setDefault(Locale.US);
-		try {
-			java.sql.Date sqlDate = new java.sql.Date(0L);
-			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-			String json = gson.toJson(sqlDate, Timestamp.class);
-			assertEquals("\"1970-01-01\"", json);
-			assertEquals(0, gson.fromJson("\"1970-01-01\"", java.sql.Date.class).getTime());
-		} finally {
-			TimeZone.setDefault(defaultTimeZone);
-			Locale.setDefault(defaultLocale);
-		}
-	}
-
-	public void testJsonPrimitiveSerialization() {
-		assertEquals("5", gson.toJson(new JsonPrimitive(5), JsonElement.class));
-		assertEquals("true", gson.toJson(new JsonPrimitive(true), JsonElement.class));
-		assertEquals("\"foo\"", gson.toJson(new JsonPrimitive("foo"), JsonElement.class));
-		assertEquals("\"a\"", gson.toJson(new JsonPrimitive('a'), JsonElement.class));
-	}
-
-	public void testJsonPrimitiveDeserialization() {
-		assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonElement.class));
-		assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonPrimitive.class));
-		assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonElement.class));
-		assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonPrimitive.class));
-		assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonElement.class));
-		assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonPrimitive.class));
-		assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonElement.class));
-		assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonPrimitive.class));
-	}
-
-	public void testJsonNullSerialization() {
-		assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonElement.class));
-		assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonNull.class));
-	}
-
-	public void testNullJsonElementSerialization() {
-		assertEquals("null", gson.toJson(null, JsonElement.class));
-		assertEquals("null", gson.toJson(null, JsonNull.class));
-	}
-
-	public void testJsonArraySerialization() {
-		JsonArray array = new JsonArray();
-		array.add(new JsonPrimitive(1));
-		array.add(new JsonPrimitive(2));
-		array.add(new JsonPrimitive(3));
-		assertEquals("[1,2,3]", gson.toJson(array, JsonElement.class));
-	}
-
-	public void testJsonArrayDeserialization() {
-		JsonArray array = new JsonArray();
-		array.add(new JsonPrimitive(1));
-		array.add(new JsonPrimitive(2));
-		array.add(new JsonPrimitive(3));
-
-		String json = "[1,2,3]";
-		assertEquals(array, gson.fromJson(json, JsonElement.class));
-		assertEquals(array, gson.fromJson(json, JsonArray.class));
-	}
-
-	public void testJsonObjectSerialization() {
-		JsonObject object = new JsonObject();
-		object.add("foo", new JsonPrimitive(1));
-		object.add("bar", new JsonPrimitive(2));
-		assertEquals("{\"foo\":1,\"bar\":2}", gson.toJson(object, JsonElement.class));
-	}
-
-	public void testJsonObjectDeserialization() {
-		JsonObject object = new JsonObject();
-		object.add("foo", new JsonPrimitive(1));
-		object.add("bar", new JsonPrimitive(2));
-
-		String json = "{\"foo\":1,\"bar\":2}";
-		JsonElement actual = gson.fromJson(json, JsonElement.class);
-		assertEquals(object, actual);
-
-		JsonObject actualObj = gson.fromJson(json, JsonObject.class);
-		assertEquals(object, actualObj);
-	}
-
-	public void testJsonNullDeserialization() {
-		assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonElement.class));
-		assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonNull.class));
-	}
-
-	public void testJsonElementTypeMismatch() {
-		try {
-			gson.fromJson("\"abc\"", JsonObject.class);
-			fail();
-		} catch (JsonSyntaxException expected) {
-			assertEquals("Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive",
-					expected.getMessage());
-		}
-	}
-
-	private static class ClassWithBigDecimal {
-		BigDecimal value;
-		ClassWithBigDecimal(String value) {
-			this.value = new BigDecimal(value);
-		}
-		String getExpectedJson() {
-			return "{\"value\":" + value.toEngineeringString() + "}";
-		}
-	}
-
-	private static class ClassWithBigInteger {
-		BigInteger value;
-		ClassWithBigInteger(String value) {
-			this.value = new BigInteger(value);
-		}
-		String getExpectedJson() {
-			return "{\"value\":" + value + "}";
-		}
-	}
-
-	public void testPropertiesSerialization() {
-		Properties props = new Properties();
-		props.setProperty("foo", "bar");
-		String json = gson.toJson(props);
-		String expected = "{\"foo\":\"bar\"}";
-		assertEquals(expected, json);
-	}
-
-	public void testPropertiesDeserialization() {
-		String json = "{foo:'bar'}";
-		Properties props = gson.fromJson(json, Properties.class);
-		assertEquals("bar", props.getProperty("foo"));
-	}
-
-	public void testTreeSetSerialization() {
-		TreeSet<String> treeSet = new TreeSet<String>();
-		treeSet.add("Value1");
-		String json = gson.toJson(treeSet);
-		assertEquals("[\"Value1\"]", json);
-	}
-
-	public void testTreeSetDeserialization() {
-		String json = "['Value1']";
-		Type type = new TypeToken<TreeSet<String>>() {}.getType();
-		TreeSet<String> treeSet = gson.fromJson(json, type);
-		assertTrue(treeSet.contains("Value1"));
-	}
-
-	public void testStringBuilderSerialization() {
-		StringBuilder sb = new StringBuilder("abc");
-		String json = gson.toJson(sb);
-		assertEquals("\"abc\"", json);
-	}
-
-	public void testStringBuilderDeserialization() {
-		StringBuilder sb = gson.fromJson("'abc'", StringBuilder.class);
-		assertEquals("abc", sb.toString());
-	}
-
-	public void testStringBufferSerialization() {
-		StringBuffer sb = new StringBuffer("abc");
-		String json = gson.toJson(sb);
-		assertEquals("\"abc\"", json);
-	}
-
-	public void testStringBufferDeserialization() {
-		StringBuffer sb = gson.fromJson("'abc'", StringBuffer.class);
-		assertEquals("abc", sb.toString());
-	}
-
-	@SuppressWarnings("rawtypes")
-	private static class MyClassTypeAdapter extends TypeAdapter<Class> {
-		@Override
-		public void write(JsonWriter out, Class value) throws IOException {
-			out.value(value.getName());
-		}
-		@Override
-		public Class read(JsonReader in) throws IOException {
-			String className = in.nextString();
-			try {
-				return Class.forName(className);
-			} catch (ClassNotFoundException e) {
-				throw new IOException(e);
-			}
-		}
-	}
-
-	static class NumberAsStringAdapter extends TypeAdapter<Number> {
-		private final Constructor<? extends Number> constructor;
-		NumberAsStringAdapter(Class<? extends Number> type) throws Exception {
-			this.constructor = type.getConstructor(String.class);
-		}
-		@Override public void write(JsonWriter out, Number value) throws IOException {
-			out.value(value.toString());
-		}
-		@Override public Number read(JsonReader in) throws IOException {
-			try {
-				return constructor.newInstance(in.nextString());
-			} catch (Exception e) {
-				throw new AssertionError(e);
-			}
-		}
-	}
-}
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index 9a1efb082..6e8ab40cc 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -16,37 +16,12 @@
 
 package com.google.gson.functional;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.google.gson.common.TestTypes.ArrayOfObjects;
-import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;
-import com.google.gson.common.TestTypes.BagOfPrimitives;
-import com.google.gson.common.TestTypes.ClassWithArray;
-import com.google.gson.common.TestTypes.ClassWithNoFields;
-import com.google.gson.common.TestTypes.ClassWithObjects;
-import com.google.gson.common.TestTypes.ClassWithTransientFields;
-import com.google.gson.common.TestTypes.Nested;
-import com.google.gson.common.TestTypes.PrimitiveArray;
-import com.google.gson.internal.JavaVersion;
-import com.google.gson.reflect.TypeToken;
-import java.lang.reflect.Type;
-import java.time.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-
-import junit.framework.TestCase;
+import com.google.gson.*;
+import com.google.gson.common.TestTypes.*;
+import com.google.gson.reflect.*;
+import java.lang.reflect.*;
+import java.util.*;
+import junit.framework.*;
 
 /**
  * Functional tests for Json serialization and deserialization of regular classes.
@@ -481,18 +456,6 @@ public void testSingletonLists() {
     gson.fromJson(gson.toJson(product), Product.class);
   }
 
-  // http://code.google.com/p/google-gson/issues/detail?id=270
-  public void testDateAsMapObjectField() {
-    HasObjectMap a = new HasObjectMap();
-    a.map.put("date", LocalDate.ofEpochDay(0L));
-    
-    assertEquals("{\"map\":{\"date\":{\"year\":1970,\"month\":1,\"day\":1}}}", gson.toJson(a));
-  }
-
-  public class HasObjectMap {
-    Map<String, Object> map = new HashMap<String, Object>();
-  }
-
   static final class Department {
     public String name = "abc";
     public String code = "123";
diff --git a/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java b/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
deleted file mode 100644
index 4768c2dbc..000000000
--- a/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal;
-
-import static org.junit.Assert.*;
-
-import org.junit.Test;
-
-import com.google.gson.internal.JavaVersion;
-
-/**
- * Unit and functional tests for {@link JavaVersion}
- *
- * @author Inderjeet Singh
- */
-public class JavaVersionTest {
-  // Borrowed some of test strings from https://github.com/prestodb/presto/blob/master/presto-main/src/test/java/com/facebook/presto/server/TestJavaVersion.java
-
-  @Test
-  public void testGetMajorJavaVersion() {
-    JavaVersion.getMajorJavaVersion();
-  }
-
-  @Test
-  public void testJava6() {
-    assertEquals(6, JavaVersion.getMajorJavaVersion("1.6.0")); // http://www.oracle.com/technetwork/java/javase/version-6-141920.html
-  }
-
-  @Test
-  public void testJava7() {
-    assertEquals(7, JavaVersion.getMajorJavaVersion("1.7.0")); // http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html
-  }
-
-  @Test
-  public void testJava8() {
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8"));
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0"));
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_131"));
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_60-ea"));
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_111-internal"));
-
-    // openjdk8 per https://github.com/AdoptOpenJDK/openjdk-build/issues/93
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0-internal"));
-    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_131-adoptopenjdk"));
-  }
-
-  @Test
-  public void testJava9() {
-    // Legacy style
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9.0.4")); // Oracle JDK 9
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9-Debian")); // Debian as reported in https://github.com/google/gson/issues/1310
-    // New style
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9-ea+19"));
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9+100"));
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9.0.1+20"));
-    assertEquals(9, JavaVersion.getMajorJavaVersion("9.1.1+20"));
-  }
-
-  @Test
-  public void testJava10() {
-    assertEquals(10, JavaVersion.getMajorJavaVersion("10.0.1")); // Oracle JDK 10.0.1
-  }
-
-  @Test
-  public void testUnknownVersionFormat() {
-    assertEquals(6, JavaVersion.getMajorJavaVersion("Java9")); // unknown format
-  }
-}
