diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index a4ca4f309..c2fe2cf80 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -49,6 +49,7 @@
 import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
 import com.google.gson.internal.bind.SqlDateTypeAdapter;
 import com.google.gson.internal.bind.TimeTypeAdapter;
+import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
@@ -56,6 +57,9 @@
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
 
+// FIXME loopcheck code
+// FIXME registerTypeAdapter
+
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
  * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}
@@ -99,8 +103,46 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  * @author Jesse Wilson
+ * @author Daniel Winterstein
  */
 public final class Gson {
+	
+	
+	/**
+	 * Allows for LATE setting of an adapter. 
+	 * @deprecated You should use {@link GsonBuilder#registerTypeAdapter(Type, Object)} instead. 
+	 * @param type
+	 * @param typeAdapter
+	 * @return this
+	 */
+	 public Gson registerTypeAdapter(Type type, Object typeAdapter) {
+//		    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+//		        || typeAdapter instanceof JsonDeserializer<?>
+//		        || typeAdapter instanceof InstanceCreator<?>
+//		        || typeAdapter instanceof TypeAdapter<?>);
+//		    if (typeAdapter instanceof InstanceCreator<?>) {
+//		      instanceCreators.put(type, (InstanceCreator) typeAdapter);
+//		    }
+	    TypeToken<?> typeToken = TypeToken.get(type);
+	    if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {		      
+	      factories.add(0, TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));
+	    }
+	    if (typeAdapter instanceof TypeAdapter<?>) {
+	      factories.add(0,TypeAdapters.newFactory(typeToken, (TypeAdapter)typeAdapter));
+	    }
+	    typeTokenCache.remove(typeToken);
+	    return this;
+	  }
+	 
+	/**
+	 * What version is this? And what version was it branched from?
+	 * The format is W(Winterwell version)_G(original Google version).
+	 * An S on the Google-version indicates "snapshot"
+	 * 
+	 * TODO update from https://github.com/google/gson v2.6.2
+	 */
+	public static String VERSION = "W1.3_G2.3.1S";
+	
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
   static final boolean DEFAULT_LENIENT = false;
   static final boolean DEFAULT_PRETTY_PRINT = false;
@@ -136,6 +178,37 @@
   private final boolean lenient;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
+
+	// Added by Daniel
+	private final String classProperty;
+
+	private boolean lenientReader;
+
+	/**
+	 * How do we handle circular references? never null. HACK Should not be
+	 * static!!!
+	 * 
+	 * @since September 2014, added by Daniel
+	 */
+	private static KLoopPolicy loopPolicy;
+
+
+	/**
+	 * How do we handle circular references? never null.
+	 * @since September 2014, added by Daniel
+	 */
+	public static KLoopPolicy getLoopPolicy() {
+		return loopPolicy;
+	}
+
+	/**
+	 * @see GsonBuilder#setClassProperty(String)
+	 * @return null if this is off.
+	 */
+	public String getClassProperty() {
+		return classProperty;
+	}
+
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
    * following settings:
@@ -175,7 +248,7 @@ public Gson() {
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList(), GsonBuilder.DEFAULT_CLASS_PROPERTY);
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
@@ -183,7 +256,7 @@ public Gson() {
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
+      List<TypeAdapterFactory> typeAdapterFactories, String classProperty) {
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
@@ -192,6 +265,7 @@ public Gson() {
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.classProperty = classProperty;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -986,4 +1060,79 @@ public String toString() {
         .append("}")
         .toString();
   }
+
+
+	/**
+	 * Strip out the _class properties added by this version of Gson.
+	 * 
+	 * @param json
+	 * @return json without the classProperty bits
+	 */
+	public String removeClassProperty(String json) {
+		if (classProperty == null)
+			return json;
+		String json2 = json.replaceAll("[\"']" + classProperty
+				+ "[\"']:[\"'][^\"']*[\"'],?", "");
+		return json2;
+	}
+
+	/**
+	 * Use "@class" (see {@link #getClassProperty()}) if set to determine
+	 * what class to make.
+	 * @param json
+	 * @return de-serialised POJO
+	 * @since October 2014, added by Daniel
+	 */
+	public <T> T fromJson(String json) {
+		if (classProperty==null) {
+			throw new IllegalStateException("This method works via @class, which is switched off. Please use fromJson(String,Class)");
+		}
+		return (T) fromJson(json, Object.class);
+	}
+	
+	/**
+	 * Use "@class" (see {@link #getClassProperty()}) if set to determine
+	 * what class to make.
+	 * @param json
+	 * @return de-serialised POJO
+	 * @since October 2014, added by Daniel
+	 */
+	public <T> T fromJson(Reader json) {
+		if (classProperty==null) {
+			throw new IllegalStateException("This method works via @class, which is switched off. Please use fromJson(String,Class)");
+		}
+		return (T) fromJson(json, Object.class);
+	}
+
+	public <X> X convert(Map mapFromJson, Class<X> klass) {
+		// inefficient, but should work
+		String json = toJson(mapFromJson);
+		X obj = fromJson(json, klass);
+		return obj;
+	}
+	
+
+	private static Gson SAFE_GSON = new GsonBuilder()
+				.setLenientReader(true)
+				.serializeSpecialFloatingPointValues()
+				.setDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
+				.setClassProperty(null).setLoopPolicy(KLoopPolicy.QUIET_NULL)
+				.create();
+	
+	/**
+	 * This is the GSON used by {@link #toJSON(Object)} and {@link #fromJSON(String)}.
+	 * @param gson
+	 */
+	public static void setDefaultGSON(Gson gson) {
+		SAFE_GSON = gson;
+	}
+	/**
+	 * Convenience for a safe robust default just-read-me-some-json convertor.
+	 * @param json
+	 * @return object
+	 */
+	// Note: named with capitals to avoid conflict with toJson()
+	public static Map fromJSON(String json) {
+		return SAFE_GSON.fromJson(json, Map.class);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 0c917d46f..0de7cbd98 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -76,6 +76,7 @@
  * @author Jesse Wilson
  */
 public final class GsonBuilder {
+  public static final String DEFAULT_CLASS_PROPERTY = "@class";	
   private Excluder excluder = Excluder.DEFAULT;
   private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;
   private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;
@@ -93,7 +94,10 @@
   private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+  private String classProperty = DEFAULT_CLASS_PROPERTY;
+  private KLoopPolicy loopPolicy = KLoopPolicy.QUIET_NULL;  
   private boolean lenient = DEFAULT_LENIENT;
+private boolean stripComments;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -569,7 +573,7 @@ public Gson create() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        serializeSpecialFloatingPointValues, longSerializationPolicy, factories, classProperty);
   }
 
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
@@ -587,4 +591,41 @@ private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeS
     factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));
     factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));
   }
+
+  
+  //Added by SoDash
+  /**
+   * Set the property name used for recording the Java class behind the
+   * json. Adding this info to the json output allows us to 
+   * de-serialize sub-classes and interface implementations.
+   * 
+   * @param propertyName Can be null to switch-off "@class" output.
+   * Defaults to "@class"
+   */
+	public GsonBuilder setClassProperty(String propertyName) {
+		this.classProperty = propertyName;
+		return this;
+	}
+	
+
+	// Added by SoDash
+	/**
+	 * @param loopy The default is {@link KLoopPolicy#QUIET_NULL}. We assume that if you're using this fork of
+	 * the Gson library, then you want robust flexible serialisation. 
+	 */
+	public GsonBuilder setLoopPolicy(KLoopPolicy loopy) {
+		loopPolicy = loopy;
+		return this;
+	}
+
+	/**
+	 * Allow comments in json. Comments are not valid in json -- though they are allowed in javascript, and often useful.
+	 * @see JsonReader#setLenient(boolean)
+	 * @param stripComments
+	 * @return this
+	 */
+	public GsonBuilder setLenientReader(boolean stripComments) {
+		this.stripComments = stripComments;
+		return this;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/KLoopPolicy.java b/gson/src/main/java/com/google/gson/KLoopPolicy.java
new file mode 100644
index 000000000..e7121d11a
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/KLoopPolicy.java
@@ -0,0 +1,25 @@
+package com.google.gson;
+
+/**
+ * @author daniel
+ *
+ */
+public enum KLoopPolicy {
+	/** The default behaviour (NB: this is equivalent to setting null as the loop-policy). Loops will cause stack-overflow. */
+	NO_CHECKS,
+	/**
+	 * Check and throw an exception if a loop is detected.
+	 */
+	EXCEPTION,
+	/** If a loop occurs, put in a null. So you can safely serialise objects with circular references, but deserialising may lose info*/
+	QUIET_NULL,
+//	/**
+//	 * TODO JSOG style "@id" and "@ref" fields. This differs from JSOG in that it only uses "@id" when a loop is detected
+//	 */
+//	ID_REF,
+	/**
+	 * TODO Use "@id" and "@ref" fields for the JSOG format.
+	 */
+	JSOG
+	;
+}
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index ffe3cb48e..7c937ea18 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -61,7 +61,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     @SuppressWarnings("unchecked") // types must agree
     final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
     if (typeCreator != null) {
-      return new ObjectConstructor<T>() {
+      return new AObjectConstructor<T>(rawType) {
         @Override public T construct() {
           return typeCreator.createInstance(type);
         }
@@ -73,7 +73,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     final InstanceCreator<T> rawTypeCreator =
         (InstanceCreator<T>) instanceCreators.get(rawType);
     if (rawTypeCreator != null) {
-      return new ObjectConstructor<T>() {
+      return new AObjectConstructor<T>(rawType) {
         @Override public T construct() {
           return rawTypeCreator.createInstance(type);
         }
@@ -100,7 +100,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
       if (!constructor.isAccessible()) {
         constructor.setAccessible(true);
       }
-      return new ObjectConstructor<T>() {
+      return new AObjectConstructor<T>(rawType) {
         @SuppressWarnings("unchecked") // T is the same raw type as is requested
         @Override public T construct() {
           try {
@@ -133,13 +133,13 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
       final Type type, Class<? super T> rawType) {
     if (Collection.class.isAssignableFrom(rawType)) {
       if (SortedSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
+        return new AObjectConstructor<T>(rawType) {
+          public T construct() {
             return (T) new TreeSet<Object>();
           }
         };
       } else if (EnumSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(rawType) {
           @SuppressWarnings("rawtypes")
           @Override public T construct() {
             if (type instanceof ParameterizedType) {
@@ -155,20 +155,20 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
           }
         };
       } else if (Set.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(LinkedHashSet.class) {
           @Override public T construct() {
             return (T) new LinkedHashSet<Object>();
           }
         };
       } else if (Queue.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(ArrayDeque.class) {
           @Override public T construct() {
             return (T) new ArrayDeque<Object>();
           }
         };
       } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
+        return new AObjectConstructor<T>(ArrayList.class) {
+          public T construct() {
             return (T) new ArrayList<Object>();
           }
         };
@@ -177,33 +177,33 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
 
     if (Map.class.isAssignableFrom(rawType)) {
       if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(ConcurrentSkipListMap.class) {
           @Override public T construct() {
             return (T) new ConcurrentSkipListMap<Object, Object>();
           }
         };
       } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(ConcurrentHashMap.class) {
           @Override public T construct() {
             return (T) new ConcurrentHashMap<Object, Object>();
           }
         };
       } else if (SortedMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
+        return new AObjectConstructor<T>(TreeMap.class) {
           @Override public T construct() {
             return (T) new TreeMap<Object, Object>();
           }
         };
       } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
           TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
+        return new AObjectConstructor<T>(LinkedHashMap.class) {
+          public T construct() {
             return (T) new LinkedHashMap<Object, Object>();
           }
         };
       } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
+        return new AObjectConstructor<T>(LinkedTreeMap.class) {
+          public T construct() {
             return (T) new LinkedTreeMap<String, Object>();
           }
         };
@@ -215,7 +215,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
 
   private <T> ObjectConstructor<T> newUnsafeAllocator(
       final Type type, final Class<? super T> rawType) {
-    return new ObjectConstructor<T>() {
+    return new AObjectConstructor<T>(rawType) {
       private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
       @SuppressWarnings("unchecked")
       @Override public T construct() {
@@ -234,3 +234,27 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     return instanceCreators.toString();
   }
 }
+
+abstract class AObjectConstructor<T> implements ObjectConstructor<T> {
+
+	private Class type;
+
+	/**
+	 * @param type The type output by {@link #construct()} 
+	 */
+	AObjectConstructor(Class type) {
+		this.type = type;
+	}
+	
+	@Override
+	public final String toString() {
+		return "ObjectConstructor["+type+"]";
+	}
+	
+	@Override
+	public Class<T> getType() {
+		return type;
+	}
+	
+	
+}
diff --git a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java b/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
index 6ef20607f..cb34a02fa 100644
--- a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
@@ -23,6 +23,7 @@
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
+ * @author Daniel Winterstein
  */
 public interface ObjectConstructor<T> {
 
@@ -30,4 +31,9 @@
    * Returns a new instance.
    */
   public T construct();
+  
+  /**
+   * @return What does this ObjectConstructor output?
+   */
+  public Class getType();
 }
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LateBinding.java b/gson/src/main/java/com/google/gson/internal/bind/LateBinding.java
new file mode 100644
index 000000000..a65db9319
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/LateBinding.java
@@ -0,0 +1,47 @@
+package com.google.gson.internal.bind;
+
+/**
+ * For JSOG references, where the object hasn't finished being made yet.
+ * @author daniel
+ *
+ */
+public class LateBinding {
+
+	public final String ref;
+
+	public LateBinding(String ref) {
+		this.ref = ref;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((ref == null) ? 0 : ref.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		LateBinding other = (LateBinding) obj;
+		if (ref == null) {
+			if (other.ref != null)
+				return false;
+		} else if (!ref.equals(other.ref))
+			return false;
+		return true;
+	}
+
+	@Override
+	public String toString() {
+		return "LateBinding [ref=" + ref + "]";
+	}
+
+	
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java
new file mode 100644
index 000000000..6ff221ed7
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java
@@ -0,0 +1,437 @@
+package com.google.gson.internal.bind;
+
+import java.io.IOException;
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.KLoopPolicy;
+import com.google.gson.TypeAdapter;
+import com.google.gson.internal.ConstructorConstructor;
+import com.google.gson.internal.ObjectConstructor;
+import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.winterwell.utilslite.MathUtils;
+import com.winterwell.utilslite.ReflectionUtils;
+
+/**
+ * Broken out from {@link ReflectiveTypeAdapterFactory} for clarity, as it is a core component.
+ * Uses "@class" property to instantiate sub-classes.
+ * 
+ * @author Google et al + Daniel
+ *
+ * @param <T>
+ */
+public final class ReflectiveTypeAdapter<T> extends TypeAdapter<T> {
+    private final ObjectConstructor<T> constructor;
+    private final Map<String, BoundField> boundFields;
+	private final KLoopPolicy loopPolicy;
+	private final String classProperty;
+	private final ConstructorConstructor conCon; 
+	private final Gson gson;
+
+    ReflectiveTypeAdapter(Gson gson, ObjectConstructor<T> constructor, Map<String, BoundField> boundFields, ConstructorConstructor conCon) {
+      this.constructor = constructor;
+      this.conCon = conCon;
+      this.boundFields = boundFields;
+      this.classProperty = gson.getClassProperty();
+      this.loopPolicy = gson.getLoopPolicy();
+      this.gson = gson;
+    }
+
+    @Override public T read(JsonReader in) throws IOException {
+    	JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+      
+		// So we're in the reflection based reader.
+		// Should we replace the default constructor behaviour?
+		// Check the reader for a _class property
+		try {
+			TypeAdapter<?> _typeAdapter = read2(in);
+			if (_typeAdapter != null && _typeAdapter!=this) {
+				return (T) _typeAdapter.read(in);
+			}
+		} catch (IOException ex) {
+			throw ex;
+		} catch (Exception ex) {
+			throw new IOException(ex);
+		}
+
+		// Just a map
+		if (constructor.getType() == Object.class) {
+			return read2_justAMap(in, peek);
+		}
+
+
+      try {
+  		// Make the Thing
+          T instance = constructor.construct();
+			// fill in its fields
+        in.beginObject();
+        while (in.hasNext()) {
+          String name = in.nextName();
+          BoundField field = boundFields.get(name);
+          if (field == null || !field.deserialized) {
+            in.skipValue();
+          } else {
+				// TODO LateBinding
+            field.read(in, instance);
+          }
+        }
+        in.endObject();
+        return instance;
+
+      } catch (IllegalStateException e) {
+        throw new JsonSyntaxException(e);
+      } catch(RuntimeException ex) {
+			// An interface? We have to hope for a late find of a @class property
+			if (constructor.getType().isInterface()) {			
+				return read2_justAMap(in, peek);
+			}
+			throw ex;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+    
+	private T read2_justAMap(JsonReader in, JsonToken peek) throws IOException {
+		if (peek==JsonToken.BEGIN_OBJECT) {
+			// read the map in
+			Map obj = read2_map(in);
+			// JSOG id / ref?
+			String id = null;
+			if (loopPolicy==KLoopPolicy.JSOG) {
+				String ref = (String) obj.get("@ref");
+				if (ref!=null) {
+					Object refVal = in.getIdValue(ref);
+					if (refVal==null) {
+						// we have to wait until the end to de-ref this
+						return (T) new LateBinding(ref);
+					}
+					return (T) refVal;
+				}
+				id = (String) obj.remove("@id");	
+			}
+			try {
+				// late find of the @class property? Or stay the same?
+				T castObj = (T) read2_maybeChangeClass((Map<String, Object>) obj, in);
+				// if we found an id, track the reference
+				if (id!=null) {
+					in.putIdValue(id, castObj);
+				}
+				return castObj;
+			} catch (Exception e) {
+				throw new IOException(e);
+			}
+		}
+		
+		Object obj = read3_value(in);
+		return (T) obj;
+	}
+
+	/**
+	 * Recurse (and recursively use our special sauce as well -- but avoid stack-overflow)
+	 * @param in
+	 * @return
+	 * @throws IOException
+	 */
+	private Map read2_map(JsonReader in) throws IOException {
+    	Map<String,Object> temp = new HashMap();
+    	in.beginObject();    	
+    	while(in.hasNext()) {
+    		String name = in.nextName();
+    		// recursively read the value, inc our special sauce    		
+    		Object value =read3_value(in);    		
+    		temp.put(name, value);
+    	}
+    	in.endObject();
+    	return temp;
+	}
+
+	/**
+	 * Copy and paste code from {@link ObjectTypeAdapter} BUT with a true recursive call.
+	 * Otherwise, our classes end up as primitives.
+	 * 
+	 * Note: We may have to further convert the outputs later, when we find out what they're meant to be. 
+	 * 
+	 * @param in
+	 * @return
+	 * @throws IOException
+	 */
+	private Object read3_value(JsonReader in) throws IOException {
+		JsonToken token = in.peek();
+		switch (token) {
+		case BEGIN_ARRAY:
+			List<Object> list = new ArrayList<Object>();
+			in.beginArray();
+			while (in.hasNext()) {
+				list.add(read(in));
+			}
+			in.endArray();
+			return list;
+
+		case BEGIN_OBJECT:
+			// recurse properly!
+			Object map = gson.fromJson(in, Object.class);
+			return map;
+
+		case STRING:
+			return in.nextString();
+
+		case NUMBER:
+			// Normally double, but can return BigInteger if needed
+			return in.nextNumber();
+
+		case BOOLEAN:
+			return in.nextBoolean();
+
+		case NULL:
+			in.nextNull();
+			return null;
+
+		default:
+			throw new IllegalStateException();
+		}
+	}
+
+	Object read2_maybeChangeClass(Map<String, Object> map, JsonReader in) throws Exception {
+		String _class = (String) map.get(classProperty);
+		if (_class == null)
+			return map;
+		Class<?> typeOfT = Class.forName(_class);
+		ObjectConstructor<?> con = conCon.get(TypeToken.get(typeOfT));
+		Object obj = con.construct();
+		// fill in the fields from map
+		for (Map.Entry<String, Object> me : map.entrySet()) {
+			if (classProperty.equals(me.getKey()))
+				continue;
+			Class klass = obj.getClass(); // ??type.getRawType()
+			Field f = getField(klass, me.getKey());
+			if (f == null) {
+				if ("@id".equals(me.getKey())) {
+					in.putIdValue((String)me.getValue(), obj);
+				}
+				// a field has been removed from the class. Skip over it
+				// Log.d("gson", "skip missing field "
+				// + obj.getClass().getName() + " " + me);
+				continue;
+			}
+			Object value = me.getValue();
+			
+			if (value == null) {
+				// Set it anyway -- null may be replacing a non-null default
+				f.set(obj, value);
+				continue;
+			}
+			
+			// LateBinding?
+			assert value != null;
+			value = read3_lateBinding(obj, f, -1, value, in);
+			// ...cant resolve it yet?
+			if (value==null) continue;
+			
+			// Class-correction: Correct for wrong-class choices, based on what the target field is.
+			// Is the target a number? We get class-cast issues where gson
+			// has opted for Double, but we need Integer			
+			Class fClass = f.getType();
+			if (fClass != double.class && ReflectionUtils.isaNumber(fClass)) {
+				value = MathUtils.cast(fClass, (Number) value);
+				
+			} else if (value instanceof String && ! ReflectionUtils.isa(String.class, fClass)) {
+				// If a Map convertor was used earlier, classes like Class and URI can end up as Strings 
+				value = gson.fromJson((String)value, fClass);
+				
+			} else if (value instanceof Map && ! ReflectionUtils.isa(value.getClass(), fClass)) {
+				// Handle Map/List sub-class choices based on the field
+				// E.g. a ListMap could get serialised to {}, deserialised to LinkedHashMap -- in which case convert
+				Map mapSubClass = (Map) fClass.newInstance();
+				mapSubClass.putAll((Map)value);
+				value = mapSubClass;
+				
+			} else if (value instanceof Collection && ! ReflectionUtils.isa(value.getClass(), fClass)) {
+				// Same as Map above, but for Lists, Sets and Arrays
+				Collection collection = (Collection)value;
+				// an array?
+				if (fClass.isArray()) {
+					Class compType = fClass.getComponentType();
+					Object array = Array.newInstance(compType, collection.size());
+					int i=0;
+					for(Object vi : collection) {
+						if (vi!=null) {
+							vi = read3_lateBinding(array, null, i, vi, in);
+						}
+						Array.set(array, i, vi);
+						i++;
+					}
+					value = array;
+					
+				} else {
+					Collection listSubClass = (Collection) fClass.newInstance();
+					int i=0;
+					for(Object vi : collection) {
+						if (vi!=null) {
+							vi = read3_lateBinding(listSubClass, null, i, vi, in);
+						}
+						listSubClass.add(vi);
+						i++;
+					}
+					value = listSubClass;
+				}
+			} // end of class correction
+			
+			// Set it
+			f.set(obj, value);
+		}
+		return obj;
+	}
+
+	/**
+	 * 
+	 * @param value
+	 * @param in 
+	 * @param value2 
+	 * @param f 
+	 * @return value/lookup-of-value, or null if value was a LateBinding we cant yet resolve.
+	 */
+	private Object read3_lateBinding(Object obj, Field f, int index, Object value, JsonReader in) {
+		assert value != null;
+		if ( ! (value instanceof LateBinding)) return value;
+		LateBinding lb = (LateBinding) value;
+		Object val = in.getIdValue(lb.ref);
+		if (val==null) {
+			in.addLateBinding(obj, f, index, lb);
+			return null;
+		}
+		return val;	
+	}
+
+	private Field getField(Class klass, String key) {
+		// NB: often klass != type.getRawType(), but a sub-class
+
+		// ?? slightly inefficient -- we look up the Fields each time,
+		// whereas elsewhere we cache them.
+		Field f = ReflectionUtils.getField(klass, key);
+		if (f==null) return null;
+		f.setAccessible(true);
+		return f;
+	}
+
+	/**
+	 * Check the reader for a _class property
+	 * 
+	 * @param in
+	 * @return the TypeAdaptor to use, or null to carry on with the default
+	 * @throws Exception
+	 */
+	private TypeAdapter<?> read2(JsonReader in) throws Exception {
+		if (classProperty == null)
+			return null;
+		JsonReader _reader = in.getShortTermCopy();
+		try {
+			JsonToken peeked = _reader.peek();
+			if (peeked != JsonToken.BEGIN_OBJECT)
+				return null;
+			_reader.beginObject();
+			if (!_reader.hasNext())
+				return null;
+			String name = _reader.nextName();
+			if (!classProperty.equals(name))
+				return null;
+			String klass = _reader.nextString();
+			return read3(klass);
+		} finally {
+			in.reset();
+		}
+	}
+
+	TypeAdapter read3(String klass) throws ClassNotFoundException {
+		// what does the constructor handle??
+		if (constructor.getType().getCanonicalName().equals(klass)) {
+			// no change needed (as you were -- use constructor)
+			return null;
+		}
+		Class<?> typeOfT = Class.forName(klass);
+		TypeToken tt = TypeToken.get(typeOfT);
+		TypeAdapter _typeAdapter = gson.getAdapter(tt);
+		return _typeAdapter;
+	}
+
+
+    @Override public void write(JsonWriter out, T value) throws IOException {
+      if (value == null) {
+        out.nullValue();
+        return;
+      }
+
+      out.beginObject();
+      
+      // start DBW
+		// id / ref?
+		if (loopPolicy==KLoopPolicy.JSOG) {
+			String ref = out.getRef(value);
+			if (ref != null) {
+				// already seen -- just reference it
+				out.name("@ref");
+				out.value(ref);
+				out.endObject();
+				if (loopPolicy != KLoopPolicy.NO_CHECKS) {
+					out.endLoopCheck(value);
+				}
+				return;
+			}
+		}
+		// id? TODO do after the class-property, so that class can be found with a peek.
+		// Which would be more efficient. Except, that code isn't ready yet.
+		if (loopPolicy==KLoopPolicy.JSOG) {
+			String id = out.getNewId(value);
+			out.name("@id");
+			out.value(id);
+		}
+
+		if (classProperty != null) {
+			// anonymous classes return null here
+			String cName = value.getClass().getCanonicalName();
+			// We can't do anything sensible at de-serialisation with
+			// member-classes.
+			// So leave it for the object->map adapter
+			boolean mc = value.getClass().isMemberClass();
+			if (mc || cName==null) {
+				// ??
+			} else if (value.getClass() != Object.class) {
+				out.name(classProperty);
+				out.value(cName);
+			}
+		}
+		// end DBW
+      
+      try {
+        for (BoundField boundField : boundFields.values()) {
+          if (boundField.writeField(value)) {
+            out.name(boundField.name);
+            boundField.write(out, value);
+          }
+        }
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+      out.endObject();
+      
+      // start DBW
+		if (loopPolicy != KLoopPolicy.NO_CHECKS) {
+			out.endLoopCheck(value);
+		}
+		// end DBW
+    }
+  }
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 34e97664e..fe8434aea 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -18,7 +18,6 @@
 
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
@@ -30,7 +29,6 @@
 import com.google.gson.internal.Primitives;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Field;
@@ -97,7 +95,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     }
 
     ObjectConstructor<T> constructor = constructorConstructor.get(type);
-    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
+    return new ReflectiveTypeAdapter<T>(gson, constructor, getBoundFields(gson, type, raw), constructorConstructor);
   }
 
   private ReflectiveTypeAdapterFactory.BoundField createBoundField(
@@ -191,62 +189,4 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
     abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;
   }
-
-  public static final class Adapter<T> extends TypeAdapter<T> {
-    private final ObjectConstructor<T> constructor;
-    private final Map<String, BoundField> boundFields;
-
-    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
-      this.constructor = constructor;
-      this.boundFields = boundFields;
-    }
-
-    @Override public T read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-
-      T instance = constructor.construct();
-
-      try {
-        in.beginObject();
-        while (in.hasNext()) {
-          String name = in.nextName();
-          BoundField field = boundFields.get(name);
-          if (field == null || !field.deserialized) {
-            in.skipValue();
-          } else {
-            field.read(in, instance);
-          }
-        }
-      } catch (IllegalStateException e) {
-        throw new JsonSyntaxException(e);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-      in.endObject();
-      return instance;
-    }
-
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
-
-      out.beginObject();
-      try {
-        for (BoundField boundField : boundFields.values()) {
-          if (boundField.writeField(value)) {
-            out.name(boundField.name);
-            boundField.write(out, value);
-          }
-        }
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-      out.endObject();
-    }
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index 2bf37ad0a..782da9517 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -54,10 +54,10 @@ public void write(JsonWriter out, T value) throws IOException {
     Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
     if (runtimeType != type) {
       TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
-      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapter)) {
         // The user registered a type adapter for the runtime type, so we will use that
         chosen = runtimeTypeAdapter;
-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+      } else if (!(delegate instanceof ReflectiveTypeAdapter)) {
         // The user registered a type adapter for Base class, so we prefer it over the
         // reflective type adapter for the runtime type
         chosen = delegate;
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 9c55c4367..1f36024e8 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -18,10 +18,18 @@
 
 import com.google.gson.internal.JsonReaderInternalAccess;
 import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.gson.internal.bind.LateBinding;
+
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Reader;
+import java.lang.reflect.Field;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
 
 /**
  * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
@@ -224,12 +232,18 @@
   private static final int NUMBER_CHAR_EXP_DIGIT = 7;
 
   /** The input JSON. */
-  private final Reader in;
+	public final Reader in;
 
   /** True to accept non-spec compliant JSON */
   private boolean lenient = false;
 
   /**
+	 * Only used for JSOG loop-policy output
+	 */
+	private final HashMap<String,Object> ids = new HashMap();
+	
+	
+	/**
    * Use a manual buffer to easily read and unread upcoming characters, and
    * also so we can create strings without an intermediate StringBuilder.
    * We decode literals directly out of this buffer, so it must be at least as
@@ -347,7 +361,8 @@ public void beginArray() throws IOException {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
+			throw new IllegalStateException("Expected BEGIN_ARRAY but was "
+					+ peek() + locationString());
     }
   }
 
@@ -365,7 +380,8 @@ public void endArray() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
+			throw new IllegalStateException("Expected END_ARRAY but was "
+					+ peek() + locationString());
     }
   }
 
@@ -382,7 +398,8 @@ public void beginObject() throws IOException {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
+			throw new IllegalStateException("Expected BEGIN_OBJECT but was "
+					+ peek() + locationString());
     }
   }
 
@@ -401,7 +418,8 @@ public void endObject() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
+			throw new IllegalStateException("Expected END_OBJECT but was "
+					+ peek() + locationString());
     }
   }
 
@@ -458,6 +476,47 @@ public JsonToken peek() throws IOException {
     }
   }
 
+
+  /**
+   * Make a copy of the reader, and mark the underlying reader so it can be reset.
+   * @return
+   * @throws IOException
+   * (Winterwell)
+   */
+	public JsonReader getShortTermCopy() throws IOException {
+      try {
+          JsonReader jr = new JsonReader(in);
+
+          // Mark it because we're going to reset pretty soon
+          jr.in.mark(1024);
+
+          jr.lenient = lenient;
+          jr.pos = pos;
+          jr.limit = limit;
+          jr.lineNumber = lineNumber;
+          jr.lineStart = lineStart;
+          jr.peeked = peeked;
+          jr.peekedLong = peekedLong;
+          jr.peekedNumberLength = peekedNumberLength;
+          jr.peekedString = peekedString;
+          jr.stack = Arrays.copyOf(stack, stack.length);
+          jr.stackSize = stackSize;
+          jr.pathNames = Arrays.copyOf(pathNames, pathNames.length);
+          jr.pathIndices = Arrays.copyOf(pathIndices, pathIndices.length);
+          // FIXME have we copied everything??
+          System.arraycopy(buffer, 0, jr.buffer, 0, buffer.length);
+          return jr;
+      } catch (IOException ex) {
+          // mark not supported
+          throw new IOException(ex.getMessage()+" "+in.getClass());
+      }
+	}
+
+	public void reset() throws IOException {
+		this.in.reset();
+	}
+
+  
   int doPeek() throws IOException {
     int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
@@ -917,6 +976,61 @@ public double nextDouble() throws IOException {
     return result;
   }
 
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} or
+	 * BigInteger value of the next token, consuming it. If the next token is a
+	 * string, this method will attempt to parse it as a double using
+	 * {@link Double#parseDouble(String)}.
+	 *
+	 * @throws IllegalStateException
+	 *             if the next token is not a literal value.
+	 * @throws NumberFormatException
+	 *             if the next literal value cannot be parsed as a double, or is
+	 *             non-finite.
+	 */
+	public Number nextNumber() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		if (p == PEEKED_LONG) {
+			peeked = PEEKED_NONE;
+			return (double) peekedLong;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+			peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\''
+					: '"');
+		} else if (p == PEEKED_UNQUOTED) {
+			peekedString = nextUnquotedValue();
+		} else if (p != PEEKED_BUFFERED) {
+			throw new IllegalStateException("Expected a double but was "
+					+ peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double dresult = Double.parseDouble(peekedString); // don't catch this
+															// NumberFormatException.
+		Number result = dresult;
+		if (dresult > Long.MAX_VALUE && peekedString.indexOf('.') == -1
+				&& peekedString.indexOf('E') == -1) {
+			BigInteger bi = new BigInteger(peekedString);
+			result = bi;
+		}
+		if (!lenient && (Double.isNaN(dresult) || Double.isInfinite(dresult))) {
+			throw new MalformedJsonException(
+					"JSON forbids NaN and infinities: " + result + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		return result;
+	}
+  
   /**
    * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
@@ -1605,4 +1719,24 @@ private void consumeNonExecutePrefix() throws IOException {
       }
     };
   }
+
+	public Object getIdValue(String ref) {
+		return ids.get(ref);
+	}
+	public void putIdValue(String id, Object value) {
+		ids.put(id, value);
+	}
+
+	public void addLateBinding(Object obj, Field f, int index, LateBinding lb) {
+		lateBindings.add(new Object[]{obj, f, index, lb});
+	}
+	
+	/**
+	 * [object, field, index, LB]
+	 */
+	List<Object[]> lateBindings = new ArrayList(0);
+
+	public List<Object[]> getLateBindings() {
+		return lateBindings;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index e2fc19611..7c298be81 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -20,6 +20,11 @@
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.HashMap;
+
+import com.google.gson.KLoopPolicy;
 
 import static com.google.gson.stream.JsonScope.DANGLING_NAME;
 import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;
@@ -656,4 +661,66 @@ private void beforeValue() throws IOException {
       throw new IllegalStateException("Nesting problem.");
     }
   }
+
+	final Deque loopy = new ArrayDeque();
+
+	/**
+	 * Calls to this must be paired with a call to {@link #endLoopCheck(Object)}
+	 * 
+	 * @param policy
+	 * @param source
+	 * @return ok-flag. true=all-fine, false if a loop is detected.
+	 */
+	public boolean beginLoopCheck(KLoopPolicy policy, Object source) {
+		if (policy == KLoopPolicy.NO_CHECKS)
+			return true;
+		if (loopy.contains(source)) {
+			switch (policy) {
+			case EXCEPTION:
+				throw new IllegalArgumentException(
+						"Circular references not allowed.");
+			case QUIET_NULL:
+				return false;
+			}
+		}
+		loopy.push(source);		
+		return true;
+	}
+	
+	/**
+	 * @param object
+	 * @return JSOG "@ref" or null
+	 */
+	public String getRef(Object object) {
+		String id = ids.get(object);
+		return id;
+	}
+	
+	
+	/**
+	 * Only used for JSOG loop-policy output
+	 */
+	private final HashMap<Object,String> ids = new HashMap();
+	
+	/**
+	 * @param object
+	 * @return A freshly created JSOG "@id"
+	 * 
+	 * @see #getRef(Object)
+	 * @see KLoopPolicy#JSOG
+	 */
+	public String getNewId(Object object) {
+		String id = String.valueOf(ids.size()+1);
+		String old = ids.put(object, id);
+		assert old == null;
+		return id;
+	}
+	
+
+	public void endLoopCheck(Object source) {
+		// guard, because loop checking might be off in which case this could be
+		// empty
+		if (loopy.peek() == source)
+			loopy.pop();
+	}
 }
diff --git a/gson/src/main/java/com/winterwell/utilslite/MathUtils.java b/gson/src/main/java/com/winterwell/utilslite/MathUtils.java
new file mode 100755
index 000000000..83b2fd820
--- /dev/null
+++ b/gson/src/main/java/com/winterwell/utilslite/MathUtils.java
@@ -0,0 +1,590 @@
+
+package com.winterwell.utilslite;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * @testedby {@link MathUtilsTest}
+ * @author daniel
+ * 
+ */
+public class MathUtils {
+
+	private static double MACH_EPS = -1;
+
+	private static Pattern NUMBER = Pattern
+			.compile("[^0-9\\-]?([0-9\\.\\-]+)[^0-9]{0,3}");
+
+	public static final double ROOT_TWO = Math.sqrt(2);
+
+	public static double[] abs(double... values) {
+		double[] values2 = new double[values.length];
+		for (int i = 0; i < values.length; i++) {
+			values2[i] = Math.abs(values[i]);
+		}
+		return values2;
+	}
+
+	/**
+	 * What's the most efficient way of condensing a long into an azAZ0-9-_
+	 * string? i.e. we want to express the long in base 64. Uses a
+	 * least-significant-first encoding.
+	 * 
+	 * @param idNum
+	 *            Must be positive
+	 * @return a short String form for the id
+	 */
+	public static String generateB64Code(long idNum) {
+		assert idNum >= 0 : idNum;
+		char[] bin = Long.toBinaryString(idNum).toCharArray();
+		// now one base 64 char = 7 binary chars??
+		StringBuilder b64 = new StringBuilder(1 + bin.length / 7);
+		short b64c = 0;
+		int n = 0;
+		for (int i = bin.length - 1; i != -1; i--) {
+			char bc = bin[i];
+			if (bc == '1') {
+				b64c += twos[n];
+			}
+			n++;
+			if (n == 6) {
+				b64.append(charTab[b64c]);
+				n = 0;
+				b64c = 0;
+			}
+		}
+		if (n != 0) {
+			b64.append(charTab[b64c]);
+		}
+		// this is least-significant-digit first, but who cares
+		return b64.toString();
+	}
+
+	static final short[] twos = new short[] { 1, 2, 4, 8, 16, 32, 64 };
+	/**
+	 * 64 url-safe chars.
+	 * <p>
+	 * The unusual ordering is so that binary search will work in this array.
+	 */
+	static final char[] charTab = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
+			.toCharArray();
+
+	/**
+	 * Inverse of {@link #generateB64Code(long)}
+	 * 
+	 * @param cde
+	 * @return
+	 */
+	public static long decodeB64(String cde) {
+		long v = 0;
+		long pow = 1;
+		for (int i = 0; i < cde.length(); i++) {
+			char c = cde.charAt(i);
+			int ci = Arrays.binarySearch(charTab, c);
+			v += ci * pow;
+			pow = 64 * pow;
+		}
+		return v;
+	}
+
+	/**
+	 * A less precise version of {@link #equalish(double, double)}. Useful for
+	 * testing stochastic things.
+	 * 
+	 * @param x
+	 * @param y
+	 * @return true if x roughly equals y. Uses ~25% tolerance for non-zero x,y.
+	 *         The result is inherently arbitrary if x or y are zero.
+	 */
+	public static boolean approx(double x, double y) {
+		if (x == 0 || y == 0)
+			// arbitrary limit
+			return Math.abs(x - y) < 0.25;
+		double d = Math.abs(x - y);
+		double m2 = Math.abs(x + y);
+		return d / m2 < 0.125;
+	}
+
+	/**
+	 * @param x
+	 * @param y
+	 * @return true if x approximately equals y. Uses ~1% tolerance for non-zero
+	 *         x,y. The result is inherently arbitrary if x or y are zero.
+	 * @see #approx(double, double)     
+	 */
+	public static boolean equalish(double x, double y) {
+		if (x == 0 || y == 0)
+			// arbitrary limit
+			return Math.abs(x - y) < 0.001;
+		double d = Math.abs(x - y);
+		double m2 = Math.abs(x + y);
+		return d / m2 < 0.005;
+	}
+
+	public static double euclideanLength(double[] vector) {
+		double x2 = 0;
+		for (double d : vector) {
+			x2 += d * d;
+		}
+		return Math.sqrt(x2);
+	}
+
+	/**
+	 * Simple convenience function: Cap value - if necessary - to lie in [min,
+	 * max].
+	 * 
+	 * @param x
+	 * @param min
+	 * @param max
+	 * @return x'
+	 */
+	public static double forceIn(double x, double min, double max) {
+		assert min <= max;
+		if (x < min)
+			return min;
+		if (x > max)
+			return max;
+		return x;
+	}
+
+	/**
+	 * The smallest safe double. 
+	 * Machine epsilon gives an upper bound on the relative error due to
+	 * rounding in floating point arithmetic.
+	 * 
+	 * @author Wikipedia
+	 */
+	public static double getMachineEpsilon() {
+		if (MACH_EPS != -1)
+			return MACH_EPS;
+		double machEps = 1.0;
+		do {
+			machEps /= 2.0;
+		} while ((1.0 + (machEps / 2.0)) != 1.0);
+		MACH_EPS = machEps;
+		return MACH_EPS;
+	}
+
+	/**
+	 * Less lenient Long flavoured version of {@link #getNumber(Object)}.
+	 * Throws exceptions on fail.
+	 * @param num Must not be null. Can be a Number or String
+	 * @return long 
+	 * 
+	 * @see #getNumber(Object)
+	 * @see #num(Object)
+	 * @see StrUtils#isNumber(String)
+	 */
+	public static long numLong(Object _num) throws NumberFormatException {
+		if (_num instanceof Number) {
+			return ((Number) _num).longValue();
+		}
+		String num = _num.toString();
+		return Long.valueOf(num);
+	}
+	
+	/**
+	 * @param x
+	 * @return true if not infinite and not NaN
+	 * @testedby {@link MathUtilsTest#testIsFinite()}
+	 */
+	public static boolean isFinite(double x) {
+		return !(Double.isNaN(x) || Double.isInfinite(x));
+	}
+	/**
+	 * @param x
+	 * @return true if finite and below {@link #TOO_BIG}
+	 */
+	public static boolean isSafe(double x) {
+		return ! (Math.abs(x) > TOO_BIG || Double.isNaN(x) || Double.isInfinite(x));
+	}
+
+	public static boolean isProb(double x) {
+		return x >= 0 && x <= 1.0000000001;
+	}
+
+	public static boolean isProb(float x) {
+		return x >= 0 && x <= 1.0000000001;
+	}
+
+	/**
+	 * @param x
+	 * @return if true, this should be treated as zero. Never divide by such a
+	 *         number!
+	 */
+	public static boolean isTooSmall(double x) {
+		// allow a bit extra room around machine-epsilon
+		return Math.abs(x) < 2*getMachineEpsilon();
+	}
+
+	/**
+	 * Handle &lt; comparison between any two Numbers, e.g. BigInteger and Long
+	 * 
+	 * @param a Must not be null
+	 * @param b Must not be null
+	 * @return true if a < b
+	 */
+	public static boolean lessThan(Number a, Number b) {
+		assert a != null && b!=null : a+" "+b;
+		// unavoidably ugly
+		if (a instanceof BigInteger) {
+			BigInteger bigB = b instanceof BigInteger ? (BigInteger) b
+					: new BigInteger(b.toString());
+			int c = ((BigInteger) a).compareTo(bigB);
+			return c < 0;
+		}
+		if (b instanceof BigInteger) {
+			BigInteger bigA = a instanceof BigInteger ? (BigInteger) a
+					: new BigInteger(a.toString());
+			int c = bigA.compareTo((BigInteger) b);
+			return c < 0;
+		}
+		if (a instanceof Long || b instanceof Long)
+			return a.longValue() < b.longValue();
+		return a.doubleValue() < b.doubleValue();
+	}
+	
+	/**
+	 * Handle &lt; comparison between any two Numbers, e.g. BigInteger and Long
+	 * 
+	 * @param a
+	 * @param b
+	 * @return a compareTo b. If a or b are null, this treats null as a low number.
+	 */
+	public static int compare(Number a, Number b) {
+		return COMPARE.compare(a, b);
+	}
+	
+	
+	/**
+	 * Handle &lt; comparison between any two Numbers, e.g. BigInteger and Long
+	 * 
+	 * @param a
+	 * @param b
+	 * @return a compareTo b. If a or b are null, this treats null as a low number.
+	 */
+	public static final Comparator<Number> COMPARE = new NumberComparator();
+
+	/**
+	 * Not the maximum double, but anything bigger than this is too easy to overflow. 
+	 */
+	public static final double TOO_BIG = Math.pow(Double.MAX_VALUE, 0.2);
+
+	/**
+	 * 
+	 * @param xs
+	 *            Can contain nulls -- which are ignored
+	 * @return this will be a member of the xs, null if the xs had no non-null
+	 *         values
+	 */
+	public static <N extends Number> N max(Collection<N> xs) {
+		assert !xs.isEmpty();
+		double max = Double.NEGATIVE_INFINITY;
+		N maxn = null;
+		for (N number : xs) {
+			// skip null!
+			if (number == null) {
+				continue;
+			}
+			// Cast down into double?! ??use lessThan instead??
+			double x = number.doubleValue();
+			if (x > max || maxn==null) {
+				max = x;
+				maxn = number;
+			}
+		}
+		return maxn;
+	}
+
+	/**
+	 * 
+	 * @param values
+	 *            Must not be zero-length or null
+	 * @return max of values
+	 */
+	public static double max(double... values) {
+		double max = values[0];
+		for (double i : values) {
+			if (i > max) {
+				max = i;
+			}
+		}
+		return max;
+	}
+
+	public static int max(int... values) {
+		int max = values[0];
+		for (int i : values) {
+			if (i > max) {
+				max = i;
+			}
+		}
+		return max;
+	}
+
+	/**
+	 * 
+	 * @param xs
+	 *            Can contain nulls -- which are ignored
+	 * @return this will be a member of the xs
+	 */
+	public static <N extends Number> N min(Collection<N> xs) {
+		assert !xs.isEmpty();
+		double min = Double.POSITIVE_INFINITY;
+		N minn = null;
+		for (N number : xs) {
+			// skip null!
+			if (number == null) {
+				continue;
+			}
+			double x = number.doubleValue();
+			if (x < min) {
+				min = x;
+				minn = number;
+			}
+		}
+		return minn;
+	}
+
+	/**
+	 * @param values
+	 *            Must not be zero-length or null
+	 * @return min of values (remember that -100 beats 1 - use min + abs if you
+	 *         want the smallest number)
+	 */
+	public static double min(double... values) {
+		double min = values[0];
+		for (double i : values) {
+			if (i < min) {
+				min = i;
+			}
+		}
+		return min;
+	}
+
+	/**
+	 * @param x
+	 * @return x*x (yes it's just a minor convenience)
+	 */
+	public static double sq(double x) {
+		return x * x;
+	}
+
+	public static double sum(double[] values) {
+		double total = 0;
+		for (double d : values) {
+			total += d;
+		}
+		return total;
+	}
+
+	/**
+	 * Copy numbers into an array.
+	 */
+	public static double[] toArray(Collection<? extends Number> values) {
+		double[] arr = new double[values.size()];
+		int i = 0;
+		for (Number d : values) {
+			arr[i] = d.doubleValue();
+			i++;
+		}
+		return arr;
+	}
+
+	/**
+	 * Copy numbers into an array. Note that using a Trove list in the first
+	 * place is more efficient. ?? Should this be in {@link Containers}?
+	 */
+	public static int[] toIntArray(Collection<Integer> values) {
+		int[] arr = new int[values.size()];
+		int i = 0;
+		for (Integer d : values) {
+			arr[i] = d;
+			i++;
+		}
+		return arr;
+	}
+
+	/**
+	 * Since Math.max() doesn't handle BigInteger
+	 * 
+	 * @param a Can be null
+	 * @param b Can be null
+	 * @return the max of a,b, or null if both are null
+	 */
+	public static BigInteger max(BigInteger a, BigInteger b) {
+		if (a==null) return b;
+		if (b==null) return a;
+		int c = a.compareTo(b);
+		return c < 0? b : a;
+	}
+	
+	/**
+	 * Since Math.max() doesn't handle BigInteger
+	 * 
+	 * @param a Can be null
+	 * @param b Can be null
+	 * @return the max of a,b, or null if both are null
+	 */
+	public static BigInteger min(BigInteger a, BigInteger b) {
+		if (a==null) return b;
+		if (b==null) return a;
+		int c = a.compareTo(b);
+		return c > 0? b : a;
+	}
+	
+	/**
+	 * Cast from one number type to another. Handles the annoying Double/double divide.
+	 * @param klass
+	 * @param nv Can be null (returns null)
+	 * @return nv as klass (which may involve rounding, e.g. double to int)
+	 */
+	public static <N extends Number> N cast(Class<N> klass, Number nv) {
+		if (nv==null) return null;
+		if (nv.getClass()==klass) return (N) nv;
+		// Ugly switch
+		if (klass==Integer.class || klass==int.class) return (N)(Number) nv.intValue();
+		if (klass==Long.class || klass==long.class) return (N)(Number) nv.longValue();
+		if (klass==Float.class || klass==float.class) return (N)(Number) nv.floatValue();
+		if (klass==Double.class || klass==double.class) return (N)(Number) nv.doubleValue();
+		if (klass==Short.class || klass==short.class) return (N)(Number) nv.shortValue();
+		if (klass==BigInteger.class) {
+			// We've probably lost some level of detail here!
+			if (nv instanceof BigDecimal) {
+				return (N) ((BigDecimal) nv).toBigInteger();
+			}
+			BigInteger value = new BigInteger(""+nv.longValue());
+			return (N) value;
+		}
+		if (klass==BigDecimal.class) {			
+			BigDecimal value = new BigDecimal(nv.toString());
+			return (N) value;
+		}
+		throw new RuntimeException("TODO "+klass+" "+nv.getClass());
+	}
+
+	/**
+	 * Lenient convertor -- accepts String or any Number subclass.
+	 * @param object Can be null (returns 0). Must be a simple number format - this method does not try
+	 * to read e.g. "10%" or "5k".
+	 * @return
+	 * @see #getNumber(Object)
+	 */
+	public static double toNum(Object object) {
+		if (object==null) return 0;
+		if (object instanceof Number) return ((Number) object).doubleValue();
+		return Double.valueOf((String)object);
+	}
+
+	/**
+	 * 
+	 * @param value
+	 * @return true if value is (not null) and a Number or a number or a String like "1"
+	 * Note: false for char/Character.
+	 * @see StrUtils#isNumber(String)
+	 */
+	public static boolean isNumber(Object value) {
+		if (value==null) return false;
+		Class<? extends Object> fClass = value.getClass();
+		if (ReflectionUtils.isa(fClass, Number.class)) return true;
+		if (value instanceof String) {
+			try {
+				// should we use a regex instead? \\d+(\\.\\d+)?
+				Double.valueOf((String)value);
+				return true;
+			} catch (Exception e) {
+				return false;
+			}
+		}
+		if ( ! fClass.isPrimitive()) return false;
+		return fClass==int.class || fClass==double.class || fClass==long.class
+				|| fClass==float.class || fClass==short.class;
+	}
+
+
+	/**
+	 * Lenient convertor -- accepts String or any Number subclass.
+	 * @param object Can be null (returns 0)
+	 */
+	public static long toLong(Object object) {
+		if (object==null) return 0;
+		if (object instanceof Number) return ((Number) object).longValue();
+		return Long.valueOf((String)object);
+	}
+
+	/**
+	 * Remove NaN and infinity from data
+	 * @param data
+	 * @return A fresh copy of data without any NaNs
+	 */
+	public static double[] filterFinite(double[] data) {
+		double[] ok = new double[data.length];
+		int oki =0;
+		for (int i = 0; i < data.length; i++) {
+			double v = data[i];
+			if (isFinite(v)) {
+				ok[oki] = v;
+				oki++;
+			}
+		}
+		if (oki==ok.length) {
+			return ok;
+		}
+		double[] ok2 = Arrays.copyOf(ok, oki);
+		return ok2;
+	}
+
+	public static int sum(int[] values) {
+		int total = 0;
+		for (int d : values) {
+			total += d;
+		}
+		return total;
+	}
+
+	public static double[] toDoubleArray(int[] vector) {
+		double[] ds = new double[vector.length];
+		for(int i=0; i<vector.length; i++) {
+			ds[i] = vector[i];
+		}
+		return ds;
+	}
+}
+
+
+final class NumberComparator implements Comparator<Number> {
+	@Override
+	public int compare(Number a, Number b) {
+		if (a==null) {
+			return b==null? 0 : -1;
+		}
+		if (b==null) {
+			return a==null? 0 : 1;
+		}
+		// unavoidably ugly
+		if (a instanceof BigInteger) {
+			BigInteger bigB = b instanceof BigInteger ? (BigInteger) b
+					: new BigInteger(b.toString());
+			int c = ((BigInteger) a).compareTo(bigB);
+			return c;
+		}
+		if (b instanceof BigInteger) {
+			BigInteger bigA = a instanceof BigInteger ? (BigInteger) a
+					: new BigInteger(a.toString());
+			int c = bigA.compareTo((BigInteger) b);
+			return c;
+		}
+		if (a instanceof Long || b instanceof Long) {
+			// Copied from the Java 7 Long.compare() method
+			long al = a.longValue(), bl = b.longValue();
+			return (al < bl) ? -1 : ((al == bl) ? 0 : 1);
+		}			
+		return Double.compare(a.doubleValue(), b.doubleValue());
+	}		
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/winterwell/utilslite/ReflectionUtils.java b/gson/src/main/java/com/winterwell/utilslite/ReflectionUtils.java
new file mode 100644
index 000000000..5509a41d8
--- /dev/null
+++ b/gson/src/main/java/com/winterwell/utilslite/ReflectionUtils.java
@@ -0,0 +1,380 @@
+package com.winterwell.utilslite;
+
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.jar.Attributes;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+/**
+ * Reflection-related utility functions
+ * 
+ * @testedby {@link ReflectionUtilsTest}
+ */
+public class ReflectionUtils {
+	
+
+	public static boolean isTransient(Field field) {
+		int mods = field.getModifiers();
+		return Modifier.isTransient(mods);
+	}
+
+	/**
+	 * Ugly hack to handle different primitives. TODO are there better ways? Use
+	 * v.getClass().getComponentType()? Array.newInstance()?
+	 * 
+	 * @param v
+	 * @return shallow copy
+	 */
+	static Object copyArray(Object v) {
+		int len = Array.getLength(v);
+		if (v instanceof boolean[]) {
+			return Arrays.copyOf((boolean[]) v, len);
+
+		} else if (v instanceof byte[]) {
+			return Arrays.copyOf((byte[]) v, len);
+
+		} else if (v instanceof char[]) {
+			return Arrays.copyOf((char[]) v, len);
+
+		}
+		if (v instanceof double[]) {
+			return Arrays.copyOf((double[]) v, len);
+
+		}
+		if (v instanceof float[]) {
+			return Arrays.copyOf((float[]) v, len);
+
+		}
+		if (v instanceof int[]) {
+			return Arrays.copyOf((int[]) v, len);
+
+		}
+		if (v instanceof long[]) {
+			return Arrays.copyOf((long[]) v, len);
+
+		}
+		if (v instanceof short[]) {
+			return Arrays.copyOf((short[]) v, len);
+
+		}
+		return copyArray2(v, len);
+	}
+
+	static <T> T[] copyArray2(Object v, int len) {
+		return Arrays.copyOf((T[]) v, len);
+	}
+
+	/**
+	 * @param clazz
+	 * @return Instance fields - public and private - which can be accessed from
+	 *         this class. Excludes: static fields and fields which cannot be
+	 *         accessed due to hardline JVM security.<br>
+	 *         Includes: non-static final fields<br>
+	 *         Field objects will have setAccessible(true) called on them as
+	 *         needed to try & make private fields accessible.
+	 */
+	public static List<Field> getAllFields(Class clazz) {
+		ArrayList<Field> list = new ArrayList<Field>();
+		getAllFields2(clazz, list);
+		return list;
+	}
+
+	private static void getAllFields2(Class clazz, ArrayList<Field> list) {
+		Field[] fields = clazz.getDeclaredFields();
+		for (Field field : fields) {
+			// exclude static
+			int m = field.getModifiers();
+			if (Modifier.isStatic(m)) {
+				continue;
+			}
+			if (!field.isAccessible()) {
+				try {
+					field.setAccessible(true);
+				} catch (SecurityException e) {
+					// skip over this field
+					continue;
+				}
+			}
+			list.add(field);
+		}
+		// recurse
+		Class superClass = clazz.getSuperclass();
+		if (superClass == null)
+			return;
+		getAllFields2(superClass, list);
+	}
+
+	/**
+	 * @param object
+	 * @param annotation
+	 * @param incPrivate
+	 *            If true, will return private and protected fields (provided
+	 *            they can be set accessible).
+	 * @return (All fields / accessible public fields) in object which are
+	 *         annotated with annotation
+	 */
+	public static List<Field> getAnnotatedFields(Object object,
+			Class<? extends Annotation> annotation, boolean incPrivate) {
+		List<Field> allFields = incPrivate ? getAllFields(object.getClass())
+				: Arrays.asList(object.getClass().getFields());
+		List<Field> fields = new ArrayList<Field>();
+		for (Field f : allFields) {
+			if (f.isAnnotationPresent(annotation)) {
+				fields.add(f);
+			}
+		}
+		return fields;
+	}
+
+	/**
+	 * Recurse to get a private field which may be declared in a super-class.
+	 * Note: {@link Class#getField(String)} will only retrieve public fields.
+	 * 
+	 * @param klass
+	 * @param fieldName
+	 * @return Field or null
+	 */
+	public static Field getField(Class klass, String fieldName) {
+//		Utils.check4null(klass, fieldName);
+		try {
+			Field f = klass.getDeclaredField(fieldName);
+			return f;
+		} catch (NoSuchFieldException e) {
+			klass = klass.getSuperclass();
+			if (klass == null)
+				return null;
+		}
+		return getField(klass, fieldName);
+	}
+
+
+	/**
+	 * 
+	 * @param clazz
+	 * @param methodName
+	 * @return The first method with matching name (ignores the parameters), or null if it isn't there. 
+	 */
+	static Method getMethod(Class<?> clazz, String methodName) {
+//		clazz.getMethod(name, parameterTypes)
+		// ignore the parameter types - but iterate over all methods :(
+		for (Method m : clazz.getMethods()) {
+			if (m.getName().equals(methodName))
+				return m;
+		}
+		return null;
+	}
+
+	public static <X> X getPrivateField(Object obj, String fieldName) {
+		Field f = getField(obj.getClass(), fieldName);
+		f.setAccessible(true);
+		try {
+			return (X) f.get(obj);
+		} catch (Exception e) {
+			throw Utils.runtime(e);
+		}
+	}
+
+
+	public static boolean hasField(Class klass, String field) {
+		return getField(klass, field) != null;
+	}
+
+	/**
+	 * @param klass
+	 * @param methodName
+	 * @return true if klass has a public method of that name
+	 */
+	public static boolean hasMethod(Class klass, String methodName) {
+		for (Method m : klass.getMethods()) {
+			if (m.getName().equals(methodName))
+				return true;
+		}
+		return false;
+	}
+
+	/**
+	 * The equivalent of instanceof, but for Class objects. 'cos I always forget
+	 * how to do this.
+	 * 
+	 * @param possSubType Can be null (returns false)
+	 * @param superType
+	 * @return true if possSubType <i>is</i> a subType of superType
+	 */
+	public static boolean isa(Class possSubType, Class superType) {
+		if (possSubType==null) return false;
+		return superType.isAssignableFrom(possSubType);
+	}
+
+
+	/**
+	 * TODO TEST!! This has changed
+	 * 
+	 * @return total available memory, in bytes. Does not run GC, so this is a fast
+	 *         call.
+	 * @see Runtime#freeMemory() -- which ignores the heap's capacity to grow, so is less
+	 * useful! Runtime#freeMemory() can be thought of as "fast memory".
+	 */
+	public static long getAvailableMemory() {
+		Runtime rt = Runtime.getRuntime();
+		long maxMem = rt.maxMemory();
+		long freeMem = rt.freeMemory();
+		long totalMem = rt.totalMemory();
+		long used = totalMem - freeMem;
+		long available = maxMem - used;
+		return available;
+	}
+
+	/**
+	 * @return a String showing the current stack
+	 */
+	public static String stacktrace() {
+		try {
+			throw new Exception();
+		} catch (Exception e) {
+			StackTraceElement[] trace = e.getStackTrace();
+			StringBuilder sb = new StringBuilder();
+			for (int i = 1; i < trace.length; i++) {
+				StackTraceElement stackTraceElement = trace[i];
+				sb.append(stackTraceElement.toString());
+				sb.append('\n');
+			}
+			return sb.toString();
+		}
+	}
+
+	/**
+	 * Who called this method?
+	 * 
+	 * NB: This always skips the actual calling method, stacktrace #-0
+	 * 
+	 * @param ignore
+	 *            list of fully-qualified-class or method names to ignore (will
+	 *            then search higher up the stack)
+	 * @return Can be a dummy entry if the filters exclude everything. Never
+	 *         null.
+	 * @see #getSomeStack(int, String...)
+	 */
+	public static StackTraceElement getCaller(String... ignore) {
+		return getCaller(1, ignore);
+	}
+
+
+	/**
+	 * Who called this method?
+	 * 
+	 * @param ignore
+	 *            list of fully-qualified-class or method names to ignore (will
+	 *            then search higher up the stack)
+	 * @param up 0 = get the method directly above the one calling this.           
+	 * @return Can be a dummy entry if the filters exclude everything. Never
+	 *         null.
+	 * @see #getSomeStack(int, String...)
+	 */
+	public static StackTraceElement getCaller(int up, String... ignore) {
+		List<String> ignoreNames = Arrays.asList(ignore);
+		try {
+			throw new Exception();
+		} catch (Exception e) {
+			StackTraceElement[] trace = e.getStackTrace();
+			for (int i = 2+up; i < trace.length; i++) {
+				String clazz = trace[i].getClassName();
+				String method = trace[i].getMethodName();
+				if (ignoreNames.contains(clazz) || ignoreNames.contains(method)) {
+					continue;
+				}
+				return trace[i]; // new Pair<String>(clazz, method);
+			}
+			return new StackTraceElement("filtered", "?", null, -1);
+		}
+	}
+
+	/**
+	 * Who called this method? Returns the lowest parts of the stack.
+	 * 
+	 * @param depth
+	 *            How many elements to aim for. Can be set very high for all-of-them.
+	 * @param ignore
+	 *            list of fully-qualified-class or method names to ignore (will
+	 *            then search higher up the stack)
+	 * @return Can be empty if the filters exclude everything. Never null.
+	 * @see #getCaller(String...)
+	 */
+	public static List<StackTraceElement> getSomeStack(int depth,
+			String... ignore) {
+		assert depth > 0 : depth;
+		List<String> ignoreNames = Arrays.asList(ignore);
+		try {
+			throw new Exception();
+		} catch (Exception e) {
+			StackTraceElement[] trace = e.getStackTrace();
+			List<StackTraceElement> stack = new ArrayList(depth);
+			for (int i = 2; i < trace.length; i++) {
+				String clazz = trace[i].getClassName();
+				String method = trace[i].getMethodName();
+				if (ignoreNames.contains(clazz) || ignoreNames.contains(method)) {
+					continue;
+				}
+				stack.add(trace[i]);
+				if (stack.size() == depth)
+					break;
+			}
+			return stack;
+		}
+	}
+
+	/**
+	 * Like class.getSimpleName() -- but if given an anonymous class, it will
+	 * return the super-classes' name (rather than null)
+	 * 
+	 * @param class1
+	 * @return name Never null or empty
+	 */
+	public static String getSimpleName(Class class1) {
+		String name = class1.getSimpleName();
+		if (!name.isEmpty()) {
+			return name;
+		}
+		return getSimpleName(class1.getSuperclass());
+	}
+
+	public static boolean isaNumber(Class<?> type) {
+		return isa(type, Number.class) || type == int.class
+				|| type == double.class || type == long.class
+				|| type == float.class;
+	}
+
+	/**
+	 * @return e.g. 1.6
+	 */
+	public static double getJavaVersion() {
+		String version = System.getProperty("java.version");
+		if (version == null) {
+			// WTF?!
+			return 1.5;
+		}
+		int pos = 0, count = 0;
+		for (; pos < version.length() && count < 2; pos++) {
+			if (version.charAt(pos) == '.')
+				count++;
+		}
+		pos--;
+		return Double.parseDouble(version.substring(0, pos));
+	}
+
+
+
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/winterwell/utilslite/Utils.java b/gson/src/main/java/com/winterwell/utilslite/Utils.java
new file mode 100644
index 000000000..6d6d3c0bc
--- /dev/null
+++ b/gson/src/main/java/com/winterwell/utilslite/Utils.java
@@ -0,0 +1,10 @@
+package com.winterwell.utilslite;
+
+public class Utils {
+
+	public static RuntimeException runtime(Exception e) {
+		if (e instanceof RuntimeException) return (RuntimeException) e;
+		return new RuntimeException(e);
+	}
+
+}
diff --git a/gson/src/test/java/com/google/gson/FlexiGsonListHandlingTest.java b/gson/src/test/java/com/google/gson/FlexiGsonListHandlingTest.java
new file mode 100644
index 000000000..6f19349ed
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/FlexiGsonListHandlingTest.java
@@ -0,0 +1,25 @@
+package com.google.gson;
+
+import java.util.List;
+import java.util.Map;
+
+import org.junit.Test;
+
+public class FlexiGsonListHandlingTest {
+
+	@Test
+	public void testToList() {
+		String json = "[1.0, 2.0, 3.0]";
+		List obj = new Gson().fromJson(json, List.class);
+		assert obj.get(0).equals(1.0) : obj;
+	}
+	
+	@Test
+	public void testListOrArray_IsList() {
+		String json = "{'list': [1.0, 2.0, 3.0]}";
+		Map obj = new Gson().fromJson(json, Map.class);
+		Object list = obj.get("list");
+		System.out.println(list.getClass());
+		assert list instanceof List;
+	}
+}
diff --git a/gson/src/test/java/com/google/gson/FlexiGsonTest.java b/gson/src/test/java/com/google/gson/FlexiGsonTest.java
new file mode 100644
index 000000000..d8c48f5d9
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/FlexiGsonTest.java
@@ -0,0 +1,96 @@
+package com.google.gson;
+
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.Test;
+
+
+public class FlexiGsonTest {
+	
+	@Test
+	public void testConvert() {
+		Gson gson = new GsonBuilder().create();
+		DummyObject dummy1 = new DummyObject();
+		dummy1.a = "Hello";
+		dummy1.b = 7;
+		dummy1.cs.add("C");
+		String json = gson.toJson(dummy1);
+		DummyObject dummy2 = gson.fromJson(json, DummyObject.class);
+		assert dummy2.equals(dummy1);
+		
+		Map map = new HashMap();
+		map.put("a", "Hello");
+		map.put("b", 7);
+		map.put("cs", new String[]{"C"});
+		
+		DummyObject dummy3 = gson.convert(map, DummyObject.class);
+		System.out.println(dummy3);
+		assert dummy1.equals(dummy3);		
+	}
+
+	@Test
+	public void testPreserveClass() {
+		Gson gson = new GsonBuilder()
+//						.setClassProperty("@class")
+						.create();
+		DummyObject dummy1 = new DummyObject();
+		dummy1.a = "Hello";
+		dummy1.b = 7;
+		dummy1.cs.add("C");
+		String json = gson.toJson(dummy1);
+		
+		assert json.contains("DummyObject") : json;
+		System.out.println(json);
+		
+		DummyObject dummy2 = gson.fromJson(json);
+		assert dummy2.equals(dummy1);		
+	}
+}
+
+
+class DummyObject {
+	@Override
+	public String toString() {
+		return "DummyObject [a=" + a + ", b=" + b + ", cs=" + cs + "]";
+	}
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((a == null) ? 0 : a.hashCode());
+		result = prime * result + b;
+		result = prime * result + ((cs == null) ? 0 : cs.hashCode());
+		return result;
+	}
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		DummyObject other = (DummyObject) obj;
+		if (a == null) {
+			if (other.a != null)
+				return false;
+		} else if (!a.equals(other.a))
+			return false;
+		if (b != other.b)
+			return false;
+		if (cs == null) {
+			if (other.cs != null)
+				return false;
+		} else if (!cs.equals(other.cs))
+			return false;
+		return true;
+	}
+	String a;
+	int b;
+	List<String> cs = new ArrayList();
+}
\ No newline at end of file
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index fb0c00321..128ec4d1d 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -44,7 +44,7 @@ public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT,
-        new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), GsonBuilder.DEFAULT_CLASS_PROPERTY);
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
