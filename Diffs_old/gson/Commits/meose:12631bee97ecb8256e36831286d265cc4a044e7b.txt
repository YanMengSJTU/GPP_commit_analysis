diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 27f3ee924..8b1ae122c 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -110,6 +110,7 @@
   static final boolean DEFAULT_SERIALIZE_NULLS = false;
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
   static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
+  static final boolean DEFAULT_USE_GETTER_SETTER = false;
 
   private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
@@ -128,6 +129,7 @@
 
   private final ConstructorConstructor constructorConstructor;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final boolean useGetterSetter;
 
   final List<TypeAdapterFactory> factories;
 
@@ -189,7 +191,7 @@ public Gson() {
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
         LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
         Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
-        Collections.<TypeAdapterFactory>emptyList());
+        Collections.<TypeAdapterFactory>emptyList(), DEFAULT_USE_GETTER_SETTER);
   }
 
   Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
@@ -199,7 +201,7 @@ public Gson() {
       LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
       int timeStyle, List<TypeAdapterFactory> builderFactories,
       List<TypeAdapterFactory> builderHierarchyFactories,
-      List<TypeAdapterFactory> factoriesToBeAdded) {
+      List<TypeAdapterFactory> factoriesToBeAdded, boolean useGetterSetter) {
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
     this.instanceCreators = instanceCreators;
@@ -210,6 +212,7 @@ public Gson() {
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.useGetterSetter = useGetterSetter;
     this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
     this.longSerializationPolicy = longSerializationPolicy;
     this.datePattern = datePattern;
@@ -306,6 +309,10 @@ public boolean htmlSafe() {
     return htmlSafe;
   }
 
+  public boolean useGetterSetter() {
+    return useGetterSetter;
+  }
+
   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
     if (serializeSpecialFloatingPointValues) {
       return TypeAdapters.DOUBLE;
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index b97be452b..343d900f3 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -40,6 +40,7 @@
 import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
 import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
 import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+import static com.google.gson.Gson.DEFAULT_USE_GETTER_SETTER;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -94,6 +95,7 @@
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
   private boolean lenient = DEFAULT_LENIENT;
+  private boolean useGetterSetter = DEFAULT_USE_GETTER_SETTER;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -577,6 +579,19 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
     return this;
   }
 
+  /**
+   * By default, Gson uses reflection to get/set values of the fields. Use this option to configure
+   * Gson to use getter/setter methods whenever possible. If no method is found,
+   * it will fallback to using reflection.
+   *
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   * @since 1.8
+   */
+  public GsonBuilder useGetterSetter() {
+    this.useGetterSetter = true;
+    return this;
+  }
+
   /**
    * Creates a {@link Gson} instance based on the current configuration. This method is free of
    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
@@ -599,7 +614,7 @@ public Gson create() {
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
         serializeSpecialFloatingPointValues, longSerializationPolicy,
         datePattern, dateStyle, timeStyle,
-        this.factories, this.hierarchyFactories, factories);
+        this.factories, this.hierarchyFactories, factories, useGetterSetter);
   }
 
   @SuppressWarnings("unchecked")
diff --git a/gson/src/main/java/com/google/gson/internal/GsonBuildConfig.java b/gson/src/main/java/com/google/gson/internal/GsonBuildConfig.java
new file mode 100644
index 000000000..b3dc3db39
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/GsonBuildConfig.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal;
+
+/**
+ * Build configuration for Gson. This file is automatically populated by
+ * templating-maven-plugin and .java/.class files are generated for use in Gson.
+ *
+ * @author Inderjeet Singh
+ */
+public final class GsonBuildConfig {
+    // Based on https://stackoverflow.com/questions/2469922/generate-a-version-java-file-in-maven
+
+    /** This field is automatically populated by Maven when a build is triggered */
+    public static final String VERSION = "${project.version}";
+
+    private GsonBuildConfig() { }
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 777e7dee3..9d1418032 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -35,6 +35,8 @@
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -121,7 +123,42 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
-        Object fieldValue = field.get(value);
+        Object fieldValue;
+
+        if(context.useGetterSetter()) {
+          String fieldName = field.getName();
+          String getterPrefix = field.getType() == boolean.class || field.getType() == Boolean.class ? "is" : "get";
+          String getterName = getterPrefix + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
+
+          try {
+            Method method = value.getClass().getMethod(getterName);
+            fieldValue = method.invoke(value);
+
+          } catch (NoSuchMethodException ignored) {
+              /*
+                Getting field via reflection if no setter method is found in the class for that field
+              */
+            fieldValue = field.get(value);
+
+          } catch (InvocationTargetException ignored) {
+              /*
+                TODO : Needs to be revisited
+                If use of getter is enabled & Gson is unable to call getter, then throw error or just use reflection?
+                Since earlier Gson version worked in all cases, using reflection to get field value for now.
+              */
+            fieldValue = field.get(value);
+          } catch (IllegalAccessException ignored) {
+              /*
+                TODO : Needs to be revisited
+                If use of getter is enabled & Gson is unable to call getter, then throw error or just use reflection?
+                Since earlier Gson version worked in all cases, using reflection to get field value for now.
+              */
+            fieldValue = field.get(value);
+          }
+        } else {
+          fieldValue = field.get(value);
+        }
+
         TypeAdapter t = jsonAdapterPresent ? typeAdapter
             : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
@@ -130,6 +167,38 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
         if (fieldValue != null || !isPrimitive) {
+          if (context.useGetterSetter()) {
+            String fieldName = field.getName();
+            String setterName = "set" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
+
+            try {
+              Method method = value.getClass().getMethod(setterName, field.getType());
+              method.invoke(value, fieldValue);
+
+            } catch (NoSuchMethodException ignored) {
+              /*
+                Setting field via reflection if no setter method is found in the class for that field
+              */
+              field.set(value, fieldValue);
+
+            } catch (InvocationTargetException ignored) {
+              /*
+                TODO : Needs to be revisited
+                If use of setter is enabled & Gson is unable to call setter, then throw error or just use reflection?
+                Since earlier Gson version worked in all cases, using reflection to set field value for now.
+              */
+              field.set(value, fieldValue);
+            } catch (IllegalAccessException ignored) {
+              /*
+                TODO : Needs to be revisited
+                If use of setter is enabled & Gson is unable to call setter, then throw error or just use reflection?
+                Since earlier Gson version worked in all cases, using reflection to set field value for now.
+              */
+              field.set(value, fieldValue);
+            }
+          } else {
+            field.set(value, fieldValue);
+          }
           field.set(value, fieldValue);
         }
       }
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index eec2ec91c..e851d0a13 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -49,12 +49,13 @@ public void testOverridesDefaultExcluder() {
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
-        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(), true);
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
     assertEquals(true, gson.serializeNulls());
     assertEquals(false, gson.htmlSafe());
+    assertEquals(true, gson.useGetterSetter());
   }
 
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
@@ -62,7 +63,7 @@ public void testClonedTypeAdapterFactoryListsAreIndependent() {
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
-        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(), true);
 
     Gson clone = original.newBuilder()
         .registerTypeAdapter(Object.class, new TestTypeAdapter())
diff --git a/gson/src/test/java/com/google/gson/functional/UseGetterSetterTest.java b/gson/src/test/java/com/google/gson/functional/UseGetterSetterTest.java
new file mode 100644
index 000000000..fc0a6099a
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/UseGetterSetterTest.java
@@ -0,0 +1,63 @@
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import junit.framework.TestCase;
+
+/**
+ * Functional Test exercising serialization/deserialization using getter/setter methods.
+ *
+ * @author Raj Srivastava
+ */
+public class UseGetterSetterTest extends TestCase {
+
+    private static final int    INITIAL_INT    = 100;
+    private static final int    GETTER_OFFSET  = 20;
+    private static final int    SETTER_OFFSET  = 40;
+    private static final String INITIAL_STRING = "initial";
+    private static final String GETTER_SUFFIX  = "-g";
+    private static final String SETTER_SUFFIX  = "-s";
+
+    private Gson gson;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        gson = new GsonBuilder().useGetterSetter().create();
+    }
+
+    public void testGetterSetterUse() throws Exception {
+        ClassWithGetterSetter request = new ClassWithGetterSetter(INITIAL_INT, INITIAL_STRING);
+        String json = gson.toJson(request);
+
+        ClassWithGetterSetter response = gson.fromJson(json, ClassWithGetterSetter.class);
+        assertEquals(response.primitiveField, INITIAL_INT + GETTER_OFFSET + SETTER_OFFSET);
+        assertEquals(response.nonPrimitiveField, INITIAL_STRING + GETTER_SUFFIX + SETTER_SUFFIX);
+    }
+
+    public static class ClassWithGetterSetter {
+        int     primitiveField;
+        String  nonPrimitiveField;
+
+        public ClassWithGetterSetter(int primitiveField, String nonPrimitiveField) {
+            this.primitiveField = primitiveField;
+            this.nonPrimitiveField = nonPrimitiveField;
+        }
+
+        public int getPrimitiveField() {
+            return primitiveField + GETTER_OFFSET;
+        }
+
+        public void setPrimitiveField(int primitiveField) {
+            this.primitiveField = primitiveField + SETTER_OFFSET;
+        }
+
+        public String getNonPrimitiveField() {
+            return nonPrimitiveField + GETTER_SUFFIX;
+        }
+
+        public void setNonPrimitiveField(String nonPrimitiveField) {
+            this.nonPrimitiveField = nonPrimitiveField + SETTER_SUFFIX;
+        }
+    }
+}
\ No newline at end of file
