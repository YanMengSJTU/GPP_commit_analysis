diff --git a/src/main/java/com/github/gv2011/gson/JsonNull.java b/src/main/java/com/github/gv2011/gson/JsonNull.java
index fadd105d3..8348d14b9 100644
--- a/src/main/java/com/github/gv2011/gson/JsonNull.java
+++ b/src/main/java/com/github/gv2011/gson/JsonNull.java
@@ -1,63 +1,63 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.gson;
-
-/**
- * A class representing a Json {@code null} value.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.2
- */
-public final class JsonNull extends JsonElement {
-  /**
-   * singleton for JsonNull
-   *
-   * @since 1.8
-   */
-  public static final JsonNull INSTANCE = new JsonNull();
-
-  /**
-   * Creates a new JsonNull object.
-   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
-   */
-  @Deprecated
-  public JsonNull() {
-    // Do nothing
-  }
-
-  @Override
-  JsonNull deepCopy() {
-    return INSTANCE;
-  }
-
-  /**
-   * All instances of JsonNull have the same hash code since they are indistinguishable
-   */
-  @Override
-  public int hashCode() {
-    return JsonNull.class.hashCode();
-  }
-
-  /**
-   * All instances of JsonNull are the same
-   */
-  @Override
-  public boolean equals(Object other) {
-    return this == other || other instanceof JsonNull;
-  }
-}
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gson;
+
+/**
+ * A class representing a Json {@code null} value.
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ * @since 1.2
+ */
+public final class JsonNull extends JsonElement {
+  /**
+   * singleton for JsonNull
+   *
+   * @since 1.8
+   */
+  public static final JsonNull INSTANCE = new JsonNull();
+
+  /**
+   * Creates a new JsonNull object.
+   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
+   */
+  @Deprecated
+  public JsonNull() {
+    // Do nothing
+  }
+
+  @Override
+  JsonNull deepCopy() {
+    return INSTANCE;
+  }
+
+  /**
+   * All instances of JsonNull have the same hash code since they are indistinguishable
+   */
+  @Override
+  public int hashCode() {
+    return JsonNull.class.hashCode();
+  }
+
+  /**
+   * All instances of JsonNull are the same
+   */
+  @Override
+  public boolean equals(Object other) {
+    return this == other || other instanceof JsonNull;
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gson/JsonParser.java b/src/main/java/com/github/gv2011/gson/JsonParser.java
index d5427d256..84cce17fe 100644
--- a/src/main/java/com/github/gv2011/gson/JsonParser.java
+++ b/src/main/java/com/github/gv2011/gson/JsonParser.java
@@ -1,93 +1,93 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.gson;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-
-import com.github.gv2011.gson.internal.Streams;
-import com.github.gv2011.gson.stream.JsonReader;
-import com.github.gv2011.gson.stream.JsonToken;
-import com.github.gv2011.gson.stream.MalformedJsonException;
-
-/**
- * A parser to parse Json into a parse tree of {@link JsonElement}s
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.3
- */
-public final class JsonParser {
-
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param json JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
-   */
-  public JsonElement parse(String json) throws JsonSyntaxException {
-    return parse(new StringReader(json));
-  }
-
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param json JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
-   */
-  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
-    try {
-      JsonReader jsonReader = new JsonReader(json);
-      JsonElement element = parse(jsonReader);
-      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
-        throw new JsonSyntaxException("Did not consume the entire document.");
-      }
-      return element;
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (NumberFormatException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-
-  /**
-   * Returns the next value from the JSON stream as a parse tree.
-   *
-   * @throws JsonParseException if there is an IOException or if the specified
-   *     text is not valid JSON
-   * @since 1.6
-   */
-  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
-    boolean lenient = json.isLenient();
-    json.setLenient(true);
-    try {
-      return Streams.parse(json);
-    } catch (StackOverflowError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
-    } catch (OutOfMemoryError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
-    } finally {
-      json.setLenient(lenient);
-    }
-  }
-}
+/*
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.gv2011.gson;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+
+import com.github.gv2011.gson.internal.Streams;
+import com.github.gv2011.gson.stream.JsonReader;
+import com.github.gv2011.gson.stream.JsonToken;
+import com.github.gv2011.gson.stream.MalformedJsonException;
+
+/**
+ * A parser to parse Json into a parse tree of {@link JsonElement}s
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ * @since 1.3
+ */
+public final class JsonParser {
+
+  /**
+   * Parses the specified JSON string into a parse tree
+   *
+   * @param json JSON text
+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+   * @throws JsonParseException if the specified text is not valid JSON
+   * @since 1.3
+   */
+  public JsonElement parse(String json) throws JsonSyntaxException {
+    return parse(new StringReader(json));
+  }
+
+  /**
+   * Parses the specified JSON string into a parse tree
+   *
+   * @param json JSON text
+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+   * @throws JsonParseException if the specified text is not valid JSON
+   * @since 1.3
+   */
+  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
+    try {
+      JsonReader jsonReader = new JsonReader(json);
+      JsonElement element = parse(jsonReader);
+      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
+        throw new JsonSyntaxException("Did not consume the entire document.");
+      }
+      return element;
+    } catch (MalformedJsonException e) {
+      throw new JsonSyntaxException(e);
+    } catch (IOException e) {
+      throw new JsonIOException(e);
+    } catch (NumberFormatException e) {
+      throw new JsonSyntaxException(e);
+    }
+  }
+
+  /**
+   * Returns the next value from the JSON stream as a parse tree.
+   *
+   * @throws JsonParseException if there is an IOException or if the specified
+   *     text is not valid JSON
+   * @since 1.6
+   */
+  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
+    boolean lenient = json.isLenient();
+    json.setLenient(true);
+    try {
+      return Streams.parse(json);
+    } catch (StackOverflowError e) {
+      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+    } catch (OutOfMemoryError e) {
+      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+    } finally {
+      json.setLenient(lenient);
+    }
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gson/internal/$Gson$Preconditions.java b/src/main/java/com/github/gv2011/gson/internal/$Gson$Preconditions.java
index 1db8cda31..23ab3f301 100644
--- a/src/main/java/com/github/gv2011/gson/internal/$Gson$Preconditions.java
+++ b/src/main/java/com/github/gv2011/gson/internal/$Gson$Preconditions.java
@@ -1,49 +1,49 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.gson.internal;
-
-/**
- * A simple utility class used to check method Preconditions.
- *
- * <pre>
- * public long divideBy(long value) {
- *   Preconditions.checkArgument(value != 0);
- *   return this.value / value;
- * }
- * </pre>
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class $Gson$Preconditions {
-  private $Gson$Preconditions() {
-    throw new UnsupportedOperationException();
-  }
-
-  public static <T> T checkNotNull(T obj) {
-    if (obj == null) {
-      throw new NullPointerException();
-    }
-    return obj;
-  }
-
-  public static void checkArgument(boolean condition) {
-    if (!condition) {
-      throw new IllegalArgumentException();
-    }
-  }
-}
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gson.internal;
+
+/**
+ * A simple utility class used to check method Preconditions.
+ *
+ * <pre>
+ * public long divideBy(long value) {
+ *   Preconditions.checkArgument(value != 0);
+ *   return this.value / value;
+ * }
+ * </pre>
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+public final class $Gson$Preconditions {
+  private $Gson$Preconditions() {
+    throw new UnsupportedOperationException();
+  }
+
+  public static <T> T checkNotNull(T obj) {
+    if (obj == null) {
+      throw new NullPointerException();
+    }
+    return obj;
+  }
+
+  public static void checkArgument(boolean condition) {
+    if (!condition) {
+      throw new IllegalArgumentException();
+    }
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/src/main/java/com/github/gv2011/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index d51433680..df11b12ff 100644
--- a/src/main/java/com/github/gv2011/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/src/main/java/com/github/gv2011/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -1,82 +1,82 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.gson.internal.bind;
-
-import com.github.gv2011.gson.Gson;
-import com.github.gv2011.gson.TypeAdapter;
-import com.github.gv2011.gson.reflect.TypeToken;
-import com.github.gv2011.gson.stream.JsonReader;
-import com.github.gv2011.gson.stream.JsonWriter;
-
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-
-final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
-  private final Gson context;
-  private final TypeAdapter<T> delegate;
-  private final Type type;
-
-  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
-    this.context = context;
-    this.delegate = delegate;
-    this.type = type;
-  }
-
-  @Override
-  public T read(JsonReader in) throws IOException {
-    return delegate.read(in);
-  }
-
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  @Override
-  public void write(JsonWriter out, T value) throws IOException {
-    // Order of preference for choosing type adapters
-    // First preference: a type adapter registered for the runtime type
-    // Second preference: a type adapter registered for the declared type
-    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
-    // Fourth preference: reflective type adapter for the declared type
-
-    TypeAdapter chosen = delegate;
-    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
-    if (runtimeType != type) {
-      TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
-      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for the runtime type, so we will use that
-        chosen = runtimeTypeAdapter;
-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for Base class, so we prefer it over the
-        // reflective type adapter for the runtime type
-        chosen = delegate;
-      } else {
-        // Use the type adapter for runtime type
-        chosen = runtimeTypeAdapter;
-      }
-    }
-    chosen.write(out, value);
-  }
-
-  /**
-   * Finds a compatible runtime type if it is more specific
-   */
-  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
-    if (value != null
-        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
-      type = value.getClass();
-    }
-    return type;
-  }
-}
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.gv2011.gson.internal.bind;
+
+import com.github.gv2011.gson.Gson;
+import com.github.gv2011.gson.TypeAdapter;
+import com.github.gv2011.gson.reflect.TypeToken;
+import com.github.gv2011.gson.stream.JsonReader;
+import com.github.gv2011.gson.stream.JsonWriter;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
+final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
+  private final Gson context;
+  private final TypeAdapter<T> delegate;
+  private final Type type;
+
+  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
+    this.context = context;
+    this.delegate = delegate;
+    this.type = type;
+  }
+
+  @Override
+  public T read(JsonReader in) throws IOException {
+    return delegate.read(in);
+  }
+
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  @Override
+  public void write(JsonWriter out, T value) throws IOException {
+    // Order of preference for choosing type adapters
+    // First preference: a type adapter registered for the runtime type
+    // Second preference: a type adapter registered for the declared type
+    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
+    // Fourth preference: reflective type adapter for the declared type
+
+    TypeAdapter chosen = delegate;
+    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
+    if (runtimeType != type) {
+      TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
+      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+        // The user registered a type adapter for the runtime type, so we will use that
+        chosen = runtimeTypeAdapter;
+      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+        // The user registered a type adapter for Base class, so we prefer it over the
+        // reflective type adapter for the runtime type
+        chosen = delegate;
+      } else {
+        // Use the type adapter for runtime type
+        chosen = runtimeTypeAdapter;
+      }
+    }
+    chosen.write(out, value);
+  }
+
+  /**
+   * Finds a compatible runtime type if it is more specific
+   */
+  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
+    if (value != null
+        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
+      type = value.getClass();
+    }
+    return type;
+  }
+}
