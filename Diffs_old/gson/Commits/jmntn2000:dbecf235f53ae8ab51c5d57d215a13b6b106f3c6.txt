diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 9d5d6ffd8..639dd31c3 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -124,6 +124,8 @@
   private final boolean htmlSafe;
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
+  private final boolean upperCaseStrings;
+  private final boolean excludeDuplicateObjects;
 
   final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {
     @SuppressWarnings("unchecked")
@@ -181,18 +183,40 @@ public Gson() {
         true, false, false, LongSerializationPolicy.DEFAULT,
         Collections.<TypeAdapterFactory>emptyList());
   }
+  
+  public Gson(boolean serializeNulls, boolean htmlsafe,boolean prettyPrinting,
+          boolean upperCaseStrings, boolean excludeDuplicateObjects) {
+    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,
+        Collections.<Type, InstanceCreator<?>>emptyMap(), serializeNulls, false, DEFAULT_JSON_NON_EXECUTABLE,
+        htmlsafe, prettyPrinting, false, LongSerializationPolicy.DEFAULT,
+        Collections.<TypeAdapterFactory>emptyList(),upperCaseStrings, excludeDuplicateObjects);
+  }
+  
+  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,
+      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
+      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
+      LongSerializationPolicy longSerializationPolicy,
+      List<TypeAdapterFactory> typeAdapterFactories){
+      this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,
+        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,
+        true, false, false, LongSerializationPolicy.DEFAULT,
+        Collections.<TypeAdapterFactory>emptyList(),false,false);
+  }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,
       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
+      List<TypeAdapterFactory> typeAdapterFactories, boolean upperCaseStings, boolean excludeDuplicateObjects) {
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.serializeNulls = serializeNulls;
     this.generateNonExecutableJson = generateNonExecutableGson;
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
+    this.upperCaseStrings = upperCaseStings;
+    this.excludeDuplicateObjects = excludeDuplicateObjects;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -599,6 +623,10 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
     writer.setHtmlSafe(htmlSafe);
     boolean oldSerializeNulls = writer.getSerializeNulls();
     writer.setSerializeNulls(serializeNulls);
+    boolean oldUppercase = writer.isUpperCaseStrings();
+    writer.setUpperCaseStrings(upperCaseStrings);
+    boolean oldExcludeDup = writer.isExcludeDuplicateObjects();
+    writer.setExcludeDuplicateObjects(excludeDuplicateObjects);
     try {
       ((TypeAdapter<Object>) adapter).write(writer, src);
     } catch (IOException e) {
@@ -607,6 +635,8 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
       writer.setSerializeNulls(oldSerializeNulls);
+      writer.setUpperCaseStrings(oldUppercase);
+      writer.setExcludeDuplicateObjects(oldExcludeDup);
     }
   }
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index feda3b87b..2dc1ad868 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -39,6 +39,10 @@
 import java.util.Map;
 
 import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -88,7 +92,7 @@ static String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {
       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize,field) {
       final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
@@ -157,11 +161,13 @@ public boolean writeField(Object value) throws IOException, IllegalAccessExcepti
     final String name;
     final boolean serialized;
     final boolean deserialized;
+    final Field field;
 
-    protected BoundField(String name, boolean serialized, boolean deserialized) {
+    protected BoundField(String name, boolean serialized, boolean deserialized,Field field) {
       this.name = name;
       this.serialized = serialized;
       this.deserialized = deserialized;
+      this.field = field;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
@@ -210,15 +216,40 @@ private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundF
         out.nullValue();
         return;
       }
-
+      Map<String,List<String>> seenIds = out.getSeenIds();
       out.beginObject();
       try {
-        for (BoundField boundField : boundFields.values()) {
-          if (boundField.writeField(value)) {
-            out.name(boundField.name);
-            boundField.write(out, value);
+          boolean idOnly = false;
+          BoundField id = null;
+          if(out.isExcludeDuplicateObjects() && !Primitives.isPrimitive(TypeToken.get(value.getClass()).getType())){
+              id = boundFields.get("id");
+              if(id!=null){
+                  Object v = id.field.get(value);
+                  String k = value.getClass().getName();
+                  if(v!=null){
+                      String sVal = v.toString();
+                    if(!seenIds.containsKey(k)){
+                        seenIds.put(k,new ArrayList<String>());
+                    }
+                    if(seenIds.get(k).contains(sVal)){
+                        idOnly = true;
+                    }else{
+                        seenIds.get(k).add(sVal);
+                    }
+                  }
+              }
           }
-        }
+          if(!idOnly){
+            for (BoundField boundField : boundFields.values()) {
+              if (boundField.writeField(value)) {
+                out.name(boundField.name);
+                boundField.write(out, value);
+              }
+            }
+          }else{
+           out.name(id.name);
+           id.write(out, value);
+                    }
       } catch (IllegalAccessException e) {
         throw new AssertionError();
       }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index 6a935ddbb..74d8f8524 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -28,6 +28,8 @@
 import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;
 import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;
 import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;
+import java.util.HashMap;
+import java.util.List;
 
 /**
  * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
@@ -184,10 +186,16 @@
   private boolean lenient;
 
   private boolean htmlSafe;
+  
+  private boolean upperCaseStrings = false;
+  
+  private boolean excludeDuplicateObjects = false;
 
   private String deferredName;
 
   private boolean serializeNulls = true;
+  
+  private HashMap<String,List<String>> seenIds = new HashMap<String, List<String>>();
 
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code out}.
@@ -201,6 +209,12 @@ public JsonWriter(Writer out) {
     this.out = out;
   }
 
+    public HashMap<String, List<String>> getSeenIds() {
+        return seenIds;
+    }
+  
+  
+
   /**
    * Sets the indentation string to be repeated for each level of indentation
    * in the encoded document. If {@code indent.isEmpty()} the encoded document
@@ -261,6 +275,24 @@ public final boolean isHtmlSafe() {
     return htmlSafe;
   }
 
+  public final void setUpperCaseStrings(boolean upperCaseStrings) {
+    this.upperCaseStrings = upperCaseStrings;
+  }
+
+  public final boolean isUpperCaseStrings() {
+    return upperCaseStrings;
+  }
+
+    public boolean isExcludeDuplicateObjects() {
+        return excludeDuplicateObjects;
+    }
+
+    public void setExcludeDuplicateObjects(boolean excludeDuplicateObjects) {
+        this.excludeDuplicateObjects = excludeDuplicateObjects;
+    }
+  
+  
+
   /**
    * Sets whether object members are serialized when their value is null.
    * This has no impact on array elements. The default is true.
@@ -416,7 +448,7 @@ public JsonWriter value(String value) throws IOException {
     }
     writeDeferredName();
     beforeValue(false);
-    string(value);
+    string(upperCaseStrings?value.toUpperCase():value);
     return this;
   }
 
diff --git a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
index d352e2418..c5afee4a3 100644
--- a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
@@ -28,6 +28,8 @@
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.common.TestTypes.ClassOverridingEquals;
+import java.math.BigInteger;
+import java.util.List;
 
 /**
  * Functional tests related to circular reference detection and error reporting.
@@ -41,18 +43,41 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new Gson();
+    gson = new Gson(false, true, true, true, true);
   }
 
   public void testCircularSerialization() throws Exception {
-    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();
-    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();
-    a.children.add(b);
-    b.children.add(a);
+//    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();
+//    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();
+//    a.children.add(b);
+//    b.children.add(a);
+      Order a = new Order();
+      a.id=new BigInteger("1");
+      a.orderName="Order A";
+      a.parts = new ArrayList<Parts>();
+      Parts l1 = new Parts();
+      Parts l2 = new Parts();
+      Parts l3 = new Parts();
+      l1.id = new BigInteger("1");
+      l1.order = a;
+      l1.part="Part 1";
+      l2.id = new BigInteger("2");
+      l2.order = a;
+      l2.part="Part 2";
+      l3.order = a;
+      l3.id = new BigInteger("3");
+      l3.part="Part 3";
+      a.parts.add(l1);
+      a.parts.add(l2);
+      a.parts.add(l3);
+      a.parts.add(l3);
     try {
-      gson.toJson(a);
+      String res = gson.toJson(a);
+        System.out.println(res);
+        System.out.println();
       fail("Circular types should not get printed!");
-    } catch (StackOverflowError expected) {
+    } catch (Exception expected) {
+        System.out.println("j");
     }
   }
 
@@ -123,4 +148,16 @@ public void testDirectedAcyclicGraphDeserialization() throws Exception {
     @SuppressWarnings("unused")
     ClassWithSelfReferenceArray[] children;
   }
+  
+  private static class Parts {
+      BigInteger id;
+      Order order;
+      String part;
+  }
+  
+  private static class Order {
+      BigInteger id;
+      List<Parts> parts;
+      String orderName;
+  }
 }
