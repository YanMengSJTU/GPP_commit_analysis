diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 000000000..b8a47ca22
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1 @@
+gson/docs/javadocs/* linguist-documentation
diff --git a/.gitignore b/.gitignore
index b1bdb7f26..5bda0b93e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,4 +13,8 @@ release.properties
 *.iws
 classes
 
+.gradle
+local.properties
+build
+
 .DS_Store
diff --git a/.travis.yml b/.travis.yml
index ee50d51cb..a9cc60645 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,8 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk7
-  - oraclejdk8
+  - oraclejdk9
 
 install: mvn -f gson install -DskipTests=true
 script: mvn -f gson test
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 45a03ceed..33f1f8119 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,28 @@
 Change Log
 ==========
 
+## Version 2.8.5
+_2018-05-21_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.4...gson-parent-2.8.5)
+ * Print Gson version while throwing AssertionError and IllegalArgumentException
+ * Moved `utils.VersionUtils` class to `internal.JavaVersion`. This is a potential backward incompatible change from 2.8.4
+ * Fixed issue https://github.com/google/gson/issues/1310 by supporting Debian Java 9
+
+## Version 2.8.4
+_2018-05-01_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.3...gson-parent-2.8.4)
+ * Added a new FieldNamingPolicy, `LOWER_CASE_WITH_DOTS` that mapps JSON name `someFieldName` to `some.field.name`
+ * Fixed issue https://github.com/google/gson/issues/1305 by removing compile/runtime dependency on `sun.misc.Unsafe`
+
+## Version 2.8.3
+_2018-04-27_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.2...gson-parent-2.8.3)
+ * Added a new API, `GsonBuilder.newBuilder()` that clones the current builder
+ * Preserving DateFormatter behavior on JDK 9
+ * Numerous other bugfixes
+
+## Version 2.8.2
+_2017-09-19_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.1...gson-parent-2.8.2)
+ * Introduced a new API, `JsonElement.deepCopy()`
+ * Numerous other bugfixes
+
 ## Version 2.8.1
 _2017-05-30_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.0...gson-parent-2.8.1)
  * New: `JsonObject.keySet()`
diff --git a/README.md b/README.md
index 2648a7ea5..a67bdb458 100644
--- a/README.md
+++ b/README.md
@@ -1,36 +1,51 @@
-# google-gson
-
-[![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson)
-[![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
+# Gson
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
-Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. 
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
 
-There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
+There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.
 
-### Gson Goals
+### Goals
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-### Gson Download and Maven
-  * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
-  * For Maven check "Dependency Information" tab, on the left side.
+### Download
+
+Gradle:
+```gradle
+dependencies {
+  implementation 'com.google.code.gson:gson:2.8.5'
+}
+```
 
-### Gson Documentation
-  * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
-  * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
-  * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
-  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+Maven:
+```xml
+<dependency>
+  <groupId>com.google.code.gson</groupId>
+  <artifactId>gson</artifactId>
+  <version>2.8.5</version>
+</dependency>
+```
 
-Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
+[Gson jar downloads](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) are available from Maven Central.
 
-### Gson-related Content Created by Third Parties
+[![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
+
+### Documentation
+  * [API Javadoc](http://www.javadoc.io/doc/com.google.code.gson/gson): Documentation for the current release
+  * [User guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
+  * [Change log](https://github.com/google/gson/blob/master/CHANGELOG.md): Changes in the recent versions
+  * [Design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
+
+Please use the 'gson' tag on StackOverflow or the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson or to post questions.
+
+### Related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
   * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
+  * [Gson API Report](https://abi-laboratory.pro/java/tracker/timeline/gson/)
 
 ### License
 
@@ -51,3 +66,7 @@ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 ```
+
+### Disclaimer
+
+This is not an officially supported Google product.
diff --git a/ReleaseProcess.md b/ReleaseProcess.md
index f75ce398e..bb2719cd4 100644
--- a/ReleaseProcess.md
+++ b/ReleaseProcess.md
@@ -1,51 +1,18 @@
-#Gson Release Process
+# Gson Release Process
 
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
-1. Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
 1. Ensure all changelists are code-reviewed and have +1
-1. Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
-1. `cd gson`; ensure there are no open files and all changes are committed.
+1. `cd gson` to the parent directory; ensure there are no open files and all changes are committed.
 1. Run `mvn release:clean`
 1. Do a dry run: `mvn release:prepare -DdryRun=true`
 1. Start the release: `mvn release:prepare`
-  * Answer questions: usually the defaults are fine.
-  * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
-1. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
-
-   ```bash
-   mvn -s /home/<username>/.m2/settings.xml release:perform
-   ```
-
-1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
-
-  ```bash
-  cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
-  cd /tmp/1.7.2
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2-javadoc.jar \
-      -Dclassifier=javadoc
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2-sources.jar \
-      -Dclassifier=sources
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2.jar
-  ```
-
-1. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+   * Answer questions: usually the defaults are fine.
+   * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
+1. Complete the release: `mvn release:perform`
+1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson.
+1. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
 1. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
 
 1. Update the version in the [Using Gson with Maven2 page](https://github.com/google/gson/blob/master/UserGuide.md#TOC-Gson-With-Maven)
@@ -58,16 +25,16 @@ The following is a step-by-step procedure for releasing a new version of Google-
 This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
 
 1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
-2. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
-3. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
-4. Now for deploying a snapshot repository, use `mvn deploy`.
+1. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+1. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
+1. Now for deploying a snapshot repository, use `mvn deploy`.
 
 ## Getting Maven Publishing Privileges
 
 Based on [Gson group thread](https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion):
 
 1. [Sign up for a Sonatype account](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide) following instructions under (2) on that page
-2. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
+1. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
 
 ## Running Benchmarks or Tests on Android
 
diff --git a/UserGuide.md b/UserGuide.md
index e829a4b51..28ced738b 100644
--- a/UserGuide.md
+++ b/UserGuide.md
@@ -5,6 +5,7 @@
 3. [Gson Performance and Scalability](#TOC-Gson-Performance-and-Scalability)
 4. [Gson Users](#TOC-Gson-Users)
 5. [Using Gson](#TOC-Using-Gson)
+   * [Using Gson with Gradle/Android](#TOC-Gson-With-Gradle)
    * [Using Gson with Maven](#TOC-Gson-With-Maven)
    * [Primitives Examples](#TOC-Primitives-Examples)
    * [Object Examples](#TOC-Object-Examples)
@@ -70,6 +71,12 @@ The primary class to use is [`Gson`](gson/src/main/java/com/google/gson/Gson.jav
 
 The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.
 
+## <a name="TOC-Gson-With-Gradle"></a>Using Gson with Gradle/Android
+```
+dependencies {
+    implementation 'com.google.code.gson:gson:2.8.5'
+}
+```
 ## <a name="TOC-Gson-With-Maven"></a>Using Gson with Maven
 To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:
 
@@ -79,7 +86,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.8.0</version>
+      <version>2.8.5</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>
@@ -137,14 +144,14 @@ BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
 
 #### <a name="TOC-Finer-Points-with-Objects"></a>**Finer Points with Objects**
 
-* It is perfectly fine (and recommended) to use private fields
+* It is perfectly fine (and recommended) to use private fields.
 * There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
 * If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
-* This implementation handles nulls correctly
-* While serializing, a null field is skipped from the output
-* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to null
-* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
-* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
+* This implementation handles nulls correctly.
+  * While serializing, a null field is omitted from the output.
+  * While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
+* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization.
+* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.
 
 ### <a name="TOC-Nested-Classes-including-Inner-Classes-"></a>Nested Classes (including Inner Classes)
 
@@ -503,12 +510,12 @@ public class VersionedClass {
 
 VersionedClass versionedObject = new VersionedClass();
 Gson gson = new GsonBuilder().setVersion(1.0).create();
-String jsonOutput = gson.toJson(someObject);
+String jsonOutput = gson.toJson(versionedObject);
 System.out.println(jsonOutput);
 System.out.println();
 
 gson = new Gson();
-jsonOutput = gson.toJson(someObject);
+jsonOutput = gson.toJson(versionedObject);
 System.out.println(jsonOutput);
 ```
 
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 000000000..28586b5ec
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,12 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
+    }
+}
+
diff --git a/examples/android-proguard-example/AndroidManifest.xml b/examples/android-proguard-example/AndroidManifest.xml
old mode 100755
new mode 100644
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
index 5db375b8b..6c5709f3d 100644
--- a/examples/android-proguard-example/proguard.cfg
+++ b/examples/android-proguard-example/proguard.cfg
@@ -7,7 +7,7 @@
 -keepattributes *Annotation*
 
 # Gson specific classes
--keep class sun.misc.Unsafe { *; }
+-dontwarn sun.misc.**
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson
diff --git a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
index bc0569cbd..47e7f5152 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
@@ -104,9 +104,9 @@
  * registered. This protects your application from injection attacks. If you
  * don't supply an explicit type label, the type's simple name will be used.
  * <pre>   {@code
- *   shapeAdapter.registerSubtype(Rectangle.class, "Rectangle");
- *   shapeAdapter.registerSubtype(Circle.class, "Circle");
- *   shapeAdapter.registerSubtype(Diamond.class, "Diamond");
+ *   shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
+ *   shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
+ *   shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
  * }</pre>
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
@@ -126,21 +126,32 @@
   private final String typeFieldName;
   private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();
   private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();
+  private final boolean maintainType;
 
-  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
+  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {
     if (typeFieldName == null || baseType == null) {
       throw new NullPointerException();
     }
     this.baseType = baseType;
     this.typeFieldName = typeFieldName;
+    this.maintainType = maintainType;
   }
 
+  /**
+   * Creates a new runtime type adapter using for {@code baseType} using {@code
+   * typeFieldName} as the type field name. Type field names are case sensitive.
+   * {@code maintainType} flag decide if the type will be stored in pojo or not.
+   */
+  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {
+    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, maintainType);
+  }
+  
   /**
    * Creates a new runtime type adapter using for {@code baseType} using {@code
    * typeFieldName} as the type field name. Type field names are case sensitive.
    */
   public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);
+    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, false);
   }
 
   /**
@@ -148,7 +159,7 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
    * the type field name.
    */
   public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, "type");
+    return new RuntimeTypeAdapterFactory<T>(baseType, "type", false);
   }
 
   /**
@@ -199,7 +210,13 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
     return new TypeAdapter<R>() {
       @Override public R read(JsonReader in) throws IOException {
         JsonElement jsonElement = Streams.parse(in);
-        JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
+        JsonElement labelJsonElement;
+        if (maintainType) {
+            labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
+        } else {
+            labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
+        }
+        
         if (labelJsonElement == null) {
           throw new JsonParseException("cannot deserialize " + baseType
               + " because it does not define a field named " + typeFieldName);
@@ -224,12 +241,20 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
               + "; did you forget to register a subtype?");
         }
         JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();
+
+        if (maintainType) {
+          Streams.write(jsonObject, out);
+          return;
+        }
+
+        JsonObject clone = new JsonObject();
+
         if (jsonObject.has(typeFieldName)) {
           throw new JsonParseException("cannot serialize " + srcType.getName()
               + " because it already defines a field named " + typeFieldName);
         }
-        JsonObject clone = new JsonObject();
         clone.add(typeFieldName, new JsonPrimitive(label));
+        
         for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
           clone.add(e.getKey(), e.getValue());
         }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 000000000..7a3265ee9
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 000000000..4c5f88200
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Apr 27 17:41:01 PDT 2018
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 000000000..cccdd3d51
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100755
index 000000000..f9553162f
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,84 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/gson/README b/gson/README
index ebae78030..a925a5cd0 100644
--- a/gson/README
+++ b/gson/README
@@ -1,5 +1,5 @@
-Gson is a Java library that can be used to convert a Java object into its 
-JSON representation. It can also be used to convert a JSON string into an 
+Gson is a Java library that can be used to convert Java Objects into their 
+JSON representation. It can also be used to convert a JSON string to an 
 equivalent Java object. Gson can work with arbitrary Java objects including 
 pre-existing objects that you do not have source-code of.
 
diff --git a/gson/build.gradle b/gson/build.gradle
new file mode 100644
index 000000000..4dd24c1d0
--- /dev/null
+++ b/gson/build.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+
+group = 'com.google.code.gson'
+version = '2.8.6-SNAPSHOT'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+sourceSets.main.java.exclude("**/module-info.java")
+dependencies {
+    testCompile "junit:junit:4.12"
+}
diff --git a/gson/pom.xml b/gson/pom.xml
index 105b409a8..8f233fe71 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.8.6-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>
@@ -17,7 +17,7 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-
+ 
   <build>
     <plugins>
       <plugin>
@@ -34,7 +34,7 @@
       <plugin>
         <groupId>biz.aQute.bnd</groupId>
         <artifactId>bnd-maven-plugin</artifactId>
-        <version>3.1.0</version>
+        <version>4.0.0</version>
         <executions>
           <execution>
             <goals>
@@ -56,6 +56,23 @@
         <groupId>org.apache.felix</groupId>
         <artifactId>maven-bundle-plugin</artifactId>
       </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>templating-maven-plugin</artifactId>
+        <version>1.0.0</version>
+        <executions>
+          <execution>
+            <id>filtering-java-templates</id>
+            <goals>
+              <goal>filter-sources</goal>
+            </goals>
+            <configuration>
+              <sourceDirectory>${basedir}/src/main/java-templates</sourceDirectory>
+              <outputDirectory>${project.build.directory}/generated-sources/java-templates</outputDirectory>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/gson/src/main/java-templates/com/google/gson/internal/GsonBuildConfig.java b/gson/src/main/java-templates/com/google/gson/internal/GsonBuildConfig.java
new file mode 100644
index 000000000..a94c96b8e
--- /dev/null
+++ b/gson/src/main/java-templates/com/google/gson/internal/GsonBuildConfig.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal;
+
+/**
+ * Build configuration for Gson. This file is automatically populated by
+ * templating-maven-plugin and .java/.class files are generated for use in Gson.
+ *
+ * @author Inderjeet Singh
+ */
+public final class GsonBuildConfig {
+  // Based on https://stackoverflow.com/questions/2469922/generate-a-version-java-file-in-maven
+
+  /** This field is automatically populated by Maven when a build is triggered */
+  public static final String VERSION = "${project.version}";
+
+  private GsonBuildConfig() { }
+}
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 95eb42bea..522963795 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -22,9 +22,13 @@
 import java.text.ParseException;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
 
+import com.google.gson.internal.JavaVersion;
+import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -42,58 +46,84 @@
   private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
 
   private final Class<? extends Date> dateType;
-  private final DateFormat enUsFormat;
-  private final DateFormat localFormat;
-  
+
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
+
   DefaultDateTypeAdapter(Class<? extends Date> dateType) {
-    this(dateType,
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (JavaVersion.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
   }
 
   DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
-    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(new SimpleDateFormat(datePattern, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(new SimpleDateFormat(datePattern));
+    }
   }
 
   DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
-    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateInstance(style, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateInstance(style));
+    }
+    if (JavaVersion.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
+    }
   }
 
   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(Date.class,
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    this(Date.class, dateStyle, timeStyle);
   }
 
   public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {
-    this(dateType,
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    }
+    if (JavaVersion.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
+    }
   }
 
-  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {
+  private static Class<? extends Date> verifyDateType(Class<? extends Date> dateType) {
     if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {
       throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType);
     }
-    this.dateType = dateType;
-    this.enUsFormat = enUsFormat;
-    this.localFormat = localFormat;
+    return dateType;
   }
 
   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
   // See issue 162
   @Override
   public void write(JsonWriter out, Date value) throws IOException {
-    synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(value);
+    if (value == null) {
+      out.nullValue();
+      return;
+    }
+    synchronized(dateFormats) {
+      String dateFormatAsString = dateFormats.get(0).format(value);
       out.value(dateFormatAsString);
     }
   }
 
   @Override
   public Date read(JsonReader in) throws IOException {
-    if (in.peek() != JsonToken.STRING) {
-      throw new JsonParseException("The date should be a string value");
+    if (in.peek() == JsonToken.NULL) {
+      in.nextNull();
+      return null;
     }
     Date date = deserializeToDate(in.nextString());
     if (dateType == Date.class) {
@@ -109,13 +139,12 @@ public Date read(JsonReader in) throws IOException {
   }
 
   private Date deserializeToDate(String s) {
-    synchronized (localFormat) {
-      try {
-        return localFormat.parse(s);
-      } catch (ParseException ignored) {}
-      try {
-        return enUsFormat.parse(s);
-      } catch (ParseException ignored) {}
+    synchronized (dateFormats) {
+      for (DateFormat dateFormat : dateFormats) {
+        try {
+          return dateFormat.parse(s);
+        } catch (ParseException ignored) {}
+      }
       try {
         return ISO8601Utils.parse(s, new ParsePosition(0));
       } catch (ParseException e) {
@@ -126,9 +155,11 @@ private Date deserializeToDate(String s) {
 
   @Override
   public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(SIMPLE_NAME);
-    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');
-    return sb.toString();
+    DateFormat defaultFormat = dateFormats.get(0);
+    if (defaultFormat instanceof SimpleDateFormat) {
+      return SIMPLE_NAME + '(' + ((SimpleDateFormat) defaultFormat).toPattern() + ')';
+    } else {
+      return SIMPLE_NAME + '(' + defaultFormat.getClass().getSimpleName() + ')';
+    }
   }
 }
diff --git a/gson/src/main/java/com/google/gson/ExclusionStrategy.java b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
index 6a3f43fb5..ea452681c 100644
--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java
+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
@@ -20,7 +20,7 @@
  * A strategy (or policy) definition that is used to decide whether or not a field or top-level
  * class should be serialized or deserialized as part of the JSON output/input. For serialization,
  * if the {@link #shouldSkipClass(Class)} method returns true then that class or field type
- * will not be part of the JSON output.  For deserialization, if {@link #shouldSkipClass(Class)}
+ * will not be part of the JSON output. For deserialization, if {@link #shouldSkipClass(Class)}
  * returns true, then it will not be set as part of the Java object structure.
  *
  * <p>The following are a few examples that shows how you can use this exclusion mechanism.
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
index ad7bb6c89..1f1eb8f10 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
@@ -114,6 +114,29 @@
     @Override public String translateName(Field f) {
       return separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
     }
+  },
+
+  /**
+   * Using this naming policy with Gson will modify the Java Field name from its camel cased
+   * form to a lower case field name where each word is separated by a dot (.).
+   *
+   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+   * <ul>
+   *   <li>someFieldName ---> some.field.name</li>
+   *   <li>_someFieldName ---> _some.field.name</li>
+   *   <li>aStringField ---> a.string.field</li>
+   *   <li>aURL ---> a.u.r.l</li>
+   * </ul>
+   * Using dots in JavaScript is not recommended since dot is also used for a member sign in
+   * expressions. This requires that a field named with dots is always accessed as a quoted
+   * property like {@code myobject['my.field']}. Accessing it as an object field
+   * {@code myobject.my.field} will result in an unintended javascript expression.
+   * @since 2.8
+   */
+  LOWER_CASE_WITH_DOTS() {
+    @Override public String translateName(Field f) {
+      return separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
+    }
   };
 
   /**
diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
index 9be453ad1..f2f7c489a 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
@@ -19,9 +19,9 @@
 import java.lang.reflect.Field;
 
 /**
- * A mechanism for providing custom field naming in Gson.  This allows the client code to translate
+ * A mechanism for providing custom field naming in Gson. This allows the client code to translate
  * field names into a particular convention that is not supported as a normal Java field
- * declaration rules.  For example, Java does not support "-" characters in a field name.
+ * declaration rules. For example, Java does not support "-" characters in a field name.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 28285738e..27f3ee924 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -25,6 +25,7 @@
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -36,6 +37,7 @@
 
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
+import com.google.gson.internal.GsonBuildConfig;
 import com.google.gson.internal.Primitives;
 import com.google.gson.internal.Streams;
 import com.google.gson.internal.bind.ArrayTypeAdapter;
@@ -78,7 +80,7 @@
  *
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
- * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
+ * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method. Here is an
  * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
@@ -124,18 +126,28 @@
 
   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
 
-  private final List<TypeAdapterFactory> factories;
   private final ConstructorConstructor constructorConstructor;
-
-  private final Excluder excluder;
-  private final FieldNamingStrategy fieldNamingStrategy;
-  private final boolean serializeNulls;
-  private final boolean htmlSafe;
-  private final boolean generateNonExecutableJson;
-  private final boolean prettyPrinting;
-  private final boolean lenient;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
+  final List<TypeAdapterFactory> factories;
+
+  final Excluder excluder;
+  final FieldNamingStrategy fieldNamingStrategy;
+  final Map<Type, InstanceCreator<?>> instanceCreators;
+  final boolean serializeNulls;
+  final boolean complexMapKeySerialization;
+  final boolean generateNonExecutableJson;
+  final boolean htmlSafe;
+  final boolean prettyPrinting;
+  final boolean lenient;
+  final boolean serializeSpecialFloatingPointValues;
+  final String datePattern;
+  final int dateStyle;
+  final int timeStyle;
+  final LongSerializationPolicy longSerializationPolicy;
+  final List<TypeAdapterFactory> builderFactories;
+  final List<TypeAdapterFactory> builderHierarchyFactories;
+
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
    * following settings:
@@ -175,23 +187,36 @@ public Gson() {
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
+        LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
+        Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
+        Collections.<TypeAdapterFactory>emptyList());
   }
 
-  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
-      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+  Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
+      Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
-      LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
-    this.constructorConstructor = new ConstructorConstructor(instanceCreators);
+      LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
+      int timeStyle, List<TypeAdapterFactory> builderFactories,
+      List<TypeAdapterFactory> builderHierarchyFactories,
+      List<TypeAdapterFactory> factoriesToBeAdded) {
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
+    this.instanceCreators = instanceCreators;
+    this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.serializeNulls = serializeNulls;
+    this.complexMapKeySerialization = complexMapKeySerialization;
     this.generateNonExecutableJson = generateNonExecutableGson;
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = longSerializationPolicy;
+    this.datePattern = datePattern;
+    this.dateStyle = dateStyle;
+    this.timeStyle = timeStyle;
+    this.builderFactories = builderFactories;
+    this.builderHierarchyFactories = builderHierarchyFactories;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -202,8 +227,8 @@ public Gson() {
     // the excluder must precede all adapters that handle user-defined types
     factories.add(excluder);
 
-    // user's type adapters
-    factories.addAll(typeAdapterFactories);
+    // users' type adapters
+    factories.addAll(factoriesToBeAdded);
 
     // type adapters for basic platform types
     factories.add(TypeAdapters.STRING_FACTORY);
@@ -255,6 +280,16 @@ public Gson() {
     this.factories = Collections.unmodifiableList(factories);
   }
 
+  /**
+   * Returns a new GsonBuilder containing all custom factories and configuration used by the current
+   * instance.
+   *
+   * @return a GsonBuilder instance.
+   */
+  public GsonBuilder newBuilder() {
+    return new GsonBuilder(this);
+  }
+
   public Excluder excluder() {
     return excluder;
   }
@@ -427,7 +462,7 @@ static void checkValidFloatingPoint(double value) {
           return candidate;
         }
       }
-      throw new IllegalArgumentException("GSON cannot handle " + type);
+      throw new IllegalArgumentException("GSON (" + GsonBuildConfig.VERSION + ") cannot handle " + type);
     } finally {
       threadCalls.remove(type);
 
@@ -669,6 +704,10 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
       ((TypeAdapter<Object>) adapter).write(writer, src);
     } catch (IOException e) {
       throw new JsonIOException(e);
+    } catch (AssertionError e) {
+      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -745,6 +784,10 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
       Streams.write(jsonElement, writer);
     } catch (IOException e) {
       throw new JsonIOException(e);
+    } catch (AssertionError e) {
+      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -765,7 +808,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the string from which the object is to be deserialized
    * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    * classOfT
    */
@@ -788,7 +832,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
    * </pre>
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    */
@@ -900,6 +945,10 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
     } catch (IOException e) {
       // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
       throw new JsonSyntaxException(e);
+    } catch (AssertionError e) {
+      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       reader.setLenient(oldLenient);
     }
@@ -917,7 +966,8 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
    * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
    * be deserialized
    * @param classOfT The class of T
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
    * @since 1.3
    */
@@ -940,7 +990,8 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
    * </pre>
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
    * @since 1.3
    */
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index bd4b87ddb..b97be452b 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -104,6 +104,31 @@
   public GsonBuilder() {
   }
 
+  /**
+   * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
+   * has the same configuration as the previously built Gson instance.
+   *
+   * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
+   */
+  GsonBuilder(Gson gson) {
+    this.excluder = gson.excluder;
+    this.fieldNamingPolicy = gson.fieldNamingStrategy;
+    this.instanceCreators.putAll(gson.instanceCreators);
+    this.serializeNulls = gson.serializeNulls;
+    this.complexMapKeySerialization = gson.complexMapKeySerialization;
+    this.generateNonExecutableJson = gson.generateNonExecutableJson;
+    this.escapeHtmlChars = gson.htmlSafe;
+    this.prettyPrinting = gson.prettyPrinting;
+    this.lenient = gson.lenient;
+    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = gson.longSerializationPolicy;
+    this.datePattern = gson.datePattern;
+    this.dateStyle = gson.dateStyle;
+    this.timeStyle = gson.timeStyle;
+    this.factories.addAll(gson.builderFactories);
+    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+  }
+
   /**
    * Configures Gson to enable versioning support.
    *
@@ -572,7 +597,9 @@ public Gson create() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        serializeSpecialFloatingPointValues, longSerializationPolicy,
+        datePattern, dateStyle, timeStyle,
+        this.factories, this.hierarchyFactories, factories);
   }
 
   @SuppressWarnings("unchecked")
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index 62bb920cd..315ff82e9 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -259,15 +259,19 @@ public byte getAsByte() {
   }
 
   /**
-   * convenience method to get this element as a primitive character value.
+   * convenience method to get the first character of this element as a string or the first
+   * character of this array's first element as a string.
    *
-   * @return get this element as a primitive char value.
+   * @return the first character of the string.
    * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * char value.
+   * string value.
    * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
    * more than a single element.
    * @since 1.3
+   * @deprecated This method is misleading, as it does not get this element as a char but rather as
+   * a string's first character.
    */
+  @Deprecated
   public char getAsCharacter() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
diff --git a/gson/src/main/java/com/google/gson/JsonNull.java b/gson/src/main/java/com/google/gson/JsonNull.java
old mode 100755
new mode 100644
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 4b63db56c..d4feb96e8 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -55,10 +55,7 @@ public JsonObject deepCopy() {
    * @param value the member object.
    */
   public void add(String property, JsonElement value) {
-    if (value == null) {
-      value = JsonNull.INSTANCE;
-    }
-    members.put(property, value);
+    members.put(property, value == null ? JsonNull.INSTANCE : value);
   }
 
   /**
@@ -80,7 +77,7 @@ public JsonElement remove(String property) {
    * @param value the string value associated with the member.
    */
   public void addProperty(String property, String value) {
-    add(property, createJsonElement(value));
+    add(property, value == null ? JsonNull.INSTANCE : new JsonPrimitive(value));
   }
 
   /**
@@ -91,7 +88,7 @@ public void addProperty(String property, String value) {
    * @param value the number value associated with the member.
    */
   public void addProperty(String property, Number value) {
-    add(property, createJsonElement(value));
+    add(property, value == null ? JsonNull.INSTANCE : new JsonPrimitive(value));
   }
 
   /**
@@ -102,7 +99,7 @@ public void addProperty(String property, Number value) {
    * @param value the number value associated with the member.
    */
   public void addProperty(String property, Boolean value) {
-    add(property, createJsonElement(value));
+    add(property, value == null ? JsonNull.INSTANCE : new JsonPrimitive(value));
   }
 
   /**
@@ -113,17 +110,7 @@ public void addProperty(String property, Boolean value) {
    * @param value the number value associated with the member.
    */
   public void addProperty(String property, Character value) {
-    add(property, createJsonElement(value));
-  }
-
-  /**
-   * Creates the proper {@link JsonElement} object from the given {@code value} object.
-   *
-   * @param value the object to generate the {@link JsonElement} for
-   * @return a {@link JsonPrimitive} if the {@code value} is not null, otherwise a {@link JsonNull}
-   */
-  private JsonElement createJsonElement(Object value) {
-    return value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);
+    add(property, value == null ? JsonNull.INSTANCE : new JsonPrimitive(value));
   }
 
   /**
diff --git a/gson/src/main/java/com/google/gson/JsonParseException.java b/gson/src/main/java/com/google/gson/JsonParseException.java
index 084f66127..c1f264d76 100644
--- a/gson/src/main/java/com/google/gson/JsonParseException.java
+++ b/gson/src/main/java/com/google/gson/JsonParseException.java
@@ -18,12 +18,12 @@
 
 /**
  * This exception is raised if there is a serious issue that occurs during parsing of a Json
- * string.  One of the main usages for this class is for the Gson infrastructure.  If the incoming
+ * string. One of the main usages for this class is for the Gson infrastructure. If the incoming
  * Json is bad/malicious, an instance of this exception is raised.
  *
- * <p>This exception is a {@link RuntimeException} because it is exposed to the client.  Using a
+ * <p>This exception is a {@link RuntimeException} because it is exposed to the client. Using a
  * {@link RuntimeException} avoids bad coding practices on the client side where they catch the
- * exception and do nothing.  It is often the case that you want to blow up if there is a parsing
+ * exception and do nothing. It is often the case that you want to blow up if there is a parsing
  * error (i.e. often clients do not know how to recover from a {@link JsonParseException}.</p>
  *
  * @author Inderjeet Singh
diff --git a/gson/src/main/java/com/google/gson/JsonParser.java b/gson/src/main/java/com/google/gson/JsonParser.java
old mode 100755
new mode 100644
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index adb18fad0..d4640293e 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -16,10 +16,10 @@
 
 package com.google.gson;
 
+import com.google.gson.internal.$Gson$Preconditions;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
-import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.LazilyParsedNumber;
 
 /**
@@ -32,11 +32,7 @@
  */
 public final class JsonPrimitive extends JsonElement {
 
-  private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,
-      float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,
-      Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };
-
-  private Object value;
+  private final Object value;
 
   /**
    * Create a primitive containing a boolean value.
@@ -44,7 +40,7 @@
    * @param bool the value to create the primitive with.
    */
   public JsonPrimitive(Boolean bool) {
-    setValue(bool);
+    value = $Gson$Preconditions.checkNotNull(bool);
   }
 
   /**
@@ -53,7 +49,7 @@ public JsonPrimitive(Boolean bool) {
    * @param number the value to create the primitive with.
    */
   public JsonPrimitive(Number number) {
-    setValue(number);
+    value = $Gson$Preconditions.checkNotNull(number);
   }
 
   /**
@@ -62,7 +58,7 @@ public JsonPrimitive(Number number) {
    * @param string the value to create the primitive with.
    */
   public JsonPrimitive(String string) {
-    setValue(string);
+    value = $Gson$Preconditions.checkNotNull(string);
   }
 
   /**
@@ -72,17 +68,9 @@ public JsonPrimitive(String string) {
    * @param c the value to create the primitive with.
    */
   public JsonPrimitive(Character c) {
-    setValue(c);
-  }
-
-  /**
-   * Create a primitive using the specified Object. It must be an instance of {@link Number}, a
-   * Java primitive type, or a String.
-   *
-   * @param primitive the value to create the primitive with.
-   */
-  JsonPrimitive(Object primitive) {
-    setValue(primitive);
+    // convert characters to strings since in JSON, characters are represented as a single
+    // character string
+    value = $Gson$Preconditions.checkNotNull(c).toString();
   }
 
   /**
@@ -94,19 +82,6 @@ public JsonPrimitive deepCopy() {
     return this;
   }
 
-  void setValue(Object primitive) {
-    if (primitive instanceof Character) {
-      // convert characters to strings since in JSON, characters are represented as a single
-      // character string
-      char c = ((Character) primitive).charValue();
-      this.value = String.valueOf(c);
-    } else {
-      $Gson$Preconditions.checkArgument(primitive instanceof Number
-              || isPrimitiveOrString(primitive));
-      this.value = primitive;
-    }
-  }
-
   /**
    * Check whether this primitive contains a boolean value.
    *
@@ -274,20 +249,6 @@ public char getAsCharacter() {
     return getAsString().charAt(0);
   }
 
-  private static boolean isPrimitiveOrString(Object target) {
-    if (target instanceof String) {
-      return true;
-    }
-
-    Class<?> classOfPrimitive = target.getClass();
-    for (Class<?> standardPrimitive : PRIMITIVE_TYPES) {
-      if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   @Override
   public int hashCode() {
     if (value == null) {
diff --git a/gson/src/main/java/com/google/gson/JsonStreamParser.java b/gson/src/main/java/com/google/gson/JsonStreamParser.java
index f0438db32..1c0c9b9d6 100644
--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java
@@ -33,7 +33,7 @@
  * 
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
- * synchronization.  For example:
+ * synchronization. For example:
  * 
  * <pre>
  * JsonStreamParser parser = new JsonStreamParser("['first'] {'second':10} 'third'");
diff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
index 7b732bab7..bb2b6666e 100644
--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
+++ b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
@@ -27,7 +27,7 @@
 public enum LongSerializationPolicy {
   /**
    * This is the "default" serialization policy that will output a {@code long} object as a JSON
-   * number.  For example, assume an object has a long field named "f" then the serialized output
+   * number. For example, assume an object has a long field named "f" then the serialized output
    * would be:
    * {@code {"f":123}}.
    */
@@ -38,7 +38,7 @@
   },
   
   /**
-   * Serializes a long value as a quoted string.  For example, assume an object has a long field 
+   * Serializes a long value as a quoted string. For example, assume an object has a long field 
    * named "f" then the serialized output would be:
    * {@code {"f":"123"}}.
    */
diff --git a/gson/src/main/java/com/google/gson/annotations/SerializedName.java b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
index 9e8e4b8d4..82bb51cd5 100644
--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java
+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
@@ -28,7 +28,7 @@
  *
  * <p>This annotation will override any {@link com.google.gson.FieldNamingPolicy}, including
  * the default field naming policy, that may have been set on the {@link com.google.gson.Gson}
- * instance.  A different naming policy can set using the {@code GsonBuilder} class.  See
+ * instance. A different naming policy can set using the {@code GsonBuilder} class. See
  * {@link com.google.gson.GsonBuilder#setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)}
  * for more information.</p>
  *
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/gson/annotations/Until.java
index 676a4b959..8c38552b9 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/gson/annotations/Until.java
@@ -25,7 +25,7 @@
 /**
  * An annotation that indicates the version number until a member or a type should be present.
  * Basically, if Gson is created with a version number that exceeds the value stored in the
- * {@code Until} annotation then the field will be ignored from the JSON output.  This annotation
+ * {@code Until} annotation then the field will be ignored from the JSON output. This annotation
  * is useful to manage versioning of your JSON classes for a web-service.
  *
  * <p>
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index f66ac157b..adea605f5 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -275,6 +275,10 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
    * @param supertype a superclass of, or interface implemented by, this.
    */
   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (context instanceof WildcardType) {
+      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
+      context = ((WildcardType)context).getUpperBounds()[0];
+    }
     checkArgument(supertype.isAssignableFrom(contextRawType));
     return resolve(context, contextRawType,
         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index 6d1e7c967..5fab46010 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -40,6 +40,7 @@
 
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonIOException;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 
 /**
@@ -47,6 +48,7 @@
  */
 public final class ConstructorConstructor {
   private final Map<Type, InstanceCreator<?>> instanceCreators;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     this.instanceCreators = instanceCreators;
@@ -98,7 +100,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     try {
       final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
       if (!constructor.isAccessible()) {
-        constructor.setAccessible(true);
+        accessor.makeAccessible(constructor);
       }
       return new ObjectConstructor<T>() {
         @SuppressWarnings("unchecked") // T is the same raw type as is requested
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index bef790406..6b83757ed 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -110,8 +110,10 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
 
   public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
-    final boolean skipSerialize = excludeClass(rawType, true);
-    final boolean skipDeserialize = excludeClass(rawType, false);
+    boolean excludeClass = excludeClassChecks(rawType);
+
+    final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
+    final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
 
     if (!skipSerialize && !skipDeserialize) {
       return null;
@@ -188,28 +190,35 @@ public boolean excludeField(Field field, boolean serialize) {
     return false;
   }
 
-  public boolean excludeClass(Class<?> clazz, boolean serialize) {
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (!serializeInnerClasses && isInnerClass(clazz)) {
-      return true;
-    }
+  private boolean excludeClassChecks(Class<?> clazz) {
+      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
+          return true;
+      }
 
-    if (isAnonymousOrLocal(clazz)) {
-      return true;
-    }
+      if (!serializeInnerClasses && isInnerClass(clazz)) {
+          return true;
+      }
 
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    for (ExclusionStrategy exclusionStrategy : list) {
-      if (exclusionStrategy.shouldSkipClass(clazz)) {
-        return true;
+      if (isAnonymousOrLocal(clazz)) {
+          return true;
       }
-    }
 
-    return false;
+      return false;
+  }
+
+  public boolean excludeClass(Class<?> clazz, boolean serialize) {
+      return excludeClassChecks(clazz) ||
+              excludeClassInStrategy(clazz, serialize);
+  }
+
+  private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
+      List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+      for (ExclusionStrategy exclusionStrategy : list) {
+          if (exclusionStrategy.shouldSkipClass(clazz)) {
+              return true;
+          }
+      }
+      return false;
   }
 
   private boolean isAnonymousOrLocal(Class<?> clazz) {
diff --git a/gson/src/main/java/com/google/gson/internal/JavaVersion.java b/gson/src/main/java/com/google/gson/internal/JavaVersion.java
new file mode 100644
index 000000000..fab1b7c27
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/JavaVersion.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal;
+
+/**
+ * Utility to check the major Java version of the current JVM.
+ */
+public final class JavaVersion {
+  // Oracle defines naming conventions at http://www.oracle.com/technetwork/java/javase/versioning-naming-139433.html
+  // However, many alternate implementations differ. For example, Debian used 9-debian as the version string
+
+  private static final int majorJavaVersion = determineMajorJavaVersion();
+
+  private static int determineMajorJavaVersion() {
+    String javaVersion = System.getProperty("java.version");
+    return getMajorJavaVersion(javaVersion);
+  }
+
+  // Visible for testing only
+  static int getMajorJavaVersion(String javaVersion) {
+    int version = parseDotted(javaVersion);
+    if (version == -1) {
+      version = extractBeginningInt(javaVersion);
+    }
+    if (version == -1) {
+      return 6;  // Choose minimum supported JDK version as default
+    }
+    return version;
+  }
+
+  // Parses both legacy 1.8 style and newer 9.0.4 style 
+  private static int parseDotted(String javaVersion) {
+    try {
+      String[] parts = javaVersion.split("[._]");
+      int firstVer = Integer.parseInt(parts[0]);
+      if (firstVer == 1 && parts.length > 1) {
+        return Integer.parseInt(parts[1]);
+      } else {
+        return firstVer;
+      }
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  private static int extractBeginningInt(String javaVersion) {
+    try {
+      StringBuilder num = new StringBuilder();
+      for (int i = 0; i < javaVersion.length(); ++i) {
+        char c = javaVersion.charAt(i);
+        if (Character.isDigit(c)) {
+          num.append(c);
+        } else {
+          break;
+        }
+      }
+      return Integer.parseInt(num.toString());
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
+   */
+  public static int getMajorJavaVersion() {
+    return majorJavaVersion;
+  }
+
+  /**
+   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
+   */
+  public static boolean isJava9OrLater() {
+    return majorJavaVersion >= 9;
+  }
+
+  private JavaVersion() { }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
new file mode 100644
index 000000000..beb527c9e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Locale;
+
+/**
+ * Provides DateFormats for US locale with patterns which were the default ones before Java 9.
+ */
+public class PreJava9DateFormatProvider {
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below.
+   */
+  public static DateFormat getUSDateFormat(int style) {
+    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);
+  }
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}
+   * in Java 8 or below.
+   */
+  public static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {
+    String pattern = getDatePartOfDateTimePattern(dateStyle) + " " + getTimePartOfDateTimePattern(timeStyle);
+    return new SimpleDateFormat(pattern, Locale.US);
+  }
+
+  private static String getDateFormatPattern(int style) {
+    switch (style) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, y";
+    case DateFormat.LONG:
+      return "MMMM d, y";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, y";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + style);
+    }
+  }
+
+  private static String getDatePartOfDateTimePattern(int dateStyle) {
+    switch (dateStyle) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, yyyy";
+    case DateFormat.LONG:
+      return "MMMM d, yyyy";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, yyyy";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + dateStyle);
+    }
+  }
+
+  private static String getTimePartOfDateTimePattern(int timeStyle) {
+    switch (timeStyle) {
+    case DateFormat.SHORT:
+      return "h:mm a";
+    case DateFormat.MEDIUM:
+      return "h:mm:ss a";
+    case DateFormat.FULL:
+    case DateFormat.LONG:
+      return "h:mm:ss a z";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + timeStyle);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
index 561af1985..6e849690e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
@@ -20,16 +20,21 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.JavaVersion;
+import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.ParsePosition;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -46,10 +51,21 @@
     }
   };
 
-  private final DateFormat enUsFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);
-  private final DateFormat localFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them (default US format) is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
+
+  public DateTypeAdapter() {
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (JavaVersion.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+  }
 
   @Override public Date read(JsonReader in) throws IOException {
     if (in.peek() == JsonToken.NULL) {
@@ -60,13 +76,10 @@
   }
 
   private synchronized Date deserializeToDate(String json) {
-    try {
-      return localFormat.parse(json);
-    } catch (ParseException ignored) {
-    }
-    try {
-      return enUsFormat.parse(json);
-    } catch (ParseException ignored) {
+    for (DateFormat dateFormat : dateFormats) {
+      try {
+        return dateFormat.parse(json);
+      } catch (ParseException ignored) {}
     }
     try {
     	return ISO8601Utils.parse(json, new ParsePosition(0));
@@ -80,7 +93,7 @@ private synchronized Date deserializeToDate(String json) {
       out.nullValue();
       return;
     }
-    String dateFormatAsString = enUsFormat.format(value);
+    String dateFormatAsString = dateFormats.get(0).format(value);
     out.value(dateFormatAsString);
   }
   
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
index 387b29e9b..a223754ae 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
@@ -27,6 +27,7 @@
 import java.io.Reader;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Arrays;
 
 /**
  * This reader walks the elements of a JsonElement as if it was coming from a
@@ -282,15 +283,10 @@ public void promoteNameToValue() throws IOException {
 
   private void push(Object newTop) {
     if (stackSize == stack.length) {
-      Object[] newStack = new Object[stackSize * 2];
-      int[] newPathIndices = new int[stackSize * 2];
-      String[] newPathNames = new String[stackSize * 2];
-      System.arraycopy(stack, 0, newStack, 0, stackSize);
-      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
-      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
-      stack = newStack;
-      pathIndices = newPathIndices;
-      pathNames = newPathNames;
+      int newLength = stackSize * 2;
+      stack = Arrays.copyOf(stack, newLength);
+      pathIndices = Arrays.copyOf(pathIndices, newLength);
+      pathNames = Arrays.copyOf(pathNames, newLength);
     }
     stack[stackSize++] = newTop;
   }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 42798d059..777e7dee3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -28,6 +28,7 @@
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -49,6 +50,7 @@
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
@@ -154,7 +156,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         if (!serialize && !deserialize) {
           continue;
         }
-        field.setAccessible(true);
+        accessor.makeAccessible(field);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index c2839bc89..354ce5a1f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -133,10 +133,11 @@ public Class read(JsonReader in) throws IOException {
   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
     @Override
     public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
+      JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
         in.nextNull();
         return null;
-      } else if (in.peek() == JsonToken.STRING) {
+      } else if (peek == JsonToken.STRING) {
         // support strings for compatibility with GSON 1.7
         return Boolean.parseBoolean(in.nextString());
       }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
index c931b0906..99ec679a7 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
@@ -266,7 +266,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
         } catch (IllegalArgumentException e) {
             fail = e;
         }
-        String input = (date == null) ? null : ('"' + date + "'");
+        String input = (date == null) ? null : ('"' + date + '"');
         String msg = fail.getMessage();
         if (msg == null || msg.isEmpty()) {
             msg = "("+fail.getClass().getName()+")";
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
new file mode 100644
index 000000000..325274e22
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * A basic implementation of {@link ReflectionAccessor} which is suitable for Java 8 and below.
+ * <p>
+ * This implementation just calls {@link AccessibleObject#setAccessible(boolean) setAccessible(true)}, which worked
+ * fine before Java 9.
+ */
+final class PreJava9ReflectionAccessor extends ReflectionAccessor {
+
+  /** {@inheritDoc} */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    ao.setAccessible(true);
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
new file mode 100644
index 000000000..6816feaf2
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+
+import com.google.gson.internal.JavaVersion;
+
+/**
+ * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
+ * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
+ * thrown or warnings like
+ * <pre>
+ *   WARNING: An illegal reflective access operation has occurred
+ *   WARNING: Illegal reflective access by ...
+ * </pre>
+ * <p/>
+ * Works both for Java 9 and earlier Java versions.
+ */
+public abstract class ReflectionAccessor {
+
+  // the singleton instance, use getInstance() to obtain
+  private static final ReflectionAccessor instance = JavaVersion.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
+
+  /**
+   * Does the same as {@code ao.setAccessible(true)}, but never throws
+   * {@link java.lang.reflect.InaccessibleObjectException}
+   */
+  public abstract void makeAccessible(AccessibleObject ao);
+
+  /**
+   * Obtains a {@link ReflectionAccessor} instance suitable for the current Java version.
+   * <p>
+   * You may need one a reflective operation in your code throws {@link java.lang.reflect.InaccessibleObjectException}.
+   * In such a case, use {@link ReflectionAccessor#makeAccessible(AccessibleObject)} on a field, method or constructor
+   * (instead of basic {@link AccessibleObject#setAccessible(boolean)}).
+   */
+  public static ReflectionAccessor getInstance() {
+    return instance;
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
new file mode 100644
index 000000000..749335b77
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import com.google.gson.JsonIOException;
+
+/**
+ * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
+ * <p>
+ * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
+ * use {@link PreJava9ReflectionAccessor} for them.
+ */
+@SuppressWarnings({"unchecked", "rawtypes"})
+final class UnsafeReflectionAccessor extends ReflectionAccessor {
+
+  private static Class unsafeClass;
+  private final Object theUnsafe = getUnsafeInstance();
+  private final Field overrideField = getOverrideField();
+
+  /** {@inheritDoc} */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    boolean success = makeAccessibleWithUnsafe(ao);
+    if (!success) {
+      try {
+        // unsafe couldn't be found, so try using accessible anyway
+        ao.setAccessible(true);
+      } catch (SecurityException e) {
+        throw new JsonIOException("Gson couldn't modify fields for " + ao
+          + "\nand sun.misc.Unsafe not found.\nEither write a custom type adapter,"
+          + " or make fields accessible, or include sun.misc.Unsafe.", e);
+      }
+    }
+  }
+
+  // Visible for testing only
+  boolean makeAccessibleWithUnsafe(AccessibleObject ao) {
+    if (theUnsafe != null && overrideField != null) {
+      try {
+        Method method = unsafeClass.getMethod("objectFieldOffset", Field.class);
+        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
+        Method putBooleanMethod = unsafeClass.getMethod("putBoolean",  Object.class, long.class, boolean.class);
+        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);
+        return true;
+      } catch (Exception ignored) { // do nothing
+      }
+    }
+    return false;
+  }
+
+  private static Object getUnsafeInstance() {
+    try {
+      unsafeClass = Class.forName("sun.misc.Unsafe");
+      Field unsafeField = unsafeClass.getDeclaredField("theUnsafe");
+      unsafeField.setAccessible(true);
+      return unsafeField.get(null);
+    } catch (Exception e) {
+      return null;
+    }
+  }
+
+  private static Field getOverrideField() {
+    try {
+      return AccessibleObject.class.getDeclaredField("override");
+    } catch (NoSuchFieldException e) {
+      return null;
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/reflect/package-info.java b/gson/src/main/java/com/google/gson/reflect/package-info.java
index e666c4311..5e43ee9fc 100644
--- a/gson/src/main/java/com/google/gson/reflect/package-info.java
+++ b/gson/src/main/java/com/google/gson/reflect/package-info.java
@@ -1,6 +1,6 @@
 /**
  * This package provides utility classes for finding type information for generic types.
- *  
+ *
  * @author Inderjeet Singh, Joel Leitch
  */
 package com.google.gson.reflect;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index e0799d736..1e2793865 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -22,6 +22,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Reader;
+import java.util.Arrays;
 
 /**
  * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
@@ -1262,15 +1263,10 @@ public void skipValue() throws IOException {
 
   private void push(int newTop) {
     if (stackSize == stack.length) {
-      int[] newStack = new int[stackSize * 2];
-      int[] newPathIndices = new int[stackSize * 2];
-      String[] newPathNames = new String[stackSize * 2];
-      System.arraycopy(stack, 0, newStack, 0, stackSize);
-      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
-      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
-      stack = newStack;
-      pathIndices = newPathIndices;
-      pathNames = newPathNames;
+      int newLength = stackSize * 2;
+      stack = Arrays.copyOf(stack, newLength);
+      pathIndices = Arrays.copyOf(pathIndices, newLength);
+      pathNames = Arrays.copyOf(pathNames, newLength);
     }
     stack[stackSize++] = newTop;
   }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index 8148816c2..597bd569a 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -20,6 +20,7 @@
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.Arrays;
 
 import static com.google.gson.stream.JsonScope.DANGLING_NAME;
 import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;
@@ -352,9 +353,7 @@ private JsonWriter close(int empty, int nonempty, String closeBracket)
 
   private void push(int newTop) {
     if (stackSize == stack.length) {
-      int[] newStack = new int[stackSize * 2];
-      System.arraycopy(stack, 0, newStack, 0, stackSize);
-      stack = newStack;
+      stack = Arrays.copyOf(stack, stackSize * 2);
     }
     stack[stackSize++] = newTop;
   }
diff --git a/gson/src/main/java/module-info.java b/gson/src/main/java/module-info.java
new file mode 100644
index 000000000..ba6ea07b7
--- /dev/null
+++ b/gson/src/main/java/module-info.java
@@ -0,0 +1,8 @@
+module com.google.gson {
+	exports com.google.gson;
+	exports com.google.gson.annotations;
+	exports com.google.gson.reflect;
+	exports com.google.gson.stream;
+
+	requires transitive java.sql;
+}
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
index b3ee5a6f4..679feb835 100644
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
@@ -22,6 +22,9 @@
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
+
+import com.google.gson.internal.JavaVersion;
+
 import junit.framework.TestCase;
 
 /**
@@ -45,17 +48,21 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(locale);
     try {
-      assertFormatted("Jan 1, 1970 12:00:00 AM", new DefaultDateTypeAdapter(Date.class));
+      String afterYearSep = JavaVersion.isJava9OrLater() ? ", " : " ";
+      String afterYearLongSep = JavaVersion.isJava9OrLater() ? " at " : " ";
+      String utcFull = JavaVersion.isJava9OrLater() ? "Coordinated Universal Time" : "UTC";
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
       assertFormatted("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
       assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
       assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
-      assertFormatted("1/1/70 12:00 AM",
+      assertFormatted(String.format("1/1/70%s12:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970 12:00:00 AM",
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("January 1, 1970%s12:00:00 AM UTC", afterYearLongSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertFormatted("Thursday, January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("Thursday, January 1, 1970%s12:00:00 AM %s", afterYearLongSep, utcFull),
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -69,17 +76,21 @@ public void testParsingDatesFormattedWithSystemLocale() throws Exception {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.FRANCE);
     try {
-      assertParsed("1 janv. 1970 00:00:00", new DefaultDateTypeAdapter(Date.class));
+      String afterYearSep = JavaVersion.isJava9OrLater() ? " à " : " ";
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
       assertParsed("01/01/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
       assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
       assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed("01/01/70 00:00",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertParsed("1 janv. 1970 00:00:00",
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970 00:00:00 UTC",
+      assertParsed(String.format("1 janvier 1970%s00:00:00 UTC", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed("jeudi 1 janvier 1970 00 h 00 UTC",
+      assertParsed(JavaVersion.isJava9OrLater() ?
+                      "jeudi 1 janvier 1970 à 00:00:00 Coordinated Universal Time" :
+                      "jeudi 1 janvier 1970 00 h 00 UTC",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -117,7 +128,9 @@ public void testFormatUsesDefaultTimezone() throws Exception {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertFormatted("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter(Date.class));
+      String afterYearSep = JavaVersion.isJava9OrLater() ? ", " : " ";
+      assertFormatted(String.format("Dec 31, 1969%s4:00:00 PM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
       assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter(Date.class));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -161,6 +174,20 @@ public void testInvalidDatePattern() throws Exception {
     } catch (IllegalArgumentException expected) { }
   }
 
+  public void testNullValue() throws Exception {
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+    assertNull(adapter.fromJson("null"));
+    assertEquals("null", adapter.toJson(null));
+  }
+
+  public void testUnexpectedToken() throws Exception {
+    try {
+      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+      adapter.fromJson("{}");
+      fail("Unexpected token should fail.");
+    } catch (IllegalStateException expected) { }
+  }
+
   private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {
     assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));
   }
diff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index fb0c00321..eec2ec91c 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -17,8 +17,12 @@
 package com.google.gson;
 
 import com.google.gson.internal.Excluder;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
+import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
 import junit.framework.TestCase;
@@ -43,12 +47,34 @@
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, true, false, LongSerializationPolicy.DEFAULT,
-        new ArrayList<TypeAdapterFactory>());
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
     assertEquals(true, gson.serializeNulls());
     assertEquals(false, gson.htmlSafe());
   }
+
+  public void testClonedTypeAdapterFactoryListsAreIndependent() {
+    Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
+        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+
+    Gson clone = original.newBuilder()
+        .registerTypeAdapter(Object.class, new TestTypeAdapter())
+        .create();
+
+    assertEquals(original.factories.size() + 1, clone.factories.size());
+  }
+
+  private static final class TestTypeAdapter extends TypeAdapter<Object> {
+    @Override public void write(JsonWriter out, Object value) throws IOException {
+      // Test stub.
+    }
+    @Override public Object read(JsonReader in) throws IOException { return null; }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java b/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
index fa3611c93..a9fbff935 100644
--- a/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
@@ -30,6 +30,29 @@
  */
 public class JsonPrimitiveTest extends TestCase {
 
+  public void testNulls() {
+    try {
+      new JsonPrimitive((Boolean) null);
+      fail();
+    } catch (NullPointerException ignored) {
+    }
+    try {
+      new JsonPrimitive((Number) null);
+      fail();
+    } catch (NullPointerException ignored) {
+    }
+    try {
+      new JsonPrimitive((String) null);
+      fail();
+    } catch (NullPointerException ignored) {
+    }
+    try {
+      new JsonPrimitive((Character) null);
+      fail();
+    } catch (NullPointerException ignored) {
+    }
+  }
+
   public void testBoolean() throws Exception {
     JsonPrimitive json = new JsonPrimitive(Boolean.TRUE);
 
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index 9a8f707b4..4ec7378b2 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -393,4 +393,23 @@ public void testSetDeserialization() {
       assertTrue(entry.value == 1 || entry.value == 2);
     }
   }
+
+  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }
+
+  private class SmallClass { private String inSmall; }
+
+  public void testIssue1107() {
+    String json = "{\n" +
+            "  \"inBig\": {\n" +
+            "    \"key\": [\n" +
+            "      { \"inSmall\": \"hello\" }\n" +
+            "    ]\n" +
+            "  }\n" +
+            "}";
+    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
+    SmallClass small = bigClass.inBig.get("key").get(0);
+    assertNotNull(small);
+    assertEquals("hello", small.inSmall);
+  }
+
 }
diff --git a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
index c53db7f23..8134ae2d1 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
@@ -31,7 +31,7 @@
 import java.lang.reflect.Type;
 
 /**
- * Functional Test exercising custom deserialization only.  When test applies to both
+ * Functional Test exercising custom deserialization only. When test applies to both
  * serialization and deserialization then add it to CustomTypeAdapterTest.
  *
  * @author Joel Leitch
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 198667162..b7307c6fc 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -27,6 +27,7 @@
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -55,6 +56,7 @@
 import java.util.TimeZone;
 import java.util.TreeSet;
 import java.util.UUID;
+
 import junit.framework.TestCase;
 
 /**
@@ -85,20 +87,20 @@ protected void tearDown() throws Exception {
 
   public void testClassSerialization() {
     try {
-      gson.toJson(String.class);  
+      gson.toJson(String.class);
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals("\"java.lang.String\"", gson.toJson(String.class));  
+    assertEquals("\"java.lang.String\"", gson.toJson(String.class));
   }
 
   public void testClassDeserialization() {
     try {
-      gson.fromJson("String.class", String.class.getClass());  
+      gson.fromJson("String.class", String.class.getClass());
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));  
+    assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
   }
 
   public void testUrlSerialization() throws Exception {
@@ -328,7 +330,11 @@ public void testBitSetDeserialization() throws Exception {
   public void testDefaultDateSerialization() {
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (JavaVersion.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserialization() {
@@ -369,7 +375,11 @@ public void testDefaultJavaSqlDateDeserialization() {
   public void testDefaultJavaSqlTimestampSerialization() {
     Timestamp now = new java.sql.Timestamp(1259875082000L);
     String json = gson.toJson(now);
-    assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    if (JavaVersion.isJava9OrLater()) {
+      assertEquals("\"Dec 3, 2009, 1:18:02 PM\"", json);
+    } else {
+      assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    }
   }
 
   public void testDefaultJavaSqlTimestampDeserialization() {
@@ -395,7 +405,11 @@ public void testDefaultDateSerializationUsingBuilder() throws Exception {
     Gson gson = new GsonBuilder().create();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (JavaVersion.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserializationUsingBuilder() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java
index 4a9f05b59..66b855ebf 100644
--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java
@@ -16,6 +16,12 @@
 
 package com.google.gson.functional;
 
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Set;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
@@ -29,13 +35,6 @@
 import com.google.gson.common.MoreAsserts;
 import com.google.gson.reflect.TypeToken;
 
-
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.Set;
-
 import junit.framework.TestCase;
 /**
  * Functional tests for Java 5.0 enums.
@@ -199,4 +198,19 @@ public void testEnumSet() {
     @SerializedName("girl")
     FEMALE
   }
+
+  public void testEnumClassWithFields() {
+	  assertEquals("\"RED\"", gson.toJson(Color.RED));
+	  assertEquals("red", gson.fromJson("RED", Color.class).value);
+  }
+
+  public enum Color {
+	  RED("red", 1), BLUE("blue", 2), GREEN("green", 3);
+	  String value;
+	  int index;
+	  private Color(String value, int index) {
+		  this.value = value;
+		  this.index = index;
+	  }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java b/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
new file mode 100644
index 000000000..36eff8e1e
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.functional;
+
+import java.io.IOException;
+import java.util.regex.Pattern;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * Functional tests to validate printing of Gson version on AssertionErrors
+ *
+ * @author Inderjeet Singh
+ */
+public class GsonVersionDiagnosticsTest extends TestCase {
+  private static final Pattern GSON_VERSION_PATTERN = Pattern.compile("(\\(GSON \\d\\.\\d\\.\\d)(?:[-.][A-Z]+)?\\)$");
+
+  private Gson gson;
+
+  @Before
+  public void setUp() {
+    gson = new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter<TestType>() {
+      @Override public void write(JsonWriter out, TestType value) {
+        throw new AssertionError("Expected during serialization");
+      }
+      @Override public TestType read(JsonReader in) throws IOException {
+        throw new AssertionError("Expected during deserialization");
+      }
+    }).create();
+  }
+
+  @Test
+  public void testVersionPattern() {
+    assertTrue(GSON_VERSION_PATTERN.matcher("(GSON 2.8.5)").matches());
+    assertTrue(GSON_VERSION_PATTERN.matcher("(GSON 2.8.5-SNAPSHOT)").matches());
+  }
+
+  @Test
+  public void testAssertionErrorInSerializationPrintsVersion() {
+    try {
+      gson.toJson(new TestType());
+      fail();
+    } catch (AssertionError expected) {
+      ensureAssertionErrorPrintsGsonVersion(expected);
+    }
+  }
+
+  @Test
+  public void testAssertionErrorInDeserializationPrintsVersion() {
+    try {
+      gson.fromJson("{'a':'abc'}", TestType.class);
+      fail();
+    } catch (AssertionError expected) {
+      ensureAssertionErrorPrintsGsonVersion(expected);
+    }
+  }
+
+  private void ensureAssertionErrorPrintsGsonVersion(AssertionError expected) {
+    String msg = expected.getMessage();
+    // System.err.println(msg);
+    int start = msg.indexOf("(GSON");
+    assertTrue(start > 0);
+    int end = msg.indexOf("):") + 1;
+    assertTrue(end > 0 && end > start + 6);
+    String version = msg.substring(start, end);
+    // System.err.println(version);
+    assertTrue(GSON_VERSION_PATTERN.matcher(version).matches());
+  }
+
+  private static final class TestType {
+    @SuppressWarnings("unused")
+    String a;
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
index b93ba0b59..475db8382 100644
--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
@@ -217,7 +217,7 @@ boolean queueContains(long... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     boolean setContains(float... values) {
@@ -235,7 +235,7 @@ boolean sortedSetContains(char... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     public String getExpectedJson() {
diff --git a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
index aad55eeb2..5437c876e 100644
--- a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
@@ -33,7 +33,7 @@
 import java.util.TreeSet;
 
 /**
- * Functional Test exercising custom serialization only.  When test applies to both
+ * Functional Test exercising custom serialization only. When test applies to both
  * serialization and deserialization then add it to CustomTypeAdapterTest.
  *
  * @author Inderjeet Singh
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index c3c0be1de..5b1bba5be 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -63,6 +63,20 @@ public void testGsonWithLowerCaseDashPolicySerialization() {
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
+  public void testGsonWithLowerCaseDotPolicySerialization() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    StringWrapper target = new StringWrapper("blah");
+    assertEquals("{\"some.constant.string.instance.field\":\""
+          + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
+  }
+
+  public void testGsonWithLowerCaseDotPolicyDeserialiation() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    String target = "{\"some.constant.string.instance.field\":\"someValue\"}";
+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
+    assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
+  }
+
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
     String target = "{\"some-constant-string-instance-field\":\"someValue\"}";
diff --git a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
old mode 100755
new mode 100644
index 7939a8c85..a9b77f1d8
--- a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
@@ -163,7 +163,7 @@ public void testAbsentJsonElementsAreSetToNull() {
     assertFalse(target.bool2); // test the default value of a primitive boolean field per JVM spec
   }
 
-  public static class ClassWithInitializedMembers  {
+  public static class ClassWithInitializedMembers {
     // Using a mix of no-args constructor and field initializers
     // Also, some fields are intialized and some are not (so initialized per JVM spec)
     public static final String MY_STRING_DEFAULT = "string";
@@ -204,7 +204,7 @@ public void testExplicitNullSetsFieldToNullDuringDeserialization() {
     Gson gson = new Gson();
     String json = "{value:null}";
     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class);
-    assertNull(obj.value);    
+    assertNull(obj.value);
   }
 
   public void testCustomTypeAdapterPassesNullSerialization() {
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index de1219a6a..48508f83b 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -33,6 +33,7 @@
 import com.google.gson.common.TestTypes.ClassWithTransientFields;
 import com.google.gson.common.TestTypes.Nested;
 import com.google.gson.common.TestTypes.PrimitiveArray;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -43,6 +44,7 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
+
 import junit.framework.TestCase;
 
 /**
@@ -482,7 +484,11 @@ public void testSingletonLists() {
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
     a.map.put("date", new Date(0));
-    assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    if (JavaVersion.isJava9OrLater()) {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969, 4:00:00 PM\"}}", gson.toJson(a));
+    } else {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    }
   }
 
   public class HasObjectMap {
diff --git a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
index 190603deb..85239c096 100644
--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
@@ -472,11 +472,11 @@ public boolean equals(Object obj) {
     @SuppressWarnings("unused")
     int q2 = 20;
   }
-  private interface Measurable<T> {    
+  private interface Measurable<T> {
   }
-  private interface Field<T> {    
+  private interface Field<T> {
   }
-  private interface Immutable {    
+  private interface Immutable {
   }
   
   public static final class Amount<Q extends Quantity> 
@@ -490,12 +490,12 @@ public void testDeepParameterizedTypeSerialization() {
     Amount<MyQuantity> amount = new Amount<MyQuantity>();
     String json = gson.toJson(amount);
     assertTrue(json.contains("value"));
-    assertTrue(json.contains("30"));    
+    assertTrue(json.contains("30"));
   }
   
   public void testDeepParameterizedTypeDeserialization() {
     String json = "{value:30}";
-    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();    
+    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();
     Amount<MyQuantity> amount = gson.fromJson(json, type);
     assertEquals(30, amount.value);
   }
diff --git a/gson/src/test/java/com/google/gson/functional/VersioningTest.java b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
index bc526de06..2416fc06d 100644
--- a/gson/src/test/java/com/google/gson/functional/VersioningTest.java
+++ b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
@@ -88,7 +88,7 @@ public void testIgnoreLaterVersionClassSerialization() {
   public void testIgnoreLaterVersionClassDeserialization() {
     Gson gson = builder.setVersion(1.0).create();
     String json = "{\"a\":3,\"b\":4,\"c\":5,\"d\":6}";
-    Version1_2 version1_2  = gson.fromJson(json, Version1_2.class);
+    Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);
     // Since the class is versioned to be after 1.0, we expect null
     // This is the new behavior in Gson 2.0
     assertNull(version1_2);
diff --git a/gson/src/test/java/com/google/gson/internal/GsonBuildConfigTest.java b/gson/src/test/java/com/google/gson/internal/GsonBuildConfigTest.java
new file mode 100644
index 000000000..dc39bc02d
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/GsonBuildConfigTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import static org.junit.Assert.assertFalse;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@code GsonBuildConfig}
+ *
+ * @author Inderjeet Singh
+ */
+public class GsonBuildConfigTest {
+
+  @Test
+  public void testEnsureGsonBuildConfigGetsUpdatedToMavenVersion() {
+    assertFalse("${project.version}".equals(GsonBuildConfig.VERSION));
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java b/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
new file mode 100644
index 000000000..4768c2dbc
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.google.gson.internal.JavaVersion;
+
+/**
+ * Unit and functional tests for {@link JavaVersion}
+ *
+ * @author Inderjeet Singh
+ */
+public class JavaVersionTest {
+  // Borrowed some of test strings from https://github.com/prestodb/presto/blob/master/presto-main/src/test/java/com/facebook/presto/server/TestJavaVersion.java
+
+  @Test
+  public void testGetMajorJavaVersion() {
+    JavaVersion.getMajorJavaVersion();
+  }
+
+  @Test
+  public void testJava6() {
+    assertEquals(6, JavaVersion.getMajorJavaVersion("1.6.0")); // http://www.oracle.com/technetwork/java/javase/version-6-141920.html
+  }
+
+  @Test
+  public void testJava7() {
+    assertEquals(7, JavaVersion.getMajorJavaVersion("1.7.0")); // http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html
+  }
+
+  @Test
+  public void testJava8() {
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8"));
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0"));
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_131"));
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_60-ea"));
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_111-internal"));
+
+    // openjdk8 per https://github.com/AdoptOpenJDK/openjdk-build/issues/93
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0-internal"));
+    assertEquals(8, JavaVersion.getMajorJavaVersion("1.8.0_131-adoptopenjdk"));
+  }
+
+  @Test
+  public void testJava9() {
+    // Legacy style
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9.0.4")); // Oracle JDK 9
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9-Debian")); // Debian as reported in https://github.com/google/gson/issues/1310
+    // New style
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9-ea+19"));
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9+100"));
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9.0.1+20"));
+    assertEquals(9, JavaVersion.getMajorJavaVersion("9.1.1+20"));
+  }
+
+  @Test
+  public void testJava10() {
+    assertEquals(10, JavaVersion.getMajorJavaVersion("10.0.1")); // Oracle JDK 10.0.1
+  }
+
+  @Test
+  public void testUnknownVersionFormat() {
+    assertEquals(6, JavaVersion.getMajorJavaVersion("Java9")); // unknown format
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
index 431fc83dd..9e1807899 100644
--- a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
+++ b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
@@ -33,7 +33,7 @@
   }
 
   /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
    * to instantiate an interface
    */
   public void testInterfaceInstantiation() {
@@ -47,7 +47,7 @@ public void testInterfaceInstantiation() {
   }
 
   /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
    * to instantiate an abstract class
    */
   public void testAbstractClassInstantiation() {
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
index aaa577b53..0f7c428d0 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -45,14 +45,16 @@
   /**
    * Test simplest case of recursion.
    */
+
   public void testRecursiveResolveSimple() {
     TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);
     assertNotNull(adapter);
   }
 
-  //
-  // Real-world samples, found in Issues #603 and #440.
-  //
+  /**
+   * Real-world samples, found in Issues #603 and #440.
+   */
+
   public void testIssue603PrintStream() {
     TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);
     assertNotNull(adapter);
@@ -63,9 +65,9 @@ public void testIssue440WeakReference() throws Exception {
     assertNotNull(adapter);
   }
 
-  //
-  // Tests belows check the behaviour of the methods changed for the fix
-  //
+  /**
+   * Tests belows check the behaviour of the methods changed for the fix.
+   */
 
   public void testDoubleSupertype() {
     assertEquals($Gson$Types.supertypeOf(Number.class),
@@ -87,9 +89,9 @@ public void testSubSupertype() {
             $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));
   }
 
-  //
-  // tests for recursion while resolving type variables
-  //
+  /**
+   * Tests for recursion while resolving type variables.
+   */
 
   private static class TestType<X> {
     TestType<? super X> superType;
diff --git a/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java b/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
new file mode 100644
index 000000000..d5caaf537
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Field;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link UnsafeReflectionAccessor}
+ *
+ * @author Inderjeet Singh
+ */
+public class UnsafeReflectionAccessorTest {
+
+  @Test
+  public void testMakeAccessibleWithUnsafe() throws Exception {
+    UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+    Field field = ClassWithPrivateFinalFields.class.getDeclaredField("a");
+    try {
+      boolean success = accessor.makeAccessibleWithUnsafe(field);
+      assertTrue(success);
+    } catch (Exception e) {
+      fail("Unsafe didn't work on the JDK");
+    }
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ClassWithPrivateFinalFields {
+    private final String a;
+    public ClassWithPrivateFinalFields(String a) {
+      this.a = a;
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
index cf444eee7..d05cf4be1 100644
--- a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
+++ b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
@@ -50,11 +50,11 @@ protected void setUp() throws Exception {
     gson = new Gson();
   }
   
-  public void testDummy() {    
+  public void testDummy() {
     // This is here to prevent Junit for complaining when we disable all tests.
-  }  
+  }
 
-  public void disabled_testStringDeserialization() {    
+  public void disabled_testStringDeserialization() {
     StringBuilder sb = new StringBuilder(8096);
     sb.append("Error Yippie");
 
@@ -138,8 +138,8 @@ public void disabled_testLargeCollectionDeserialization() {
     }    
     sb.append(']');
     String json = sb.toString();
-    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();    
-    List<CollectionEntry> list = gson.fromJson(json, collectionType);       
+    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();
+    List<CollectionEntry> list = gson.fromJson(json, collectionType);
     assertEquals(count, list.size());
   }
 
@@ -203,7 +203,7 @@ public void disabled_testSerializeClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Serialize classes avg time: %d ms\n", avg);     
+    System.out.printf("Serialize classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testDeserializeClasses() {
@@ -215,7 +215,7 @@ public void disabled_testDeserializeClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Deserialize classes avg time: %d ms\n", avg);     
+    System.out.printf("Deserialize classes avg time: %d ms\n", avg);
   }
   
   public void disable_testLargeObjectSerializationAndDeserialization() {
@@ -249,7 +249,7 @@ public void disabled_testSerializeExposedClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Serialize exposed classes avg time: %d ms\n", avg);     
+    System.out.printf("Serialize exposed classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testDeserializeExposedClasses() {
@@ -261,7 +261,7 @@ public void disabled_testDeserializeExposedClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Deserialize exposed classes avg time: %d ms\n", avg);     
+    System.out.printf("Deserialize exposed classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testLargeGsonMapRoundTrip() throws Exception {
@@ -343,4 +343,4 @@ public ClassWithField(String field) {
       this.field = field; 
     } 
   }
-}
+}
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 9d3eeaaf7..8814acb87 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.8.2-SNAPSHOT</version>
+  <version>2.8.6-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>
@@ -63,16 +63,34 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.8.0</version>
+          <executions>
+            <execution>
+              <id>default-compile</id>
+              <configuration>
+                <release>9</release>
+              </configuration>
+            </execution>
+            <execution>
+              <id>base-compile</id>
+              <goals>
+                <goal>compile</goal>
+              </goals>
+              <configuration>
+                <excludes>
+                  <exclude>module-info.java</exclude>
+                </excludes>
+              </configuration>
+            </execution>
+          </executions>
           <configuration>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
+            <release>6</release>
           </configuration>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.3</version>
+          <version>2.10.4</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
@@ -81,7 +99,7 @@
         <plugin>
           <groupId>org.apache.felix</groupId>
           <artifactId>maven-bundle-plugin</artifactId>
-          <version>3.2.0</version>
+          <version>3.3.0</version>
           <inherited>true</inherited>
         </plugin>
       </plugins>
@@ -90,12 +108,12 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.4.2</version>
+        <version>2.5.3</version>
         <dependencies>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9</version>
+            <version>1.9.5</version>
           </dependency>
         </dependencies>
         <configuration>
diff --git a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
index 5570edc98..c378685c8 100644
--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Converter;
 import com.google.common.collect.MapMaker;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonDeserializationContext;
@@ -35,8 +34,8 @@
 import com.google.protobuf.Descriptors.EnumDescriptor;
 import com.google.protobuf.Descriptors.EnumValueDescriptor;
 import com.google.protobuf.Descriptors.FieldDescriptor;
+import com.google.protobuf.DynamicMessage;
 import com.google.protobuf.Extension;
-import com.google.protobuf.GeneratedMessage;
 import com.google.protobuf.Message;
 
 import java.lang.reflect.Field;
@@ -73,7 +72,7 @@
  * @author Stanley Wang
  */
 public class ProtoTypeAdapter
-    implements JsonSerializer<GeneratedMessage>, JsonDeserializer<GeneratedMessage> {
+    implements JsonSerializer<Message>, JsonDeserializer<Message> {
   /**
    * Determines how enum <u>values</u> should be serialized.
    */
@@ -94,7 +93,8 @@
     private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
     private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
     private EnumSerialization enumSerialization;
-    private Converter<String, String> fieldNameSerializationFormat;
+    private CaseFormat protoFormat;
+    private CaseFormat jsonFormat;
 
     private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
@@ -126,7 +126,8 @@ public Builder setEnumSerialization(EnumSerialization enumSerialization) {
      */
     public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
-      fieldNameSerializationFormat = fromFieldNameFormat.converterTo(toFieldNameFormat);
+      this.protoFormat = fromFieldNameFormat;
+      this.jsonFormat = toFieldNameFormat;
       return this;
     }
 
@@ -174,7 +175,7 @@ public Builder addSerializedEnumValueExtension(
     }
 
     public ProtoTypeAdapter build() {
-      return new ProtoTypeAdapter(enumSerialization, fieldNameSerializationFormat,
+      return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat,
           serializedNameExtensions, serializedEnumValueExtensions);
     }
   }
@@ -195,22 +196,25 @@ public static Builder newBuilder() {
       new MapMaker().makeMap();
 
   private final EnumSerialization enumSerialization;
-  private final Converter<String, String> fieldNameSerializationFormat;
+  private final CaseFormat protoFormat;
+  private final CaseFormat jsonFormat;
   private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
   private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
 
   private ProtoTypeAdapter(EnumSerialization enumSerialization,
-      Converter<String, String> fieldNameSerializationFormat,
+      CaseFormat protoFormat,
+      CaseFormat jsonFormat,
       Set<Extension<FieldOptions, String>> serializedNameExtensions,
       Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {
     this.enumSerialization = enumSerialization;
-    this.fieldNameSerializationFormat = fieldNameSerializationFormat;
+    this.protoFormat = protoFormat;
+    this.jsonFormat = jsonFormat;
     this.serializedNameExtensions = serializedNameExtensions;
     this.serializedEnumValueExtensions = serializedEnumValueExtensions;
   }
 
   @Override
-  public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
+  public JsonElement serialize(Message src, Type typeOfSrc,
       JsonSerializationContext context) {
     JsonObject ret = new JsonObject();
     final Map<FieldDescriptor, Object> fields = src.getAllFields();
@@ -243,17 +247,24 @@ public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
   }
 
   @Override
-  public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
+  public Message deserialize(JsonElement json, Type typeOfT,
       JsonDeserializationContext context) throws JsonParseException {
     try {
       JsonObject jsonObject = json.getAsJsonObject();
       @SuppressWarnings("unchecked")
-      Class<? extends GeneratedMessage> protoClass = (Class<? extends GeneratedMessage>) typeOfT;
+      Class<? extends Message> protoClass = (Class<? extends Message>) typeOfT;
+
+      if (DynamicMessage.class.isAssignableFrom(protoClass)) {
+        throw new IllegalStateException("only generated messages are supported");
+      }
 
       try {
         // Invoke the ProtoClass.newBuilder() method
-        GeneratedMessage.Builder<?> protoBuilder =
-            (GeneratedMessage.Builder<?>) getCachedMethod(protoClass, "newBuilder").invoke(null);
+        Message.Builder protoBuilder =
+            (Message.Builder) getCachedMethod(protoClass, "newBuilder").invoke(null);
+
+        Message defaultInstance =
+            (Message) getCachedMethod(protoClass, "getDefaultInstance").invoke(null);
 
         Descriptor protoDescriptor =
             (Descriptor) getCachedMethod(protoClass, "getDescriptor").invoke(null);
@@ -284,21 +295,21 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else if (fieldDescriptor.isRepeated()) {
               // If the type is an array, then we have to grab the type from the class.
+              // protobuf java field names are always lower camel case
               String protoArrayFieldName =
-                  fieldNameSerializationFormat.convert(fieldDescriptor.getName()) + "_";
+                  protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + "_";
               Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);
               Type protoArrayFieldType = protoArrayField.getGenericType();
               fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else {
-              Message prototype = protoBuilder.build();
-              Object field = prototype.getField(fieldDescriptor);
+              Object field = defaultInstance.getField(fieldDescriptor);
               fieldValue = context.deserialize(jsonElement, field.getClass());
               protoBuilder.setField(fieldDescriptor, fieldValue);
             }
           }
         }
-        return (GeneratedMessage) protoBuilder.build();
+        return (Message) protoBuilder.build();
       } catch (SecurityException e) {
         throw new JsonParseException(e);
       } catch (NoSuchMethodException e) {
@@ -325,7 +336,7 @@ private String getCustSerializedName(FieldOptions options, String defaultName) {
         return options.getExtension(extension);
       }
     }
-    return fieldNameSerializationFormat.convert(defaultName);
+    return protoFormat.to(jsonFormat, defaultName);
   }
 
   /**
diff --git a/proto/src/main/protobuf/bag.proto b/proto/src/main/protobuf/bag.proto
index 26189a24f..48cc96397 100644
--- a/proto/src/main/protobuf/bag.proto
+++ b/proto/src/main/protobuf/bag.proto
@@ -24,6 +24,11 @@ message SimpleProto {
   optional int32 count = 2;
 }
 
+message ProtoWithDifferentCaseFormat {
+  repeated string name_that_tests_case_format = 1;
+  optional string another_field = 2;
+}
+
 message ProtoWithRepeatedFields {
   repeated int64 numbers = 1;
   repeated SimpleProto simples = 2;
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
index 964549d6b..b61d3f509 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
@@ -15,10 +15,13 @@
  */
 package com.google.gson.protobuf.functional;
 
+import com.google.common.base.CaseFormat;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
 import com.google.gson.protobuf.ProtoTypeAdapter;
 import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
+import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
 import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
 import com.google.protobuf.GeneratedMessage;
@@ -32,6 +35,7 @@
  */
 public class ProtosWithComplexAndRepeatedFieldsTest extends TestCase {
   private Gson gson;
+  private Gson upperCamelGson;
 
   @Override
   protected void setUp() throws Exception {
@@ -43,6 +47,14 @@ protected void setUp() throws Exception {
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
             .create();
+    upperCamelGson =
+        new GsonBuilder()
+            .registerTypeHierarchyAdapter(
+                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+                    .setFieldNameSerializationFormat(
+                        CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
+                    .build())
+            .create();
   }
 
   public void testSerializeRepeatedFields() {
@@ -67,4 +79,23 @@ public void testDeserializeRepeatedFieldsProto() {
     assertEquals("bar", proto.getSimples(0).getMsg());
     assertEquals(7, proto.getSimples(1).getCount());
   }
+
+  public void testSerializeDifferentCaseFormat() {
+    final ProtoWithDifferentCaseFormat proto =
+      ProtoWithDifferentCaseFormat.newBuilder()
+        .setAnotherField("foo")
+        .addNameThatTestsCaseFormat("bar")
+        .build();
+    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
+    assertEquals("foo", json.get("AnotherField").getAsString());
+    assertEquals("bar", json.get("NameThatTestsCaseFormat").getAsJsonArray().get(0).getAsString());
+  }
+
+  public void testDeserializeDifferentCaseFormat() {
+    final String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
+    ProtoWithDifferentCaseFormat proto =
+      upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
+    assertEquals("foo", proto.getAnotherField());
+    assertEquals("bar", proto.getNameThatTestsCaseFormat(0));
+  }
 }
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 000000000..975ec9b39
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':gson'
