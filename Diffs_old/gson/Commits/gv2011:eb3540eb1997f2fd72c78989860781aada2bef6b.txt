diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonElement.java b/src/main/java/com/github/gv2011/jsoncore/JsonElement.java
index 5f07a556c..04a51be4c 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonElement.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonElement.java
@@ -20,8 +20,7 @@
 import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-
-import com.github.gv2011.jsoncore.imp.Streams;
+import java.util.Map;
 
 /**
  * A class representing an element of Json. It could either be a {@link JsonObject}, a
@@ -318,13 +317,47 @@ public short getAsShort() {
   @Override
   public String toString() {
     try {
-      StringWriter stringWriter = new StringWriter();
-      JsonWriter jsonWriter = new JsonWriter(stringWriter);
+      final StringWriter stringWriter = new StringWriter();
+      final JsonWriter jsonWriter = new JsonWriter(stringWriter);
       jsonWriter.setLenient(true);
-      Streams.write(this, jsonWriter);
+      write(jsonWriter, this);
       return stringWriter.toString();
-    } catch (IOException e) {
+    } catch (final IOException e) {
       throw new AssertionError(e);
     }
   }
+
+  private void write(final JsonWriter out, final JsonElement value) throws IOException {
+    if (value == null || value.isJsonNull()) {
+      out.nullValue();
+    } else if (value.isJsonPrimitive()) {
+      final JsonPrimitive primitive = value.getAsJsonPrimitive();
+      if (primitive.isNumber()) {
+        out.value(primitive.getAsNumber());
+      } else if (primitive.isBoolean()) {
+        out.value(primitive.getAsBoolean());
+      } else {
+        out.value(primitive.getAsString());
+      }
+
+    } else if (value.isJsonArray()) {
+      out.beginArray();
+      for (final JsonElement e : value.getAsJsonArray()) {
+        write(out, e);
+      }
+      out.endArray();
+
+    } else if (value.isJsonObject()) {
+      out.beginObject();
+      for (final Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
+        out.name(e.getKey());
+        write(out, e.getValue());
+      }
+      out.endObject();
+
+    } else {
+      throw new IllegalArgumentException("Couldn't write " + value.getClass());
+    }
+  }
+
 }
diff --git a/src/main/java/com/google/gson/JsonIOException.java b/src/main/java/com/github/gv2011/jsoncore/JsonIOException.java
similarity index 97%
rename from src/main/java/com/google/gson/JsonIOException.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonIOException.java
index dfeccd8ed..34c5c03dd 100644
--- a/src/main/java/com/google/gson/JsonIOException.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonIOException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.github.gv2011.jsoncore;
 
 /**
  * This exception is raised when Gson was unable to read an input stream
diff --git a/src/main/java/com/google/gson/JsonParseException.java b/src/main/java/com/github/gv2011/jsoncore/JsonParseException.java
similarity index 98%
rename from src/main/java/com/google/gson/JsonParseException.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonParseException.java
index 084f66127..7b22b3739 100644
--- a/src/main/java/com/google/gson/JsonParseException.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonParseException.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.github.gv2011.jsoncore;
 
 /**
  * This exception is raised if there is a serious issue that occurs during parsing of a Json
diff --git a/src/main/java/com/google/gson/JsonSyntaxException.java b/src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java
similarity index 97%
rename from src/main/java/com/google/gson/JsonSyntaxException.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java
index 17c1d3d3a..e2ec62af5 100644
--- a/src/main/java/com/google/gson/JsonSyntaxException.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.github.gv2011.jsoncore;
 
 /**
  * This exception is raised when Gson attempts to read (or write) a malformed
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/JsonElementTypeAdapter.java b/src/main/java/com/github/gv2011/jsoncore/imp/JsonElementTypeAdapter.java
new file mode 100644
index 000000000..d40ab7f87
--- /dev/null
+++ b/src/main/java/com/github/gv2011/jsoncore/imp/JsonElementTypeAdapter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.jsoncore.imp;
+
+import java.io.IOException;
+import java.util.Map;
+
+import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonPrimitive;
+import com.github.gv2011.jsoncore.JsonWriter;
+
+/**
+ * Type adapters for basic types.
+ */
+public final class JsonElementTypeAdapter {
+
+  public static final JsonElementTypeAdapter JSON_ELEMENT = new JsonElementTypeAdapter();
+
+  public void write(final JsonWriter out, final JsonElement value) throws IOException {
+    if (value == null || value.isJsonNull()) {
+      out.nullValue();
+    } else if (value.isJsonPrimitive()) {
+      final JsonPrimitive primitive = value.getAsJsonPrimitive();
+      if (primitive.isNumber()) {
+        out.value(primitive.getAsNumber());
+      } else if (primitive.isBoolean()) {
+        out.value(primitive.getAsBoolean());
+      } else {
+        out.value(primitive.getAsString());
+      }
+
+    } else if (value.isJsonArray()) {
+      out.beginArray();
+      for (final JsonElement e : value.getAsJsonArray()) {
+        write(out, e);
+      }
+      out.endArray();
+
+    } else if (value.isJsonObject()) {
+      out.beginObject();
+      for (final Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
+        out.name(e.getKey());
+        write(out, e.getValue());
+      }
+      out.endObject();
+
+    } else {
+      throw new IllegalArgumentException("Couldn't write " + value.getClass());
+    }
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/Streams.java b/src/main/java/com/github/gv2011/jsoncore/imp/Streams.java
deleted file mode 100644
index e6dda7225..000000000
--- a/src/main/java/com/github/gv2011/jsoncore/imp/Streams.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import com.github.gv2011.jsoncore.JsonElement;
-import com.github.gv2011.jsoncore.JsonNull;
-import com.github.gv2011.jsoncore.JsonReader;
-import com.github.gv2011.jsoncore.JsonWriter;
-import com.github.gv2011.jsoncore.MalformedJsonException;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.internal.bind.TypeAdapters;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.Writer;
-
-/**
- * Reads and writes GSON parse trees over streams.
- */
-public final class Streams {
-  private Streams() {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * Takes a reader in any state and returns the next value as a JsonElement.
-   */
-  public static JsonElement parse(JsonReader reader) throws JsonParseException {
-    boolean isEmpty = true;
-    try {
-      reader.peek();
-      isEmpty = false;
-      return TypeAdapters.JSON_ELEMENT.read(reader);
-    } catch (EOFException e) {
-      /*
-       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for
-       * empty documents instead of throwing.
-       */
-      if (isEmpty) {
-        return JsonNull.INSTANCE;
-      }
-      // The stream ended prematurely so it is likely a syntax error.
-      throw new JsonSyntaxException(e);
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (NumberFormatException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-
-  /**
-   * Writes the JSON element to the writer, recursively.
-   */
-  public static void write(JsonElement element, JsonWriter writer) throws IOException {
-    TypeAdapters.JSON_ELEMENT.write(writer, element);
-  }
-
-  @SuppressWarnings("resource")
-  public static Writer writerForAppendable(Appendable appendable) {
-    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
-  }
-
-  /**
-   * Adapts an {@link Appendable} so it can be passed anywhere a {@link Writer}
-   * is used.
-   */
-  private static final class AppendableWriter extends Writer {
-    private final Appendable appendable;
-    private final CurrentWrite currentWrite = new CurrentWrite();
-
-    AppendableWriter(Appendable appendable) {
-      this.appendable = appendable;
-    }
-
-    @Override public void write(char[] chars, int offset, int length) throws IOException {
-      currentWrite.chars = chars;
-      appendable.append(currentWrite, offset, offset + length);
-    }
-
-    @Override public void write(int i) throws IOException {
-      appendable.append((char) i);
-    }
-
-    @Override public void flush() {}
-    @Override public void close() {}
-
-    /**
-     * A mutable char sequence pointing at a single char[].
-     */
-    static class CurrentWrite implements CharSequence {
-      char[] chars;
-      public int length() {
-        return chars.length;
-      }
-      public char charAt(int i) {
-        return chars[i];
-      }
-      public CharSequence subSequence(int start, int end) {
-        return new String(chars, start, end - start);
-      }
-    }
-  }
-
-}
diff --git a/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 9e361f3ad..8f7321742 100644
--- a/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -27,7 +27,9 @@
 import java.util.TimeZone;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 
 /**
diff --git a/src/main/java/com/google/gson/Gson.java b/src/main/java/com/google/gson/Gson.java
index dedde21ab..532a45cfe 100644
--- a/src/main/java/com/google/gson/Gson.java
+++ b/src/main/java/com/google/gson/Gson.java
@@ -35,13 +35,17 @@
 import java.util.concurrent.atomic.AtomicLongArray;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonIOException;
 import com.github.gv2011.jsoncore.JsonNull;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.github.gv2011.jsoncore.imp.JsonTreeReader;
 import com.github.gv2011.jsoncore.imp.Streams;
+import com.github.gv2011.jsoncore.imp.TypeAdapters;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -55,7 +59,6 @@
 import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
 import com.google.gson.internal.bind.SqlDateTypeAdapter;
 import com.google.gson.internal.bind.TimeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 
 /**
diff --git a/src/main/java/com/google/gson/GsonBuilder.java b/src/main/java/com/google/gson/GsonBuilder.java
index f8e0d6b7a..0fc09cc91 100644
--- a/src/main/java/com/google/gson/GsonBuilder.java
+++ b/src/main/java/com/google/gson/GsonBuilder.java
@@ -29,9 +29,9 @@
 import com.github.gv2011.jsoncore.JsonObject;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.imp.Preconditions;
+import com.github.gv2011.jsoncore.imp.TypeAdapters;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.bind.TreeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 
 import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
diff --git a/src/main/java/com/google/gson/JsonDeserializationContext.java b/src/main/java/com/google/gson/JsonDeserializationContext.java
index e73f06cb6..2c27cad68 100644
--- a/src/main/java/com/google/gson/JsonDeserializationContext.java
+++ b/src/main/java/com/google/gson/JsonDeserializationContext.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Type;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 
 /**
  * Context for deserialization that is passed to a custom deserializer during invocation of its
diff --git a/src/main/java/com/google/gson/JsonDeserializer.java b/src/main/java/com/google/gson/JsonDeserializer.java
index 8d13325f7..5590bdea5 100644
--- a/src/main/java/com/google/gson/JsonDeserializer.java
+++ b/src/main/java/com/google/gson/JsonDeserializer.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Type;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 
 /**
  * <p>Interface representing a custom deserializer for Json. You should write a custom
diff --git a/src/main/java/com/google/gson/JsonParser.java b/src/main/java/com/google/gson/JsonParser.java
index 9cb4f8d3d..bdd9af4e6 100755
--- a/src/main/java/com/google/gson/JsonParser.java
+++ b/src/main/java/com/google/gson/JsonParser.java
@@ -20,7 +20,10 @@
 import java.io.StringReader;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonIOException;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.github.gv2011.jsoncore.imp.Streams;
diff --git a/src/main/java/com/google/gson/JsonStreamParser.java b/src/main/java/com/google/gson/JsonStreamParser.java
index b46a43728..b3644e10c 100644
--- a/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/src/main/java/com/google/gson/JsonStreamParser.java
@@ -23,7 +23,10 @@
 import java.util.NoSuchElementException;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonIOException;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.github.gv2011.jsoncore.imp.Streams;
diff --git a/src/main/java/com/google/gson/TypeAdapter.java b/src/main/java/com/google/gson/TypeAdapter.java
index 74fc38535..1260f26f4 100644
--- a/src/main/java/com/google/gson/TypeAdapter.java
+++ b/src/main/java/com/google/gson/TypeAdapter.java
@@ -18,6 +18,7 @@
 
 import com.google.gson.internal.bind.JsonTreeWriter;
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonIOException;
 import com.github.gv2011.jsoncore.JsonNull;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonToken;
diff --git a/src/main/java/com/google/gson/internal/$Gson$Types.java b/src/main/java/com/google/gson/internal/$Gson$Types.java
deleted file mode 100644
index 7e7dce047..000000000
--- a/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ /dev/null
@@ -1,588 +0,0 @@
-/**
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import static com.github.gv2011.jsoncore.imp.Preconditions.checkArgument;
-import static com.github.gv2011.jsoncore.imp.Preconditions.checkNotNull;
-
-import java.io.Serializable;
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Properties;
-
-/**
- * Static methods for working with types.
- *
- * @author Bob Lee
- * @author Jesse Wilson
- */
-public final class $Gson$Types {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
-
-  private $Gson$Types() {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * Returns a new parameterized type, applying {@code typeArguments} to
-   * {@code rawType} and enclosed by {@code ownerType}.
-   *
-   * @return a {@link java.io.Serializable serializable} parameterized type.
-   */
-  public static ParameterizedType newParameterizedTypeWithOwner(
-      Type ownerType, Type rawType, Type... typeArguments) {
-    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
-  }
-
-  /**
-   * Returns an array type whose elements are all instances of
-   * {@code componentType}.
-   *
-   * @return a {@link java.io.Serializable serializable} generic array type.
-   */
-  public static GenericArrayType arrayOf(Type componentType) {
-    return new GenericArrayTypeImpl(componentType);
-  }
-
-  /**
-   * Returns a type that represents an unknown type that extends {@code bound}.
-   * For example, if {@code bound} is {@code CharSequence.class}, this returns
-   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
-   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.
-   */
-  public static WildcardType subtypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);
-  }
-
-  /**
-   * Returns a type that represents an unknown supertype of {@code bound}. For
-   * example, if {@code bound} is {@code String.class}, this returns {@code ?
-   * super String}.
-   */
-  public static WildcardType supertypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });
-  }
-
-  /**
-   * Returns a type that is functionally equal but not necessarily equal
-   * according to {@link Object#equals(Object) Object.equals()}. The returned
-   * type is {@link java.io.Serializable}.
-   */
-  public static Type canonicalize(Type type) {
-    if (type instanceof Class) {
-      Class<?> c = (Class<?>) type;
-      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType p = (ParameterizedType) type;
-      return new ParameterizedTypeImpl(p.getOwnerType(),
-          p.getRawType(), p.getActualTypeArguments());
-
-    } else if (type instanceof GenericArrayType) {
-      GenericArrayType g = (GenericArrayType) type;
-      return new GenericArrayTypeImpl(g.getGenericComponentType());
-
-    } else if (type instanceof WildcardType) {
-      WildcardType w = (WildcardType) type;
-      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
-
-    } else {
-      // type is either serializable as-is or unsupported
-      return type;
-    }
-  }
-
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class.
-      // Neal isn't either but suspects some pathological case related
-      // to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      checkArgument(rawType instanceof Class);
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType)type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // we could use the variable's bounds, but that won't work if there are multiple.
-      // having a raw type that's more general than necessary is okay
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
-  static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Returns true if {@code a} and {@code b} are equal.
-   */
-  public static boolean equals(Type a, Type b) {
-    if (a == b) {
-      // also handles (a == null && b == null)
-      return true;
-
-    } else if (a instanceof Class) {
-      // Class already specifies equals().
-      return a.equals(b);
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) {
-        return false;
-      }
-
-      // TODO: save a .clone() call
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) {
-        return false;
-      }
-
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) {
-        return false;
-      }
-
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) {
-        return false;
-      }
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      // This isn't a type we support. Could be a generic array type, wildcard type, etc.
-      return false;
-    }
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  public static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) {
-      return context;
-    }
-
-    // we skip searching through interfaces if unknown is an interface
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
-    }
-
-    // check our supertypes
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
-
-    // we can't resolve this further
-    return toResolve;
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    checkArgument(supertype.isAssignableFrom(contextRawType));
-    return resolve(context, contextRawType,
-        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  /**
-   * Returns the component type of this array type.
-   * @throws ClassCastException if this type is not an array.
-   */
-  public static Type getArrayComponentType(Type array) {
-    return array instanceof GenericArrayType
-        ? ((GenericArrayType) array).getGenericComponentType()
-        : ((Class<?>) array).getComponentType();
-  }
-
-  /**
-   * Returns the element type of this collection type.
-   * @throws IllegalArgumentException if this type is not a collection.
-   */
-  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {
-    Type collectionType = getSupertype(context, contextRawType, Collection.class);
-
-    if (collectionType instanceof WildcardType) {
-      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];
-    }
-    if (collectionType instanceof ParameterizedType) {
-      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];
-    }
-    return Object.class;
-  }
-
-  /**
-   * Returns a two element array containing this map's key and value types in
-   * positions 0 and 1 respectively.
-   */
-  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {
-    /*
-     * Work around a problem with the declaration of java.util.Properties. That
-     * class should extend Hashtable<String, String>, but it's declared to
-     * extend Hashtable<Object, Object>.
-     */
-    if (context == Properties.class) {
-      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!
-    }
-
-    Type mapType = getSupertype(context, contextRawType, Map.class);
-    // TODO: strip wildcards?
-    if (mapType instanceof ParameterizedType) {
-      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;
-      return mapParameterizedType.getActualTypeArguments();
-    }
-    return new Type[] { Object.class, Object.class };
-  }
-
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // this implementation is made a little more complicated in an attempt to avoid object-creation
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType
-            ? original
-            : arrayOf(newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType
-            ? original
-            : arrayOf(newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
-        }
-
-        return changed
-            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
-            : original;
-
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
-
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return supertypeOf(lowerBound);
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return subtypeOf(upperBound);
-          }
-        }
-        return original;
-
-      } else {
-        return toResolve;
-      }
-    }
-  }
-
-  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // we can't reduce this further
-    if (declaredByRaw == null) {
-      return unknown;
-    }
-
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
-
-    return unknown;
-  }
-
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) {
-        return i;
-      }
-    }
-    throw new NoSuchElementException();
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class
-        ? (Class<?>) genericDeclaration
-        : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // require an owner type if the raw type needs it
-      if (rawType instanceof Class<?>) {
-        Class<?> rawTypeAsClass = (Class<?>) rawType;
-        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())
-            || rawTypeAsClass.getEnclosingClass() == null;
-        checkArgument(ownerType != null || isStaticOrTopLevelClass);
-      }
-
-      this.ownerType = ownerType == null ? null : canonicalize(ownerType);
-      this.rawType = canonicalize(rawType);
-      this.typeArguments = typeArguments.clone();
-      for (int t = 0; t < this.typeArguments.length; t++) {
-        checkNotNull(this.typeArguments[t]);
-        checkNotPrimitive(this.typeArguments[t]);
-        this.typeArguments[t] = canonicalize(this.typeArguments[t]);
-      }
-    }
-
-    public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
-    }
-
-    public Type getRawType() {
-      return rawType;
-    }
-
-    public Type getOwnerType() {
-      return ownerType;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType
-          && $Gson$Types.equals(this, (ParameterizedType) other);
-    }
-
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments)
-          ^ rawType.hashCode()
-          ^ hashCodeOrZero(ownerType);
-    }
-
-    @Override public String toString() {
-      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));
-      stringBuilder.append(typeToString(rawType));
-
-      if (typeArguments.length == 0) {
-        return stringBuilder.toString();
-      }
-
-      stringBuilder.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        stringBuilder.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return stringBuilder.append(">").toString();
-    }
-
-    private static final long serialVersionUID = 0;
-  }
-
-  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {
-    private final Type componentType;
-
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = canonicalize(componentType);
-    }
-
-    public Type getGenericComponentType() {
-      return componentType;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && $Gson$Types.equals(this, (GenericArrayType) o);
-    }
-
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
-
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-
-    private static final long serialVersionUID = 0;
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType, Serializable {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      checkArgument(lowerBounds.length <= 1);
-      checkArgument(upperBounds.length == 1);
-
-      if (lowerBounds.length == 1) {
-        checkNotNull(lowerBounds[0]);
-        checkNotPrimitive(lowerBounds[0]);
-        checkArgument(upperBounds[0] == Object.class);
-        this.lowerBound = canonicalize(lowerBounds[0]);
-        this.upperBound = Object.class;
-
-      } else {
-        checkNotNull(upperBounds[0]);
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = canonicalize(upperBounds[0]);
-      }
-    }
-
-    public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
-
-    public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType
-          && $Gson$Types.equals(this, (WildcardType) other);
-    }
-
-    @Override public int hashCode() {
-      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)
-          ^ (31 + upperBound.hashCode());
-    }
-
-    @Override public String toString() {
-      if (lowerBound != null) {
-        return "? super " + typeToString(lowerBound);
-      } else if (upperBound == Object.class) {
-        return "?";
-      } else {
-        return "? extends " + typeToString(upperBound);
-      }
-    }
-
-    private static final long serialVersionUID = 0;
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/src/main/java/com/google/gson/internal/ConstructorConstructor.java
deleted file mode 100644
index 7ffcf2855..000000000
--- a/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.SortedSet;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ConcurrentNavigableMap;
-import java.util.concurrent.ConcurrentSkipListMap;
-
-import com.github.gv2011.jsoncore.imp.LinkedTreeMap;
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonIOException;
-import com.google.gson.reflect.TypeToken;
-
-/**
- * Returns a function that can construct an instance of a requested type.
- */
-public final class ConstructorConstructor {
-  private final Map<Type, InstanceCreator<?>> instanceCreators;
-
-  public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
-    this.instanceCreators = instanceCreators;
-  }
-
-  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {
-    final Type type = typeToken.getType();
-    final Class<? super T> rawType = typeToken.getRawType();
-
-    // first try an instance creator
-
-    @SuppressWarnings("unchecked") // types must agree
-    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
-    if (typeCreator != null) {
-      return new ObjectConstructor<T>() {
-        @Override public T construct() {
-          return typeCreator.createInstance(type);
-        }
-      };
-    }
-
-    // Next try raw type match for instance creators
-    @SuppressWarnings("unchecked") // types must agree
-    final InstanceCreator<T> rawTypeCreator =
-        (InstanceCreator<T>) instanceCreators.get(rawType);
-    if (rawTypeCreator != null) {
-      return new ObjectConstructor<T>() {
-        @Override public T construct() {
-          return rawTypeCreator.createInstance(type);
-        }
-      };
-    }
-
-    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);
-    if (defaultConstructor != null) {
-      return defaultConstructor;
-    }
-
-    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);
-    if (defaultImplementation != null) {
-      return defaultImplementation;
-    }
-
-    // finally try unsafe
-    return newUnsafeAllocator(type, rawType);
-  }
-
-  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {
-    try {
-      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
-      if (!constructor.isAccessible()) {
-        constructor.setAccessible(true);
-      }
-      return new ObjectConstructor<T>() {
-        @SuppressWarnings("unchecked") // T is the same raw type as is requested
-        @Override public T construct() {
-          try {
-            Object[] args = null;
-            return (T) constructor.newInstance(args);
-          } catch (InstantiationException e) {
-            // TODO: JsonParseException ?
-            throw new RuntimeException("Failed to invoke " + constructor + " with no args", e);
-          } catch (InvocationTargetException e) {
-            // TODO: don't wrap if cause is unchecked!
-            // TODO: JsonParseException ?
-            throw new RuntimeException("Failed to invoke " + constructor + " with no args",
-                e.getTargetException());
-          } catch (IllegalAccessException e) {
-            throw new AssertionError(e);
-          }
-        }
-      };
-    } catch (NoSuchMethodException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Constructors for common interface types like Map and List and their
-   * subtypes.
-   */
-  @SuppressWarnings("unchecked") // use runtime checks to guarantee that 'T' is what it is
-  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
-      final Type type, Class<? super T> rawType) {
-    if (Collection.class.isAssignableFrom(rawType)) {
-      if (SortedSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new TreeSet<Object>();
-          }
-        };
-      } else if (EnumSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @SuppressWarnings("rawtypes")
-          @Override public T construct() {
-            if (type instanceof ParameterizedType) {
-              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
-              if (elementType instanceof Class) {
-                return (T) EnumSet.noneOf((Class)elementType);
-              } else {
-                throw new JsonIOException("Invalid EnumSet type: " + type.toString());
-              }
-            } else {
-              throw new JsonIOException("Invalid EnumSet type: " + type.toString());
-            }
-          }
-        };
-      } else if (Set.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedHashSet<Object>();
-          }
-        };
-      } else if (Queue.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ArrayDeque<Object>();
-          }
-        };
-      } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ArrayList<Object>();
-          }
-        };
-      }
-    }
-
-    if (Map.class.isAssignableFrom(rawType)) {
-      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ConcurrentSkipListMap<Object, Object>();
-          }
-        };
-      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ConcurrentHashMap<Object, Object>();
-          }
-        };
-      } else if (SortedMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new TreeMap<Object, Object>();
-          }
-        };
-      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
-          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedHashMap<Object, Object>();
-          }
-        };
-      } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedTreeMap<String, Object>();
-          }
-        };
-      }
-    }
-
-    return null;
-  }
-
-  private <T> ObjectConstructor<T> newUnsafeAllocator(
-      final Type type, final Class<? super T> rawType) {
-    return new ObjectConstructor<T>() {
-      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
-      @SuppressWarnings("unchecked")
-      @Override public T construct() {
-        try {
-          Object newInstance = unsafeAllocator.newInstance(rawType);
-          return (T) newInstance;
-        } catch (Exception e) {
-          throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
-        }
-      }
-    };
-  }
-
-  @Override public String toString() {
-    return instanceCreators.toString();
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/Excluder.java b/src/main/java/com/google/gson/internal/Excluder.java
deleted file mode 100644
index 1356fc064..000000000
--- a/src/main/java/com/google/gson/internal/Excluder.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import com.github.gv2011.jsoncore.JsonReader;
-import com.github.gv2011.jsoncore.JsonWriter;
-import com.google.gson.ExclusionStrategy;
-import com.google.gson.FieldAttributes;
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.Expose;
-import com.google.gson.annotations.Since;
-import com.google.gson.annotations.Until;
-import com.google.gson.reflect.TypeToken;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * This class selects which fields and types to omit. It is configurable,
- * supporting version attributes {@link Since} and {@link Until}, modifiers,
- * synthetic fields, anonymous and local classes, inner classes, and fields with
- * the {@link Expose} annotation.
- *
- * <p>This class is a type adapter factory; types that are excluded will be
- * adapted to null. It may delegate to another type adapter if only one
- * direction is excluded.
- *
- * @author Joel Leitch
- * @author Jesse Wilson
- */
-public final class Excluder implements TypeAdapterFactory, Cloneable {
-  private static final double IGNORE_VERSIONS = -1.0d;
-  public static final Excluder DEFAULT = new Excluder();
-
-  private double version = IGNORE_VERSIONS;
-  private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;
-  private boolean serializeInnerClasses = true;
-  private boolean requireExpose;
-  private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();
-  private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();
-
-  @Override protected Excluder clone() {
-    try {
-      return (Excluder) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public Excluder withVersion(double ignoreVersionsAfter) {
-    Excluder result = clone();
-    result.version = ignoreVersionsAfter;
-    return result;
-  }
-
-  public Excluder withModifiers(int... modifiers) {
-    Excluder result = clone();
-    result.modifiers = 0;
-    for (int modifier : modifiers) {
-      result.modifiers |= modifier;
-    }
-    return result;
-  }
-
-  public Excluder disableInnerClassSerialization() {
-    Excluder result = clone();
-    result.serializeInnerClasses = false;
-    return result;
-  }
-
-  public Excluder excludeFieldsWithoutExposeAnnotation() {
-    Excluder result = clone();
-    result.requireExpose = true;
-    return result;
-  }
-
-  public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
-      boolean serialization, boolean deserialization) {
-    Excluder result = clone();
-    if (serialization) {
-      result.serializationStrategies = new ArrayList<ExclusionStrategy>(serializationStrategies);
-      result.serializationStrategies.add(exclusionStrategy);
-    }
-    if (deserialization) {
-      result.deserializationStrategies
-          = new ArrayList<ExclusionStrategy>(deserializationStrategies);
-      result.deserializationStrategies.add(exclusionStrategy);
-    }
-    return result;
-  }
-
-  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
-    Class<?> rawType = type.getRawType();
-    final boolean skipSerialize = excludeClass(rawType, true);
-    final boolean skipDeserialize = excludeClass(rawType, false);
-
-    if (!skipSerialize && !skipDeserialize) {
-      return null;
-    }
-
-    return new TypeAdapter<T>() {
-      /** The delegate is lazily created because it may not be needed, and creating it may fail. */
-      private TypeAdapter<T> delegate;
-
-      @Override public T read(JsonReader in) throws IOException {
-        if (skipDeserialize) {
-          in.skipValue();
-          return null;
-        }
-        return delegate().read(in);
-      }
-
-      @Override public void write(JsonWriter out, T value) throws IOException {
-        if (skipSerialize) {
-          out.nullValue();
-          return;
-        }
-        delegate().write(out, value);
-      }
-
-      private TypeAdapter<T> delegate() {
-        TypeAdapter<T> d = delegate;
-        return d != null
-            ? d
-            : (delegate = gson.getDelegateAdapter(Excluder.this, type));
-      }
-    };
-  }
-
-  public boolean excludeField(Field field, boolean serialize) {
-    if ((modifiers & field.getModifiers()) != 0) {
-      return true;
-    }
-
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (field.isSynthetic()) {
-      return true;
-    }
-
-    if (requireExpose) {
-      Expose annotation = field.getAnnotation(Expose.class);
-      if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {
-        return true;
-      }
-    }
-
-    if (!serializeInnerClasses && isInnerClass(field.getType())) {
-      return true;
-    }
-
-    if (isAnonymousOrLocal(field.getType())) {
-      return true;
-    }
-
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    if (!list.isEmpty()) {
-      FieldAttributes fieldAttributes = new FieldAttributes(field);
-      for (ExclusionStrategy exclusionStrategy : list) {
-        if (exclusionStrategy.shouldSkipField(fieldAttributes)) {
-          return true;
-        }
-      }
-    }
-
-    return false;
-  }
-
-  public boolean excludeClass(Class<?> clazz, boolean serialize) {
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (!serializeInnerClasses && isInnerClass(clazz)) {
-      return true;
-    }
-
-    if (isAnonymousOrLocal(clazz)) {
-      return true;
-    }
-
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    for (ExclusionStrategy exclusionStrategy : list) {
-      if (exclusionStrategy.shouldSkipClass(clazz)) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  private boolean isAnonymousOrLocal(Class<?> clazz) {
-    return !Enum.class.isAssignableFrom(clazz)
-        && (clazz.isAnonymousClass() || clazz.isLocalClass());
-  }
-
-  private boolean isInnerClass(Class<?> clazz) {
-    return clazz.isMemberClass() && !isStatic(clazz);
-  }
-
-  private boolean isStatic(Class<?> clazz) {
-    return (clazz.getModifiers() & Modifier.STATIC) != 0;
-  }
-
-  private boolean isValidVersion(Since since, Until until) {
-    return isValidSince(since) && isValidUntil(until);
-  }
-
-  private boolean isValidSince(Since annotation) {
-    if (annotation != null) {
-      double annotationVersion = annotation.value();
-      if (annotationVersion > version) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private boolean isValidUntil(Until annotation) {
-    if (annotation != null) {
-      double annotationVersion = annotation.value();
-      if (annotationVersion <= version) {
-        return false;
-      }
-    }
-    return true;
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java b/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
deleted file mode 100644
index b2707c50d..000000000
--- a/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
+++ /dev/null
@@ -1,864 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.util.AbstractMap;
-import java.util.AbstractSet;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-/**
- * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses
- * insertion order for iteration order. Comparison order is only used as an
- * optimization for efficient insertion and removal.
- *
- * <p>This implementation was derived from Android 4.1's TreeMap and
- * LinkedHashMap classes.
- */
-public final class LinkedHashTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
-  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
-    public int compare(Comparable a, Comparable b) {
-      return a.compareTo(b);
-    }
-  };
-
-  Comparator<? super K> comparator;
-  Node<K, V>[] table;
-  final Node<K, V> header;
-  int size = 0;
-  int modCount = 0;
-  int threshold;
-
-  /**
-   * Create a natural order, empty tree map whose keys must be mutually
-   * comparable and non-null.
-   */
-  @SuppressWarnings("unchecked") // unsafe! this assumes K is comparable
-  public LinkedHashTreeMap() {
-    this((Comparator<? super K>) NATURAL_ORDER);
-  }
-
-  /**
-   * Create a tree map ordered by {@code comparator}. This map's keys may only
-   * be null if {@code comparator} permits.
-   *
-   * @param comparator the comparator to order elements with, or {@code null} to
-   *     use the natural ordering.
-   */
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // unsafe! if comparator is null, this assumes K is comparable
-  public LinkedHashTreeMap(Comparator<? super K> comparator) {
-    this.comparator = comparator != null
-        ? comparator
-        : (Comparator) NATURAL_ORDER;
-    this.header = new Node<K, V>();
-    this.table = new Node[16]; // TODO: sizing/resizing policies
-    this.threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity
-  }
-
-  @Override public int size() {
-    return size;
-  }
-
-  @Override public V get(Object key) {
-    Node<K, V> node = findByObject(key);
-    return node != null ? node.value : null;
-  }
-
-  @Override public boolean containsKey(Object key) {
-    return findByObject(key) != null;
-  }
-
-  @Override public V put(K key, V value) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-    Node<K, V> created = find(key, true);
-    V result = created.value;
-    created.value = value;
-    return result;
-  }
-
-  @Override public void clear() {
-    Arrays.fill(table, null);
-    size = 0;
-    modCount++;
-
-    // Clear all links to help GC
-    Node<K, V> header = this.header;
-    for (Node<K, V> e = header.next; e != header; ) {
-      Node<K, V> next = e.next;
-      e.next = e.prev = null;
-      e = next;
-    }
-
-    header.next = header.prev = header;
-  }
-
-  @Override public V remove(Object key) {
-    Node<K, V> node = removeInternalByKey(key);
-    return node != null ? node.value : null;
-  }
-
-  /**
-   * Returns the node at or adjacent to the given key, creating it if requested.
-   *
-   * @throws ClassCastException if {@code key} and the tree's keys aren't
-   *     mutually comparable.
-   */
-  Node<K, V> find(K key, boolean create) {
-    Comparator<? super K> comparator = this.comparator;
-    Node<K, V>[] table = this.table;
-    int hash = secondaryHash(key.hashCode());
-    int index = hash & (table.length - 1);
-    Node<K, V> nearest = table[index];
-    int comparison = 0;
-
-    if (nearest != null) {
-      // Micro-optimization: avoid polymorphic calls to Comparator.compare().
-      @SuppressWarnings("unchecked") // Throws a ClassCastException below if there's trouble.
-      Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)
-          ? (Comparable<Object>) key
-          : null;
-
-      while (true) {
-        comparison = (comparableKey != null)
-            ? comparableKey.compareTo(nearest.key)
-            : comparator.compare(key, nearest.key);
-
-        // We found the requested key.
-        if (comparison == 0) {
-          return nearest;
-        }
-
-        // If it exists, the key is in a subtree. Go deeper.
-        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
-        if (child == null) {
-          break;
-        }
-
-        nearest = child;
-      }
-    }
-
-    // The key doesn't exist in this tree.
-    if (!create) {
-      return null;
-    }
-
-    // Create the node and add it to the tree or the table.
-    Node<K, V> header = this.header;
-    Node<K, V> created;
-    if (nearest == null) {
-      // Check that the value is comparable if we didn't do any comparisons.
-      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {
-        throw new ClassCastException(key.getClass().getName() + " is not Comparable");
-      }
-      created = new Node<K, V>(nearest, key, hash, header, header.prev);
-      table[index] = created;
-    } else {
-      created = new Node<K, V>(nearest, key, hash, header, header.prev);
-      if (comparison < 0) { // nearest.key is higher
-        nearest.left = created;
-      } else { // comparison > 0, nearest.key is lower
-        nearest.right = created;
-      }
-      rebalance(nearest, true);
-    }
-
-    if (size++ > threshold) {
-      doubleCapacity();
-    }
-    modCount++;
-
-    return created;
-  }
-
-  @SuppressWarnings("unchecked")
-  Node<K, V> findByObject(Object key) {
-    try {
-      return key != null ? find((K) key, false) : null;
-    } catch (ClassCastException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns this map's entry that has the same key and value as {@code
-   * entry}, or null if this map has no such entry.
-   *
-   * <p>This method uses the comparator for key equality rather than {@code
-   * equals}. If this map's comparator isn't consistent with equals (such as
-   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
-   * contains()} will violate the collections API.
-   */
-  Node<K, V> findByEntry(Entry<?, ?> entry) {
-    Node<K, V> mine = findByObject(entry.getKey());
-    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
-    return valuesEqual ? mine : null;
-  }
-
-  private boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Applies a supplemental hash function to a given hashCode, which defends
-   * against poor quality hash functions. This is critical because HashMap
-   * uses power-of-two length hash tables, that otherwise encounter collisions
-   * for hashCodes that do not differ in lower or upper bits.
-   */
-  private static int secondaryHash(int h) {
-    // Doug Lea's supplemental hash function
-    h ^= (h >>> 20) ^ (h >>> 12);
-    return h ^ (h >>> 7) ^ (h >>> 4);
-  }
-
-  /**
-   * Removes {@code node} from this tree, rearranging the tree's structure as
-   * necessary.
-   *
-   * @param unlink true to also unlink this node from the iteration linked list.
-   */
-  void removeInternal(Node<K, V> node, boolean unlink) {
-    if (unlink) {
-      node.prev.next = node.next;
-      node.next.prev = node.prev;
-      node.next = node.prev = null; // Help the GC (for performance)
-    }
-
-    Node<K, V> left = node.left;
-    Node<K, V> right = node.right;
-    Node<K, V> originalParent = node.parent;
-    if (left != null && right != null) {
-
-      /*
-       * To remove a node with both left and right subtrees, move an
-       * adjacent node from one of those subtrees into this node's place.
-       *
-       * Removing the adjacent node may change this node's subtrees. This
-       * node may no longer have two subtrees once the adjacent node is
-       * gone!
-       */
-
-      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
-      removeInternal(adjacent, false); // takes care of rebalance and size--
-
-      int leftHeight = 0;
-      left = node.left;
-      if (left != null) {
-        leftHeight = left.height;
-        adjacent.left = left;
-        left.parent = adjacent;
-        node.left = null;
-      }
-      int rightHeight = 0;
-      right = node.right;
-      if (right != null) {
-        rightHeight = right.height;
-        adjacent.right = right;
-        right.parent = adjacent;
-        node.right = null;
-      }
-      adjacent.height = Math.max(leftHeight, rightHeight) + 1;
-      replaceInParent(node, adjacent);
-      return;
-    } else if (left != null) {
-      replaceInParent(node, left);
-      node.left = null;
-    } else if (right != null) {
-      replaceInParent(node, right);
-      node.right = null;
-    } else {
-      replaceInParent(node, null);
-    }
-
-    rebalance(originalParent, false);
-    size--;
-    modCount++;
-  }
-
-  Node<K, V> removeInternalByKey(Object key) {
-    Node<K, V> node = findByObject(key);
-    if (node != null) {
-      removeInternal(node, true);
-    }
-    return node;
-  }
-
-  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
-    Node<K, V> parent = node.parent;
-    node.parent = null;
-    if (replacement != null) {
-      replacement.parent = parent;
-    }
-
-    if (parent != null) {
-      if (parent.left == node) {
-        parent.left = replacement;
-      } else {
-        assert (parent.right == node);
-        parent.right = replacement;
-      }
-    } else {
-      int index = node.hash & (table.length - 1);
-      table[index] = replacement;
-    }
-  }
-
-  /**
-   * Rebalances the tree by making any AVL rotations necessary between the
-   * newly-unbalanced node and the tree's root.
-   *
-   * @param insert true if the node was unbalanced by an insert; false if it
-   *     was by a removal.
-   */
-  private void rebalance(Node<K, V> unbalanced, boolean insert) {
-    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
-      Node<K, V> left = node.left;
-      Node<K, V> right = node.right;
-      int leftHeight = left != null ? left.height : 0;
-      int rightHeight = right != null ? right.height : 0;
-
-      int delta = leftHeight - rightHeight;
-      if (delta == -2) {
-        Node<K, V> rightLeft = right.left;
-        Node<K, V> rightRight = right.right;
-        int rightRightHeight = rightRight != null ? rightRight.height : 0;
-        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
-
-        int rightDelta = rightLeftHeight - rightRightHeight;
-        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
-          rotateLeft(node); // AVL right right
-        } else {
-          assert (rightDelta == 1);
-          rotateRight(right); // AVL right left
-          rotateLeft(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 2) {
-        Node<K, V> leftLeft = left.left;
-        Node<K, V> leftRight = left.right;
-        int leftRightHeight = leftRight != null ? leftRight.height : 0;
-        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
-
-        int leftDelta = leftLeftHeight - leftRightHeight;
-        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
-          rotateRight(node); // AVL left left
-        } else {
-          assert (leftDelta == -1);
-          rotateLeft(left); // AVL left right
-          rotateRight(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 0) {
-        node.height = leftHeight + 1; // leftHeight == rightHeight
-        if (insert) {
-          break; // the insert caused balance, so rebalancing is done!
-        }
-
-      } else {
-        assert (delta == -1 || delta == 1);
-        node.height = Math.max(leftHeight, rightHeight) + 1;
-        if (!insert) {
-          break; // the height hasn't changed, so rebalancing is done!
-        }
-      }
-    }
-  }
-
-  /**
-   * Rotates the subtree so that its root's right child is the new root.
-   */
-  private void rotateLeft(Node<K, V> root) {
-    Node<K, V> left = root.left;
-    Node<K, V> pivot = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's left child to the root's right
-    root.right = pivotLeft;
-    if (pivotLeft != null) {
-      pivotLeft.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's left
-    pivot.left = root;
-    root.parent = pivot;
-
-    // fix heights
-    root.height = Math.max(left != null ? left.height : 0,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-  }
-
-  /**
-   * Rotates the subtree so that its root's left child is the new root.
-   */
-  private void rotateRight(Node<K, V> root) {
-    Node<K, V> pivot = root.left;
-    Node<K, V> right = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's right child to the root's left
-    root.left = pivotRight;
-    if (pivotRight != null) {
-      pivotRight.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's right
-    pivot.right = root;
-    root.parent = pivot;
-
-    // fixup heights
-    root.height = Math.max(right != null ? right.height : 0,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-  }
-
-  private EntrySet entrySet;
-  private KeySet keySet;
-
-  @Override public Set<Entry<K, V>> entrySet() {
-    EntrySet result = entrySet;
-    return result != null ? result : (entrySet = new EntrySet());
-  }
-
-  @Override public Set<K> keySet() {
-    KeySet result = keySet;
-    return result != null ? result : (keySet = new KeySet());
-  }
-
-  static final class Node<K, V> implements Entry<K, V> {
-    Node<K, V> parent;
-    Node<K, V> left;
-    Node<K, V> right;
-    Node<K, V> next;
-    Node<K, V> prev;
-    final K key;
-    final int hash;
-    V value;
-    int height;
-
-    /** Create the header entry */
-    Node() {
-      key = null;
-      hash = -1;
-      next = prev = this;
-    }
-
-    /** Create a regular entry */
-    Node(Node<K, V> parent, K key, int hash, Node<K, V> next, Node<K, V> prev) {
-      this.parent = parent;
-      this.key = key;
-      this.hash = hash;
-      this.height = 1;
-      this.next = next;
-      this.prev = prev;
-      prev.next = this;
-      next.prev = this;
-    }
-
-    public K getKey() {
-      return key;
-    }
-
-    public V getValue() {
-      return value;
-    }
-
-    public V setValue(V value) {
-      V oldValue = this.value;
-      this.value = value;
-      return oldValue;
-    }
-
-    @SuppressWarnings("rawtypes")
-    @Override public boolean equals(Object o) {
-      if (o instanceof Entry) {
-        Entry other = (Entry) o;
-        return (key == null ? other.getKey() == null : key.equals(other.getKey()))
-            && (value == null ? other.getValue() == null : value.equals(other.getValue()));
-      }
-      return false;
-    }
-
-    @Override public int hashCode() {
-      return (key == null ? 0 : key.hashCode())
-          ^ (value == null ? 0 : value.hashCode());
-    }
-
-    @Override public String toString() {
-      return key + "=" + value;
-    }
-
-    /**
-     * Returns the first node in this subtree.
-     */
-    public Node<K, V> first() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.left;
-      while (child != null) {
-        node = child;
-        child = node.left;
-      }
-      return node;
-    }
-
-    /**
-     * Returns the last node in this subtree.
-     */
-    public Node<K, V> last() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.right;
-      while (child != null) {
-        node = child;
-        child = node.right;
-      }
-      return node;
-    }
-  }
-
-  private void doubleCapacity() {
-    table = doubleCapacity(table);
-    threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity
-  }
-
-  /**
-   * Returns a new array containing the same nodes as {@code oldTable}, but with
-   * twice as many trees, each of (approximately) half the previous size.
-   */
-  static <K, V> Node<K, V>[] doubleCapacity(Node<K, V>[] oldTable) {
-    // TODO: don't do anything if we're already at MAX_CAPACITY
-    int oldCapacity = oldTable.length;
-    @SuppressWarnings("unchecked") // Arrays and generics don't get along.
-    Node<K, V>[] newTable = new Node[oldCapacity * 2];
-    AvlIterator<K, V> iterator = new AvlIterator<K, V>();
-    AvlBuilder<K, V> leftBuilder = new AvlBuilder<K, V>();
-    AvlBuilder<K, V> rightBuilder = new AvlBuilder<K, V>();
-
-    // Split each tree into two trees.
-    for (int i = 0; i < oldCapacity; i++) {
-      Node<K, V> root = oldTable[i];
-      if (root == null) {
-        continue;
-      }
-
-      // Compute the sizes of the left and right trees.
-      iterator.reset(root);
-      int leftSize = 0;
-      int rightSize = 0;
-      for (Node<K, V> node; (node = iterator.next()) != null; ) {
-        if ((node.hash & oldCapacity) == 0) {
-          leftSize++;
-        } else {
-          rightSize++;
-        }
-      }
-
-      // Split the tree into two.
-      leftBuilder.reset(leftSize);
-      rightBuilder.reset(rightSize);
-      iterator.reset(root);
-      for (Node<K, V> node; (node = iterator.next()) != null; ) {
-        if ((node.hash & oldCapacity) == 0) {
-          leftBuilder.add(node);
-        } else {
-          rightBuilder.add(node);
-        }
-      }
-
-      // Populate the enlarged array with these new roots.
-      newTable[i] = leftSize > 0 ? leftBuilder.root() : null;
-      newTable[i + oldCapacity] = rightSize > 0 ? rightBuilder.root() : null;
-    }
-    return newTable;
-  }
-
-  /**
-   * Walks an AVL tree in iteration order. Once a node has been returned, its
-   * left, right and parent links are <strong>no longer used</strong>. For this
-   * reason it is safe to transform these links as you walk a tree.
-   *
-   * <p><strong>Warning:</strong> this iterator is destructive. It clears the
-   * parent node of all nodes in the tree. It is an error to make a partial
-   * iteration of a tree.
-   */
-  static class AvlIterator<K, V> {
-    /** This stack is a singly linked list, linked by the 'parent' field. */
-    private Node<K, V> stackTop;
-
-    void reset(Node<K, V> root) {
-      Node<K, V> stackTop = null;
-      for (Node<K, V> n = root; n != null; n = n.left) {
-        n.parent = stackTop;
-        stackTop = n; // Stack push.
-      }
-      this.stackTop = stackTop;
-    }
-
-    public Node<K, V> next() {
-      Node<K, V> stackTop = this.stackTop;
-      if (stackTop == null) {
-        return null;
-      }
-      Node<K, V> result = stackTop;
-      stackTop = result.parent;
-      result.parent = null;
-      for (Node<K, V> n = result.right; n != null; n = n.left) {
-        n.parent = stackTop;
-        stackTop = n; // Stack push.
-      }
-      this.stackTop = stackTop;
-      return result;
-    }
-  }
-
-  /**
-   * Builds AVL trees of a predetermined size by accepting nodes of increasing
-   * value. To use:
-   * <ol>
-   *   <li>Call {@link #reset} to initialize the target size <i>size</i>.
-   *   <li>Call {@link #add} <i>size</i> times with increasing values.
-   *   <li>Call {@link #root} to get the root of the balanced tree.
-   * </ol>
-   *
-   * <p>The returned tree will satisfy the AVL constraint: for every node
-   * <i>N</i>, the height of <i>N.left</i> and <i>N.right</i> is different by at
-   * most 1. It accomplishes this by omitting deepest-level leaf nodes when
-   * building trees whose size isn't a power of 2 minus 1.
-   *
-   * <p>Unlike rebuilding a tree from scratch, this approach requires no value
-   * comparisons. Using this class to create a tree of size <i>S</i> is
-   * {@code O(S)}.
-   */
-  final static class AvlBuilder<K, V> {
-    /** This stack is a singly linked list, linked by the 'parent' field. */
-    private Node<K, V> stack;
-    private int leavesToSkip;
-    private int leavesSkipped;
-    private int size;
-
-    void reset(int targetSize) {
-      // compute the target tree size. This is a power of 2 minus one, like 15 or 31.
-      int treeCapacity = Integer.highestOneBit(targetSize) * 2 - 1;
-      leavesToSkip = treeCapacity - targetSize;
-      size = 0;
-      leavesSkipped = 0;
-      stack = null;
-    }
-
-    void add(Node<K, V> node) {
-      node.left = node.parent = node.right = null;
-      node.height = 1;
-
-      // Skip a leaf if necessary.
-      if (leavesToSkip > 0 && (size & 1) == 0) {
-        size++;
-        leavesToSkip--;
-        leavesSkipped++;
-      }
-
-      node.parent = stack;
-      stack = node; // Stack push.
-      size++;
-
-      // Skip a leaf if necessary.
-      if (leavesToSkip > 0 && (size & 1) == 0) {
-        size++;
-        leavesToSkip--;
-        leavesSkipped++;
-      }
-
-      /*
-       * Combine 3 nodes into subtrees whenever the size is one less than a
-       * multiple of 4. For example we combine the nodes A, B, C into a
-       * 3-element tree with B as the root.
-       *
-       * Combine two subtrees and a spare single value whenever the size is one
-       * less than a multiple of 8. For example at 8 we may combine subtrees
-       * (A B C) and (E F G) with D as the root to form ((A B C) D (E F G)).
-       *
-       * Just as we combine single nodes when size nears a multiple of 4, and
-       * 3-element trees when size nears a multiple of 8, we combine subtrees of
-       * size (N-1) whenever the total size is 2N-1 whenever N is a power of 2.
-       */
-      for (int scale = 4; (size & scale - 1) == scale - 1; scale *= 2) {
-        if (leavesSkipped == 0) {
-          // Pop right, center and left, then make center the top of the stack.
-          Node<K, V> right = stack;
-          Node<K, V> center = right.parent;
-          Node<K, V> left = center.parent;
-          center.parent = left.parent;
-          stack = center;
-          // Construct a tree.
-          center.left = left;
-          center.right = right;
-          center.height = right.height + 1;
-          left.parent = center;
-          right.parent = center;
-        } else if (leavesSkipped == 1) {
-          // Pop right and center, then make center the top of the stack.
-          Node<K, V> right = stack;
-          Node<K, V> center = right.parent;
-          stack = center;
-          // Construct a tree with no left child.
-          center.right = right;
-          center.height = right.height + 1;
-          right.parent = center;
-          leavesSkipped = 0;
-        } else if (leavesSkipped == 2) {
-          leavesSkipped = 0;
-        }
-      }
-    }
-
-    Node<K, V> root() {
-      Node<K, V> stackTop = this.stack;
-      if (stackTop.parent != null) {
-        throw new IllegalStateException();
-      }
-      return stackTop;
-    }
-  }
-
-  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {
-    Node<K, V> next = header.next;
-    Node<K, V> lastReturned = null;
-    int expectedModCount = modCount;
-
-    LinkedTreeMapIterator() {
-    }
-
-    public final boolean hasNext() {
-      return next != header;
-    }
-
-    final Node<K, V> nextNode() {
-      Node<K, V> e = next;
-      if (e == header) {
-        throw new NoSuchElementException();
-      }
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
-      }
-      next = e.next;
-      return lastReturned = e;
-    }
-
-    public final void remove() {
-      if (lastReturned == null) {
-        throw new IllegalStateException();
-      }
-      removeInternal(lastReturned, true);
-      lastReturned = null;
-      expectedModCount = modCount;
-    }
-  }
-
-  final class EntrySet extends AbstractSet<Entry<K, V>> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<Entry<K, V>> iterator() {
-      return new LinkedTreeMapIterator<Entry<K, V>>() {
-        public Entry<K, V> next() {
-          return nextNode();
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
-    }
-
-    @Override public boolean remove(Object o) {
-      if (!(o instanceof Entry)) {
-        return false;
-      }
-
-      Node<K, V> node = findByEntry((Entry<?, ?>) o);
-      if (node == null) {
-        return false;
-      }
-      removeInternal(node, true);
-      return true;
-    }
-
-    @Override public void clear() {
-      LinkedHashTreeMap.this.clear();
-    }
-  }
-
-  final class KeySet extends AbstractSet<K> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<K> iterator() {
-      return new LinkedTreeMapIterator<K>() {
-        public K next() {
-          return nextNode().key;
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return containsKey(o);
-    }
-
-    @Override public boolean remove(Object key) {
-      return removeInternalByKey(key) != null;
-    }
-
-    @Override public void clear() {
-      LinkedHashTreeMap.this.clear();
-    }
-  }
-
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a LinkedHashMap so that they won't need Gson on the other side to
-   * deserialize it. Using serialization defeats our DoS defence, so most apps
-   * shouldn't use it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new LinkedHashMap<K, V>(this);
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/ObjectConstructor.java b/src/main/java/com/google/gson/internal/ObjectConstructor.java
deleted file mode 100644
index 6ef20607f..000000000
--- a/src/main/java/com/google/gson/internal/ObjectConstructor.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-/**
- * Defines a generic object construction factory.  The purpose of this class
- * is to construct a default instance of a class that can be used for object
- * navigation while deserialization from its JSON representation.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public interface ObjectConstructor<T> {
-
-  /**
-   * Returns a new instance.
-   */
-  public T construct();
-}
\ No newline at end of file
diff --git a/src/main/java/com/google/gson/internal/Primitives.java b/src/main/java/com/google/gson/internal/Primitives.java
deleted file mode 100644
index 872f50225..000000000
--- a/src/main/java/com/google/gson/internal/Primitives.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-
-import java.lang.reflect.Type;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import com.github.gv2011.jsoncore.imp.Preconditions;
-
-/**
- * Contains static utility methods pertaining to primitive types and their
- * corresponding wrapper types.
- *
- * @author Kevin Bourrillion
- */
-public final class Primitives {
-  private Primitives() {
-    throw new UnsupportedOperationException();
-  }
-
-  /** A map from primitive types to their corresponding wrapper types. */
-  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;
-
-  /** A map from wrapper types to their corresponding primitive types. */
-  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;
-
-  // Sad that we can't use a BiMap. :(
-
-  static {
-    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);
-    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);
-
-    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
-    add(primToWrap, wrapToPrim, byte.class, Byte.class);
-    add(primToWrap, wrapToPrim, char.class, Character.class);
-    add(primToWrap, wrapToPrim, double.class, Double.class);
-    add(primToWrap, wrapToPrim, float.class, Float.class);
-    add(primToWrap, wrapToPrim, int.class, Integer.class);
-    add(primToWrap, wrapToPrim, long.class, Long.class);
-    add(primToWrap, wrapToPrim, short.class, Short.class);
-    add(primToWrap, wrapToPrim, void.class, Void.class);
-
-    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
-    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
-  }
-
-  private static void add(Map<Class<?>, Class<?>> forward,
-      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {
-    forward.put(key, value);
-    backward.put(value, key);
-  }
-
-  /**
-   * Returns true if this type is a primitive.
-   */
-  public static boolean isPrimitive(Type type) {
-    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);
-  }
-
-  /**
-   * Returns {@code true} if {@code type} is one of the nine
-   * primitive-wrapper types, such as {@link Integer}.
-   *
-   * @see Class#isPrimitive
-   */
-  public static boolean isWrapperType(Type type) {
-    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(
-        Preconditions.checkNotNull(type));
-  }
-
-  /**
-   * Returns the corresponding wrapper type of {@code type} if it is a primitive
-   * type; otherwise returns {@code type} itself. Idempotent.
-   * <pre>
-   *     wrap(int.class) == Integer.class
-   *     wrap(Integer.class) == Integer.class
-   *     wrap(String.class) == String.class
-   * </pre>
-   */
-  public static <T> Class<T> wrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(
-        Preconditions.checkNotNull(type));
-    return (wrapped == null) ? type : wrapped;
-  }
-
-  /**
-   * Returns the corresponding primitive type of {@code type} if it is a
-   * wrapper type; otherwise returns {@code type} itself. Idempotent.
-   * <pre>
-   *     unwrap(Integer.class) == int.class
-   *     unwrap(int.class) == int.class
-   *     unwrap(String.class) == String.class
-   * </pre>
-   */
-  public static <T> Class<T> unwrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(
-        Preconditions.checkNotNull(type));
-    return (unwrapped == null) ? type : unwrapped;
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/src/main/java/com/google/gson/internal/UnsafeAllocator.java
deleted file mode 100644
index 41e7cd156..000000000
--- a/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import java.io.ObjectInputStream;
-import java.io.ObjectStreamClass;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Do sneaky things to allocate objects without invoking their constructors.
- *
- * @author Joel Leitch
- * @author Jesse Wilson
- */
-public abstract class UnsafeAllocator {
-  public abstract <T> T newInstance(Class<T> c) throws Exception;
-
-  public static UnsafeAllocator create() {
-    // try JVM
-    // public class Unsafe {
-    //   public Object allocateInstance(Class<?> type);
-    // }
-    try {
-      Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
-      Field f = unsafeClass.getDeclaredField("theUnsafe");
-      f.setAccessible(true);
-      final Object unsafe = f.get(null);
-      final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) allocateInstance.invoke(unsafe, c);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // try dalvikvm, post-gingerbread
-    // public class ObjectStreamClass {
-    //   private static native int getConstructorId(Class<?> c);
-    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);
-    // }
-    try {
-      Method getConstructorId = ObjectStreamClass.class
-          .getDeclaredMethod("getConstructorId", Class.class);
-      getConstructorId.setAccessible(true);
-      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);
-      final Method newInstance = ObjectStreamClass.class
-          .getDeclaredMethod("newInstance", Class.class, int.class);
-      newInstance.setAccessible(true);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) newInstance.invoke(null, c, constructorId);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // try dalvikvm, pre-gingerbread
-    // public class ObjectInputStream {
-    //   private static native Object newInstance(
-    //     Class<?> instantiationClass, Class<?> constructorClass);
-    // }
-    try {
-      final Method newInstance = ObjectInputStream.class
-          .getDeclaredMethod("newInstance", Class.class, Class.class);
-      newInstance.setAccessible(true);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) newInstance.invoke(null, c, Object.class);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // give up
-    return new UnsafeAllocator() {
-      @Override
-      public <T> T newInstance(Class<T> c) {
-        throw new UnsupportedOperationException("Cannot allocate " + c);
-      }
-    };
-  }
-
-  /**
-   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
-   * throw an {@link java.lang.UnsupportedOperationException}
-   * @param c instance of the class to be checked
-   */
-  private static void assertInstantiable(Class<?> c) {
-    int modifiers = c.getModifiers();
-    if (Modifier.isInterface(modifiers)) {
-      throw new UnsupportedOperationException("Interface can't be instantiated! Interface name: " + c.getName());
-    }
-    if (Modifier.isAbstract(modifiers)) {
-      throw new UnsupportedOperationException("Abstract class can't be instantiated! Class name: " + c.getName());
-    }
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
index 06eaaf23a..374aca528 100644
--- a/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
@@ -17,10 +17,10 @@
 package com.google.gson.internal.bind;
 
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.bind.util.ISO8601Utils;
diff --git a/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 3bf7e5363..d484ce36f 100644
--- a/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -19,12 +19,13 @@
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.github.gv2011.jsoncore.imp.JsonReaderInternalAccess;
 import com.github.gv2011.jsoncore.imp.Streams;
+import com.github.gv2011.jsoncore.imp.TypeAdapters;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Types;
diff --git a/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index fa62b9900..097945580 100644
--- a/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -17,11 +17,11 @@
 package com.google.gson.internal.bind;
 
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
diff --git a/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
index 70f1cf3a1..1b7fc79f6 100644
--- a/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
@@ -17,10 +17,10 @@
 package com.google.gson.internal.bind;
 
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
diff --git a/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
index 269d18d39..3de7a233a 100644
--- a/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
@@ -17,10 +17,10 @@
 package com.google.gson.internal.bind;
 
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonToken;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
diff --git a/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index b6d18c32a..bea6ffff9 100644
--- a/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -17,6 +17,7 @@
 package com.google.gson.internal.bind;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.github.gv2011.jsoncore.imp.Preconditions;
@@ -24,7 +25,6 @@
 import com.google.gson.Gson;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
diff --git a/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
deleted file mode 100644
index 215d67283..000000000
--- a/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ /dev/null
@@ -1,924 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import java.io.IOException;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Calendar;
-import java.util.Currency;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicIntegerArray;
-
-import com.github.gv2011.jsoncore.JsonArray;
-import com.github.gv2011.jsoncore.JsonElement;
-import com.github.gv2011.jsoncore.JsonNull;
-import com.github.gv2011.jsoncore.JsonObject;
-import com.github.gv2011.jsoncore.JsonPrimitive;
-import com.github.gv2011.jsoncore.JsonReader;
-import com.github.gv2011.jsoncore.JsonToken;
-import com.github.gv2011.jsoncore.JsonWriter;
-import com.github.gv2011.jsoncore.imp.LazilyParsedNumber;
-import com.google.gson.Gson;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.reflect.TypeToken;
-
-/**
- * Type adapters for basic types.
- */
-public final class TypeAdapters {
-  private TypeAdapters() {
-    throw new UnsupportedOperationException();
-  }
-
-  @SuppressWarnings("rawtypes")
-  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {
-    @Override
-    public void write(JsonWriter out, Class value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-      } else {
-        throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
-            + value.getName() + ". Forgot to register a type adapter?");
-      }
-    }
-    @Override
-    public Class read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else {
-        throw new UnsupportedOperationException(
-            "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
-      }
-    }
-  };
-  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
-
-  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {
-    @Override public BitSet read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-
-      BitSet bitset = new BitSet();
-      in.beginArray();
-      int i = 0;
-      JsonToken tokenType = in.peek();
-      while (tokenType != JsonToken.END_ARRAY) {
-        boolean set;
-        switch (tokenType) {
-        case NUMBER:
-          set = in.nextInt() != 0;
-          break;
-        case BOOLEAN:
-          set = in.nextBoolean();
-          break;
-        case STRING:
-          String stringValue = in.nextString();
-          try {
-            set = Integer.parseInt(stringValue) != 0;
-          } catch (NumberFormatException e) {
-            throw new JsonSyntaxException(
-                "Error: Expecting: bitset number value (1, 0), Found: " + stringValue);
-          }
-          break;
-        default:
-          throw new JsonSyntaxException("Invalid bitset value type: " + tokenType);
-        }
-        if (set) {
-          bitset.set(i);
-        }
-        ++i;
-        tokenType = in.peek();
-      }
-      in.endArray();
-      return bitset;
-    }
-
-    @Override public void write(JsonWriter out, BitSet src) throws IOException {
-      if (src == null) {
-        out.nullValue();
-        return;
-      }
-
-      out.beginArray();
-      for (int i = 0; i < src.length(); i++) {
-        int value = (src.get(i)) ? 1 : 0;
-        out.value(value);
-      }
-      out.endArray();
-    }
-  };
-
-  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
-
-  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
-    @Override
-    public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else if (in.peek() == JsonToken.STRING) {
-        // support strings for compatibility with GSON 1.7
-        return Boolean.parseBoolean(in.nextString());
-      }
-      return in.nextBoolean();
-    }
-    @Override
-    public void write(JsonWriter out, Boolean value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  /**
-   * Writes a boolean as a string. Useful for map keys, where booleans aren't
-   * otherwise permitted.
-   */
-  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {
-    @Override public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return Boolean.valueOf(in.nextString());
-    }
-
-    @Override public void write(JsonWriter out, Boolean value) throws IOException {
-      out.value(value == null ? "null" : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory BOOLEAN_FACTORY
-      = newFactory(boolean.class, Boolean.class, BOOLEAN);
-
-  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        int intValue = in.nextInt();
-        return (byte) intValue;
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory BYTE_FACTORY
-      = newFactory(byte.class, Byte.class, BYTE);
-
-  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return (short) in.nextInt();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory SHORT_FACTORY
-      = newFactory(short.class, Short.class, SHORT);
-
-  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return in.nextInt();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-  public static final TypeAdapterFactory INTEGER_FACTORY
-      = newFactory(int.class, Integer.class, INTEGER);
-
-  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {
-    @Override public AtomicInteger read(JsonReader in) throws IOException {
-      try {
-        return new AtomicInteger(in.nextInt());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {
-      out.value(value.get());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =
-      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);
-
-  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {
-    @Override public AtomicBoolean read(JsonReader in) throws IOException {
-      return new AtomicBoolean(in.nextBoolean());
-    }
-    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {
-      out.value(value.get());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =
-      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);
-
-  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {
-    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {
-        List<Integer> list = new ArrayList<Integer>();
-        in.beginArray();
-        while (in.hasNext()) {
-          try {
-            int integer = in.nextInt();
-            list.add(integer);
-          } catch (NumberFormatException e) {
-            throw new JsonSyntaxException(e);
-          }
-        }
-        in.endArray();
-        int length = list.size();
-        AtomicIntegerArray array = new AtomicIntegerArray(length);
-        for (int i = 0; i < length; ++i) {
-          array.set(i, list.get(i));
-        }
-        return array;
-    }
-    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {
-      out.beginArray();
-      for (int i = 0, length = value.length(); i < length; i++) {
-        out.value(value.get(i));
-      }
-      out.endArray();
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =
-      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);
-
-  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return in.nextLong();
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return (float) in.nextDouble();
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return in.nextDouble();
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {
-    @Override
-    public Number read(JsonReader in) throws IOException {
-      JsonToken jsonToken = in.peek();
-      switch (jsonToken) {
-      case NULL:
-        in.nextNull();
-        return null;
-      case NUMBER:
-        return new LazilyParsedNumber(in.nextString());
-      default:
-        throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);
-
-  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {
-    @Override
-    public Character read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String str = in.nextString();
-      if (str.length() != 1) {
-        throw new JsonSyntaxException("Expecting character, got: " + str);
-      }
-      return str.charAt(0);
-    }
-    @Override
-    public void write(JsonWriter out, Character value) throws IOException {
-      out.value(value == null ? null : String.valueOf(value));
-    }
-  };
-
-  public static final TypeAdapterFactory CHARACTER_FACTORY
-      = newFactory(char.class, Character.class, CHARACTER);
-
-  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {
-    @Override
-    public String read(JsonReader in) throws IOException {
-      JsonToken peek = in.peek();
-      if (peek == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      /* coerce booleans to strings for backwards compatibility */
-      if (peek == JsonToken.BOOLEAN) {
-        return Boolean.toString(in.nextBoolean());
-      }
-      return in.nextString();
-    }
-    @Override
-    public void write(JsonWriter out, String value) throws IOException {
-      out.value(value);
-    }
-  };
-  
-  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {
-    @Override public BigDecimal read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return new BigDecimal(in.nextString());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-
-    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {
-      out.value(value);
-    }
-  };
-  
-  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {
-    @Override public BigInteger read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        return new BigInteger(in.nextString());
-      } catch (NumberFormatException e) {
-        throw new JsonSyntaxException(e);
-      }
-    }
-
-    @Override public void write(JsonWriter out, BigInteger value) throws IOException {
-      out.value(value);
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);
-
-  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {
-    @Override
-    public StringBuilder read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return new StringBuilder(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, StringBuilder value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =
-    newFactory(StringBuilder.class, STRING_BUILDER);
-
-  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {
-    @Override
-    public StringBuffer read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return new StringBuffer(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, StringBuffer value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =
-    newFactory(StringBuffer.class, STRING_BUFFER);
-
-  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {
-    @Override
-    public URL read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String nextString = in.nextString();
-      return "null".equals(nextString) ? null : new URL(nextString);
-    }
-    @Override
-    public void write(JsonWriter out, URL value) throws IOException {
-      out.value(value == null ? null : value.toExternalForm());
-    }
-  };
-
-  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);
-
-  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {
-    @Override
-    public URI read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      try {
-        String nextString = in.nextString();
-        return "null".equals(nextString) ? null : new URI(nextString);
-      } catch (URISyntaxException e) {
-        throw new JsonIOException(e);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, URI value) throws IOException {
-      out.value(value == null ? null : value.toASCIIString());
-    }
-  };
-
-  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);
-
-  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {
-    @Override
-    public InetAddress read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      // regrettably, this should have included both the host name and the host address
-      return InetAddress.getByName(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, InetAddress value) throws IOException {
-      out.value(value == null ? null : value.getHostAddress());
-    }
-  };
-
-  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =
-    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);
-
-  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {
-    @Override
-    public UUID read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return java.util.UUID.fromString(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, UUID value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);
-
-  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {
-    @Override
-    public Currency read(JsonReader in) throws IOException {
-      return Currency.getInstance(in.nextString());
-    }
-    @Override
-    public void write(JsonWriter out, Currency value) throws IOException {
-      out.value(value.getCurrencyCode());
-    }
-  }.nullSafe();
-  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);
-
-  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      if (typeToken.getRawType() != Timestamp.class) {
-        return null;
-      }
-
-      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);
-      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {
-        @Override public Timestamp read(JsonReader in) throws IOException {
-          Date date = dateTypeAdapter.read(in);
-          return date != null ? new Timestamp(date.getTime()) : null;
-        }
-
-        @Override public void write(JsonWriter out, Timestamp value) throws IOException {
-          dateTypeAdapter.write(out, value);
-        }
-      };
-    }
-  };
-
-  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {
-    private static final String YEAR = "year";
-    private static final String MONTH = "month";
-    private static final String DAY_OF_MONTH = "dayOfMonth";
-    private static final String HOUR_OF_DAY = "hourOfDay";
-    private static final String MINUTE = "minute";
-    private static final String SECOND = "second";
-
-    @Override
-    public Calendar read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return  null;
-      }
-      in.beginObject();
-      int year = 0;
-      int month = 0;
-      int dayOfMonth = 0;
-      int hourOfDay = 0;
-      int minute = 0;
-      int second = 0;
-      while (in.peek() != JsonToken.END_OBJECT) {
-        String name = in.nextName();
-        int value = in.nextInt();
-        if (YEAR.equals(name)) {
-          year = value;
-        } else if (MONTH.equals(name)) {
-          month = value;
-        } else if (DAY_OF_MONTH.equals(name)) {
-          dayOfMonth = value;
-        } else if (HOUR_OF_DAY.equals(name)) {
-          hourOfDay = value;
-        } else if (MINUTE.equals(name)) {
-          minute = value;
-        } else if (SECOND.equals(name)) {
-          second = value;
-        }
-      }
-      in.endObject();
-      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);
-    }
-
-    @Override
-    public void write(JsonWriter out, Calendar value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
-      out.beginObject();
-      out.name(YEAR);
-      out.value(value.get(Calendar.YEAR));
-      out.name(MONTH);
-      out.value(value.get(Calendar.MONTH));
-      out.name(DAY_OF_MONTH);
-      out.value(value.get(Calendar.DAY_OF_MONTH));
-      out.name(HOUR_OF_DAY);
-      out.value(value.get(Calendar.HOUR_OF_DAY));
-      out.name(MINUTE);
-      out.value(value.get(Calendar.MINUTE));
-      out.name(SECOND);
-      out.value(value.get(Calendar.SECOND));
-      out.endObject();
-    }
-  };
-
-  public static final TypeAdapterFactory CALENDAR_FACTORY =
-    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);
-
-  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {
-    @Override
-    public Locale read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      String locale = in.nextString();
-      StringTokenizer tokenizer = new StringTokenizer(locale, "_");
-      String language = null;
-      String country = null;
-      String variant = null;
-      if (tokenizer.hasMoreElements()) {
-        language = tokenizer.nextToken();
-      }
-      if (tokenizer.hasMoreElements()) {
-        country = tokenizer.nextToken();
-      }
-      if (tokenizer.hasMoreElements()) {
-        variant = tokenizer.nextToken();
-      }
-      if (country == null && variant == null) {
-        return new Locale(language);
-      } else if (variant == null) {
-        return new Locale(language, country);
-      } else {
-        return new Locale(language, country, variant);
-      }
-    }
-    @Override
-    public void write(JsonWriter out, Locale value) throws IOException {
-      out.value(value == null ? null : value.toString());
-    }
-  };
-
-  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);
-
-  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {
-    @Override public JsonElement read(JsonReader in) throws IOException {
-      switch (in.peek()) {
-      case STRING:
-        return new JsonPrimitive(in.nextString());
-      case NUMBER:
-        String number = in.nextString();
-        return new JsonPrimitive(new LazilyParsedNumber(number));
-      case BOOLEAN:
-        return new JsonPrimitive(in.nextBoolean());
-      case NULL:
-        in.nextNull();
-        return JsonNull.INSTANCE;
-      case BEGIN_ARRAY:
-        JsonArray array = new JsonArray();
-        in.beginArray();
-        while (in.hasNext()) {
-          array.add(read(in));
-        }
-        in.endArray();
-        return array;
-      case BEGIN_OBJECT:
-        JsonObject object = new JsonObject();
-        in.beginObject();
-        while (in.hasNext()) {
-          object.add(in.nextName(), read(in));
-        }
-        in.endObject();
-        return object;
-      case END_DOCUMENT:
-      case NAME:
-      case END_OBJECT:
-      case END_ARRAY:
-      default:
-        throw new IllegalArgumentException();
-      }
-    }
-
-    @Override public void write(JsonWriter out, JsonElement value) throws IOException {
-      if (value == null || value.isJsonNull()) {
-        out.nullValue();
-      } else if (value.isJsonPrimitive()) {
-        JsonPrimitive primitive = value.getAsJsonPrimitive();
-        if (primitive.isNumber()) {
-          out.value(primitive.getAsNumber());
-        } else if (primitive.isBoolean()) {
-          out.value(primitive.getAsBoolean());
-        } else {
-          out.value(primitive.getAsString());
-        }
-
-      } else if (value.isJsonArray()) {
-        out.beginArray();
-        for (JsonElement e : value.getAsJsonArray()) {
-          write(out, e);
-        }
-        out.endArray();
-
-      } else if (value.isJsonObject()) {
-        out.beginObject();
-        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
-          out.name(e.getKey());
-          write(out, e.getValue());
-        }
-        out.endObject();
-
-      } else {
-        throw new IllegalArgumentException("Couldn't write " + value.getClass());
-      }
-    }
-  };
-
-  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY
-      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
-
-  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
-    private final Map<String, T> nameToConstant = new HashMap<String, T>();
-    private final Map<T, String> constantToName = new HashMap<T, String>();
-
-    public EnumTypeAdapter(Class<T> classOfT) {
-      try {
-        for (T constant : classOfT.getEnumConstants()) {
-          String name = constant.name();
-          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
-          if (annotation != null) {
-            name = annotation.value();
-            for (String alternate : annotation.alternate()) {
-              nameToConstant.put(alternate, constant);
-            }
-          }
-          nameToConstant.put(name, constant);
-          constantToName.put(constant, name);
-        }
-      } catch (NoSuchFieldException e) {
-        throw new AssertionError("Missing field in " + classOfT.getName(), e);
-      }
-    }
-    @Override public T read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-      return nameToConstant.get(in.nextString());
-    }
-
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      out.value(value == null ? null : constantToName.get(value));
-    }
-  }
-
-  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      Class<? super T> rawType = typeToken.getRawType();
-      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {
-        return null;
-      }
-      if (!rawType.isEnum()) {
-        rawType = rawType.getSuperclass(); // handle anonymous subclasses
-      }
-      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);
-    }
-  };
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactory(
-      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        Class<? super T> rawType = typeToken.getRawType();
-        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + boxed.getName()
-            + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,
-      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        Class<? super T> rawType = typeToken.getRawType();
-        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;
-      }
-      @Override public String toString() {
-        return "Factory[type=" + base.getName()
-            + "+" + sub.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-
-  /**
-   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
-   * that the deserialized type matches the type requested.
-   */
-  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(
-      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
-    return new TypeAdapterFactory() {
-      @SuppressWarnings("unchecked")
-      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
-        final Class<? super T2> requestedType = typeToken.getRawType();
-        if (!clazz.isAssignableFrom(requestedType)) {
-          return null;
-        }
-        return (TypeAdapter<T2>) new TypeAdapter<T1>() {
-          @Override public void write(JsonWriter out, T1 value) throws IOException {
-            typeAdapter.write(out, value);
-          }
-
-          @Override public T1 read(JsonReader in) throws IOException {
-            T1 result = typeAdapter.read(in);
-            if (result != null && !requestedType.isInstance(result)) {
-              throw new JsonSyntaxException("Expected a " + requestedType.getName()
-                  + " but was " + result.getClass().getName());
-            }
-            return result;
-          }
-        };
-      }
-      @Override public String toString() {
-        return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";
-      }
-    };
-  }
-}
diff --git a/src/main/java/com/google/gson/internal/package-info.java b/src/main/java/com/google/gson/internal/package-info.java
deleted file mode 100644
index b5139b6de..000000000
--- a/src/main/java/com/google/gson/internal/package-info.java
+++ /dev/null
@@ -1,7 +0,0 @@
-/**
- * Do NOT use any class in this package as they are meant for internal use in Gson.
- * These classes will very likely change incompatibly in future versions. You have been warned.
- *
- * @author Inderjeet Singh, Joel Leitch, Jesse Wilson
- */
-package com.google.gson.internal;
\ No newline at end of file
diff --git a/src/test/java/com/google/gson/GsonTypeAdapterTest.java b/src/test/java/com/google/gson/GsonTypeAdapterTest.java
index 228cfca94..79dcea6de 100644
--- a/src/test/java/com/google/gson/GsonTypeAdapterTest.java
+++ b/src/test/java/com/google/gson/GsonTypeAdapterTest.java
@@ -22,6 +22,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 
 import junit.framework.TestCase;
diff --git a/src/test/java/com/google/gson/JsonParserTest.java b/src/test/java/com/google/gson/JsonParserTest.java
index 54b655109..b6f531c2b 100644
--- a/src/test/java/com/google/gson/JsonParserTest.java
+++ b/src/test/java/com/google/gson/JsonParserTest.java
@@ -25,6 +25,7 @@
 import com.github.gv2011.jsoncore.JsonArray;
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.imp.Streams;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 
diff --git a/src/test/java/com/google/gson/MixedStreamTest.java b/src/test/java/com/google/gson/MixedStreamTest.java
index a85ed52c8..b4e55c556 100644
--- a/src/test/java/com/google/gson/MixedStreamTest.java
+++ b/src/test/java/com/google/gson/MixedStreamTest.java
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonWriter;
diff --git a/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index 1cb579262..8a913ccd7 100644
--- a/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -18,6 +18,7 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.internal.$Gson$Types;
 
 import com.google.gson.internal.Primitives;
diff --git a/src/test/java/com/google/gson/PrimitiveTypeAdapter.java b/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
index fb38687b5..a13367dff 100644
--- a/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
+++ b/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.internal.Primitives;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
diff --git a/src/test/java/com/google/gson/common/TestTypes.java b/src/test/java/com/google/gson/common/TestTypes.java
index 8dc3b3e7a..defccaccb 100644
--- a/src/test/java/com/google/gson/common/TestTypes.java
+++ b/src/test/java/com/google/gson/common/TestTypes.java
@@ -21,10 +21,10 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.annotations.SerializedName;
diff --git a/src/test/java/com/google/gson/functional/ArrayTest.java b/src/test/java/com/google/gson/functional/ArrayTest.java
index 11388e90a..e8cc9bdbf 100644
--- a/src/test/java/com/google/gson/functional/ArrayTest.java
+++ b/src/test/java/com/google/gson/functional/ArrayTest.java
@@ -16,9 +16,9 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonParseException;
 import com.google.gson.common.MoreAsserts;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.ClassWithObjects;
diff --git a/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
index 49c722ad7..0897a8074 100644
--- a/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
+++ b/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
@@ -18,11 +18,11 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.common.TestTypes.Base;
 import com.google.gson.common.TestTypes.ClassWithBaseField;
 
diff --git a/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index 66908e398..4ca21e225 100644
--- a/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -17,13 +17,13 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
diff --git a/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 85e5b677c..b8c6251dc 100644
--- a/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -19,15 +19,15 @@
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonNull;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 
diff --git a/src/test/java/com/google/gson/functional/EnumTest.java b/src/test/java/com/google/gson/functional/EnumTest.java
index f167fdc5d..175cd64fc 100644
--- a/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/src/test/java/com/google/gson/functional/EnumTest.java
@@ -17,12 +17,12 @@
 package com.google.gson.functional;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.annotations.SerializedName;
diff --git a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index a1420c0ea..73f6ad364 100644
--- a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -17,6 +17,7 @@
 package com.google.gson.functional;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonWriter;
@@ -24,7 +25,6 @@
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
diff --git a/src/test/java/com/google/gson/functional/JsonParserTest.java b/src/test/java/com/google/gson/functional/JsonParserTest.java
index 01a0ce86e..f0b89e0ba 100644
--- a/src/test/java/com/google/gson/functional/JsonParserTest.java
+++ b/src/test/java/com/google/gson/functional/JsonParserTest.java
@@ -18,11 +18,11 @@
 
 import com.github.gv2011.jsoncore.JsonArray;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.Gson;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonParser;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.Nested;
 import com.google.gson.reflect.TypeToken;
diff --git a/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java b/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
index c7cfcdf9f..552bb34fe 100644
--- a/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
+++ b/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
@@ -16,9 +16,9 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.HashMap;
diff --git a/src/test/java/com/google/gson/functional/MapTest.java b/src/test/java/com/google/gson/functional/MapTest.java
index f851ad561..cfc485ae4 100755
--- a/src/test/java/com/google/gson/functional/MapTest.java
+++ b/src/test/java/com/google/gson/functional/MapTest.java
@@ -30,15 +30,15 @@
 
 import com.github.gv2011.jsoncore.JsonArray;
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonParser;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.common.TestTypes;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
diff --git a/src/test/java/com/google/gson/functional/ObjectTest.java b/src/test/java/com/google/gson/functional/ObjectTest.java
index ea342681a..5a0c6196f 100644
--- a/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -18,10 +18,10 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.common.TestTypes.ArrayOfObjects;
diff --git a/src/test/java/com/google/gson/functional/PrimitiveTest.java b/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 2d0478322..d5a9c7638 100644
--- a/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -17,9 +17,9 @@
 package com.google.gson.functional;
 
 import com.github.gv2011.jsoncore.JsonPrimitive;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.LongSerializationPolicy;
 import com.google.gson.reflect.TypeToken;
 import java.io.Serializable;
diff --git a/src/test/java/com/google/gson/functional/ReadersWritersTest.java b/src/test/java/com/google/gson/functional/ReadersWritersTest.java
index e21fb903e..1995cced7 100644
--- a/src/test/java/com/google/gson/functional/ReadersWritersTest.java
+++ b/src/test/java/com/google/gson/functional/ReadersWritersTest.java
@@ -15,10 +15,10 @@
  */
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonStreamParser;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 
 import com.google.gson.reflect.TypeToken;
diff --git a/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index cec3e8fc4..db9e96b33 100644
--- a/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -23,12 +23,12 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.github.gv2011.jsoncore.imp.Streams;
 import com.google.gson.Gson;
-import com.google.gson.JsonParseException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
diff --git a/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 9041bc4e8..996926b43 100644
--- a/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -20,10 +20,10 @@
 import com.github.gv2011.jsoncore.JsonObject;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonSyntaxException;
 import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 
diff --git a/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
index f999c6c01..7cc75d2e0 100644
--- a/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
@@ -25,12 +25,12 @@
 import junit.framework.TestCase;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.reflect.TypeToken;
diff --git a/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java b/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
index b24bc1491..e5cca4015 100644
--- a/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
+++ b/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
@@ -18,12 +18,12 @@
 
 import com.github.gv2011.jsoncore.JsonElement;
 import com.github.gv2011.jsoncore.JsonObject;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.github.gv2011.jsoncore.JsonPrimitive;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import java.lang.reflect.Type;
diff --git a/src/test/java/com/google/gson/functional/UncategorizedTest.java b/src/test/java/com/google/gson/functional/UncategorizedTest.java
index ea7471c72..851601cd0 100644
--- a/src/test/java/com/google/gson/functional/UncategorizedTest.java
+++ b/src/test/java/com/google/gson/functional/UncategorizedTest.java
@@ -16,11 +16,11 @@
 package com.google.gson.functional;
 
 import com.github.gv2011.jsoncore.JsonElement;
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonParseException;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.ClassOverridingEquals;
 
diff --git a/src/test/java/com/google/gson/metrics/PerformanceTest.java b/src/test/java/com/google/gson/metrics/PerformanceTest.java
index cf444eee7..19ae3ad82 100644
--- a/src/test/java/com/google/gson/metrics/PerformanceTest.java
+++ b/src/test/java/com/google/gson/metrics/PerformanceTest.java
@@ -16,8 +16,8 @@
 
 package com.google.gson.metrics;
 
+import com.github.gv2011.jsoncore.JsonParseException;
 import com.google.gson.Gson;
-import com.google.gson.JsonParseException;
 import com.google.gson.annotations.Expose;
 import com.google.gson.reflect.TypeToken;
 
