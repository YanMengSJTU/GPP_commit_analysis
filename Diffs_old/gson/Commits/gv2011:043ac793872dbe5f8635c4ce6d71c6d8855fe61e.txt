diff --git a/LICENSE b/LICENSE
index c4097ce0f..52de5f843 100644
--- a/LICENSE
+++ b/LICENSE
@@ -189,7 +189,7 @@ Vinz Jsoncore (based on Google Gson)
       identification within third-party archives.
 
    Copyright 2008-2011 Google Inc.
-   Copyright 2016 Vinz (https://github.com/gv2011)
+   Copyright 2016 Copyright (C) 2016 Vinz (https://github.com/gv2011) (https://github.com/gv2011)
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
diff --git a/README b/README
index ebae78030..db112edeb 100644
--- a/README
+++ b/README
@@ -1,7 +1,2 @@
-Gson is a Java library that can be used to convert a Java object into its 
-JSON representation. It can also be used to convert a JSON string into an 
-equivalent Java object. Gson can work with arbitrary Java objects including 
-pre-existing objects that you do not have source-code of.
-
-Complete Gson documentation is available at its project page 
-https://github.com/google/gson
+Low level (JsonWriter and JsonReader) functionality extracted from 
+Gson (https://github.com/google/gson).
diff --git a/api/.gitignore b/api/.gitignore
new file mode 100644
index 000000000..9947b6928
--- /dev/null
+++ b/api/.gitignore
@@ -0,0 +1,4 @@
+/.settings/
+/.project
+/.classpath
+/target/
\ No newline at end of file
diff --git a/api/pom.xml b/api/pom.xml
new file mode 100644
index 000000000..883a18ba4
--- /dev/null
+++ b/api/pom.xml
@@ -0,0 +1,13 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+    <groupId>com.github.gv2011</groupId>
+    <artifactId>jsoncore</artifactId>
+    <version>0.0.3-SNAPSHOT</version>
+  </parent>
+
+	<artifactId>jsoncore-api</artifactId>
+
+</project>
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java
new file mode 100644
index 000000000..22db99c0c
--- /dev/null
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java
@@ -0,0 +1,25 @@
+package com.github.gv2011.jsoncore;
+
+import java.io.Closeable;
+
+public interface JsonParser extends Closeable{
+
+  void beginObject();
+
+  JsonToken peek();
+
+  String nextName();
+
+  void endObject();
+
+  String nextString();
+
+  boolean nextBoolean();
+
+  void beginArray();
+
+  void endArray();
+
+  void nextNull();
+
+}
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonToken.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
similarity index 97%
rename from src/main/java/com/github/gv2011/jsoncore/JsonToken.java
rename to api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
index ec1d9ec5a..ae14fc243 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/imp/.gitignore b/imp/.gitignore
new file mode 100644
index 000000000..9947b6928
--- /dev/null
+++ b/imp/.gitignore
@@ -0,0 +1,4 @@
+/.settings/
+/.project
+/.classpath
+/target/
\ No newline at end of file
diff --git a/imp/pom.xml b/imp/pom.xml
new file mode 100644
index 000000000..362db8005
--- /dev/null
+++ b/imp/pom.xml
@@ -0,0 +1,26 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>com.github.gv2011</groupId>
+		<artifactId>jsoncore</artifactId>
+		<version>0.0.3-SNAPSHOT</version>
+	</parent>
+
+	<artifactId>jsoncore-imp</artifactId>
+
+	<dependencies>
+    <dependency>
+      <groupId>com.github.gv2011</groupId>
+      <artifactId>jsoncore-api</artifactId>
+      <version>0.0.3-SNAPSHOT</version>
+    </dependency>
+    <dependency>
+      <groupId>com.github.gv2011</groupId>
+      <artifactId>util</artifactId>
+    </dependency>
+		
+	</dependencies>
+
+</project>
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonArray.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java
similarity index 94%
rename from src/main/java/com/github/gv2011/jsoncore/JsonArray.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java
index ea6a9217e..6d7881473 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonArray.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -42,8 +43,8 @@ public JsonArray() {
 
   @Override
   JsonArray deepCopy() {
-    JsonArray result = new JsonArray();
-    for (JsonElement element : elements) {
+    final JsonArray result = new JsonArray();
+    for (final JsonElement element : elements) {
       result.add(element.deepCopy());
     }
     return result;
@@ -54,7 +55,7 @@ JsonArray deepCopy() {
    *
    * @param bool the boolean that needs to be added to the array.
    */
-  public void add(Boolean bool) {
+  public void add(final Boolean bool) {
     elements.add(bool == null ? JsonNull.INSTANCE : new JsonPrimitive(bool));
   }
 
@@ -63,7 +64,7 @@ public void add(Boolean bool) {
    *
    * @param character the character that needs to be added to the array.
    */
-  public void add(Character character) {
+  public void add(final Character character) {
     elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));
   }
 
@@ -72,7 +73,7 @@ public void add(Character character) {
    *
    * @param number the number that needs to be added to the array.
    */
-  public void add(Number number) {
+  public void add(final Number number) {
     elements.add(number == null ? JsonNull.INSTANCE : new JsonPrimitive(number));
   }
 
@@ -81,7 +82,7 @@ public void add(Number number) {
    *
    * @param string the string that needs to be added to the array.
    */
-  public void add(String string) {
+  public void add(final String string) {
     elements.add(string == null ? JsonNull.INSTANCE : new JsonPrimitive(string));
   }
 
@@ -102,7 +103,7 @@ public void add(JsonElement element) {
    *
    * @param array the array whose elements need to be added to the array.
    */
-  public void addAll(JsonArray array) {
+  public void addAll(final JsonArray array) {
     elements.addAll(array.elements);
   }
 
@@ -114,7 +115,7 @@ public void addAll(JsonArray array) {
    * @return the element previously at the specified position
    * @throws IndexOutOfBoundsException if the specified index is outside the array bounds
    */
-  public JsonElement set(int index, JsonElement element) {
+  public JsonElement set(final int index, final JsonElement element) {
     return elements.set(index, element);
   }
 
@@ -125,7 +126,7 @@ public JsonElement set(int index, JsonElement element) {
    * @return true if this array contained the specified element, false otherwise
    * @since 2.3
    */
-  public boolean remove(JsonElement element) {
+  public boolean remove(final JsonElement element) {
     return elements.remove(element);
   }
 
@@ -138,7 +139,7 @@ public boolean remove(JsonElement element) {
    * @throws IndexOutOfBoundsException if the specified index is outside the array bounds
    * @since 2.3
    */
-  public JsonElement remove(int index) {
+  public JsonElement remove(final int index) {
     return elements.remove(index);
   }
 
@@ -148,7 +149,7 @@ public JsonElement remove(int index) {
    * @param element whose presence in this array is to be tested
    * @since 2.3
    */
-  public boolean contains(JsonElement element) {
+  public boolean contains(final JsonElement element) {
     return elements.contains(element);
   }
 
@@ -167,6 +168,7 @@ public int size() {
    *
    * @return an iterator to navigate the elements of the array.
    */
+  @Override
   public Iterator<JsonElement> iterator() {
     return elements.iterator();
   }
@@ -179,7 +181,7 @@ public int size() {
    * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the
    * {@link #size()} of the array.
    */
-  public JsonElement get(int i) {
+  public JsonElement get(final int i) {
     return elements.get(i);
   }
 
@@ -362,7 +364,7 @@ public boolean getAsBoolean() {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(final Object o) {
     return (o == this) || (o instanceof JsonArray && ((JsonArray) o).elements.equals(elements));
   }
 
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonElement.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
similarity index 99%
rename from src/main/java/com/github/gv2011/jsoncore/JsonElement.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
index 04a51be4c..141d77d92 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonElement.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.io.IOException;
 import java.io.StringWriter;
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonIOException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java
similarity index 81%
rename from src/main/java/com/github/gv2011/jsoncore/JsonIOException.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java
index 34c5c03dd..34a9a5be7 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonIOException.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,23 +14,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * This exception is raised when Gson was unable to read an input stream
  * or write to one.
- * 
+ *
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
 public final class JsonIOException extends JsonParseException {
   private static final long serialVersionUID = 1L;
 
-  public JsonIOException(String msg) {
+  public JsonIOException(final String msg) {
     super(msg);
   }
 
-  public JsonIOException(String msg, Throwable cause) {
+  public JsonIOException(final String msg, final Throwable cause) {
     super(msg, cause);
   }
 
@@ -39,7 +40,7 @@ public JsonIOException(String msg, Throwable cause) {
    *
    * @param cause root exception that caused this exception to be thrown.
    */
-  public JsonIOException(Throwable cause) {
+  public JsonIOException(final Throwable cause) {
     super(cause);
   }
 }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonNull.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java
similarity index 87%
rename from src/main/java/com/github/gv2011/jsoncore/JsonNull.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java
index f7fcd01b4..d4ea3ef02 100755
--- a/src/main/java/com/github/gv2011/jsoncore/JsonNull.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * A class representing a Json {@code null} value.
@@ -57,7 +58,7 @@ public int hashCode() {
    * All instances of JsonNull are the same
    */
   @Override
-  public boolean equals(Object other) {
+  public boolean equals(final Object other) {
     return this == other || other instanceof JsonNull;
   }
 }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonObject.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java
similarity index 83%
rename from src/main/java/com/github/gv2011/jsoncore/JsonObject.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java
index 9ab6c3388..6fc385e26 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonObject.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,13 +15,11 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.util.Map;
 import java.util.Set;
 
-import com.github.gv2011.jsoncore.imp.LinkedTreeMap;
-
 /**
  * A class representing an object type in Json. An object consists of name-value pairs where names
  * are strings, and values are any other type of {@link JsonElement}. This allows for a creating a
@@ -35,8 +34,8 @@
 
   @Override
   JsonObject deepCopy() {
-    JsonObject result = new JsonObject();
-    for (Map.Entry<String, JsonElement> entry : members.entrySet()) {
+    final JsonObject result = new JsonObject();
+    for (final Map.Entry<String, JsonElement> entry : members.entrySet()) {
       result.add(entry.getKey(), entry.getValue().deepCopy());
     }
     return result;
@@ -50,7 +49,7 @@ JsonObject deepCopy() {
    * @param property name of the member.
    * @param value the member object.
    */
-  public void add(String property, JsonElement value) {
+  public void add(final String property, JsonElement value) {
     if (value == null) {
       value = JsonNull.INSTANCE;
     }
@@ -64,7 +63,7 @@ public void add(String property, JsonElement value) {
    * @return the {@link JsonElement} object that is being removed.
    * @since 1.3
    */
-  public JsonElement remove(String property) {
+  public JsonElement remove(final String property) {
     return members.remove(property);
   }
 
@@ -75,7 +74,7 @@ public JsonElement remove(String property) {
    * @param property name of the member.
    * @param value the string value associated with the member.
    */
-  public void addProperty(String property, String value) {
+  public void addProperty(final String property, final String value) {
     add(property, createJsonElement(value));
   }
 
@@ -86,7 +85,7 @@ public void addProperty(String property, String value) {
    * @param property name of the member.
    * @param value the number value associated with the member.
    */
-  public void addProperty(String property, Number value) {
+  public void addProperty(final String property, final Number value) {
     add(property, createJsonElement(value));
   }
 
@@ -97,7 +96,7 @@ public void addProperty(String property, Number value) {
    * @param property name of the member.
    * @param value the number value associated with the member.
    */
-  public void addProperty(String property, Boolean value) {
+  public void addProperty(final String property, final Boolean value) {
     add(property, createJsonElement(value));
   }
 
@@ -108,7 +107,7 @@ public void addProperty(String property, Boolean value) {
    * @param property name of the member.
    * @param value the number value associated with the member.
    */
-  public void addProperty(String property, Character value) {
+  public void addProperty(final String property, final Character value) {
     add(property, createJsonElement(value));
   }
 
@@ -118,7 +117,7 @@ public void addProperty(String property, Character value) {
    * @param value the object to generate the {@link JsonElement} for
    * @return a {@link JsonPrimitive} if the {@code value} is not null, otherwise a {@link JsonNull}
    */
-  private JsonElement createJsonElement(Object value) {
+  private JsonElement createJsonElement(final Object value) {
     return value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);
   }
 
@@ -138,7 +137,7 @@ private JsonElement createJsonElement(Object value) {
    * @param memberName name of the member that is being checked for presence.
    * @return true if there is a member with the specified name, false otherwise.
    */
-  public boolean has(String memberName) {
+  public boolean has(final String memberName) {
     return members.containsKey(memberName);
   }
 
@@ -148,7 +147,7 @@ public boolean has(String memberName) {
    * @param memberName name of the member that is being requested.
    * @return the member matching the name. Null if no such member exists.
    */
-  public JsonElement get(String memberName) {
+  public JsonElement get(final String memberName) {
     return members.get(memberName);
   }
 
@@ -158,7 +157,7 @@ public JsonElement get(String memberName) {
    * @param memberName name of the member being requested.
    * @return the JsonPrimitive corresponding to the specified member.
    */
-  public JsonPrimitive getAsJsonPrimitive(String memberName) {
+  public JsonPrimitive getAsJsonPrimitive(final String memberName) {
     return (JsonPrimitive) members.get(memberName);
   }
 
@@ -168,7 +167,7 @@ public JsonPrimitive getAsJsonPrimitive(String memberName) {
    * @param memberName name of the member being requested.
    * @return the JsonArray corresponding to the specified member.
    */
-  public JsonArray getAsJsonArray(String memberName) {
+  public JsonArray getAsJsonArray(final String memberName) {
     return (JsonArray) members.get(memberName);
   }
 
@@ -178,12 +177,12 @@ public JsonArray getAsJsonArray(String memberName) {
    * @param memberName name of the member being requested.
    * @return the JsonObject corresponding to the specified member.
    */
-  public JsonObject getAsJsonObject(String memberName) {
+  public JsonObject getAsJsonObject(final String memberName) {
     return (JsonObject) members.get(memberName);
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(final Object o) {
     return (o == this) || (o instanceof JsonObject
         && ((JsonObject) o).members.equals(members));
   }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonParseException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonParseException.java
similarity index 89%
rename from src/main/java/com/github/gv2011/jsoncore/JsonParseException.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonParseException.java
index 7b22b3739..34b019fb1 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonParseException.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonParseException.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * This exception is raised if there is a serious issue that occurs during parsing of a Json
@@ -38,7 +39,7 @@
    *
    * @param msg error message describing a possible cause of this exception.
    */
-  public JsonParseException(String msg) {
+  public JsonParseException(final String msg) {
     super(msg);
   }
 
@@ -48,7 +49,7 @@ public JsonParseException(String msg) {
    * @param msg error message describing what happened.
    * @param cause root exception that caused this exception to be thrown.
    */
-  public JsonParseException(String msg, Throwable cause) {
+  public JsonParseException(final String msg, final Throwable cause) {
     super(msg, cause);
   }
 
@@ -58,7 +59,7 @@ public JsonParseException(String msg, Throwable cause) {
    *
    * @param cause root exception that caused this exception to be thrown.
    */
-  public JsonParseException(Throwable cause) {
+  public JsonParseException(final Throwable cause) {
     super(cause);
   }
 }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonPrimitive.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java
similarity index 88%
rename from src/main/java/com/github/gv2011/jsoncore/JsonPrimitive.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java
index d46d5cab5..77b0dee7e 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonPrimitive.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,14 +15,11 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
-import com.github.gv2011.jsoncore.imp.LazilyParsedNumber;
-import com.github.gv2011.jsoncore.imp.Preconditions;
-
 /**
  * A class representing a Json primitive value. A primitive value
  * is either a String, a Java primitive, or a Java primitive
@@ -43,7 +41,7 @@
    *
    * @param bool the value to create the primitive with.
    */
-  public JsonPrimitive(Boolean bool) {
+  public JsonPrimitive(final Boolean bool) {
     setValue(bool);
   }
 
@@ -52,7 +50,7 @@ public JsonPrimitive(Boolean bool) {
    *
    * @param number the value to create the primitive with.
    */
-  public JsonPrimitive(Number number) {
+  public JsonPrimitive(final Number number) {
     setValue(number);
   }
 
@@ -61,7 +59,7 @@ public JsonPrimitive(Number number) {
    *
    * @param string the value to create the primitive with.
    */
-  public JsonPrimitive(String string) {
+  public JsonPrimitive(final String string) {
     setValue(string);
   }
 
@@ -71,7 +69,7 @@ public JsonPrimitive(String string) {
    *
    * @param c the value to create the primitive with.
    */
-  public JsonPrimitive(Character c) {
+  public JsonPrimitive(final Character c) {
     setValue(c);
   }
 
@@ -81,7 +79,7 @@ public JsonPrimitive(Character c) {
    *
    * @param primitive the value to create the primitive with.
    */
-  JsonPrimitive(Object primitive) {
+  JsonPrimitive(final Object primitive) {
     setValue(primitive);
   }
 
@@ -90,16 +88,16 @@ JsonPrimitive deepCopy() {
     return this;
   }
 
-  void setValue(Object primitive) {
+  void setValue(final Object primitive) {
     if (primitive instanceof Character) {
       // convert characters to strings since in JSON, characters are represented as a single
       // character string
-      char c = ((Character) primitive).charValue();
-      this.value = String.valueOf(c);
+      final char c = ((Character) primitive).charValue();
+      value = String.valueOf(c);
     } else {
       Preconditions.checkArgument(primitive instanceof Number
               || isPrimitiveOrString(primitive));
-      this.value = primitive;
+      value = primitive;
     }
   }
 
@@ -270,13 +268,13 @@ public char getAsCharacter() {
     return getAsString().charAt(0);
   }
 
-  private static boolean isPrimitiveOrString(Object target) {
+  private static boolean isPrimitiveOrString(final Object target) {
     if (target instanceof String) {
       return true;
     }
 
-    Class<?> classOfPrimitive = target.getClass();
-    for (Class<?> standardPrimitive : PRIMITIVE_TYPES) {
+    final Class<?> classOfPrimitive = target.getClass();
+    for (final Class<?> standardPrimitive : PRIMITIVE_TYPES) {
       if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {
         return true;
       }
@@ -291,25 +289,25 @@ public int hashCode() {
     }
     // Using recommended hashing algorithm from Effective Java for longs and doubles
     if (isIntegral(this)) {
-      long value = getAsNumber().longValue();
+      final long value = getAsNumber().longValue();
       return (int) (value ^ (value >>> 32));
     }
     if (value instanceof Number) {
-      long value = Double.doubleToLongBits(getAsNumber().doubleValue());
+      final long value = Double.doubleToLongBits(getAsNumber().doubleValue());
       return (int) (value ^ (value >>> 32));
     }
     return value.hashCode();
   }
 
   @Override
-  public boolean equals(Object obj) {
+  public boolean equals(final Object obj) {
     if (this == obj) {
       return true;
     }
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    JsonPrimitive other = (JsonPrimitive)obj;
+    final JsonPrimitive other = (JsonPrimitive)obj;
     if (value == null) {
       return other.value == null;
     }
@@ -317,10 +315,10 @@ public boolean equals(Object obj) {
       return getAsNumber().longValue() == other.getAsNumber().longValue();
     }
     if (value instanceof Number && other.value instanceof Number) {
-      double a = getAsNumber().doubleValue();
+      final double a = getAsNumber().doubleValue();
       // Java standard types other than double return true for two NaN. So, need
       // special handling for double.
-      double b = other.getAsNumber().doubleValue();
+      final double b = other.getAsNumber().doubleValue();
       return a == b || (Double.isNaN(a) && Double.isNaN(b));
     }
     return value.equals(other.value);
@@ -330,9 +328,9 @@ public boolean equals(Object obj) {
    * Returns true if the specified number is an integral type
    * (Long, Integer, Short, Byte, BigInteger)
    */
-  private static boolean isIntegral(JsonPrimitive primitive) {
+  private static boolean isIntegral(final JsonPrimitive primitive) {
     if (primitive.value instanceof Number) {
-      Number number = (Number) primitive.value;
+      final Number number = (Number) primitive.value;
       return number instanceof BigInteger || number instanceof Long || number instanceof Integer
           || number instanceof Short || number instanceof Byte;
     }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonReader.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
similarity index 95%
rename from src/main/java/com/github/gv2011/jsoncore/JsonReader.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
index e4b6242e0..2a8072564 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonReader.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
@@ -15,15 +15,15 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
+
+import static com.github.gv2011.util.ex.Exceptions.call;
+import static com.github.gv2011.util.ex.Exceptions.run;
 
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.IOException;
 import java.io.Reader;
 
-import com.github.gv2011.jsoncore.imp.JsonReaderInternalAccess;
-import com.github.gv2011.jsoncore.imp.JsonTreeReader;
+import com.github.gv2011.jsoncore.JsonParser;
+import com.github.gv2011.jsoncore.JsonToken;
 
 /**
  * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
@@ -189,7 +189,7 @@
  * @author Jesse Wilson
  * @since 1.6
  */
-public class JsonReader implements Closeable {
+public class JsonReader implements JsonParser {
   /** The only non-execute prefix this parser permits */
   private static final char[] NON_EXECUTE_PREFIX = ")]}'\n".toCharArray();
   private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
@@ -339,7 +339,8 @@ public final boolean isLenient() {
    * Consumes the next token from the JSON stream and asserts that it is the
    * beginning of a new array.
    */
-  public void beginArray() throws IOException {
+  @Override
+  public void beginArray() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -358,7 +359,8 @@ public void beginArray() throws IOException {
    * Consumes the next token from the JSON stream and asserts that it is the
    * end of the current array.
    */
-  public void endArray() throws IOException {
+  @Override
+  public void endArray(){
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -377,7 +379,8 @@ public void endArray() throws IOException {
    * Consumes the next token from the JSON stream and asserts that it is the
    * beginning of a new object.
    */
-  public void beginObject() throws IOException {
+  @Override
+  public void beginObject() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -395,7 +398,8 @@ public void beginObject() throws IOException {
    * Consumes the next token from the JSON stream and asserts that it is the
    * end of the current object.
    */
-  public void endObject() throws IOException {
+  @Override
+  public void endObject(){
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -414,7 +418,7 @@ public void endObject() throws IOException {
   /**
    * Returns true if the current array or object has another element.
    */
-  public boolean hasNext() throws IOException {
+  public boolean hasNext() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -425,7 +429,8 @@ public boolean hasNext() throws IOException {
   /**
    * Returns the type of the next token without consuming it.
    */
-  public JsonToken peek() throws IOException {
+  @Override
+  public JsonToken peek() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -464,7 +469,7 @@ public JsonToken peek() throws IOException {
     }
   }
 
-  int doPeek() throws IOException {
+  int doPeek(){
     final int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
@@ -600,7 +605,7 @@ int doPeek() throws IOException {
     return peeked = PEEKED_UNQUOTED;
   }
 
-  private int peekKeyword() throws IOException {
+  private int peekKeyword() {
     // Figure out which keyword we're matching against by its first character.
     char c = buffer[pos];
     String keyword;
@@ -644,7 +649,7 @@ private int peekKeyword() throws IOException {
     return peeked = peeking;
   }
 
-  private int peekNumber() throws IOException {
+  private int peekNumber() {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
     final char[] buffer = this.buffer;
     int p = pos;
@@ -747,7 +752,7 @@ private int peekNumber() throws IOException {
     }
   }
 
-  private boolean isLiteral(final char c) throws IOException {
+  private boolean isLiteral(final char c) {
     switch (c) {
     case '/':
     case '\\':
@@ -779,7 +784,8 @@ private boolean isLiteral(final char c) throws IOException {
    * @throws java.io.IOException if the next token in the stream is not a property
    *     name.
    */
-  public String nextName() throws IOException {
+  @Override
+  public String nextName() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -808,7 +814,8 @@ public String nextName() throws IOException {
    * @throws IllegalStateException if the next token is not a string or if
    *     this reader is closed.
    */
-  public String nextString() throws IOException {
+  @Override
+  public String nextString() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -844,7 +851,8 @@ public String nextString() throws IOException {
    * @throws IllegalStateException if the next token is not a boolean or if
    *     this reader is closed.
    */
-  public boolean nextBoolean() throws IOException {
+  @Override
+  public boolean nextBoolean() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -869,7 +877,8 @@ public boolean nextBoolean() throws IOException {
    * @throws IllegalStateException if the next token is not null or if this
    *     reader is closed.
    */
-  public void nextNull() throws IOException {
+  @Override
+  public void nextNull() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -892,7 +901,7 @@ public void nextNull() throws IOException {
    * @throws NumberFormatException if the next literal value cannot be parsed
    *     as a double, or is non-finite.
    */
-  public double nextDouble() throws IOException {
+  public double nextDouble() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -938,7 +947,7 @@ public double nextDouble() throws IOException {
    * @throws NumberFormatException if the next literal value cannot be parsed
    *     as a number, or exactly represented as a long.
    */
-  public long nextLong() throws IOException {
+  public long nextLong() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -995,7 +1004,7 @@ public long nextLong() throws IOException {
    * @throws NumberFormatException if any unicode escape sequences are
    *     malformed.
    */
-  private String nextQuotedValue(final char quote) throws IOException {
+  private String nextQuotedValue(final char quote) {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
     final char[] buffer = this.buffer;
     final StringBuilder builder = new StringBuilder();
@@ -1036,7 +1045,7 @@ private String nextQuotedValue(final char quote) throws IOException {
    * Returns an unquoted value as a string.
    */
   @SuppressWarnings("fallthrough")
-  private String nextUnquotedValue() throws IOException {
+  private String nextUnquotedValue() {
     StringBuilder builder = null;
     int i = 0;
 
@@ -1097,7 +1106,7 @@ private String nextUnquotedValue() throws IOException {
     return result;
   }
 
-  private void skipQuotedValue(final char quote) throws IOException {
+  private void skipQuotedValue(final char quote) {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
     final char[] buffer = this.buffer;
     do {
@@ -1124,7 +1133,7 @@ private void skipQuotedValue(final char quote) throws IOException {
     throw syntaxError("Unterminated string");
   }
 
-  private void skipUnquotedValue() throws IOException {
+  private void skipUnquotedValue() {
     do {
       int i = 0;
       for (; pos + i < limit; i++) {
@@ -1164,7 +1173,7 @@ private void skipUnquotedValue() throws IOException {
    * @throws NumberFormatException if the next literal value cannot be parsed
    *     as a number, or exactly represented as an int.
    */
-  public int nextInt() throws IOException {
+  public int nextInt() {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -1221,11 +1230,11 @@ public int nextInt() throws IOException {
    * Closes this JSON reader and the underlying {@link java.io.Reader}.
    */
   @Override
-  public void close() throws IOException {
+  public void close() {
     peeked = PEEKED_NONE;
     stack[0] = JsonScope.CLOSED;
     stackSize = 1;
-    in.close();
+    run(in::close);
   }
 
   /**
@@ -1233,7 +1242,7 @@ public void close() throws IOException {
    * elements are skipped. This method is intended for use when the JSON token
    * stream contains unrecognized or unhandled values.
    */
-  public void skipValue() throws IOException {
+  public void skipValue() {
     int count = 0;
     do {
       int p = peeked;
@@ -1289,7 +1298,7 @@ private void push(final int newTop) {
    * exhausted before that many characters are available, this returns
    * false.
    */
-  private boolean fillBuffer(int minimum) throws IOException {
+  private boolean fillBuffer(int minimum) {
     final char[] buffer = this.buffer;
     lineStart -= pos;
     if (limit != pos) {
@@ -1301,7 +1310,7 @@ private boolean fillBuffer(int minimum) throws IOException {
 
     pos = 0;
     int total;
-    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
+    while ((total = call(()->in.read(buffer, limit, buffer.length - limit))) != -1) {
       limit += total;
 
       // if this is the first read, consume an optional byte order mark (BOM) if it exists
@@ -1332,7 +1341,7 @@ int getColumnNumber() {
    * {@code buffer[pos-1]}; this means the caller can always push back the
    * returned character by decrementing {@code pos}.
    */
-  private int nextNonWhitespace(final boolean throwOnEof) throws IOException {
+  private int nextNonWhitespace(final boolean throwOnEof) {
     /*
      * This code uses ugly local variables 'p' and 'l' representing the 'pos'
      * and 'limit' fields respectively. Using locals rather than fields saves
@@ -1415,14 +1424,14 @@ private int nextNonWhitespace(final boolean throwOnEof) throws IOException {
       }
     }
     if (throwOnEof) {
-      throw new EOFException("End of input"
+      throw new IllegalStateException("End of input"
           + " at line " + getLineNumber() + " column " + getColumnNumber());
     } else {
       return -1;
     }
   }
 
-  private void checkLenient() throws IOException {
+  private void checkLenient(){
     if (!lenient) {
       throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
     }
@@ -1433,7 +1442,7 @@ private void checkLenient() throws IOException {
    * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
    * caller.
    */
-  private void skipToEndOfLine() throws IOException {
+  private void skipToEndOfLine() {
     while (pos < limit || fillBuffer(1)) {
       final char c = buffer[pos++];
       if (c == '\n') {
@@ -1449,7 +1458,7 @@ private void skipToEndOfLine() throws IOException {
   /**
    * @param toFind a string to search for. Must not contain a newline.
    */
-  private boolean skipTo(final String toFind) throws IOException {
+  private boolean skipTo(final String toFind) {
     outer:
     for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
       if (buffer[pos] == '\n') {
@@ -1512,7 +1521,7 @@ public String getPath() {
    * @throws NumberFormatException if any unicode escape sequences are
    *     malformed.
    */
-  private char readEscapeCharacter() throws IOException {
+  private char readEscapeCharacter() {
     if (pos == limit && !fillBuffer(1)) {
       throw syntaxError("Unterminated escape sequence");
     }
@@ -1573,7 +1582,7 @@ private char readEscapeCharacter() throws IOException {
    * Throws a new IO exception with the given message and a context snippet
    * with this reader's content.
    */
-  private IOException syntaxError(final String message) throws IOException {
+  private MalformedJsonException syntaxError(final String message) {
     throw new MalformedJsonException(message
         + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
   }
@@ -1581,7 +1590,7 @@ private IOException syntaxError(final String message) throws IOException {
   /**
    * Consumes the non-execute prefix if it exists.
    */
-  private void consumeNonExecutePrefix() throws IOException {
+  private void consumeNonExecutePrefix() {
     // fast forward through the leading whitespace
     nextNonWhitespace(true);
     pos--;
@@ -1602,7 +1611,7 @@ private void consumeNonExecutePrefix() throws IOException {
 
   static {
     JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {
-      @Override public void promoteNameToValue(final JsonReader reader) throws IOException {
+      @Override public void promoteNameToValue(final JsonReader reader) {
         if (reader instanceof JsonTreeReader) {
           ((JsonTreeReader)reader).promoteNameToValue();
           return;
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
similarity index 94%
rename from src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
index a972d2dec..eee348a90 100644
--- a/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,8 +19,6 @@
 
 import java.io.IOException;
 
-import com.github.gv2011.jsoncore.JsonReader;
-
 /**
  * Internal-only APIs of JsonReader available only to other classes in Gson.
  */
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonScope.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
similarity index 97%
rename from src/main/java/com/github/gv2011/jsoncore/JsonScope.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
index 9f3d17f5c..96f003007 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonScope.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * Lexical scoping elements within a JSON reader or writer.
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java
similarity index 81%
rename from src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java
index e2ec62af5..6ade8c539 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonSyntaxException.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * This exception is raised when Gson attempts to read (or write) a malformed
@@ -26,11 +27,11 @@
 
   private static final long serialVersionUID = 1L;
 
-  public JsonSyntaxException(String msg) {
+  public JsonSyntaxException(final String msg) {
     super(msg);
   }
 
-  public JsonSyntaxException(String msg, Throwable cause) {
+  public JsonSyntaxException(final String msg, final Throwable cause) {
     super(msg, cause);
   }
 
@@ -41,7 +42,7 @@ public JsonSyntaxException(String msg, Throwable cause) {
    *
    * @param cause root exception that caused this exception to be thrown.
    */
-  public JsonSyntaxException(Throwable cause) {
+  public JsonSyntaxException(final Throwable cause) {
     super(cause);
   }
 }
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
similarity index 67%
rename from src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
index b4cb4a91e..a803f5046 100644
--- a/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,19 +17,12 @@
 
 package com.github.gv2011.jsoncore.imp;
 
-import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
-import com.github.gv2011.jsoncore.JsonArray;
-import com.github.gv2011.jsoncore.JsonElement;
-import com.github.gv2011.jsoncore.JsonNull;
-import com.github.gv2011.jsoncore.JsonObject;
-import com.github.gv2011.jsoncore.JsonPrimitive;
-import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonToken;
 
 /**
@@ -39,10 +33,10 @@
  */
 public final class JsonTreeReader extends JsonReader {
   private static final Reader UNREADABLE_READER = new Reader() {
-    @Override public int read(char[] buffer, int offset, int count) throws IOException {
+    @Override public int read(final char[] buffer, final int offset, final int count){
       throw new AssertionError();
     }
-    @Override public void close() throws IOException {
+    @Override public void close(){
       throw new AssertionError();
     }
   };
@@ -50,49 +44,49 @@
 
   private final List<Object> stack = new ArrayList<Object>();
 
-  public JsonTreeReader(JsonElement element) {
+  public JsonTreeReader(final JsonElement element) {
     super(UNREADABLE_READER);
     stack.add(element);
   }
 
-  @Override public void beginArray() throws IOException {
+  @Override public void beginArray(){
     expect(JsonToken.BEGIN_ARRAY);
-    JsonArray array = (JsonArray) peekStack();
+    final JsonArray array = (JsonArray) peekStack();
     stack.add(array.iterator());
   }
 
-  @Override public void endArray() throws IOException {
+  @Override public void endArray(){
     expect(JsonToken.END_ARRAY);
     popStack(); // empty iterator
     popStack(); // array
   }
 
-  @Override public void beginObject() throws IOException {
+  @Override public void beginObject(){
     expect(JsonToken.BEGIN_OBJECT);
-    JsonObject object = (JsonObject) peekStack();
+    final JsonObject object = (JsonObject) peekStack();
     stack.add(object.entrySet().iterator());
   }
 
-  @Override public void endObject() throws IOException {
+  @Override public void endObject(){
     expect(JsonToken.END_OBJECT);
     popStack(); // empty iterator
     popStack(); // object
   }
 
-  @Override public boolean hasNext() throws IOException {
-    JsonToken token = peek();
+  @Override public boolean hasNext(){
+    final JsonToken token = peek();
     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
   }
 
-  @Override public JsonToken peek() throws IOException {
+  @Override public JsonToken peek(){
     if (stack.isEmpty()) {
       return JsonToken.END_DOCUMENT;
     }
 
-    Object o = peekStack();
+    final Object o = peekStack();
     if (o instanceof Iterator) {
-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
-      Iterator<?> iterator = (Iterator<?>) o;
+      final boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
+      final Iterator<?> iterator = (Iterator<?>) o;
       if (iterator.hasNext()) {
         if (isObject) {
           return JsonToken.NAME;
@@ -108,7 +102,7 @@ public JsonTreeReader(JsonElement element) {
     } else if (o instanceof JsonArray) {
       return JsonToken.BEGIN_ARRAY;
     } else if (o instanceof JsonPrimitive) {
-      JsonPrimitive primitive = (JsonPrimitive) o;
+      final JsonPrimitive primitive = (JsonPrimitive) o;
       if (primitive.isString()) {
         return JsonToken.STRING;
       } else if (primitive.isBoolean()) {
@@ -135,44 +129,44 @@ private Object popStack() {
     return stack.remove(stack.size() - 1);
   }
 
-  private void expect(JsonToken expected) throws IOException {
+  private void expect(final JsonToken expected){
     if (peek() != expected) {
       throw new IllegalStateException("Expected " + expected + " but was " + peek());
     }
   }
 
-  @Override public String nextName() throws IOException {
+  @Override public String nextName(){
     expect(JsonToken.NAME);
-    Iterator<?> i = (Iterator<?>) peekStack();
-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
+    final Iterator<?> i = (Iterator<?>) peekStack();
+    final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
     stack.add(entry.getValue());
     return (String) entry.getKey();
   }
 
-  @Override public String nextString() throws IOException {
-    JsonToken token = peek();
+  @Override public String nextString(){
+    final JsonToken token = peek();
     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
       throw new IllegalStateException("Expected " + JsonToken.STRING + " but was " + token);
     }
     return ((JsonPrimitive) popStack()).getAsString();
   }
 
-  @Override public boolean nextBoolean() throws IOException {
+  @Override public boolean nextBoolean(){
     expect(JsonToken.BOOLEAN);
     return ((JsonPrimitive) popStack()).getAsBoolean();
   }
 
-  @Override public void nextNull() throws IOException {
+  @Override public void nextNull(){
     expect(JsonToken.NULL);
     popStack();
   }
 
-  @Override public double nextDouble() throws IOException {
-    JsonToken token = peek();
+  @Override public double nextDouble(){
+    final JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
       throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
     }
-    double result = ((JsonPrimitive) peekStack()).getAsDouble();
+    final double result = ((JsonPrimitive) peekStack()).getAsDouble();
     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
       throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
     }
@@ -180,32 +174,32 @@ private void expect(JsonToken expected) throws IOException {
     return result;
   }
 
-  @Override public long nextLong() throws IOException {
-    JsonToken token = peek();
+  @Override public long nextLong(){
+    final JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
       throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
     }
-    long result = ((JsonPrimitive) peekStack()).getAsLong();
+    final long result = ((JsonPrimitive) peekStack()).getAsLong();
     popStack();
     return result;
   }
 
-  @Override public int nextInt() throws IOException {
-    JsonToken token = peek();
+  @Override public int nextInt(){
+    final JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
       throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
     }
-    int result = ((JsonPrimitive) peekStack()).getAsInt();
+    final int result = ((JsonPrimitive) peekStack()).getAsInt();
     popStack();
     return result;
   }
 
-  @Override public void close() throws IOException {
+  @Override public void close(){
     stack.clear();
     stack.add(SENTINEL_CLOSED);
   }
 
-  @Override public void skipValue() throws IOException {
+  @Override public void skipValue(){
     if (peek() == JsonToken.NAME) {
       nextName();
     } else {
@@ -217,10 +211,10 @@ private void expect(JsonToken expected) throws IOException {
     return getClass().getSimpleName();
   }
 
-  public void promoteNameToValue() throws IOException {
+  public void promoteNameToValue(){
     expect(JsonToken.NAME);
-    Iterator<?> i = (Iterator<?>) peekStack();
-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
+    final Iterator<?> i = (Iterator<?>) peekStack();
+    final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
     stack.add(entry.getValue());
     stack.add(new JsonPrimitive((String)entry.getKey()));
   }
diff --git a/src/main/java/com/github/gv2011/jsoncore/JsonWriter.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
similarity index 97%
rename from src/main/java/com/github/gv2011/jsoncore/JsonWriter.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
index 8bd101715..5af60d028 100644
--- a/src/main/java/com/github/gv2011/jsoncore/JsonWriter.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
@@ -15,15 +15,15 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
-
-import static com.github.gv2011.jsoncore.JsonScope.DANGLING_NAME;
-import static com.github.gv2011.jsoncore.JsonScope.EMPTY_ARRAY;
-import static com.github.gv2011.jsoncore.JsonScope.EMPTY_DOCUMENT;
-import static com.github.gv2011.jsoncore.JsonScope.EMPTY_OBJECT;
-import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_ARRAY;
-import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_DOCUMENT;
-import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_OBJECT;
+package com.github.gv2011.jsoncore.imp;
+
+import static com.github.gv2011.jsoncore.imp.JsonScope.DANGLING_NAME;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_OBJECT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_OBJECT;
 
 import java.io.Closeable;
 import java.io.Flushable;
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
similarity index 85%
rename from src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
index 8d6caca2c..affb5c467 100644
--- a/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,7 +28,7 @@
   private final String value;
 
   /** @param value must not be null */
-  public LazilyParsedNumber(String value) {
+  public LazilyParsedNumber(final String value) {
     this.value = value;
   }
 
@@ -35,10 +36,10 @@ public LazilyParsedNumber(String value) {
   public int intValue() {
     try {
       return Integer.parseInt(value);
-    } catch (NumberFormatException e) {
+    } catch (final NumberFormatException e) {
       try {
         return (int) Long.parseLong(value);
-      } catch (NumberFormatException nfe) {
+      } catch (final NumberFormatException nfe) {
         return new BigDecimal(value).intValue();
       }
     }
@@ -48,7 +49,7 @@ public int intValue() {
   public long longValue() {
     try {
       return Long.parseLong(value);
-    } catch (NumberFormatException e) {
+    } catch (final NumberFormatException e) {
       return new BigDecimal(value).longValue();
     }
   }
@@ -83,12 +84,12 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(Object obj) {
+  public boolean equals(final Object obj) {
     if (this == obj) {
       return true;
     }
     if (obj instanceof LazilyParsedNumber) {
-      LazilyParsedNumber other = (LazilyParsedNumber) obj;
+      final LazilyParsedNumber other = (LazilyParsedNumber) obj;
       return value == other.value || value.equals(other.value);
     }
     return false;
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
similarity index 79%
rename from src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
index 336a9278c..f75a75b92 100644
--- a/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
@@ -1,6 +1,7 @@
 /*
- * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2012 Google Inc.
+ * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,7 +39,8 @@
 public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
   @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
   private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
-    public int compare(Comparable a, Comparable b) {
+    @Override
+    public int compare(final Comparable a, final Comparable b) {
       return a.compareTo(b);
     }
   };
@@ -68,7 +70,7 @@ public LinkedTreeMap() {
    *     use the natural ordering.
    */
   @SuppressWarnings({ "unchecked", "rawtypes" }) // unsafe! if comparator is null, this assumes K is comparable
-  public LinkedTreeMap(Comparator<? super K> comparator) {
+  public LinkedTreeMap(final Comparator<? super K> comparator) {
     this.comparator = comparator != null
         ? comparator
         : (Comparator) NATURAL_ORDER;
@@ -78,21 +80,21 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
     return size;
   }
 
-  @Override public V get(Object key) {
-    Node<K, V> node = findByObject(key);
+  @Override public V get(final Object key) {
+    final Node<K, V> node = findByObject(key);
     return node != null ? node.value : null;
   }
 
-  @Override public boolean containsKey(Object key) {
+  @Override public boolean containsKey(final Object key) {
     return findByObject(key) != null;
   }
 
-  @Override public V put(K key, V value) {
+  @Override public V put(final K key, final V value) {
     if (key == null) {
       throw new NullPointerException("key == null");
     }
-    Node<K, V> created = find(key, true);
-    V result = created.value;
+    final Node<K, V> created = find(key, true);
+    final V result = created.value;
     created.value = value;
     return result;
   }
@@ -103,12 +105,12 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
     modCount++;
 
     // Clear iteration order
-    Node<K, V> header = this.header;
+    final Node<K, V> header = this.header;
     header.next = header.prev = header;
   }
 
-  @Override public V remove(Object key) {
-    Node<K, V> node = removeInternalByKey(key);
+  @Override public V remove(final Object key) {
+    final Node<K, V> node = removeInternalByKey(key);
     return node != null ? node.value : null;
   }
 
@@ -118,14 +120,15 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
    * @throws ClassCastException if {@code key} and the tree's keys aren't
    *     mutually comparable.
    */
-  Node<K, V> find(K key, boolean create) {
-    Comparator<? super K> comparator = this.comparator;
+  Node<K, V> find(final K key, final boolean create) {
+    final Comparator<? super K> comparator = this.comparator;
     Node<K, V> nearest = root;
     int comparison = 0;
 
     if (nearest != null) {
       // Micro-optimization: avoid polymorphic calls to Comparator.compare().
       @SuppressWarnings("unchecked") // Throws a ClassCastException below if there's trouble.
+      final
           Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)
           ? (Comparable<Object>) key
           : null;
@@ -141,7 +144,7 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
         }
 
         // If it exists, the key is in a subtree. Go deeper.
-        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
+        final Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
         if (child == null) {
           break;
         }
@@ -156,7 +159,7 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
     }
 
     // Create the node and add it to the tree or the table.
-    Node<K, V> header = this.header;
+    final Node<K, V> header = this.header;
     Node<K, V> created;
     if (nearest == null) {
       // Check that the value is comparable if we didn't do any comparisons.
@@ -181,10 +184,10 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
   }
 
   @SuppressWarnings("unchecked")
-  Node<K, V> findByObject(Object key) {
+  Node<K, V> findByObject(final Object key) {
     try {
       return key != null ? find((K) key, false) : null;
-    } catch (ClassCastException e) {
+    } catch (final ClassCastException e) {
       return null;
     }
   }
@@ -198,13 +201,13 @@ public LinkedTreeMap(Comparator<? super K> comparator) {
    * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
    * contains()} will violate the collections API.
    */
-  Node<K, V> findByEntry(Entry<?, ?> entry) {
-    Node<K, V> mine = findByObject(entry.getKey());
-    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
+  Node<K, V> findByEntry(final Entry<?, ?> entry) {
+    final Node<K, V> mine = findByObject(entry.getKey());
+    final boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
     return valuesEqual ? mine : null;
   }
 
-  private boolean equal(Object a, Object b) {
+  private boolean equal(final Object a, final Object b) {
     return a == b || (a != null && a.equals(b));
   }
 
@@ -214,7 +217,7 @@ private boolean equal(Object a, Object b) {
    *
    * @param unlink true to also unlink this node from the iteration linked list.
    */
-  void removeInternal(Node<K, V> node, boolean unlink) {
+  void removeInternal(final Node<K, V> node, final boolean unlink) {
     if (unlink) {
       node.prev.next = node.next;
       node.next.prev = node.prev;
@@ -222,7 +225,7 @@ void removeInternal(Node<K, V> node, boolean unlink) {
 
     Node<K, V> left = node.left;
     Node<K, V> right = node.right;
-    Node<K, V> originalParent = node.parent;
+    final Node<K, V> originalParent = node.parent;
     if (left != null && right != null) {
 
       /*
@@ -234,7 +237,7 @@ void removeInternal(Node<K, V> node, boolean unlink) {
        * gone!
        */
 
-      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
+      final Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
       removeInternal(adjacent, false); // takes care of rebalance and size--
 
       int leftHeight = 0;
@@ -273,16 +276,16 @@ void removeInternal(Node<K, V> node, boolean unlink) {
     modCount++;
   }
 
-  Node<K, V> removeInternalByKey(Object key) {
-    Node<K, V> node = findByObject(key);
+  Node<K, V> removeInternalByKey(final Object key) {
+    final Node<K, V> node = findByObject(key);
     if (node != null) {
       removeInternal(node, true);
     }
     return node;
   }
 
-  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
-    Node<K, V> parent = node.parent;
+  private void replaceInParent(final Node<K, V> node, final Node<K, V> replacement) {
+    final Node<K, V> parent = node.parent;
     node.parent = null;
     if (replacement != null) {
       replacement.parent = parent;
@@ -307,21 +310,21 @@ private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
    * @param insert true if the node was unbalanced by an insert; false if it
    *     was by a removal.
    */
-  private void rebalance(Node<K, V> unbalanced, boolean insert) {
+  private void rebalance(final Node<K, V> unbalanced, final boolean insert) {
     for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
-      Node<K, V> left = node.left;
-      Node<K, V> right = node.right;
-      int leftHeight = left != null ? left.height : 0;
-      int rightHeight = right != null ? right.height : 0;
+      final Node<K, V> left = node.left;
+      final Node<K, V> right = node.right;
+      final int leftHeight = left != null ? left.height : 0;
+      final int rightHeight = right != null ? right.height : 0;
 
-      int delta = leftHeight - rightHeight;
+      final int delta = leftHeight - rightHeight;
       if (delta == -2) {
-        Node<K, V> rightLeft = right.left;
-        Node<K, V> rightRight = right.right;
-        int rightRightHeight = rightRight != null ? rightRight.height : 0;
-        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
+        final Node<K, V> rightLeft = right.left;
+        final Node<K, V> rightRight = right.right;
+        final int rightRightHeight = rightRight != null ? rightRight.height : 0;
+        final int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
 
-        int rightDelta = rightLeftHeight - rightRightHeight;
+        final int rightDelta = rightLeftHeight - rightRightHeight;
         if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
           rotateLeft(node); // AVL right right
         } else {
@@ -334,12 +337,12 @@ private void rebalance(Node<K, V> unbalanced, boolean insert) {
         }
 
       } else if (delta == 2) {
-        Node<K, V> leftLeft = left.left;
-        Node<K, V> leftRight = left.right;
-        int leftRightHeight = leftRight != null ? leftRight.height : 0;
-        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
+        final Node<K, V> leftLeft = left.left;
+        final Node<K, V> leftRight = left.right;
+        final int leftRightHeight = leftRight != null ? leftRight.height : 0;
+        final int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
 
-        int leftDelta = leftLeftHeight - leftRightHeight;
+        final int leftDelta = leftLeftHeight - leftRightHeight;
         if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
           rotateRight(node); // AVL left left
         } else {
@@ -370,11 +373,11 @@ private void rebalance(Node<K, V> unbalanced, boolean insert) {
   /**
    * Rotates the subtree so that its root's right child is the new root.
    */
-  private void rotateLeft(Node<K, V> root) {
-    Node<K, V> left = root.left;
-    Node<K, V> pivot = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
+  private void rotateLeft(final Node<K, V> root) {
+    final Node<K, V> left = root.left;
+    final Node<K, V> pivot = root.right;
+    final Node<K, V> pivotLeft = pivot.left;
+    final Node<K, V> pivotRight = pivot.right;
 
     // move the pivot's left child to the root's right
     root.right = pivotLeft;
@@ -398,11 +401,11 @@ private void rotateLeft(Node<K, V> root) {
   /**
    * Rotates the subtree so that its root's left child is the new root.
    */
-  private void rotateRight(Node<K, V> root) {
-    Node<K, V> pivot = root.left;
-    Node<K, V> right = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
+  private void rotateRight(final Node<K, V> root) {
+    final Node<K, V> pivot = root.left;
+    final Node<K, V> right = root.right;
+    final Node<K, V> pivotLeft = pivot.left;
+    final Node<K, V> pivotRight = pivot.right;
 
     // move the pivot's right child to the root's left
     root.left = pivotRight;
@@ -427,12 +430,12 @@ private void rotateRight(Node<K, V> root) {
   private KeySet keySet;
 
   @Override public Set<Entry<K, V>> entrySet() {
-    EntrySet result = entrySet;
+    final EntrySet result = entrySet;
     return result != null ? result : (entrySet = new EntrySet());
   }
 
   @Override public Set<K> keySet() {
-    KeySet result = keySet;
+    final KeySet result = keySet;
     return result != null ? result : (keySet = new KeySet());
   }
 
@@ -453,7 +456,7 @@ private void rotateRight(Node<K, V> root) {
     }
 
     /** Create a regular entry */
-    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {
+    Node(final Node<K, V> parent, final K key, final Node<K, V> next, final Node<K, V> prev) {
       this.parent = parent;
       this.key = key;
       this.height = 1;
@@ -463,24 +466,27 @@ private void rotateRight(Node<K, V> root) {
       next.prev = this;
     }
 
+    @Override
     public K getKey() {
       return key;
     }
 
+    @Override
     public V getValue() {
       return value;
     }
 
-    public V setValue(V value) {
-      V oldValue = this.value;
+    @Override
+    public V setValue(final V value) {
+      final V oldValue = this.value;
       this.value = value;
       return oldValue;
     }
 
     @SuppressWarnings("rawtypes")
-    @Override public boolean equals(Object o) {
+    @Override public boolean equals(final Object o) {
       if (o instanceof Entry) {
-        Entry other = (Entry) o;
+        final Entry other = (Entry) o;
         return (key == null ? other.getKey() == null : key.equals(other.getKey()))
             && (value == null ? other.getValue() == null : value.equals(other.getValue()));
       }
@@ -531,12 +537,13 @@ public V setValue(V value) {
     LinkedTreeMapIterator() {
     }
 
+    @Override
     public final boolean hasNext() {
       return next != header;
     }
 
     final Node<K, V> nextNode() {
-      Node<K, V> e = next;
+      final Node<K, V> e = next;
       if (e == header) {
         throw new NoSuchElementException();
       }
@@ -547,6 +554,7 @@ public final boolean hasNext() {
       return lastReturned = e;
     }
 
+    @Override
     public final void remove() {
       if (lastReturned == null) {
         throw new IllegalStateException();
@@ -564,22 +572,23 @@ public final void remove() {
 
     @Override public Iterator<Entry<K, V>> iterator() {
       return new LinkedTreeMapIterator<Entry<K, V>>() {
+        @Override
         public Entry<K, V> next() {
           return nextNode();
         }
       };
     }
 
-    @Override public boolean contains(Object o) {
+    @Override public boolean contains(final Object o) {
       return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
     }
 
-    @Override public boolean remove(Object o) {
+    @Override public boolean remove(final Object o) {
       if (!(o instanceof Entry)) {
         return false;
       }
 
-      Node<K, V> node = findByEntry((Entry<?, ?>) o);
+      final Node<K, V> node = findByEntry((Entry<?, ?>) o);
       if (node == null) {
         return false;
       }
@@ -599,17 +608,18 @@ public final void remove() {
 
     @Override public Iterator<K> iterator() {
       return new LinkedTreeMapIterator<K>() {
+        @Override
         public K next() {
           return nextNode().key;
         }
       };
     }
 
-    @Override public boolean contains(Object o) {
+    @Override public boolean contains(final Object o) {
       return containsKey(o);
     }
 
-    @Override public boolean remove(Object key) {
+    @Override public boolean remove(final Object key) {
       return removeInternalByKey(key) != null;
     }
 
diff --git a/src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/MalformedJsonException.java
similarity index 77%
rename from src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/MalformedJsonException.java
index e05a2c74b..fee7cfcb7 100644
--- a/src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/MalformedJsonException.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,29 +15,27 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
-
-import java.io.IOException;
+package com.github.gv2011.jsoncore.imp;
 
 /**
  * Thrown when a reader encounters malformed JSON. Some syntax errors can be
  * ignored by calling {@link JsonReader#setLenient(boolean)}.
  */
-public final class MalformedJsonException extends IOException {
+public final class MalformedJsonException extends RuntimeException {
   private static final long serialVersionUID = 1L;
 
-  public MalformedJsonException(String msg) {
+  public MalformedJsonException(final String msg) {
     super(msg);
   }
 
-  public MalformedJsonException(String msg, Throwable throwable) {
+  public MalformedJsonException(final String msg, final Throwable throwable) {
     super(msg);
     // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
     // with a constructor with Throwable. This was done in Java 1.6
     initCause(throwable);
   }
 
-  public MalformedJsonException(Throwable throwable) {
+  public MalformedJsonException(final Throwable throwable) {
     // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
     // with a constructor with Throwable. This was done in Java 1.6
     initCause(throwable);
diff --git a/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
similarity index 83%
rename from src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
index 68fbc7444..3c05467a8 100644
--- a/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,19 +30,20 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Deprecated
 public final class Preconditions {
   private Preconditions() {
     throw new UnsupportedOperationException();
   }
 
-  public static <T> T checkNotNull(T obj) {
+  public static <T> T checkNotNull(final T obj) {
     if (obj == null) {
       throw new NullPointerException();
     }
     return obj;
   }
 
-  public static void checkArgument(boolean condition) {
+  public static void checkArgument(final boolean condition) {
     if (!condition) {
       throw new IllegalArgumentException();
     }
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonArrayTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java
similarity index 73%
rename from src/test/java/com/github/gv2011/jsoncore/JsonArrayTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java
index a73945755..43a3a0d12 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonArrayTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,14 +15,14 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
-import junit.framework.TestCase;
+import com.github.gv2011.jsoncore.imp.JsonArray;
+import com.github.gv2011.jsoncore.imp.JsonNull;
+import com.github.gv2011.jsoncore.imp.JsonObject;
+import com.github.gv2011.jsoncore.imp.JsonPrimitive;
 
-import com.github.gv2011.jsoncore.JsonArray;
-import com.github.gv2011.jsoncore.JsonNull;
-import com.github.gv2011.jsoncore.JsonObject;
-import com.github.gv2011.jsoncore.JsonPrimitive;
+import junit.framework.TestCase;
 
 /**
  * @author Jesse Wilson
@@ -33,8 +34,8 @@ public void testEqualsOnEmptyArray() {
   }
 
   public void testEqualsNonEmptyArray() {
-    JsonArray a = new JsonArray();
-    JsonArray b = new JsonArray();
+    final JsonArray a = new JsonArray();
+    final JsonArray b = new JsonArray();
 
     assertEquals(a, a);
 
@@ -55,12 +56,12 @@ public void testEqualsNonEmptyArray() {
   }
 
   public void testRemove() {
-    JsonArray array = new JsonArray();
+    final JsonArray array = new JsonArray();
     try {
       array.remove(0);
       fail();
-    } catch (IndexOutOfBoundsException expected) {}
-    JsonPrimitive a = new JsonPrimitive("a");
+    } catch (final IndexOutOfBoundsException expected) {}
+    final JsonPrimitive a = new JsonPrimitive("a");
     array.add(a);
     assertTrue(array.remove(a));
     assertFalse(array.contains(a));
@@ -72,12 +73,12 @@ public void testRemove() {
   }
 
   public void testSet() {
-    JsonArray array = new JsonArray();
+    final JsonArray array = new JsonArray();
     try {
       array.set(0, new JsonPrimitive(1));
       fail();
-    } catch (IndexOutOfBoundsException expected) {}
-    JsonPrimitive a = new JsonPrimitive("a");
+    } catch (final IndexOutOfBoundsException expected) {}
+    final JsonPrimitive a = new JsonPrimitive("a");
     array.add(a);
     array.set(0, new JsonPrimitive("b"));
     assertEquals("b", array.get(0).getAsString());
@@ -89,11 +90,11 @@ public void testSet() {
   }
 
   public void testDeepCopy() {
-    JsonArray original = new JsonArray();
-    JsonArray firstEntry = new JsonArray();
+    final JsonArray original = new JsonArray();
+    final JsonArray firstEntry = new JsonArray();
     original.add(firstEntry);
 
-    JsonArray copy = original.deepCopy();
+    final JsonArray copy = original.deepCopy();
     original.add(new JsonPrimitive("y"));
 
     assertEquals(1, copy.size());
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonNullTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java
similarity index 89%
rename from src/test/java/com/github/gv2011/jsoncore/JsonNullTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java
index f4b6bc8b1..b40b5398a 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonNullTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,9 +15,9 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
-import com.github.gv2011.jsoncore.JsonNull;
+import com.github.gv2011.jsoncore.imp.JsonNull;
 
 import junit.framework.TestCase;
 
@@ -34,6 +35,7 @@ public void testEqualsAndHashcode() {
 
   public void testDeepCopy() {
     @SuppressWarnings("deprecation")
+    final
     JsonNull a = new JsonNull();
     assertSame(JsonNull.INSTANCE, a.deepCopy());
     assertSame(JsonNull.INSTANCE, JsonNull.INSTANCE.deepCopy());
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonObjectTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java
similarity index 92%
rename from src/test/java/com/github/gv2011/jsoncore/JsonObjectTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java
index 3a2a51b4b..34b50ca42 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonObjectTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,13 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
+
+import com.github.gv2011.jsoncore.imp.JsonArray;
+import com.github.gv2011.jsoncore.imp.JsonElement;
+import com.github.gv2011.jsoncore.imp.JsonNull;
+import com.github.gv2011.jsoncore.imp.JsonObject;
+import com.github.gv2011.jsoncore.imp.JsonPrimitive;
 
 import junit.framework.TestCase;
 
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonPrimitiveTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java
similarity index 75%
rename from src/test/java/com/github/gv2011/jsoncore/JsonPrimitiveTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java
index bfa379c00..6b4ffc3be 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonPrimitiveTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,15 +15,15 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
-
-import com.github.gv2011.jsoncore.JsonPrimitive;
-
-import junit.framework.TestCase;
+package com.github.gv2011.jsoncore.imp;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
+import com.github.gv2011.jsoncore.imp.JsonPrimitive;
+
+import junit.framework.TestCase;
+
 /**
  * Unit test for the {@link JsonPrimitive} class.
  *
@@ -54,14 +55,14 @@ public void testBoolean() throws Exception {
   }
 
   public void testParsingStringAsBoolean() throws Exception {
-    JsonPrimitive json = new JsonPrimitive("true");
+    final JsonPrimitive json = new JsonPrimitive("true");
 
     assertFalse(json.isBoolean());
     assertTrue(json.getAsBoolean());
   }
 
   public void testParsingStringAsNumber() throws Exception {
-    JsonPrimitive json = new JsonPrimitive("1");
+    final JsonPrimitive json = new JsonPrimitive("1");
 
     assertFalse(json.isNumber());
     assertEquals(1D, json.getAsDouble(), 0.00001);
@@ -87,7 +88,7 @@ public void testStringsAndChar() throws Exception {
   }
 
   public void testExponential() throws Exception {
-    JsonPrimitive json = new JsonPrimitive("1E+7");
+    final JsonPrimitive json = new JsonPrimitive("1E+7");
 
     assertEquals(new BigDecimal("1E+7"), json.getAsBigDecimal());
     assertEquals(new Double("1E+7"), json.getAsDouble(), 0.00001);
@@ -96,96 +97,96 @@ public void testExponential() throws Exception {
     try {
       json.getAsInt();
       fail("Integers can not handle exponents like this.");
-    } catch (NumberFormatException expected) { }
+    } catch (final NumberFormatException expected) { }
   }
 
   public void testByteEqualsShort() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Short((short)10));
+    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Short((short)10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
+    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
+    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
+    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10));
+    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Long(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testIntegerEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
+    final JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
+    final JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testIntegerEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
-    JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testLongEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Long(10L));
-    JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Long(10L));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testFloatEqualsDouble() {
-    JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
-    JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D));
+    final JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
+    final JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testFloatEqualsBigDecimal() {
-    JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
-    JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testDoubleEqualsBigDecimal() {
-    JsonPrimitive p1 = new JsonPrimitive(new Double(10.25D));
-    JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
+    final JsonPrimitive p1 = new JsonPrimitive(new Double(10.25D));
+    final JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
@@ -227,9 +228,9 @@ public void testEqualsAcrossTypes() {
   }
 
   public void testEqualsIntegerAndBigInteger() {
-    JsonPrimitive a = new JsonPrimitive(5L);
-    JsonPrimitive b = new JsonPrimitive(new BigInteger("18446744073709551621")); // 2^64 + 5
-    // Ideally, the following assertion should have failed but the price is too much to pay 
+    final JsonPrimitive a = new JsonPrimitive(5L);
+    final JsonPrimitive b = new JsonPrimitive(new BigInteger("18446744073709551621")); // 2^64 + 5
+    // Ideally, the following assertion should have failed but the price is too much to pay
     // assertFalse(a + " equals " + b, a.equals(b));
     assertTrue(a + " equals " + b, a.equals(b));
   }
@@ -241,7 +242,7 @@ public void testEqualsDoesNotEquateStringAndNonStringTypes() {
   }
 
   public void testDeepCopy() {
-    JsonPrimitive a = new JsonPrimitive("a");
+    final JsonPrimitive a = new JsonPrimitive("a");
     assertSame(a, a.deepCopy()); // Primitives are immutable!
   }
 }
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonReaderPathTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
similarity index 87%
rename from src/test/java/com/github/gv2011/jsoncore/JsonReaderPathTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
index ec56e4589..04b589525 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonReaderPathTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2014 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,19 +15,19 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.io.IOException;
 import java.io.StringReader;
 
-import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.imp.JsonReader;
 
 import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
 public class JsonReaderPathTest extends TestCase {
   public void testPath() throws IOException {
-    JsonReader reader = new JsonReader(
+    final JsonReader reader = new JsonReader(
         new StringReader("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}"));
     assertEquals("$", reader.getPath());
     reader.beginObject();
@@ -66,7 +67,7 @@ public void testPath() throws IOException {
   }
 
   public void testObjectPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -106,7 +107,7 @@ public void testObjectPath() throws IOException {
   }
 
   public void testArrayPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2]"));
+    final JsonReader reader = new JsonReader(new StringReader("[1,2]"));
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -136,7 +137,7 @@ public void testArrayPath() throws IOException {
   }
 
   public void testMultipleTopLevelValuesInOneDocument() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[][]"));
+    final JsonReader reader = new JsonReader(new StringReader("[][]"));
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -147,7 +148,7 @@ public void testMultipleTopLevelValuesInOneDocument() throws IOException {
   }
 
   public void testSkipArrayElements() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2,3]"));
+    final JsonReader reader = new JsonReader(new StringReader("[1,2,3]"));
     reader.beginArray();
     reader.skipValue();
     reader.skipValue();
@@ -155,14 +156,14 @@ public void testSkipArrayElements() throws IOException {
   }
 
   public void testSkipObjectNames() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1}"));
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1}"));
     reader.beginObject();
     reader.skipValue();
     assertEquals("$.null", reader.getPath());
   }
 
   public void testSkipObjectValues() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
     reader.beginObject();
     reader.nextName();
     reader.skipValue();
@@ -172,14 +173,14 @@ public void testSkipObjectValues() throws IOException {
   }
 
   public void testSkipNestedStructures() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[1,2,3],4]"));
+    final JsonReader reader = new JsonReader(new StringReader("[[1,2,3],4]"));
     reader.beginArray();
     reader.skipValue();
     assertEquals("$[1]", reader.getPath());
   }
 
   public void testArrayOfObjects() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[{},{},{}]"));
+    final JsonReader reader = new JsonReader(new StringReader("[{},{},{}]"));
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginObject();
@@ -199,7 +200,7 @@ public void testArrayOfObjects() throws IOException {
   }
 
   public void testArrayOfArrays() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[],[],[]]"));
+    final JsonReader reader = new JsonReader(new StringReader("[[],[],[]]"));
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginArray();
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonReaderTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
similarity index 59%
rename from src/test/java/com/github/gv2011/jsoncore/JsonReaderTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
index 64ab03cfc..a306a74cb 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonReaderTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import static com.github.gv2011.jsoncore.JsonToken.BEGIN_ARRAY;
 import static com.github.gv2011.jsoncore.JsonToken.BEGIN_OBJECT;
@@ -26,22 +27,18 @@
 import static com.github.gv2011.jsoncore.JsonToken.NUMBER;
 import static com.github.gv2011.jsoncore.JsonToken.STRING;
 
-import java.io.EOFException;
-import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.Arrays;
 
-import com.github.gv2011.jsoncore.JsonReader;
 import com.github.gv2011.jsoncore.JsonToken;
-import com.github.gv2011.jsoncore.MalformedJsonException;
 
 import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
 public final class JsonReaderTest extends TestCase {
-  public void testReadArray() throws IOException {
-    JsonReader reader = new JsonReader(reader("[true, true]"));
+  public void testReadArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true, true]"));
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     assertEquals(true, reader.nextBoolean());
@@ -49,16 +46,16 @@ public void testReadArray() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testReadEmptyArray() throws IOException {
-    JsonReader reader = new JsonReader(reader("[]"));
+  public void testReadEmptyArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[]"));
     reader.beginArray();
     assertFalse(reader.hasNext());
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testReadObject() throws IOException {
-    JsonReader reader = new JsonReader(reader(
+  public void testReadObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\": \"android\", \"b\": \"banana\"}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -69,16 +66,16 @@ public void testReadObject() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testReadEmptyObject() throws IOException {
-    JsonReader reader = new JsonReader(reader("{}"));
+  public void testReadEmptyObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{}"));
     reader.beginObject();
     assertFalse(reader.hasNext());
     reader.endObject();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testSkipArray() throws IOException {
-    JsonReader reader = new JsonReader(reader(
+  public void testSkipArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -90,7 +87,7 @@ public void testSkipArray() throws IOException {
   }
 
   public void testSkipArrayAfterPeek() throws Exception {
-    JsonReader reader = new JsonReader(reader(
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -103,14 +100,14 @@ public void testSkipArrayAfterPeek() throws Exception {
   }
 
   public void testSkipTopLevelObject() throws Exception {
-    JsonReader reader = new JsonReader(reader(
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testSkipObject() throws IOException {
-    JsonReader reader = new JsonReader(reader(
+  public void testSkipObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\": { \"c\": [], \"d\": [true, true, {}] }, \"b\": \"banana\"}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -122,9 +119,9 @@ public void testSkipObject() throws IOException {
   }
 
   public void testSkipObjectAfterPeek() throws Exception {
-    String json = "{" + "  \"one\": { \"num\": 1 }"
+    final String json = "{" + "  \"one\": { \"num\": 1 }"
         + ", \"two\": { \"num\": 2 }" + ", \"three\": { \"num\": 3 }" + "}";
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginObject();
     assertEquals("one", reader.nextName());
     assertEquals(BEGIN_OBJECT, reader.peek());
@@ -138,8 +135,8 @@ public void testSkipObjectAfterPeek() throws Exception {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testSkipInteger() throws IOException {
-    JsonReader reader = new JsonReader(reader(
+  public void testSkipInteger() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\":123456789,\"b\":-123456789}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -150,8 +147,8 @@ public void testSkipInteger() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testSkipDouble() throws IOException {
-    JsonReader reader = new JsonReader(reader(
+  public void testSkipDouble() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
         "{\"a\":-123.456e-789,\"b\":123456789.0}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -162,12 +159,12 @@ public void testSkipDouble() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testHelloWorld() throws IOException {
-    String json = "{\n" +
+  public void testHelloWorld() throws MalformedJsonException {
+    final String json = "{\n" +
         "   \"hello\": true,\n" +
         "   \"foo\": [\"world\"]\n" +
         "}";
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginObject();
     assertEquals("hello", reader.nextName());
     assertEquals(true, reader.nextBoolean());
@@ -183,7 +180,7 @@ public void testNulls() {
     try {
       new JsonReader(null);
       fail();
-    } catch (NullPointerException expected) {
+    } catch (final NullPointerException expected) {
     }
   }
 
@@ -191,17 +188,17 @@ public void testEmptyString() {
     try {
       new JsonReader(reader("")).beginArray();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
     try {
       new JsonReader(reader("")).beginObject();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testCharacterUnescaping() throws IOException {
-    String json = "[\"a\","
+  public void testCharacterUnescaping() throws MalformedJsonException {
+    final String json = "[\"a\","
         + "\"a\\\"\","
         + "\"\\\"\","
         + "\":\","
@@ -221,7 +218,7 @@ public void testCharacterUnescaping() throws IOException {
         + "\"\\u0019\","
         + "\"\\u20AC\""
         + "]";
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     assertEquals("a", reader.nextString());
     assertEquals("a\"", reader.nextString());
@@ -246,49 +243,49 @@ public void testCharacterUnescaping() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testUnescapingInvalidCharacters() throws IOException {
-    String json = "[\"\\u000g\"]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testUnescapingInvalidCharacters() throws MalformedJsonException {
+    final String json = "[\"\\u000g\"]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
   }
 
-  public void testUnescapingTruncatedCharacters() throws IOException {
-    String json = "[\"\\u000";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testUnescapingTruncatedCharacters() throws MalformedJsonException {
+    final String json = "[\"\\u000";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testUnescapingTruncatedSequence() throws IOException {
-    String json = "[\"\\";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testUnescapingTruncatedSequence() throws MalformedJsonException {
+    final String json = "[\"\\";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testIntegersWithFractionalPartSpecified() throws IOException {
-    JsonReader reader = new JsonReader(reader("[1.0,1.0,1.0]"));
+  public void testIntegersWithFractionalPartSpecified() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1.0,1.0,1.0]"));
     reader.beginArray();
     assertEquals(1.0, reader.nextDouble());
     assertEquals(1, reader.nextInt());
     assertEquals(1L, reader.nextLong());
   }
 
-  public void testDoubles() throws IOException {
-    String json = "[-0.0,"
+  public void testDoubles() throws MalformedJsonException {
+    final String json = "[-0.0,"
         + "1.0,"
         + "1.7976931348623157E308,"
         + "4.9E-324,"
@@ -297,7 +294,7 @@ public void testDoubles() throws IOException {
         + "2.2250738585072014E-308,"
         + "3.141592653589793,"
         + "2.718281828459045]";
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     assertEquals(-0.0, reader.nextDouble());
     assertEquals(1.0, reader.nextDouble());
@@ -312,31 +309,31 @@ public void testDoubles() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testStrictNonFiniteDoubles() throws IOException {
-    String json = "[NaN]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testStrictNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[NaN]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.nextDouble();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictQuotedNonFiniteDoubles() throws IOException {
-    String json = "[\"NaN\"]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testStrictQuotedNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[\"NaN\"]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.nextDouble();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientNonFiniteDoubles() throws IOException {
-    String json = "[NaN, -Infinity, Infinity]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testLenientNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[NaN, -Infinity, Infinity]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.setLenient(true);
     reader.beginArray();
     assertTrue(Double.isNaN(reader.nextDouble()));
@@ -345,9 +342,9 @@ public void testLenientNonFiniteDoubles() throws IOException {
     reader.endArray();
   }
 
-  public void testLenientQuotedNonFiniteDoubles() throws IOException {
-    String json = "[\"NaN\", \"-Infinity\", \"Infinity\"]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testLenientQuotedNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[\"NaN\", \"-Infinity\", \"Infinity\"]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.setLenient(true);
     reader.beginArray();
     assertTrue(Double.isNaN(reader.nextDouble()));
@@ -356,24 +353,24 @@ public void testLenientQuotedNonFiniteDoubles() throws IOException {
     reader.endArray();
   }
 
-  public void testStrictNonFiniteDoublesWithSkipValue() throws IOException {
-    String json = "[NaN]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void testStrictNonFiniteDoublesWithSkipValue() throws MalformedJsonException {
+    final String json = "[NaN]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.skipValue();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLongs() throws IOException {
-    String json = "[0,0,0,"
+  public void testLongs() throws MalformedJsonException {
+    final String json = "[0,0,0,"
         + "1,1,1,"
         + "-1,-1,-1,"
         + "-9223372036854775808,"
         + "9223372036854775807]";
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     assertEquals(0L, reader.nextLong());
     assertEquals(0, reader.nextInt());
@@ -387,50 +384,50 @@ public void testLongs() throws IOException {
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals(Long.MIN_VALUE, reader.nextLong());
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals(Long.MAX_VALUE, reader.nextLong());
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void disabled_testNumberWithOctalPrefix() throws IOException {
-    String json = "[01]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void disabled_testNumberWithOctalPrefix() throws MalformedJsonException {
+    final String json = "[01]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     try {
       reader.peek();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
     try {
       reader.nextInt();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
     try {
       reader.nextLong();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
     try {
       reader.nextDouble();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
     assertEquals("01", reader.nextString());
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testBooleans() throws IOException {
-    JsonReader reader = new JsonReader(reader("[true,false]"));
+  public void testBooleans() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true,false]"));
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     assertEquals(false, reader.nextBoolean());
@@ -438,21 +435,21 @@ public void testBooleans() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testPeekingUnquotedStringsPrefixedWithBooleans() throws IOException {
-    JsonReader reader = new JsonReader(reader("[truey]"));
+  public void testPeekingUnquotedStringsPrefixedWithBooleans() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[truey]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     try {
       reader.nextBoolean();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     assertEquals("truey", reader.nextString());
     reader.endArray();
   }
 
-  public void testMalformedNumbers() throws IOException {
+  public void testMalformedNumbers() throws MalformedJsonException {
     assertNotANumber("-");
     assertNotANumber(".");
 
@@ -489,8 +486,8 @@ public void testMalformedNumbers() throws IOException {
     assertNotANumber("-.0e1");
   }
 
-  private void assertNotANumber(String s) throws IOException {
-    JsonReader reader = new JsonReader(reader("[" + s + "]"));
+  private void assertNotANumber(final String s) throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[" + s + "]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
@@ -498,56 +495,56 @@ private void assertNotANumber(String s) throws IOException {
     reader.endArray();
   }
 
-  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {
-    JsonReader reader = new JsonReader(reader("[12.34e5x]"));
+  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[12.34e5x]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals("12.34e5x", reader.nextString());
   }
 
-  public void testPeekLongMinValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[-9223372036854775808]"));
+  public void testPeekLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775808]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     assertEquals(-9223372036854775808L, reader.nextLong());
   }
 
-  public void testPeekLongMaxValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[9223372036854775807]"));
+  public void testPeekLongMaxValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[9223372036854775807]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     assertEquals(9223372036854775807L, reader.nextLong());
   }
 
-  public void testLongLargerThanMaxLongThatWrapsAround() throws IOException {
-    JsonReader reader = new JsonReader(reader("[22233720368547758070]"));
+  public void testLongLargerThanMaxLongThatWrapsAround() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[22233720368547758070]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
   }
 
-  public void testLongLargerThanMinLongThatWrapsAround() throws IOException {
-    JsonReader reader = new JsonReader(reader("[-22233720368547758070]"));
+  public void testLongLargerThanMinLongThatWrapsAround() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-22233720368547758070]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
   }
 
@@ -555,15 +552,15 @@ public void testLongLargerThanMinLongThatWrapsAround() throws IOException {
    * This test fails because there's no double for 9223372036854775808, and our
    * long parsing uses Double.parseDouble() for fractional values.
    */
-  public void disabled_testPeekLargerThanLongMaxValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[9223372036854775808]"));
+  public void disabled_testPeekLargerThanLongMaxValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[9223372036854775808]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException e) {
+    } catch (final NumberFormatException e) {
     }
   }
 
@@ -571,15 +568,15 @@ public void disabled_testPeekLargerThanLongMaxValue() throws IOException {
    * This test fails because there's no double for -9223372036854775809, and our
    * long parsing uses Double.parseDouble() for fractional values.
    */
-  public void disabled_testPeekLargerThanLongMinValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[-9223372036854775809]"));
+  public void disabled_testPeekLargerThanLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775809]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals(-9223372036854775809d, reader.nextDouble());
   }
@@ -588,37 +585,37 @@ public void disabled_testPeekLargerThanLongMinValue() throws IOException {
    * This test fails because there's no double for 9223372036854775806, and
    * our long parsing uses Double.parseDouble() for fractional values.
    */
-  public void disabled_testHighPrecisionLong() throws IOException {
-    String json = "[9223372036854775806.000]";
-    JsonReader reader = new JsonReader(reader(json));
+  public void disabled_testHighPrecisionLong() throws MalformedJsonException {
+    final String json = "[9223372036854775806.000]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     assertEquals(9223372036854775806L, reader.nextLong());
     reader.endArray();
   }
 
-  public void testPeekMuchLargerThanLongMinValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[-92233720368547758080]"));
+  public void testPeekMuchLargerThanLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-92233720368547758080]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals(-92233720368547758080d, reader.nextDouble());
   }
 
-  public void testQuotedNumberWithEscape() throws IOException {
-    JsonReader reader = new JsonReader(reader("[\"12\u00334\"]"));
+  public void testQuotedNumberWithEscape() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"12\u00334\"]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     assertEquals(1234, reader.nextInt());
   }
 
-  public void testMixedCaseLiterals() throws IOException {
-    JsonReader reader = new JsonReader(reader("[True,TruE,False,FALSE,NULL,nulL]"));
+  public void testMixedCaseLiterals() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[True,TruE,False,FALSE,NULL,nulL]"));
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     assertEquals(true, reader.nextBoolean());
@@ -630,159 +627,159 @@ public void testMixedCaseLiterals() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testMissingValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":}"));
+  public void testMissingValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     try {
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testPrematureEndOfInput() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":true,"));
+  public void testPrematureEndOfInput() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true,"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals(true, reader.nextBoolean());
     try {
       reader.nextName();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testPrematurelyClosed() throws IOException {
+  public void testPrematurelyClosed() throws MalformedJsonException {
     try {
-      JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
+      final JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
       reader.beginObject();
       reader.close();
       reader.nextName();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
 
     try {
-      JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
+      final JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
       reader.close();
       reader.beginObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
 
     try {
-      JsonReader reader = new JsonReader(reader("{\"a\":true}"));
+      final JsonReader reader = new JsonReader(reader("{\"a\":true}"));
       reader.beginObject();
       reader.nextName();
       reader.peek();
       reader.close();
       reader.nextBoolean();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
-  public void testNextFailuresDoNotAdvance() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":true}"));
+  public void testNextFailuresDoNotAdvance() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true}"));
     reader.beginObject();
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     assertEquals("a", reader.nextName());
     try {
       reader.nextName();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.beginObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.endObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     assertEquals(true, reader.nextBoolean());
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.nextName();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       reader.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     reader.endObject();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
     reader.close();
   }
 
-  public void testIntegerMismatchFailuresDoNotAdvance() throws IOException {
-    JsonReader reader = new JsonReader(reader("[1.5]"));
+  public void testIntegerMismatchFailuresDoNotAdvance() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1.5]"));
     reader.beginArray();
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (final NumberFormatException expected) {
     }
     assertEquals(1.5d, reader.nextDouble());
     reader.endArray();
   }
 
-  public void testStringNullIsNotNull() throws IOException {
-    JsonReader reader = new JsonReader(reader("[\"null\"]"));
+  public void testStringNullIsNotNull() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"null\"]"));
     reader.beginArray();
     try {
       reader.nextNull();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
-  public void testNullLiteralIsNotAString() throws IOException {
-    JsonReader reader = new JsonReader(reader("[null]"));
+  public void testNullLiteralIsNotAString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[null]"));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
-  public void testStrictNameValueSeparator() throws IOException {
+  public void testStrictNameValueSeparator() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     try {
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("{\"a\"=>true}"));
@@ -791,11 +788,11 @@ public void testStrictNameValueSeparator() throws IOException {
     try {
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientNameValueSeparator() throws IOException {
+  public void testLenientNameValueSeparator() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
     reader.setLenient(true);
     reader.beginObject();
@@ -809,14 +806,14 @@ public void testLenientNameValueSeparator() throws IOException {
     assertEquals(true, reader.nextBoolean());
   }
 
-  public void testStrictNameValueSeparatorWithSkipValue() throws IOException {
+  public void testStrictNameValueSeparatorWithSkipValue() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("{\"a\"=>true}"));
@@ -825,7 +822,7 @@ public void testStrictNameValueSeparatorWithSkipValue() throws IOException {
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
@@ -848,13 +845,13 @@ public void testCommentsInStringValue() throws Exception {
     reader.endObject();
   }
 
-  public void testStrictComments() throws IOException {
+  public void testStrictComments() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[// comment \n true]"));
     reader.beginArray();
     try {
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[# comment \n true]"));
@@ -862,7 +859,7 @@ public void testStrictComments() throws IOException {
     try {
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[/* comment */ true]"));
@@ -870,11 +867,11 @@ public void testStrictComments() throws IOException {
     try {
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientComments() throws IOException {
+  public void testLenientComments() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[// comment \n true]"));
     reader.setLenient(true);
     reader.beginArray();
@@ -891,13 +888,13 @@ public void testLenientComments() throws IOException {
     assertEquals(true, reader.nextBoolean());
   }
 
-  public void testStrictCommentsWithSkipValue() throws IOException {
+  public void testStrictCommentsWithSkipValue() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[// comment \n true]"));
     reader.beginArray();
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[# comment \n true]"));
@@ -905,7 +902,7 @@ public void testStrictCommentsWithSkipValue() throws IOException {
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[/* comment */ true]"));
@@ -913,162 +910,162 @@ public void testStrictCommentsWithSkipValue() throws IOException {
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictUnquotedNames() throws IOException {
-    JsonReader reader = new JsonReader(reader("{a:true}"));
+  public void testStrictUnquotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"));
     reader.beginObject();
     try {
       reader.nextName();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientUnquotedNames() throws IOException {
-    JsonReader reader = new JsonReader(reader("{a:true}"));
+  public void testLenientUnquotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"));
     reader.setLenient(true);
     reader.beginObject();
     assertEquals("a", reader.nextName());
   }
 
-  public void testStrictUnquotedNamesWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("{a:true}"));
+  public void testStrictUnquotedNamesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"));
     reader.beginObject();
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictSingleQuotedNames() throws IOException {
-    JsonReader reader = new JsonReader(reader("{'a':true}"));
+  public void testStrictSingleQuotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"));
     reader.beginObject();
     try {
       reader.nextName();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientSingleQuotedNames() throws IOException {
-    JsonReader reader = new JsonReader(reader("{'a':true}"));
+  public void testLenientSingleQuotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"));
     reader.setLenient(true);
     reader.beginObject();
     assertEquals("a", reader.nextName());
   }
 
-  public void testStrictSingleQuotedNamesWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("{'a':true}"));
+  public void testStrictSingleQuotedNamesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"));
     reader.beginObject();
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictUnquotedStrings() throws IOException {
-    JsonReader reader = new JsonReader(reader("[a]"));
+  public void testStrictUnquotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictUnquotedStringsWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[a]"));
+  public void testStrictUnquotedStringsWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"));
     reader.beginArray();
     try {
       reader.skipValue();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientUnquotedStrings() throws IOException {
-    JsonReader reader = new JsonReader(reader("[a]"));
+  public void testLenientUnquotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals("a", reader.nextString());
   }
 
-  public void testStrictSingleQuotedStrings() throws IOException {
-    JsonReader reader = new JsonReader(reader("['a']"));
+  public void testStrictSingleQuotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"));
     reader.beginArray();
     try {
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientSingleQuotedStrings() throws IOException {
-    JsonReader reader = new JsonReader(reader("['a']"));
+  public void testLenientSingleQuotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals("a", reader.nextString());
   }
 
-  public void testStrictSingleQuotedStringsWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("['a']"));
+  public void testStrictSingleQuotedStringsWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"));
     reader.beginArray();
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictSemicolonDelimitedArray() throws IOException {
-    JsonReader reader = new JsonReader(reader("[true;true]"));
+  public void testStrictSemicolonDelimitedArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"));
     reader.beginArray();
     try {
       reader.nextBoolean();
       reader.nextBoolean();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientSemicolonDelimitedArray() throws IOException {
-    JsonReader reader = new JsonReader(reader("[true;true]"));
+  public void testLenientSemicolonDelimitedArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     assertEquals(true, reader.nextBoolean());
   }
 
-  public void testStrictSemicolonDelimitedArrayWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[true;true]"));
+  public void testStrictSemicolonDelimitedArrayWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"));
     reader.beginArray();
     try {
       reader.skipValue();
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictSemicolonDelimitedNameValuePair() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
+  public void testStrictSemicolonDelimitedNameValuePair() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     try {
       reader.nextBoolean();
       reader.nextName();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientSemicolonDelimitedNameValuePair() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
+  public void testLenientSemicolonDelimitedNameValuePair() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
     reader.setLenient(true);
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -1076,26 +1073,26 @@ public void testLenientSemicolonDelimitedNameValuePair() throws IOException {
     assertEquals("b", reader.nextName());
   }
 
-  public void testStrictSemicolonDelimitedNameValuePairWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
+  public void testStrictSemicolonDelimitedNameValuePairWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     try {
       reader.skipValue();
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictUnnecessaryArraySeparators() throws IOException {
+  public void testStrictUnnecessaryArraySeparators() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[true,,true]"));
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     try {
       reader.nextNull();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[,true]"));
@@ -1103,7 +1100,7 @@ public void testStrictUnnecessaryArraySeparators() throws IOException {
     try {
       reader.nextNull();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[true,]"));
@@ -1112,7 +1109,7 @@ public void testStrictUnnecessaryArraySeparators() throws IOException {
     try {
       reader.nextNull();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[,]"));
@@ -1120,11 +1117,11 @@ public void testStrictUnnecessaryArraySeparators() throws IOException {
     try {
       reader.nextNull();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientUnnecessaryArraySeparators() throws IOException {
+  public void testLenientUnnecessaryArraySeparators() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[true,,true]"));
     reader.setLenient(true);
     reader.beginArray();
@@ -1155,14 +1152,14 @@ public void testLenientUnnecessaryArraySeparators() throws IOException {
     reader.endArray();
   }
 
-  public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws IOException {
+  public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws MalformedJsonException {
     JsonReader reader = new JsonReader(reader("[true,,true]"));
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[,true]"));
@@ -1170,7 +1167,7 @@ public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws IOExcepti
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[true,]"));
@@ -1179,7 +1176,7 @@ public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws IOExcepti
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
 
     reader = new JsonReader(reader("[,]"));
@@ -1187,23 +1184,23 @@ public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws IOExcepti
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStrictMultipleTopLevelValues() throws IOException {
-    JsonReader reader = new JsonReader(reader("[] []"));
+  public void testStrictMultipleTopLevelValues() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] []"));
     reader.beginArray();
     reader.endArray();
     try {
       reader.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientMultipleTopLevelValues() throws IOException {
-    JsonReader reader = new JsonReader(reader("[] true {}"));
+  public void testLenientMultipleTopLevelValues() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] true {}"));
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -1213,78 +1210,78 @@ public void testLenientMultipleTopLevelValues() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testStrictMultipleTopLevelValuesWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("[] []"));
+  public void testStrictMultipleTopLevelValuesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] []"));
     reader.beginArray();
     reader.endArray();
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testTopLevelValueTypes() throws IOException {
-    JsonReader reader1 = new JsonReader(reader("true"));
+  public void testTopLevelValueTypes() throws MalformedJsonException {
+    final JsonReader reader1 = new JsonReader(reader("true"));
     assertTrue(reader1.nextBoolean());
     assertEquals(JsonToken.END_DOCUMENT, reader1.peek());
 
-    JsonReader reader2 = new JsonReader(reader("false"));
+    final JsonReader reader2 = new JsonReader(reader("false"));
     assertFalse(reader2.nextBoolean());
     assertEquals(JsonToken.END_DOCUMENT, reader2.peek());
 
-    JsonReader reader3 = new JsonReader(reader("null"));
+    final JsonReader reader3 = new JsonReader(reader("null"));
     assertEquals(JsonToken.NULL, reader3.peek());
     reader3.nextNull();
     assertEquals(JsonToken.END_DOCUMENT, reader3.peek());
 
-    JsonReader reader4 = new JsonReader(reader("123"));
+    final JsonReader reader4 = new JsonReader(reader("123"));
     assertEquals(123, reader4.nextInt());
     assertEquals(JsonToken.END_DOCUMENT, reader4.peek());
 
-    JsonReader reader5 = new JsonReader(reader("123.4"));
+    final JsonReader reader5 = new JsonReader(reader("123.4"));
     assertEquals(123.4, reader5.nextDouble());
     assertEquals(JsonToken.END_DOCUMENT, reader5.peek());
 
-    JsonReader reader6 = new JsonReader(reader("\"a\""));
+    final JsonReader reader6 = new JsonReader(reader("\"a\""));
     assertEquals("a", reader6.nextString());
     assertEquals(JsonToken.END_DOCUMENT, reader6.peek());
   }
 
-  public void testTopLevelValueTypeWithSkipValue() throws IOException {
-    JsonReader reader = new JsonReader(reader("true"));
+  public void testTopLevelValueTypeWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("true"));
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testStrictNonExecutePrefix() {
-    JsonReader reader = new JsonReader(reader(")]}'\n []"));
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
     try {
       reader.beginArray();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
   public void testStrictNonExecutePrefixWithSkipValue() {
-    JsonReader reader = new JsonReader(reader(")]}'\n []"));
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
     try {
       reader.skipValue();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientNonExecutePrefix() throws IOException {
-    JsonReader reader = new JsonReader(reader(")]}'\n []"));
+  public void testLenientNonExecutePrefix() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testLenientNonExecutePrefixWithLeadingWhitespace() throws IOException {
-    JsonReader reader = new JsonReader(reader("\r\n \t)]}'\n []"));
+  public void testLenientNonExecutePrefixWithLeadingWhitespace() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\r\n \t)]}'\n []"));
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -1292,104 +1289,104 @@ public void testLenientNonExecutePrefixWithLeadingWhitespace() throws IOExceptio
   }
 
   public void testLenientPartialNonExecutePrefix() {
-    JsonReader reader = new JsonReader(reader(")]}' []"));
+    final JsonReader reader = new JsonReader(reader(")]}' []"));
     reader.setLenient(true);
     try {
       assertEquals(")", reader.nextString());
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testBomIgnoredAsFirstCharacterOfDocument() throws IOException {
-    JsonReader reader = new JsonReader(reader("\ufeff[]"));
+  public void testBomIgnoredAsFirstCharacterOfDocument() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\ufeff[]"));
     reader.beginArray();
     reader.endArray();
   }
 
-  public void testBomForbiddenAsOtherCharacterInDocument() throws IOException {
-    JsonReader reader = new JsonReader(reader("[\ufeff]"));
+  public void testBomForbiddenAsOtherCharacterInDocument() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\ufeff]"));
     reader.beginArray();
     try {
       reader.endArray();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testFailWithPosition() throws IOException {
+  public void testFailWithPosition() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 6 column 5 path $[1]",
         "[\n\n\n\n\n\"a\",}]");
   }
 
-  public void testFailWithPositionGreaterThanBufferSize() throws IOException {
-    String spaces = repeat(' ', 8192);
+  public void testFailWithPositionGreaterThanBufferSize() throws MalformedJsonException {
+    final String spaces = repeat(' ', 8192);
     testFailWithPosition("Expected value at line 6 column 5 path $[1]",
         "[\n\n" + spaces + "\n\n\n\"a\",}]");
   }
 
-  public void testFailWithPositionOverSlashSlashEndOfLineComment() throws IOException {
+  public void testFailWithPositionOverSlashSlashEndOfLineComment() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 5 column 6 path $[1]",
         "\n// foo\n\n//bar\r\n[\"a\",}");
   }
 
-  public void testFailWithPositionOverHashEndOfLineComment() throws IOException {
+  public void testFailWithPositionOverHashEndOfLineComment() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 5 column 6 path $[1]",
         "\n# foo\n\n#bar\r\n[\"a\",}");
   }
 
-  public void testFailWithPositionOverCStyleComment() throws IOException {
+  public void testFailWithPositionOverCStyleComment() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 6 column 12 path $[1]",
         "\n\n/* foo\n*\n*\r\nbar */[\"a\",}");
   }
 
-  public void testFailWithPositionOverQuotedString() throws IOException {
+  public void testFailWithPositionOverQuotedString() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 5 column 3 path $[1]",
         "[\"foo\nbar\r\nbaz\n\",\n  }");
   }
 
-  public void testFailWithPositionOverUnquotedString() throws IOException {
+  public void testFailWithPositionOverUnquotedString() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 5 column 2 path $[1]", "[\n\nabcd\n\n,}");
   }
 
-  public void testFailWithEscapedNewlineCharacter() throws IOException {
+  public void testFailWithEscapedNewlineCharacter() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 5 column 3 path $[1]", "[\n\n\"\\\n\n\",}");
   }
 
-  public void testFailWithPositionIsOffsetByBom() throws IOException {
+  public void testFailWithPositionIsOffsetByBom() throws MalformedJsonException {
     testFailWithPosition("Expected value at line 1 column 6 path $[1]",
         "\ufeff[\"a\",}]");
   }
 
-  private void testFailWithPosition(String message, String json) throws IOException {
+  private void testFailWithPosition(final String message, final String json) throws MalformedJsonException {
     // Validate that it works reading the string normally.
-    JsonReader reader1 = new JsonReader(reader(json));
+    final JsonReader reader1 = new JsonReader(reader(json));
     reader1.setLenient(true);
     reader1.beginArray();
     reader1.nextString();
     try {
       reader1.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
       assertEquals(message, expected.getMessage());
     }
 
     // Also validate that it works when skipping.
-    JsonReader reader2 = new JsonReader(reader(json));
+    final JsonReader reader2 = new JsonReader(reader(json));
     reader2.setLenient(true);
     reader2.beginArray();
     reader2.skipValue();
     try {
       reader2.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
       assertEquals(message, expected.getMessage());
     }
   }
 
-  public void testFailWithPositionDeepPath() throws IOException {
-    JsonReader reader = new JsonReader(reader("[1,{\"a\":[2,3,}"));
+  public void testFailWithPositionDeepPath() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1,{\"a\":[2,3,}"));
     reader.beginArray();
     reader.nextInt();
     reader.beginObject();
@@ -1400,23 +1397,23 @@ public void testFailWithPositionDeepPath() throws IOException {
     try {
       reader.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
       assertEquals("Expected value at line 1 column 14 path $[1].a[2]", expected.getMessage());
     }
   }
 
-  public void testStrictVeryLongNumber() throws IOException {
-    JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
+  public void testStrictVeryLongNumber() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
     reader.beginArray();
     try {
       assertEquals(1d, reader.nextDouble());
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientVeryLongNumber() throws IOException {
-    JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
+  public void testLenientVeryLongNumber() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
@@ -1425,18 +1422,18 @@ public void testLenientVeryLongNumber() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testVeryLongUnquotedLiteral() throws IOException {
-    String literal = "a" + repeat('b', 8192) + "c";
-    JsonReader reader = new JsonReader(reader("[" + literal + "]"));
+  public void testVeryLongUnquotedLiteral() throws MalformedJsonException {
+    final String literal = "a" + repeat('b', 8192) + "c";
+    final JsonReader reader = new JsonReader(reader("[" + literal + "]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(literal, reader.nextString());
     reader.endArray();
   }
 
-  public void testDeeplyNestedArrays() throws IOException {
+  public void testDeeplyNestedArrays() throws MalformedJsonException {
     // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer
-    JsonReader reader = new JsonReader(reader(
+    final JsonReader reader = new JsonReader(reader(
         "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]"));
     for (int i = 0; i < 40; i++) {
       reader.beginArray();
@@ -1449,15 +1446,15 @@ public void testDeeplyNestedArrays() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testDeeplyNestedObjects() throws IOException {
+  public void testDeeplyNestedObjects() throws MalformedJsonException {
     // Build a JSON document structured like {"a":{"a":{"a":{"a":true}}}}, but 40 levels deep
-    String array = "{\"a\":%s}";
+    final String array = "{\"a\":%s}";
     String json = "true";
     for (int i = 0; i < 40; i++) {
       json = String.format(array, json);
     }
 
-    JsonReader reader = new JsonReader(reader(json));
+    final JsonReader reader = new JsonReader(reader(json));
     for (int i = 0; i < 40; i++) {
       reader.beginObject();
       assertEquals("a", reader.nextName());
@@ -1472,38 +1469,38 @@ public void testDeeplyNestedObjects() throws IOException {
   }
 
   // http://code.google.com/p/google-gson/issues/detail?id=409
-  public void testStringEndingInSlash() throws IOException {
-    JsonReader reader = new JsonReader(reader("/"));
+  public void testStringEndingInSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/"));
     reader.setLenient(true);
     try {
       reader.peek();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testDocumentWithCommentEndingInSlash() throws IOException {
-    JsonReader reader = new JsonReader(reader("/* foo *//"));
+  public void testDocumentWithCommentEndingInSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/* foo *//"));
     reader.setLenient(true);
     try {
       reader.peek();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testStringWithLeadingSlash() throws IOException {
-    JsonReader reader = new JsonReader(reader("/x"));
+  public void testStringWithLeadingSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/x"));
     reader.setLenient(true);
     try {
       reader.peek();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testUnterminatedObject() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":\"android\"x"));
+  public void testUnterminatedObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"android\"x"));
     reader.setLenient(true);
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -1511,101 +1508,101 @@ public void testUnterminatedObject() throws IOException {
     try {
       reader.peek();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testVeryLongQuotedString() throws IOException {
-    char[] stringChars = new char[1024 * 16];
+  public void testVeryLongQuotedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
     Arrays.fill(stringChars, 'x');
-    String string = new String(stringChars);
-    String json = "[\"" + string + "\"]";
-    JsonReader reader = new JsonReader(reader(json));
+    final String string = new String(stringChars);
+    final String json = "[\"" + string + "\"]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.beginArray();
     assertEquals(string, reader.nextString());
     reader.endArray();
   }
 
-  public void testVeryLongUnquotedString() throws IOException {
-    char[] stringChars = new char[1024 * 16];
+  public void testVeryLongUnquotedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
     Arrays.fill(stringChars, 'x');
-    String string = new String(stringChars);
-    String json = "[" + string + "]";
-    JsonReader reader = new JsonReader(reader(json));
+    final String string = new String(stringChars);
+    final String json = "[" + string + "]";
+    final JsonReader reader = new JsonReader(reader(json));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(string, reader.nextString());
     reader.endArray();
   }
 
-  public void testVeryLongUnterminatedString() throws IOException {
-    char[] stringChars = new char[1024 * 16];
+  public void testVeryLongUnterminatedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
     Arrays.fill(stringChars, 'x');
-    String string = new String(stringChars);
-    String json = "[" + string;
-    JsonReader reader = new JsonReader(reader(json));
+    final String string = new String(stringChars);
+    final String json = "[" + string;
+    final JsonReader reader = new JsonReader(reader(json));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(string, reader.nextString());
     try {
       reader.peek();
       fail();
-    } catch (EOFException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testSkipVeryLongUnquotedString() throws IOException {
-    JsonReader reader = new JsonReader(reader("[" + repeat('x', 8192) + "]"));
+  public void testSkipVeryLongUnquotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[" + repeat('x', 8192) + "]"));
     reader.setLenient(true);
     reader.beginArray();
     reader.skipValue();
     reader.endArray();
   }
 
-  public void testSkipTopLevelUnquotedString() throws IOException {
-    JsonReader reader = new JsonReader(reader(repeat('x', 8192)));
+  public void testSkipTopLevelUnquotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(repeat('x', 8192)));
     reader.setLenient(true);
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testSkipVeryLongQuotedString() throws IOException {
-    JsonReader reader = new JsonReader(reader("[\"" + repeat('x', 8192) + "\"]"));
+  public void testSkipVeryLongQuotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"" + repeat('x', 8192) + "\"]"));
     reader.beginArray();
     reader.skipValue();
     reader.endArray();
   }
 
-  public void testSkipTopLevelQuotedString() throws IOException {
-    JsonReader reader = new JsonReader(reader("\"" + repeat('x', 8192) + "\""));
+  public void testSkipTopLevelQuotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\"" + repeat('x', 8192) + "\""));
     reader.setLenient(true);
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testStringAsNumberWithTruncatedExponent() throws IOException {
-    JsonReader reader = new JsonReader(reader("[123e]"));
+  public void testStringAsNumberWithTruncatedExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123e]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
-  public void testStringAsNumberWithDigitAndNonDigitExponent() throws IOException {
-    JsonReader reader = new JsonReader(reader("[123e4b]"));
+  public void testStringAsNumberWithDigitAndNonDigitExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123e4b]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
-  public void testStringAsNumberWithNonDigitExponent() throws IOException {
-    JsonReader reader = new JsonReader(reader("[123eb]"));
+  public void testStringAsNumberWithNonDigitExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123eb]"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
-  public void testEmptyStringName() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"\":true}"));
+  public void testEmptyStringName() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"\":true}"));
     reader.setLenient(true);
     assertEquals(BEGIN_OBJECT, reader.peek());
     reader.beginObject();
@@ -1618,20 +1615,20 @@ public void testEmptyStringName() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testStrictExtraCommasInMaps() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
+  public void testStrictExtraCommasInMaps() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals("b", reader.nextString());
     try {
       reader.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  public void testLenientExtraCommasInMaps() throws IOException {
-    JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
+  public void testLenientExtraCommasInMaps() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
     reader.setLenient(true);
     reader.beginObject();
     assertEquals("a", reader.nextName());
@@ -1639,78 +1636,78 @@ public void testLenientExtraCommasInMaps() throws IOException {
     try {
       reader.peek();
       fail();
-    } catch (IOException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
+  private String repeat(final char c, final int count) {
+    final char[] array = new char[count];
     Arrays.fill(array, c);
     return new String(array);
   }
 
-  public void testMalformedDocuments() throws IOException {
-    assertDocument("{]", BEGIN_OBJECT, IOException.class);
-    assertDocument("{,", BEGIN_OBJECT, IOException.class);
-    assertDocument("{{", BEGIN_OBJECT, IOException.class);
-    assertDocument("{[", BEGIN_OBJECT, IOException.class);
-    assertDocument("{:", BEGIN_OBJECT, IOException.class);
-    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\":}", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\"::", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\":,", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\"=}", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\"=>}", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\"=>\"string\":", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\"=>\"string\"=", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\"=>\"string\"=>", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\"=>\"string\",", BEGIN_OBJECT, NAME, STRING, IOException.class);
+  public void testMalformedDocuments() throws MalformedJsonException {
+    assertDocument("{]", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{,", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{{", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{[", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{:", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\":}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"::", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\":,", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=>}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\":", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\"=", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\"=>", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\",", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
     assertDocument("{\"name\"=>\"string\",\"name\"", BEGIN_OBJECT, NAME, STRING, NAME);
-    assertDocument("[}", BEGIN_ARRAY, IOException.class);
+    assertDocument("[}", BEGIN_ARRAY, MalformedJsonException.class);
     assertDocument("[,]", BEGIN_ARRAY, NULL, NULL, END_ARRAY);
-    assertDocument("{", BEGIN_OBJECT, IOException.class);
-    assertDocument("{\"name\"", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{'name'", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{'name',", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("{name", BEGIN_OBJECT, NAME, IOException.class);
-    assertDocument("[", BEGIN_ARRAY, IOException.class);
-    assertDocument("[string", BEGIN_ARRAY, STRING, IOException.class);
-    assertDocument("[\"string\"", BEGIN_ARRAY, STRING, IOException.class);
-    assertDocument("['string'", BEGIN_ARRAY, STRING, IOException.class);
-    assertDocument("[123", BEGIN_ARRAY, NUMBER, IOException.class);
-    assertDocument("[123,", BEGIN_ARRAY, NUMBER, IOException.class);
-    assertDocument("{\"name\":123", BEGIN_OBJECT, NAME, NUMBER, IOException.class);
-    assertDocument("{\"name\":123,", BEGIN_OBJECT, NAME, NUMBER, IOException.class);
-    assertDocument("{\"name\":\"string\"", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\":\"string\",", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\":'string'", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\":'string',", BEGIN_OBJECT, NAME, STRING, IOException.class);
-    assertDocument("{\"name\":false", BEGIN_OBJECT, NAME, BOOLEAN, IOException.class);
-    assertDocument("{\"name\":false,,", BEGIN_OBJECT, NAME, BOOLEAN, IOException.class);
+    assertDocument("{", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{\"name\"", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{'name'", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{'name',", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{name", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("[", BEGIN_ARRAY, MalformedJsonException.class);
+    assertDocument("[string", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("[\"string\"", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("['string'", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("[123", BEGIN_ARRAY, NUMBER, MalformedJsonException.class);
+    assertDocument("[123,", BEGIN_ARRAY, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":123", BEGIN_OBJECT, NAME, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":123,", BEGIN_OBJECT, NAME, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":\"string\"", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":\"string\",", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":'string'", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":'string',", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":false", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);
+    assertDocument("{\"name\":false,,", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);
   }
 
   /**
    * This test behave slightly differently in Gson 2.2 and earlier. It fails
    * during peek rather than during nextString().
    */
-  public void testUnterminatedStringFailure() throws IOException {
-    JsonReader reader = new JsonReader(reader("[\"string"));
+  public void testUnterminatedStringFailure() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"string"));
     reader.setLenient(true);
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
     try {
       reader.nextString();
       fail();
-    } catch (MalformedJsonException expected) {
+    } catch (final MalformedJsonException expected) {
     }
   }
 
-  private void assertDocument(String document, Object... expectations) throws IOException {
-    JsonReader reader = new JsonReader(reader(document));
+  private void assertDocument(final String document, final Object... expectations) throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(document));
     reader.setLenient(true);
-    for (Object expectation : expectations) {
+    for (final Object expectation : expectations) {
       if (expectation == BEGIN_OBJECT) {
         reader.beginObject();
       } else if (expectation == BEGIN_ARRAY) {
@@ -1729,11 +1726,11 @@ private void assertDocument(String document, Object... expectations) throws IOEx
         assertEquals(123, reader.nextInt());
       } else if (expectation == NULL) {
         reader.nextNull();
-      } else if (expectation == IOException.class) {
+      } else if (expectation == MalformedJsonException.class) {
         try {
           reader.peek();
           fail();
-        } catch (IOException expected) {
+        } catch (final MalformedJsonException expected) {
         }
       } else {
         throw new AssertionError();
@@ -1748,7 +1745,7 @@ private Reader reader(final String s) {
     /* if (true) */ return new StringReader(s);
     /* return new Reader() {
       int position = 0;
-      @Override public int read(char[] buffer, int offset, int count) throws IOException {
+      @Override public int read(char[] buffer, int offset, int count) throws MalformedJsonException {
         if (position == s.length()) {
           return -1;
         } else if (count > 0) {
@@ -1758,7 +1755,7 @@ private Reader reader(final String s) {
           throw new IllegalArgumentException();
         }
       }
-      @Override public void close() throws IOException {
+      @Override public void close() throws MalformedJsonException {
       }
     }; */
   }
diff --git a/src/test/java/com/github/gv2011/jsoncore/JsonWriterTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
similarity index 99%
rename from src/test/java/com/github/gv2011/jsoncore/JsonWriterTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
index 6a5eececd..2e7ba7394 100644
--- a/src/test/java/com/github/gv2011/jsoncore/JsonWriterTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,14 +15,14 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.io.IOException;
 import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
-import com.github.gv2011.jsoncore.JsonWriter;
+import com.github.gv2011.jsoncore.imp.JsonWriter;
 
 import junit.framework.TestCase;
 
diff --git a/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
similarity index 71%
rename from src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
index 7ae4a3a37..1e5a8affd 100644
--- a/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2015 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,20 +16,18 @@
  */
 package com.github.gv2011.jsoncore.imp;
 
-import com.github.gv2011.jsoncore.imp.LazilyParsedNumber;
-
 import junit.framework.TestCase;
 
 public class LazilyParsedNumberTest extends TestCase {
   public void testHashCode() {
-    LazilyParsedNumber n1 = new LazilyParsedNumber("1");
-    LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
+    final LazilyParsedNumber n1 = new LazilyParsedNumber("1");
+    final LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
     assertEquals(n1.hashCode(), n1Another.hashCode());
   }
 
   public void testEquals() {
-    LazilyParsedNumber n1 = new LazilyParsedNumber("1");
-    LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
+    final LazilyParsedNumber n1 = new LazilyParsedNumber("1");
+    final LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
     assertTrue(n1.equals(n1Another));
   }
 }
diff --git a/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
similarity index 98%
rename from src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
index 87b63e288..835f83558 100644
--- a/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2012 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -22,8 +23,6 @@
 import java.util.Map;
 import java.util.Random;
 
-import com.github.gv2011.jsoncore.MoreAsserts;
-
 import junit.framework.TestCase;
 
 public final class LinkedTreeMapTest extends TestCase {
diff --git a/src/test/java/com/github/gv2011/jsoncore/MoreAsserts.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java
similarity index 95%
rename from src/test/java/com/github/gv2011/jsoncore/MoreAsserts.java
rename to imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java
index 8ffcdd402..705fb6087 100644
--- a/src/test/java/com/github/gv2011/jsoncore/MoreAsserts.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.jsoncore.imp;
 
 import java.util.Collection;
 
diff --git a/pom.xml b/pom.xml
index 52f5323af..f335d38c9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,6 +9,7 @@
 	</parent>
 
 	<artifactId>jsoncore</artifactId>
+	<packaging>pom</packaging>
 
 	<name>Vinz Jsoncore</name>
 	<description>Json Reader and Writer (extracted from Gson)</description>
@@ -20,13 +21,18 @@
 			<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
 		</license>
 	</licenses>
-	
-	 <scm>
-    <connection>scm:git:git@github.com:gv2011/jsoncore.git</connection>
-    <developerConnection>scm:git:git@github.com:gv2011/jsoncore.git</developerConnection>
-    <url>https://github.com/gv2011/jsoncore</url>
-    <tag>HEAD</tag>
-  </scm>
-	
+
+	<scm>
+		<connection>scm:git:git@github.com:gv2011/jsoncore.git</connection>
+		<developerConnection>scm:git:git@github.com:gv2011/jsoncore.git</developerConnection>
+		<url>https://github.com/gv2011/jsoncore</url>
+		<tag>HEAD</tag>
+	</scm>
+
+	<modules>
+		<module>api</module>
+		<module>imp</module>
+	</modules>
+
 
 </project>
