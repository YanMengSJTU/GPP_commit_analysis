diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 2529c77b2..a65c7d3b2 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -37,11 +37,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -53,8 +49,8 @@
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
-      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
+                                      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
+                                      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
     this.constructorConstructor = constructorConstructor;
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.excluder = excluder;
@@ -103,15 +99,15 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
   }
 
   private ReflectiveTypeAdapterFactory.BoundField createBoundField(
-      final Gson context, final Field field, final String name,
-      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
+          final Gson context, final Field field, final String name,
+          final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
     TypeAdapter<?> mapped = null;
     if (annotation != null) {
       mapped = jsonAdapterFactory.getTypeAdapter(
-          constructorConstructor, context, fieldType, annotation);
+              constructorConstructor, context, fieldType, annotation);
     }
     final boolean jsonAdapterPresent = mapped != null;
     if (mapped == null) mapped = context.getAdapter(fieldType);
@@ -120,7 +116,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
-          throws IOException, IllegalAccessException {
+              throws IOException, IllegalAccessException {
         Object fieldValue;
 
         if(context.useGetterSetter()) {
@@ -158,11 +154,11 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         }
 
         TypeAdapter t = jsonAdapterPresent ? typeAdapter
-            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
+                : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
-          throws IOException, IllegalAccessException {
+              throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
         if (fieldValue != null || !isPrimitive) {
 
@@ -230,15 +226,31 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         for (int i = 0, size = fieldNames.size(); i < size; ++i) {
           String name = fieldNames.get(i);
           if (i != 0) serialize = false; // only serialize the default name
+          GetterSetterSerializedField wrapped = new GetterSetterSerializedField(
+                  name, fieldType, context, field
+          );
+          /*
           BoundField boundField = createBoundField(context, field, name,
               TypeToken.get(fieldType), serialize, deserialize);
+          */
+          BoundField boundField = wrapped.createBoundField(serialize, deserialize);
           BoundField replaced = result.put(name, boundField);
           if (previous == null) previous = replaced;
         }
         if (previous != null) {
           throw new IllegalArgumentException(declaredType
-              + " declares multiple JSON fields named " + previous.name);
+                  + " declares multiple JSON fields named " + previous.name);
         }
+        /*
+        if(context.useGetterSetter()){
+          Method[] getters = ReflectionHelper.getAllGetters(raw, true);
+          for (Method getter: getters){
+            serialize = excludeField(field, true);
+          }
+        }
+        */
+
+
       }
       type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));
       raw = type.getRawType();
@@ -246,6 +258,189 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     return result;
   }
 
+  static class ReflectionHelper{
+    static String getGetterName(Field field){
+      String fieldName = field.getName();
+      String getterPrefix = field.getType() == boolean.class || field.getType() == Boolean.class ? "is" : "get";
+      return getterPrefix + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
+    }
+
+    static String getSetterName(Field field){
+      return "set" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);
+    }
+
+    static boolean fieldHasGetter(Field field){
+      String getterName = getGetterName(field);
+      Class<?> cls = field.getDeclaringClass();
+      try{
+        cls.getMethod(getterName, new Class[]{});
+        return true;
+      } catch (NoSuchMethodException e){
+        return false;
+      } catch (SecurityException e){
+        return false;
+      }
+    }
+
+    static Method[] getAllGetters(Class cls, boolean declaredOnly) {
+      Set<Method> getters = new HashSet<>();
+      Method[] methods = declaredOnly ? cls.getDeclaredMethods() : cls.getMethods();
+      for (Method m : methods) {
+        String name = m.getName();
+        if (name.substring(0, 2).equals("is") || name.substring(0, 3).equals("get")) {
+          getters.add(m);
+        }
+
+      }
+      return getters.toArray(new Method[]{});
+    }
+
+    static String fieldNameFromGetter(Method getter) {
+      String getterName = getter.getName();
+      if (getterName.substring(0, 2).equals("is")) {
+        return getterName.substring(2, 3).toLowerCase() + getterName.substring(3);
+      } else if (getterName.substring(0, 3).equals("get")) {
+        return getterName.substring(3, 4).toLowerCase() + getterName.substring(4);
+      } else {
+        throw new IllegalArgumentException("The passed method with the name " + getterName + "is not a getter");
+      }
+    }
+  }
+
+  abstract class GeneralizedField {
+    final String name;
+    final Type fieldType;
+    final TypeToken<?> typeToken;
+    final Gson context;
+
+    GeneralizedField(String name, Type fieldType, Gson context){
+      this.name = name;
+      this.fieldType = fieldType;
+      this.typeToken = TypeToken.get(fieldType);
+      this.context = context;
+    }
+
+    abstract TypeAdapter<?> getTypeAdapter();
+    abstract Object getValue(Object instance) throws IllegalAccessException;
+    abstract void setValue(Object instance, Object value) throws IllegalAccessException;
+    abstract boolean isRuntimeWrapped();
+
+    ReflectiveTypeAdapterFactory.BoundField createBoundField(boolean serialize, boolean deserialize) {
+      return new  ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+
+        @Override
+        boolean writeField(Object value) throws IOException, IllegalAccessException {
+          if (!serialized) return false;
+          Object fieldValue = getValue(value);
+          return fieldValue != value; //
+        }
+
+        @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
+        @Override
+        void write(JsonWriter writer, Object instance) throws IOException, IllegalAccessException {
+          TypeAdapter t = isRuntimeWrapped() ? getTypeAdapter()
+                  : new TypeAdapterRuntimeTypeWrapper(context, getTypeAdapter(), typeToken.getType());
+          t.write(writer, getValue(instance));
+        }
+
+        @Override
+        void read(JsonReader reader, Object instance) throws IOException, IllegalAccessException {
+          Object fieldValue = getTypeAdapter().read(reader);
+          final boolean isPrimitive = Primitives.isPrimitive(typeToken.getRawType());
+          if (fieldValue != null || !isPrimitive) {
+            setValue(instance, fieldValue);
+          }
+        }
+      };
+
+    }
+  }
+
+  class StandardField extends GeneralizedField{
+
+    private final TypeAdapter<?> typeAdapter;
+    private final boolean jsonAdapterPresent;
+    protected final Field field;
+
+    StandardField(String name, Type fieldType, Gson context, Field field){
+      super(name, fieldType, context);
+      JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+      TypeAdapter<?> mapped = null;
+      if (annotation != null) {
+        mapped = jsonAdapterFactory.getTypeAdapter(
+                constructorConstructor, context, this.typeToken, annotation);
+      }
+      jsonAdapterPresent = mapped != null;
+      if (mapped == null) mapped = context.getAdapter(this.typeToken);
+      typeAdapter = mapped;
+      this.field = field;
+    }
+
+
+    @Override
+    TypeAdapter<?> getTypeAdapter() {
+      return this.typeAdapter;
+    }
+
+    @Override
+    Object getValue(Object instance) throws IllegalAccessException {
+      return field.get(instance);
+    }
+
+    @Override
+    void setValue(Object instance, Object value) throws IllegalAccessException {
+      field.set(instance, value);
+    }
+
+    @Override
+    boolean isRuntimeWrapped() {
+      return jsonAdapterPresent;
+    }
+  }
+
+  class GetterSetterSerializedField extends StandardField{
+
+    private final boolean useGetterSetter;
+
+    GetterSetterSerializedField(String name, Type fieldType, Gson context, Field field) {
+      super(name, fieldType, context, field);
+      this.useGetterSetter = context.useGetterSetter();
+    }
+
+    @Override
+    Object getValue(Object instance) throws IllegalAccessException {
+      if(!useGetterSetter || !ReflectionHelper.fieldHasGetter(field)){
+        return super.getValue(instance);
+      } else {
+        String getterName = ReflectionHelper.getGetterName(field);
+        try {
+          Method method = instance.getClass().getMethod(getterName);
+          return method.invoke(instance);
+        } catch (NoSuchMethodException | InvocationTargetException ignored) {
+          // TODO: revisit this
+          return super.getValue(instance);
+        }
+      }
+    }
+
+    @Override
+    void setValue(Object instance, Object value) throws IllegalAccessException {
+      if(!useGetterSetter){
+        super.setValue(instance, value);
+      } else {
+        String setterName = ReflectionHelper.getSetterName(field);
+        try {
+          Method method = instance.getClass().getMethod(setterName, field.getType());
+          method.invoke(instance, value);
+        } catch (NoSuchMethodException | InvocationTargetException e){
+          // TODO: revisit this
+          super.setValue(instance, value);
+        }
+      }
+    }
+  }
+
+
   static abstract class BoundField {
     final String name;
     final boolean serialized;
