diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index 235d2b383..b695e84da 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -76,7 +76,7 @@ private ObjectTypeAdapter(Gson gson) {
       return in.nextString();
 
     case NUMBER:
-      return in.nextDouble();
+      return in.nextNumber();
 
     case BOOLEAN:
       return in.nextBoolean();
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 388f30b06..06eb953c3 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -888,6 +888,51 @@ public void nextNull() throws IOException {
     }
   }
 
+    /**
+     * Returns the {@link com.google.gson.stream.JsonToken#NUMBER Number} value of the next token,
+     * consuming it. If the next token is a string, this method will attempt to
+     * parse it as a double using {@link Double#parseDouble(String)}.
+     *
+     * @throws IllegalStateException if the next token is not a literal value.
+     * @throws NumberFormatException if the next literal value cannot be parsed
+     *     as a Number, or is non-finite.
+     */
+    public Number nextNumber() throws IOException {
+        int p = peeked;
+        if (p == PEEKED_NONE) {
+            p = doPeek();
+        }
+
+        if (p == PEEKED_LONG) {
+            peeked = PEEKED_NONE;
+            pathIndices[stackSize - 1]++;
+            return peekedLong;
+        }
+
+        if (p == PEEKED_NUMBER) {
+            peekedString = new String(buffer, pos, peekedNumberLength);
+            pos += peekedNumberLength;
+        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+        } else if (p == PEEKED_UNQUOTED) {
+            peekedString = nextUnquotedValue();
+        } else if (p != PEEKED_BUFFERED) {
+            throw new IllegalStateException("Expected a double but was " + peek()
+                    + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+        }
+
+        peeked = PEEKED_BUFFERED;
+        double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+        if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+            throw new MalformedJsonException("JSON forbids NaN and infinities: " + result
+                    + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+        }
+        peekedString = null;
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+        return result;
+    }
+
   /**
    * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
