diff --git a/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java b/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
new file mode 100644
index 000000000..bd7c2d24d
--- /dev/null
+++ b/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.extras.examples.rawcollections;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonParser;
+
+public class RawCollectionsExample {
+  static class Event {
+    private String name;
+    private String source;
+    private Event(String name, String source) {
+      this.name = name;
+      this.source = source;
+    }
+    @Override
+    public String toString() {
+      return String.format("(name=%s, source=%s)", name, source);
+    }
+  }
+
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  public static void main(String[] args) {
+    Gson gson = new Gson();
+    Collection collection = new ArrayList();
+    collection.add("hello");
+    collection.add(5);
+    collection.add(new Event("GREETINGS", "guest"));
+    String json = gson.toJson(collection);
+    System.out.println("Using Gson.toJson() on a raw collection: " + json);
+    JsonParser parser = new JsonParser();
+    JsonArray array = parser.parse(json).getAsJsonArray();
+    String message = gson.fromJson(array.get(0), String.class);
+    int number = gson.fromJson(array.get(1), int.class);
+    Event event = gson.fromJson(array.get(2), Event.class);
+    System.out.printf("Using Gson.fromJson() to get: %s, %d, %s", message, number, event);
+  }
+}
diff --git a/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java b/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
new file mode 100644
index 000000000..cd8ea00f4
--- /dev/null
+++ b/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.graph;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.InstanceCreator;
+import com.google.gson.JsonElement;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.ConstructorConstructor;
+import com.google.gson.internal.ObjectConstructor;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+
+/**
+ * Writes a graph of objects as a list of named nodes.
+ */
+// TODO: proper documentation
+@SuppressWarnings("rawtypes")
+public final class GraphAdapterBuilder {
+  private final Map<Type, InstanceCreator<?>> instanceCreators;
+  private final ConstructorConstructor constructorConstructor;
+
+  public GraphAdapterBuilder() {
+      this.instanceCreators = new HashMap<Type, InstanceCreator<?>>();
+      this.constructorConstructor = new ConstructorConstructor(instanceCreators);
+  }
+  public GraphAdapterBuilder addType(Type type) {
+    final ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));
+    InstanceCreator<Object> instanceCreator = new InstanceCreator<Object>() {
+      public Object createInstance(Type type) {
+        return objectConstructor.construct();
+      }
+    };
+    return addType(type, instanceCreator);
+  }
+
+  public GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator) {
+    if (type == null || instanceCreator == null) {
+      throw new NullPointerException();
+    }
+    instanceCreators.put(type, instanceCreator);
+    return this;
+  }
+
+  public void registerOn(GsonBuilder gsonBuilder) {
+    Factory factory = new Factory(instanceCreators);
+    gsonBuilder.registerTypeAdapterFactory(factory);
+    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {
+      gsonBuilder.registerTypeAdapter(entry.getKey(), factory);
+    }
+  }
+
+  static class Factory implements TypeAdapterFactory, InstanceCreator {
+    private final Map<Type, InstanceCreator<?>> instanceCreators;
+    private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<Graph>();
+
+    Factory(Map<Type, InstanceCreator<?>> instanceCreators) {
+      this.instanceCreators = instanceCreators;
+    }
+
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+      if (!instanceCreators.containsKey(type.getType())) {
+        return null;
+      }
+
+      final TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);
+      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
+      return new TypeAdapter<T>() {
+        @Override public void write(JsonWriter out, T value) throws IOException {
+          if (value == null) {
+            out.nullValue();
+            return;
+          }
+
+          Graph graph = graphThreadLocal.get();
+          boolean writeEntireGraph = false;
+
+          /*
+           * We have one of two cases:
+           *  1. We've encountered the first known object in this graph. Write
+           *     out the graph, starting with that object.
+           *  2. We've encountered another graph object in the course of #1.
+           *     Just write out this object's name. We'll circle back to writing
+           *     out the object's value as a part of #1.
+           */
+
+          if (graph == null) {
+            writeEntireGraph = true;
+            graph = new Graph(new IdentityHashMap<Object, Element<?>>());
+          }
+
+          @SuppressWarnings("unchecked") // graph.map guarantees consistency between value and T
+          Element<T> element = (Element<T>) graph.map.get(value);
+          if (element == null) {
+            element = new Element<T>(value, graph.nextName(), typeAdapter, null);
+            graph.map.put(value, element);
+            graph.queue.add(element);
+          }
+
+          if (writeEntireGraph) {
+            graphThreadLocal.set(graph);
+            try {
+              out.beginObject();
+              Element<?> current;
+              while ((current = graph.queue.poll()) != null) {
+                out.name(current.id);
+                current.write(out);
+              }
+              out.endObject();
+            } finally {
+              graphThreadLocal.remove();
+            }
+          } else {
+            out.value(element.id);
+          }
+        }
+
+        @Override public T read(JsonReader in) throws IOException {
+          if (in.peek() == JsonToken.NULL) {
+            in.nextNull();
+            return null;
+          }
+
+          /*
+           * Again we have one of two cases:
+           *  1. We've encountered the first known object in this graph. Read
+           *     the entire graph in as a map from names to their JsonElements.
+           *     Then convert the first JsonElement to its Java object.
+           *  2. We've encountered another graph object in the course of #1.
+           *     Read in its name, then deserialize its value from the
+           *     JsonElement in our map. We need to do this lazily because we
+           *     don't know which TypeAdapter to use until a value is
+           *     encountered in the wild.
+           */
+
+          String currentName = null;
+          Graph graph = graphThreadLocal.get();
+          boolean readEntireGraph = false;
+
+          if (graph == null) {
+            graph = new Graph(new HashMap<Object, Element<?>>());
+            readEntireGraph = true;
+
+            // read the entire tree into memory
+            in.beginObject();
+            while (in.hasNext()) {
+              String name = in.nextName();
+              if (currentName == null) {
+                currentName = name;
+              }
+              JsonElement element = elementAdapter.read(in);
+              graph.map.put(name, new Element<T>(null, name, typeAdapter, element));
+            }
+            in.endObject();
+          } else {
+            currentName = in.nextString();
+          }
+
+          if (readEntireGraph) {
+            graphThreadLocal.set(graph);
+          }
+          try {
+            @SuppressWarnings("unchecked") // graph.map guarantees consistency between value and T
+            Element<T> element = (Element<T>) graph.map.get(currentName);
+            // now that we know the typeAdapter for this name, go from JsonElement to 'T'
+            if (element.value == null) {
+              element.typeAdapter = typeAdapter;
+              element.read(graph);
+            }
+            return element.value;
+          } finally {
+            if (readEntireGraph) {
+              graphThreadLocal.remove();
+            }
+          }
+        }
+      };
+    }
+
+    /**
+     * Hook for the graph adapter to get a reference to a deserialized value
+     * before that value is fully populated. This is useful to deserialize
+     * values that directly or indirectly reference themselves: we can hand
+     * out an instance before read() returns.
+     *
+     * <p>Gson should only ever call this method when we're expecting it to;
+     * that is only when we've called back into Gson to deserialize a tree.
+     */
+    @SuppressWarnings("unchecked")
+    public Object createInstance(Type type) {
+      Graph graph = graphThreadLocal.get();
+      if (graph == null || graph.nextCreate == null) {
+        throw new IllegalStateException("Unexpected call to createInstance() for " + type);
+      }
+      InstanceCreator<?> creator = instanceCreators.get(type);
+      Object result = creator.createInstance(type);
+      graph.nextCreate.value = result;
+      graph.nextCreate = null;
+      return result;
+    }
+  }
+
+  static class Graph {
+    /**
+     * The graph elements. On serialization keys are objects (using an identity
+     * hash map) and on deserialization keys are the string names (using a
+     * standard hash map).
+     */
+    private final Map<Object, Element<?>> map;
+
+    /**
+     * The queue of elements to write during serialization. Unused during
+     * deserialization.
+     */
+    private final Queue<Element> queue = new LinkedList<Element>();
+
+    /**
+     * The instance currently being deserialized. Used as a backdoor between
+     * the graph traversal (which needs to know instances) and instance creators
+     * which create them.
+     */
+    private Element nextCreate;
+
+    private Graph(Map<Object, Element<?>> map) {
+      this.map = map;
+    }
+
+    /**
+     * Returns a unique name for an element to be inserted into the graph.
+     */
+    public String nextName() {
+      return "0x" + Integer.toHexString(map.size() + 1);
+    }
+  }
+
+  /**
+   * An element of the graph during serialization or deserialization.
+   */
+  static class Element<T> {
+    /**
+     * This element's name in the top level graph object.
+     */
+    private final String id;
+
+    /**
+     * The value if known. During deserialization this is lazily populated.
+     */
+    private T value;
+
+    /**
+     * This element's type adapter if known. During deserialization this is
+     * lazily populated.
+     */
+    private TypeAdapter<T> typeAdapter;
+
+    /**
+     * The element to deserialize. Unused in serialization.
+     */
+    private final JsonElement element;
+
+    Element(T value, String id, TypeAdapter<T> typeAdapter, JsonElement element) {
+      this.value = value;
+      this.id = id;
+      this.typeAdapter = typeAdapter;
+      this.element = element;
+    }
+
+    void write(JsonWriter out) throws IOException {
+      typeAdapter.write(out, value);
+    }
+
+    void read(Graph graph) throws IOException {
+      if (graph.nextCreate != null) {
+        throw new IllegalStateException("Unexpected recursive call to read() for " + id);
+      }
+      graph.nextCreate = this;
+      value = typeAdapter.fromJsonTree(element);
+      if (value == null) {
+        throw new IllegalStateException("non-null value deserialized to null: " + element);
+      }
+    }
+  }
+}
diff --git a/src/main/java/com/google/gson/interceptors/Intercept.java b/src/main/java/com/google/gson/interceptors/Intercept.java
new file mode 100644
index 000000000..0c4e9043f
--- /dev/null
+++ b/src/main/java/com/google/gson/interceptors/Intercept.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.interceptors;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+
+/**
+ * Use this annotation to indicate various interceptors for class instances after
+ * they have been processed by Gson. For example, you can use it to validate an instance
+ * after it has been deserialized from Json.
+ * Here is an example of how this annotation is used:
+ * <p>Here is an example of how this annotation is used:
+ * <p><pre>
+ * &#64Intercept(postDeserialize=UserValidator.class)
+ * public class User {
+ *   String name;
+ *   String password;
+ *   String emailAddress;
+ * }
+ *
+ * public class UserValidator implements JsonPostDeserializer&lt;User&gt; {
+ *   public void postDeserialize(User user) {
+ *     // Do some checks on user
+ *     if (user.name == null || user.password == null) {
+ *       throw new JsonParseException("name and password are required fields.");
+ *     }
+ *     if (user.emailAddress == null) {
+ *       emailAddress = "unknown"; // assign a default value.
+ *     }
+ *   }
+ * }
+ * </pre></p>
+ *
+ * @author Inderjeet Singh
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface Intercept {
+
+  /**
+   * Specify the class that provides the methods that should be invoked after an instance
+   * has been deserialized.
+   */
+  @SuppressWarnings("rawtypes")
+  public Class<? extends JsonPostDeserializer> postDeserialize();
+}
diff --git a/src/main/java/com/google/gson/interceptors/InterceptorFactory.java b/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
new file mode 100644
index 000000000..907fca3a4
--- /dev/null
+++ b/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
@@ -0,0 +1,49 @@
+package com.google.gson.interceptors;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+
+/**
+ * A type adapter factory that implements {@code @Intercept}.
+ */
+public final class InterceptorFactory implements TypeAdapterFactory {
+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+    Intercept intercept = type.getRawType().getAnnotation(Intercept.class);
+    if (intercept == null) {
+      return null;
+    }
+
+    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+    return new InterceptorAdapter<T>(delegate, intercept);
+  }
+
+  static class InterceptorAdapter<T> extends TypeAdapter<T> {
+    private final TypeAdapter<T> delegate;
+    private final JsonPostDeserializer<T> postDeserializer;
+
+    @SuppressWarnings("unchecked") // ?
+    public InterceptorAdapter(TypeAdapter<T> delegate, Intercept intercept) {
+      try {
+        this.delegate = delegate;
+        this.postDeserializer = intercept.postDeserialize().newInstance();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void write(JsonWriter out, T value) throws IOException {
+      delegate.write(out, value);
+    }
+
+    @Override public T read(JsonReader in) throws IOException {
+      T result = delegate.read(in);
+      postDeserializer.postDeserialize(result);
+      return result;
+    }
+  }
+}
diff --git a/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java b/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java
new file mode 100644
index 000000000..0f3a72ca8
--- /dev/null
+++ b/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.interceptors;
+
+import com.google.gson.InstanceCreator;
+
+/**
+ * This interface is implemented by a class that wishes to inspect or modify an object
+ * after it has been deserialized. You must define a no-args constructor or register an
+ * {@link InstanceCreator} for such a class.
+ *
+ * @author Inderjeet Singh
+ */
+public interface JsonPostDeserializer<T> {
+
+  /**
+   * This method is called by Gson after the object has been deserialized from Json.
+   */
+  public void postDeserialize(T object);
+}
diff --git a/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java b/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
new file mode 100644
index 000000000..5e8c0ccee
--- /dev/null
+++ b/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import java.io.IOException;
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import com.google.gson.JsonParseException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+public final class UtcDateTypeAdapter extends TypeAdapter<Date> {
+  private final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("UTC");
+
+  @Override
+  public void write(JsonWriter out, Date date) throws IOException {
+    if (date == null) {
+      out.nullValue();
+    } else {
+      String value = format(date, true, UTC_TIME_ZONE);
+      out.value(value);
+    }
+  }
+
+  @Override
+  public Date read(JsonReader in) throws IOException {
+    try {
+      switch (in.peek()) {
+      case NULL:
+        in.nextNull();
+        return null;
+      default:
+        String date = in.nextString();
+        // Instead of using iso8601Format.parse(value), we use Jackson's date parsing
+        // This is because Android doesn't support XXX because it is JDK 1.6
+        return parse(date, new ParsePosition(0));
+      }
+    } catch (ParseException e) {
+      throw new JsonParseException(e);
+    }
+  }
+
+  // Date parsing code from Jackson databind ISO8601Utils.java
+  // https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+  private static final String GMT_ID = "GMT";
+
+  /**
+   * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
+   *
+   * @param date the date to format
+   * @param millis true to include millis precision otherwise false
+   * @param tz timezone to use for the formatting (GMT will produce 'Z')
+   * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
+   */
+  private static String format(Date date, boolean millis, TimeZone tz) {
+      Calendar calendar = new GregorianCalendar(tz, Locale.US);
+      calendar.setTime(date);
+
+      // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
+      int capacity = "yyyy-MM-ddThh:mm:ss".length();
+      capacity += millis ? ".sss".length() : 0;
+      capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length();
+      StringBuilder formatted = new StringBuilder(capacity);
+
+      padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
+      formatted.append('-');
+      padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
+      formatted.append('-');
+      padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
+      formatted.append('T');
+      padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
+      formatted.append(':');
+      padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
+      formatted.append(':');
+      padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
+      if (millis) {
+          formatted.append('.');
+          padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
+      }
+
+      int offset = tz.getOffset(calendar.getTimeInMillis());
+      if (offset != 0) {
+          int hours = Math.abs((offset / (60 * 1000)) / 60);
+          int minutes = Math.abs((offset / (60 * 1000)) % 60);
+          formatted.append(offset < 0 ? '-' : '+');
+          padInt(formatted, hours, "hh".length());
+          formatted.append(':');
+          padInt(formatted, minutes, "mm".length());
+      } else {
+          formatted.append('Z');
+      }
+
+      return formatted.toString();
+  }
+  /**
+   * Zero pad a number to a specified length
+   *
+   * @param buffer buffer to use for padding
+   * @param value the integer value to pad if necessary.
+   * @param length the length of the string we should zero pad
+   */
+  private static void padInt(StringBuilder buffer, int value, int length) {
+      String strValue = Integer.toString(value);
+      for (int i = length - strValue.length(); i > 0; i--) {
+          buffer.append('0');
+      }
+      buffer.append(strValue);
+  }
+
+  /**
+   * Parse a date from ISO-8601 formatted string. It expects a format
+   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
+   *
+   * @param date ISO string to parse in the appropriate format.
+   * @param pos The position to start parsing from, updated to where parsing stopped.
+   * @return the parsed date
+   * @throws ParseException if the date is not in the appropriate format
+   */
+  private static Date parse(String date, ParsePosition pos) throws ParseException {
+    Exception fail = null;
+    try {
+      int offset = pos.getIndex();
+
+      // extract year
+      int year = parseInt(date, offset, offset += 4);
+      if (checkOffset(date, offset, '-')) {
+        offset += 1;
+      }
+
+      // extract month
+      int month = parseInt(date, offset, offset += 2);
+      if (checkOffset(date, offset, '-')) {
+        offset += 1;
+      }
+
+      // extract day
+      int day = parseInt(date, offset, offset += 2);
+      // default time value
+      int hour = 0;
+      int minutes = 0;
+      int seconds = 0;
+      int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
+      if (checkOffset(date, offset, 'T')) {
+
+        // extract hours, minutes, seconds and milliseconds
+        hour = parseInt(date, offset += 1, offset += 2);
+        if (checkOffset(date, offset, ':')) {
+          offset += 1;
+        }
+
+        minutes = parseInt(date, offset, offset += 2);
+        if (checkOffset(date, offset, ':')) {
+          offset += 1;
+        }
+        // second and milliseconds can be optional
+        if (date.length() > offset) {
+          char c = date.charAt(offset);
+          if (c != 'Z' && c != '+' && c != '-') {
+            seconds = parseInt(date, offset, offset += 2);
+            // milliseconds can be optional in the format
+            if (checkOffset(date, offset, '.')) {
+              milliseconds = parseInt(date, offset += 1, offset += 3);
+            }
+          }
+        }
+      }
+
+      // extract timezone
+      String timezoneId;
+      if (date.length() <= offset) {
+        throw new IllegalArgumentException("No time zone indicator");
+      }
+      char timezoneIndicator = date.charAt(offset);
+      if (timezoneIndicator == '+' || timezoneIndicator == '-') {
+        String timezoneOffset = date.substring(offset);
+        timezoneId = GMT_ID + timezoneOffset;
+        offset += timezoneOffset.length();
+      } else if (timezoneIndicator == 'Z') {
+        timezoneId = GMT_ID;
+        offset += 1;
+      } else {
+        throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator);
+      }
+
+      TimeZone timezone = TimeZone.getTimeZone(timezoneId);
+      if (!timezone.getID().equals(timezoneId)) {
+        throw new IndexOutOfBoundsException();
+      }
+
+      Calendar calendar = new GregorianCalendar(timezone);
+      calendar.setLenient(false);
+      calendar.set(Calendar.YEAR, year);
+      calendar.set(Calendar.MONTH, month - 1);
+      calendar.set(Calendar.DAY_OF_MONTH, day);
+      calendar.set(Calendar.HOUR_OF_DAY, hour);
+      calendar.set(Calendar.MINUTE, minutes);
+      calendar.set(Calendar.SECOND, seconds);
+      calendar.set(Calendar.MILLISECOND, milliseconds);
+
+      pos.setIndex(offset);
+      return calendar.getTime();
+      // If we get a ParseException it'll already have the right message/offset.
+      // Other exception types can convert here.
+    } catch (IndexOutOfBoundsException e) {
+      fail = e;
+    } catch (NumberFormatException e) {
+      fail = e;
+    } catch (IllegalArgumentException e) {
+      fail = e;
+    }
+    String input = (date == null) ? null : ('"' + date + "'");
+    throw new ParseException("Failed to parse date [" + input + "]: " + fail.getMessage(), pos.getIndex());
+  }
+
+  /**
+   * Check if the expected character exist at the given offset in the value.
+   *
+   * @param value the string to check at the specified offset
+   * @param offset the offset to look for the expected character
+   * @param expected the expected character
+   * @return true if the expected character exist at the given offset
+   */
+  private static boolean checkOffset(String value, int offset, char expected) {
+    return (offset < value.length()) && (value.charAt(offset) == expected);
+  }
+
+  /**
+   * Parse an integer located between 2 given offsets in a string
+   *
+   * @param value the string to parse
+   * @param beginIndex the start index for the integer in the string
+   * @param endIndex the end index for the integer in the string
+   * @return the int
+   * @throws NumberFormatException if the value is not a number
+   */
+  private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
+    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
+      throw new NumberFormatException(value);
+    }
+    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
+    int i = beginIndex;
+    int result = 0;
+    int digit;
+    if (i < endIndex) {
+      digit = Character.digit(value.charAt(i++), 10);
+      if (digit < 0) {
+        throw new NumberFormatException("Invalid number: " + value);
+      }
+      result = -digit;
+    }
+    while (i < endIndex) {
+      digit = Character.digit(value.charAt(i++), 10);
+      if (digit < 0) {
+        throw new NumberFormatException("Invalid number: " + value);
+      }
+      result *= 10;
+      result -= digit;
+    }
+    return -result;
+  }
+}
diff --git a/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java b/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
new file mode 100644
index 000000000..8a1d7cdbf
--- /dev/null
+++ b/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.graph;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import junit.framework.TestCase;
+
+public final class GraphAdapterBuilderTest extends TestCase {
+  public void testSerialization() {
+    Roshambo rock = new Roshambo("ROCK");
+    Roshambo scissors = new Roshambo("SCISSORS");
+    Roshambo paper = new Roshambo("PAPER");
+    rock.beats = scissors;
+    scissors.beats = paper;
+    paper.beats = rock;
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Roshambo.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    assertEquals("{'0x1':{'name':'ROCK','beats':'0x2'}," +
+        "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
+        "'0x3':{'name':'PAPER','beats':'0x1'}}",
+        gson.toJson(rock).replace('"', '\''));
+  }
+
+  public void testDeserialization() {
+    String json = "{'0x1':{'name':'ROCK','beats':'0x2'}," +
+        "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
+        "'0x3':{'name':'PAPER','beats':'0x1'}}";
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Roshambo.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    Roshambo rock = gson.fromJson(json, Roshambo.class);
+    assertEquals("ROCK", rock.name);
+    Roshambo scissors = rock.beats;
+    assertEquals("SCISSORS", scissors.name);
+    Roshambo paper = scissors.beats;
+    assertEquals("PAPER", paper.name);
+    assertSame(rock, paper.beats);
+  }
+
+  public void testSerializationDirectSelfReference() {
+    Roshambo suicide = new Roshambo("SUICIDE");
+    suicide.beats = suicide;
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Roshambo.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    assertEquals("{'0x1':{'name':'SUICIDE','beats':'0x1'}}",
+        gson.toJson(suicide).replace('"', '\''));
+  }
+
+  public void testDeserializationDirectSelfReference() {
+    String json = "{'0x1':{'name':'SUICIDE','beats':'0x1'}}";
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Roshambo.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    Roshambo suicide = gson.fromJson(json, Roshambo.class);
+    assertEquals("SUICIDE", suicide.name);
+    assertSame(suicide, suicide.beats);
+  }
+
+  public void testSerializeListOfLists() {
+    Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();
+    Type listOfAnyType = new TypeToken<List<?>>() {}.getType();
+
+    List<List<?>> listOfLists = new ArrayList<List<?>>();
+    listOfLists.add(listOfLists);
+    listOfLists.add(new ArrayList<Object>());
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(listOfListsType)
+        .addType(listOfAnyType)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    String json = gson.toJson(listOfLists, listOfListsType);
+    assertEquals("{'0x1':['0x1','0x2'],'0x2':[]}", json.replace('"', '\''));
+  }
+
+  public void testDeserializeListOfLists() {
+    Type listOfAnyType = new TypeToken<List<?>>() {}.getType();
+    Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(listOfListsType)
+        .addType(listOfAnyType)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    List<List<?>> listOfLists = gson.fromJson("{'0x1':['0x1','0x2'],'0x2':[]}", listOfListsType);
+    assertEquals(2, listOfLists.size());
+    assertSame(listOfLists, listOfLists.get(0));
+    assertEquals(Collections.emptyList(), listOfLists.get(1));
+  }
+
+  public void testSerializationWithMultipleTypes() {
+    Company google = new Company("Google");
+    new Employee("Jesse", google);
+    new Employee("Joel", google);
+
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Company.class)
+        .addType(Employee.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    assertEquals("{'0x1':{'name':'Google','employees':['0x2','0x3']},"
+        + "'0x2':{'name':'Jesse','company':'0x1'},"
+        + "'0x3':{'name':'Joel','company':'0x1'}}",
+        gson.toJson(google).replace('"', '\''));
+  }
+
+  public void testDeserializationWithMultipleTypes() {
+    GsonBuilder gsonBuilder = new GsonBuilder();
+    new GraphAdapterBuilder()
+        .addType(Company.class)
+        .addType(Employee.class)
+        .registerOn(gsonBuilder);
+    Gson gson = gsonBuilder.create();
+
+    String json = "{'0x1':{'name':'Google','employees':['0x2','0x3']},"
+        + "'0x2':{'name':'Jesse','company':'0x1'},"
+        + "'0x3':{'name':'Joel','company':'0x1'}}";
+    Company company = gson.fromJson(json, Company.class);
+    assertEquals("Google", company.name);
+    Employee jesse = company.employees.get(0);
+    assertEquals("Jesse", jesse.name);
+    assertEquals(company, jesse.company);
+    Employee joel = company.employees.get(1);
+    assertEquals("Joel", joel.name);
+    assertEquals(company, joel.company);
+  }
+
+  static class Roshambo {
+    String name;
+    Roshambo beats;
+    Roshambo(String name) {
+      this.name = name;
+    }
+  }
+
+  static class Employee {
+    final String name;
+    final Company company;
+    Employee(String name, Company company) {
+      this.name = name;
+      this.company = company;
+      this.company.employees.add(this);
+    }
+  }
+
+  static class Company {
+    final String name;
+    final List<Employee> employees = new ArrayList<Employee>();
+    Company(String name) {
+      this.name = name;
+    }
+  }
+}
diff --git a/src/test/java/com/google/gson/interceptors/InterceptorTest.java b/src/test/java/com/google/gson/interceptors/InterceptorTest.java
new file mode 100644
index 000000000..0aab6598c
--- /dev/null
+++ b/src/test/java/com/google/gson/interceptors/InterceptorTest.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.interceptors;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link Intercept} and {@link JsonPostDeserializer}.
+ *
+ * @author Inderjeet Singh
+ */
+public final class InterceptorTest extends TestCase {
+
+  private Gson gson;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    this.gson = new GsonBuilder()
+        .registerTypeAdapterFactory(new InterceptorFactory())
+        .enableComplexMapKeySerialization()
+        .create();
+  }
+
+  public void testExceptionsPropagated() {
+    try {
+      gson.fromJson("{}", User.class);
+      fail();
+    } catch (JsonParseException expected) {}
+  }
+
+  public void testTopLevelClass() {
+    User user = gson.fromJson("{name:'bob',password:'pwd'}", User.class);
+    assertEquals(User.DEFAULT_EMAIL, user.email);
+  }
+
+  public void testList() {
+    List<User> list = gson.fromJson("[{name:'bob',password:'pwd'}]", new TypeToken<List<User>>(){}.getType());
+    User user = list.get(0);
+    assertEquals(User.DEFAULT_EMAIL, user.email);
+  }
+
+  public void testCollection() {
+    Collection<User> list = gson.fromJson("[{name:'bob',password:'pwd'}]", new TypeToken<Collection<User>>(){}.getType());
+    User user = list.iterator().next();
+    assertEquals(User.DEFAULT_EMAIL, user.email);
+  }
+
+  public void testMapKeyAndValues() {
+    Type mapType = new TypeToken<Map<User, Address>>(){}.getType();
+    try {
+      gson.fromJson("[[{name:'bob',password:'pwd'},{}]]", mapType);
+      fail();
+    } catch (JsonSyntaxException expected) {}
+    Map<User, Address> map = gson.fromJson("[[{name:'bob',password:'pwd'},{city:'Mountain View',state:'CA',zip:'94043'}]]",
+        mapType);
+    Entry<User, Address> entry = map.entrySet().iterator().next();
+    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);
+    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);
+  }
+
+  public void testField() {
+    UserGroup userGroup = gson.fromJson("{user:{name:'bob',password:'pwd'}}", UserGroup.class);
+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
+  }
+
+  public void testCustomTypeAdapter() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(User.class, new TypeAdapter<User>() {
+          @Override public void write(JsonWriter out, User value) throws IOException {
+            throw new UnsupportedOperationException();
+          }
+
+          @Override public User read(JsonReader in) throws IOException {
+            in.beginObject();
+            in.nextName();
+            String name = in.nextString();
+            in.nextName();
+            String password = in.nextString();
+            in.endObject();
+            return new User(name, password);
+          }
+        })
+        .registerTypeAdapterFactory(new InterceptorFactory())
+        .create();
+    UserGroup userGroup = gson.fromJson("{user:{name:'bob',password:'pwd'}}", UserGroup.class);
+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
+  }
+
+  public void testDirectInvocationOfTypeAdapter() throws Exception {
+    TypeAdapter<UserGroup> adapter = gson.getAdapter(UserGroup.class);
+    UserGroup userGroup = adapter.fromJson("{\"user\":{\"name\":\"bob\",\"password\":\"pwd\"}}");
+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
+  }
+
+  @SuppressWarnings("unused")
+  private static final class UserGroup {
+    User user;
+    String city;
+  }
+
+  @Intercept(postDeserialize = UserValidator.class)
+  @SuppressWarnings("unused")
+  private static final class User {
+    static final String DEFAULT_EMAIL = "invalid@invalid.com";
+    String name;
+    String password;
+    String email;
+    Address address;
+    public User(String name, String password) {
+      this.name = name;
+      this.password = password;
+    }
+  }
+
+  public static final class UserValidator implements JsonPostDeserializer<User> {
+    public void postDeserialize(User user) {
+      if (user.name == null || user.password == null) {
+        throw new JsonSyntaxException("name and password are required fields.");
+      }
+      if (user.email == null) user.email = User.DEFAULT_EMAIL;
+    }
+  }
+
+  @Intercept(postDeserialize = AddressValidator.class)
+  @SuppressWarnings("unused")
+  private static final class Address {
+    static final String DEFAULT_FIRST_LINE = "unknown";
+    String firstLine;
+    String secondLine;
+    String city;
+    String state;
+    String zip;
+  }
+
+  public static final class AddressValidator implements JsonPostDeserializer<Address> {
+    public void postDeserialize(Address address) {
+      if (address.city == null || address.state == null || address.zip == null) {
+        throw new JsonSyntaxException("Address city, state and zip are required fields.");
+      }
+      if (address.firstLine == null) address.firstLine = Address.DEFAULT_FIRST_LINE;
+    }
+  }
+}
diff --git a/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java b/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
new file mode 100644
index 000000000..902dc4774
--- /dev/null
+++ b/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import junit.framework.TestCase;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+public final class UtcDateTypeAdapterTest extends TestCase {
+  private final Gson gson = new GsonBuilder()
+    .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
+    .create();
+
+  public void testLocalTimeZone() {
+    Date expected = new Date();
+    String json = gson.toJson(expected);
+    Date actual = gson.fromJson(json, Date.class);
+    assertEquals(expected.getTime(), actual.getTime());
+  }
+
+  public void testDifferentTimeZones() {
+    for (String timeZone : TimeZone.getAvailableIDs()) {
+      Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
+      Date expected = cal.getTime();
+      String json = gson.toJson(expected);
+      // System.out.println(json + ": " + timeZone);
+      Date actual = gson.fromJson(json, Date.class);
+      assertEquals(expected.getTime(), actual.getTime());
+    }
+  }
+
+  /**
+   * JDK 1.7 introduced support for XXX format to indicate UTC date. But Android is older JDK.
+   * We want to make sure that this date is parseable in Android.
+   */
+  public void testUtcDatesOnJdkBefore1_7() {
+    Gson gson = new GsonBuilder()
+      .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
+      .create();
+    gson.fromJson("'2014-12-05T04:00:00.000Z'", Date.class);
+  }
+
+  public void testUtcWithJdk7Default() {
+    Date expected = new Date();
+    SimpleDateFormat iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX", Locale.US);
+    iso8601Format.setTimeZone(TimeZone.getTimeZone("UTC"));
+    String expectedJson = "\"" + iso8601Format.format(expected) + "\"";
+    String actualJson = gson.toJson(expected);
+    assertEquals(expectedJson, actualJson);
+    Date actual = gson.fromJson(expectedJson, Date.class);
+    assertEquals(expected.getTime(), actual.getTime());
+  }
+
+  public void testNullDateSerialization() {
+    String json = gson.toJson(null, Date.class);
+    assertEquals("null", json);
+  }
+}
