diff --git a/gson/build.gradle b/gson/build.gradle
deleted file mode 100644
index c3e8597f0..000000000
--- a/gson/build.gradle
+++ /dev/null
@@ -1,13 +0,0 @@
-apply plugin: 'java'
-apply plugin: 'maven'
-
-group = 'com.google.code.gson'
-version = '2.8.6-SNAPSHOT'
-
-sourceCompatibility = 11
-targetCompatibility = 11
-
-sourceSets.main.java.exclude("**/module-info.java")
-dependencies {
-    testCompile "junit:junit:4.12"
-}
diff --git a/gson/pom.xml b/gson/pom.xml
index 3a54c98dd..a6bd4db1a 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -12,10 +12,11 @@
 
   <dependencies>
     <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
+	    <groupId>junit</groupId>
+	    <artifactId>junit</artifactId>
+	    <version>4.12</version>
+	    <scope>test</scope>
+	</dependency>
   </dependencies>
  
   <build>
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 26a20c5d3..0e963e197 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -159,8 +159,6 @@
 		factories.add(TypeAdapters.UUID_FACTORY);
 		factories.add(TypeAdapters.CURRENCY_FACTORY);
 		factories.add(TypeAdapters.LOCALE_FACTORY);
-		factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
-		factories.add(TypeAdapters.BIT_SET_FACTORY);
 		factories.add(ArrayTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.CLASS_FACTORY);
 		factories.add(LocalTimeAdapter.factory);
@@ -263,10 +261,6 @@ public static JsonElement parseReader(JsonReader reader) throws JsonIOException,
 		}
 	}
 
-	public Excluder excluder() {
-		return excluder;
-	}
-
 	public Function<Field, String> fieldNamingStrategy() {
 		return fieldNamingStrategy;
 	}
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index ba7ccafa6..2180891a5 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -60,44 +60,42 @@
  * @author Jesse Wilson
  */
 public final class GsonBuilder {
-	private Excluder excluder = Excluder.DEFAULT;
-	private Function<Field, String> fieldNamingPolicy = FieldNamingStrategies.IDENTITY;
-	private final Map<Type, InstanceCreator<?>> instanceCreators
-	= new HashMap<>();
-	private final List<TypeAdapterFactory> factories = new ArrayList<>();
+	private Excluder excluder;
+	private Function<Field, String> fieldNamingPolicy;
+	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final List<TypeAdapterFactory> factories;
 	/** tree-style hierarchy factories. These come after factories for backwards compatibility. */
-	private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();
-	private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
-	private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
-	private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
-	private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
-	private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+	private final List<TypeAdapterFactory> hierarchyFactories;
+	private boolean serializeNulls;
+	private boolean complexMapKeySerialization;
+	private boolean escapeHtmlChars;
+	private boolean prettyPrinting;
+	private boolean generateNonExecutableJson;
 
-	/**
-	 * Creates a GsonBuilder instance that can be used to build Gson with various configuration
-	 * settings. GsonBuilder follows the builder pattern, and it is typically used by first
-	 * invoking various configuration methods to set desired options, and finally calling
-	 * {@link #create()}.
-	 */
-	GsonBuilder() {}
+	GsonBuilder() {
+		this.excluder = Excluder.DEFAULT;
+		this.fieldNamingPolicy = FieldNamingStrategies.IDENTITY;
+		this.instanceCreators = new HashMap<>();
+		this.factories = new ArrayList<>();
+		this.hierarchyFactories = new ArrayList<>();
+		this.serializeNulls = DEFAULT_SERIALIZE_NULLS;
+		this.complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
+		this.escapeHtmlChars = DEFAULT_ESCAPE_HTML;
+		this.prettyPrinting = DEFAULT_PRETTY_PRINT;
+		this.generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+	}
 
-	/**
-	 * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
-	 * has the same configuration as the previously built Gson instance.
-	 *
-	 * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
-	 */
 	GsonBuilder(Gson gson) {
 		this.excluder = gson.excluder;
 		this.fieldNamingPolicy = gson.fieldNamingStrategy;
-		this.instanceCreators.putAll(gson.instanceCreators);
+		this.instanceCreators = new HashMap<>(gson.instanceCreators);
 		this.serializeNulls = gson.serializeNulls;
 		this.complexMapKeySerialization = gson.complexMapKeySerialization;
 		this.generateNonExecutableJson = gson.generateNonExecutableJson;
 		this.escapeHtmlChars = gson.htmlSafe;
 		this.prettyPrinting = gson.prettyPrinting;
-		this.factories.addAll(gson.builderFactories);
-		this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+		this.factories = new ArrayList<>(gson.builderFactories);
+		this.hierarchyFactories = new ArrayList<>(gson.builderHierarchyFactories);
 	}
 
 	/**
@@ -281,7 +279,7 @@ public GsonBuilder setFieldNamingStrategy(Function<Field, String> fieldNamingStr
 	 * @since 1.4
 	 */
 	public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
-		for (ExclusionStrategy strategy : strategies) {
+		for (var strategy : strategies) {
 			excluder = excluder.withExclusionStrategy(strategy, true, true);
 		}
 		return this;
@@ -362,13 +360,9 @@ public GsonBuilder disableHtmlEscaping() {
 	 */
 	@SuppressWarnings({"unchecked", "rawtypes"})
 	public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
-		$Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+		GsonHelpers.checkArgument(typeAdapter instanceof JsonSerializer<?>
 		|| typeAdapter instanceof JsonDeserializer<?>
-		|| typeAdapter instanceof InstanceCreator<?>
 		|| typeAdapter instanceof TypeAdapter<?>);
-		if (typeAdapter instanceof InstanceCreator<?>) {
-			instanceCreators.put(type, (InstanceCreator) typeAdapter);
-		}
 		if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {
 			TypeToken<?> typeToken = TypeToken.get(type);
 			factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));
@@ -378,6 +372,11 @@ public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
 		}
 		return this;
 	}
+	
+	public GsonBuilder registerInstanceCreator(Type type, InstanceCreator<?> instanceCreator) {
+		instanceCreators.put(type, instanceCreator);
+		return this;
+	}
 
 	/**
 	 * Register a factory for type adapters. Registering a factory is useful when the type
@@ -408,7 +407,7 @@ public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
 	 */
 	@SuppressWarnings({"unchecked", "rawtypes"})
 	public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
-		$Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+		GsonHelpers.checkArgument(typeAdapter instanceof JsonSerializer<?>
 		|| typeAdapter instanceof JsonDeserializer<?>
 		|| typeAdapter instanceof TypeAdapter<?>);
 		if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
diff --git a/gson/src/main/java/com/google/gson/InstanceCreator.java b/gson/src/main/java/com/google/gson/InstanceCreator.java
index 4805682f0..c71d11ab5 100644
--- a/gson/src/main/java/com/google/gson/InstanceCreator.java
+++ b/gson/src/main/java/com/google/gson/InstanceCreator.java
@@ -88,5 +88,5 @@
    * @param type the parameterized T represented as a {@link Type}.
    * @return a default object instance of type T.
    */
-  public T createInstance(Type type);
+  public T createInstance(Class<T> type);
 }
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index 60f1a3877..39b5e6f76 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -21,6 +21,8 @@
 import java.io.*;
 import java.math.*;
 import java.util.*;
+import java.util.function.*;
+import java.util.stream.*;
 
 /**
  * A class representing an array type in Json. An array is a list of {@link JsonElement}s each of
@@ -31,7 +33,7 @@
  * @author Joel Leitch
  */
 public final class JsonArray extends JsonElement implements Iterable<JsonElement> {
-	private final List<JsonElement> elements;
+	private final ArrayList<JsonElement> elements;
 
 	/**
 	 * Creates an empty JsonArray.
@@ -159,6 +161,21 @@ public JsonElement remove(int index) {
 	public boolean contains(JsonElement element) {
 		return elements.contains(element);
 	}
+	
+	public Stream<JsonElement> stream(){
+		return elements.stream();
+	}
+	
+	public Stream<JsonObject> objectStream(){
+		return elements.stream().map(JsonElement::getAsJsonObject);
+	}
+	
+	@Override
+	public void forEach(Consumer<? super JsonElement> action) {
+		for(var e : elements) {
+			action.accept(e);
+		}
+	}
 
 	/**
 	 * Returns the number of elements in the array.
@@ -362,4 +379,4 @@ public String toString() {
 	public int hashCode() {
 		return elements.hashCode();
 	}
-}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 56a5133ba..89e838f4d 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -40,8 +40,8 @@
 	 */
 	@Override
 	public JsonObject deepCopy() {
-		JsonObject result = new JsonObject();
-		for (Map.Entry<String, JsonElement> entry : members.entrySet()) {
+		var result = new JsonObject();
+		for (var entry : members.entrySet()) {
 			result.add(entry.getKey(), entry.getValue().deepCopy());
 		}
 		return result;
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index 3ec496dc9..d897ce1c2 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -27,7 +27,7 @@
 import java.lang.reflect.WildcardType;
 import java.util.*;
 
-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
+import static com.google.gson.internal.GsonHelpers.checkArgument;
 
 /**
  * Static methods for working with types.
@@ -421,22 +421,13 @@ static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVaria
 
 		Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
 		if (declaredBy instanceof ParameterizedType) {
-			int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+			int index = GsonHelpers.indexOf(declaredByRaw.getTypeParameters(), unknown);
 			return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
 		}
 
 		return unknown;
 	}
 
-	private static int indexOf(Object[] array, Object toFind) {
-		for (int i = 0, length = array.length; i < length; i++) {
-			if (toFind.equals(array[i])) {
-				return i;
-			}
-		}
-		throw new NoSuchElementException();
-	}
-
 	/**
 	 * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
 	 * a class.
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index df8794e6e..7150c5cf6 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -30,14 +30,14 @@
 
   public static <T> Supplier<T> get(TypeToken<T> typeToken, Map<Type, InstanceCreator<?>> instanceCreators) {
     final Type type = typeToken.getType();
-    final Class<? super T> rawType = typeToken.getRawType();
+    final Class<T> rawType = (Class<T>) typeToken.getRawType();
 
     // first try an instance creator
 
     @SuppressWarnings("unchecked") // types must agree
     final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
     if (typeCreator != null) {
-      return () -> typeCreator.createInstance(type);
+      return () -> typeCreator.createInstance(rawType);
     }
 
     // Next try raw type match for instance creators
@@ -45,7 +45,7 @@
     final InstanceCreator<T> rawTypeCreator =
         (InstanceCreator<T>) instanceCreators.get(rawType);
     if (rawTypeCreator != null) {
-      return () -> rawTypeCreator.createInstance(type);
+      return () -> rawTypeCreator.createInstance(rawType);
     }
 
     Supplier<T> defaultConstructor = newDefaultConstructor(rawType);
@@ -64,8 +64,8 @@
 
   private static <T> Supplier<T> newDefaultConstructor(Class<? super T> rawType) {
     try {
-      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
-      if (!constructor.isAccessible()) {
+      var constructor = rawType.getDeclaredConstructor();
+      if(!constructor.canAccess(null)){
         constructor.setAccessible(true);
       }
       return () -> {
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java b/gson/src/main/java/com/google/gson/internal/GsonHelpers.java
similarity index 69%
rename from gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
rename to gson/src/main/java/com/google/gson/internal/GsonHelpers.java
index e7314fe61..67a803f5d 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
+++ b/gson/src/main/java/com/google/gson/internal/GsonHelpers.java
@@ -29,10 +29,19 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public final class $Gson$Preconditions {
-  public static void checkArgument(boolean condition) {
-    if (!condition) {
-      throw new IllegalArgumentException();
-    }
-  }
-}
+public final class GsonHelpers {
+	public static void checkArgument(boolean condition) {
+		if (!condition) {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	public static<T> int indexOf(T[] array, T toFind) {
+		for (int i = 0, length = array.length; i < length; i++) {
+			if (array[i].equals(toFind)) {
+				return i;
+			}
+		}
+		return -1;
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
index 04bc47bb7..e3899a535 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
@@ -16,83 +16,83 @@
 
 package com.google.gson.internal.bind;
 
-import java.io.IOException;
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+import com.google.gson.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
 
 /**
  * Adapt an array of objects.
  */
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      Type type = typeToken.getType();
-      if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
-        return null;
-      }
-
-      Type componentType = $Gson$Types.getArrayComponentType(type);
-      TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));
-      return new ArrayTypeAdapter(
-              gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));
-    }
-  };
+	public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
+		@SuppressWarnings({"unchecked", "rawtypes"})
+		@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+			Type type = typeToken.getType();
+			if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
+				return null;
+			}
 
-  private final Class<E> componentType;
-  private final TypeAdapter<E> componentTypeAdapter;
+			Type componentType = $Gson$Types.getArrayComponentType(type);
+			TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));
+			return new ArrayTypeAdapter(gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));
+		}
+	};
 
-  public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {
-    this.componentTypeAdapter = new TypeAdapterRuntimeTypeWrapper<>(context, componentTypeAdapter, componentType);
-    this.componentType = componentType;
-  }
+	private final Class<E> componentType;
+	private final TypeAdapter<E> componentTypeAdapter;
 
-  @Override public Object read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
+	public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {
+		this.componentTypeAdapter = new TypeAdapterRuntimeTypeWrapper<>(context, componentTypeAdapter, componentType);
+		this.componentType = componentType;
+	}
 
-    List<E> list = new ArrayList<>();
-    in.beginArray();
-    while (in.hasNext()) {
-      E instance = componentTypeAdapter.read(in);
-      list.add(instance);
-    }
-    in.endArray();
+	@Override 
+	public Object read(JsonReader in) throws IOException {
+		if (in.peek() == JsonToken.NULL) {
+			in.nextNull();
+			return null;
+		}
 
-    int size = list.size();
-    Object array = Array.newInstance(componentType, size);
-    for (int i = 0; i < size; i++) {
-      Array.set(array, i, list.get(i));
-    }
-    return array;
-  }
+		var componentType = this.componentType;
+		var adapter = this.componentTypeAdapter;
+		var data = Array.newInstance(componentType, 16);
+		var arrayLen = 16;
+		var index = 0;
+		
+		in.beginArray();
+		while (in.hasNext()) {
+			if(index == arrayLen) {
+				var newLen = arrayLen + (arrayLen >> 1);
+				data = Array.newInstance(componentType, newLen);
+				arrayLen = newLen;
+			}
+			
+			Array.set(data, index++, adapter.read(in));
+		}
+		in.endArray();
+		
+		var array = Array.newInstance(componentType, index);
+		System.arraycopy(data, 0, array, 0, index);
+		
+		return array;
+	}
 
-  @SuppressWarnings("unchecked")
-  @Override public void write(JsonWriter out, Object array) throws IOException {
-    if (array == null) {
-      out.nullValue();
-      return;
-    }
+	@SuppressWarnings("unchecked")
+	@Override public void write(JsonWriter out, Object array) throws IOException {
+		if (array == null) {
+			out.nullValue();
+			return;
+		}
 
-    out.beginArray();
-    for (int i = 0, length = Array.getLength(array); i < length; i++) {
-      E value = (E) Array.get(array, i);
-      componentTypeAdapter.write(out, value);
-    }
-    out.endArray();
-  }
+		out.beginArray();
+		var adapter = this.componentTypeAdapter;
+		
+		for (int i = 0, length = Array.getLength(array); i < length; i++) {
+			adapter.write(out, (E) Array.get(array, i));
+		}
+		out.endArray();
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
index c92459e1d..58d01b891 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -29,69 +29,70 @@
  * Adapt a homogeneous collection of objects.
  */
 public final class CollectionTypeAdapterFactory implements TypeAdapterFactory {
-  private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, InstanceCreator<?>> instanceCreators;
 
-  public CollectionTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators) {
-    this.instanceCreators = instanceCreators;
-  }
+	public CollectionTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators) {
+		this.instanceCreators = instanceCreators;
+	}
 
-  @Override
-  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-    Type type = typeToken.getType();
+	@Override
+	public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
+		Type type = typeToken.getType();
 
-    Class<? super T> rawType = typeToken.getRawType();
-    if (!Collection.class.isAssignableFrom(rawType)) {
-      return null;
-    }
+		Class<? super T> rawType = typeToken.getRawType();
+		if (!Collection.class.isAssignableFrom(rawType)) {
+			return null;
+		}
 
-    Type elementType = $Gson$Types.getCollectionElementType(type, rawType);
-    TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
-    Supplier<T> constructor = ConstructorConstructor.get(typeToken, instanceCreators);
+		Type elementType = $Gson$Types.getCollectionElementType(type, rawType);
+		TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
+		Supplier<T> constructor = ConstructorConstructor.get(typeToken, instanceCreators);
 
-    @SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
-    TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);
-    return result;
-  }
+		@SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
+		TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);
+		return result;
+	}
 
-  private static final class Adapter<E> extends TypeAdapter<Collection<E>> {
-    private final TypeAdapter<E> elementTypeAdapter;
-    private final Supplier<? extends Collection<E>> constructor;
+	private static final class Adapter<E> extends TypeAdapter<Collection<E>> {
+		private final TypeAdapter<E> elementTypeAdapter;
+		private final Supplier<? extends Collection<E>> constructor;
 
-    public Adapter(Gson context, Type elementType,
-        TypeAdapter<E> elementTypeAdapter,
-        Supplier<? extends Collection<E>> constructor) {
-      this.elementTypeAdapter =
-          new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);
-      this.constructor = constructor;
-    }
+		public Adapter(Gson context, Type elementType, TypeAdapter<E> elementTypeAdapter, Supplier<? extends Collection<E>> constructor) {
+			this.elementTypeAdapter = new TypeAdapterRuntimeTypeWrapper<>(context, elementTypeAdapter, elementType);
+			this.constructor = constructor;
+		}
 
-    @Override public Collection<E> read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
+		@Override 
+		public Collection<E> read(JsonReader in) throws IOException {
+			if (in.peek() == JsonToken.NULL) {
+				in.nextNull();
+				return null;
+			}
 
-      Collection<E> collection = constructor.get();
-      in.beginArray();
-      while (in.hasNext()) {
-        E instance = elementTypeAdapter.read(in);
-        collection.add(instance);
-      }
-      in.endArray();
-      return collection;
-    }
+			var collection = constructor.get();
+			var adapter = elementTypeAdapter;
 
-    @Override public void write(JsonWriter out, Collection<E> collection) throws IOException {
-      if (collection == null) {
-        out.nullValue();
-        return;
-      }
+			in.beginArray();
+			while (in.hasNext()) {
+				collection.add(adapter.read(in));
+			}
+			in.endArray();
+			return collection;
+		}
 
-      out.beginArray();
-      for (E element : collection) {
-        elementTypeAdapter.write(out, element);
-      }
-      out.endArray();
-    }
-  }
-}
+		@Override 
+		public void write(JsonWriter out, Collection<E> collection) throws IOException {
+			if (collection == null) {
+				out.nullValue();
+				return;
+			}
+
+			var adapter = elementTypeAdapter;
+			out.beginArray();
+			for (var element : collection) {
+				adapter.write(out, element);
+			}
+			out.endArray();
+		}
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java
index 1d03c719f..9b985dd24 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java
@@ -9,6 +9,7 @@
 public class InstantTypeAdapter extends TypeAdapter<Instant>{
 	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
 		
+		@SuppressWarnings("unchecked")
 		@Override
 		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
 			return type.getRawType() == Instant.class ? (TypeAdapter<T>) new InstantTypeAdapter() : null;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
index 5cb218fc6..c947007af 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
@@ -11,6 +11,7 @@
 
 	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
 		
+		@SuppressWarnings("unchecked")
 		@Override
 		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
 			return type.getRawType() == LocalDate.class ? (TypeAdapter<T>) new LocalDateAdapter() : null;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
index bb557eff8..3f1ff1dca 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
@@ -9,6 +9,7 @@
 public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime>{
 
 	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
+		@SuppressWarnings("unchecked")
 		@Override
 		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
 			return type.getRawType() == LocalDateTime.class ? (TypeAdapter<T>) new LocalDateTimeAdapter() : null;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java
index 4bb845181..adc35952e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java
@@ -9,6 +9,7 @@
 public class LocalTimeAdapter extends TypeAdapter<LocalTime>{
 	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
 		
+		@SuppressWarnings("unchecked")
 		@Override
 		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
 			return type.getRawType() == LocalTime.class ? (TypeAdapter<T>) new LocalTimeAdapter() : null;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index ec42e0482..3e3519b4a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -35,75 +35,75 @@
  * serialization and a primitive/Map/List on deserialization.
  */
 public final class ObjectTypeAdapter extends TypeAdapter<Object> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked")
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-      if (type.getRawType() == Object.class) {
-        return (TypeAdapter<T>) new ObjectTypeAdapter(gson);
-      }
-      return null;
-    }
-  };
-
-  private final Gson gson;
-
-  ObjectTypeAdapter(Gson gson) {
-    this.gson = gson;
-  }
-
-  @Override public Object read(JsonReader in) throws IOException {
-    JsonToken token = in.peek();
-    switch (token) {
-    case BEGIN_ARRAY:
-      List<Object> list = new ArrayList<Object>();
-      in.beginArray();
-      while (in.hasNext()) {
-        list.add(read(in));
-      }
-      in.endArray();
-      return list;
-
-    case BEGIN_OBJECT:
-      Map<String, Object> map = new LinkedTreeMap<String, Object>();
-      in.beginObject();
-      while (in.hasNext()) {
-        map.put(in.nextName(), read(in));
-      }
-      in.endObject();
-      return map;
-
-    case STRING:
-      return in.nextString();
-
-    case NUMBER:
-      return in.nextDouble();
-
-    case BOOLEAN:
-      return in.nextBoolean();
-
-    case NULL:
-      in.nextNull();
-      return null;
-
-    default:
-      throw new IllegalStateException();
-    }
-  }
-
-  @SuppressWarnings("unchecked")
-  @Override public void write(JsonWriter out, Object value) throws IOException {
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-
-    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
-    if (typeAdapter instanceof ObjectTypeAdapter) {
-      out.beginObject();
-      out.endObject();
-      return;
-    }
-
-    typeAdapter.write(out, value);
-  }
+	public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
+		@SuppressWarnings("unchecked")
+		@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+			if (type.getRawType() == Object.class) {
+				return (TypeAdapter<T>) new ObjectTypeAdapter(gson);
+			}
+			return null;
+		}
+	};
+
+	private final Gson gson;
+
+	ObjectTypeAdapter(Gson gson) {
+		this.gson = gson;
+	}
+
+	@Override public Object read(JsonReader in) throws IOException {
+		JsonToken token = in.peek();
+		switch (token) {
+		case BEGIN_ARRAY:
+			List<Object> list = new ArrayList<Object>();
+			in.beginArray();
+			while (in.hasNext()) {
+				list.add(read(in));
+			}
+			in.endArray();
+			return list;
+
+		case BEGIN_OBJECT:
+			Map<String, Object> map = new LinkedTreeMap<String, Object>();
+			in.beginObject();
+			while (in.hasNext()) {
+				map.put(in.nextName(), read(in));
+			}
+			in.endObject();
+			return map;
+
+		case STRING:
+			return in.nextString();
+
+		case NUMBER:
+			return in.nextDouble();
+
+		case BOOLEAN:
+			return in.nextBoolean();
+
+		case NULL:
+			in.nextNull();
+			return null;
+
+		default:
+			throw new IllegalStateException();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override public void write(JsonWriter out, Object value) throws IOException {
+		if (value == null) {
+			out.nullValue();
+			return;
+		}
+
+		TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
+		if (typeAdapter instanceof ObjectTypeAdapter) {
+			out.beginObject();
+			out.endObject();
+			return;
+		}
+
+		typeAdapter.write(out, value);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 7f123f92c..b50da91b5 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -42,10 +42,6 @@ public ReflectiveTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreato
 	}
 
 	public boolean excludeField(Field f, boolean serialize) {
-		return excludeField(f, serialize, excluder);
-	}
-
-	static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 		return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);
 	}
 
@@ -71,7 +67,8 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 		return fieldNames;
 	}
 
-	@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+	@Override 
+	public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
 		Class<? super T> raw = type.getRawType();
 
 		if (!Object.class.isAssignableFrom(raw)) {
@@ -82,10 +79,8 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 		return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
 	}
 
-	private ReflectiveTypeAdapterFactory.BoundField createBoundField(
-			final Gson context, final Field field, final String name,
-			final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
-		final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
+	private ReflectiveTypeAdapterFactory.BoundField createBoundField(Gson context, Field field, String name, TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
+		boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
 		// special casing primitives here saves ~5% on Android...
 		JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
 		TypeAdapter<?> mapped = null;
@@ -95,7 +90,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 		final boolean jsonAdapterPresent = mapped != null;
 		if (mapped == null) mapped = context.getAdapter(fieldType);
 
-		final TypeAdapter<?> typeAdapter = mapped;
+		TypeAdapter<?> typeAdapter = mapped;
 		return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
 			@SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
 			@Override void write(JsonWriter writer, Object value)
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index beb97eb73..21b34b882 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -121,7 +121,7 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
 					deserializer = typeAdapter instanceof JsonDeserializer
 							? (JsonDeserializer<?>) typeAdapter
 									: null;
-							$Gson$Preconditions.checkArgument(serializer != null || deserializer != null);
+							GsonHelpers.checkArgument(serializer != null || deserializer != null);
 							this.exactType = exactType;
 							this.matchRawType = matchRawType;
 							this.hierarchyType = hierarchyType;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index 2bf37ad0a..0e1ba37b3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -26,57 +26,56 @@
 import com.google.gson.stream.JsonWriter;
 
 final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
-  private final Gson context;
-  private final TypeAdapter<T> delegate;
-  private final Type type;
+	private final Gson context;
+	private final TypeAdapter<T> delegate;
+	private final Type type;
 
-  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
-    this.context = context;
-    this.delegate = delegate;
-    this.type = type;
-  }
+	TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {
+		this.context = context;
+		this.delegate = delegate;
+		this.type = type;
+	}
 
-  @Override
-  public T read(JsonReader in) throws IOException {
-    return delegate.read(in);
-  }
+	@Override
+	public T read(JsonReader in) throws IOException {
+		return delegate.read(in);
+	}
 
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  @Override
-  public void write(JsonWriter out, T value) throws IOException {
-    // Order of preference for choosing type adapters
-    // First preference: a type adapter registered for the runtime type
-    // Second preference: a type adapter registered for the declared type
-    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
-    // Fourth preference: reflective type adapter for the declared type
+	@SuppressWarnings({"rawtypes", "unchecked"})
+	@Override
+	public void write(JsonWriter out, T value) throws IOException {
+		// Order of preference for choosing type adapters
+		// First preference: a type adapter registered for the runtime type
+		// Second preference: a type adapter registered for the declared type
+		// Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
+		// Fourth preference: reflective type adapter for the declared type
 
-    TypeAdapter chosen = delegate;
-    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
-    if (runtimeType != type) {
-      TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
-      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for the runtime type, so we will use that
-        chosen = runtimeTypeAdapter;
-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
-        // The user registered a type adapter for Base class, so we prefer it over the
-        // reflective type adapter for the runtime type
-        chosen = delegate;
-      } else {
-        // Use the type adapter for runtime type
-        chosen = runtimeTypeAdapter;
-      }
-    }
-    chosen.write(out, value);
-  }
+		TypeAdapter chosen = delegate;
+		Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);
+		if (runtimeType != type) {
+			TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));
+			if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+				// The user registered a type adapter for the runtime type, so we will use that
+				chosen = runtimeTypeAdapter;
+			} else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {
+				// The user registered a type adapter for Base class, so we prefer it over the
+				// reflective type adapter for the runtime type
+				chosen = delegate;
+			} else {
+				// Use the type adapter for runtime type
+				chosen = runtimeTypeAdapter;
+			}
+		}
+		chosen.write(out, value);
+	}
 
-  /**
-   * Finds a compatible runtime type if it is more specific
-   */
-  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
-    if (value != null
-        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
-      type = value.getClass();
-    }
-    return type;
-  }
-}
+	/**
+	 * Finds a compatible runtime type if it is more specific
+	 */
+	private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
+		if (value != null && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
+			return value.getClass();
+		}
+		return type;
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 3ae172178..fe58c704e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -25,80 +25,22 @@
 import java.math.*;
 import java.net.*;
 import java.util.*;
-import java.util.concurrent.atomic.*;
 
 /**
  * Type adapters for basic types.
  */
 public final class TypeAdapters {
-	private TypeAdapters() {
-		throw new UnsupportedOperationException();
-	}
 
-	@SuppressWarnings("rawtypes")
-	public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {
+	public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, new TypeAdapter<Class>() {
 		@Override
 		public void write(JsonWriter out, Class value) throws IOException {
-			throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
-					+ value.getName() + ". Forgot to register a type adapter?");
+			throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: " + value.getName() + ". Forgot to register a type adapter?");
 		}
 		@Override
 		public Class read(JsonReader in) throws IOException {
-			throw new UnsupportedOperationException(
-					"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
-		}
-	}.nullSafe();
-
-	public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
-
-	public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {
-		@Override public BitSet read(JsonReader in) throws IOException {
-			BitSet bitset = new BitSet();
-			in.beginArray();
-			int i = 0;
-			JsonToken tokenType = in.peek();
-			while (tokenType != JsonToken.END_ARRAY) {
-				boolean set;
-				switch (tokenType) {
-				case NUMBER:
-					set = in.nextInt() != 0;
-					break;
-				case BOOLEAN:
-					set = in.nextBoolean();
-					break;
-				case STRING:
-					String stringValue = in.nextString();
-					try {
-						set = Integer.parseInt(stringValue) != 0;
-					} catch (NumberFormatException e) {
-						throw new JsonSyntaxException(
-								"Error: Expecting: bitset number value (1, 0), Found: " + stringValue);
-					}
-					break;
-				default:
-					throw new JsonSyntaxException("Invalid bitset value type: " + tokenType);
-				}
-				if (set) {
-					bitset.set(i);
-				}
-				++i;
-				tokenType = in.peek();
-			}
-			in.endArray();
-			return bitset;
-		}
-
-		@Override public void write(JsonWriter out, BitSet src) throws IOException {
-			out.beginArray();
-			for (int i = 0, length = src.length(); i < length; i++) {
-				int value = (src.get(i)) ? 1 : 0;
-				out.value(value);
-			}
-			out.endArray();
+			throw new UnsupportedOperationException("Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
 		}
-	}.nullSafe();
-
-	public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
+	}.nullSafe());
 
 	public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<>() {
 		@Override
@@ -107,9 +49,6 @@ public Boolean read(JsonReader in) throws IOException {
 			if (peek == JsonToken.NULL) {
 				in.nextNull();
 				return null;
-			} else if (peek == JsonToken.STRING) {
-				// support strings for compatibility with GSON 1.7
-				return Boolean.parseBoolean(in.nextString());
 			}
 			return in.nextBoolean();
 		}
@@ -206,63 +145,6 @@ public void write(JsonWriter out, Number value) throws IOException {
 	public static final TypeAdapterFactory INTEGER_FACTORY
 	= newFactory(int.class, Integer.class, INTEGER);
 
-	public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {
-		@Override public AtomicInteger read(JsonReader in) throws IOException {
-			try {
-				return new AtomicInteger(in.nextInt());
-			} catch (NumberFormatException e) {
-				throw new JsonSyntaxException(e);
-			}
-		}
-		@Override public void write(JsonWriter out, AtomicInteger value) throws IOException {
-			out.value(value.get());
-		}
-	}.nullSafe();
-	public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =
-			newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);
-
-	public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {
-		@Override public AtomicBoolean read(JsonReader in) throws IOException {
-			return new AtomicBoolean(in.nextBoolean());
-		}
-		@Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {
-			out.value(value.get());
-		}
-	}.nullSafe();
-	public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =
-			newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);
-
-	public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {
-		@Override public AtomicIntegerArray read(JsonReader in) throws IOException {
-			List<Integer> list = new ArrayList<>();
-			in.beginArray();
-			while (in.hasNext()) {
-				try {
-					int integer = in.nextInt();
-					list.add(integer);
-				} catch (NumberFormatException e) {
-					throw new JsonSyntaxException(e);
-				}
-			}
-			in.endArray();
-			int length = list.size();
-			AtomicIntegerArray array = new AtomicIntegerArray(length);
-			for (int i = 0; i < length; ++i) {
-				array.set(i, list.get(i));
-			}
-			return array;
-		}
-		@Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {
-			out.beginArray();
-			for (int i = 0, length = value.length(); i < length; i++) {
-				out.value(value.get(i));
-			}
-			out.endArray();
-		}
-	}.nullSafe();
-	public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =
-			newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);
-
 	public static final TypeAdapter<Number> LONG = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
@@ -511,25 +393,6 @@ public void write(JsonWriter out, URI value) throws IOException {
 
 	public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);
 
-	public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<>() {
-		@Override
-		public InetAddress read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			// regrettably, this should have included both the host name and the host address
-			return InetAddress.getByName(in.nextString());
-		}
-		@Override
-		public void write(JsonWriter out, InetAddress value) throws IOException {
-			out.value(value == null ? null : value.getHostAddress());
-		}
-	};
-
-	public static final TypeAdapterFactory INET_ADDRESS_FACTORY =
-			newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);
-
 	public static final TypeAdapter<UUID> UUID = new TypeAdapter<>() {
 		@Override
 		public UUID read(JsonReader in) throws IOException {
@@ -730,8 +593,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
 		};
 	}
 
-	public static <TT> TypeAdapterFactory newFactory(
-			final Class<TT> type, final TypeAdapter<TT> typeAdapter) {
+	public static <TT> TypeAdapterFactory newFactory(Class<TT> type, TypeAdapter<TT> typeAdapter) {
 		return new TypeAdapterFactory() {
 			@SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
 			@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
diff --git a/gson/src/test/java/com/google/gson/DefaultInetAddressTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultInetAddressTypeAdapterTest.java
deleted file mode 100644
index 975548e69..000000000
--- a/gson/src/test/java/com/google/gson/DefaultInetAddressTypeAdapterTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.net.InetAddress;
-
-import junit.framework.TestCase;
-
-/**
- * Unit tests for the default serializer/deserializer for the {@code InetAddress} type.
- * 
- * @author Joel Leitch
- */
-public class DefaultInetAddressTypeAdapterTest extends TestCase {
-  private Gson gson;
-  
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    gson = Gson.newGson();
-  }
-  
-  public void testInetAddressSerializationAndDeserialization() throws Exception {
-    InetAddress address = InetAddress.getByName("8.8.8.8");
-    String jsonAddress = gson.toJson(address);
-    assertEquals("\"8.8.8.8\"", jsonAddress);
-    
-    InetAddress value = gson.fromJson(jsonAddress, InetAddress.class);
-    assertEquals(value, address);
-  } 
-}
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 99ac377d5..8f0361581 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -16,17 +16,13 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Excluder;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.HashMap;
+import com.google.gson.internal.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
+import java.util.*;
 import java.util.function.*;
-import junit.framework.TestCase;
+import junit.framework.*;
 
 /**
  * Unit tests for {@link Gson}.
@@ -47,7 +43,7 @@ public void testOverridesDefaultExcluder() {
         true, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
-    assertEquals(CUSTOM_EXCLUDER, gson.excluder());
+    assertEquals(CUSTOM_EXCLUDER, gson.excluder);
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
     assertEquals(true, gson.serializeNulls());
     assertEquals(false, gson.htmlSafe());
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index 4e05fa7c9..d22016761 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -122,7 +122,7 @@ public boolean equals(Object obj) {
     public MyParameterizedTypeInstanceCreator(T instanceOfT) {
       this.instanceOfT = instanceOfT;
     }
-    @Override public MyParameterizedType<T> createInstance(Type type) {
+    @Override public MyParameterizedType<T> createInstance(Class<MyParameterizedType<T>> type) {
       return new MyParameterizedType<T>(instanceOfT);
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index a64323cab..38b03683a 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -290,7 +290,7 @@ public StringHolder(String part1, String part2) {
   private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>,
       JsonDeserializer<StringHolder>, InstanceCreator<StringHolder> {
 
-    @Override public StringHolder createInstance(Type type) {
+    @Override public StringHolder createInstance(Class<StringHolder> type) {
       //Fill up with objects that will be thrown away
       return new StringHolder("unknown:thing");
     }
diff --git a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
index 6cfe808fd..dd361df90 100644
--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
@@ -39,7 +39,7 @@ protected void setUp() throws Exception {
     super.setUp();
     gson = Gson.newBuilder()
         .excludeFieldsWithoutExposeAnnotation()
-        .registerTypeAdapter(SomeInterface.class, new SomeInterfaceInstanceCreator())
+        .registerInstanceCreator(SomeInterface.class, type -> new SomeObject())
         .build();
   }
 
@@ -160,12 +160,6 @@ public String getExpectedJson() {
     // Do nothing
   }
   
-  private static class SomeInterfaceInstanceCreator implements InstanceCreator<SomeInterface> {
-    @Override public SomeInterface createInstance(Type type) {
-      return new SomeObject();
-    }
-  }
-  
   private static class ClassWithInterfaceField {
     @Expose
     private final SomeInterface interfaceField;
diff --git a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
index 12cc9cc83..3eb160da3 100644
--- a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
@@ -42,11 +42,7 @@
 
   public void testInstanceCreatorReturnsBaseType() {
     Gson gson = Gson.newBuilder()
-      .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
-        @Override public Base createInstance(Type type) {
-         return new Base();
-       }
-      })
+      .registerInstanceCreator(Base.class, type -> new Base())
       .build();
     String json = "{baseName:'BaseRevised',subName:'Sub'}";
     Base base = gson.fromJson(json, Base.class);
@@ -55,11 +51,7 @@ public void testInstanceCreatorReturnsBaseType() {
 
   public void testInstanceCreatorReturnsSubTypeForTopLevelObject() {
     Gson gson = Gson.newBuilder()
-    .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
-      @Override public Base createInstance(Type type) {
-        return new Sub();
-      }
-    })
+    .registerInstanceCreator(Base.class, type -> new Sub())
     .build();
 
     String json = "{baseName:'Base',subName:'SubRevised'}";
@@ -73,11 +65,7 @@ public void testInstanceCreatorReturnsSubTypeForTopLevelObject() {
 
   public void testInstanceCreatorReturnsSubTypeForField() {
     Gson gson = Gson.newBuilder()
-    .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
-      @Override public Base createInstance(Type type) {
-        return new Sub();
-      }
-    })
+    .registerInstanceCreator(Base.class, type -> new Sub())
     .build();
     String json = "{base:{baseName:'Base',subName:'SubRevised'}}";
     ClassWithBaseField target = gson.fromJson(json, ClassWithBaseField.class);
@@ -89,14 +77,9 @@ public void testInstanceCreatorReturnsSubTypeForField() {
   public void testInstanceCreatorForCollectionType() {
     @SuppressWarnings("serial")
     class SubArrayList<T> extends ArrayList<T> {}
-    InstanceCreator<List<String>> listCreator = new InstanceCreator<List<String>>() {
-      @Override public List<String> createInstance(Type type) {
-        return new SubArrayList<String>();
-      }
-    };
     Type listOfStringType = new TypeToken<List<String>>() {}.getType();
     Gson gson = Gson.newBuilder()
-        .registerTypeAdapter(listOfStringType, listCreator)
+        .registerInstanceCreator(listOfStringType, type -> new SubArrayList<String>())
         .build();
     List<String> list = gson.fromJson("[\"a\"]", listOfStringType);
     assertEquals(SubArrayList.class, list.getClass());
@@ -107,12 +90,12 @@ public void testInstanceCreatorForParametrizedType() throws Exception {
     @SuppressWarnings("serial")
     class SubTreeSet<T> extends TreeSet<T> {}
     InstanceCreator<SortedSet> sortedSetCreator = new InstanceCreator<SortedSet>() {
-      @Override public SortedSet createInstance(Type type) {
+      @Override public SortedSet createInstance(Class<SortedSet> type) {
         return new SubTreeSet();
       }
     };
     Gson gson = Gson.newBuilder()
-        .registerTypeAdapter(SortedSet.class, sortedSetCreator)
+        .registerInstanceCreator(SortedSet.class, sortedSetCreator)
         .build();
 
     Type sortedSetType = new TypeToken<SortedSet<String>>() {}.getType();
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index 85a6a1394..962c7b644 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -263,11 +263,7 @@ public void testMapStandardSubclassDeserialization() {
   }
 
   public void testMapSubclassDeserialization() {
-    Gson gson = Gson.newBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {
-      public MyMap createInstance(Type type) {
-        return new MyMap();
-      }
-    }).build();
+    Gson gson = Gson.newBuilder().registerInstanceCreator(MyMap.class, type -> new MyMap()).build();
     String json = "{\"a\":1,\"b\":2}";
     MyMap map = gson.fromJson(json, MyMap.class);
     assertEquals("1", map.get("a"));
@@ -278,15 +274,12 @@ public void testCustomSerializerForSpecificMapType() {
     Type type = $Gson$Types.newParameterizedTypeWithOwner(
         null, Map.class, String.class, Long.class);
     Gson gson = Gson.newBuilder()
-        .registerTypeAdapter(type, new JsonSerializer<Map<String, Long>>() {
-          public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
-              JsonSerializationContext context) {
-            JsonArray array = new JsonArray();
-            for (long value : src.values()) {
-              array.add(new JsonPrimitive(value));
-            }
-            return array;
-          }
+        .registerTypeAdapter(type, (JsonSerializer<Map<String, Long>>) (src, typeOfSrc, context) -> {
+		JsonArray array = new JsonArray();
+		for (long value : src.values()) {
+		  array.add(new JsonPrimitive(value));
+		}
+		return array;
         }).build();
 
     Map<String, Long> src = new LinkedHashMap<String, Long>();
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index a81fccef8..5b69cca2b 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -311,12 +311,7 @@ public void testClassWithObjectFieldSerialization() {
 
   public void testInnerClassDeserialization() {
     final Parent p = new Parent();
-    Gson gson = Gson.newBuilder().registerTypeAdapter(
-        Parent.Child.class, new InstanceCreator<Parent.Child>() {
-      public Parent.Child createInstance(Type type) {
-        return p.new Child();
-      }
-    }).build();
+    Gson gson = Gson.newBuilder().registerInstanceCreator(Parent.Child.class, type -> p.new Child()).build();
     String json = "{'value2':3}";
     Parent.Child c = gson.fromJson(json, Parent.Child.class);
     assertEquals(3, c.value2);
diff --git a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
index 50bffa6ec..07da6692d 100644
--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
@@ -63,7 +63,7 @@ public void testParameterizedTypeDeserialization() throws Exception {
     MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);
     Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();
     BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();
-    Gson gson = Gson.newBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerInstanceCreator(
         expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))
         .build();
 
@@ -119,8 +119,8 @@ public void testParameterizedTypesWithCustomDeserializer() {
     Gson gson = Gson.newBuilder().registerTypeAdapter(
         ptIntegerType, new MyParameterizedTypeAdapter<Integer>())
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())
-        .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""))
-        .registerTypeAdapter(ptIntegerType,
+        .registerInstanceCreator(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""))
+        .registerInstanceCreator(ptIntegerType,
             new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))
         .build();
 
@@ -148,7 +148,7 @@ public void testParameterizedTypeWithReaderDeserialization() throws Exception {
     MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);
     Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();
     BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();
-    Gson gson = Gson.newBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerInstanceCreator(
         expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))
         .build();
 
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 160ab94e9..04afcefc8 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -739,10 +739,4 @@ public void testDeserializingBigIntegerAsBigDecimal() {
       gson.fromJson("12121211243123245845384534687435634558945453489543985435", BigDecimal.class);
     assertEquals("12121211243123245845384534687435634558945453489543985435", actual.toPlainString());
   }
-
-  public void testStringsAsBooleans() {
-    String json = "['true', 'false', 'TRUE', 'yes', '1']";
-    assertEquals(Arrays.asList(true, false, true, false, false),
-        gson.<List<Boolean>>fromJson(json, new TypeToken<List<Boolean>>() {}.getType()));
-  }
 }
