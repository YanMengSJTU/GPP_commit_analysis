diff --git a/gson/src/main/java/com/google/gson/ExclusionStrategy.java b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
index ea452681c..eb6a21054 100644
--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java
+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
@@ -16,6 +16,8 @@
 
 package com.google.gson;
 
+import java.lang.reflect.*;
+
 /**
  * A strategy (or policy) definition that is used to decide whether or not a field or top-level
  * class should be serialized or deserialized as part of the JSON output/input. For serialization,
@@ -94,16 +96,15 @@
  * @since 1.4
  */
 public interface ExclusionStrategy {
+	/**
+	 * @param f the field object that is under test
+	 * @return true if the field should be ignored; otherwise false
+	 */
+	public boolean shouldSkipField(Field f);
 
-  /**
-   * @param f the field object that is under test
-   * @return true if the field should be ignored; otherwise false
-   */
-  public boolean shouldSkipField(FieldAttributes f);
-
-  /**
-   * @param clazz the class object that is under test
-   * @return true if the class should be ignored; otherwise false
-   */
-  public boolean shouldSkipClass(Class<?> clazz);
-}
+	/**
+	 * @param clazz the class object that is under test
+	 * @return true if the class should be ignored; otherwise false
+	 */
+	public boolean shouldSkipClass(Class<?> clazz);
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/FieldAttributes.java b/gson/src/main/java/com/google/gson/FieldAttributes.java
deleted file mode 100644
index 4ee906a60..000000000
--- a/gson/src/main/java/com/google/gson/FieldAttributes.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import com.google.gson.internal.$Gson$Preconditions;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.Arrays;
-import java.util.Collection;
-
-/**
- * A data object that stores attributes of a field.
- *
- * <p>This class is immutable; therefore, it can be safely shared across threads.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- *
- * @since 1.4
- */
-public final class FieldAttributes {
-  private final Field field;
-
-  /**
-   * Constructs a Field Attributes object from the {@code f}.
-   *
-   * @param f the field to pull attributes from
-   */
-  public FieldAttributes(Field f) {
-    $Gson$Preconditions.checkNotNull(f);
-    this.field = f;
-  }
-
-  /**
-   * @return the declaring class that contains this field
-   */
-  public Class<?> getDeclaringClass() {
-    return field.getDeclaringClass();
-  }
-
-  /**
-   * @return the name of the field
-   */
-  public String getName() {
-    return field.getName();
-  }
-
-  /**
-   * <p>For example, assume the following class definition:
-   * <pre class="code">
-   * public class Foo {
-   *   private String bar;
-   *   private List&lt;String&gt; red;
-   * }
-   *
-   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
-   * </pre>
-   *
-   * <p>This method would return {@code String.class} for the {@code bar} field and
-   * {@code listParameterizedType} for the {@code red} field.
-   *
-   * @return the specific type declared for this field
-   */
-  public Type getDeclaredType() {
-    return field.getGenericType();
-  }
-
-  /**
-   * Returns the {@code Class} object that was declared for this field.
-   *
-   * <p>For example, assume the following class definition:
-   * <pre class="code">
-   * public class Foo {
-   *   private String bar;
-   *   private List&lt;String&gt; red;
-   * }
-   * </pre>
-   *
-   * <p>This method would return {@code String.class} for the {@code bar} field and
-   * {@code List.class} for the {@code red} field.
-   *
-   * @return the specific class object that was declared for the field
-   */
-  public Class<?> getDeclaredClass() {
-    return field.getType();
-  }
-
-  /**
-   * Return the {@code T} annotation object from this field if it exist; otherwise returns
-   * {@code null}.
-   *
-   * @param annotation the class of the annotation that will be retrieved
-   * @return the annotation instance if it is bound to the field; otherwise {@code null}
-   */
-  public <T extends Annotation> T getAnnotation(Class<T> annotation) {
-    return field.getAnnotation(annotation);
-  }
-
-  /**
-   * Return the annotations that are present on this field.
-   *
-   * @return an array of all the annotations set on the field
-   * @since 1.4
-   */
-  public Collection<Annotation> getAnnotations() {
-    return Arrays.asList(field.getAnnotations());
-  }
-
-  /**
-   * Returns {@code true} if the field is defined with the {@code modifier}.
-   *
-   * <p>This method is meant to be called as:
-   * <pre class="code">
-   * boolean hasPublicModifier = fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);
-   * </pre>
-   *
-   * @see java.lang.reflect.Modifier
-   */
-  public boolean hasModifier(int modifier) {
-    return (field.getModifiers() & modifier) != 0;
-  }
-
-  /**
-   * Returns the value of the field represented by this {@code Field}, on
-   * the specified object. The value is automatically wrapped in an
-   * object if it has a primitive type.
-   *
-   * @return the value of the represented field in object
-   * {@code obj}; primitive values are wrapped in an appropriate
-   * object before being returned
-   * @throws IllegalAccessException
-   * @throws IllegalArgumentException
-   */
-  Object get(Object instance) throws IllegalAccessException {
-    return field.get(instance);
-  }
-
-  /**
-   * This is exposed internally only for the removing synthetic fields from the JSON output.
-   *
-   * @return true if the field is synthetic; otherwise false
-   */
-  boolean isSynthetic() {
-    return field.isSynthetic();
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
deleted file mode 100644
index 2e833cd07..000000000
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.lang.reflect.Field;
-import java.util.Locale;
-
-/**
- * An enumeration that defines a few standard naming conventions for JSON field names.
- * This enumeration should be used in conjunction with {@link com.google.gson.GsonBuilder}
- * to configure a {@link com.google.gson.Gson} instance to properly translate Java field
- * names into the desired JSON field names.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public enum FieldNamingPolicy implements FieldNamingStrategy {
-
-  /**
-   * Using this naming policy with Gson will ensure that the field name is
-   * unchanged.
-   */
-  IDENTITY() {
-    @Override public String translateName(Field f) {
-      return f.getName();
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will ensure that the first "letter" of the Java
-   * field name is capitalized when serialized to its JSON form.
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> SomeFieldName</li>
-   *   <li>_someFieldName ---> _SomeFieldName</li>
-   * </ul>
-   */
-  UPPER_CAMEL_CASE() {
-    @Override public String translateName(Field f) {
-      return upperCaseFirstLetter(f.getName());
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will ensure that the first "letter" of the Java
-   * field name is capitalized when serialized to its JSON form and the words will be
-   * separated by a space.
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> Some Field Name</li>
-   *   <li>_someFieldName ---> _Some Field Name</li>
-   * </ul>
-   *
-   * @since 1.4
-   */
-  UPPER_CAMEL_CASE_WITH_SPACES() {
-    @Override public String translateName(Field f) {
-      return upperCaseFirstLetter(separateCamelCase(f.getName(), " "));
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will modify the Java Field name from its camel cased
-   * form to a lower case field name where each word is separated by an underscore (_).
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> some_field_name</li>
-   *   <li>_someFieldName ---> _some_field_name</li>
-   *   <li>aStringField ---> a_string_field</li>
-   *   <li>aURL ---> a_u_r_l</li>
-   * </ul>
-   */
-  LOWER_CASE_WITH_UNDERSCORES() {
-    @Override public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will modify the Java Field name from its camel cased
-   * form to a lower case field name where each word is separated by a dash (-).
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> some-field-name</li>
-   *   <li>_someFieldName ---> _some-field-name</li>
-   *   <li>aStringField ---> a-string-field</li>
-   *   <li>aURL ---> a-u-r-l</li>
-   * </ul>
-   * Using dashes in JavaScript is not recommended since dash is also used for a minus sign in
-   * expressions. This requires that a field named with dashes is always accessed as a quoted
-   * property like {@code myobject['my-field']}. Accessing it as an object field
-   * {@code myobject.my-field} will result in an unintended javascript expression.
-   * @since 1.4
-   */
-  LOWER_CASE_WITH_DASHES() {
-    @Override public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
-    }
-  },
-
-  /**
-   * Using this naming policy with Gson will modify the Java Field name from its camel cased
-   * form to a lower case field name where each word is separated by a dot (.).
-   *
-   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
-   * <ul>
-   *   <li>someFieldName ---> some.field.name</li>
-   *   <li>_someFieldName ---> _some.field.name</li>
-   *   <li>aStringField ---> a.string.field</li>
-   *   <li>aURL ---> a.u.r.l</li>
-   * </ul>
-   * Using dots in JavaScript is not recommended since dot is also used for a member sign in
-   * expressions. This requires that a field named with dots is always accessed as a quoted
-   * property like {@code myobject['my.field']}. Accessing it as an object field
-   * {@code myobject.my.field} will result in an unintended javascript expression.
-   * @since 2.8
-   */
-  LOWER_CASE_WITH_DOTS() {
-    @Override public String translateName(Field f) {
-      return separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
-    }
-  };
-
-  /**
-   * Converts the field name that uses camel-case define word separation into
-   * separate words that are separated by the provided {@code separatorString}.
-   */
-  static String separateCamelCase(String name, String separator) {
-    StringBuilder translation = new StringBuilder();
-    for (int i = 0, length = name.length(); i < length; i++) {
-      char character = name.charAt(i);
-      if (Character.isUpperCase(character) && translation.length() != 0) {
-        translation.append(separator);
-      }
-      translation.append(character);
-    }
-    return translation.toString();
-  }
-
-  /**
-   * Ensures the JSON field names begins with an upper case letter.
-   */
-  static String upperCaseFirstLetter(String name) {
-    int firstLetterIndex = 0;
-    int limit = name.length() - 1;
-    for(; !Character.isLetter(name.charAt(firstLetterIndex)) && firstLetterIndex < limit; ++firstLetterIndex);
-
-    char firstLetter = name.charAt(firstLetterIndex);
-    if(Character.isUpperCase(firstLetter)) { //The letter is already uppercased, return the original
-      return name;
-    }
-
-    char uppercased = Character.toUpperCase(firstLetter);
-    if(firstLetterIndex == 0) { //First character in the string is the first letter, saves 1 substring
-      return uppercased + name.substring(1);
-    }
-
-    return name.substring(0, firstLetterIndex) + uppercased + name.substring(firstLetterIndex + 1);
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
index f2f7c489a..039afe275 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import java.lang.reflect.Field;
+import java.util.*;
 
 /**
  * A mechanism for providing custom field naming in Gson. This allows the client code to translate
@@ -29,12 +30,134 @@
  */
 public interface FieldNamingStrategy {
 
-  /**
-   * Translates the field name into its JSON field name representation.
-   *
-   * @param f the field object that we are translating
-   * @return the translated field name.
-   * @since 1.3
-   */
-  public String translateName(Field f);
-}
+	/**
+	 * Translates the field name into its JSON field name representation.
+	 *
+	 * @param f the field object that we are translating
+	 * @return the translated field name.
+	 * @since 1.3
+	 */
+	public String translateName(Field f);
+
+	/**
+	 * Using this naming policy with Gson will ensure that the field name is
+	 * unchanged.
+	 */
+	public static final FieldNamingStrategy IDENTITY = Field::getName;
+
+	/**
+	 * Using this naming policy with Gson will ensure that the first "letter" of the Java
+	 * field name is capitalized when serialized to its JSON form.
+	 *
+	 * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+	 * <ul>
+	 *   <li>someFieldName ---> SomeFieldName</li>
+	 *   <li>_someFieldName ---> _SomeFieldName</li>
+	 * </ul>
+	 */
+	public static final FieldNamingStrategy UPPER_CAMEL_CASE = f -> upperCaseFirstLetter(f.getName());
+
+	/**
+	 * Using this naming policy with Gson will ensure that the first "letter" of the Java
+	 * field name is capitalized when serialized to its JSON form and the words will be
+	 * separated by a space.
+	 *
+	 * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+	 * <ul>
+	 *   <li>someFieldName ---> Some Field Name</li>
+	 *   <li>_someFieldName ---> _Some Field Name</li>
+	 * </ul>
+	 *
+	 * @since 1.4
+	 */
+	public static final FieldNamingStrategy UPPER_CAMEL_CASE_WITH_SPACES = f -> upperCaseFirstLetter(separateCamelCase(f.getName(), " "));
+
+	/**
+	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
+	 * form to a lower case field name where each word is separated by an underscore (_).
+	 *
+	 * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+	 * <ul>
+	 *   <li>someFieldName ---> some_field_name</li>
+	 *   <li>_someFieldName ---> _some_field_name</li>
+	 *   <li>aStringField ---> a_string_field</li>
+	 *   <li>aURL ---> a_u_r_l</li>
+	 * </ul>
+	 */
+	public static final FieldNamingStrategy LOWER_CASE_WITH_UNDERSCORES = f -> separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
+
+	/**
+	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
+	 * form to a lower case field name where each word is separated by a dash (-).
+	 *
+	 * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+	 * <ul>
+	 *   <li>someFieldName ---> some-field-name</li>
+	 *   <li>_someFieldName ---> _some-field-name</li>
+	 *   <li>aStringField ---> a-string-field</li>
+	 *   <li>aURL ---> a-u-r-l</li>
+	 * </ul>
+	 * Using dashes in JavaScript is not recommended since dash is also used for a minus sign in
+	 * expressions. This requires that a field named with dashes is always accessed as a quoted
+	 * property like {@code myobject['my-field']}. Accessing it as an object field
+	 * {@code myobject.my-field} will result in an unintended javascript expression.
+	 * @since 1.4
+	 */
+	public static final FieldNamingStrategy LOWER_CASE_WITH_DASHES = f -> separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
+
+	/**
+	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
+	 * form to a lower case field name where each word is separated by a dot (.).
+	 *
+	 * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+	 * <ul>
+	 *   <li>someFieldName ---> some.field.name</li>
+	 *   <li>_someFieldName ---> _some.field.name</li>
+	 *   <li>aStringField ---> a.string.field</li>
+	 *   <li>aURL ---> a.u.r.l</li>
+	 * </ul>
+	 * Using dots in JavaScript is not recommended since dot is also used for a member sign in
+	 * expressions. This requires that a field named with dots is always accessed as a quoted
+	 * property like {@code myobject['my.field']}. Accessing it as an object field
+	 * {@code myobject.my.field} will result in an unintended javascript expression.
+	 * @since 2.8
+	 */
+	public static final FieldNamingStrategy LOWER_CASE_WITH_DOTS = f -> separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
+
+	/**
+	 * Converts the field name that uses camel-case define word separation into
+	 * separate words that are separated by the provided {@code separatorString}.
+	 */
+	private static String separateCamelCase(String name, String separator) {
+		var translation = new StringBuilder();
+		for (int i = 0, length = name.length(); i < length; i++) {
+			char character = name.charAt(i);
+			if (Character.isUpperCase(character) && translation.length() != 0) {
+				translation.append(separator);
+			}
+			translation.append(character);
+		}
+		return translation.toString();
+	}
+
+	/**
+	 * Ensures the JSON field names begins with an upper case letter.
+	 */
+	private static String upperCaseFirstLetter(String name) {
+		int firstLetterIndex = 0;
+		int limit = name.length() - 1;
+		for(; !Character.isLetter(name.charAt(firstLetterIndex)) && firstLetterIndex < limit; ++firstLetterIndex);
+
+		char firstLetter = name.charAt(firstLetterIndex);
+		if(Character.isUpperCase(firstLetter)) { //The letter is already uppercased, return the original
+			return name;
+		}
+
+		char uppercased = Character.toUpperCase(firstLetter);
+		if(firstLetterIndex == 0) { //First character in the string is the first letter, saves 1 substring
+			return uppercased + name.substring(1);
+		}
+
+		return name.substring(0, firstLetterIndex) + uppercased + name.substring(firstLetterIndex + 1);
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 27f3ee924..1225f8c1d 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -183,7 +183,7 @@
    * </ul>
    */
   public Gson() {
-    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,
+    this(Excluder.DEFAULT, FieldNamingStrategy.IDENTITY,
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index b97be452b..f2b4dabb5 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -28,8 +28,7 @@
 
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
-import com.google.gson.internal.bind.TreeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
+import com.google.gson.internal.bind.*;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 
@@ -78,7 +77,7 @@
 public final class GsonBuilder {
   private Excluder excluder = Excluder.DEFAULT;
   private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;
-  private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;
+  private FieldNamingStrategy fieldNamingPolicy = FieldNamingStrategy.IDENTITY;
   private final Map<Type, InstanceCreator<?>> instanceCreators
       = new HashMap<Type, InstanceCreator<?>>();
   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
@@ -299,19 +298,6 @@ public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializat
     return this;
   }
 
-  /**
-   * Configures Gson to apply a specific naming policy to an object's field during serialization
-   * and deserialization.
-   *
-   * @param namingConvention the JSON field naming convention to use for serialization and
-   * deserialization.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {
-    this.fieldNamingPolicy = namingConvention;
-    return this;
-  }
-
   /**
    * Configures Gson to apply a specific naming policy strategy to an object's field during
    * serialization and deserialization.
diff --git a/gson/src/main/java/com/google/gson/InstanceCreator.java b/gson/src/main/java/com/google/gson/InstanceCreator.java
index d5096a07a..8036f9a87 100644
--- a/gson/src/main/java/com/google/gson/InstanceCreator.java
+++ b/gson/src/main/java/com/google/gson/InstanceCreator.java
@@ -1,92 +1,92 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.lang.reflect.Type;
-
-/**
- * This interface is implemented to create instances of a class that does not define a no-args
- * constructor. If you can modify the class, you should instead add a private, or public
- * no-args constructor. However, that is not possible for library classes, such as JDK classes, or
- * a third-party library that you do not have source-code of. In such cases, you should define an
- * instance creator for the class. Implementations of this interface should be registered with
- * {@link GsonBuilder#registerTypeAdapter(Type, Object)} method before Gson will be able to use
- * them.
- * <p>Let us look at an example where defining an InstanceCreator might be useful. The
- * {@code Id} class defined below does not have a default no-args constructor.</p>
- *
- * <pre>
- * public class Id&lt;T&gt; {
- *   private final Class&lt;T&gt; clazz;
- *   private final long value;
- *   public Id(Class&lt;T&gt; clazz, long value) {
- *     this.clazz = clazz;
- *     this.value = value;
- *   }
- * }
- * </pre>
- *
- * <p>If Gson encounters an object of type {@code Id} during deserialization, it will throw an
- * exception. The easiest way to solve this problem will be to add a (public or private) no-args
- * constructor as follows:</p>
- *
- * <pre>
- * private Id() {
- *   this(Object.class, 0L);
- * }
- * </pre>
- *
- * <p>However, let us assume that the developer does not have access to the source-code of the
- * {@code Id} class, or does not want to define a no-args constructor for it. The developer
- * can solve this problem by defining an {@code InstanceCreator} for {@code Id}:</p>
- *
- * <pre>
- * class IdInstanceCreator implements InstanceCreator&lt;Id&gt; {
- *   public Id createInstance(Type type) {
- *     return new Id(Object.class, 0L);
- *   }
- * }
- * </pre>
- *
- * <p>Note that it does not matter what the fields of the created instance contain since Gson will
- * overwrite them with the deserialized values specified in Json. You should also ensure that a
- * <i>new</i> object is returned, not a common object since its fields will be overwritten.
- * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>
- *
- * <pre>
- * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();
- * </pre>
- *
- * @param <T> the type of object that will be created by this implementation.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public interface InstanceCreator<T> {
-
-  /**
-   * Gson invokes this call-back method during deserialization to create an instance of the
-   * specified type. The fields of the returned instance are overwritten with the data present
-   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not
-   * return an instance that is useful elsewhere. In particular, do not return a common instance,
-   * always use {@code new} to create a new instance.
-   *
-   * @param type the parameterized T represented as a {@link Type}.
-   * @return a default object instance of type T.
-   */
-  public T createInstance(Type type);
-}
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import java.lang.reflect.Type;
+
+/**
+ * This interface is implemented to create instances of a class that does not define a no-args
+ * constructor. If you can modify the class, you should instead add a private, or public
+ * no-args constructor. However, that is not possible for library classes, such as JDK classes, or
+ * a third-party library that you do not have source-code of. In such cases, you should define an
+ * instance creator for the class. Implementations of this interface should be registered with
+ * {@link GsonBuilder#registerTypeAdapter(Type, Object)} method before Gson will be able to use
+ * them.
+ * <p>Let us look at an example where defining an InstanceCreator might be useful. The
+ * {@code Id} class defined below does not have a default no-args constructor.</p>
+ *
+ * <pre>
+ * public class Id&lt;T&gt; {
+ *   private final Class&lt;T&gt; clazz;
+ *   private final long value;
+ *   public Id(Class&lt;T&gt; clazz, long value) {
+ *     this.clazz = clazz;
+ *     this.value = value;
+ *   }
+ * }
+ * </pre>
+ *
+ * <p>If Gson encounters an object of type {@code Id} during deserialization, it will throw an
+ * exception. The easiest way to solve this problem will be to add a (public or private) no-args
+ * constructor as follows:</p>
+ *
+ * <pre>
+ * private Id() {
+ *   this(Object.class, 0L);
+ * }
+ * </pre>
+ *
+ * <p>However, let us assume that the developer does not have access to the source-code of the
+ * {@code Id} class, or does not want to define a no-args constructor for it. The developer
+ * can solve this problem by defining an {@code InstanceCreator} for {@code Id}:</p>
+ *
+ * <pre>
+ * class IdInstanceCreator implements InstanceCreator&lt;Id&gt; {
+ *   public Id createInstance(Type type) {
+ *     return new Id(Object.class, 0L);
+ *   }
+ * }
+ * </pre>
+ *
+ * <p>Note that it does not matter what the fields of the created instance contain since Gson will
+ * overwrite them with the deserialized values specified in Json. You should also ensure that a
+ * <i>new</i> object is returned, not a common object since its fields will be overwritten.
+ * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>
+ *
+ * <pre>
+ * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();
+ * </pre>
+ *
+ * @param <T> the type of object that will be created by this implementation.
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+public interface InstanceCreator<T> {
+
+  /**
+   * Gson invokes this call-back method during deserialization to create an instance of the
+   * specified type. The fields of the returned instance are overwritten with the data present
+   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not
+   * return an instance that is useful elsewhere. In particular, do not return a common instance,
+   * always use {@code new} to create a new instance.
+   *
+   * @param type the parameterized T represented as a {@link Type}.
+   * @return a default object instance of type T.
+   */
+  public T createInstance(Type type);
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index f2b3b31f5..819aa4c51 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -324,38 +324,6 @@ public int getAsInt() {
     throw new IllegalStateException();
   }
 
-  @Override
-  public byte getAsByte() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsByte();
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override
-  public char getAsCharacter() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsCharacter();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a primitive short if it contains a single element.
-   *
-   * @return get this element as a primitive short if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid short.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public short getAsShort() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsShort();
-    }
-    throw new IllegalStateException();
-  }
-
   /**
    * convenience method to get this array as a boolean if it contains a single element.
    *
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index 2ab1a1609..e5d61e7de 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -231,38 +231,6 @@ public int getAsInt() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
 
-  /**
-   * convenience method to get this element as a primitive byte value.
-   *
-   * @return get this element as a primitive byte value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * byte value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.3
-   */
-  public byte getAsByte() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get the first character of this element as a string or the first
-   * character of this array's first element as a string.
-   *
-   * @return the first character of the string.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * string value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.3
-   * @deprecated This method is misleading, as it does not get this element as a char but rather as
-   * a string's first character.
-   */
-  @Deprecated
-  public char getAsCharacter() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
   /**
    * convenience method to get this element as a {@link BigDecimal}.
    *
@@ -291,19 +259,6 @@ public BigInteger getAsBigInteger() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
 
-  /**
-   * convenience method to get this element as a primitive short value.
-   *
-   * @return get this element as a primitive short value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * short value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public short getAsShort() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
   /**
    * Returns a String representation of this element.
    */
diff --git a/gson/src/main/java/com/google/gson/JsonIOException.java b/gson/src/main/java/com/google/gson/JsonIOException.java
index dfeccd8ed..b1de8a3c3 100644
--- a/gson/src/main/java/com/google/gson/JsonIOException.java
+++ b/gson/src/main/java/com/google/gson/JsonIOException.java
@@ -23,23 +23,23 @@
  * @author Joel Leitch
  */
 public final class JsonIOException extends JsonParseException {
-  private static final long serialVersionUID = 1L;
+	private static final long serialVersionUID = 1L;
 
-  public JsonIOException(String msg) {
-    super(msg);
-  }
+	public JsonIOException(String msg) {
+		super(msg);
+	}
 
-  public JsonIOException(String msg, Throwable cause) {
-    super(msg, cause);
-  }
+	public JsonIOException(String msg, Throwable cause) {
+		super(msg, cause);
+	}
 
-  /**
-   * Creates exception with the specified cause. Consider using
-   * {@link #JsonIOException(String, Throwable)} instead if you can describe what happened.
-   *
-   * @param cause root exception that caused this exception to be thrown.
-   */
-  public JsonIOException(Throwable cause) {
-    super(cause);
-  }
+	/**
+	 * Creates exception with the specified cause. Consider using
+	 * {@link #JsonIOException(String, Throwable)} instead if you can describe what happened.
+	 *
+	 * @param cause root exception that caused this exception to be thrown.
+	 */
+	public JsonIOException(Throwable cause) {
+		super(cause);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/JsonNull.java b/gson/src/main/java/com/google/gson/JsonNull.java
index 67cb9325b..ae9ea2ef5 100644
--- a/gson/src/main/java/com/google/gson/JsonNull.java
+++ b/gson/src/main/java/com/google/gson/JsonNull.java
@@ -24,44 +24,37 @@
  * @since 1.2
  */
 public final class JsonNull extends JsonElement {
-  /**
-   * singleton for JsonNull
-   *
-   * @since 1.8
-   */
-  public static final JsonNull INSTANCE = new JsonNull();
+	/**
+	 * singleton for JsonNull
+	 *
+	 * @since 1.8
+	 */
+	public static final JsonNull INSTANCE = new JsonNull();
 
-  /**
-   * Creates a new JsonNull object.
-   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
-   */
-  @Deprecated
-  public JsonNull() {
-    // Do nothing
-  }
+	private JsonNull() {}
 
-  /**
-   * Returns the same instance since it is an immutable value
-   * @since 2.8.2
-   */
-  @Override
-  public JsonNull deepCopy() {
-    return INSTANCE;
-  }
+	/**
+	 * Returns the same instance since it is an immutable value
+	 * @since 2.8.2
+	 */
+	@Override
+	public JsonNull deepCopy() {
+		return INSTANCE;
+	}
 
-  /**
-   * All instances of JsonNull have the same hash code since they are indistinguishable
-   */
-  @Override
-  public int hashCode() {
-    return JsonNull.class.hashCode();
-  }
+	/**
+	 * All instances of JsonNull have the same hash code since they are indistinguishable
+	 */
+	@Override
+	public int hashCode() {
+		return JsonNull.class.hashCode();
+	}
 
-  /**
-   * All instances of JsonNull are the same
-   */
-  @Override
-  public boolean equals(Object other) {
-    return this == other || other instanceof JsonNull;
-  }
-}
+	/**
+	 * All instances of JsonNull are the same
+	 */
+	@Override
+	public boolean equals(Object other) {
+		return other == INSTANCE;
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonParseException.java b/gson/src/main/java/com/google/gson/JsonParseException.java
index c1f264d76..8c688c624 100644
--- a/gson/src/main/java/com/google/gson/JsonParseException.java
+++ b/gson/src/main/java/com/google/gson/JsonParseException.java
@@ -30,35 +30,35 @@
  * @author Joel Leitch
  */
 public class JsonParseException extends RuntimeException {
-  static final long serialVersionUID = -4086729973971783390L;
+	static final long serialVersionUID = -4086729973971783390L;
 
-  /**
-   * Creates exception with the specified message. If you are wrapping another exception, consider
-   * using {@link #JsonParseException(String, Throwable)} instead.
-   *
-   * @param msg error message describing a possible cause of this exception.
-   */
-  public JsonParseException(String msg) {
-    super(msg);
-  }
+	/**
+	 * Creates exception with the specified message. If you are wrapping another exception, consider
+	 * using {@link #JsonParseException(String, Throwable)} instead.
+	 *
+	 * @param msg error message describing a possible cause of this exception.
+	 */
+	public JsonParseException(String msg) {
+		super(msg);
+	}
 
-  /**
-   * Creates exception with the specified message and cause.
-   *
-   * @param msg error message describing what happened.
-   * @param cause root exception that caused this exception to be thrown.
-   */
-  public JsonParseException(String msg, Throwable cause) {
-    super(msg, cause);
-  }
+	/**
+	 * Creates exception with the specified message and cause.
+	 *
+	 * @param msg error message describing what happened.
+	 * @param cause root exception that caused this exception to be thrown.
+	 */
+	public JsonParseException(String msg, Throwable cause) {
+		super(msg, cause);
+	}
 
-  /**
-   * Creates exception with the specified cause. Consider using
-   * {@link #JsonParseException(String, Throwable)} instead if you can describe what happened.
-   *
-   * @param cause root exception that caused this exception to be thrown.
-   */
-  public JsonParseException(Throwable cause) {
-    super(cause);
-  }
+	/**
+	 * Creates exception with the specified cause. Consider using
+	 * {@link #JsonParseException(String, Throwable)} instead if you can describe what happened.
+	 *
+	 * @param cause root exception that caused this exception to be thrown.
+	 */
+	public JsonParseException(Throwable cause) {
+		super(cause);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/JsonParser.java b/gson/src/main/java/com/google/gson/JsonParser.java
index 5121e4e10..2e46811e7 100644
--- a/gson/src/main/java/com/google/gson/JsonParser.java
+++ b/gson/src/main/java/com/google/gson/JsonParser.java
@@ -32,81 +32,60 @@
  * @since 1.3
  */
 public final class JsonParser {
-  /** @deprecated No need to instantiate this class, use the static methods instead. */
-  @Deprecated
-  public JsonParser() {}
+	private JsonParser() {}
 
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param json JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   */
-  public static JsonElement parseString(String json) throws JsonSyntaxException {
-    return parseReader(new StringReader(json));
-  }
+	/**
+	 * Parses the specified JSON string into a parse tree
+	 *
+	 * @param json JSON text
+	 * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+	 * @throws JsonParseException if the specified text is not valid JSON
+	 */
+	public static JsonElement parseString(String json) throws JsonSyntaxException {
+		return parseReader(new StringReader(json));
+	}
 
-  /**
-   * Parses the specified JSON string into a parse tree
-   *
-   * @param reader JSON text
-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
-   * @throws JsonParseException if the specified text is not valid JSON
-   */
-  public static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {
-    try {
-      JsonReader jsonReader = new JsonReader(reader);
-      JsonElement element = parseReader(jsonReader);
-      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
-        throw new JsonSyntaxException("Did not consume the entire document.");
-      }
-      return element;
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (NumberFormatException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
+	/**
+	 * Parses the specified JSON string into a parse tree
+	 *
+	 * @param reader JSON text
+	 * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
+	 * @throws JsonParseException if the specified text is not valid JSON
+	 */
+	public static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {
+		try {
+			JsonReader jsonReader = new JsonReader(reader);
+			JsonElement element = parseReader(jsonReader);
+			if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
+				throw new JsonSyntaxException("Did not consume the entire document.");
+			}
+			return element;
+		} catch (MalformedJsonException e) {
+			throw new JsonSyntaxException(e);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		} catch (NumberFormatException e) {
+			throw new JsonSyntaxException(e);
+		}
+	}
 
-  /**
-   * Returns the next value from the JSON stream as a parse tree.
-   *
-   * @throws JsonParseException if there is an IOException or if the specified
-   *     text is not valid JSON
-   */
-  public static JsonElement parseReader(JsonReader reader)
-      throws JsonIOException, JsonSyntaxException {
-    boolean lenient = reader.isLenient();
-    reader.setLenient(true);
-    try {
-      return Streams.parse(reader);
-    } catch (StackOverflowError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
-    } catch (OutOfMemoryError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
-    } finally {
-      reader.setLenient(lenient);
-    }
-  }
-
-  /** @deprecated Use {@link JsonParser#parseString} */
-  @Deprecated
-  public JsonElement parse(String json) throws JsonSyntaxException {
-    return parseString(json);
-  }
-
-  /** @deprecated Use {@link JsonParser#parseReader(Reader)} */
-  @Deprecated
-  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
-    return parseReader(json);
-  }
-
-  /** @deprecated Use {@link JsonParser#parseReader(JsonReader)} */
-  @Deprecated
-  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
-    return parseReader(json);
-  }
-}
+	/**
+	 * Returns the next value from the JSON stream as a parse tree.
+	 *
+	 * @throws JsonParseException if there is an IOException or if the specified
+	 *     text is not valid JSON
+	 */
+	public static JsonElement parseReader(JsonReader reader) throws JsonIOException, JsonSyntaxException {
+		boolean lenient = reader.isLenient();
+		reader.setLenient(true);
+		try {
+			return Streams.parse(reader);
+		} catch (StackOverflowError e) {
+			throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
+		} catch (OutOfMemoryError e) {
+			throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
+		} finally {
+			reader.setLenient(lenient);
+		}
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index 5e95d5a82..3cb80981b 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -16,10 +16,9 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Gson$Preconditions;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-
+import java.util.*;
 import com.google.gson.internal.LazilyParsedNumber;
 
 /**
@@ -31,265 +30,243 @@
  * @author Joel Leitch
  */
 public final class JsonPrimitive extends JsonElement {
+	private final Object value;
 
-  private final Object value;
-
-  /**
-   * Create a primitive containing a boolean value.
-   *
-   * @param bool the value to create the primitive with.
-   */
-  public JsonPrimitive(Boolean bool) {
-    value = $Gson$Preconditions.checkNotNull(bool);
-  }
-
-  /**
-   * Create a primitive containing a {@link Number}.
-   *
-   * @param number the value to create the primitive with.
-   */
-  public JsonPrimitive(Number number) {
-    value = $Gson$Preconditions.checkNotNull(number);
-  }
-
-  /**
-   * Create a primitive containing a String value.
-   *
-   * @param string the value to create the primitive with.
-   */
-  public JsonPrimitive(String string) {
-    value = $Gson$Preconditions.checkNotNull(string);
-  }
-
-  /**
-   * Create a primitive containing a character. The character is turned into a one character String
-   * since Json only supports String.
-   *
-   * @param c the value to create the primitive with.
-   */
-  public JsonPrimitive(Character c) {
-    // convert characters to strings since in JSON, characters are represented as a single
-    // character string
-    value = $Gson$Preconditions.checkNotNull(c).toString();
-  }
+	/**
+	 * Create a primitive containing a boolean value.
+	 *
+	 * @param bool the value to create the primitive with.
+	 */
+	public JsonPrimitive(Boolean bool) {
+		value = Objects.requireNonNull(bool);
+	}
 
-  /**
-   * Returns the same value as primitives are immutable.
-   * @since 2.8.2
-   */
-  @Override
-  public JsonPrimitive deepCopy() {
-    return this;
-  }
+	/**
+	 * Create a primitive containing a {@link Number}.
+	 *
+	 * @param number the value to create the primitive with.
+	 */
+	public JsonPrimitive(Number number) {
+		value = Objects.requireNonNull(number);
+	}
 
-  /**
-   * Check whether this primitive contains a boolean value.
-   *
-   * @return true if this primitive contains a boolean value, false otherwise.
-   */
-  public boolean isBoolean() {
-    return value instanceof Boolean;
-  }
+	/**
+	 * Create a primitive containing a String value.
+	 *
+	 * @param string the value to create the primitive with.
+	 */
+	public JsonPrimitive(String string) {
+		value = Objects.requireNonNull(string);
+	}
 
-  /**
-   * convenience method to get this element as a boolean value.
-   *
-   * @return get this element as a primitive boolean value.
-   */
-  @Override
-  public boolean getAsBoolean() {
-    if (isBoolean()) {
-      return ((Boolean) value).booleanValue();
-    }
-	// Check to see if the value as a String is "true" in any case.
-    return Boolean.parseBoolean(getAsString());
-  }
+	/**
+	 * Create a primitive containing a character. The character is turned into a one character String
+	 * since Json only supports String.
+	 *
+	 * @param c the value to create the primitive with.
+	 */
+	public JsonPrimitive(Character c) {
+		// convert characters to strings since in JSON, characters are represented as a single
+		// character string
+		value = Objects.requireNonNull(c).toString();
+	}
 
-  /**
-   * Check whether this primitive contains a Number.
-   *
-   * @return true if this primitive contains a Number, false otherwise.
-   */
-  public boolean isNumber() {
-    return value instanceof Number;
-  }
+	/**
+	 * Returns the same value as primitives are immutable.
+	 * @since 2.8.2
+	 */
+	@Override
+	public JsonPrimitive deepCopy() {
+		return this;
+	}
 
-  /**
-   * convenience method to get this element as a Number.
-   *
-   * @return get this element as a Number.
-   * @throws NumberFormatException if the value contained is not a valid Number.
-   */
-  @Override
-  public Number getAsNumber() {
-    return value instanceof String ? new LazilyParsedNumber((String) value) : (Number) value;
-  }
+	/**
+	 * Check whether this primitive contains a boolean value.
+	 *
+	 * @return true if this primitive contains a boolean value, false otherwise.
+	 */
+	public boolean isBoolean() {
+		return value instanceof Boolean;
+	}
 
-  /**
-   * Check whether this primitive contains a String value.
-   *
-   * @return true if this primitive contains a String value, false otherwise.
-   */
-  public boolean isString() {
-    return value instanceof String;
-  }
+	/**
+	 * convenience method to get this element as a boolean value.
+	 *
+	 * @return get this element as a primitive boolean value.
+	 */
+	@Override
+	public boolean getAsBoolean() {
+		if (isBoolean()) {
+			return ((Boolean) value).booleanValue();
+		}
+		// Check to see if the value as a String is "true" in any case.
+		return Boolean.parseBoolean(getAsString());
+	}
 
-  /**
-   * convenience method to get this element as a String.
-   *
-   * @return get this element as a String.
-   */
-  @Override
-  public String getAsString() {
-    if (isNumber()) {
-      return getAsNumber().toString();
-    } else if (isBoolean()) {
-      return ((Boolean) value).toString();
-    } else {
-      return (String) value;
-    }
-  }
+	/**
+	 * Check whether this primitive contains a Number.
+	 *
+	 * @return true if this primitive contains a Number, false otherwise.
+	 */
+	public boolean isNumber() {
+		return value instanceof Number;
+	}
 
-  /**
-   * convenience method to get this element as a primitive double.
-   *
-   * @return get this element as a primitive double.
-   * @throws NumberFormatException if the value contained is not a valid double.
-   */
-  @Override
-  public double getAsDouble() {
-    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a Number.
+	 *
+	 * @return get this element as a Number.
+	 * @throws NumberFormatException if the value contained is not a valid Number.
+	 */
+	@Override
+	public Number getAsNumber() {
+		return value instanceof String ? new LazilyParsedNumber((String) value) : (Number) value;
+	}
 
-  /**
-   * convenience method to get this element as a {@link BigDecimal}.
-   *
-   * @return get this element as a {@link BigDecimal}.
-   * @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.
-   */
-  @Override
-  public BigDecimal getAsBigDecimal() {
-    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString());
-  }
+	/**
+	 * Check whether this primitive contains a String value.
+	 *
+	 * @return true if this primitive contains a String value, false otherwise.
+	 */
+	public boolean isString() {
+		return value instanceof String;
+	}
 
-  /**
-   * convenience method to get this element as a {@link BigInteger}.
-   *
-   * @return get this element as a {@link BigInteger}.
-   * @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.
-   */
-  @Override
-  public BigInteger getAsBigInteger() {
-    return value instanceof BigInteger ?
-        (BigInteger) value : new BigInteger(value.toString());
-  }
+	/**
+	 * convenience method to get this element as a String.
+	 *
+	 * @return get this element as a String.
+	 */
+	@Override
+	public String getAsString() {
+		if (isNumber()) {
+			return getAsNumber().toString();
+		} else if (isBoolean()) {
+			return ((Boolean) value).toString();
+		} else {
+			return (String) value;
+		}
+	}
 
-  /**
-   * convenience method to get this element as a float.
-   *
-   * @return get this element as a float.
-   * @throws NumberFormatException if the value contained is not a valid float.
-   */
-  @Override
-  public float getAsFloat() {
-    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a primitive double.
+	 *
+	 * @return get this element as a primitive double.
+	 * @throws NumberFormatException if the value contained is not a valid double.
+	 */
+	@Override
+	public double getAsDouble() {
+		return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());
+	}
 
-  /**
-   * convenience method to get this element as a primitive long.
-   *
-   * @return get this element as a primitive long.
-   * @throws NumberFormatException if the value contained is not a valid long.
-   */
-  @Override
-  public long getAsLong() {
-    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a {@link BigDecimal}.
+	 *
+	 * @return get this element as a {@link BigDecimal}.
+	 * @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.
+	 */
+	@Override
+	public BigDecimal getAsBigDecimal() {
+		return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString());
+	}
 
-  /**
-   * convenience method to get this element as a primitive short.
-   *
-   * @return get this element as a primitive short.
-   * @throws NumberFormatException if the value contained is not a valid short value.
-   */
-  @Override
-  public short getAsShort() {
-    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a {@link BigInteger}.
+	 *
+	 * @return get this element as a {@link BigInteger}.
+	 * @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.
+	 */
+	@Override
+	public BigInteger getAsBigInteger() {
+		return value instanceof BigInteger ?
+				(BigInteger) value : new BigInteger(value.toString());
+	}
 
- /**
-  * convenience method to get this element as a primitive integer.
-  *
-  * @return get this element as a primitive integer.
-  * @throws NumberFormatException if the value contained is not a valid integer.
-  */
-  @Override
-  public int getAsInt() {
-    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a float.
+	 *
+	 * @return get this element as a float.
+	 * @throws NumberFormatException if the value contained is not a valid float.
+	 */
+	@Override
+	public float getAsFloat() {
+		return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());
+	}
 
-  @Override
-  public byte getAsByte() {
-    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());
-  }
+	/**
+	 * convenience method to get this element as a primitive long.
+	 *
+	 * @return get this element as a primitive long.
+	 * @throws NumberFormatException if the value contained is not a valid long.
+	 */
+	@Override
+	public long getAsLong() {
+		return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());
+	}
 
-  @Override
-  public char getAsCharacter() {
-    return getAsString().charAt(0);
-  }
+	/**
+	 * convenience method to get this element as a primitive integer.
+	 *
+	 * @return get this element as a primitive integer.
+	 * @throws NumberFormatException if the value contained is not a valid integer.
+	 */
+	@Override
+	public int getAsInt() {
+		return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());
+	}
 
-  @Override
-  public int hashCode() {
-    if (value == null) {
-      return 31;
-    }
-    // Using recommended hashing algorithm from Effective Java for longs and doubles
-    if (isIntegral(this)) {
-      long value = getAsNumber().longValue();
-      return (int) (value ^ (value >>> 32));
-    }
-    if (value instanceof Number) {
-      long value = Double.doubleToLongBits(getAsNumber().doubleValue());
-      return (int) (value ^ (value >>> 32));
-    }
-    return value.hashCode();
-  }
+	@Override
+	public int hashCode() {
+		if (value == null) {
+			return 31;
+		}
+		// Using recommended hashing algorithm from Effective Java for longs and doubles
+		if (isIntegral(this)) {
+			long value = getAsNumber().longValue();
+			return (int) (value ^ (value >>> 32));
+		}
+		if (value instanceof Number) {
+			long value = Double.doubleToLongBits(getAsNumber().doubleValue());
+			return (int) (value ^ (value >>> 32));
+		}
+		return value.hashCode();
+	}
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
-    }
-    JsonPrimitive other = (JsonPrimitive)obj;
-    if (value == null) {
-      return other.value == null;
-    }
-    if (isIntegral(this) && isIntegral(other)) {
-      return getAsNumber().longValue() == other.getAsNumber().longValue();
-    }
-    if (value instanceof Number && other.value instanceof Number) {
-      double a = getAsNumber().doubleValue();
-      // Java standard types other than double return true for two NaN. So, need
-      // special handling for double.
-      double b = other.getAsNumber().doubleValue();
-      return a == b || (Double.isNaN(a) && Double.isNaN(b));
-    }
-    return value.equals(other.value);
-  }
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null || getClass() != obj.getClass()) {
+			return false;
+		}
+		JsonPrimitive other = (JsonPrimitive)obj;
+		if (value == null) {
+			return other.value == null;
+		}
+		if (isIntegral(this) && isIntegral(other)) {
+			return getAsNumber().longValue() == other.getAsNumber().longValue();
+		}
+		if (value instanceof Number && other.value instanceof Number) {
+			double a = getAsNumber().doubleValue();
+			// Java standard types other than double return true for two NaN. So, need
+			// special handling for double.
+			double b = other.getAsNumber().doubleValue();
+			return a == b || (Double.isNaN(a) && Double.isNaN(b));
+		}
+		return value.equals(other.value);
+	}
 
-  /**
-   * Returns true if the specified number is an integral type
-   * (Long, Integer, Short, Byte, BigInteger)
-   */
-  private static boolean isIntegral(JsonPrimitive primitive) {
-    if (primitive.value instanceof Number) {
-      Number number = (Number) primitive.value;
-      return number instanceof BigInteger || number instanceof Long || number instanceof Integer
-          || number instanceof Short || number instanceof Byte;
-    }
-    return false;
-  }
+	/**
+	 * Returns true if the specified number is an integral type
+	 * (Long, Integer, Short, Byte, BigInteger)
+	 */
+	private static boolean isIntegral(JsonPrimitive primitive) {
+		if (primitive.value instanceof Number) {
+			Number number = (Number) primitive.value;
+			return number instanceof BigInteger || number instanceof Long || number instanceof Integer
+					|| number instanceof Short || number instanceof Byte;
+		}
+		return false;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
index bb2b6666e..11db0a748 100644
--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
+++ b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
@@ -25,34 +25,34 @@
  * @author Joel Leitch
  */
 public enum LongSerializationPolicy {
-  /**
-   * This is the "default" serialization policy that will output a {@code long} object as a JSON
-   * number. For example, assume an object has a long field named "f" then the serialized output
-   * would be:
-   * {@code {"f":123}}.
-   */
-  DEFAULT() {
-    @Override public JsonElement serialize(Long value) {
-      return new JsonPrimitive(value);
-    }
-  },
-  
-  /**
-   * Serializes a long value as a quoted string. For example, assume an object has a long field 
-   * named "f" then the serialized output would be:
-   * {@code {"f":"123"}}.
-   */
-  STRING() {
-    @Override public JsonElement serialize(Long value) {
-      return new JsonPrimitive(String.valueOf(value));
-    }
-  };
-  
-  /**
-   * Serialize this {@code value} using this serialization policy.
-   *
-   * @param value the long value to be serialized into a {@link JsonElement}
-   * @return the serialized version of {@code value}
-   */
-  public abstract JsonElement serialize(Long value);
+	/**
+	 * This is the "default" serialization policy that will output a {@code long} object as a JSON
+	 * number. For example, assume an object has a long field named "f" then the serialized output
+	 * would be:
+	 * {@code {"f":123}}.
+	 */
+	DEFAULT() {
+		@Override public JsonElement serialize(Long value) {
+			return new JsonPrimitive(value);
+		}
+	},
+
+	/**
+	 * Serializes a long value as a quoted string. For example, assume an object has a long field 
+	 * named "f" then the serialized output would be:
+	 * {@code {"f":"123"}}.
+	 */
+	STRING() {
+		@Override public JsonElement serialize(Long value) {
+			return new JsonPrimitive(String.valueOf(value));
+		}
+	};
+
+	/**
+	 * Serialize this {@code value} using this serialization policy.
+	 *
+	 * @param value the long value to be serialized into a {@link JsonElement}
+	 * @return the serialized version of {@code value}
+	 */
+	public abstract JsonElement serialize(Long value);
 }
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java b/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
index f0e7d3fac..e7314fe61 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
@@ -30,17 +30,6 @@
  * @author Joel Leitch
  */
 public final class $Gson$Preconditions {
-  private $Gson$Preconditions() {
-    throw new UnsupportedOperationException();
-  }
-
-  public static <T> T checkNotNull(T obj) {
-    if (obj == null) {
-      throw new NullPointerException();
-    }
-    return obj;
-  }
-
   public static void checkArgument(boolean condition) {
     if (!condition) {
       throw new IllegalArgumentException();
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index adea605f5..715399696 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -28,7 +28,6 @@
 import java.util.*;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
 
 /**
  * Static methods for working with types.
@@ -37,574 +36,574 @@
  * @author Jesse Wilson
  */
 public final class $Gson$Types {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
-
-  private $Gson$Types() {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * Returns a new parameterized type, applying {@code typeArguments} to
-   * {@code rawType} and enclosed by {@code ownerType}.
-   *
-   * @return a {@link java.io.Serializable serializable} parameterized type.
-   */
-  public static ParameterizedType newParameterizedTypeWithOwner(
-      Type ownerType, Type rawType, Type... typeArguments) {
-    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
-  }
-
-  /**
-   * Returns an array type whose elements are all instances of
-   * {@code componentType}.
-   *
-   * @return a {@link java.io.Serializable serializable} generic array type.
-   */
-  public static GenericArrayType arrayOf(Type componentType) {
-    return new GenericArrayTypeImpl(componentType);
-  }
-
-  /**
-   * Returns a type that represents an unknown type that extends {@code bound}.
-   * For example, if {@code bound} is {@code CharSequence.class}, this returns
-   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
-   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.
-   */
-  public static WildcardType subtypeOf(Type bound) {
-    Type[] upperBounds;
-    if (bound instanceof WildcardType) {
-      upperBounds = ((WildcardType) bound).getUpperBounds();
-    } else {
-      upperBounds = new Type[] { bound };
-    }
-    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
-  }
-
-  /**
-   * Returns a type that represents an unknown supertype of {@code bound}. For
-   * example, if {@code bound} is {@code String.class}, this returns {@code ?
-   * super String}.
-   */
-  public static WildcardType supertypeOf(Type bound) {
-    Type[] lowerBounds;
-    if (bound instanceof WildcardType) {
-      lowerBounds = ((WildcardType) bound).getLowerBounds();
-    } else {
-      lowerBounds = new Type[] { bound };
-    }
-    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
-  }
-
-  /**
-   * Returns a type that is functionally equal but not necessarily equal
-   * according to {@link Object#equals(Object) Object.equals()}. The returned
-   * type is {@link java.io.Serializable}.
-   */
-  public static Type canonicalize(Type type) {
-    if (type instanceof Class) {
-      Class<?> c = (Class<?>) type;
-      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType p = (ParameterizedType) type;
-      return new ParameterizedTypeImpl(p.getOwnerType(),
-          p.getRawType(), p.getActualTypeArguments());
-
-    } else if (type instanceof GenericArrayType) {
-      GenericArrayType g = (GenericArrayType) type;
-      return new GenericArrayTypeImpl(g.getGenericComponentType());
-
-    } else if (type instanceof WildcardType) {
-      WildcardType w = (WildcardType) type;
-      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
-
-    } else {
-      // type is either serializable as-is or unsupported
-      return type;
-    }
-  }
-
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class.
-      // Neal isn't either but suspects some pathological case related
-      // to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      checkArgument(rawType instanceof Class);
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType)type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // we could use the variable's bounds, but that won't work if there are multiple.
-      // having a raw type that's more general than necessary is okay
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
-  static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Returns true if {@code a} and {@code b} are equal.
-   */
-  public static boolean equals(Type a, Type b) {
-    if (a == b) {
-      // also handles (a == null && b == null)
-      return true;
-
-    } else if (a instanceof Class) {
-      // Class already specifies equals().
-      return a.equals(b);
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) {
-        return false;
-      }
-
-      // TODO: save a .clone() call
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) {
-        return false;
-      }
-
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) {
-        return false;
-      }
-
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) {
-        return false;
-      }
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      // This isn't a type we support. Could be a generic array type, wildcard type, etc.
-      return false;
-    }
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  public static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) {
-      return context;
-    }
-
-    // we skip searching through interfaces if unknown is an interface
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
-    }
-
-    // check our supertypes
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
-
-    // we can't resolve this further
-    return toResolve;
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (context instanceof WildcardType) {
-      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
-      context = ((WildcardType)context).getUpperBounds()[0];
-    }
-    checkArgument(supertype.isAssignableFrom(contextRawType));
-    return resolve(context, contextRawType,
-        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  /**
-   * Returns the component type of this array type.
-   * @throws ClassCastException if this type is not an array.
-   */
-  public static Type getArrayComponentType(Type array) {
-    return array instanceof GenericArrayType
-        ? ((GenericArrayType) array).getGenericComponentType()
-        : ((Class<?>) array).getComponentType();
-  }
-
-  /**
-   * Returns the element type of this collection type.
-   * @throws IllegalArgumentException if this type is not a collection.
-   */
-  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {
-    Type collectionType = getSupertype(context, contextRawType, Collection.class);
-
-    if (collectionType instanceof WildcardType) {
-      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];
-    }
-    if (collectionType instanceof ParameterizedType) {
-      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];
-    }
-    return Object.class;
-  }
-
-  /**
-   * Returns a two element array containing this map's key and value types in
-   * positions 0 and 1 respectively.
-   */
-  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {
-    /*
-     * Work around a problem with the declaration of java.util.Properties. That
-     * class should extend Hashtable<String, String>, but it's declared to
-     * extend Hashtable<Object, Object>.
-     */
-    if (context == Properties.class) {
-      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!
-    }
-
-    Type mapType = getSupertype(context, contextRawType, Map.class);
-    // TODO: strip wildcards?
-    if (mapType instanceof ParameterizedType) {
-      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;
-      return mapParameterizedType.getActualTypeArguments();
-    }
-    return new Type[] { Object.class, Object.class };
-  }
-
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
-  }
-
-  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Collection<TypeVariable> visitedTypeVariables) {
-    // this implementation is made a little more complicated in an attempt to avoid object-creation
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        if (visitedTypeVariables.contains(typeVariable)) {
-          // cannot reduce due to infinite recursion
-          return toResolve;
-        } else {
-          visitedTypeVariables.add(typeVariable);
-        }
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
-            ? original
-            : arrayOf(newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
-            ? original
-            : arrayOf(newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
-        }
-
-        return changed
-            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
-            : original;
-
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
-
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
-          if (lowerBound != originalLowerBound[0]) {
-            return supertypeOf(lowerBound);
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
-          if (upperBound != originalUpperBound[0]) {
-            return subtypeOf(upperBound);
-          }
-        }
-        return original;
-
-      } else {
-        return toResolve;
-      }
-    }
-  }
-
-  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // we can't reduce this further
-    if (declaredByRaw == null) {
-      return unknown;
-    }
-
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
-
-    return unknown;
-  }
-
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0, length = array.length; i < length; i++) {
-      if (toFind.equals(array[i])) {
-        return i;
-      }
-    }
-    throw new NoSuchElementException();
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class
-        ? (Class<?>) genericDeclaration
-        : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // require an owner type if the raw type needs it
-      if (rawType instanceof Class<?>) {
-        Class<?> rawTypeAsClass = (Class<?>) rawType;
-        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())
-            || rawTypeAsClass.getEnclosingClass() == null;
-        checkArgument(ownerType != null || isStaticOrTopLevelClass);
-      }
-
-      this.ownerType = ownerType == null ? null : canonicalize(ownerType);
-      this.rawType = canonicalize(rawType);
-      this.typeArguments = typeArguments.clone();
-      for (int t = 0, length = this.typeArguments.length; t < length; t++) {
-        checkNotNull(this.typeArguments[t]);
-        checkNotPrimitive(this.typeArguments[t]);
-        this.typeArguments[t] = canonicalize(this.typeArguments[t]);
-      }
-    }
-
-    public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
-    }
-
-    public Type getRawType() {
-      return rawType;
-    }
-
-    public Type getOwnerType() {
-      return ownerType;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType
-          && $Gson$Types.equals(this, (ParameterizedType) other);
-    }
-
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments)
-          ^ rawType.hashCode()
-          ^ hashCodeOrZero(ownerType);
-    }
-
-    @Override public String toString() {
-      int length = typeArguments.length;
-      if (length == 0) {
-        return typeToString(rawType);
-      }
-
-      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));
-      stringBuilder.append(typeToString(rawType)).append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < length; i++) {
-        stringBuilder.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return stringBuilder.append(">").toString();
-    }
-
-    private static final long serialVersionUID = 0;
-  }
-
-  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {
-    private final Type componentType;
-
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = canonicalize(componentType);
-    }
-
-    public Type getGenericComponentType() {
-      return componentType;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && $Gson$Types.equals(this, (GenericArrayType) o);
-    }
-
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
-
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-
-    private static final long serialVersionUID = 0;
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType, Serializable {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      checkArgument(lowerBounds.length <= 1);
-      checkArgument(upperBounds.length == 1);
-
-      if (lowerBounds.length == 1) {
-        checkNotNull(lowerBounds[0]);
-        checkNotPrimitive(lowerBounds[0]);
-        checkArgument(upperBounds[0] == Object.class);
-        this.lowerBound = canonicalize(lowerBounds[0]);
-        this.upperBound = Object.class;
-
-      } else {
-        checkNotNull(upperBounds[0]);
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = canonicalize(upperBounds[0]);
-      }
-    }
-
-    public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
-
-    public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType
-          && $Gson$Types.equals(this, (WildcardType) other);
-    }
-
-    @Override public int hashCode() {
-      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)
-          ^ (31 + upperBound.hashCode());
-    }
-
-    @Override public String toString() {
-      if (lowerBound != null) {
-        return "? super " + typeToString(lowerBound);
-      } else if (upperBound == Object.class) {
-        return "?";
-      } else {
-        return "? extends " + typeToString(upperBound);
-      }
-    }
-
-    private static final long serialVersionUID = 0;
-  }
+	static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
+
+	private $Gson$Types() {
+		throw new UnsupportedOperationException();
+	}
+
+	/**
+	 * Returns a new parameterized type, applying {@code typeArguments} to
+	 * {@code rawType} and enclosed by {@code ownerType}.
+	 *
+	 * @return a {@link java.io.Serializable serializable} parameterized type.
+	 */
+	public static ParameterizedType newParameterizedTypeWithOwner(
+			Type ownerType, Type rawType, Type... typeArguments) {
+		return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
+	}
+
+	/**
+	 * Returns an array type whose elements are all instances of
+	 * {@code componentType}.
+	 *
+	 * @return a {@link java.io.Serializable serializable} generic array type.
+	 */
+	public static GenericArrayType arrayOf(Type componentType) {
+		return new GenericArrayTypeImpl(componentType);
+	}
+
+	/**
+	 * Returns a type that represents an unknown type that extends {@code bound}.
+	 * For example, if {@code bound} is {@code CharSequence.class}, this returns
+	 * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
+	 * this returns {@code ?}, which is shorthand for {@code ? extends Object}.
+	 */
+	public static WildcardType subtypeOf(Type bound) {
+		Type[] upperBounds;
+		if (bound instanceof WildcardType) {
+			upperBounds = ((WildcardType) bound).getUpperBounds();
+		} else {
+			upperBounds = new Type[] { bound };
+		}
+		return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
+	}
+
+	/**
+	 * Returns a type that represents an unknown supertype of {@code bound}. For
+	 * example, if {@code bound} is {@code String.class}, this returns {@code ?
+	 * super String}.
+	 */
+	public static WildcardType supertypeOf(Type bound) {
+		Type[] lowerBounds;
+		if (bound instanceof WildcardType) {
+			lowerBounds = ((WildcardType) bound).getLowerBounds();
+		} else {
+			lowerBounds = new Type[] { bound };
+		}
+		return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
+	}
+
+	/**
+	 * Returns a type that is functionally equal but not necessarily equal
+	 * according to {@link Object#equals(Object) Object.equals()}. The returned
+	 * type is {@link java.io.Serializable}.
+	 */
+	public static Type canonicalize(Type type) {
+		if (type instanceof Class) {
+			Class<?> c = (Class<?>) type;
+			return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;
+
+		} else if (type instanceof ParameterizedType) {
+			ParameterizedType p = (ParameterizedType) type;
+			return new ParameterizedTypeImpl(p.getOwnerType(),
+					p.getRawType(), p.getActualTypeArguments());
+
+		} else if (type instanceof GenericArrayType) {
+			GenericArrayType g = (GenericArrayType) type;
+			return new GenericArrayTypeImpl(g.getGenericComponentType());
+
+		} else if (type instanceof WildcardType) {
+			WildcardType w = (WildcardType) type;
+			return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
+
+		} else {
+			// type is either serializable as-is or unsupported
+			return type;
+		}
+	}
+
+	public static Class<?> getRawType(Type type) {
+		if (type instanceof Class<?>) {
+			// type is a normal class.
+			return (Class<?>) type;
+
+		} else if (type instanceof ParameterizedType) {
+			ParameterizedType parameterizedType = (ParameterizedType) type;
+
+			// I'm not exactly sure why getRawType() returns Type instead of Class.
+			// Neal isn't either but suspects some pathological case related
+			// to nested classes exists.
+			Type rawType = parameterizedType.getRawType();
+			checkArgument(rawType instanceof Class);
+			return (Class<?>) rawType;
+
+		} else if (type instanceof GenericArrayType) {
+			Type componentType = ((GenericArrayType)type).getGenericComponentType();
+			return Array.newInstance(getRawType(componentType), 0).getClass();
+
+		} else if (type instanceof TypeVariable) {
+			// we could use the variable's bounds, but that won't work if there are multiple.
+			// having a raw type that's more general than necessary is okay
+			return Object.class;
+
+		} else if (type instanceof WildcardType) {
+			return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+		} else {
+			String className = type == null ? "null" : type.getClass().getName();
+			throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+					+ "GenericArrayType, but <" + type + "> is of type " + className);
+		}
+	}
+
+	static boolean equal(Object a, Object b) {
+		return a == b || (a != null && a.equals(b));
+	}
+
+	/**
+	 * Returns true if {@code a} and {@code b} are equal.
+	 */
+	public static boolean equals(Type a, Type b) {
+		if (a == b) {
+			// also handles (a == null && b == null)
+			return true;
+
+		} else if (a instanceof Class) {
+			// Class already specifies equals().
+			return a.equals(b);
+
+		} else if (a instanceof ParameterizedType) {
+			if (!(b instanceof ParameterizedType)) {
+				return false;
+			}
+
+			// TODO: save a .clone() call
+			ParameterizedType pa = (ParameterizedType) a;
+			ParameterizedType pb = (ParameterizedType) b;
+			return equal(pa.getOwnerType(), pb.getOwnerType())
+					&& pa.getRawType().equals(pb.getRawType())
+					&& Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
+
+		} else if (a instanceof GenericArrayType) {
+			if (!(b instanceof GenericArrayType)) {
+				return false;
+			}
+
+			GenericArrayType ga = (GenericArrayType) a;
+			GenericArrayType gb = (GenericArrayType) b;
+			return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+		} else if (a instanceof WildcardType) {
+			if (!(b instanceof WildcardType)) {
+				return false;
+			}
+
+			WildcardType wa = (WildcardType) a;
+			WildcardType wb = (WildcardType) b;
+			return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+					&& Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+		} else if (a instanceof TypeVariable) {
+			if (!(b instanceof TypeVariable)) {
+				return false;
+			}
+			TypeVariable<?> va = (TypeVariable<?>) a;
+			TypeVariable<?> vb = (TypeVariable<?>) b;
+			return va.getGenericDeclaration() == vb.getGenericDeclaration()
+					&& va.getName().equals(vb.getName());
+
+		} else {
+			// This isn't a type we support. Could be a generic array type, wildcard type, etc.
+			return false;
+		}
+	}
+
+	static int hashCodeOrZero(Object o) {
+		return o != null ? o.hashCode() : 0;
+	}
+
+	public static String typeToString(Type type) {
+		return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+	}
+
+	/**
+	 * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+	 * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+	 * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+	 */
+	static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+		if (toResolve == rawType) {
+			return context;
+		}
+
+		// we skip searching through interfaces if unknown is an interface
+		if (toResolve.isInterface()) {
+			Class<?>[] interfaces = rawType.getInterfaces();
+			for (int i = 0, length = interfaces.length; i < length; i++) {
+				if (interfaces[i] == toResolve) {
+					return rawType.getGenericInterfaces()[i];
+				} else if (toResolve.isAssignableFrom(interfaces[i])) {
+					return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+				}
+			}
+		}
+
+		// check our supertypes
+		if (!rawType.isInterface()) {
+			while (rawType != Object.class) {
+				Class<?> rawSupertype = rawType.getSuperclass();
+				if (rawSupertype == toResolve) {
+					return rawType.getGenericSuperclass();
+				} else if (toResolve.isAssignableFrom(rawSupertype)) {
+					return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+				}
+				rawType = rawSupertype;
+			}
+		}
+
+		// we can't resolve this further
+		return toResolve;
+	}
+
+	/**
+	 * Returns the generic form of {@code supertype}. For example, if this is {@code
+	 * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+	 * Iterable.class}.
+	 *
+	 * @param supertype a superclass of, or interface implemented by, this.
+	 */
+	static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+		if (context instanceof WildcardType) {
+			// wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
+			context = ((WildcardType)context).getUpperBounds()[0];
+		}
+		checkArgument(supertype.isAssignableFrom(contextRawType));
+		return resolve(context, contextRawType,
+				$Gson$Types.getGenericSupertype(context, contextRawType, supertype));
+	}
+
+	/**
+	 * Returns the component type of this array type.
+	 * @throws ClassCastException if this type is not an array.
+	 */
+	public static Type getArrayComponentType(Type array) {
+		return array instanceof GenericArrayType
+				? ((GenericArrayType) array).getGenericComponentType()
+						: ((Class<?>) array).getComponentType();
+	}
+
+	/**
+	 * Returns the element type of this collection type.
+	 * @throws IllegalArgumentException if this type is not a collection.
+	 */
+	public static Type getCollectionElementType(Type context, Class<?> contextRawType) {
+		Type collectionType = getSupertype(context, contextRawType, Collection.class);
+
+		if (collectionType instanceof WildcardType) {
+			collectionType = ((WildcardType)collectionType).getUpperBounds()[0];
+		}
+		if (collectionType instanceof ParameterizedType) {
+			return ((ParameterizedType) collectionType).getActualTypeArguments()[0];
+		}
+		return Object.class;
+	}
+
+	/**
+	 * Returns a two element array containing this map's key and value types in
+	 * positions 0 and 1 respectively.
+	 */
+	public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {
+		/*
+		 * Work around a problem with the declaration of java.util.Properties. That
+		 * class should extend Hashtable<String, String>, but it's declared to
+		 * extend Hashtable<Object, Object>.
+		 */
+		if (context == Properties.class) {
+			return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!
+		}
+
+		Type mapType = getSupertype(context, contextRawType, Map.class);
+		// TODO: strip wildcards?
+		if (mapType instanceof ParameterizedType) {
+			ParameterizedType mapParameterizedType = (ParameterizedType) mapType;
+			return mapParameterizedType.getActualTypeArguments();
+		}
+		return new Type[] { Object.class, Object.class };
+	}
+
+	public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+		return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
+	}
+
+	private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
+			Collection<TypeVariable> visitedTypeVariables) {
+		// this implementation is made a little more complicated in an attempt to avoid object-creation
+		while (true) {
+			if (toResolve instanceof TypeVariable) {
+				TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+				if (visitedTypeVariables.contains(typeVariable)) {
+					// cannot reduce due to infinite recursion
+					return toResolve;
+				} else {
+					visitedTypeVariables.add(typeVariable);
+				}
+				toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+				if (toResolve == typeVariable) {
+					return toResolve;
+				}
+
+			} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+				Class<?> original = (Class<?>) toResolve;
+				Type componentType = original.getComponentType();
+				Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
+				return componentType == newComponentType
+						? original
+								: arrayOf(newComponentType);
+
+			} else if (toResolve instanceof GenericArrayType) {
+				GenericArrayType original = (GenericArrayType) toResolve;
+				Type componentType = original.getGenericComponentType();
+				Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
+				return componentType == newComponentType
+						? original
+								: arrayOf(newComponentType);
+
+			} else if (toResolve instanceof ParameterizedType) {
+				ParameterizedType original = (ParameterizedType) toResolve;
+				Type ownerType = original.getOwnerType();
+				Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
+				boolean changed = newOwnerType != ownerType;
+
+				Type[] args = original.getActualTypeArguments();
+				for (int t = 0, length = args.length; t < length; t++) {
+					Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
+					if (resolvedTypeArgument != args[t]) {
+						if (!changed) {
+							args = args.clone();
+							changed = true;
+						}
+						args[t] = resolvedTypeArgument;
+					}
+				}
+
+				return changed
+						? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
+								: original;
+
+			} else if (toResolve instanceof WildcardType) {
+				WildcardType original = (WildcardType) toResolve;
+				Type[] originalLowerBound = original.getLowerBounds();
+				Type[] originalUpperBound = original.getUpperBounds();
+
+				if (originalLowerBound.length == 1) {
+					Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
+					if (lowerBound != originalLowerBound[0]) {
+						return supertypeOf(lowerBound);
+					}
+				} else if (originalUpperBound.length == 1) {
+					Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
+					if (upperBound != originalUpperBound[0]) {
+						return subtypeOf(upperBound);
+					}
+				}
+				return original;
+
+			} else {
+				return toResolve;
+			}
+		}
+	}
+
+	static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+		Class<?> declaredByRaw = declaringClassOf(unknown);
+
+		// we can't reduce this further
+		if (declaredByRaw == null) {
+			return unknown;
+		}
+
+		Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+		if (declaredBy instanceof ParameterizedType) {
+			int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+			return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+		}
+
+		return unknown;
+	}
+
+	private static int indexOf(Object[] array, Object toFind) {
+		for (int i = 0, length = array.length; i < length; i++) {
+			if (toFind.equals(array[i])) {
+				return i;
+			}
+		}
+		throw new NoSuchElementException();
+	}
+
+	/**
+	 * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+	 * a class.
+	 */
+	private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+		GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+		return genericDeclaration instanceof Class
+				? (Class<?>) genericDeclaration
+						: null;
+	}
+
+	static void checkNotPrimitive(Type type) {
+		checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
+	}
+
+	private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
+		private final Type ownerType;
+		private final Type rawType;
+		private final Type[] typeArguments;
+
+		public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+			// require an owner type if the raw type needs it
+			if (rawType instanceof Class<?>) {
+				Class<?> rawTypeAsClass = (Class<?>) rawType;
+				boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())
+						|| rawTypeAsClass.getEnclosingClass() == null;
+				checkArgument(ownerType != null || isStaticOrTopLevelClass);
+			}
+
+			this.ownerType = ownerType == null ? null : canonicalize(ownerType);
+			this.rawType = canonicalize(rawType);
+			this.typeArguments = typeArguments.clone();
+			for (int t = 0, length = this.typeArguments.length; t < length; t++) {
+				Objects.requireNonNull(this.typeArguments[t]);
+				checkNotPrimitive(this.typeArguments[t]);
+				this.typeArguments[t] = canonicalize(this.typeArguments[t]);
+			}
+		}
+
+		public Type[] getActualTypeArguments() {
+			return typeArguments.clone();
+		}
+
+		public Type getRawType() {
+			return rawType;
+		}
+
+		public Type getOwnerType() {
+			return ownerType;
+		}
+
+		@Override public boolean equals(Object other) {
+			return other instanceof ParameterizedType
+					&& $Gson$Types.equals(this, (ParameterizedType) other);
+		}
+
+		@Override public int hashCode() {
+			return Arrays.hashCode(typeArguments)
+					^ rawType.hashCode()
+					^ hashCodeOrZero(ownerType);
+		}
+
+		@Override public String toString() {
+			int length = typeArguments.length;
+			if (length == 0) {
+				return typeToString(rawType);
+			}
+
+			StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));
+			stringBuilder.append(typeToString(rawType)).append("<").append(typeToString(typeArguments[0]));
+			for (int i = 1; i < length; i++) {
+				stringBuilder.append(", ").append(typeToString(typeArguments[i]));
+			}
+			return stringBuilder.append(">").toString();
+		}
+
+		private static final long serialVersionUID = 0;
+	}
+
+	private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {
+		private final Type componentType;
+
+		public GenericArrayTypeImpl(Type componentType) {
+			this.componentType = canonicalize(componentType);
+		}
+
+		public Type getGenericComponentType() {
+			return componentType;
+		}
+
+		@Override public boolean equals(Object o) {
+			return o instanceof GenericArrayType
+					&& $Gson$Types.equals(this, (GenericArrayType) o);
+		}
+
+		@Override public int hashCode() {
+			return componentType.hashCode();
+		}
+
+		@Override public String toString() {
+			return typeToString(componentType) + "[]";
+		}
+
+		private static final long serialVersionUID = 0;
+	}
+
+	/**
+	 * The WildcardType interface supports multiple upper bounds and multiple
+	 * lower bounds. We only support what the Java 6 language needs - at most one
+	 * bound. If a lower bound is set, the upper bound must be Object.class.
+	 */
+	private static final class WildcardTypeImpl implements WildcardType, Serializable {
+		private final Type upperBound;
+		private final Type lowerBound;
+
+		public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+			checkArgument(lowerBounds.length <= 1);
+			checkArgument(upperBounds.length == 1);
+
+			if (lowerBounds.length == 1) {
+				Objects.requireNonNull(lowerBounds[0]);
+				checkNotPrimitive(lowerBounds[0]);
+				checkArgument(upperBounds[0] == Object.class);
+				this.lowerBound = canonicalize(lowerBounds[0]);
+				this.upperBound = Object.class;
+
+			} else {
+				Objects.requireNonNull(upperBounds[0]);
+				checkNotPrimitive(upperBounds[0]);
+				this.lowerBound = null;
+				this.upperBound = canonicalize(upperBounds[0]);
+			}
+		}
+
+		public Type[] getUpperBounds() {
+			return new Type[] { upperBound };
+		}
+
+		public Type[] getLowerBounds() {
+			return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+		}
+
+		@Override public boolean equals(Object other) {
+			return other instanceof WildcardType
+					&& $Gson$Types.equals(this, (WildcardType) other);
+		}
+
+		@Override public int hashCode() {
+			// this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());
+			return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)
+					^ (31 + upperBound.hashCode());
+		}
+
+		@Override public String toString() {
+			if (lowerBound != null) {
+				return "? super " + typeToString(lowerBound);
+			} else if (upperBound == Object.class) {
+				return "?";
+			} else {
+				return "? extends " + typeToString(upperBound);
+			}
+		}
+
+		private static final long serialVersionUID = 0;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index 5fab46010..7605bfd9e 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -16,45 +16,24 @@
 
 package com.google.gson.internal;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.SortedSet;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ConcurrentNavigableMap;
-import java.util.concurrent.ConcurrentSkipListMap;
-
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonIOException;
-import com.google.gson.internal.reflect.ReflectionAccessor;
-import com.google.gson.reflect.TypeToken;
+import com.google.gson.*;
+import com.google.gson.reflect.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.function.*;
 
 /**
  * Returns a function that can construct an instance of a requested type.
  */
 public final class ConstructorConstructor {
   private final Map<Type, InstanceCreator<?>> instanceCreators;
-  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     this.instanceCreators = instanceCreators;
   }
 
-  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {
+  public <T> Supplier<T> get(TypeToken<T> typeToken) {
     final Type type = typeToken.getType();
     final Class<? super T> rawType = typeToken.getRawType();
 
@@ -63,11 +42,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     @SuppressWarnings("unchecked") // types must agree
     final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
     if (typeCreator != null) {
-      return new ObjectConstructor<T>() {
-        @Override public T construct() {
-          return typeCreator.createInstance(type);
-        }
-      };
+      return () -> typeCreator.createInstance(type);
     }
 
     // Next try raw type match for instance creators
@@ -75,19 +50,15 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     final InstanceCreator<T> rawTypeCreator =
         (InstanceCreator<T>) instanceCreators.get(rawType);
     if (rawTypeCreator != null) {
-      return new ObjectConstructor<T>() {
-        @Override public T construct() {
-          return rawTypeCreator.createInstance(type);
-        }
-      };
+      return () -> rawTypeCreator.createInstance(type);
     }
 
-    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);
+    Supplier<T> defaultConstructor = newDefaultConstructor(rawType);
     if (defaultConstructor != null) {
       return defaultConstructor;
     }
 
-    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);
+    Supplier<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);
     if (defaultImplementation != null) {
       return defaultImplementation;
     }
@@ -96,31 +67,28 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     return newUnsafeAllocator(type, rawType);
   }
 
-  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {
+  private static <T> Supplier<T> newDefaultConstructor(Class<? super T> rawType) {
     try {
       final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
       if (!constructor.isAccessible()) {
-        accessor.makeAccessible(constructor);
+        constructor.setAccessible(true);
       }
-      return new ObjectConstructor<T>() {
-        @SuppressWarnings("unchecked") // T is the same raw type as is requested
-        @Override public T construct() {
-          try {
-            Object[] args = null;
-            return (T) constructor.newInstance(args);
-          } catch (InstantiationException e) {
-            // TODO: JsonParseException ?
-            throw new RuntimeException("Failed to invoke " + constructor + " with no args", e);
-          } catch (InvocationTargetException e) {
-            // TODO: don't wrap if cause is unchecked!
-            // TODO: JsonParseException ?
-            throw new RuntimeException("Failed to invoke " + constructor + " with no args",
-                e.getTargetException());
-          } catch (IllegalAccessException e) {
-            throw new AssertionError(e);
-          }
-        }
-      };
+      return () -> {
+	  try {
+	    Object[] args = null;
+	    return (T) constructor.newInstance(args);
+	  } catch (InstantiationException e1) {
+	    // TODO: JsonParseException ?
+	    throw new RuntimeException("Failed to invoke " + constructor + " with no args", e1);
+	  } catch (InvocationTargetException e2) {
+	    // TODO: don't wrap if cause is unchecked!
+	    // TODO: JsonParseException ?
+	    throw new RuntimeException("Failed to invoke " + constructor + " with no args",
+	        e2.getTargetException());
+	  } catch (IllegalAccessException e3) {
+	    throw new AssertionError(e3);
+	  }
+	};
     } catch (NoSuchMethodException e) {
       return null;
     }
@@ -131,19 +99,12 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
    * subtypes.
    */
   @SuppressWarnings("unchecked") // use runtime checks to guarantee that 'T' is what it is
-  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
-      final Type type, Class<? super T> rawType) {
+  private static <T> Supplier<T> newDefaultImplementationConstructor(Type type, Class<? super T> rawType) {
     if (Collection.class.isAssignableFrom(rawType)) {
       if (SortedSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new TreeSet<Object>();
-          }
-        };
+        return () -> (T) new TreeSet<>();
       } else if (EnumSet.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @SuppressWarnings("rawtypes")
-          @Override public T construct() {
+        return () -> {
             if (type instanceof ParameterizedType) {
               Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
               if (elementType instanceof Class) {
@@ -154,82 +115,44 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
             } else {
               throw new JsonIOException("Invalid EnumSet type: " + type.toString());
             }
-          }
-        };
+          };
       } else if (Set.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedHashSet<Object>();
-          }
-        };
+        return () -> (T) new LinkedHashSet<>();
       } else if (Queue.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ArrayDeque<Object>();
-          }
-        };
+        return () -> (T) new ArrayDeque<>();
       } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ArrayList<Object>();
-          }
-        };
+        return () -> (T) new ArrayList<>();
       }
     }
 
     if (Map.class.isAssignableFrom(rawType)) {
       if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ConcurrentSkipListMap<Object, Object>();
-          }
-        };
+        return () -> (T) new ConcurrentSkipListMap<>();
       } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new ConcurrentHashMap<Object, Object>();
-          }
-        };
+        return () -> (T) new ConcurrentHashMap<>();
       } else if (SortedMap.class.isAssignableFrom(rawType)) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new TreeMap<Object, Object>();
-          }
-        };
+        return () -> (T) new TreeMap<>();
       } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
           TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedHashMap<Object, Object>();
-          }
-        };
+        return () -> (T) new LinkedHashMap<>();
       } else {
-        return new ObjectConstructor<T>() {
-          @Override public T construct() {
-            return (T) new LinkedTreeMap<String, Object>();
-          }
-        };
+        return () -> (T) new LinkedTreeMap<String, Object>();
       }
     }
 
     return null;
   }
 
-  private <T> ObjectConstructor<T> newUnsafeAllocator(
-      final Type type, final Class<? super T> rawType) {
-    return new ObjectConstructor<T>() {
-      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
-      @SuppressWarnings("unchecked")
-      @Override public T construct() {
+  private static <T> Supplier<T> newUnsafeAllocator(Type type, Class<? super T> rawType) {
+    return () -> {
         try {
-          Object newInstance = unsafeAllocator.newInstance(rawType);
+          Object newInstance = UnsafeAllocator.allocator.newInstance(rawType);
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
               + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
         }
-      }
-    };
+      };
   }
 
   @Override public String toString() {
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index 6b83757ed..245389aca 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -16,23 +16,13 @@
 
 package com.google.gson.internal;
 
-import com.google.gson.ExclusionStrategy;
-import com.google.gson.FieldAttributes;
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.Expose;
-import com.google.gson.annotations.Since;
-import com.google.gson.annotations.Until;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import com.google.gson.*;
+import com.google.gson.annotations.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
+import java.util.*;
 
 /**
  * This class selects which fields and types to omit. It is configurable,
@@ -179,9 +169,8 @@ public boolean excludeField(Field field, boolean serialize) {
 
     List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
     if (!list.isEmpty()) {
-      FieldAttributes fieldAttributes = new FieldAttributes(field);
       for (ExclusionStrategy exclusionStrategy : list) {
-        if (exclusionStrategy.shouldSkipField(fieldAttributes)) {
+        if (exclusionStrategy.shouldSkipField(field)) {
           return true;
         }
       }
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java b/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
deleted file mode 100644
index b2707c50d..000000000
--- a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
+++ /dev/null
@@ -1,864 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.util.AbstractMap;
-import java.util.AbstractSet;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-/**
- * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses
- * insertion order for iteration order. Comparison order is only used as an
- * optimization for efficient insertion and removal.
- *
- * <p>This implementation was derived from Android 4.1's TreeMap and
- * LinkedHashMap classes.
- */
-public final class LinkedHashTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
-  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
-    public int compare(Comparable a, Comparable b) {
-      return a.compareTo(b);
-    }
-  };
-
-  Comparator<? super K> comparator;
-  Node<K, V>[] table;
-  final Node<K, V> header;
-  int size = 0;
-  int modCount = 0;
-  int threshold;
-
-  /**
-   * Create a natural order, empty tree map whose keys must be mutually
-   * comparable and non-null.
-   */
-  @SuppressWarnings("unchecked") // unsafe! this assumes K is comparable
-  public LinkedHashTreeMap() {
-    this((Comparator<? super K>) NATURAL_ORDER);
-  }
-
-  /**
-   * Create a tree map ordered by {@code comparator}. This map's keys may only
-   * be null if {@code comparator} permits.
-   *
-   * @param comparator the comparator to order elements with, or {@code null} to
-   *     use the natural ordering.
-   */
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // unsafe! if comparator is null, this assumes K is comparable
-  public LinkedHashTreeMap(Comparator<? super K> comparator) {
-    this.comparator = comparator != null
-        ? comparator
-        : (Comparator) NATURAL_ORDER;
-    this.header = new Node<K, V>();
-    this.table = new Node[16]; // TODO: sizing/resizing policies
-    this.threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity
-  }
-
-  @Override public int size() {
-    return size;
-  }
-
-  @Override public V get(Object key) {
-    Node<K, V> node = findByObject(key);
-    return node != null ? node.value : null;
-  }
-
-  @Override public boolean containsKey(Object key) {
-    return findByObject(key) != null;
-  }
-
-  @Override public V put(K key, V value) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-    Node<K, V> created = find(key, true);
-    V result = created.value;
-    created.value = value;
-    return result;
-  }
-
-  @Override public void clear() {
-    Arrays.fill(table, null);
-    size = 0;
-    modCount++;
-
-    // Clear all links to help GC
-    Node<K, V> header = this.header;
-    for (Node<K, V> e = header.next; e != header; ) {
-      Node<K, V> next = e.next;
-      e.next = e.prev = null;
-      e = next;
-    }
-
-    header.next = header.prev = header;
-  }
-
-  @Override public V remove(Object key) {
-    Node<K, V> node = removeInternalByKey(key);
-    return node != null ? node.value : null;
-  }
-
-  /**
-   * Returns the node at or adjacent to the given key, creating it if requested.
-   *
-   * @throws ClassCastException if {@code key} and the tree's keys aren't
-   *     mutually comparable.
-   */
-  Node<K, V> find(K key, boolean create) {
-    Comparator<? super K> comparator = this.comparator;
-    Node<K, V>[] table = this.table;
-    int hash = secondaryHash(key.hashCode());
-    int index = hash & (table.length - 1);
-    Node<K, V> nearest = table[index];
-    int comparison = 0;
-
-    if (nearest != null) {
-      // Micro-optimization: avoid polymorphic calls to Comparator.compare().
-      @SuppressWarnings("unchecked") // Throws a ClassCastException below if there's trouble.
-      Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)
-          ? (Comparable<Object>) key
-          : null;
-
-      while (true) {
-        comparison = (comparableKey != null)
-            ? comparableKey.compareTo(nearest.key)
-            : comparator.compare(key, nearest.key);
-
-        // We found the requested key.
-        if (comparison == 0) {
-          return nearest;
-        }
-
-        // If it exists, the key is in a subtree. Go deeper.
-        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
-        if (child == null) {
-          break;
-        }
-
-        nearest = child;
-      }
-    }
-
-    // The key doesn't exist in this tree.
-    if (!create) {
-      return null;
-    }
-
-    // Create the node and add it to the tree or the table.
-    Node<K, V> header = this.header;
-    Node<K, V> created;
-    if (nearest == null) {
-      // Check that the value is comparable if we didn't do any comparisons.
-      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {
-        throw new ClassCastException(key.getClass().getName() + " is not Comparable");
-      }
-      created = new Node<K, V>(nearest, key, hash, header, header.prev);
-      table[index] = created;
-    } else {
-      created = new Node<K, V>(nearest, key, hash, header, header.prev);
-      if (comparison < 0) { // nearest.key is higher
-        nearest.left = created;
-      } else { // comparison > 0, nearest.key is lower
-        nearest.right = created;
-      }
-      rebalance(nearest, true);
-    }
-
-    if (size++ > threshold) {
-      doubleCapacity();
-    }
-    modCount++;
-
-    return created;
-  }
-
-  @SuppressWarnings("unchecked")
-  Node<K, V> findByObject(Object key) {
-    try {
-      return key != null ? find((K) key, false) : null;
-    } catch (ClassCastException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns this map's entry that has the same key and value as {@code
-   * entry}, or null if this map has no such entry.
-   *
-   * <p>This method uses the comparator for key equality rather than {@code
-   * equals}. If this map's comparator isn't consistent with equals (such as
-   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
-   * contains()} will violate the collections API.
-   */
-  Node<K, V> findByEntry(Entry<?, ?> entry) {
-    Node<K, V> mine = findByObject(entry.getKey());
-    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
-    return valuesEqual ? mine : null;
-  }
-
-  private boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Applies a supplemental hash function to a given hashCode, which defends
-   * against poor quality hash functions. This is critical because HashMap
-   * uses power-of-two length hash tables, that otherwise encounter collisions
-   * for hashCodes that do not differ in lower or upper bits.
-   */
-  private static int secondaryHash(int h) {
-    // Doug Lea's supplemental hash function
-    h ^= (h >>> 20) ^ (h >>> 12);
-    return h ^ (h >>> 7) ^ (h >>> 4);
-  }
-
-  /**
-   * Removes {@code node} from this tree, rearranging the tree's structure as
-   * necessary.
-   *
-   * @param unlink true to also unlink this node from the iteration linked list.
-   */
-  void removeInternal(Node<K, V> node, boolean unlink) {
-    if (unlink) {
-      node.prev.next = node.next;
-      node.next.prev = node.prev;
-      node.next = node.prev = null; // Help the GC (for performance)
-    }
-
-    Node<K, V> left = node.left;
-    Node<K, V> right = node.right;
-    Node<K, V> originalParent = node.parent;
-    if (left != null && right != null) {
-
-      /*
-       * To remove a node with both left and right subtrees, move an
-       * adjacent node from one of those subtrees into this node's place.
-       *
-       * Removing the adjacent node may change this node's subtrees. This
-       * node may no longer have two subtrees once the adjacent node is
-       * gone!
-       */
-
-      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
-      removeInternal(adjacent, false); // takes care of rebalance and size--
-
-      int leftHeight = 0;
-      left = node.left;
-      if (left != null) {
-        leftHeight = left.height;
-        adjacent.left = left;
-        left.parent = adjacent;
-        node.left = null;
-      }
-      int rightHeight = 0;
-      right = node.right;
-      if (right != null) {
-        rightHeight = right.height;
-        adjacent.right = right;
-        right.parent = adjacent;
-        node.right = null;
-      }
-      adjacent.height = Math.max(leftHeight, rightHeight) + 1;
-      replaceInParent(node, adjacent);
-      return;
-    } else if (left != null) {
-      replaceInParent(node, left);
-      node.left = null;
-    } else if (right != null) {
-      replaceInParent(node, right);
-      node.right = null;
-    } else {
-      replaceInParent(node, null);
-    }
-
-    rebalance(originalParent, false);
-    size--;
-    modCount++;
-  }
-
-  Node<K, V> removeInternalByKey(Object key) {
-    Node<K, V> node = findByObject(key);
-    if (node != null) {
-      removeInternal(node, true);
-    }
-    return node;
-  }
-
-  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
-    Node<K, V> parent = node.parent;
-    node.parent = null;
-    if (replacement != null) {
-      replacement.parent = parent;
-    }
-
-    if (parent != null) {
-      if (parent.left == node) {
-        parent.left = replacement;
-      } else {
-        assert (parent.right == node);
-        parent.right = replacement;
-      }
-    } else {
-      int index = node.hash & (table.length - 1);
-      table[index] = replacement;
-    }
-  }
-
-  /**
-   * Rebalances the tree by making any AVL rotations necessary between the
-   * newly-unbalanced node and the tree's root.
-   *
-   * @param insert true if the node was unbalanced by an insert; false if it
-   *     was by a removal.
-   */
-  private void rebalance(Node<K, V> unbalanced, boolean insert) {
-    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
-      Node<K, V> left = node.left;
-      Node<K, V> right = node.right;
-      int leftHeight = left != null ? left.height : 0;
-      int rightHeight = right != null ? right.height : 0;
-
-      int delta = leftHeight - rightHeight;
-      if (delta == -2) {
-        Node<K, V> rightLeft = right.left;
-        Node<K, V> rightRight = right.right;
-        int rightRightHeight = rightRight != null ? rightRight.height : 0;
-        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
-
-        int rightDelta = rightLeftHeight - rightRightHeight;
-        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
-          rotateLeft(node); // AVL right right
-        } else {
-          assert (rightDelta == 1);
-          rotateRight(right); // AVL right left
-          rotateLeft(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 2) {
-        Node<K, V> leftLeft = left.left;
-        Node<K, V> leftRight = left.right;
-        int leftRightHeight = leftRight != null ? leftRight.height : 0;
-        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
-
-        int leftDelta = leftLeftHeight - leftRightHeight;
-        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
-          rotateRight(node); // AVL left left
-        } else {
-          assert (leftDelta == -1);
-          rotateLeft(left); // AVL left right
-          rotateRight(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 0) {
-        node.height = leftHeight + 1; // leftHeight == rightHeight
-        if (insert) {
-          break; // the insert caused balance, so rebalancing is done!
-        }
-
-      } else {
-        assert (delta == -1 || delta == 1);
-        node.height = Math.max(leftHeight, rightHeight) + 1;
-        if (!insert) {
-          break; // the height hasn't changed, so rebalancing is done!
-        }
-      }
-    }
-  }
-
-  /**
-   * Rotates the subtree so that its root's right child is the new root.
-   */
-  private void rotateLeft(Node<K, V> root) {
-    Node<K, V> left = root.left;
-    Node<K, V> pivot = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's left child to the root's right
-    root.right = pivotLeft;
-    if (pivotLeft != null) {
-      pivotLeft.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's left
-    pivot.left = root;
-    root.parent = pivot;
-
-    // fix heights
-    root.height = Math.max(left != null ? left.height : 0,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-  }
-
-  /**
-   * Rotates the subtree so that its root's left child is the new root.
-   */
-  private void rotateRight(Node<K, V> root) {
-    Node<K, V> pivot = root.left;
-    Node<K, V> right = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's right child to the root's left
-    root.left = pivotRight;
-    if (pivotRight != null) {
-      pivotRight.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's right
-    pivot.right = root;
-    root.parent = pivot;
-
-    // fixup heights
-    root.height = Math.max(right != null ? right.height : 0,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-  }
-
-  private EntrySet entrySet;
-  private KeySet keySet;
-
-  @Override public Set<Entry<K, V>> entrySet() {
-    EntrySet result = entrySet;
-    return result != null ? result : (entrySet = new EntrySet());
-  }
-
-  @Override public Set<K> keySet() {
-    KeySet result = keySet;
-    return result != null ? result : (keySet = new KeySet());
-  }
-
-  static final class Node<K, V> implements Entry<K, V> {
-    Node<K, V> parent;
-    Node<K, V> left;
-    Node<K, V> right;
-    Node<K, V> next;
-    Node<K, V> prev;
-    final K key;
-    final int hash;
-    V value;
-    int height;
-
-    /** Create the header entry */
-    Node() {
-      key = null;
-      hash = -1;
-      next = prev = this;
-    }
-
-    /** Create a regular entry */
-    Node(Node<K, V> parent, K key, int hash, Node<K, V> next, Node<K, V> prev) {
-      this.parent = parent;
-      this.key = key;
-      this.hash = hash;
-      this.height = 1;
-      this.next = next;
-      this.prev = prev;
-      prev.next = this;
-      next.prev = this;
-    }
-
-    public K getKey() {
-      return key;
-    }
-
-    public V getValue() {
-      return value;
-    }
-
-    public V setValue(V value) {
-      V oldValue = this.value;
-      this.value = value;
-      return oldValue;
-    }
-
-    @SuppressWarnings("rawtypes")
-    @Override public boolean equals(Object o) {
-      if (o instanceof Entry) {
-        Entry other = (Entry) o;
-        return (key == null ? other.getKey() == null : key.equals(other.getKey()))
-            && (value == null ? other.getValue() == null : value.equals(other.getValue()));
-      }
-      return false;
-    }
-
-    @Override public int hashCode() {
-      return (key == null ? 0 : key.hashCode())
-          ^ (value == null ? 0 : value.hashCode());
-    }
-
-    @Override public String toString() {
-      return key + "=" + value;
-    }
-
-    /**
-     * Returns the first node in this subtree.
-     */
-    public Node<K, V> first() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.left;
-      while (child != null) {
-        node = child;
-        child = node.left;
-      }
-      return node;
-    }
-
-    /**
-     * Returns the last node in this subtree.
-     */
-    public Node<K, V> last() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.right;
-      while (child != null) {
-        node = child;
-        child = node.right;
-      }
-      return node;
-    }
-  }
-
-  private void doubleCapacity() {
-    table = doubleCapacity(table);
-    threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity
-  }
-
-  /**
-   * Returns a new array containing the same nodes as {@code oldTable}, but with
-   * twice as many trees, each of (approximately) half the previous size.
-   */
-  static <K, V> Node<K, V>[] doubleCapacity(Node<K, V>[] oldTable) {
-    // TODO: don't do anything if we're already at MAX_CAPACITY
-    int oldCapacity = oldTable.length;
-    @SuppressWarnings("unchecked") // Arrays and generics don't get along.
-    Node<K, V>[] newTable = new Node[oldCapacity * 2];
-    AvlIterator<K, V> iterator = new AvlIterator<K, V>();
-    AvlBuilder<K, V> leftBuilder = new AvlBuilder<K, V>();
-    AvlBuilder<K, V> rightBuilder = new AvlBuilder<K, V>();
-
-    // Split each tree into two trees.
-    for (int i = 0; i < oldCapacity; i++) {
-      Node<K, V> root = oldTable[i];
-      if (root == null) {
-        continue;
-      }
-
-      // Compute the sizes of the left and right trees.
-      iterator.reset(root);
-      int leftSize = 0;
-      int rightSize = 0;
-      for (Node<K, V> node; (node = iterator.next()) != null; ) {
-        if ((node.hash & oldCapacity) == 0) {
-          leftSize++;
-        } else {
-          rightSize++;
-        }
-      }
-
-      // Split the tree into two.
-      leftBuilder.reset(leftSize);
-      rightBuilder.reset(rightSize);
-      iterator.reset(root);
-      for (Node<K, V> node; (node = iterator.next()) != null; ) {
-        if ((node.hash & oldCapacity) == 0) {
-          leftBuilder.add(node);
-        } else {
-          rightBuilder.add(node);
-        }
-      }
-
-      // Populate the enlarged array with these new roots.
-      newTable[i] = leftSize > 0 ? leftBuilder.root() : null;
-      newTable[i + oldCapacity] = rightSize > 0 ? rightBuilder.root() : null;
-    }
-    return newTable;
-  }
-
-  /**
-   * Walks an AVL tree in iteration order. Once a node has been returned, its
-   * left, right and parent links are <strong>no longer used</strong>. For this
-   * reason it is safe to transform these links as you walk a tree.
-   *
-   * <p><strong>Warning:</strong> this iterator is destructive. It clears the
-   * parent node of all nodes in the tree. It is an error to make a partial
-   * iteration of a tree.
-   */
-  static class AvlIterator<K, V> {
-    /** This stack is a singly linked list, linked by the 'parent' field. */
-    private Node<K, V> stackTop;
-
-    void reset(Node<K, V> root) {
-      Node<K, V> stackTop = null;
-      for (Node<K, V> n = root; n != null; n = n.left) {
-        n.parent = stackTop;
-        stackTop = n; // Stack push.
-      }
-      this.stackTop = stackTop;
-    }
-
-    public Node<K, V> next() {
-      Node<K, V> stackTop = this.stackTop;
-      if (stackTop == null) {
-        return null;
-      }
-      Node<K, V> result = stackTop;
-      stackTop = result.parent;
-      result.parent = null;
-      for (Node<K, V> n = result.right; n != null; n = n.left) {
-        n.parent = stackTop;
-        stackTop = n; // Stack push.
-      }
-      this.stackTop = stackTop;
-      return result;
-    }
-  }
-
-  /**
-   * Builds AVL trees of a predetermined size by accepting nodes of increasing
-   * value. To use:
-   * <ol>
-   *   <li>Call {@link #reset} to initialize the target size <i>size</i>.
-   *   <li>Call {@link #add} <i>size</i> times with increasing values.
-   *   <li>Call {@link #root} to get the root of the balanced tree.
-   * </ol>
-   *
-   * <p>The returned tree will satisfy the AVL constraint: for every node
-   * <i>N</i>, the height of <i>N.left</i> and <i>N.right</i> is different by at
-   * most 1. It accomplishes this by omitting deepest-level leaf nodes when
-   * building trees whose size isn't a power of 2 minus 1.
-   *
-   * <p>Unlike rebuilding a tree from scratch, this approach requires no value
-   * comparisons. Using this class to create a tree of size <i>S</i> is
-   * {@code O(S)}.
-   */
-  final static class AvlBuilder<K, V> {
-    /** This stack is a singly linked list, linked by the 'parent' field. */
-    private Node<K, V> stack;
-    private int leavesToSkip;
-    private int leavesSkipped;
-    private int size;
-
-    void reset(int targetSize) {
-      // compute the target tree size. This is a power of 2 minus one, like 15 or 31.
-      int treeCapacity = Integer.highestOneBit(targetSize) * 2 - 1;
-      leavesToSkip = treeCapacity - targetSize;
-      size = 0;
-      leavesSkipped = 0;
-      stack = null;
-    }
-
-    void add(Node<K, V> node) {
-      node.left = node.parent = node.right = null;
-      node.height = 1;
-
-      // Skip a leaf if necessary.
-      if (leavesToSkip > 0 && (size & 1) == 0) {
-        size++;
-        leavesToSkip--;
-        leavesSkipped++;
-      }
-
-      node.parent = stack;
-      stack = node; // Stack push.
-      size++;
-
-      // Skip a leaf if necessary.
-      if (leavesToSkip > 0 && (size & 1) == 0) {
-        size++;
-        leavesToSkip--;
-        leavesSkipped++;
-      }
-
-      /*
-       * Combine 3 nodes into subtrees whenever the size is one less than a
-       * multiple of 4. For example we combine the nodes A, B, C into a
-       * 3-element tree with B as the root.
-       *
-       * Combine two subtrees and a spare single value whenever the size is one
-       * less than a multiple of 8. For example at 8 we may combine subtrees
-       * (A B C) and (E F G) with D as the root to form ((A B C) D (E F G)).
-       *
-       * Just as we combine single nodes when size nears a multiple of 4, and
-       * 3-element trees when size nears a multiple of 8, we combine subtrees of
-       * size (N-1) whenever the total size is 2N-1 whenever N is a power of 2.
-       */
-      for (int scale = 4; (size & scale - 1) == scale - 1; scale *= 2) {
-        if (leavesSkipped == 0) {
-          // Pop right, center and left, then make center the top of the stack.
-          Node<K, V> right = stack;
-          Node<K, V> center = right.parent;
-          Node<K, V> left = center.parent;
-          center.parent = left.parent;
-          stack = center;
-          // Construct a tree.
-          center.left = left;
-          center.right = right;
-          center.height = right.height + 1;
-          left.parent = center;
-          right.parent = center;
-        } else if (leavesSkipped == 1) {
-          // Pop right and center, then make center the top of the stack.
-          Node<K, V> right = stack;
-          Node<K, V> center = right.parent;
-          stack = center;
-          // Construct a tree with no left child.
-          center.right = right;
-          center.height = right.height + 1;
-          right.parent = center;
-          leavesSkipped = 0;
-        } else if (leavesSkipped == 2) {
-          leavesSkipped = 0;
-        }
-      }
-    }
-
-    Node<K, V> root() {
-      Node<K, V> stackTop = this.stack;
-      if (stackTop.parent != null) {
-        throw new IllegalStateException();
-      }
-      return stackTop;
-    }
-  }
-
-  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {
-    Node<K, V> next = header.next;
-    Node<K, V> lastReturned = null;
-    int expectedModCount = modCount;
-
-    LinkedTreeMapIterator() {
-    }
-
-    public final boolean hasNext() {
-      return next != header;
-    }
-
-    final Node<K, V> nextNode() {
-      Node<K, V> e = next;
-      if (e == header) {
-        throw new NoSuchElementException();
-      }
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
-      }
-      next = e.next;
-      return lastReturned = e;
-    }
-
-    public final void remove() {
-      if (lastReturned == null) {
-        throw new IllegalStateException();
-      }
-      removeInternal(lastReturned, true);
-      lastReturned = null;
-      expectedModCount = modCount;
-    }
-  }
-
-  final class EntrySet extends AbstractSet<Entry<K, V>> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<Entry<K, V>> iterator() {
-      return new LinkedTreeMapIterator<Entry<K, V>>() {
-        public Entry<K, V> next() {
-          return nextNode();
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
-    }
-
-    @Override public boolean remove(Object o) {
-      if (!(o instanceof Entry)) {
-        return false;
-      }
-
-      Node<K, V> node = findByEntry((Entry<?, ?>) o);
-      if (node == null) {
-        return false;
-      }
-      removeInternal(node, true);
-      return true;
-    }
-
-    @Override public void clear() {
-      LinkedHashTreeMap.this.clear();
-    }
-  }
-
-  final class KeySet extends AbstractSet<K> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<K> iterator() {
-      return new LinkedTreeMapIterator<K>() {
-        public K next() {
-          return nextNode().key;
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return containsKey(o);
-    }
-
-    @Override public boolean remove(Object key) {
-      return removeInternalByKey(key) != null;
-    }
-
-    @Override public void clear() {
-      LinkedHashTreeMap.this.clear();
-    }
-  }
-
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a LinkedHashMap so that they won't need Gson on the other side to
-   * deserialize it. Using serialization defeats our DoS defence, so most apps
-   * shouldn't use it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new LinkedHashMap<K, V>(this);
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java b/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
deleted file mode 100644
index 6ef20607f..000000000
--- a/gson/src/main/java/com/google/gson/internal/ObjectConstructor.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-/**
- * Defines a generic object construction factory.  The purpose of this class
- * is to construct a default instance of a class that can be used for object
- * navigation while deserialization from its JSON representation.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public interface ObjectConstructor<T> {
-
-  /**
-   * Returns a new instance.
-   */
-  public T construct();
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
index 999a2b57e..a5414cbfb 100644
--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
@@ -29,9 +29,11 @@
  * @author Jesse Wilson
  */
 public abstract class UnsafeAllocator {
+  public static final UnsafeAllocator allocator = create();
+	
   public abstract <T> T newInstance(Class<T> c) throws Exception;
 
-  public static UnsafeAllocator create() {
+  private static UnsafeAllocator create() {
     // try JVM
     // public class Unsafe {
     //   public Object allocateInstance(Class<?> type);
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
index 1d57844a4..b8beeab4f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -16,19 +16,14 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.util.Collection;
+import com.google.gson.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.function.*;
 
 /**
  * Adapt a homogeneous collection of objects.
@@ -51,7 +46,7 @@ public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructo
 
     Type elementType = $Gson$Types.getCollectionElementType(type, rawType);
     TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
-    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);
+    Supplier<T> constructor = constructorConstructor.get(typeToken);
 
     @SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
     TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);
@@ -60,11 +55,11 @@ public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructo
 
   private static final class Adapter<E> extends TypeAdapter<Collection<E>> {
     private final TypeAdapter<E> elementTypeAdapter;
-    private final ObjectConstructor<? extends Collection<E>> constructor;
+    private final Supplier<? extends Collection<E>> constructor;
 
     public Adapter(Gson context, Type elementType,
         TypeAdapter<E> elementTypeAdapter,
-        ObjectConstructor<? extends Collection<E>> constructor) {
+        Supplier<? extends Collection<E>> constructor) {
       this.elementTypeAdapter =
           new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);
       this.constructor = constructor;
@@ -76,7 +71,7 @@ public Adapter(Gson context, Type elementType,
         return null;
       }
 
-      Collection<E> collection = constructor.construct();
+      Collection<E> collection = constructor.get();
       in.beginArray();
       while (in.hasNext()) {
         E instance = elementTypeAdapter.read(in);
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
similarity index 93%
rename from gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
rename to gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
index 522963795..5b38247e0 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal.bind;
 
 import java.io.IOException;
 import java.sql.Timestamp;
@@ -26,7 +26,7 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
-
+import com.google.gson.*;
 import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
@@ -41,7 +41,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
+public final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
 
   private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
 
@@ -53,7 +53,7 @@
    */
   private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
 
-  DefaultDateTypeAdapter(Class<? extends Date> dateType) {
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType) {
     this.dateType = verifyDateType(dateType);
     dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
     if (!Locale.getDefault().equals(Locale.US)) {
@@ -64,7 +64,7 @@
     }
   }
 
-  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
     this.dateType = verifyDateType(dateType);
     dateFormats.add(new SimpleDateFormat(datePattern, Locale.US));
     if (!Locale.getDefault().equals(Locale.US)) {
@@ -72,7 +72,7 @@
     }
   }
 
-  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
     this.dateType = verifyDateType(dateType);
     dateFormats.add(DateFormat.getDateInstance(style, Locale.US));
     if (!Locale.getDefault().equals(Locale.US)) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 13a7bb7eb..8d2a7a98a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -50,9 +50,10 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
   }
 
   @SuppressWarnings({ "unchecked", "rawtypes" }) // Casts guarded by conditionals.
+static
   TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
       TypeToken<?> type, JsonAdapter annotation) {
-    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();
+    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).get();
 
     TypeAdapter<?> typeAdapter;
     if (instance instanceof TypeAdapter) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 5a34a5d5f..2468b2aa3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -16,26 +16,14 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.JsonReaderInternalAccess;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.internal.Streams;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
+import com.google.gson.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.function.*;
 
 /**
  * Adapts maps to either JSON objects or JSON arrays.
@@ -124,7 +112,7 @@ public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,
     Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);
     TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);
     TypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));
-    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);
+    Supplier<T> constructor = constructorConstructor.get(typeToken);
 
     @SuppressWarnings({"unchecked", "rawtypes"})
     // we don't define a type parameter for the key or value types
@@ -145,11 +133,11 @@ public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,
   private final class Adapter<K, V> extends TypeAdapter<Map<K, V>> {
     private final TypeAdapter<K> keyTypeAdapter;
     private final TypeAdapter<V> valueTypeAdapter;
-    private final ObjectConstructor<? extends Map<K, V>> constructor;
+    private final Supplier<? extends Map<K, V>> constructor;
 
     public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
         Type valueType, TypeAdapter<V> valueTypeAdapter,
-        ObjectConstructor<? extends Map<K, V>> constructor) {
+        Supplier<? extends Map<K, V>> constructor) {
       this.keyTypeAdapter =
         new TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);
       this.valueTypeAdapter =
@@ -164,7 +152,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
         return null;
       }
 
-      Map<K, V> map = constructor.construct();
+      Map<K, V> map = constructor.get();
 
       if (peek == JsonToken.BEGIN_ARRAY) {
         in.beginArray();
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 777e7dee3..b434ae55c 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -16,31 +16,15 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.FieldNamingStrategy;
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.JsonAdapter;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.internal.Primitives;
-import com.google.gson.internal.reflect.ReflectionAccessor;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import com.google.gson.*;
+import com.google.gson.annotations.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.function.*;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -50,7 +34,6 @@
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
-  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
@@ -98,7 +81,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       return null; // it's a primitive!
     }
 
-    ObjectConstructor<T> constructor = constructorConstructor.get(type);
+    Supplier<T> constructor = constructorConstructor.get(type);
     return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
   }
 
@@ -156,7 +139,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         if (!serialize && !deserialize) {
           continue;
         }
-        accessor.makeAccessible(field);
+        field.setAccessible(true);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;
@@ -195,10 +178,10 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
   }
 
   public static final class Adapter<T> extends TypeAdapter<T> {
-    private final ObjectConstructor<T> constructor;
+    private final Supplier<T> constructor;
     private final Map<String, BoundField> boundFields;
 
-    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
+    Adapter(Supplier<T> constructor, Map<String, BoundField> boundFields) {
       this.constructor = constructor;
       this.boundFields = boundFields;
     }
@@ -209,7 +192,7 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
         return null;
       }
 
-      T instance = constructor.construct();
+      T instance = constructor.get();
 
       try {
         in.beginObject();
diff --git a/gson/src/main/java/com/google/gson/internal/package-info.java b/gson/src/main/java/com/google/gson/internal/package-info.java
deleted file mode 100644
index b5139b6de..000000000
--- a/gson/src/main/java/com/google/gson/internal/package-info.java
+++ /dev/null
@@ -1,7 +0,0 @@
-/**
- * Do NOT use any class in this package as they are meant for internal use in Gson.
- * These classes will very likely change incompatibly in future versions. You have been warned.
- *
- * @author Inderjeet Singh, Joel Leitch, Jesse Wilson
- */
-package com.google.gson.internal;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
deleted file mode 100644
index 325274e22..000000000
--- a/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal.reflect;
-
-import java.lang.reflect.AccessibleObject;
-
-/**
- * A basic implementation of {@link ReflectionAccessor} which is suitable for Java 8 and below.
- * <p>
- * This implementation just calls {@link AccessibleObject#setAccessible(boolean) setAccessible(true)}, which worked
- * fine before Java 9.
- */
-final class PreJava9ReflectionAccessor extends ReflectionAccessor {
-
-  /** {@inheritDoc} */
-  @Override
-  public void makeAccessible(AccessibleObject ao) {
-    ao.setAccessible(true);
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
deleted file mode 100644
index 6816feaf2..000000000
--- a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal.reflect;
-
-import java.lang.reflect.AccessibleObject;
-
-import com.google.gson.internal.JavaVersion;
-
-/**
- * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
- * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
- * thrown or warnings like
- * <pre>
- *   WARNING: An illegal reflective access operation has occurred
- *   WARNING: Illegal reflective access by ...
- * </pre>
- * <p/>
- * Works both for Java 9 and earlier Java versions.
- */
-public abstract class ReflectionAccessor {
-
-  // the singleton instance, use getInstance() to obtain
-  private static final ReflectionAccessor instance = JavaVersion.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
-
-  /**
-   * Does the same as {@code ao.setAccessible(true)}, but never throws
-   * {@link java.lang.reflect.InaccessibleObjectException}
-   */
-  public abstract void makeAccessible(AccessibleObject ao);
-
-  /**
-   * Obtains a {@link ReflectionAccessor} instance suitable for the current Java version.
-   * <p>
-   * You may need one a reflective operation in your code throws {@link java.lang.reflect.InaccessibleObjectException}.
-   * In such a case, use {@link ReflectionAccessor#makeAccessible(AccessibleObject)} on a field, method or constructor
-   * (instead of basic {@link AccessibleObject#setAccessible(boolean)}).
-   */
-  public static ReflectionAccessor getInstance() {
-    return instance;
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
deleted file mode 100644
index 749335b77..000000000
--- a/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal.reflect;
-
-import java.lang.reflect.AccessibleObject;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-
-import com.google.gson.JsonIOException;
-
-/**
- * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
- * <p>
- * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
- * use {@link PreJava9ReflectionAccessor} for them.
- */
-@SuppressWarnings({"unchecked", "rawtypes"})
-final class UnsafeReflectionAccessor extends ReflectionAccessor {
-
-  private static Class unsafeClass;
-  private final Object theUnsafe = getUnsafeInstance();
-  private final Field overrideField = getOverrideField();
-
-  /** {@inheritDoc} */
-  @Override
-  public void makeAccessible(AccessibleObject ao) {
-    boolean success = makeAccessibleWithUnsafe(ao);
-    if (!success) {
-      try {
-        // unsafe couldn't be found, so try using accessible anyway
-        ao.setAccessible(true);
-      } catch (SecurityException e) {
-        throw new JsonIOException("Gson couldn't modify fields for " + ao
-          + "\nand sun.misc.Unsafe not found.\nEither write a custom type adapter,"
-          + " or make fields accessible, or include sun.misc.Unsafe.", e);
-      }
-    }
-  }
-
-  // Visible for testing only
-  boolean makeAccessibleWithUnsafe(AccessibleObject ao) {
-    if (theUnsafe != null && overrideField != null) {
-      try {
-        Method method = unsafeClass.getMethod("objectFieldOffset", Field.class);
-        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
-        Method putBooleanMethod = unsafeClass.getMethod("putBoolean",  Object.class, long.class, boolean.class);
-        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);
-        return true;
-      } catch (Exception ignored) { // do nothing
-      }
-    }
-    return false;
-  }
-
-  private static Object getUnsafeInstance() {
-    try {
-      unsafeClass = Class.forName("sun.misc.Unsafe");
-      Field unsafeField = unsafeClass.getDeclaredField("theUnsafe");
-      unsafeField.setAccessible(true);
-      return unsafeField.get(null);
-    } catch (Exception e) {
-      return null;
-    }
-  }
-
-  private static Field getOverrideField() {
-    try {
-      return AccessibleObject.class.getDeclaredField("override");
-    } catch (NoSuchFieldException e) {
-      return null;
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
index 3fb8af2bc..7bdb06c41 100644
--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java
+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
@@ -16,14 +16,9 @@
 
 package com.google.gson.reflect;
 
-import com.google.gson.internal.$Gson$Types;
-import com.google.gson.internal.$Gson$Preconditions;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.util.HashMap;
-import java.util.Map;
+import com.google.gson.internal.*;
+import java.lang.reflect.*;
+import java.util.*;
 
 /**
  * Represents a generic type {@code T}. Java doesn't yet provide a way to
@@ -69,7 +64,7 @@ protected TypeToken() {
    */
   @SuppressWarnings("unchecked")
   TypeToken(Type type) {
-    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));
+    this.type = $Gson$Types.canonicalize(Objects.requireNonNull(type));
     this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);
     this.hashCode = this.type.hashCode();
   }
@@ -101,181 +96,6 @@ public final Type getType() {
     return type;
   }
 
-  /**
-   * Check if this type is assignable from the given class object.
-   *
-   * @deprecated this implementation may be inconsistent with javac for types
-   *     with wildcards.
-   */
-  @Deprecated
-  public boolean isAssignableFrom(Class<?> cls) {
-    return isAssignableFrom((Type) cls);
-  }
-
-  /**
-   * Check if this type is assignable from the given Type.
-   *
-   * @deprecated this implementation may be inconsistent with javac for types
-   *     with wildcards.
-   */
-  @Deprecated
-  public boolean isAssignableFrom(Type from) {
-    if (from == null) {
-      return false;
-    }
-
-    if (type.equals(from)) {
-      return true;
-    }
-
-    if (type instanceof Class<?>) {
-      return rawType.isAssignableFrom($Gson$Types.getRawType(from));
-    } else if (type instanceof ParameterizedType) {
-      return isAssignableFrom(from, (ParameterizedType) type,
-          new HashMap<String, Type>());
-    } else if (type instanceof GenericArrayType) {
-      return rawType.isAssignableFrom($Gson$Types.getRawType(from))
-          && isAssignableFrom(from, (GenericArrayType) type);
-    } else {
-      throw buildUnexpectedTypeError(
-          type, Class.class, ParameterizedType.class, GenericArrayType.class);
-    }
-  }
-
-  /**
-   * Check if this type is assignable from the given type token.
-   *
-   * @deprecated this implementation may be inconsistent with javac for types
-   *     with wildcards.
-   */
-  @Deprecated
-  public boolean isAssignableFrom(TypeToken<?> token) {
-    return isAssignableFrom(token.getType());
-  }
-
-  /**
-   * Private helper function that performs some assignability checks for
-   * the provided GenericArrayType.
-   */
-  private static boolean isAssignableFrom(Type from, GenericArrayType to) {
-    Type toGenericComponentType = to.getGenericComponentType();
-    if (toGenericComponentType instanceof ParameterizedType) {
-      Type t = from;
-      if (from instanceof GenericArrayType) {
-        t = ((GenericArrayType) from).getGenericComponentType();
-      } else if (from instanceof Class<?>) {
-        Class<?> classType = (Class<?>) from;
-        while (classType.isArray()) {
-          classType = classType.getComponentType();
-        }
-        t = classType;
-      }
-      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,
-          new HashMap<String, Type>());
-    }
-    // No generic defined on "to"; therefore, return true and let other
-    // checks determine assignability
-    return true;
-  }
-
-  /**
-   * Private recursive helper function to actually do the type-safe checking
-   * of assignability.
-   */
-  private static boolean isAssignableFrom(Type from, ParameterizedType to,
-      Map<String, Type> typeVarMap) {
-
-    if (from == null) {
-      return false;
-    }
-
-    if (to.equals(from)) {
-      return true;
-    }
-
-    // First figure out the class and any type information.
-    Class<?> clazz = $Gson$Types.getRawType(from);
-    ParameterizedType ptype = null;
-    if (from instanceof ParameterizedType) {
-      ptype = (ParameterizedType) from;
-    }
-
-    // Load up parameterized variable info if it was parameterized.
-    if (ptype != null) {
-      Type[] tArgs = ptype.getActualTypeArguments();
-      TypeVariable<?>[] tParams = clazz.getTypeParameters();
-      for (int i = 0; i < tArgs.length; i++) {
-        Type arg = tArgs[i];
-        TypeVariable<?> var = tParams[i];
-        while (arg instanceof TypeVariable<?>) {
-          TypeVariable<?> v = (TypeVariable<?>) arg;
-          arg = typeVarMap.get(v.getName());
-        }
-        typeVarMap.put(var.getName(), arg);
-      }
-
-      // check if they are equivalent under our current mapping.
-      if (typeEquals(ptype, to, typeVarMap)) {
-        return true;
-      }
-    }
-
-    for (Type itype : clazz.getGenericInterfaces()) {
-      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {
-        return true;
-      }
-    }
-
-    // Interfaces didn't work, try the superclass.
-    Type sType = clazz.getGenericSuperclass();
-    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));
-  }
-
-  /**
-   * Checks if two parameterized types are exactly equal, under the variable
-   * replacement described in the typeVarMap.
-   */
-  private static boolean typeEquals(ParameterizedType from,
-      ParameterizedType to, Map<String, Type> typeVarMap) {
-    if (from.getRawType().equals(to.getRawType())) {
-      Type[] fromArgs = from.getActualTypeArguments();
-      Type[] toArgs = to.getActualTypeArguments();
-      for (int i = 0; i < fromArgs.length; i++) {
-        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {
-          return false;
-        }
-      }
-      return true;
-    }
-    return false;
-  }
-
-  private static AssertionError buildUnexpectedTypeError(
-      Type token, Class<?>... expected) {
-
-    // Build exception message
-    StringBuilder exceptionMessage =
-        new StringBuilder("Unexpected type. Expected one of: ");
-    for (Class<?> clazz : expected) {
-      exceptionMessage.append(clazz.getName()).append(", ");
-    }
-    exceptionMessage.append("but got: ").append(token.getClass().getName())
-        .append(", for type token: ").append(token.toString()).append('.');
-
-    return new AssertionError(exceptionMessage.toString());
-  }
-
-  /**
-   * Checks if two types are the same or are equivalent under a variable mapping
-   * given in the type map that was provided.
-   */
-  private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
-    return to.equals(from)
-        || (from instanceof TypeVariable
-        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));
-
-  }
-
   @Override public final int hashCode() {
     return this.hashCode;
   }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonScope.java b/gson/src/main/java/com/google/gson/stream/JsonScope.java
index da6913727..02a9eb06c 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonScope.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonScope.java
@@ -23,8 +23,7 @@
  * @since 1.6
  */
 final class JsonScope {
-
-    /**
+	/**
      * An array with no elements requires no separators or newlines before
      * it is closed.
      */
@@ -68,4 +67,5 @@
      * A document that's been closed and cannot be accessed.
      */
     static final int CLOSED = 8;
+    
 }
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
index 679feb835..b95666737 100644
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
@@ -24,7 +24,7 @@
 import java.util.TimeZone;
 
 import com.google.gson.internal.JavaVersion;
-
+import com.google.gson.internal.bind.*;
 import junit.framework.TestCase;
 
 /**
diff --git a/gson/src/test/java/com/google/gson/FieldAttributesTest.java b/gson/src/test/java/com/google/gson/FieldAttributesTest.java
deleted file mode 100644
index 8a9d95338..000000000
--- a/gson/src/test/java/com/google/gson/FieldAttributesTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import com.google.gson.reflect.TypeToken;
-
-import junit.framework.TestCase;
-
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
-import java.util.List;
-
-/**
- * Unit tests for the {@link FieldAttributes} class.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public class FieldAttributesTest extends TestCase {
-  private FieldAttributes fieldAttributes;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    fieldAttributes = new FieldAttributes(Foo.class.getField("bar"));
-  }
-
-  public void testNullField() throws Exception {
-    try {
-      new FieldAttributes(null);
-      fail("Field parameter can not be null");
-    } catch (NullPointerException expected) { }
-  }
-
-  public void testDeclaringClass() throws Exception {
-    assertEquals(Foo.class, fieldAttributes.getDeclaringClass());
-  }
-
-  public void testModifiers() throws Exception {
-    assertFalse(fieldAttributes.hasModifier(Modifier.STATIC));
-    assertFalse(fieldAttributes.hasModifier(Modifier.FINAL));
-    assertFalse(fieldAttributes.hasModifier(Modifier.ABSTRACT));
-    assertFalse(fieldAttributes.hasModifier(Modifier.VOLATILE));
-    assertFalse(fieldAttributes.hasModifier(Modifier.PROTECTED));
-
-    assertTrue(fieldAttributes.hasModifier(Modifier.PUBLIC));
-    assertTrue(fieldAttributes.hasModifier(Modifier.TRANSIENT));
-  }
-
-  public void testIsSynthetic() throws Exception {
-    assertFalse(fieldAttributes.isSynthetic());
-  }
-
-  public void testName() throws Exception {
-    assertEquals("bar", fieldAttributes.getName());
-  }
-
-  public void testDeclaredTypeAndClass() throws Exception {
-    Type expectedType = new TypeToken<List<String>>() {}.getType();
-    assertEquals(expectedType, fieldAttributes.getDeclaredType());
-    assertEquals(List.class, fieldAttributes.getDeclaredClass());
-  }
-
-  private static class Foo {
-    @SuppressWarnings("unused")
-    public transient List<String> bar;
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/JsonNullTest.java b/gson/src/test/java/com/google/gson/JsonNullTest.java
deleted file mode 100644
index 6157e3876..000000000
--- a/gson/src/test/java/com/google/gson/JsonNullTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import com.google.gson.common.MoreAsserts;
-import junit.framework.TestCase;
-
-/**
- * @author Jesse Wilson
- */
-public final class JsonNullTest extends TestCase {
-
-  @SuppressWarnings("deprecation")
-  public void testEqualsAndHashcode() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), new JsonNull());
-    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), JsonNull.INSTANCE);
-    MoreAsserts.assertEqualsAndHashCode(JsonNull.INSTANCE, JsonNull.INSTANCE);
-  }
-
-  public void testDeepCopy() {
-    @SuppressWarnings("deprecation")
-    JsonNull a = new JsonNull();
-    assertSame(JsonNull.INSTANCE, a.deepCopy());
-    assertSame(JsonNull.INSTANCE, JsonNull.INSTANCE.deepCopy());
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java
index 652b52885..9e47b9733 100644
--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java
+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java
@@ -104,7 +104,6 @@ public void testAddingCharacterProperties() throws Exception {
     JsonElement jsonElement = jsonObj.get(propertyName);
     assertNotNull(jsonElement);
     assertEquals(String.valueOf(value), jsonElement.getAsString());
-    assertEquals(value, jsonElement.getAsCharacter());
   }
 
   /**
diff --git a/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java b/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
index a9fbff935..7d3d9a690 100644
--- a/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
@@ -91,8 +91,6 @@ public void testParsingStringAsNumber() throws Exception {
     assertEquals(1F, json.getAsFloat(), 0.00001);
     assertEquals(1, json.getAsInt());
     assertEquals(1L, json.getAsLong());
-    assertEquals((short) 1, json.getAsShort());
-    assertEquals((byte) 1, json.getAsByte());
     assertEquals(new BigInteger("1"), json.getAsBigInteger());
     assertEquals(new BigDecimal("1"), json.getAsBigDecimal());
   }
@@ -100,12 +98,10 @@ public void testParsingStringAsNumber() throws Exception {
   public void testStringsAndChar() throws Exception {
     JsonPrimitive json = new JsonPrimitive("abc");
     assertTrue(json.isString());
-    assertEquals('a', json.getAsCharacter());
     assertEquals("abc", json.getAsString());
 
     json = new JsonPrimitive('z');
     assertTrue(json.isString());
-    assertEquals('z', json.getAsCharacter());
     assertEquals("z", json.getAsString());
   }
 
diff --git a/gson/src/test/java/com/google/gson/MockExclusionStrategy.java b/gson/src/test/java/com/google/gson/MockExclusionStrategy.java
deleted file mode 100644
index 7830d8a2f..000000000
--- a/gson/src/test/java/com/google/gson/MockExclusionStrategy.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-/**
- * This is a configurable {@link ExclusionStrategy} that can be used for
- * unit testing.
- *
- * @author Joel Leitch
- */
-final class MockExclusionStrategy implements ExclusionStrategy {
-  private final boolean skipClass;
-  private final boolean skipField;
-
-  public MockExclusionStrategy(boolean skipClass, boolean skipField) {
-    this.skipClass = skipClass;
-    this.skipField = skipField;
-  }
-
-  @Override
-  public boolean shouldSkipField(FieldAttributes f) {
-    return skipField;
-  }
-
-  @Override
-  public boolean shouldSkipClass(Class<?> clazz) {
-    return skipClass;
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
index 2eca8bb4f..148378f00 100644
--- a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
@@ -16,17 +16,10 @@
 
 package com.google.gson.functional;
 
-import com.google.gson.ExclusionStrategy;
-import com.google.gson.FieldAttributes;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import junit.framework.TestCase;
+import com.google.gson.*;
+import java.lang.annotation.*;
+import java.lang.reflect.*;
+import junit.framework.*;
 
 /**
  * Performs some functional tests when Gson is instantiated with some common user defined
@@ -37,7 +30,7 @@
  */
 public class ExclusionStrategyFunctionalTest extends TestCase {
   private static final ExclusionStrategy EXCLUDE_SAMPLE_OBJECT_FOR_TEST = new ExclusionStrategy() {
-    @Override public boolean shouldSkipField(FieldAttributes f) {
+    @Override public boolean shouldSkipField(Field f) {
       return false;
     }
     @Override public boolean shouldSkipClass(Class<?> clazz) {
@@ -195,7 +188,7 @@ private MyExclusionStrategy(Class<?> typeToSkip) {
       return (clazz == typeToSkip);
     }
 
-    @Override public boolean shouldSkipField(FieldAttributes f) {
+    @Override public boolean shouldSkipField(Field f) {
       return f.getAnnotation(Foo.class) != null;
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
index 4e383ec83..bd2089588 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
@@ -16,13 +16,13 @@
 
 package com.google.gson.functional;
 
-import static com.google.gson.FieldNamingPolicy.IDENTITY;
-import static com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_DASHES;
-import static com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES;
-import static com.google.gson.FieldNamingPolicy.UPPER_CAMEL_CASE;
-import static com.google.gson.FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES;
+import static com.google.gson.FieldNamingStrategy.IDENTITY;
+import static com.google.gson.FieldNamingStrategy.LOWER_CASE_WITH_DASHES;
+import static com.google.gson.FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES;
+import static com.google.gson.FieldNamingStrategy.UPPER_CAMEL_CASE;
+import static com.google.gson.FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES;
 
-import com.google.gson.FieldNamingPolicy;
+import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.annotations.SerializedName;
@@ -69,9 +69,9 @@ public void testLowerCaseWithDashes() {
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
-  private Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){
+  private Gson getGsonWithNamingPolicy(FieldNamingStrategy fieldNamingPolicy){
     return new GsonBuilder()
-      .setFieldNamingPolicy(fieldNamingPolicy)
+      .setFieldNamingStrategy(fieldNamingPolicy)
         .create();
   }
 
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index 5b1bba5be..6585b5b58 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -15,7 +15,6 @@
  */
 package com.google.gson.functional;
 
-import com.google.gson.FieldNamingPolicy;
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -43,49 +42,49 @@ protected void setUp() throws Exception {
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicySerialization() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).create();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"SomeConstantStringInstanceField\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).create();
     String target = "{\"SomeConstantStringInstanceField\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicySerialization() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).create();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some-constant-string-instance-field\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicySerialization() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).create();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some.constant.string.instance.field\":\""
           + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).create();
     String target = "{\"some.constant.string.instance.field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).create();
     String target = "{\"some-constant-string-instance-field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseUnderscorePolicySerialization() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
         .create();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some_constant_string_instance_field\":\""
@@ -93,7 +92,7 @@ public void testGsonWithLowerCaseUnderscorePolicySerialization() {
   }
 
   public void testGsonWithLowerCaseUnderscorePolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
         .create();
     String target = "{\"some_constant_string_instance_field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
@@ -126,7 +125,7 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
   }
 
   public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
         .create();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"Some Constant String Instance Field\":\""
@@ -134,7 +133,7 @@ public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
   }
 
   public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
         .create();
     String target = "{\"Some Constant String Instance Field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
diff --git a/gson/src/test/java/com/google/gson/internal/LinkedHashTreeMapTest.java b/gson/src/test/java/com/google/gson/internal/LinkedHashTreeMapTest.java
deleted file mode 100644
index 2aeeeb764..000000000
--- a/gson/src/test/java/com/google/gson/internal/LinkedHashTreeMapTest.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import com.google.gson.common.MoreAsserts;
-import com.google.gson.internal.LinkedHashTreeMap.AvlBuilder;
-import com.google.gson.internal.LinkedHashTreeMap.AvlIterator;
-import com.google.gson.internal.LinkedHashTreeMap.Node;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Random;
-import junit.framework.TestCase;
-
-public final class LinkedHashTreeMapTest extends TestCase {
-  public void testIterationOrder() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    assertIterationOrder(map.keySet(), "a", "c", "b");
-    assertIterationOrder(map.values(), "android", "cola", "bbq");
-  }
-
-  public void testRemoveRootDoesNotDoubleUnlink() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    Iterator<Map.Entry<String,String>> it = map.entrySet().iterator();
-    it.next();
-    it.next();
-    it.next();
-    it.remove();
-    assertIterationOrder(map.keySet(), "a", "c");
-  }
-
-  public void testPutNullKeyFails() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    try {
-      map.put(null, "android");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  public void testPutNonComparableKeyFails() {
-    LinkedHashTreeMap<Object, String> map = new LinkedHashTreeMap<Object, String>();
-    try {
-      map.put(new Object(), "android");
-      fail();
-    } catch (ClassCastException expected) {}
-  }
-
-  public void testContainsNonComparableKeyReturnsFalse() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "android");
-    assertFalse(map.containsKey(new Object()));
-  }
-
-  public void testContainsNullKeyIsAlwaysFalse() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "android");
-    assertFalse(map.containsKey(null));
-  }
-
-  public void testPutOverrides() throws Exception {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    assertNull(map.put("d", "donut"));
-    assertNull(map.put("e", "eclair"));
-    assertNull(map.put("f", "froyo"));
-    assertEquals(3, map.size());
-
-    assertEquals("donut", map.get("d"));
-    assertEquals("donut", map.put("d", "done"));
-    assertEquals(3, map.size());
-  }
-
-  public void testEmptyStringValues() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "");
-    assertTrue(map.containsKey("a"));
-    assertEquals("", map.get("a"));
-  }
-
-  // NOTE that this does not happen every time, but given the below predictable random,
-  // this test will consistently fail (assuming the initial size is 16 and rehashing
-  // size remains at 3/4)
-  public void testForceDoublingAndRehash() throws Exception {
-    Random random = new Random(1367593214724L);
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    String[] keys = new String[1000];
-    for (int i = 0; i < keys.length; i++) {
-      keys[i] = Integer.toString(Math.abs(random.nextInt()), 36) + "-" + i;
-      map.put(keys[i], "" + i);
-    }
-
-    for (int i = 0; i < keys.length; i++) {
-      String key = keys[i];
-      assertTrue(map.containsKey(key));
-      assertEquals("" + i, map.get(key));
-    }
-  }
-
-  public void testClear() {
-    LinkedHashTreeMap<String, String> map = new LinkedHashTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    map.clear();
-    assertIterationOrder(map.keySet());
-    assertEquals(0, map.size());
-  }
-
-  public void testEqualsAndHashCode() throws Exception {
-    LinkedHashTreeMap<String, Integer> map1 = new LinkedHashTreeMap<String, Integer>();
-    map1.put("A", 1);
-    map1.put("B", 2);
-    map1.put("C", 3);
-    map1.put("D", 4);
-
-    LinkedHashTreeMap<String, Integer> map2 = new LinkedHashTreeMap<String, Integer>();
-    map2.put("C", 3);
-    map2.put("B", 2);
-    map2.put("D", 4);
-    map2.put("A", 1);
-
-    MoreAsserts.assertEqualsAndHashCode(map1, map2);
-  }
-
-  public void testAvlWalker() {
-    assertAvlWalker(node(node("a"), "b", node("c")),
-        "a", "b", "c");
-    assertAvlWalker(node(node(node("a"), "b", node("c")), "d", node(node("e"), "f", node("g"))),
-        "a", "b", "c", "d", "e", "f", "g");
-    assertAvlWalker(node(node(null, "a", node("b")), "c", node(node("d"), "e", null)),
-        "a", "b", "c", "d", "e");
-    assertAvlWalker(node(null, "a", node(null, "b", node(null, "c", node("d")))),
-        "a", "b", "c", "d");
-    assertAvlWalker(node(node(node(node("a"), "b", null), "c", null), "d", null),
-        "a", "b", "c", "d");
-  }
-
-  private void assertAvlWalker(Node<String, String> root, String... values) {
-    AvlIterator<String, String> iterator = new AvlIterator<String, String>();
-    iterator.reset(root);
-    for (String value : values) {
-      assertEquals(value, iterator.next().getKey());
-    }
-    assertNull(iterator.next());
-  }
-
-  public void testAvlBuilder() {
-    assertAvlBuilder(1, "a");
-    assertAvlBuilder(2, "(. a b)");
-    assertAvlBuilder(3, "(a b c)");
-    assertAvlBuilder(4, "(a b (. c d))");
-    assertAvlBuilder(5, "(a b (c d e))");
-    assertAvlBuilder(6, "((. a b) c (d e f))");
-    assertAvlBuilder(7, "((a b c) d (e f g))");
-    assertAvlBuilder(8, "((a b c) d (e f (. g h)))");
-    assertAvlBuilder(9, "((a b c) d (e f (g h i)))");
-    assertAvlBuilder(10, "((a b c) d ((. e f) g (h i j)))");
-    assertAvlBuilder(11, "((a b c) d ((e f g) h (i j k)))");
-    assertAvlBuilder(12, "((a b (. c d)) e ((f g h) i (j k l)))");
-    assertAvlBuilder(13, "((a b (c d e)) f ((g h i) j (k l m)))");
-    assertAvlBuilder(14, "(((. a b) c (d e f)) g ((h i j) k (l m n)))");
-    assertAvlBuilder(15, "(((a b c) d (e f g)) h ((i j k) l (m n o)))");
-    assertAvlBuilder(16, "(((a b c) d (e f g)) h ((i j k) l (m n (. o p))))");
-    assertAvlBuilder(30, "((((. a b) c (d e f)) g ((h i j) k (l m n))) o "
-        + "(((p q r) s (t u v)) w ((x y z) A (B C D))))");
-    assertAvlBuilder(31, "((((a b c) d (e f g)) h ((i j k) l (m n o))) p "
-        + "(((q r s) t (u v w)) x ((y z A) B (C D E))))");
-  }
-
-  private void assertAvlBuilder(int size, String expected) {
-    char[] values = "abcdefghijklmnopqrstuvwxyzABCDE".toCharArray();
-    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();
-    avlBuilder.reset(size);
-    for (int i = 0; i < size; i++) {
-      avlBuilder.add(node(Character.toString(values[i])));
-    }
-    assertTree(expected, avlBuilder.root());
-  }
-
-  public void testDoubleCapacity() {
-    @SuppressWarnings("unchecked") // Arrays and generics don't get along.
-    Node<String, String>[] oldTable = new Node[1];
-    oldTable[0] = node(node(node("a"), "b", node("c")), "d", node(node("e"), "f", node("g")));
-
-    Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);
-    assertTree("(b d f)", newTable[0]); // Even hash codes!
-    assertTree("(a c (. e g))", newTable[1]); // Odd hash codes!
-  }
-
-  public void testDoubleCapacityAllNodesOnLeft() {
-    @SuppressWarnings("unchecked") // Arrays and generics don't get along.
-    Node<String, String>[] oldTable = new Node[1];
-    oldTable[0] = node(node("b"), "d", node("f"));
-
-    Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);
-    assertTree("(b d f)", newTable[0]); // Even hash codes!
-    assertNull(newTable[1]); // Odd hash codes!
-
-    for (Node<?, ?> node : newTable) {
-      if (node != null) {
-        assertConsistent(node);
-      }
-    }
-  }
-
-  private static final Node<String, String> head = new Node<String, String>();
-
-  private Node<String, String> node(String value) {
-    return new Node<String, String>(null, value, value.hashCode(), head, head);
-  }
-
-  private Node<String, String> node(Node<String, String> left, String value,
-      Node<String, String> right) {
-    Node<String, String> result = node(value);
-    if (left != null) {
-      result.left = left;
-      left.parent = result;
-    }
-    if (right != null) {
-      result.right = right;
-      right.parent = result;
-    }
-    return result;
-  }
-
-  private void assertTree(String expected, Node<?, ?> root) {
-    assertEquals(expected, toString(root));
-    assertConsistent(root);
-  }
-
-  private void assertConsistent(Node<?, ?> node) {
-    int leftHeight = 0;
-    if (node.left != null) {
-      assertConsistent(node.left);
-      assertSame(node, node.left.parent);
-      leftHeight = node.left.height;
-    }
-    int rightHeight = 0;
-    if (node.right != null) {
-      assertConsistent(node.right);
-      assertSame(node, node.right.parent);
-      rightHeight = node.right.height;
-    }
-    if (node.parent != null) {
-      assertTrue(node.parent.left == node || node.parent.right == node);
-    }
-    if (Math.max(leftHeight, rightHeight) + 1 != node.height) {
-      fail();
-    }
-  }
-
-  private String toString(Node<?, ?> root) {
-    if (root == null) {
-      return ".";
-    } else if (root.left == null && root.right == null) {
-      return String.valueOf(root.key);
-    } else {
-      return String.format("(%s %s %s)", toString(root.left), root.key, toString(root.right));
-    }
-  }
-
-  private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
-    ArrayList<T> actualList = new ArrayList<T>();
-    for (T t : actual) {
-      actualList.add(t);
-    }
-    assertEquals(Arrays.asList(expected), actualList);
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
deleted file mode 100644
index 9e1807899..000000000
--- a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2016 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal;
-
-import junit.framework.TestCase;
-
-/**
- * Test unsafe allocator instantiation
- * @author Ugljesa Jovanovic
- */
-public final class UnsafeAllocatorInstantiationTest extends TestCase {
-
-  public interface Interface {
-  }
-
-  public static abstract class AbstractClass {
-  }
-
-  public static class ConcreteClass {
-  }
-
-  /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
-   * to instantiate an interface
-   */
-  public void testInterfaceInstantiation() {
-    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
-    try {
-      unsafeAllocator.newInstance(Interface.class);
-      fail();
-    } catch (Exception e) {
-      assertEquals(e.getClass(), UnsupportedOperationException.class);
-    }
-  }
-
-  /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
-   * to instantiate an abstract class
-   */
-  public void testAbstractClassInstantiation() {
-    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
-    try {
-      unsafeAllocator.newInstance(AbstractClass.class);
-      fail();
-    } catch (Exception e) {
-      assertEquals(e.getClass(), UnsupportedOperationException.class);
-    }
-  }
-
-  /**
-   * Ensure that no exception is thrown when trying to instantiate a concrete class
-   */
-  public void testConcreteClassInstantiation() {
-    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
-    try {
-      unsafeAllocator.newInstance(ConcreteClass.class);
-    } catch (Exception e) {
-      fail();
-    }
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java b/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
deleted file mode 100644
index d5caaf537..000000000
--- a/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2018 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.internal.reflect;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.lang.reflect.Field;
-
-import org.junit.Test;
-
-/**
- * Unit tests for {@link UnsafeReflectionAccessor}
- *
- * @author Inderjeet Singh
- */
-public class UnsafeReflectionAccessorTest {
-
-  @Test
-  public void testMakeAccessibleWithUnsafe() throws Exception {
-    UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
-    Field field = ClassWithPrivateFinalFields.class.getDeclaredField("a");
-    try {
-      boolean success = accessor.makeAccessibleWithUnsafe(field);
-      assertTrue(success);
-    } catch (Exception e) {
-      fail("Unsafe didn't work on the JDK");
-    }
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ClassWithPrivateFinalFields {
-    private final String a;
-    public ClassWithPrivateFinalFields(String a) {
-      this.a = a;
-    }
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
index 40572716b..77a547f79 100644
--- a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
@@ -37,50 +37,6 @@
   List<Set<String>> listOfSetOfString = null;
   List<Set<?>> listOfSetOfUnknown = null;
 
-  public void testIsAssignableFromRawTypes() {
-    assertTrue(TypeToken.get(Object.class).isAssignableFrom(String.class));
-    assertFalse(TypeToken.get(String.class).isAssignableFrom(Object.class));
-    assertTrue(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class));
-    assertFalse(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class));
-  }
-
-  public void testIsAssignableFromWithTypeParameters() throws Exception {
-    Type a = getClass().getDeclaredField("listOfInteger").getGenericType();
-    Type b = getClass().getDeclaredField("listOfNumber").getGenericType();
-    assertTrue(TypeToken.get(a).isAssignableFrom(a));
-    assertTrue(TypeToken.get(b).isAssignableFrom(b));
-
-    // listOfInteger = listOfNumber; // doesn't compile; must be false
-    assertFalse(TypeToken.get(a).isAssignableFrom(b));
-    // listOfNumber = listOfInteger; // doesn't compile; must be false
-    assertFalse(TypeToken.get(b).isAssignableFrom(a));
-  }
-
-  public void testIsAssignableFromWithBasicWildcards() throws Exception {
-    Type a = getClass().getDeclaredField("listOfString").getGenericType();
-    Type b = getClass().getDeclaredField("listOfUnknown").getGenericType();
-    assertTrue(TypeToken.get(a).isAssignableFrom(a));
-    assertTrue(TypeToken.get(b).isAssignableFrom(b));
-
-    // listOfString = listOfUnknown  // doesn't compile; must be false
-    assertFalse(TypeToken.get(a).isAssignableFrom(b));
-    listOfUnknown = listOfString; // compiles; must be true
-    // The following assertion is too difficult to support reliably, so disabling
-    // assertTrue(TypeToken.get(b).isAssignableFrom(a));
-  }
-
-  public void testIsAssignableFromWithNestedWildcards() throws Exception {
-    Type a = getClass().getDeclaredField("listOfSetOfString").getGenericType();
-    Type b = getClass().getDeclaredField("listOfSetOfUnknown").getGenericType();
-    assertTrue(TypeToken.get(a).isAssignableFrom(a));
-    assertTrue(TypeToken.get(b).isAssignableFrom(b));
-
-    // listOfSetOfString = listOfSetOfUnknown; // doesn't compile; must be false
-    assertFalse(TypeToken.get(a).isAssignableFrom(b));
-    // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false
-    assertFalse(TypeToken.get(b).isAssignableFrom(a));
-  }
-
   public void testArrayFactory() {
     TypeToken<?> expectedStringArray = new TypeToken<String[]>() {};
     assertEquals(expectedStringArray, TypeToken.getArray(String.class));
