diff --git a/.gitignore b/.gitignore
index 5bda0b93e..4bf981dbe 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,8 @@
 .project
 .settings
 eclipsebin
+bin
+gson/testBin
 target
 */target
 pom.xml.*
diff --git a/codegen/pom.xml b/codegen/pom.xml
deleted file mode 100644
index c2f9499a3..000000000
--- a/codegen/pom.xml
+++ /dev/null
@@ -1,182 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-codegen</artifactId>
-  <packaging>jar</packaging>
-  <version>1.0-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson Code Gen</name>
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-  <url>http://code.google.com/p/google-gson/</url>
-  <description>Google Gson grab bag of utilities, type adapters, etc.</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:svn:http://google-gson.googlecode.com/svn/trunk/extras</connection>
-    <developerConnection>scm:svn:https://google-gson.googlecode.com/svn/trunk/extras</developerConnection>
-    <url>http://google-gson.codegoogle.com/svn/trunk/extras</url>
-  </scm>
-  <issueManagement>
-    <system>Google Code Issue Tracking</system>
-    <url>http://code.google.com/p/google-gson/issues/list</url>
-  </issueManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.2</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.4</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>  
-  <build>
-    <defaultGoal>package</defaultGoal>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5.1</version>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.4</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-          </archive>
-        </configuration>
-      </plugin>
-      <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>2.1.2</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.8.1</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <links>
-             <link>http://download.oracle.com/javase/1.5.0/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>public</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.9</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <!--  version>2.3.2</version -->
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-          <tagBase>https://google-gson.googlecode.com/svn/tags/</tagBase>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-      <organization>Trymph Inc.</organization>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
-</project>
diff --git a/codegen/src/main/java/com/google/gson/codegen/CodeGen.java b/codegen/src/main/java/com/google/gson/codegen/CodeGen.java
deleted file mode 100644
index 011568ff9..000000000
--- a/codegen/src/main/java/com/google/gson/codegen/CodeGen.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.codegen;
-
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-
-public class CodeGen {
-  private CodeGen() {
-  }
-
-  public static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns a fully qualified class name to complement {@code type}.
-   */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
-  }
-
-  static void rawTypeToString(StringBuilder result, TypeElement type, char innerClassSeparator) {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String qualifiedName = type.getQualifiedName().toString();
-    result.append(packageName);
-    result.append('.');
-    result.append(
-        qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
-  }
-}
diff --git a/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapter.java b/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapter.java
deleted file mode 100644
index 1694d88ac..000000000
--- a/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapter.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.codegen;
-
-public @interface GeneratedTypeAdapter {
-  Class<?>[] value() default {};
-}
diff --git a/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapterProcessor.java b/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapterProcessor.java
deleted file mode 100644
index cd542bc35..000000000
--- a/codegen/src/main/java/com/google/gson/codegen/GeneratedTypeAdapterProcessor.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.codegen;
-
-import static java.lang.reflect.Modifier.FINAL;
-
-import java.io.IOException;
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-@SupportedAnnotationTypes("com.google.gson.codegen.GeneratedTypeAdapter")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
-public final class GeneratedTypeAdapterProcessor extends AbstractProcessor {
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    System.out.println("invoked GeneratedTypeAdapterProcessor");
-    try {
-      for (Element element : env.getElementsAnnotatedWith(GeneratedTypeAdapter.class)) {
-        writeAdapter((TypeElement) element);
-      }
-    } catch (IOException e) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
-    }
-    return true;
-  }
-
-  private void writeAdapter(TypeElement type) throws IOException {
-    String typeAdapterName = CodeGen.adapterName(type, "$TypeAdapter");
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(typeAdapterName, type);
-    System.out.println("Generating type adapter: " + typeAdapterName + " in " + sourceFile.getName());
-
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-    writer.beginType(typeAdapterName, "class", FINAL, null);
-    writer.endType();
-    writer.close();
-  }
-}
diff --git a/codegen/src/main/java/com/google/gson/codegen/JavaWriter.java b/codegen/src/main/java/com/google/gson/codegen/JavaWriter.java
deleted file mode 100644
index ccba6c8cd..000000000
--- a/codegen/src/main/java/com/google/gson/codegen/JavaWriter.java
+++ /dev/null
@@ -1,443 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.codegen;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Emits Java source files.
- */
-public final class JavaWriter {
-  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w$]+)");
-  private static final String INDENT = "  ";
-
-  /** Map fully qualified type names to their short names. */
-  private final Map<String, String> importedTypes = new HashMap<String, String>();
-
-  private String packagePrefix;
-  private final List<Scope> scopes = new ArrayList<Scope>();
-  private final Writer out;
-
-  /**
-   * @param out the stream to which Java source will be written. This should be
-   *     a buffered stream.
-   */
-  public JavaWriter(Writer out) {
-    this.out = out;
-  }
-
-  /**
-   * Emit a package declaration.
-   */
-  public void addPackage(String packageName) throws IOException {
-    if (this.packagePrefix != null) {
-      throw new IllegalStateException();
-    }
-    out.write("package ");
-    out.write(packageName);
-    out.write(";\n");
-    this.packagePrefix = packageName + ".";
-  }
-
-  /**
-   * Equivalent to {@code addImport(type.getName())}.
-   */
-  public void addImport(Class<?> type) throws IOException {
-    addImport(type.getName());
-  }
-
-  /**
-   * Emit an import for {@code type}. For the duration of the file, all
-   * references to this class will be automatically shortened.
-   */
-  public void addImport(String type) throws IOException {
-    Matcher matcher = TYPE_PATTERN.matcher(type);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(type);
-    }
-    if (importedTypes.put(type, matcher.group(1)) != null) {
-      throw new IllegalArgumentException(type);
-    }
-    out.write("import ");
-    out.write(type);
-    out.write(";\n");
-  }
-
-  /**
-   * Emits a name like {@code java.lang.String} or {@code
-   * java.util.List<java.lang.String>}, shorting it with imports if
-   * possible.
-   */
-  private void type(String type) throws IOException {
-    if (this.packagePrefix == null) {
-      throw new IllegalStateException();
-    }
-
-    Matcher m = TYPE_PATTERN.matcher(type);
-    int pos = 0;
-    while (true) {
-      boolean found = m.find(pos);
-
-      // copy non-matching characters like "<"
-      int typeStart = found ? m.start() : type.length();
-      out.write(type, pos, typeStart - pos);
-
-      if (!found) {
-        break;
-      }
-
-      // copy a single class name, shortening it if possible
-      String name = m.group(0);
-      String imported;
-      if ((imported = importedTypes.get(name)) != null) {
-        out.write(imported);
-      } else if (name.startsWith(packagePrefix)
-          && name.indexOf('.', packagePrefix.length()) == -1) {
-        out.write(name.substring(packagePrefix.length()));
-      } else if (name.startsWith("java.lang.")) {
-        out.write(name.substring("java.lang.".length()));
-      } else {
-        out.write(name);
-      }
-      pos = m.end();
-    }
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   */
-  public void beginType(String type, String kind, int modifiers) throws IOException {
-    beginType(type, kind, modifiers, null);
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   * @param extendsType the class to extend, or null for no extends clause.
-   */
-  public void beginType(String type, String kind, int modifiers,
-      String extendsType, String... implementsTypes) throws IOException {
-    indent();
-    modifiers(modifiers);
-    out.write(kind);
-    out.write(" ");
-    type(type);
-    if (extendsType != null) {
-      out.write("\n");
-      indent();
-      out.write("    extends ");
-      type(extendsType);
-    }
-    if (implementsTypes.length > 0) {
-      out.write("\n");
-      indent();
-      out.write("    implements ");
-      for (int i = 0; i < implementsTypes.length; i++) {
-        if (i != 0) {
-          out.write(", ");
-        }
-        type(implementsTypes[i]);
-      }
-    }
-    out.write(" {\n");
-    pushScope(Scope.TYPE_DECLARATION);
-  }
-
-  /**
-   * Completes the current type declaration.
-   */
-  public void endType() throws IOException {
-    if (popScope() != Scope.TYPE_DECLARATION) {
-      throw new IllegalStateException();
-    }
-    indent();
-    out.write("}\n");
-  }
-
-  /**
-   * Emits a field declaration.
-   */
-  public void field(String type, String name, int modifiers) throws IOException {
-    field(type, name, modifiers, null);
-  }
-
-  public void field(String type, String name, int modifiers, String initialValue)
-      throws IOException {
-    indent();
-    modifiers(modifiers);
-    type(type);
-    out.write(" ");
-    out.write(name);
-
-    if (initialValue != null) {
-      out.write(" = ");
-      out.write(initialValue);
-    }
-    out.write(";\n");
-  }
-
-  /**
-   * Emit a method declaration.
-   *
-   * @param returnType the method's return type, or null for constructors.
-   * @param parameters alternating parameter types and names.
-   * @param name the method name, or the fully qualified class name for
-   *     constructors.
-   */
-  public void beginMethod(String returnType, String name, int modifiers, String... parameters)
-      throws IOException {
-    indent();
-    modifiers(modifiers);
-    if (returnType != null) {
-      type(returnType);
-      out.write(" ");
-      out.write(name);
-    } else {
-      type(name);
-    }
-    out.write("(");
-    for (int p = 0; p < parameters.length; ) {
-      if (p != 0) {
-        out.write(", ");
-      }
-      type(parameters[p++]);
-      out.write(" ");
-      type(parameters[p++]);
-    }
-    out.write(")");
-    if ((modifiers & Modifier.ABSTRACT) != 0) {
-      out.write(";\n");
-      pushScope(Scope.ABSTRACT_METHOD);
-    } else {
-      out.write(" {\n");
-      pushScope(Scope.NON_ABSTRACT_METHOD);
-    }
-  }
-
-  /**
-   * Annotates the next element with {@code annotation}. The annotation has no
-   * attributes.
-   */
-  public void annotation(String annotation) throws IOException {
-    indent();
-    out.write("@");
-    type(annotation);
-    out.write("\n");
-  }
-
-  /**
-   * Equivalent to {@code annotation(annotationType.getName())}.
-   */
-  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
-    annotation(annotationType.getName());
-  }
-
-  /**
-   * @param pattern a code pattern like "int i = %s". Shouldn't contain a
-   * trailing semicolon or newline character.
-   */
-  public void statement(String pattern, Object... args) throws IOException {
-    checkInMethod();
-    indent();
-    out.write(String.format(pattern, args));
-    out.write(";\n");
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as
-   *     "if (foo == 5)". Shouldn't contain braces or newline characters.
-   */
-  public void beginControlFlow(String controlFlow) throws IOException {
-    checkInMethod();
-    indent();
-    out.write(controlFlow);
-    out.write(" {\n");
-    pushScope(Scope.CONTROL_FLOW);
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as
-   *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
-   */
-  public void nextControlFlow(String controlFlow) throws IOException {
-    if (popScope() != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-
-    indent();
-    pushScope(Scope.CONTROL_FLOW);
-    out.write("} ");
-    out.write(controlFlow);
-    out.write(" {\n");
-  }
-
-  public void endControlFlow() throws IOException {
-    endControlFlow(null);
-  }
-
-  /**
-   * @param controlFlow the optional control flow construct and its code, such
-   *     as "while(foo == 20)". Only used for "do/while" control flows.
-   */
-  public void endControlFlow(String controlFlow) throws IOException {
-    if (popScope() != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-
-    indent();
-    if (controlFlow != null) {
-      out.write("} ");
-      out.write(controlFlow);
-      out.write(";\n");
-    } else {
-      out.write("}\n");
-    }
-  }
-
-  /**
-   * Completes the current method declaration.
-   */
-  public void endMethod() throws IOException {
-    Scope popped = popScope();
-    if (popped == Scope.NON_ABSTRACT_METHOD) {
-      indent();
-      out.write("}\n");
-    } else if (popped != Scope.ABSTRACT_METHOD) {
-      throw new IllegalStateException();
-    }
-  }
-
-  /**
-   * Returns the string literal representing {@code data}, including wrapping
-   * quotes.
-   */
-  public static String stringLiteral(String data) {
-    StringBuilder result = new StringBuilder();
-    result.append('"');
-    for (int i = 0; i < data.length(); i++) {
-      char c = data.charAt(i);
-      switch (c) {
-        case '"':
-          result.append("\\\"");
-          break;
-        case '\\':
-          result.append("\\\\");
-          break;
-        case '\t':
-          result.append("\\\t");
-          break;
-        case '\b':
-          result.append("\\\b");
-          break;
-        case '\n':
-          result.append("\\\n");
-          break;
-        case '\r':
-          result.append("\\\r");
-          break;
-        case '\f':
-          result.append("\\\f");
-          break;
-        default:
-          result.append(c);
-      }
-    }
-    result.append('"');
-    return result.toString();
-  }
-
-  public void close() throws IOException {
-    out.close();
-  }
-
-  /**
-   * Emit modifier names.
-   */
-  private void modifiers(int modifiers) throws IOException {
-    if ((modifiers & Modifier.PUBLIC) != 0) {
-      out.write("public ");
-    }
-    if ((modifiers & Modifier.PRIVATE) != 0) {
-      out.write("private ");
-    }
-    if ((modifiers & Modifier.PROTECTED) != 0) {
-      out.write("protected ");
-    }
-    if ((modifiers & Modifier.STATIC) != 0) {
-      out.write("static ");
-    }
-    if ((modifiers & Modifier.FINAL) != 0) {
-      out.write("final ");
-    }
-    if ((modifiers & Modifier.ABSTRACT) != 0) {
-      out.write("abstract ");
-    }
-    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
-      out.write("synchronized ");
-    }
-    if ((modifiers & Modifier.TRANSIENT) != 0) {
-      out.write("transient ");
-    }
-    if ((modifiers & Modifier.VOLATILE) != 0) {
-      out.write("volatile ");
-    }
-  }
-
-  private void indent() throws IOException {
-    for (int i = 0; i < scopes.size(); i++) {
-      out.write(INDENT);
-    }
-  }
-
-  private void checkInMethod() {
-    Scope scope = peekScope();
-    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private void pushScope(Scope pushed) {
-    scopes.add(pushed);
-  }
-
-  private Scope peekScope() {
-    return scopes.get(scopes.size() - 1);
-  }
-
-  private Scope popScope() {
-    return scopes.remove(scopes.size() - 1);
-  }
-
-  private enum Scope {
-    TYPE_DECLARATION,
-    ABSTRACT_METHOD,
-    NON_ABSTRACT_METHOD,
-    CONTROL_FLOW,
-  }
-}
diff --git a/codegen/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/codegen/src/main/resources/META-INF/services/javax.annotation.processing.Processor
deleted file mode 100644
index a052da0c1..000000000
--- a/codegen/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ /dev/null
@@ -1 +0,0 @@
-com.google.gson.codegen.GeneratedTypeAdapterProcessor
\ No newline at end of file
diff --git a/codegen/src/test/java/com/google/gson/codegen/functional/Order.java b/codegen/src/test/java/com/google/gson/codegen/functional/Order.java
deleted file mode 100644
index 916587f3b..000000000
--- a/codegen/src/test/java/com/google/gson/codegen/functional/Order.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.codegen.functional;
-
-import com.google.gson.codegen.GeneratedTypeAdapter;
-
-@GeneratedTypeAdapter
-final class Order {
-  private final String itemName;
-  private final int price;
-
-  public Order(String itemName, int price) {
-    this.itemName = itemName;
-    this.price = price;
-  }
-
-  public String getItemName() {
-    return itemName;
-  }
-
-  public int getAmount() {
-    return price;
-  }
-}
diff --git a/examples/android-proguard-example/AndroidManifest.xml b/examples/android-proguard-example/AndroidManifest.xml
deleted file mode 100644
index 7e9b1d8b0..000000000
--- a/examples/android-proguard-example/AndroidManifest.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-  package="com.google.gson.examples.android"
-  android:versionCode="1"
-  android:versionName="1.0">
-  <uses-sdk android:minSdkVersion="3"/>
-  <application android:icon="@drawable/icon" android:label="@string/app_name">
-    <activity android:name=".GsonProguardExampleActivity" 
-              android:label="@string/app_name" 
-              android:exported="true" 
-              android:icon="@drawable/icon"
-              android:configChanges="keyboardHidden|orientation" 
-              android:enabled="true">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.LAUNCHER" />
-      </intent-filter>
-    </activity>
-  </application>
-  <uses-permission android:name="android.permission.INTERNET" />
-</manifest> 
diff --git a/examples/android-proguard-example/default.properties b/examples/android-proguard-example/default.properties
deleted file mode 100644
index 7d4fed0b2..000000000
--- a/examples/android-proguard-example/default.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "build.properties", and override values to adapt the script to your
-# project structure.
-
-# Project target.
-target=android-3
-proguard.config=proguard.cfg
\ No newline at end of file
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
deleted file mode 100644
index 6c5709f3d..000000000
--- a/examples/android-proguard-example/proguard.cfg
+++ /dev/null
@@ -1,22 +0,0 @@
-##---------------Begin: proguard configuration for Gson  ----------
-# Gson uses generic type information stored in a class file when working with fields. Proguard
-# removes such information by default, so configure it to keep all of it.
--keepattributes Signature
-
-# For using GSON @Expose annotation
--keepattributes *Annotation*
-
-# Gson specific classes
--dontwarn sun.misc.**
-#-keep class com.google.gson.stream.** { *; }
-
-# Application classes that will be serialized/deserialized over Gson
--keep class com.google.gson.examples.android.model.** { *; }
-
-# Prevent proguard from stripping interface information from TypeAdapterFactory,
-# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
--keep class * implements com.google.gson.TypeAdapterFactory
--keep class * implements com.google.gson.JsonSerializer
--keep class * implements com.google.gson.JsonDeserializer
-
-##---------------End: proguard configuration for Gson  ----------
diff --git a/examples/android-proguard-example/res/drawable/icon.png b/examples/android-proguard-example/res/drawable/icon.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/examples/android-proguard-example/res/drawable/icon.png and /dev/null differ
diff --git a/examples/android-proguard-example/res/layout/main.xml b/examples/android-proguard-example/res/layout/main.xml
deleted file mode 100644
index 0ac46e684..000000000
--- a/examples/android-proguard-example/res/layout/main.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout
-  xmlns:android="http://schemas.android.com/apk/res/android" 
-  android:orientation="vertical"
-  android:layout_width="fill_parent"
-  android:layout_height="fill_parent">
-  
-  <TextView android:id="@+id/tv"
-    android:layout_width="fill_parent"
-    android:layout_height="wrap_content" />
-</LinearLayout>
\ No newline at end of file
diff --git a/examples/android-proguard-example/res/values/strings.xml b/examples/android-proguard-example/res/values/strings.xml
deleted file mode 100644
index ba3be81e8..000000000
--- a/examples/android-proguard-example/res/values/strings.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="app_name">Gson Proguard Example</string>
-</resources>
-
diff --git a/examples/android-proguard-example/src/com/google/gson/examples/android/GsonProguardExampleActivity.java b/examples/android-proguard-example/src/com/google/gson/examples/android/GsonProguardExampleActivity.java
deleted file mode 100644
index bd5443114..000000000
--- a/examples/android-proguard-example/src/com/google/gson/examples/android/GsonProguardExampleActivity.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.examples.android;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.widget.TextView;
-
-import com.google.gson.Gson;
-import com.google.gson.examples.android.model.Cart;
-import com.google.gson.examples.android.model.LineItem;
-
-/**
- * Activity class illustrating how to use proguard with Gson
- *
- * @author Inderjeet Singh
- */
-public class GsonProguardExampleActivity extends Activity {
-  @Override
-  public void onCreate(Bundle icicle) {
-    super.onCreate(icicle);
-    setContentView(R.layout.main);
-    TextView tv = (TextView) findViewById(R.id.tv);
-    Gson gson = new Gson();
-    Cart cart = buildCart();
-    StringBuilder sb = new StringBuilder();
-    sb.append("Gson.toJson() example: \n");
-    sb.append("  Cart Object: ").append(cart).append("\n");
-    sb.append("  Cart JSON: ").append(gson.toJson(cart)).append("\n");
-    sb.append("\n\nGson.fromJson() example: \n");
-    String json = "{buyer:'Happy Camper',creditCard:'4111-1111-1111-1111',"
-      + "lineItems:[{name:'nails',priceInMicros:100000,quantity:100,currencyCode:'USD'}]}";
-    sb.append("Cart JSON: ").append(json).append("\n");
-    sb.append("Cart Object: ").append(gson.fromJson(json, Cart.class)).append("\n");
-    tv.setText(sb.toString());
-    tv.invalidate();
-  }
-
-  private Cart buildCart() {
-    List<LineItem> lineItems = new ArrayList<LineItem>();
-    lineItems.add(new LineItem("hammer", 1, 12000000, "USD"));
-    return new Cart(lineItems, "Happy Buyer", "4111-1111-1111-1111");
-  }
-}
diff --git a/examples/android-proguard-example/src/com/google/gson/examples/android/model/Cart.java b/examples/android-proguard-example/src/com/google/gson/examples/android/model/Cart.java
deleted file mode 100644
index 7582036eb..000000000
--- a/examples/android-proguard-example/src/com/google/gson/examples/android/model/Cart.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.examples.android.model;
-
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.WildcardType;
-import java.util.List;
-
-import com.google.gson.annotations.SerializedName;
-
-/**
- * A model object representing a cart that can be posted to an order-processing server
- * 
- * @author Inderjeet Singh
- */
-public class Cart {
-  public final List<LineItem> lineItems;
-
-  @SerializedName("buyer")
-  private final String buyerName;
-
-  private final String creditCard;
-
-  public Cart(List<LineItem> lineItems, String buyerName, String creditCard) {
-    this.lineItems = lineItems;
-    this.buyerName = buyerName;
-    this.creditCard = creditCard;
-  }
-
-  public List<LineItem> getLineItems() {
-    return lineItems;
-  }
-
-  public String getBuyerName() {
-    return buyerName;
-  }
-
-  public String getCreditCard() {
-    return creditCard;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder itemsText = new StringBuilder();
-    boolean first = true;
-    if (lineItems != null) {
-      try {
-        Class<?> fieldType = Cart.class.getField("lineItems").getType();
-        System.out.println("LineItems CLASS: " + getSimpleTypeName(fieldType));
-      } catch (SecurityException e) {
-      } catch (NoSuchFieldException e) {
-      }
-      for (LineItem item : lineItems) {
-        if (first) {
-          first = false;
-        } else {
-          itemsText.append("; ");
-        }
-        itemsText.append(item);
-      }
-    }
-    return "[BUYER: " + buyerName + "; CC: " + creditCard + "; "
-    + "LINE_ITEMS: " + itemsText.toString() + "]";
-  }
-
-  @SuppressWarnings("unchecked")
-  public static String getSimpleTypeName(Type type) {
-    if (type == null) {
-      return "null";
-    }
-    if (type instanceof Class) {
-      return ((Class)type).getSimpleName();
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType pType = (ParameterizedType) type;
-      StringBuilder sb = new StringBuilder(getSimpleTypeName(pType.getRawType()));
-      sb.append('<');
-      boolean first = true;
-      for (Type argumentType : pType.getActualTypeArguments()) {
-        if (first) {
-          first = false;
-        } else {
-          sb.append(',');
-        }
-        sb.append(getSimpleTypeName(argumentType));
-      }
-      sb.append('>');
-      return sb.toString();
-    } else if (type instanceof WildcardType) {
-      return "?";
-    }
-    return type.toString();
-  }
-
-}
diff --git a/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java b/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
deleted file mode 100644
index 1273ec971..000000000
--- a/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.examples.android.model;
-
-/**
- * A line item in a cart. This is not a rest resource, just a dependent object
- *
- * @author Inderjeet Singh
- */
-public class LineItem {
-  private final String name;
-  private final int quantity;
-  private final long priceInMicros;
-  private final String currencyCode;
-
-  public LineItem(String name, int quantity, long priceInMicros, String currencyCode) {
-    this.name = name;
-    this.quantity = quantity;
-    this.priceInMicros = priceInMicros;
-    this.currencyCode = currencyCode;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public int getQuantity() {
-    return quantity;
-  }
-
-  public long getPriceInMicros() {
-    return priceInMicros;
-  }
-
-  public String getCurrencyCode() {
-    return currencyCode;
-  }
-
-  @Override
-  public String toString() {
-    return String.format("(item: %s, qty: %s, price: %.2f %s)",
-        name, quantity, priceInMicros / 1000000d, currencyCode);
-  }
-}
diff --git a/extras/pom.xml b/extras/pom.xml
deleted file mode 100644
index 1c5e76c39..000000000
--- a/extras/pom.xml
+++ /dev/null
@@ -1,191 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-extras</artifactId>
-  <packaging>jar</packaging>
-  <version>1.0-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson Extras</name>
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-  </parent>
-  <url>http://code.google.com/p/google-gson/</url>
-  <description>Google Gson grab bag of utilities, type adapters, etc.</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:svn:http://google-gson.googlecode.com/svn/trunk/extras</connection>
-    <developerConnection>scm:svn:https://google-gson.googlecode.com/svn/trunk/extras</developerConnection>
-    <url>http://google-gson.codegoogle.com/svn/trunk/extras</url>
-  </scm>
-  <issueManagement>
-    <system>Google Code Issue Tracking</system>
-    <url>http://code.google.com/p/google-gson/issues/list</url>
-  </issueManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <version>2.7</version>
-      <scope>compile</scope>
-    </dependency>
-    <dependency>
-      <groupId>javax.annotation</groupId>
-      <artifactId>jsr250-api</artifactId>
-      <version>1.0</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.2</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.5</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>  
-  <build>
-    <defaultGoal>package</defaultGoal>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.5.1</version>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-          </archive>
-        </configuration>
-      </plugin>
-      <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>3.0.1</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.4</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <links>
-             <link>http://download.oracle.com/javase/1.5.0/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>public</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.10</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <!--  version>2.3.2</version -->
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-          <tagBase>https://google-gson.googlecode.com/svn/tags/</tagBase>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
-</project>
diff --git a/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java b/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
deleted file mode 100644
index bd7c2d24d..000000000
--- a/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.extras.examples.rawcollections;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonParser;
-
-public class RawCollectionsExample {
-  static class Event {
-    private String name;
-    private String source;
-    private Event(String name, String source) {
-      this.name = name;
-      this.source = source;
-    }
-    @Override
-    public String toString() {
-      return String.format("(name=%s, source=%s)", name, source);
-    }
-  }
-
-  @SuppressWarnings({ "unchecked", "rawtypes" })
-  public static void main(String[] args) {
-    Gson gson = new Gson();
-    Collection collection = new ArrayList();
-    collection.add("hello");
-    collection.add(5);
-    collection.add(new Event("GREETINGS", "guest"));
-    String json = gson.toJson(collection);
-    System.out.println("Using Gson.toJson() on a raw collection: " + json);
-    JsonParser parser = new JsonParser();
-    JsonArray array = parser.parse(json).getAsJsonArray();
-    String message = gson.fromJson(array.get(0), String.class);
-    int number = gson.fromJson(array.get(1), int.class);
-    Event event = gson.fromJson(array.get(2), Event.class);
-    System.out.printf("Using Gson.fromJson() to get: %s, %d, %s", message, number, event);
-  }
-}
diff --git a/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java b/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
deleted file mode 100644
index cd8ea00f4..000000000
--- a/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.graph;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonElement;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Queue;
-
-/**
- * Writes a graph of objects as a list of named nodes.
- */
-// TODO: proper documentation
-@SuppressWarnings("rawtypes")
-public final class GraphAdapterBuilder {
-  private final Map<Type, InstanceCreator<?>> instanceCreators;
-  private final ConstructorConstructor constructorConstructor;
-
-  public GraphAdapterBuilder() {
-      this.instanceCreators = new HashMap<Type, InstanceCreator<?>>();
-      this.constructorConstructor = new ConstructorConstructor(instanceCreators);
-  }
-  public GraphAdapterBuilder addType(Type type) {
-    final ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));
-    InstanceCreator<Object> instanceCreator = new InstanceCreator<Object>() {
-      public Object createInstance(Type type) {
-        return objectConstructor.construct();
-      }
-    };
-    return addType(type, instanceCreator);
-  }
-
-  public GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator) {
-    if (type == null || instanceCreator == null) {
-      throw new NullPointerException();
-    }
-    instanceCreators.put(type, instanceCreator);
-    return this;
-  }
-
-  public void registerOn(GsonBuilder gsonBuilder) {
-    Factory factory = new Factory(instanceCreators);
-    gsonBuilder.registerTypeAdapterFactory(factory);
-    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {
-      gsonBuilder.registerTypeAdapter(entry.getKey(), factory);
-    }
-  }
-
-  static class Factory implements TypeAdapterFactory, InstanceCreator {
-    private final Map<Type, InstanceCreator<?>> instanceCreators;
-    private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<Graph>();
-
-    Factory(Map<Type, InstanceCreator<?>> instanceCreators) {
-      this.instanceCreators = instanceCreators;
-    }
-
-    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-      if (!instanceCreators.containsKey(type.getType())) {
-        return null;
-      }
-
-      final TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);
-      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
-      return new TypeAdapter<T>() {
-        @Override public void write(JsonWriter out, T value) throws IOException {
-          if (value == null) {
-            out.nullValue();
-            return;
-          }
-
-          Graph graph = graphThreadLocal.get();
-          boolean writeEntireGraph = false;
-
-          /*
-           * We have one of two cases:
-           *  1. We've encountered the first known object in this graph. Write
-           *     out the graph, starting with that object.
-           *  2. We've encountered another graph object in the course of #1.
-           *     Just write out this object's name. We'll circle back to writing
-           *     out the object's value as a part of #1.
-           */
-
-          if (graph == null) {
-            writeEntireGraph = true;
-            graph = new Graph(new IdentityHashMap<Object, Element<?>>());
-          }
-
-          @SuppressWarnings("unchecked") // graph.map guarantees consistency between value and T
-          Element<T> element = (Element<T>) graph.map.get(value);
-          if (element == null) {
-            element = new Element<T>(value, graph.nextName(), typeAdapter, null);
-            graph.map.put(value, element);
-            graph.queue.add(element);
-          }
-
-          if (writeEntireGraph) {
-            graphThreadLocal.set(graph);
-            try {
-              out.beginObject();
-              Element<?> current;
-              while ((current = graph.queue.poll()) != null) {
-                out.name(current.id);
-                current.write(out);
-              }
-              out.endObject();
-            } finally {
-              graphThreadLocal.remove();
-            }
-          } else {
-            out.value(element.id);
-          }
-        }
-
-        @Override public T read(JsonReader in) throws IOException {
-          if (in.peek() == JsonToken.NULL) {
-            in.nextNull();
-            return null;
-          }
-
-          /*
-           * Again we have one of two cases:
-           *  1. We've encountered the first known object in this graph. Read
-           *     the entire graph in as a map from names to their JsonElements.
-           *     Then convert the first JsonElement to its Java object.
-           *  2. We've encountered another graph object in the course of #1.
-           *     Read in its name, then deserialize its value from the
-           *     JsonElement in our map. We need to do this lazily because we
-           *     don't know which TypeAdapter to use until a value is
-           *     encountered in the wild.
-           */
-
-          String currentName = null;
-          Graph graph = graphThreadLocal.get();
-          boolean readEntireGraph = false;
-
-          if (graph == null) {
-            graph = new Graph(new HashMap<Object, Element<?>>());
-            readEntireGraph = true;
-
-            // read the entire tree into memory
-            in.beginObject();
-            while (in.hasNext()) {
-              String name = in.nextName();
-              if (currentName == null) {
-                currentName = name;
-              }
-              JsonElement element = elementAdapter.read(in);
-              graph.map.put(name, new Element<T>(null, name, typeAdapter, element));
-            }
-            in.endObject();
-          } else {
-            currentName = in.nextString();
-          }
-
-          if (readEntireGraph) {
-            graphThreadLocal.set(graph);
-          }
-          try {
-            @SuppressWarnings("unchecked") // graph.map guarantees consistency between value and T
-            Element<T> element = (Element<T>) graph.map.get(currentName);
-            // now that we know the typeAdapter for this name, go from JsonElement to 'T'
-            if (element.value == null) {
-              element.typeAdapter = typeAdapter;
-              element.read(graph);
-            }
-            return element.value;
-          } finally {
-            if (readEntireGraph) {
-              graphThreadLocal.remove();
-            }
-          }
-        }
-      };
-    }
-
-    /**
-     * Hook for the graph adapter to get a reference to a deserialized value
-     * before that value is fully populated. This is useful to deserialize
-     * values that directly or indirectly reference themselves: we can hand
-     * out an instance before read() returns.
-     *
-     * <p>Gson should only ever call this method when we're expecting it to;
-     * that is only when we've called back into Gson to deserialize a tree.
-     */
-    @SuppressWarnings("unchecked")
-    public Object createInstance(Type type) {
-      Graph graph = graphThreadLocal.get();
-      if (graph == null || graph.nextCreate == null) {
-        throw new IllegalStateException("Unexpected call to createInstance() for " + type);
-      }
-      InstanceCreator<?> creator = instanceCreators.get(type);
-      Object result = creator.createInstance(type);
-      graph.nextCreate.value = result;
-      graph.nextCreate = null;
-      return result;
-    }
-  }
-
-  static class Graph {
-    /**
-     * The graph elements. On serialization keys are objects (using an identity
-     * hash map) and on deserialization keys are the string names (using a
-     * standard hash map).
-     */
-    private final Map<Object, Element<?>> map;
-
-    /**
-     * The queue of elements to write during serialization. Unused during
-     * deserialization.
-     */
-    private final Queue<Element> queue = new LinkedList<Element>();
-
-    /**
-     * The instance currently being deserialized. Used as a backdoor between
-     * the graph traversal (which needs to know instances) and instance creators
-     * which create them.
-     */
-    private Element nextCreate;
-
-    private Graph(Map<Object, Element<?>> map) {
-      this.map = map;
-    }
-
-    /**
-     * Returns a unique name for an element to be inserted into the graph.
-     */
-    public String nextName() {
-      return "0x" + Integer.toHexString(map.size() + 1);
-    }
-  }
-
-  /**
-   * An element of the graph during serialization or deserialization.
-   */
-  static class Element<T> {
-    /**
-     * This element's name in the top level graph object.
-     */
-    private final String id;
-
-    /**
-     * The value if known. During deserialization this is lazily populated.
-     */
-    private T value;
-
-    /**
-     * This element's type adapter if known. During deserialization this is
-     * lazily populated.
-     */
-    private TypeAdapter<T> typeAdapter;
-
-    /**
-     * The element to deserialize. Unused in serialization.
-     */
-    private final JsonElement element;
-
-    Element(T value, String id, TypeAdapter<T> typeAdapter, JsonElement element) {
-      this.value = value;
-      this.id = id;
-      this.typeAdapter = typeAdapter;
-      this.element = element;
-    }
-
-    void write(JsonWriter out) throws IOException {
-      typeAdapter.write(out, value);
-    }
-
-    void read(Graph graph) throws IOException {
-      if (graph.nextCreate != null) {
-        throw new IllegalStateException("Unexpected recursive call to read() for " + id);
-      }
-      graph.nextCreate = this;
-      value = typeAdapter.fromJsonTree(element);
-      if (value == null) {
-        throw new IllegalStateException("non-null value deserialized to null: " + element);
-      }
-    }
-  }
-}
diff --git a/extras/src/main/java/com/google/gson/interceptors/Intercept.java b/extras/src/main/java/com/google/gson/interceptors/Intercept.java
deleted file mode 100644
index 0c4e9043f..000000000
--- a/extras/src/main/java/com/google/gson/interceptors/Intercept.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.interceptors;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-
-/**
- * Use this annotation to indicate various interceptors for class instances after
- * they have been processed by Gson. For example, you can use it to validate an instance
- * after it has been deserialized from Json.
- * Here is an example of how this annotation is used:
- * <p>Here is an example of how this annotation is used:
- * <p><pre>
- * &#64Intercept(postDeserialize=UserValidator.class)
- * public class User {
- *   String name;
- *   String password;
- *   String emailAddress;
- * }
- *
- * public class UserValidator implements JsonPostDeserializer&lt;User&gt; {
- *   public void postDeserialize(User user) {
- *     // Do some checks on user
- *     if (user.name == null || user.password == null) {
- *       throw new JsonParseException("name and password are required fields.");
- *     }
- *     if (user.emailAddress == null) {
- *       emailAddress = "unknown"; // assign a default value.
- *     }
- *   }
- * }
- * </pre></p>
- *
- * @author Inderjeet Singh
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE)
-public @interface Intercept {
-
-  /**
-   * Specify the class that provides the methods that should be invoked after an instance
-   * has been deserialized.
-   */
-  @SuppressWarnings("rawtypes")
-  public Class<? extends JsonPostDeserializer> postDeserialize();
-}
diff --git a/extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java b/extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
deleted file mode 100644
index 907fca3a4..000000000
--- a/extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package com.google.gson.interceptors;
-
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-
-/**
- * A type adapter factory that implements {@code @Intercept}.
- */
-public final class InterceptorFactory implements TypeAdapterFactory {
-  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-    Intercept intercept = type.getRawType().getAnnotation(Intercept.class);
-    if (intercept == null) {
-      return null;
-    }
-
-    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
-    return new InterceptorAdapter<T>(delegate, intercept);
-  }
-
-  static class InterceptorAdapter<T> extends TypeAdapter<T> {
-    private final TypeAdapter<T> delegate;
-    private final JsonPostDeserializer<T> postDeserializer;
-
-    @SuppressWarnings("unchecked") // ?
-    public InterceptorAdapter(TypeAdapter<T> delegate, Intercept intercept) {
-      try {
-        this.delegate = delegate;
-        this.postDeserializer = intercept.postDeserialize().newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      delegate.write(out, value);
-    }
-
-    @Override public T read(JsonReader in) throws IOException {
-      T result = delegate.read(in);
-      postDeserializer.postDeserialize(result);
-      return result;
-    }
-  }
-}
diff --git a/extras/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java b/extras/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java
deleted file mode 100644
index 0f3a72ca8..000000000
--- a/extras/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.interceptors;
-
-import com.google.gson.InstanceCreator;
-
-/**
- * This interface is implemented by a class that wishes to inspect or modify an object
- * after it has been deserialized. You must define a no-args constructor or register an
- * {@link InstanceCreator} for such a class.
- *
- * @author Inderjeet Singh
- */
-public interface JsonPostDeserializer<T> {
-
-  /**
-   * This method is called by Gson after the object has been deserialized from Json.
-   */
-  public void postDeserialize(T object);
-}
diff --git a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
deleted file mode 100644
index 36e06da20..000000000
--- a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2016 Gson Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import javax.annotation.PostConstruct;
-
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
-public class PostConstructAdapterFactory implements TypeAdapterFactory {
-    // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
-    @Override
-    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-        for (Class<?> t = type.getRawType(); (t != Object.class) && (t.getSuperclass() != null); t = t.getSuperclass()) {
-            for (Method m : t.getDeclaredMethods()) {
-                if (m.isAnnotationPresent(PostConstruct.class)) {
-                    m.setAccessible(true);
-                    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
-                    return new PostConstructAdapter<T>(delegate, m);
-                }
-            }
-        }
-        return null;
-    }
-
-    final static class PostConstructAdapter<T> extends TypeAdapter<T> {
-        private final TypeAdapter<T> delegate;
-        private final Method method;
-
-        public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
-            this.delegate = delegate;
-            this.method = method;
-        }
-
-        @Override public T read(JsonReader in) throws IOException {
-            T result = delegate.read(in);
-            if (result != null) {
-                try {
-                    method.invoke(result);
-                } catch (IllegalAccessException e) {
-                    throw new AssertionError();
-                } catch (InvocationTargetException e) {
-                    if (e.getCause() instanceof RuntimeException) throw (RuntimeException) e.getCause();
-                    throw new RuntimeException(e.getCause());
-                }
-            }
-            return result;
-        }
-
-        @Override public void write(JsonWriter out, T value) throws IOException {
-            delegate.write(out, value);
-        }
-    }
-}
diff --git a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
deleted file mode 100644
index 47e7f5152..000000000
--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import java.io.IOException;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.Streams;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
-/**
- * Adapts values whose runtime type may differ from their declaration type. This
- * is necessary when a field's type is not the same type that GSON should create
- * when deserializing that field. For example, consider these types:
- * <pre>   {@code
- *   abstract class Shape {
- *     int x;
- *     int y;
- *   }
- *   class Circle extends Shape {
- *     int radius;
- *   }
- *   class Rectangle extends Shape {
- *     int width;
- *     int height;
- *   }
- *   class Diamond extends Shape {
- *     int width;
- *     int height;
- *   }
- *   class Drawing {
- *     Shape bottomShape;
- *     Shape topShape;
- *   }
- * }</pre>
- * <p>Without additional type information, the serialized JSON is ambiguous. Is
- * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code
- *   {
- *     "bottomShape": {
- *       "width": 10,
- *       "height": 5,
- *       "x": 0,
- *       "y": 0
- *     },
- *     "topShape": {
- *       "radius": 2,
- *       "x": 4,
- *       "y": 1
- *     }
- *   }}</pre>
- * This class addresses this problem by adding type information to the
- * serialized JSON and honoring that type information when the JSON is
- * deserialized: <pre>   {@code
- *   {
- *     "bottomShape": {
- *       "type": "Diamond",
- *       "width": 10,
- *       "height": 5,
- *       "x": 0,
- *       "y": 0
- *     },
- *     "topShape": {
- *       "type": "Circle",
- *       "radius": 2,
- *       "x": 4,
- *       "y": 1
- *     }
- *   }}</pre>
- * Both the type field name ({@code "type"}) and the type labels ({@code
- * "Rectangle"}) are configurable.
- *
- * <h3>Registering Types</h3>
- * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
- * name to the {@link #of} factory method. If you don't supply an explicit type
- * field name, {@code "type"} will be used. <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
- *       = RuntimeTypeAdapterFactory.of(Shape.class, "type");
- * }</pre>
- * Next register all of your subtypes. Every subtype must be explicitly
- * registered. This protects your application from injection attacks. If you
- * don't supply an explicit type label, the type's simple name will be used.
- * <pre>   {@code
- *   shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
- *   shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
- *   shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
- * }</pre>
- * Finally, register the type adapter factory in your application's GSON builder:
- * <pre>   {@code
- *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapterFactory(shapeAdapterFactory)
- *       .create();
- * }</pre>
- * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
- *       .registerSubtype(Rectangle.class)
- *       .registerSubtype(Circle.class)
- *       .registerSubtype(Diamond.class);
- * }</pre>
- */
-public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
-  private final Class<?> baseType;
-  private final String typeFieldName;
-  private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();
-  private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();
-  private final boolean maintainType;
-
-  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {
-    if (typeFieldName == null || baseType == null) {
-      throw new NullPointerException();
-    }
-    this.baseType = baseType;
-    this.typeFieldName = typeFieldName;
-    this.maintainType = maintainType;
-  }
-
-  /**
-   * Creates a new runtime type adapter using for {@code baseType} using {@code
-   * typeFieldName} as the type field name. Type field names are case sensitive.
-   * {@code maintainType} flag decide if the type will be stored in pojo or not.
-   */
-  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, maintainType);
-  }
-  
-  /**
-   * Creates a new runtime type adapter using for {@code baseType} using {@code
-   * typeFieldName} as the type field name. Type field names are case sensitive.
-   */
-  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, false);
-  }
-
-  /**
-   * Creates a new runtime type adapter for {@code baseType} using {@code "type"} as
-   * the type field name.
-   */
-  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, "type", false);
-  }
-
-  /**
-   * Registers {@code type} identified by {@code label}. Labels are case
-   * sensitive.
-   *
-   * @throws IllegalArgumentException if either {@code type} or {@code label}
-   *     have already been registered on this type adapter.
-   */
-  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
-    if (type == null || label == null) {
-      throw new NullPointerException();
-    }
-    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {
-      throw new IllegalArgumentException("types and labels must be unique");
-    }
-    labelToSubtype.put(label, type);
-    subtypeToLabel.put(type, label);
-    return this;
-  }
-
-  /**
-   * Registers {@code type} identified by its {@link Class#getSimpleName simple
-   * name}. Labels are case sensitive.
-   *
-   * @throws IllegalArgumentException if either {@code type} or its simple name
-   *     have already been registered on this type adapter.
-   */
-  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
-    return registerSubtype(type, type.getSimpleName());
-  }
-
-  public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
-    if (type.getRawType() != baseType) {
-      return null;
-    }
-
-    final Map<String, TypeAdapter<?>> labelToDelegate
-        = new LinkedHashMap<String, TypeAdapter<?>>();
-    final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate
-        = new LinkedHashMap<Class<?>, TypeAdapter<?>>();
-    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
-      TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
-      labelToDelegate.put(entry.getKey(), delegate);
-      subtypeToDelegate.put(entry.getValue(), delegate);
-    }
-
-    return new TypeAdapter<R>() {
-      @Override public R read(JsonReader in) throws IOException {
-        JsonElement jsonElement = Streams.parse(in);
-        JsonElement labelJsonElement;
-        if (maintainType) {
-            labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
-        } else {
-            labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
-        }
-        
-        if (labelJsonElement == null) {
-          throw new JsonParseException("cannot deserialize " + baseType
-              + " because it does not define a field named " + typeFieldName);
-        }
-        String label = labelJsonElement.getAsString();
-        @SuppressWarnings("unchecked") // registration requires that subtype extends T
-        TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
-        if (delegate == null) {
-          throw new JsonParseException("cannot deserialize " + baseType + " subtype named "
-              + label + "; did you forget to register a subtype?");
-        }
-        return delegate.fromJsonTree(jsonElement);
-      }
-
-      @Override public void write(JsonWriter out, R value) throws IOException {
-        Class<?> srcType = value.getClass();
-        String label = subtypeToLabel.get(srcType);
-        @SuppressWarnings("unchecked") // registration requires that subtype extends T
-        TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
-        if (delegate == null) {
-          throw new JsonParseException("cannot serialize " + srcType.getName()
-              + "; did you forget to register a subtype?");
-        }
-        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();
-
-        if (maintainType) {
-          Streams.write(jsonObject, out);
-          return;
-        }
-
-        JsonObject clone = new JsonObject();
-
-        if (jsonObject.has(typeFieldName)) {
-          throw new JsonParseException("cannot serialize " + srcType.getName()
-              + " because it already defines a field named " + typeFieldName);
-        }
-        clone.add(typeFieldName, new JsonPrimitive(label));
-        
-        for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
-          clone.add(e.getKey(), e.getValue());
-        }
-        Streams.write(clone, out);
-      }
-    }.nullSafe();
-  }
-}
diff --git a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
deleted file mode 100644
index 1e889d373..000000000
--- a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import java.io.IOException;
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import com.google.gson.JsonParseException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
-public final class UtcDateTypeAdapter extends TypeAdapter<Date> {
-  private final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("UTC");
-
-  @Override
-  public void write(JsonWriter out, Date date) throws IOException {
-    if (date == null) {
-      out.nullValue();
-    } else {
-      String value = format(date, true, UTC_TIME_ZONE);
-      out.value(value);
-    }
-  }
-
-  @Override
-  public Date read(JsonReader in) throws IOException {
-    try {
-      switch (in.peek()) {
-      case NULL:
-        in.nextNull();
-        return null;
-      default:
-        String date = in.nextString();
-        // Instead of using iso8601Format.parse(value), we use Jackson's date parsing
-        // This is because Android doesn't support XXX because it is JDK 1.6
-        return parse(date, new ParsePosition(0));
-      }
-    } catch (ParseException e) {
-      throw new JsonParseException(e);
-    }
-  }
-
-  // Date parsing code from Jackson databind ISO8601Utils.java
-  // https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
-  private static final String GMT_ID = "GMT";
-
-  /**
-   * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-   *
-   * @param date the date to format
-   * @param millis true to include millis precision otherwise false
-   * @param tz timezone to use for the formatting (GMT will produce 'Z')
-   * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
-   */
-  private static String format(Date date, boolean millis, TimeZone tz) {
-      Calendar calendar = new GregorianCalendar(tz, Locale.US);
-      calendar.setTime(date);
-
-      // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
-      int capacity = "yyyy-MM-ddThh:mm:ss".length();
-      capacity += millis ? ".sss".length() : 0;
-      capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length();
-      StringBuilder formatted = new StringBuilder(capacity);
-
-      padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
-      formatted.append('-');
-      padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
-      formatted.append('-');
-      padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
-      formatted.append('T');
-      padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
-      formatted.append(':');
-      padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
-      formatted.append(':');
-      padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
-      if (millis) {
-          formatted.append('.');
-          padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
-      }
-
-      int offset = tz.getOffset(calendar.getTimeInMillis());
-      if (offset != 0) {
-          int hours = Math.abs((offset / (60 * 1000)) / 60);
-          int minutes = Math.abs((offset / (60 * 1000)) % 60);
-          formatted.append(offset < 0 ? '-' : '+');
-          padInt(formatted, hours, "hh".length());
-          formatted.append(':');
-          padInt(formatted, minutes, "mm".length());
-      } else {
-          formatted.append('Z');
-      }
-
-      return formatted.toString();
-  }
-  /**
-   * Zero pad a number to a specified length
-   *
-   * @param buffer buffer to use for padding
-   * @param value the integer value to pad if necessary.
-   * @param length the length of the string we should zero pad
-   */
-  private static void padInt(StringBuilder buffer, int value, int length) {
-      String strValue = Integer.toString(value);
-      for (int i = length - strValue.length(); i > 0; i--) {
-          buffer.append('0');
-      }
-      buffer.append(strValue);
-  }
-
-  /**
-   * Parse a date from ISO-8601 formatted string. It expects a format
-   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
-   *
-   * @param date ISO string to parse in the appropriate format.
-   * @param pos The position to start parsing from, updated to where parsing stopped.
-   * @return the parsed date
-   * @throws ParseException if the date is not in the appropriate format
-   */
-  private static Date parse(String date, ParsePosition pos) throws ParseException {
-    Exception fail = null;
-    try {
-      int offset = pos.getIndex();
-
-      // extract year
-      int year = parseInt(date, offset, offset += 4);
-      if (checkOffset(date, offset, '-')) {
-        offset += 1;
-      }
-
-      // extract month
-      int month = parseInt(date, offset, offset += 2);
-      if (checkOffset(date, offset, '-')) {
-        offset += 1;
-      }
-
-      // extract day
-      int day = parseInt(date, offset, offset += 2);
-      // default time value
-      int hour = 0;
-      int minutes = 0;
-      int seconds = 0;
-      int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
-      if (checkOffset(date, offset, 'T')) {
-
-        // extract hours, minutes, seconds and milliseconds
-        hour = parseInt(date, offset += 1, offset += 2);
-        if (checkOffset(date, offset, ':')) {
-          offset += 1;
-        }
-
-        minutes = parseInt(date, offset, offset += 2);
-        if (checkOffset(date, offset, ':')) {
-          offset += 1;
-        }
-        // second and milliseconds can be optional
-        if (date.length() > offset) {
-          char c = date.charAt(offset);
-          if (c != 'Z' && c != '+' && c != '-') {
-            seconds = parseInt(date, offset, offset += 2);
-            // milliseconds can be optional in the format
-            if (checkOffset(date, offset, '.')) {
-              milliseconds = parseInt(date, offset += 1, offset += 3);
-            }
-          }
-        }
-      }
-
-      // extract timezone
-      String timezoneId;
-      if (date.length() <= offset) {
-        throw new IllegalArgumentException("No time zone indicator");
-      }
-      char timezoneIndicator = date.charAt(offset);
-      if (timezoneIndicator == '+' || timezoneIndicator == '-') {
-        String timezoneOffset = date.substring(offset);
-        timezoneId = GMT_ID + timezoneOffset;
-        offset += timezoneOffset.length();
-      } else if (timezoneIndicator == 'Z') {
-        timezoneId = GMT_ID;
-        offset += 1;
-      } else {
-        throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator);
-      }
-
-      TimeZone timezone = TimeZone.getTimeZone(timezoneId);
-      if (!timezone.getID().equals(timezoneId)) {
-        throw new IndexOutOfBoundsException();
-      }
-
-      Calendar calendar = new GregorianCalendar(timezone);
-      calendar.setLenient(false);
-      calendar.set(Calendar.YEAR, year);
-      calendar.set(Calendar.MONTH, month - 1);
-      calendar.set(Calendar.DAY_OF_MONTH, day);
-      calendar.set(Calendar.HOUR_OF_DAY, hour);
-      calendar.set(Calendar.MINUTE, minutes);
-      calendar.set(Calendar.SECOND, seconds);
-      calendar.set(Calendar.MILLISECOND, milliseconds);
-
-      pos.setIndex(offset);
-      return calendar.getTime();
-      // If we get a ParseException it'll already have the right message/offset.
-      // Other exception types can convert here.
-    } catch (IndexOutOfBoundsException e) {
-      fail = e;
-    } catch (NumberFormatException e) {
-      fail = e;
-    } catch (IllegalArgumentException e) {
-      fail = e;
-    }
-    String input = (date == null) ? null : ("'" + date + "'");
-    throw new ParseException("Failed to parse date [" + input + "]: " + fail.getMessage(), pos.getIndex());
-  }
-
-  /**
-   * Check if the expected character exist at the given offset in the value.
-   *
-   * @param value the string to check at the specified offset
-   * @param offset the offset to look for the expected character
-   * @param expected the expected character
-   * @return true if the expected character exist at the given offset
-   */
-  private static boolean checkOffset(String value, int offset, char expected) {
-    return (offset < value.length()) && (value.charAt(offset) == expected);
-  }
-
-  /**
-   * Parse an integer located between 2 given offsets in a string
-   *
-   * @param value the string to parse
-   * @param beginIndex the start index for the integer in the string
-   * @param endIndex the end index for the integer in the string
-   * @return the int
-   * @throws NumberFormatException if the value is not a number
-   */
-  private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
-    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
-      throw new NumberFormatException(value);
-    }
-    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
-    int i = beginIndex;
-    int result = 0;
-    int digit;
-    if (i < endIndex) {
-      digit = Character.digit(value.charAt(i++), 10);
-      if (digit < 0) {
-        throw new NumberFormatException("Invalid number: " + value);
-      }
-      result = -digit;
-    }
-    while (i < endIndex) {
-      digit = Character.digit(value.charAt(i++), 10);
-      if (digit < 0) {
-        throw new NumberFormatException("Invalid number: " + value);
-      }
-      result *= 10;
-      result -= digit;
-    }
-    return -result;
-  }
-}
diff --git a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
deleted file mode 100644
index 8a1d7cdbf..000000000
--- a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.graph;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.reflect.TypeToken;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import junit.framework.TestCase;
-
-public final class GraphAdapterBuilderTest extends TestCase {
-  public void testSerialization() {
-    Roshambo rock = new Roshambo("ROCK");
-    Roshambo scissors = new Roshambo("SCISSORS");
-    Roshambo paper = new Roshambo("PAPER");
-    rock.beats = scissors;
-    scissors.beats = paper;
-    paper.beats = rock;
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Roshambo.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    assertEquals("{'0x1':{'name':'ROCK','beats':'0x2'}," +
-        "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
-        "'0x3':{'name':'PAPER','beats':'0x1'}}",
-        gson.toJson(rock).replace('"', '\''));
-  }
-
-  public void testDeserialization() {
-    String json = "{'0x1':{'name':'ROCK','beats':'0x2'}," +
-        "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
-        "'0x3':{'name':'PAPER','beats':'0x1'}}";
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Roshambo.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    Roshambo rock = gson.fromJson(json, Roshambo.class);
-    assertEquals("ROCK", rock.name);
-    Roshambo scissors = rock.beats;
-    assertEquals("SCISSORS", scissors.name);
-    Roshambo paper = scissors.beats;
-    assertEquals("PAPER", paper.name);
-    assertSame(rock, paper.beats);
-  }
-
-  public void testSerializationDirectSelfReference() {
-    Roshambo suicide = new Roshambo("SUICIDE");
-    suicide.beats = suicide;
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Roshambo.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    assertEquals("{'0x1':{'name':'SUICIDE','beats':'0x1'}}",
-        gson.toJson(suicide).replace('"', '\''));
-  }
-
-  public void testDeserializationDirectSelfReference() {
-    String json = "{'0x1':{'name':'SUICIDE','beats':'0x1'}}";
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Roshambo.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    Roshambo suicide = gson.fromJson(json, Roshambo.class);
-    assertEquals("SUICIDE", suicide.name);
-    assertSame(suicide, suicide.beats);
-  }
-
-  public void testSerializeListOfLists() {
-    Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();
-    Type listOfAnyType = new TypeToken<List<?>>() {}.getType();
-
-    List<List<?>> listOfLists = new ArrayList<List<?>>();
-    listOfLists.add(listOfLists);
-    listOfLists.add(new ArrayList<Object>());
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(listOfListsType)
-        .addType(listOfAnyType)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    String json = gson.toJson(listOfLists, listOfListsType);
-    assertEquals("{'0x1':['0x1','0x2'],'0x2':[]}", json.replace('"', '\''));
-  }
-
-  public void testDeserializeListOfLists() {
-    Type listOfAnyType = new TypeToken<List<?>>() {}.getType();
-    Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(listOfListsType)
-        .addType(listOfAnyType)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    List<List<?>> listOfLists = gson.fromJson("{'0x1':['0x1','0x2'],'0x2':[]}", listOfListsType);
-    assertEquals(2, listOfLists.size());
-    assertSame(listOfLists, listOfLists.get(0));
-    assertEquals(Collections.emptyList(), listOfLists.get(1));
-  }
-
-  public void testSerializationWithMultipleTypes() {
-    Company google = new Company("Google");
-    new Employee("Jesse", google);
-    new Employee("Joel", google);
-
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Company.class)
-        .addType(Employee.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    assertEquals("{'0x1':{'name':'Google','employees':['0x2','0x3']},"
-        + "'0x2':{'name':'Jesse','company':'0x1'},"
-        + "'0x3':{'name':'Joel','company':'0x1'}}",
-        gson.toJson(google).replace('"', '\''));
-  }
-
-  public void testDeserializationWithMultipleTypes() {
-    GsonBuilder gsonBuilder = new GsonBuilder();
-    new GraphAdapterBuilder()
-        .addType(Company.class)
-        .addType(Employee.class)
-        .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
-
-    String json = "{'0x1':{'name':'Google','employees':['0x2','0x3']},"
-        + "'0x2':{'name':'Jesse','company':'0x1'},"
-        + "'0x3':{'name':'Joel','company':'0x1'}}";
-    Company company = gson.fromJson(json, Company.class);
-    assertEquals("Google", company.name);
-    Employee jesse = company.employees.get(0);
-    assertEquals("Jesse", jesse.name);
-    assertEquals(company, jesse.company);
-    Employee joel = company.employees.get(1);
-    assertEquals("Joel", joel.name);
-    assertEquals(company, joel.company);
-  }
-
-  static class Roshambo {
-    String name;
-    Roshambo beats;
-    Roshambo(String name) {
-      this.name = name;
-    }
-  }
-
-  static class Employee {
-    final String name;
-    final Company company;
-    Employee(String name, Company company) {
-      this.name = name;
-      this.company = company;
-      this.company.employees.add(this);
-    }
-  }
-
-  static class Company {
-    final String name;
-    final List<Employee> employees = new ArrayList<Employee>();
-    Company(String name) {
-      this.name = name;
-    }
-  }
-}
diff --git a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
deleted file mode 100644
index 0aab6598c..000000000
--- a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.interceptors;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link Intercept} and {@link JsonPostDeserializer}.
- *
- * @author Inderjeet Singh
- */
-public final class InterceptorTest extends TestCase {
-
-  private Gson gson;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    this.gson = new GsonBuilder()
-        .registerTypeAdapterFactory(new InterceptorFactory())
-        .enableComplexMapKeySerialization()
-        .create();
-  }
-
-  public void testExceptionsPropagated() {
-    try {
-      gson.fromJson("{}", User.class);
-      fail();
-    } catch (JsonParseException expected) {}
-  }
-
-  public void testTopLevelClass() {
-    User user = gson.fromJson("{name:'bob',password:'pwd'}", User.class);
-    assertEquals(User.DEFAULT_EMAIL, user.email);
-  }
-
-  public void testList() {
-    List<User> list = gson.fromJson("[{name:'bob',password:'pwd'}]", new TypeToken<List<User>>(){}.getType());
-    User user = list.get(0);
-    assertEquals(User.DEFAULT_EMAIL, user.email);
-  }
-
-  public void testCollection() {
-    Collection<User> list = gson.fromJson("[{name:'bob',password:'pwd'}]", new TypeToken<Collection<User>>(){}.getType());
-    User user = list.iterator().next();
-    assertEquals(User.DEFAULT_EMAIL, user.email);
-  }
-
-  public void testMapKeyAndValues() {
-    Type mapType = new TypeToken<Map<User, Address>>(){}.getType();
-    try {
-      gson.fromJson("[[{name:'bob',password:'pwd'},{}]]", mapType);
-      fail();
-    } catch (JsonSyntaxException expected) {}
-    Map<User, Address> map = gson.fromJson("[[{name:'bob',password:'pwd'},{city:'Mountain View',state:'CA',zip:'94043'}]]",
-        mapType);
-    Entry<User, Address> entry = map.entrySet().iterator().next();
-    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);
-    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);
-  }
-
-  public void testField() {
-    UserGroup userGroup = gson.fromJson("{user:{name:'bob',password:'pwd'}}", UserGroup.class);
-    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
-  }
-
-  public void testCustomTypeAdapter() {
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapter(User.class, new TypeAdapter<User>() {
-          @Override public void write(JsonWriter out, User value) throws IOException {
-            throw new UnsupportedOperationException();
-          }
-
-          @Override public User read(JsonReader in) throws IOException {
-            in.beginObject();
-            in.nextName();
-            String name = in.nextString();
-            in.nextName();
-            String password = in.nextString();
-            in.endObject();
-            return new User(name, password);
-          }
-        })
-        .registerTypeAdapterFactory(new InterceptorFactory())
-        .create();
-    UserGroup userGroup = gson.fromJson("{user:{name:'bob',password:'pwd'}}", UserGroup.class);
-    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
-  }
-
-  public void testDirectInvocationOfTypeAdapter() throws Exception {
-    TypeAdapter<UserGroup> adapter = gson.getAdapter(UserGroup.class);
-    UserGroup userGroup = adapter.fromJson("{\"user\":{\"name\":\"bob\",\"password\":\"pwd\"}}");
-    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
-  }
-
-  @SuppressWarnings("unused")
-  private static final class UserGroup {
-    User user;
-    String city;
-  }
-
-  @Intercept(postDeserialize = UserValidator.class)
-  @SuppressWarnings("unused")
-  private static final class User {
-    static final String DEFAULT_EMAIL = "invalid@invalid.com";
-    String name;
-    String password;
-    String email;
-    Address address;
-    public User(String name, String password) {
-      this.name = name;
-      this.password = password;
-    }
-  }
-
-  public static final class UserValidator implements JsonPostDeserializer<User> {
-    public void postDeserialize(User user) {
-      if (user.name == null || user.password == null) {
-        throw new JsonSyntaxException("name and password are required fields.");
-      }
-      if (user.email == null) user.email = User.DEFAULT_EMAIL;
-    }
-  }
-
-  @Intercept(postDeserialize = AddressValidator.class)
-  @SuppressWarnings("unused")
-  private static final class Address {
-    static final String DEFAULT_FIRST_LINE = "unknown";
-    String firstLine;
-    String secondLine;
-    String city;
-    String state;
-    String zip;
-  }
-
-  public static final class AddressValidator implements JsonPostDeserializer<Address> {
-    public void postDeserialize(Address address) {
-      if (address.city == null || address.state == null || address.zip == null) {
-        throw new JsonSyntaxException("Address city, state and zip are required fields.");
-      }
-      if (address.firstLine == null) address.firstLine = Address.DEFAULT_FIRST_LINE;
-    }
-  }
-}
diff --git a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
deleted file mode 100644
index 7bd0a520d..000000000
--- a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2016 Gson Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import javax.annotation.PostConstruct;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-
-import junit.framework.TestCase;
-
-import java.util.Arrays;
-import java.util.List;
-
-public class PostConstructAdapterFactoryTest extends TestCase {
-    public void test() throws Exception {
-        Gson gson = new GsonBuilder()
-                .registerTypeAdapterFactory(new PostConstructAdapterFactory())
-                .create();
-        gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
-        try {
-            gson.fromJson("{\"bread\": \"cheesey bread\", \"cheese\": \"swiss\"}", Sandwich.class);
-            fail();
-        } catch (IllegalArgumentException expected) {
-            assertEquals("too cheesey", expected.getMessage());
-        }
-    }
-
-    public void testList() {
-        MultipleSandwiches sandwiches = new MultipleSandwiches(Arrays.asList(
-            new Sandwich("white", "cheddar"),
-            new Sandwich("whole wheat", "swiss")));
-
-        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();
-
-        // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
-        String json = gson.toJson(sandwiches);
-        assertEquals("{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}", json);
-
-        MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
-        assertEquals(sandwiches, sandwichesFromJson);
-    }
-
-    static class Sandwich {
-        public String bread;
-        public String cheese;
-
-        public Sandwich(String bread, String cheese) {
-            this.bread = bread;
-            this.cheese = cheese;
-        }
-
-        @PostConstruct private void validate() {
-            if (bread.equals("cheesey bread") && cheese != null) {
-                throw new IllegalArgumentException("too cheesey");
-            }
-        }
-
-        public boolean equals(Object o) {
-            if (o == this) {
-                return true;
-            }
-            if (!(o instanceof Sandwich)) {
-                return false;
-            }
-            final Sandwich other = (Sandwich) o;
-            if (this.bread == null ? other.bread != null : !this.bread.equals(other.bread)) {
-                return false;
-            }
-            if (this.cheese == null ? other.cheese != null : !this.cheese.equals(other.cheese)) {
-                return false;
-            }
-            return true;
-        }
-    }
-
-    static class MultipleSandwiches {
-        public List<Sandwich> sandwiches;
-
-        public MultipleSandwiches(List<Sandwich> sandwiches) {
-            this.sandwiches = sandwiches;
-        }
-
-        public boolean equals(Object o) {
-            if (o == this) {
-                return true;
-            }
-            if (!(o instanceof MultipleSandwiches)) {
-                return false;
-            }
-            final MultipleSandwiches other = (MultipleSandwiches) o;
-            if (this.sandwiches == null ? other.sandwiches != null : !this.sandwiches.equals(other.sandwiches)) {
-                return false;
-            }
-            return true;
-        }
-    }
-}
diff --git a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
deleted file mode 100644
index 8c62bef7f..000000000
--- a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonParseException;
-import com.google.gson.TypeAdapterFactory;
-import junit.framework.TestCase;
-
-public final class RuntimeTypeAdapterFactoryTest extends TestCase {
-
-  public void testRuntimeTypeAdapter() {
-    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class)
-        .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(rta)
-        .create();
-
-    CreditCard original = new CreditCard("Jesse", 234);
-    assertEquals("{\"type\":\"CreditCard\",\"cvv\":234,\"ownerName\":\"Jesse\"}",
-        gson.toJson(original, BillingInstrument.class));
-    BillingInstrument deserialized = gson.fromJson(
-        "{type:'CreditCard',cvv:234,ownerName:'Jesse'}", BillingInstrument.class);
-    assertEquals("Jesse", deserialized.ownerName);
-    assertTrue(deserialized instanceof CreditCard);
-  }
-
-  public void testRuntimeTypeIsBaseType() {
-    TypeAdapterFactory rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class)
-        .registerSubtype(BillingInstrument.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(rta)
-        .create();
-
-    BillingInstrument original = new BillingInstrument("Jesse");
-    assertEquals("{\"type\":\"BillingInstrument\",\"ownerName\":\"Jesse\"}",
-        gson.toJson(original, BillingInstrument.class));
-    BillingInstrument deserialized = gson.fromJson(
-        "{type:'BillingInstrument',ownerName:'Jesse'}", BillingInstrument.class);
-    assertEquals("Jesse", deserialized.ownerName);
-  }
-
-  public void testNullBaseType() {
-    try {
-      RuntimeTypeAdapterFactory.of(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  public void testNullTypeFieldName() {
-    try {
-      RuntimeTypeAdapterFactory.of(BillingInstrument.class, null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  public void testNullSubtype() {
-    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class);
-    try {
-      rta.registerSubtype(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  public void testNullLabel() {
-    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class);
-    try {
-      rta.registerSubtype(CreditCard.class, null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  public void testDuplicateSubtype() {
-    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class);
-    rta.registerSubtype(CreditCard.class, "CC");
-    try {
-      rta.registerSubtype(CreditCard.class, "Visa");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  public void testDuplicateLabel() {
-    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
-        BillingInstrument.class);
-    rta.registerSubtype(CreditCard.class, "CC");
-    try {
-      rta.registerSubtype(BankTransfer.class, "CC");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  public void testDeserializeMissingTypeField() {
-    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
-        .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(billingAdapter)
-        .create();
-    try {
-      gson.fromJson("{ownerName:'Jesse'}", BillingInstrument.class);
-      fail();
-    } catch (JsonParseException expected) {
-    }
-  }
-
-  public void testDeserializeMissingSubtype() {
-    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
-        .registerSubtype(BankTransfer.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(billingAdapter)
-        .create();
-    try {
-      gson.fromJson("{type:'CreditCard',ownerName:'Jesse'}", BillingInstrument.class);
-      fail();
-    } catch (JsonParseException expected) {
-    }
-  }
-
-  public void testSerializeMissingSubtype() {
-    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
-        .registerSubtype(BankTransfer.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(billingAdapter)
-        .create();
-    try {
-      gson.toJson(new CreditCard("Jesse", 456), BillingInstrument.class);
-      fail();
-    } catch (JsonParseException expected) {
-    }
-  }
-
-  public void testSerializeCollidingTypeFieldName() {
-    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class, "cvv")
-        .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(billingAdapter)
-        .create();
-    try {
-      gson.toJson(new CreditCard("Jesse", 456), BillingInstrument.class);
-      fail();
-    } catch (JsonParseException expected) {
-    }
-  }
-
-  public void testSerializeWrappedNullValue() {
-    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
-        .registerSubtype(CreditCard.class)
-        .registerSubtype(BankTransfer.class);    
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapterFactory(billingAdapter)
-        .create();    
-    String serialized = gson.toJson(new BillingInstrumentWrapper(null), BillingInstrumentWrapper.class);
-    BillingInstrumentWrapper deserialized = gson.fromJson(serialized, BillingInstrumentWrapper.class);
-    assertNull(deserialized.instrument);
-  }
-
-  static class BillingInstrumentWrapper {
-    BillingInstrument instrument;
-    BillingInstrumentWrapper(BillingInstrument instrument) {
-      this.instrument = instrument;
-    }
-  }
-
-  static class BillingInstrument {
-    private final String ownerName;
-    BillingInstrument(String ownerName) {
-      this.ownerName = ownerName;
-    }
-  }
-
-  static class CreditCard extends BillingInstrument {
-    int cvv;
-    CreditCard(String ownerName, int cvv) {
-      super(ownerName);
-      this.cvv = cvv;
-    }
-  }
-
-  static class BankTransfer extends BillingInstrument {
-    int bankAccount;
-    BankTransfer(String ownerName, int bankAccount) {
-      super(ownerName);
-      this.bankAccount = bankAccount;
-    }
-  }
-}
diff --git a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
deleted file mode 100644
index 56e54290c..000000000
--- a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.typeadapters;
-
-import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import com.google.gson.JsonParseException;
-import junit.framework.TestCase;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-
-public final class UtcDateTypeAdapterTest extends TestCase {
-  private final Gson gson = new GsonBuilder()
-    .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
-    .create();
-
-  public void testLocalTimeZone() {
-    Date expected = new Date();
-    String json = gson.toJson(expected);
-    Date actual = gson.fromJson(json, Date.class);
-    assertEquals(expected.getTime(), actual.getTime());
-  }
-
-  public void testDifferentTimeZones() {
-    for (String timeZone : TimeZone.getAvailableIDs()) {
-      Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
-      Date expected = cal.getTime();
-      String json = gson.toJson(expected);
-      // System.out.println(json + ": " + timeZone);
-      Date actual = gson.fromJson(json, Date.class);
-      assertEquals(expected.getTime(), actual.getTime());
-    }
-  }
-
-  /**
-   * JDK 1.7 introduced support for XXX format to indicate UTC date. But Android is older JDK.
-   * We want to make sure that this date is parseable in Android.
-   */
-  public void testUtcDatesOnJdkBefore1_7() {
-    Gson gson = new GsonBuilder()
-      .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
-      .create();
-    gson.fromJson("'2014-12-05T04:00:00.000Z'", Date.class);
-  }
-
-  public void testUtcWithJdk7Default() {
-    Date expected = new Date();
-    SimpleDateFormat iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX", Locale.US);
-    iso8601Format.setTimeZone(TimeZone.getTimeZone("UTC"));
-    String expectedJson = "\"" + iso8601Format.format(expected) + "\"";
-    String actualJson = gson.toJson(expected);
-    assertEquals(expectedJson, actualJson);
-    Date actual = gson.fromJson(expectedJson, Date.class);
-    assertEquals(expected.getTime(), actual.getTime());
-  }
-
-  public void testNullDateSerialization() {
-    String json = gson.toJson(null, Date.class);
-    assertEquals("null", json);
-  }
-
-  public void testWellFormedParseException() {
-    try {
-      gson.fromJson("2017-06-20T14:32:30", Date.class);
-      fail("No exception");
-    } catch (JsonParseException exe) {
-      assertEquals(exe.getMessage(), "java.text.ParseException: Failed to parse date ['2017-06-20T14']: 2017-06-20T14");
-    }
-  }
-}
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 7a3265ee9..000000000
Binary files a/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 4c5f88200..000000000
--- a/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Fri Apr 27 17:41:01 PDT 2018
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/gson/pom.xml b/gson/pom.xml
index 8f233fe71..230a83b83 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -2,20 +2,27 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.google.code.gson</groupId>
-    <artifactId>gson-parent</artifactId>
-    <version>2.8.6-SNAPSHOT</version>
+	<groupId>com.praxar</groupId>
+	<artifactId>gson-parent</artifactId>
+	<version>2.8.6-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>
   <name>Gson</name>
 
+<properties>
+	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+	<maven.compiler.source>9</maven.compiler.source>
+   	<maven.compiler.target>9</maven.compiler.target>
+</properties>
+
   <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
+      <dependency>
+        <groupId>junit</groupId>
+        <artifactId>junit</artifactId>
+        <version>4.12</version>
+        <scope>test</scope>
+      </dependency>
   </dependencies>
  
   <build>
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 0c455b2a0..bf206f1da 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -57,6 +57,7 @@
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
+import com.praxem.google.ext.State;
 
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
@@ -110,6 +111,7 @@
   static final boolean DEFAULT_SERIALIZE_NULLS = false;
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
   static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
+  static final JsonGlobalContext DEFAULT_JSON_GLOBAL_CONTEXT = null;
 
   private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
@@ -128,7 +130,11 @@
 
   private final ConstructorConstructor constructorConstructor;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
-
+  
+  final boolean forDisplay;
+  final State state;
+  final JsonGlobalContext globalContext;
+  
   final List<TypeAdapterFactory> factories;
 
   final Excluder excluder;
@@ -189,7 +195,7 @@ public Gson() {
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
         LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
         Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
-        Collections.<TypeAdapterFactory>emptyList());
+        Collections.<TypeAdapterFactory>emptyList(), null, false, null);
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
@@ -199,7 +205,7 @@ public Gson() {
       LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
       int timeStyle, List<TypeAdapterFactory> builderFactories,
       List<TypeAdapterFactory> builderHierarchyFactories,
-      List<TypeAdapterFactory> factoriesToBeAdded) {
+      List<TypeAdapterFactory> factoriesToBeAdded, JsonGlobalContext globalContext, boolean forDisplay, State state) {
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
     this.instanceCreators = instanceCreators;
@@ -217,6 +223,10 @@ public Gson() {
     this.timeStyle = timeStyle;
     this.builderFactories = builderFactories;
     this.builderHierarchyFactories = builderHierarchyFactories;
+    
+    this.globalContext = globalContext;
+    this.forDisplay = forDisplay;
+    this.state = state;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -846,7 +856,12 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
     return target;
   }
 
-  /**
+  public JsonGlobalContext getGlobalContext()
+{
+	return globalContext;
+}
+
+/**
    * This method deserializes the Json read from the specified reader into an object of the
    * specified class. It is not suitable to use if the specified class is a generic type since it
    * will not have the generic type information because of the Type Erasure feature of Java.
@@ -1034,4 +1049,14 @@ public String toString() {
         .append("}")
         .toString();
   }
+
+	public boolean isForDisplay()
+	{
+		return forDisplay;
+	}
+	
+	public State state()
+	{
+		return state;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index b97be452b..f487709b8 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,6 +16,14 @@
 
 package com.google.gson;
 
+import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
+import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
+import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
+import static com.google.gson.Gson.DEFAULT_LENIENT;
+import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
+import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
+import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -32,14 +40,7 @@
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
-
-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
-import static com.google.gson.Gson.DEFAULT_LENIENT;
-import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+import com.praxem.google.ext.State;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -95,6 +96,10 @@
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
   private boolean lenient = DEFAULT_LENIENT;
 
+  private JsonGlobalContext globalContext = null;
+  private boolean forDisplay = false;
+  private State state = null;
+  
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
    * settings. GsonBuilder follows the builder pattern, and it is typically used by first
@@ -127,6 +132,9 @@ public GsonBuilder() {
     this.timeStyle = gson.timeStyle;
     this.factories.addAll(gson.builderFactories);
     this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+    this.state = gson.state;
+    this.forDisplay = gson.forDisplay;
+    this.globalContext = gson.globalContext;
   }
 
   /**
@@ -599,7 +607,7 @@ public Gson create() {
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
         serializeSpecialFloatingPointValues, longSerializationPolicy,
         datePattern, dateStyle, timeStyle,
-        this.factories, this.hierarchyFactories, factories);
+        this.factories, this.hierarchyFactories, factories, globalContext, forDisplay, state);
   }
 
   @SuppressWarnings("unchecked")
@@ -624,4 +632,20 @@ private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeS
     factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
     factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
   }
+
+public void setJsonGlobalContext(JsonGlobalContext globalContext) {
+   this.globalContext = globalContext;
+}
+
+public GsonBuilder setState(State s) {
+   state = s;
+  return this;
+}
+
+public GsonBuilder forDisplay() {
+   forDisplay = true;
+   return this;
+ }
+  
+  
 }
diff --git a/gson/src/main/java/com/google/gson/Initializer.java b/gson/src/main/java/com/google/gson/Initializer.java
new file mode 100644
index 000000000..6cf558684
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/Initializer.java
@@ -0,0 +1,6 @@
+package com.google.gson;
+
+public interface Initializer
+{
+   public void initialize(JsonGlobalContext globalContext);
+}
diff --git a/gson/src/main/java/com/google/gson/InstanceInitializer.java b/gson/src/main/java/com/google/gson/InstanceInitializer.java
new file mode 100644
index 000000000..05aad6728
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/InstanceInitializer.java
@@ -0,0 +1,6 @@
+package com.google.gson;
+
+public interface InstanceInitializer<T>
+{
+   public void initialize(JsonGlobalContext globalContext, T t);
+}
diff --git a/gson/src/main/java/com/google/gson/JsonDeserializer.java b/gson/src/main/java/com/google/gson/JsonDeserializer.java
index 0589eb284..85e6e2a7e 100644
--- a/gson/src/main/java/com/google/gson/JsonDeserializer.java
+++ b/gson/src/main/java/com/google/gson/JsonDeserializer.java
@@ -86,6 +86,6 @@
    * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}
    * @throws JsonParseException if json is not in the expected format of {@code typeofT}
    */
-  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
       throws JsonParseException;
 }
diff --git a/gson/src/main/java/com/google/gson/JsonGlobalContext.java b/gson/src/main/java/com/google/gson/JsonGlobalContext.java
new file mode 100644
index 000000000..ff81f6ec9
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/JsonGlobalContext.java
@@ -0,0 +1,14 @@
+package com.google.gson;
+
+import com.praxem.google.ext.SaveMethod;
+
+public interface JsonGlobalContext
+{
+   public JsonGlobalContext getContext();
+   
+   public SaveMethod getSaveMethod();
+   
+   public boolean isRandomNumberActive();
+   
+   public double getRandomDouble();
+}
diff --git a/gson/src/main/java/com/google/gson/JsonSerializer.java b/gson/src/main/java/com/google/gson/JsonSerializer.java
index a60500336..ddc61e418 100644
--- a/gson/src/main/java/com/google/gson/JsonSerializer.java
+++ b/gson/src/main/java/com/google/gson/JsonSerializer.java
@@ -85,5 +85,5 @@
    * @param typeOfSrc the actual type (fully genericized version) of the source object.
    * @return a JsonElement corresponding to the specified object.
    */
-  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);
+  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext);
 }
diff --git a/gson/src/main/java/com/google/gson/annotations/AllState.java b/gson/src/main/java/com/google/gson/annotations/AllState.java
new file mode 100644
index 000000000..db2e00e37
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/AllState.java
@@ -0,0 +1,12 @@
+package com.google.gson.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface AllState
+{
+}
diff --git a/gson/src/main/java/com/google/gson/annotations/ExcludeWhenCleanSave.java b/gson/src/main/java/com/google/gson/annotations/ExcludeWhenCleanSave.java
new file mode 100644
index 000000000..67b759c4e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/ExcludeWhenCleanSave.java
@@ -0,0 +1,12 @@
+package com.google.gson.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface ExcludeWhenCleanSave
+{
+}
diff --git a/gson/src/main/java/com/google/gson/annotations/ExcludeWhenDisplay.java b/gson/src/main/java/com/google/gson/annotations/ExcludeWhenDisplay.java
new file mode 100644
index 000000000..c53430fa6
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/ExcludeWhenDisplay.java
@@ -0,0 +1,12 @@
+package com.google.gson.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface ExcludeWhenDisplay
+{
+}
diff --git a/codegen/src/test/java/com/google/gson/codegen/functional/CodeGenFunctionalTest.java b/gson/src/main/java/com/google/gson/annotations/State.java
similarity index 51%
rename from codegen/src/test/java/com/google/gson/codegen/functional/CodeGenFunctionalTest.java
rename to gson/src/main/java/com/google/gson/annotations/State.java
index 855ee3faf..42ed16379 100644
--- a/codegen/src/test/java/com/google/gson/codegen/functional/CodeGenFunctionalTest.java
+++ b/gson/src/main/java/com/google/gson/annotations/State.java
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2012 Google Inc.
+ * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -13,14 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.codegen.functional;
 
-import junit.framework.TestCase;
+package com.google.gson.annotations;
 
-public class CodeGenFunctionalTest extends TestCase {
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
-  public void testGeneratedJson() {
-    Order order = new Order("toy", 10);
-    // TODO: figure out how to access the generated type adapter
-  }
-}
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface State {
+  
+  public boolean base() default false;
+
+  public boolean factory() default false;
+  
+  public boolean instance() default false;
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index 6b83757ed..14463f2e5 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -16,23 +16,29 @@
 
 package com.google.gson.internal;
 
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 import com.google.gson.ExclusionStrategy;
 import com.google.gson.FieldAttributes;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.annotations.AllState;
+import com.google.gson.annotations.ExcludeWhenCleanSave;
+import com.google.gson.annotations.ExcludeWhenDisplay;
 import com.google.gson.annotations.Expose;
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import com.praxem.google.ext.SaveMethod;
+import com.praxem.google.ext.State;
 
 /**
  * This class selects which fields and types to omit. It is configurable,
@@ -57,6 +63,9 @@
   private boolean requireExpose;
   private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();
   private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();
+  private SaveMethod saveMethod;
+  private boolean forDisplay;
+  private State state;
 
   @Override protected Excluder clone() {
     try {
@@ -109,8 +118,14 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
   }
 
   public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
-    Class<?> rawType = type.getRawType();
-    boolean excludeClass = excludeClassChecks(rawType);
+     if (gson.getGlobalContext() != null)
+        this.saveMethod = gson.getGlobalContext().getSaveMethod();
+     
+     this.forDisplay = gson.isForDisplay();
+     this.state = gson.state();
+     
+     Class<?> rawType = type.getRawType();
+     boolean excludeClass = excludeClassChecks(rawType);
 
     final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
     final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
@@ -149,7 +164,41 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
   }
 
   public boolean excludeField(Field field, boolean serialize) {
-    if ((modifiers & field.getModifiers()) != 0) {
+     if (state != null)
+     {
+        AllState as = field.getAnnotation(AllState.class);
+        if (as == null)
+        {
+           com.google.gson.annotations.State annotation = field.getAnnotation(com.google.gson.annotations.State.class);
+           if (state == State.BASE)
+           {
+              if (!annotation.base())
+                 return true;
+           }
+           else if (state == State.FACTORY)
+           {
+              if (!annotation.factory())
+                 return true;
+           }
+           else if (state == State.INSTANCE)
+           {
+              if (!annotation.instance())
+                 return true;
+           }
+        }
+     }
+     
+     ExcludeWhenDisplay exExcludeWhenDisplay = field.getAnnotation(ExcludeWhenDisplay.class);
+     if (serialize && forDisplay && exExcludeWhenDisplay != null) {
+        return true; 
+     }
+     
+     ExcludeWhenCleanSave exAnnotation = field.getAnnotation(ExcludeWhenCleanSave.class);
+     if (serialize && saveMethod == SaveMethod.CLEAN && exAnnotation != null) {
+        return true; 
+     }
+     
+     if ((modifiers & field.getModifiers()) != 0) {
       return true;
     }
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CopyOfReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CopyOfReflectiveTypeAdapterFactory.java
new file mode 100644
index 000000000..7cb84620d
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/CopyOfReflectiveTypeAdapterFactory.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal.bind;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.google.gson.FieldNamingStrategy;
+import com.google.gson.Gson;
+import com.google.gson.Initializer;
+import com.google.gson.InstanceInitializer;
+import com.google.gson.JsonGlobalContext;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.ConstructorConstructor;
+import com.google.gson.internal.Excluder;
+import com.google.gson.internal.ObjectConstructor;
+import com.google.gson.internal.Primitives;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+
+/**
+ * Type adapter that reflects over the fields and methods of a class.
+ */
+public final class CopyOfReflectiveTypeAdapterFactory implements TypeAdapterFactory {
+  private final ConstructorConstructor constructorConstructor;
+  private final FieldNamingStrategy fieldNamingPolicy;
+  private final Excluder excluder;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+
+  public CopyOfReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
+    this.constructorConstructor = constructorConstructor;
+    this.fieldNamingPolicy = fieldNamingPolicy;
+    this.excluder = excluder;
+    this.jsonAdapterFactory = jsonAdapterFactory;
+  }
+
+  public boolean excludeField(Field f, boolean serialize) {
+    return excludeField(f, serialize, excluder);
+  }
+
+  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
+    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);
+  }
+
+  /** first element holds the default name */
+  private List<String> getFieldNames(Field f) {
+    SerializedName annotation = f.getAnnotation(SerializedName.class);
+    if (annotation == null) {
+      String name = fieldNamingPolicy.translateName(f);
+      return Collections.singletonList(name);
+    }
+
+    String serializedName = annotation.value();
+    String[] alternates = annotation.alternate();
+    if (alternates.length == 0) {
+      return Collections.singletonList(serializedName);
+    }
+
+    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);
+    fieldNames.add(serializedName);
+    for (String alternate : alternates) {
+      fieldNames.add(alternate);
+    }
+    return fieldNames;
+  }
+
+  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+    Class<? super T> raw = type.getRawType();
+
+    if (!Object.class.isAssignableFrom(raw)) {
+      return null; // it's a primitive!
+    }
+
+    ObjectConstructor<T> constructor = constructorConstructor.get(type);
+    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
+  }
+
+  private CopyOfReflectiveTypeAdapterFactory.BoundField createBoundField(
+      final Gson context, final Field field, final String name,
+      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
+    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
+    // special casing primitives here saves ~5% on Android...
+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+    TypeAdapter<?> mapped = null;
+    if (annotation != null) {
+      mapped = jsonAdapterFactory.getTypeAdapter(
+          constructorConstructor, context, fieldType, annotation);
+    }
+    final boolean jsonAdapterPresent = mapped != null;
+    if (mapped == null) mapped = context.getAdapter(fieldType);
+
+    final TypeAdapter<?> typeAdapter = mapped;
+    return new CopyOfReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize, context.getGlobalContext()) {
+      @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
+      @Override void write(JsonWriter writer, Object value)
+          throws IOException, IllegalAccessException {
+        Object fieldValue = field.get(value);
+        TypeAdapter t = jsonAdapterPresent ? typeAdapter
+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
+        t.write(writer, fieldValue);
+      }
+      @Override void read(JsonReader reader, Object value)
+          throws IOException, IllegalAccessException {
+        Object fieldValue = typeAdapter.read(reader);
+        if (fieldValue != null || !isPrimitive) {
+          field.set(value, fieldValue);
+        }
+      }
+      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
+        if (!serialized) return false;
+        Object fieldValue = field.get(value);
+        return fieldValue != value; // avoid recursion for example for Throwable.cause
+      }
+    };
+  }
+
+  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
+    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
+    if (raw.isInterface()) {
+      return result;
+    }
+
+    Type declaredType = type.getType();
+    while (raw != Object.class) {
+      Field[] fields = raw.getDeclaredFields();
+      for (Field field : fields) {
+        boolean serialize = excludeField(field, true);
+        boolean deserialize = excludeField(field, false);
+        if (!serialize && !deserialize) {
+          continue;
+        }
+        field.setAccessible(true);
+        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
+        List<String> fieldNames = getFieldNames(field);
+        BoundField previous = null;
+        for (int i = 0, size = fieldNames.size(); i < size; ++i) {
+          String name = fieldNames.get(i);
+          if (i != 0) serialize = false; // only serialize the default name
+          BoundField boundField = createBoundField(context, field, name,
+              TypeToken.get(fieldType), serialize, deserialize);
+          BoundField replaced = result.put(name, boundField);
+          if (previous == null) previous = replaced;
+        }
+        if (previous != null) {
+          throw new IllegalArgumentException(declaredType
+              + " declares multiple JSON fields named " + previous.name);
+        }
+      }
+      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));
+      raw = type.getRawType();
+    }
+    return result;
+  }
+
+  static abstract class BoundField {
+    final String name;
+    final boolean serialized;
+    final boolean deserialized;
+    final JsonGlobalContext globalContext;
+
+    protected BoundField(String name, boolean serialized, boolean deserialized, JsonGlobalContext globalContext) {
+      this.name = name;
+      this.serialized = serialized;
+      this.deserialized = deserialized;
+      this.globalContext = globalContext;
+    }
+    abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
+    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
+    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;
+  }
+
+  public static final class Adapter<T> extends TypeAdapter<T> {
+    private final ObjectConstructor<T> constructor;
+    private final Map<String, BoundField> boundFields;
+
+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
+      this.constructor = constructor;
+      this.boundFields = boundFields;
+    }
+
+    @SuppressWarnings("unchecked")
+   @Override public T read(JsonReader in) throws IOException {
+      if (in.peek() == JsonToken.NULL) {
+        in.nextNull();
+        return null;
+      }
+
+      T instance = constructor.construct();
+      JsonGlobalContext globalContext = null;
+
+      try {
+        in.beginObject();
+        while (in.hasNext()) {
+          String name = in.nextName();
+          BoundField field = boundFields.get(name);
+          
+          if (globalContext == null && field != null)
+         	 globalContext = field.globalContext;
+          
+          if (field == null || !field.deserialized) {
+            in.skipValue();
+          } else {
+            field.read(in, instance);
+          }
+        }
+      } catch (IllegalStateException e) {
+        throw new JsonSyntaxException(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+      in.endObject();
+      
+      if (instance instanceof Initializer)
+      {
+      	if (globalContext == null)
+      		System.out.println("Warning - globalContext is null");
+      	
+      	((Initializer)instance).initialize(globalContext);
+      }
+      
+      if (instance instanceof InstanceInitializer<?>)
+      {
+      	if (globalContext == null)
+      		System.out.println("Warning - globalContext is null");
+      	
+      	((InstanceInitializer<T>)instance).initialize(globalContext, instance);
+      }
+      
+      return instance;
+    }
+
+    @Override public void write(JsonWriter out, T value) throws IOException {
+      if (value == null) {
+        out.nullValue();
+        return;
+      }
+
+      out.beginObject();
+      try {
+        for (BoundField boundField : boundFields.values()) {
+          if (boundField.writeField(value)) {
+            out.name(boundField.name);
+            boundField.write(out, value);
+          }
+        }
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+      out.endObject();
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 777e7dee3..bcc6204ee 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -16,8 +16,20 @@
 
 package com.google.gson.internal.bind;
 
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
+import com.google.gson.Initializer;
+import com.google.gson.InstanceInitializer;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
@@ -33,14 +45,6 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -117,7 +121,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     if (mapped == null) mapped = context.getAdapter(fieldType);
 
     final TypeAdapter<?> typeAdapter = mapped;
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize, context.getGlobalContext()) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
@@ -183,11 +187,13 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     final String name;
     final boolean serialized;
     final boolean deserialized;
+    final JsonGlobalContext globalContext;
 
-    protected BoundField(String name, boolean serialized, boolean deserialized) {
+    protected BoundField(String name, boolean serialized, boolean deserialized, JsonGlobalContext globalContext) {
       this.name = name;
       this.serialized = serialized;
       this.deserialized = deserialized;
+      this.globalContext = globalContext;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
@@ -210,12 +216,17 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
       }
 
       T instance = constructor.construct();
+      JsonGlobalContext globalContext = null;
 
       try {
         in.beginObject();
         while (in.hasNext()) {
           String name = in.nextName();
           BoundField field = boundFields.get(name);
+          
+          if (globalContext == null && field != null)
+         	 globalContext = field.globalContext;
+          
           if (field == null || !field.deserialized) {
             in.skipValue();
           } else {
@@ -228,6 +239,23 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
         throw new AssertionError(e);
       }
       in.endObject();
+      
+      if (instance instanceof Initializer)
+      {
+      	if (globalContext == null)
+      		System.out.println("Warning - globalContext is null");
+      	
+      	((Initializer)instance).initialize(globalContext);
+      }
+      
+      if (instance instanceof InstanceInitializer<?>)
+      {
+      	if (globalContext == null)
+      		System.out.println("Warning - globalContext is null");
+      	
+      	((InstanceInitializer<T>)instance).initialize(globalContext, instance);
+      }
+      
       return instance;
     }
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index a5c6c5dcd..30da9c0dc 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -66,7 +66,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
     if (value.isJsonNull()) {
       return null;
     }
-    return deserializer.deserialize(value, typeToken.getType(), context);
+    return deserializer.deserialize(value, typeToken.getType(), context, gson.getGlobalContext());
   }
 
   @Override public void write(JsonWriter out, T value) throws IOException {
@@ -78,7 +78,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
       out.nullValue();
       return;
     }
-    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);
+    JsonElement tree = serializer.serialize(value, typeToken.getType(), context, gson.getGlobalContext());
     Streams.write(tree, out);
   }
 
diff --git a/gson/src/main/java/com/praxem/google/ext/SaveMethod.java b/gson/src/main/java/com/praxem/google/ext/SaveMethod.java
new file mode 100644
index 000000000..1b242467e
--- /dev/null
+++ b/gson/src/main/java/com/praxem/google/ext/SaveMethod.java
@@ -0,0 +1,6 @@
+package com.praxem.google.ext;
+
+public enum SaveMethod
+{
+   FULL, CLEAN  
+}
diff --git a/gson/src/main/java/com/praxem/google/ext/State.java b/gson/src/main/java/com/praxem/google/ext/State.java
new file mode 100644
index 000000000..ad7f72527
--- /dev/null
+++ b/gson/src/main/java/com/praxem/google/ext/State.java
@@ -0,0 +1,6 @@
+package com.praxem.google.ext;
+
+public enum State
+{
+   BASE, FACTORY, INSTANCE  
+}
diff --git a/gson/src/main/java/com/praxem/google/ext/package-info.java b/gson/src/main/java/com/praxem/google/ext/package-info.java
new file mode 100644
index 000000000..65b5697bc
--- /dev/null
+++ b/gson/src/main/java/com/praxem/google/ext/package-info.java
@@ -0,0 +1,8 @@
+/**
+ * 
+ */
+/**
+ * @author Utilisateur
+ *
+ */
+package com.praxem.google.ext;
\ No newline at end of file
diff --git a/gson/src/main/java/module-info.java b/gson/src/main/java/module-info.java
index d567d8ce5..cc37adcbf 100644
--- a/gson/src/main/java/module-info.java
+++ b/gson/src/main/java/module-info.java
@@ -3,6 +3,7 @@
 	exports com.google.gson.annotations;
 	exports com.google.gson.reflect;
 	exports com.google.gson.stream;
+	exports com.praxem.google.ext;
 
 	requires java.sql;
 }
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index eec2ec91c..6d636f8eb 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -49,7 +49,7 @@ public void testOverridesDefaultExcluder() {
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
-        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(), null, false, null);
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
@@ -62,7 +62,7 @@ public void testClonedTypeAdapterFactoryListsAreIndependent() {
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
-        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(), null, false, null);
 
     Gson clone = original.newBuilder()
         .registerTypeAdapter(Object.class, new TestTypeAdapter())
@@ -70,6 +70,25 @@ public void testClonedTypeAdapterFactoryListsAreIndependent() {
 
     assertEquals(original.factories.size() + 1, clone.factories.size());
   }
+  
+  public void testPraxarExt() {
+     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
+         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+         true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(), null, false, null);
+
+     Gson clone = original.newBuilder()
+         .registerTypeAdapter(Object.class, new TestTypeAdapter())
+         .create();
+
+     assertEquals(original.isForDisplay(), false);
+     assertEquals(clone.isForDisplay(), false);
+     
+     assertEquals(original.getGlobalContext(), null);
+     assertEquals(clone.getGlobalContext(), null);
+   }
+  
 
   private static final class TestTypeAdapter extends TypeAdapter<Object> {
     @Override public void write(JsonWriter out, Object value) throws IOException {
diff --git a/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java b/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
index decb93d83..2738def27 100644
--- a/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
@@ -81,11 +81,11 @@ public void testTypeAdapterDoesNotAffectNonAdaptedTypes() throws Exception {
   private static class ExceptionTypeAdapter
       implements JsonSerializer<AtomicLong>, JsonDeserializer<AtomicLong> {
     @Override public JsonElement serialize(
-        AtomicLong src, Type typeOfSrc, JsonSerializationContext context) {
+        AtomicLong src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       throw new IllegalStateException();
     }
     @Override public AtomicLong deserialize(
-        JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       throw new IllegalStateException();
     }
@@ -93,11 +93,11 @@ public void testTypeAdapterDoesNotAffectNonAdaptedTypes() throws Exception {
 
   private static class AtomicIntegerTypeAdapter
       implements JsonSerializer<AtomicInteger>, JsonDeserializer<AtomicInteger> {
-    @Override public JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context) {
+    @Override public JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive(src.incrementAndGet());
     }
 
-    @Override public AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    @Override public AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       int intValue = json.getAsInt();
       return new AtomicInteger(--intValue);
@@ -131,7 +131,7 @@ private void assertSerialized(String expected, Class<?> instanceType, boolean re
       boolean registerAbstractHierarchyDeserializer, Object instance) {
     JsonDeserializer<Abstract> deserializer = new JsonDeserializer<Abstract>() {
       public Abstract deserialize(JsonElement json, Type typeOfT,
-          JsonDeserializationContext context) throws JsonParseException {
+          JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
         throw new AssertionError();
       }
     };
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index 0959ee429..b17389c87 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -143,7 +143,7 @@ public MyParameterizedTypeInstanceCreator(T instanceOfT) {
     }
 
     @Override public JsonElement serialize(MyParameterizedType<T> src, Type classOfSrc,
-        JsonSerializationContext context) {
+        JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject json = new JsonObject();
       T value = src.getValue();
       json.add(value.getClass().getSimpleName(), context.serialize(value));
@@ -152,7 +152,7 @@ public MyParameterizedTypeInstanceCreator(T instanceOfT) {
 
     @SuppressWarnings("unchecked")
     @Override public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,
-        JsonDeserializationContext context) throws JsonParseException {
+        JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];
       Class<?> rawType = $Gson$Types.getRawType(genericClass);
       String className = rawType.getSimpleName();
diff --git a/gson/src/test/java/com/google/gson/common/TestTypes.java b/gson/src/test/java/com/google/gson/common/TestTypes.java
index 11d3d0abe..e554953be 100644
--- a/gson/src/test/java/com/google/gson/common/TestTypes.java
+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java
@@ -22,6 +22,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
@@ -78,7 +79,7 @@ public ClassWithBaseCollectionField(Collection<Base> base) {
   public static class BaseSerializer implements JsonSerializer<Base> {
     public static final String NAME = BaseSerializer.class.getSimpleName(); 
     @Override
-    public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject obj = new JsonObject();
       obj.addProperty(Base.SERIALIZER_KEY, NAME);
       return obj;
@@ -87,7 +88,7 @@ public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext
   public static class SubSerializer implements JsonSerializer<Sub> {
     public static final String NAME = SubSerializer.class.getSimpleName(); 
     @Override
-    public JsonElement serialize(Sub src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Sub src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject obj = new JsonObject();
       obj.addProperty(Base.SERIALIZER_KEY, NAME);
       return obj;
@@ -409,11 +410,11 @@ public String getExpectedJson() {
       implements JsonSerializer<Long>, JsonDeserializer<Long> {
     public static final long DIFFERENCE = 5L;
     @Override
-    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive(src + DIFFERENCE);
     }
     @Override
-    public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return json.getAsLong() - DIFFERENCE;
     }
diff --git a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
index d352e2418..b2695ffe8 100644
--- a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
@@ -19,16 +19,17 @@
 import java.util.ArrayList;
 import java.util.Collection;
 
-import junit.framework.TestCase;
-
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.common.TestTypes.ClassOverridingEquals;
 
+import junit.framework.TestCase;
+
 /**
  * Functional tests related to circular reference detection and error reporting.
  *
@@ -80,7 +81,7 @@ public void testSelfReferenceCustomHandlerSerialization() throws Exception {
     obj.child = obj;
     Gson gson = new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer<ClassWithSelfReference>() {
       public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,
-          JsonSerializationContext context) {
+          JsonSerializationContext context, JsonGlobalContext globalContext) {
         JsonObject obj = new JsonObject();
         obj.addProperty("property", "value");
         obj.add("child", context.serialize(src.child));
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index 4ec7378b2..08ff23141 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -34,6 +34,7 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
@@ -329,7 +330,7 @@ public void testUserCollectionTypeAdapter() {
     Type listOfString = new TypeToken<List<String>>() {}.getType();
     Object stringListSerializer = new JsonSerializer<List<String>>() {
       public JsonElement serialize(List<String> src, Type typeOfSrc,
-          JsonSerializationContext context) {
+          JsonSerializationContext context, JsonGlobalContext globalContext) {
         return new JsonPrimitive(src.get(0) + ";" + src.get(1));
       }
     };
diff --git a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
index c53db7f23..87707e8ef 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.common.TestTypes.Base;
@@ -102,7 +103,7 @@ public DataHolder getWrappedData() {
 
   private static class DataHolderDeserializer implements JsonDeserializer<DataHolder> {
     @Override
-    public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       JsonObject jsonObj = json.getAsJsonObject();
       String dataString = jsonObj.get("data").getAsString();
@@ -114,7 +115,7 @@ public void testJsonTypeFieldBasedDeserialization() {
     String json = "{field1:'abc',field2:'def',__type__:'SUB_TYPE1'}";
     Gson gson = new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer<MyBase>() {
       @Override public MyBase deserialize(JsonElement json, Type pojoType,
-          JsonDeserializationContext context) throws JsonParseException {
+          JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
         String type = json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();
         return context.deserialize(json, SubTypes.valueOf(type).getSubclass());
       }
@@ -152,7 +153,7 @@ public void testCustomDeserializerReturnsNullForTopLevelObject() {
     Gson gson = new GsonBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
-        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
             throws JsonParseException {
           return null;
         }
@@ -166,7 +167,7 @@ public void testCustomDeserializerReturnsNull() {
     Gson gson = new GsonBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
-        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
             throws JsonParseException {
           return null;
         }
@@ -180,7 +181,7 @@ public void testCustomDeserializerReturnsNullForArrayElements() {
     Gson gson = new GsonBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
-        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
             throws JsonParseException {
           return null;
         }
@@ -195,7 +196,7 @@ public void testCustomDeserializerReturnsNullForArrayElementsForArrayField() {
     Gson gson = new GsonBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
-        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
             throws JsonParseException {
           return null;
         }
diff --git a/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
index c8095463a..c83ae6af0 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
@@ -20,6 +20,7 @@
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
@@ -91,7 +92,7 @@ public void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInsta
    public void testSerializerReturnsNull() {
      Gson gson = new GsonBuilder()
        .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {
-         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
+         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
            return null;
          }
        })
diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index b452849dd..7c1c5f440 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
@@ -58,7 +59,7 @@ public void testCustomSerializers() {
     Gson gson = builder.registerTypeAdapter(
         ClassWithCustomTypeConverter.class, new JsonSerializer<ClassWithCustomTypeConverter>() {
           @Override public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc,
-              JsonSerializationContext context) {
+              JsonSerializationContext context, JsonGlobalContext globalContext) {
         JsonObject json = new JsonObject();
         json.addProperty("bag", 5);
         json.addProperty("value", 25);
@@ -73,7 +74,7 @@ public void testCustomDeserializers() {
     Gson gson = new GsonBuilder().registerTypeAdapter(
         ClassWithCustomTypeConverter.class, new JsonDeserializer<ClassWithCustomTypeConverter>() {
           @Override public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,
-              JsonDeserializationContext context) {
+              JsonDeserializationContext context, JsonGlobalContext globalContext) {
         JsonObject jsonObject = json.getAsJsonObject();
         int value = jsonObject.get("bag").getAsInt();
         return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,
@@ -110,7 +111,7 @@ public void testCustomNestedSerializers() {
     Gson gson = new GsonBuilder().registerTypeAdapter(
         BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {
           @Override public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,
-          JsonSerializationContext context) {
+          JsonSerializationContext context, JsonGlobalContext globalContext) {
         return new JsonPrimitive(6);
       }
     }).create();
@@ -122,7 +123,7 @@ public void testCustomNestedDeserializers() {
     Gson gson = new GsonBuilder().registerTypeAdapter(
         BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {
           @Override public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,
-          JsonDeserializationContext context) throws JsonParseException {
+          JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
         int value = json.getAsInt();
         return new BagOfPrimitives(value, value, false, "");
       }
@@ -135,7 +136,7 @@ public void testCustomNestedDeserializers() {
   public void testCustomTypeAdapterDoesNotAppliesToSubClasses() {
     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
       @Override
-      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
+      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
         JsonObject json = new JsonObject();
         json.addProperty("value", src.baseValue);
         return json;
@@ -152,7 +153,7 @@ public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext
   public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {
     Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
       @Override
-      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
+      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
         JsonObject json = new JsonObject();
         json.addProperty("value", src.baseValue);
         return json;
@@ -197,13 +198,13 @@ public Foo(int key, long value) {
 
   public static final class FooTypeAdapter implements JsonSerializer<Foo>, JsonDeserializer<Foo> {
     @Override
-    public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return context.deserialize(json, typeOfT);
     }
 
     @Override
-    public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return context.serialize(src, typeOfSrc);
     }
   }
@@ -211,7 +212,7 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
   public void testCustomSerializerInvokedForPrimitives() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(boolean.class, new JsonSerializer<Boolean>() {
-          @Override public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {
+          @Override public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c, JsonGlobalContext globalContext) {
             return new JsonPrimitive(s ? 1 : 0);
           }
         })
@@ -225,7 +226,7 @@ public void testCustomDeserializerInvokedForPrimitives() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(boolean.class, new JsonDeserializer() {
           @Override
-          public Object deserialize(JsonElement json, Type t, JsonDeserializationContext context) {
+          public Object deserialize(JsonElement json, Type t, JsonDeserializationContext context, JsonGlobalContext globalContext) {
             return json.getAsInt() != 0;
           }
         })
@@ -237,7 +238,7 @@ public Object deserialize(JsonElement json, Type t, JsonDeserializationContext c
   public void testCustomByteArraySerializer() {
     Gson gson = new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {
       @Override
-      public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {
+      public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
         StringBuilder sb = new StringBuilder(src.length);
         for (byte b : src) {
           sb.append(b);
@@ -254,7 +255,7 @@ public void testCustomByteArrayDeserializerAndInstanceCreator() {
     GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class,
         new JsonDeserializer<byte[]>() {
           @Override public byte[] deserialize(JsonElement json,
-              Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
+              Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
         String str = json.getAsString();
         byte[] data = new byte[str.length()];
         for (int i = 0; i < data.length; ++i) {
@@ -296,12 +297,12 @@ public StringHolder(String part1, String part2) {
     }
 
     @Override public StringHolder deserialize(JsonElement src, Type type,
-        JsonDeserializationContext context) {
+        JsonDeserializationContext context, JsonGlobalContext globalContext) {
       return new StringHolder(src.getAsString());
     }
 
     @Override public JsonElement serialize(StringHolder src, Type typeOfSrc,
-        JsonSerializationContext context) {
+        JsonSerializationContext context, JsonGlobalContext globalContext) {
       String contents = src.part1 + ':' + src.part2;
       return new JsonPrimitive(contents);
     }
@@ -430,7 +431,7 @@ public DataHolderWrapper(DataHolder data) {
 
   private static class DataHolderSerializer implements JsonSerializer<DataHolder> {
     @Override
-    public JsonElement serialize(DataHolder src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(DataHolder src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject obj = new JsonObject();
       obj.addProperty("myData", src.data);
       return obj;
@@ -439,7 +440,7 @@ public JsonElement serialize(DataHolder src, Type typeOfSrc, JsonSerializationCo
 
   private static class DataHolderDeserializer implements JsonDeserializer<DataHolder> {
     @Override
-    public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       JsonObject jsonObj = json.getAsJsonObject();
       JsonElement jsonElement = jsonObj.get("data");
@@ -452,13 +453,13 @@ public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializatio
 
   private static class DateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
     @Override
-    public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
+    public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext) {
       return typeOfT == Date.class
           ? new Date(json.getAsLong())
           : new java.sql.Date(json.getAsLong());
     }
     @Override
-    public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive(src.getTime());
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index f76dd18c3..516070217 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
@@ -493,7 +494,7 @@ public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws E
         .setDateFormat(pattern)
         .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
           public Date deserialize(JsonElement json, Type typeOfT,
-              JsonDeserializationContext context)
+              JsonDeserializationContext context, JsonGlobalContext globalContext )
               throws JsonParseException {
             return new Date(1315806903103L);
           }
diff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java
index 66b855ebf..203ee96d7 100644
--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java
@@ -27,6 +27,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
@@ -181,11 +182,11 @@ public void testEnumSet() {
 
   private static class MyEnumTypeAdapter
       implements JsonSerializer<Roshambo>, JsonDeserializer<Roshambo> {
-    @Override public JsonElement serialize(Roshambo src, Type typeOfSrc, JsonSerializationContext context) {
+    @Override public JsonElement serialize(Roshambo src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("123" + src.name());
     }
 
-    @Override public Roshambo deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context)
+    @Override public Roshambo deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return Roshambo.valueOf(json.getAsString().substring(3));
     }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index 4288bfe3b..50ac80a7b 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
@@ -89,7 +90,7 @@ public void testRegisteredAdapterOverridesJsonAdapter() {
   public void testRegisteredSerializerOverridesJsonAdapter() {
     JsonSerializer<A> serializer = new JsonSerializer<A>() {
       public JsonElement serialize(A src, Type typeOfSrc,
-          JsonSerializationContext context) {
+          JsonSerializationContext context, JsonGlobalContext globalContext) {
         return new JsonPrimitive("registeredSerializer");
       }
     };
@@ -108,7 +109,7 @@ public JsonElement serialize(A src, Type typeOfSrc,
   public void testRegisteredDeserializerOverridesJsonAdapter() {
     JsonDeserializer<A> deserializer = new JsonDeserializer<A>() {
       public A deserialize(JsonElement json, Type typeOfT,
-          JsonDeserializationContext context) throws JsonParseException {
+          JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
         return new A("registeredDeserializer");
       }
     };
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
index 8ab4e128a..2a9c48546 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
@@ -22,6 +22,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
@@ -65,14 +66,14 @@ private User(String name) {
 
   private static final class UserSerializer implements JsonSerializer<User> {
     @Override
-    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("UserSerializer");
     }
   }
 
   private static final class UserDeserializer implements JsonDeserializer<User> {
     @Override
-    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return new User("UserSerializer");
     }
@@ -80,11 +81,11 @@ public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationConte
 
   private static final class UserSerializerDeserializer implements JsonSerializer<User>, JsonDeserializer<User> {
     @Override
-    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("UserSerializerDeserializer");
     }
     @Override
-    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return new User("UserSerializerDeserializer");
     }
@@ -115,11 +116,11 @@ private User2(String name) {
 
   private static final class UserSerializerDeserializer2 implements JsonSerializer<User2>, JsonDeserializer<User2> {
     @Override
-    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("UserSerializerDeserializer2");
     }
     @Override
-    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       return new User2("UserSerializerDeserializer2");
     }
@@ -151,13 +152,13 @@ public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {
   }
 
   private static final class BaseStringAdapter implements JsonSerializer<Base<String>> {
-    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context) {
+    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("BaseStringAdapter");
     }
   }
 
   private static final class BaseIntegerAdapter implements JsonSerializer<Base<Integer>> {
-    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context) {
+    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive("BaseIntegerAdapter");
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index 154ecf558..b01bdf7e0 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -33,6 +33,7 @@
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonParser;
 import com.google.gson.JsonPrimitive;
@@ -300,7 +301,7 @@ public void testCustomSerializerForSpecificMapType() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(type, new JsonSerializer<Map<String, Long>>() {
           public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
-              JsonSerializationContext context) {
+              JsonSerializationContext context, JsonGlobalContext globalContext) {
             JsonArray array = new JsonArray();
             for (long value : src.values()) {
               array.add(new JsonPrimitive(value));
@@ -494,7 +495,7 @@ public final void testInterfaceTypeMapWithSerializer() {
 
     JsonSerializer<TestTypes.Base> baseTypeAdapter = new JsonSerializer<TestTypes.Base>() {
       public JsonElement serialize(TestTypes.Base src, Type typeOfSrc,
-          JsonSerializationContext context) {
+          JsonSerializationContext context, JsonGlobalContext globalContext) {
         return baseTypeJsonElement;
       }
     };
diff --git a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
index 7939a8c85..8bedb5897 100644
--- a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
@@ -19,6 +19,7 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonDeserializationContext;
@@ -193,7 +194,7 @@ public ClassWithInitializedMembers() {
   
   private static class ClassWithObjectsSerializer implements JsonSerializer<ClassWithObjects> {
     @Override public JsonElement serialize(ClassWithObjects src, Type typeOfSrc,
-        JsonSerializationContext context) {
+        JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject obj = new JsonObject();
       obj.add("bag", JsonNull.INSTANCE);
       return obj;
@@ -211,7 +212,7 @@ public void testCustomTypeAdapterPassesNullSerialization() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(ObjectWithField.class, new JsonSerializer<ObjectWithField>() {
           @Override public JsonElement serialize(ObjectWithField src, Type typeOfSrc,
-              JsonSerializationContext context) {
+              JsonSerializationContext context, JsonGlobalContext globalContext) {
             return context.serialize(null);
           }
         }).create();
@@ -225,7 +226,7 @@ public void testCustomTypeAdapterPassesNullDesrialization() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(ObjectWithField.class, new JsonDeserializer<ObjectWithField>() {
           @Override public ObjectWithField deserialize(JsonElement json, Type type,
-              JsonDeserializationContext context) {
+              JsonDeserializationContext context, JsonGlobalContext globalContext) {
             return context.deserialize(null, type);
           }
         }).create();
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index 48508f83b..8a58e1067 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -20,6 +20,7 @@
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
@@ -294,7 +295,7 @@ public void testAnonymousLocalClassesCustomSerialization() throws Exception {
         .registerTypeHierarchyAdapter(ClassWithNoFields.class,
             new JsonSerializer<ClassWithNoFields>() {
               public JsonElement serialize(
-                  ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {
+                  ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
                 return new JsonObject();
               }
             }).create();
diff --git a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
index ad737ec51..e745394a5 100644
--- a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
@@ -29,6 +29,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
@@ -95,7 +96,7 @@ public String getValue() {
 
     @SuppressWarnings("rawtypes")
     @Override
-    public Id<?> deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    public Id<?> deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       if (!(typeOfT instanceof ParameterizedType)) {
         throw new JsonParseException("Id of unknown type: " + typeOfT);
@@ -108,7 +109,7 @@ public String getValue() {
     }
 
     @Override
-    public JsonElement serialize(Id<?> src, Type typeOfSrc, JsonSerializationContext context) {
+    public JsonElement serialize(Id<?> src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive(src.getValue());
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
index 5f881530d..71a480782 100644
--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
@@ -123,7 +124,7 @@ private Foo(String name) {
   private JsonSerializer<Foo> newSerializer(final String name) {
     return new JsonSerializer<Foo>() {
       @Override
-      public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {
+      public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
         return new JsonPrimitive(src.name + " via " + name);
       }
     };
@@ -132,7 +133,7 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
   private JsonDeserializer<Foo> newDeserializer(final String name) {
     return new JsonDeserializer<Foo>() {
       @Override
-      public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
+      public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext) {
         return new Foo(json.getAsString() + " via " + name);
       }
     };
diff --git a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
index 25b9c3436..d3edc07ee 100644
--- a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
@@ -21,6 +21,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonPrimitive;
@@ -140,19 +141,19 @@ public void testRegisterSubTypeFirstAllowed() {
   }
 
   static class ManagerAdapter implements JsonSerializer<Manager>, JsonDeserializer<Manager> {
-    @Override public Manager deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
+    @Override public Manager deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext) {
       Manager result = new Manager();
       result.userid = json.getAsString();
       return result;
     }
-    @Override public JsonElement serialize(Manager src, Type typeOfSrc, JsonSerializationContext context) {
+    @Override public JsonElement serialize(Manager src, Type typeOfSrc, JsonSerializationContext context, JsonGlobalContext globalContext) {
       return new JsonPrimitive(src.userid);
     }
   }
 
   static class EmployeeAdapter implements JsonSerializer<Employee>, JsonDeserializer<Employee> {
     @Override public JsonElement serialize(Employee employee, Type typeOfSrc,
-        JsonSerializationContext context) {
+        JsonSerializationContext context, JsonGlobalContext globalContext) {
       JsonObject result = new JsonObject();
       result.add("userid", context.serialize(employee.userid, String.class));
       result.add("startDate", context.serialize(employee.startDate, long.class));
@@ -166,7 +167,7 @@ public void testRegisterSubTypeFirstAllowed() {
     }
 
     @Override public Employee deserialize(JsonElement json, Type typeOfT,
-        JsonDeserializationContext context) throws JsonParseException {
+        JsonDeserializationContext context, JsonGlobalContext globalContext) throws JsonParseException {
       JsonObject object = json.getAsJsonObject();
       Employee result = null;
 
diff --git a/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java b/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
index 0ac038035..9434770fc 100644
--- a/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
+++ b/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
@@ -20,6 +20,7 @@
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
 import com.google.gson.JsonElement;
+import com.google.gson.JsonGlobalContext;
 import com.google.gson.JsonParseException;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.ClassOverridingEquals;
@@ -118,7 +119,7 @@ public void testTrailingWhitespace() throws Exception {
     Derived2() { opType = OperationType.OP2; }
   }
   private static class BaseTypeAdapter implements JsonDeserializer<Base> {
-    @Override public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+    @Override public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context, JsonGlobalContext globalContext)
         throws JsonParseException {
       String opTypeStr = json.getAsJsonObject().get("opType").getAsString();
       OperationType opType = OperationType.valueOf(opTypeStr);
diff --git a/metrics/pom.xml b/metrics/pom.xml
deleted file mode 100644
index 9a084452c..000000000
--- a/metrics/pom.xml
+++ /dev/null
@@ -1,141 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-metrics</artifactId>
-  <packaging>jar</packaging>
-  <version>1.0-SNAPSHOT</version>
-  <inceptionYear>2011</inceptionYear>
-  <name>Gson Metrics</name>
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>5</version>
-  </parent>
-  <url>http://code.google.com/p/google-gson/</url>
-  <description>Performance Metrics for Google Gson library</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:svn:http://google-gson.googlecode.com/svn/trunk/metrics</connection>
-    <developerConnection>scm:svn:https://google-gson.googlecode.com/svn/trunk/metrics</developerConnection>
-    <url>http://google-gson.codegoogle.com/svn/trunk/metrics</url>
-  </scm>
-  <issueManagement>
-    <system>Google Code Issue Tracking</system>
-    <url>http://code.google.com/p/google-gson/issues/list</url>
-  </issueManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <version>1.7.2-SNAPSHOT</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.caliper</groupId>
-      <artifactId>caliper</artifactId>
-      <version>1.0-SNAPSHOT</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.2</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <build>
-    <defaultGoal>package</defaultGoal>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.3.2</version>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-eclipse-plugin</artifactId>
-        <version>2.8</version>
-        <configuration>
-          <downloadSources>true</downloadSources>
-          <downloadJavadocs>true</downloadJavadocs>
-          <workspace>../eclipse-ws/</workspace>
-          <workspaceCodeStylesURL>
-            file:///${basedir}/../lib/gson-formatting-styles.xml
-          </workspaceCodeStylesURL>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.1</version>
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-          <tagBase>https://google-gson.googlecode.com/svn/tags/</tagBase>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-source-plugin</artifactId>
-        <version>2.1.2</version>
-        <executions>
-          <execution>
-            <id>attach-sources</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.7</version>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <links>
-            <link>http://download.oracle.com/javase/1.5.0/docs/api/</link>
-          </links>
-          <version>true</version>
-          <show>public</show>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Google Inc.</organization>
-    </developer>
-  </developers>
-</project>
diff --git a/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitives.java b/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitives.java
deleted file mode 100644
index 72cd6b6d1..000000000
--- a/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitives.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.metrics;
-
-/**
- * Class with a bunch of primitive fields
- *
- * @author Inderjeet Singh
- */
-public class BagOfPrimitives {
-  public static final long DEFAULT_VALUE = 0;
-  public long longValue;
-  public int intValue;
-  public boolean booleanValue;
-  public String stringValue;
-
-  public BagOfPrimitives() {
-    this(DEFAULT_VALUE, 0, false, "");
-  }
-
-  public BagOfPrimitives(long longValue, int intValue, boolean booleanValue, String stringValue) {
-    this.longValue = longValue;
-    this.intValue = intValue;
-    this.booleanValue = booleanValue;
-    this.stringValue = stringValue;
-  }
-
-  public int getIntValue() {
-    return intValue;
-  }
-
-  public String getExpectedJson() {
-    StringBuilder sb = new StringBuilder();
-    sb.append("{");
-    sb.append("\"longValue\":").append(longValue).append(",");
-    sb.append("\"intValue\":").append(intValue).append(",");
-    sb.append("\"booleanValue\":").append(booleanValue).append(",");
-    sb.append("\"stringValue\":\"").append(stringValue).append("\"");
-    sb.append("}");
-    return sb.toString();
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + (booleanValue ? 1231 : 1237);
-    result = prime * result + intValue;
-    result = prime * result + (int) (longValue ^ (longValue >>> 32));
-    result = prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    BagOfPrimitives other = (BagOfPrimitives) obj;
-    if (booleanValue != other.booleanValue)
-      return false;
-    if (intValue != other.intValue)
-      return false;
-    if (longValue != other.longValue)
-      return false;
-    if (stringValue == null) {
-      if (other.stringValue != null)
-        return false;
-    } else if (!stringValue.equals(other.stringValue))
-      return false;
-    return true;
-  }
-
-  @Override
-  public String toString() {
-    return String.format("(longValue=%d,intValue=%d,booleanValue=%b,stringValue=%s)",
-        longValue, intValue, booleanValue, stringValue);
-  }
-}
diff --git a/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitivesDeserializationBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitivesDeserializationBenchmark.java
deleted file mode 100644
index 8e6ea2b24..000000000
--- a/metrics/src/main/java/com/google/gson/metrics/BagOfPrimitivesDeserializationBenchmark.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.metrics;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.lang.reflect.Field;
-
-import com.google.caliper.Runner;
-import com.google.caliper.SimpleBenchmark;
-import com.google.gson.Gson;
-import com.google.gson.stream.JsonReader;
-
-/**
- * Caliper based micro benchmarks for Gson
- *
- * @author Inderjeet Singh
- * @author Jesse Wilson
- * @author Joel Leitch
- */
-public class BagOfPrimitivesDeserializationBenchmark extends SimpleBenchmark {
-
-  private Gson gson;
-  private String json;
-
-  public static void main(String[] args) {
-    Runner.main(BagOfPrimitivesDeserializationBenchmark.class, args);
-  }
-  
-  @Override
-  protected void setUp() throws Exception {
-    this.gson = new Gson();
-    BagOfPrimitives bag = new BagOfPrimitives(10L, 1, false, "foo");
-    this.json = gson.toJson(bag);
-  }
-
-  /** 
-   * Benchmark to measure Gson performance for deserializing an object
-   */
-  public void timeBagOfPrimitivesDefault(int reps) {
-    for (int i=0; i<reps; ++i) {
-      gson.fromJson(json, BagOfPrimitives.class);
-    }
-  }
-
-  /**
-   * Benchmark to measure deserializing objects by hand
-   */
-  public void timeBagOfPrimitivesStreaming(int reps) throws IOException {
-    for (int i=0; i<reps; ++i) {
-      StringReader reader = new StringReader(json);
-      JsonReader jr = new JsonReader(reader);
-      jr.beginObject();
-      long longValue = 0;
-      int intValue = 0;
-      boolean booleanValue = false;
-      String stringValue = null;
-      while(jr.hasNext()) {
-        String name = jr.nextName();
-        if (name.equals("longValue")) {
-          longValue = jr.nextLong();
-        } else if (name.equals("intValue")) {
-          intValue = jr.nextInt();
-        } else if (name.equals("booleanValue")) {
-          booleanValue = jr.nextBoolean();
-        } else if (name.equals("stringValue")) {
-          stringValue = jr.nextString();
-        } else {
-          throw new IOException("Unexpected name: " + name);
-        }
-      }
-      jr.endObject();
-      new BagOfPrimitives(longValue, intValue, booleanValue, stringValue);
-    }
-  }
-
-  /**
-   * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and
-   * setting object values by reflection. We should strive to reduce the discrepancy between this
-   * and {@link #timeBagOfPrimitivesDefault(int)} .
-   */
-  public void timeBagOfPrimitivesReflectionStreaming(int reps) throws Exception {
-    for (int i=0; i<reps; ++i) {
-      StringReader reader = new StringReader(json);
-      JsonReader jr = new JsonReader(reader);
-      jr.beginObject();
-      BagOfPrimitives bag = new BagOfPrimitives();
-      while(jr.hasNext()) {
-        String name = jr.nextName();
-        for (Field field : BagOfPrimitives.class.getDeclaredFields()) {
-          if (field.getName().equals(name)) {
-            Class<?> fieldType = field.getType();
-            if (fieldType.equals(long.class)) {
-              field.setLong(bag, jr.nextLong());
-            } else if (fieldType.equals(int.class)) {
-              field.setInt(bag, jr.nextInt());
-            } else if (fieldType.equals(boolean.class)) {
-              field.setBoolean(bag, jr.nextBoolean());
-            } else if (fieldType.equals(String.class)) {
-              field.set(bag, jr.nextString());
-            } else {
-              throw new RuntimeException("Unexpected: type: " + fieldType + ", name: " + name);
-            }
-          }
-        }
-      }
-      jr.endObject();
-    }
-  }
-}
diff --git a/metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java
deleted file mode 100644
index 09a5782ab..000000000
--- a/metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.metrics;
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.google.caliper.Runner;
-import com.google.caliper.SimpleBenchmark;
-import com.google.gson.Gson;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-
-/**
- * Caliper based micro benchmarks for Gson
- *
- * @author Inderjeet Singh
- */
-public class CollectionsDeserializationBenchmark extends SimpleBenchmark {
-
-  private static final Type LIST_TYPE = new TypeToken<List<BagOfPrimitives>>(){}.getType();
-  private Gson gson;
-  private String json;
-
-  public static void main(String[] args) {
-    Runner.main(CollectionsDeserializationBenchmark.class, args);
-  }
-  
-  @Override
-  protected void setUp() throws Exception {
-    this.gson = new Gson();
-    List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();
-    for (int i = 0; i < 100; ++i) {
-      bags.add(new BagOfPrimitives(10L, 1, false, "foo"));
-    }
-    this.json = gson.toJson(bags, LIST_TYPE);
-  }
-
-  /** 
-   * Benchmark to measure Gson performance for deserializing an object
-   */
-  public void timeCollectionsDefault(int reps) {
-    for (int i=0; i<reps; ++i) {
-      gson.fromJson(json, LIST_TYPE);
-    }
-  }
-
-  /**
-   * Benchmark to measure deserializing objects by hand
-   */
-  public void timeCollectionsStreaming(int reps) throws IOException {
-    for (int i=0; i<reps; ++i) {
-      StringReader reader = new StringReader(json);
-      JsonReader jr = new JsonReader(reader);
-      jr.beginArray();
-      List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();
-      while(jr.hasNext()) {
-        jr.beginObject();
-        long longValue = 0;
-        int intValue = 0;
-        boolean booleanValue = false;
-        String stringValue = null;
-        while(jr.hasNext()) {
-          String name = jr.nextName();
-          if (name.equals("longValue")) {
-            longValue = jr.nextLong();
-          } else if (name.equals("intValue")) {
-            intValue = jr.nextInt();
-          } else if (name.equals("booleanValue")) {
-            booleanValue = jr.nextBoolean();
-          } else if (name.equals("stringValue")) {
-            stringValue = jr.nextString();
-          } else {
-            throw new IOException("Unexpected name: " + name);
-          }
-        }
-        jr.endObject();
-        bags.add(new BagOfPrimitives(longValue, intValue, booleanValue, stringValue));
-      }
-      jr.endArray();
-    }
-  }
-
-  /**
-   * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and
-   * setting object values by reflection. We should strive to reduce the discrepancy between this
-   * and {@link #timeCollectionsDefault(int)} .
-   */
-  public void timeCollectionsReflectionStreaming(int reps) throws Exception {
-    for (int i=0; i<reps; ++i) {
-      StringReader reader = new StringReader(json);
-      JsonReader jr = new JsonReader(reader);
-      jr.beginArray();
-      List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();
-      while(jr.hasNext()) {
-        jr.beginObject();
-        BagOfPrimitives bag = new BagOfPrimitives();
-        while(jr.hasNext()) {
-          String name = jr.nextName();
-          for (Field field : BagOfPrimitives.class.getDeclaredFields()) {
-            if (field.getName().equals(name)) {
-              Class<?> fieldType = field.getType();
-              if (fieldType.equals(long.class)) {
-                field.setLong(bag, jr.nextLong());
-              } else if (fieldType.equals(int.class)) {
-                field.setInt(bag, jr.nextInt());
-              } else if (fieldType.equals(boolean.class)) {
-                field.setBoolean(bag, jr.nextBoolean());
-              } else if (fieldType.equals(String.class)) {
-                field.set(bag, jr.nextString());
-              } else {
-                throw new RuntimeException("Unexpected: type: " + fieldType + ", name: " + name);
-              }
-            }
-          }
-        }
-        jr.endObject();
-        bags.add(bag);
-      }
-      jr.endArray();
-    }
-  }
-}
diff --git a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
deleted file mode 100644
index 68134372c..000000000
--- a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.metrics;
-
-import com.google.caliper.Param;
-import com.google.caliper.Runner;
-import com.google.caliper.SimpleBenchmark;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonParser;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.reflect.TypeToken;
-import java.io.CharArrayReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.lang.reflect.Type;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.List;
-import org.codehaus.jackson.JsonFactory;
-import org.codehaus.jackson.annotate.JsonProperty;
-import org.codehaus.jackson.map.DeserializationConfig;
-import org.codehaus.jackson.map.ObjectMapper;
-import org.codehaus.jackson.type.TypeReference;
-
-/**
- * Measure Gson and Jackson parsing and binding performance.
- *
- * <p>This benchmark requires that ParseBenchmarkData.zip is on the classpath.
- * That file contains Twitter feed data, which is representative of what
- * applications will be parsing.
- */
-public final class ParseBenchmark extends SimpleBenchmark {
-  @Param Document document;
-  @Param Api api;
-
-  private enum Document {
-    TWEETS(new TypeToken<List<Tweet>>() {}, new TypeReference<List<Tweet>>() {}),
-    READER_SHORT(new TypeToken<Feed>() {}, new TypeReference<Feed>() {}),
-    READER_LONG(new TypeToken<Feed>() {}, new TypeReference<Feed>() {});
-
-    private final Type gsonType;
-    private final TypeReference<?> jacksonType;
-
-    private Document(TypeToken<?> typeToken, TypeReference<?> typeReference) {
-      this.gsonType = typeToken.getType();
-      this.jacksonType = typeReference;
-    }
-  }
-
-  private enum Api {
-    JACKSON_STREAM {
-      @Override Parser newParser() {
-        return new JacksonStreamParser();
-      }
-    },
-    JACKSON_BIND {
-      @Override Parser newParser() {
-        return new JacksonBindParser();
-      }
-    },
-    GSON_STREAM {
-      @Override Parser newParser() {
-        return new GsonStreamParser();
-      }
-    },
-    GSON_SKIP {
-      @Override Parser newParser() {
-        return new GsonSkipParser();
-      }
-    },
-    GSON_DOM {
-      @Override Parser newParser() {
-        return new GsonDomParser();
-      }
-    },
-    GSON_BIND {
-      @Override Parser newParser() {
-        return new GsonBindParser();
-      }
-    };
-    abstract Parser newParser();
-  }
-
-  private char[] text;
-  private Parser parser;
-
-  @Override protected void setUp() throws Exception {
-    text = resourceToString("/" + document.name() + ".json").toCharArray();
-    parser = api.newParser();
-  }
-
-  public void timeParse(int reps) throws Exception {
-    for (int i = 0; i < reps; i++) {
-      parser.parse(text, document);
-    }
-  }
-
-  private static String resourceToString(String path) throws Exception {
-    InputStream in = ParseBenchmark.class.getResourceAsStream(path);
-    if (in == null) {
-      throw new IllegalArgumentException("No such file: " + path);
-    }
-
-    Reader reader = new InputStreamReader(in, "UTF-8");
-    char[] buffer = new char[8192];
-    StringWriter writer = new StringWriter();
-    int count;
-    while ((count = reader.read(buffer)) != -1) {
-      writer.write(buffer, 0, count);
-    }
-    reader.close();
-    return writer.toString();
-  }
-
-  public static void main(String[] args) throws Exception {
-    Runner.main(ParseBenchmark.class, args);
-  }
-
-  interface Parser {
-    void parse(char[] data, Document document) throws Exception;
-  }
-
-  private static class GsonStreamParser implements Parser {
-    public void parse(char[] data, Document document) throws Exception {
-      com.google.gson.stream.JsonReader jsonReader
-          = new com.google.gson.stream.JsonReader(new CharArrayReader(data));
-      readToken(jsonReader);
-      jsonReader.close();
-    }
-
-    private void readToken(com.google.gson.stream.JsonReader reader) throws IOException {
-      while (true) {
-        switch (reader.peek()) {
-        case BEGIN_ARRAY:
-          reader.beginArray();
-          break;
-        case END_ARRAY:
-          reader.endArray();
-          break;
-        case BEGIN_OBJECT:
-          reader.beginObject();
-          break;
-        case END_OBJECT:
-          reader.endObject();
-          break;
-        case NAME:
-          reader.nextName();
-          break;
-        case BOOLEAN:
-          reader.nextBoolean();
-          break;
-        case NULL:
-          reader.nextNull();
-          break;
-        case NUMBER:
-          reader.nextLong();
-          break;
-        case STRING:
-          reader.nextString();
-          break;
-        case END_DOCUMENT:
-          return;
-        default:
-          throw new IllegalArgumentException("Unexpected token" + reader.peek());
-        }
-      }
-    }
-  }
-
-  private static class GsonSkipParser implements Parser {
-    public void parse(char[] data, Document document) throws Exception {
-      com.google.gson.stream.JsonReader jsonReader
-          = new com.google.gson.stream.JsonReader(new CharArrayReader(data));
-      jsonReader.skipValue();
-      jsonReader.close();
-    }
-  }
-
-  private static class JacksonStreamParser implements Parser {
-    public void parse(char[] data, Document document) throws Exception {
-      JsonFactory jsonFactory = new JsonFactory();
-      org.codehaus.jackson.JsonParser jp = jsonFactory.createJsonParser(new CharArrayReader(data));
-      jp.configure(org.codehaus.jackson.JsonParser.Feature.CANONICALIZE_FIELD_NAMES, false);
-      int depth = 0;
-      do {
-        switch (jp.nextToken()) {
-        case START_OBJECT:
-        case START_ARRAY:
-          depth++;
-          break;
-        case END_OBJECT:
-        case END_ARRAY:
-          depth--;
-          break;
-        case FIELD_NAME:
-          jp.getCurrentName();
-          break;
-        case VALUE_STRING:
-          jp.getText();
-          break;
-        case VALUE_NUMBER_INT:
-        case VALUE_NUMBER_FLOAT:
-          jp.getLongValue();
-          break;
-        }
-      } while (depth > 0);
-      jp.close();
-    }
-  }
-
-  private static class GsonDomParser implements Parser {
-    public void parse(char[] data, Document document) throws Exception {
-      new JsonParser().parse(new CharArrayReader(data));
-    }
-  }
-
-  private static class GsonBindParser implements Parser {
-    private static Gson gson = new GsonBuilder()
-        .setDateFormat("EEE MMM dd HH:mm:ss Z yyyy")
-        .create();
-
-    public void parse(char[] data, Document document) throws Exception {
-      gson.fromJson(new CharArrayReader(data), document.gsonType);
-    }
-  }
-
-  private static class JacksonBindParser implements Parser {
-    private static ObjectMapper mapper = new ObjectMapper();
-
-    static {
-      mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
-      mapper.configure(DeserializationConfig.Feature.AUTO_DETECT_FIELDS, true);
-      mapper.setDateFormat(new SimpleDateFormat("EEE MMM dd HH:mm:ss Z yyyy"));
-    }
-
-    public void parse(char[] data, Document document) throws Exception {
-      mapper.readValue(new CharArrayReader(data), document.jacksonType);
-    }
-  }
-
-  static class Tweet {
-    @JsonProperty String coordinates;
-    @JsonProperty boolean favorited;
-    @JsonProperty Date created_at;
-    @JsonProperty boolean truncated;
-    @JsonProperty Tweet retweeted_status;
-    @JsonProperty String id_str;
-    @JsonProperty String in_reply_to_id_str;
-    @JsonProperty String contributors;
-    @JsonProperty String text;
-    @JsonProperty long id;
-    @JsonProperty String retweet_count;
-    @JsonProperty String in_reply_to_status_id_str;
-    @JsonProperty Object geo;
-    @JsonProperty boolean retweeted;
-    @JsonProperty String in_reply_to_user_id;
-    @JsonProperty String in_reply_to_screen_name;
-    @JsonProperty Object place;
-    @JsonProperty User user;
-    @JsonProperty String source;
-    @JsonProperty String in_reply_to_user_id_str;
-  }
-
-  static class User {
-    @JsonProperty String name;
-    @JsonProperty String profile_sidebar_border_color;
-    @JsonProperty boolean profile_background_tile;
-    @JsonProperty String profile_sidebar_fill_color;
-    @JsonProperty Date created_at;
-    @JsonProperty String location;
-    @JsonProperty String profile_image_url;
-    @JsonProperty boolean follow_request_sent;
-    @JsonProperty String profile_link_color;
-    @JsonProperty boolean is_translator;
-    @JsonProperty String id_str;
-    @JsonProperty int favourites_count;
-    @JsonProperty boolean contributors_enabled;
-    @JsonProperty String url;
-    @JsonProperty boolean default_profile;
-    @JsonProperty long utc_offset;
-    @JsonProperty long id;
-    @JsonProperty boolean profile_use_background_image;
-    @JsonProperty int listed_count;
-    @JsonProperty String lang;
-    @JsonProperty("protected") @SerializedName("protected") boolean isProtected;
-    @JsonProperty int followers_count;
-    @JsonProperty String profile_text_color;
-    @JsonProperty String profile_background_color;
-    @JsonProperty String time_zone;
-    @JsonProperty String description;
-    @JsonProperty boolean notifications;
-    @JsonProperty boolean geo_enabled;
-    @JsonProperty boolean verified;
-    @JsonProperty String profile_background_image_url;
-    @JsonProperty boolean defalut_profile_image;
-    @JsonProperty int friends_count;
-    @JsonProperty int statuses_count;
-    @JsonProperty String screen_name;
-    @JsonProperty boolean following;
-    @JsonProperty boolean show_all_inline_media;
-  }
-
-  static class Feed {
-    @JsonProperty String id;
-    @JsonProperty String title;
-    @JsonProperty String description;
-    @JsonProperty("alternate") @SerializedName("alternate") List<Link> alternates;
-    @JsonProperty long updated;
-    @JsonProperty List<Item> items;
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder()
-          .append(id)
-          .append("\n").append(title)
-          .append("\n").append(description)
-          .append("\n").append(alternates)
-          .append("\n").append(updated);
-      int i = 1;
-      for (Item item : items) {
-        result.append(i++).append(": ").append(item).append("\n\n");
-      }
-      return result.toString();
-    }
-  }
-
-  static class Link {
-    @JsonProperty String href;
-
-    @Override public String toString() {
-      return href;
-    }
-  }
-
-  static class Item {
-    @JsonProperty List<String> categories;
-    @JsonProperty String title;
-    @JsonProperty long published;
-    @JsonProperty long updated;
-    @JsonProperty("alternate") @SerializedName("alternate") List<Link> alternates;
-    @JsonProperty Content content;
-    @JsonProperty String author;
-    @JsonProperty List<ReaderUser> likingUsers;
-
-    @Override public String toString() {
-      return title
-          + "\nauthor: " + author
-          + "\npublished: " + published
-          + "\nupdated: " + updated
-          + "\n" + content
-          + "\nliking users: " + likingUsers
-          + "\nalternates: " + alternates
-          + "\ncategories: " + categories;
-    }
-  }
-
-  static class Content {
-    @JsonProperty String content;
-
-    @Override public String toString() {
-      return content;
-    }
-  }
-
-  static class ReaderUser {
-    @JsonProperty String userId;
-
-    @Override public String toString() {
-      return userId;
-    }
-  }
-}
diff --git a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmarkData.zip b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmarkData.zip
deleted file mode 100644
index 58e08bb50..000000000
Binary files a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmarkData.zip and /dev/null differ
diff --git a/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
deleted file mode 100644
index 9cdf085e8..000000000
--- a/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.metrics;
-
-import com.google.caliper.Param;
-import com.google.caliper.Runner;
-import com.google.caliper.SimpleBenchmark;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-
-/**
- * Caliper based micro benchmarks for Gson serialization
- *
- * @author Inderjeet Singh
- * @author Jesse Wilson
- * @author Joel Leitch
- */
-public class SerializationBenchmark extends SimpleBenchmark {
-
-  private Gson gson;
-  private BagOfPrimitives bag;
-  @Param
-  private boolean pretty;
-
-  public static void main(String[] args) {
-    Runner.main(SerializationBenchmark.class, args);
-  }
-  
-  @Override
-  protected void setUp() throws Exception {
-    this.gson = pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();
-    this.bag = new BagOfPrimitives(10L, 1, false, "foo");
-  }
-
-  public void timeObjectSerialization(int reps) {
-    for (int i=0; i<reps; ++i) {
-      gson.toJson(bag);
-    }
-  }
-}
diff --git a/pom.xml b/pom.xml
index 8814acb87..43d3ca0b0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,144 +1,171 @@
 <?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+	<modelVersion>4.0.0</modelVersion>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+	<groupId>com.praxar</groupId>
+	<artifactId>gson-parent</artifactId>
+	<version>2.8.6-SNAPSHOT</version>
+	<packaging>pom</packaging>
 
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
+	<name>Gson Parent</name>
+	<description>Gson JSON library</description>
+	<url>https://github.com/google/gson</url>
 
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-parent</artifactId>
-  <version>2.8.6-SNAPSHOT</version>
-  <packaging>pom</packaging>
+	<modules>
+		<module>gson</module>
+	</modules>
 
-  <name>Gson Parent</name>
-  <description>Gson JSON library</description>
-  <url>https://github.com/google/gson</url>
+	<properties>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<maven.compiler.source>9</maven.compiler.source>
+    	<maven.compiler.target>9</maven.compiler.target>
+	</properties>
 
-  <modules>
-    <module>gson</module>
-  </modules>
+	<scm>
+		<url>https://github.com/google/gson/</url>
+		<connection>scm:git:https://github.com/google/gson.git</connection>
+		<developerConnection>scm:git:git@github.com:google/gson.git</developerConnection>
+		<tag>HEAD</tag>
+	</scm>
 
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <java.version>1.6</java.version>
-  </properties>
+	<issueManagement>
+		<system>GitHub Issues</system>
+		<url>https://github.com/google/gson/issues</url>
+	</issueManagement>
 
-  <scm>
-    <url>https://github.com/google/gson/</url>
-    <connection>scm:git:https://github.com/google/gson.git</connection>
-    <developerConnection>scm:git:git@github.com:google/gson.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
+	<licenses>
+		<license>
+			<name>Apache 2.0</name>
+			<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+		</license>
+	</licenses>
 
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>https://github.com/google/gson/issues</url>
-  </issueManagement>
+	<dependencies>
+		<dependency>
+			<groupId>junit</groupId>
+			<artifactId>junit</artifactId>
+			<version>4.12</version>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
 
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>4.12</version>
-        <scope>test</scope>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.8.0</version>
-          <executions>
-            <execution>
-              <id>default-compile</id>
-              <configuration>
-                <release>9</release>
-              </configuration>
-            </execution>
-            <execution>
-              <id>base-compile</id>
-              <goals>
-                <goal>compile</goal>
-              </goals>
-              <configuration>
-                <excludes>
-                  <exclude>module-info.java</exclude>
-                </excludes>
-              </configuration>
-            </execution>
-          </executions>
-          <configuration>
-            <release>6</release>
-          </configuration>
-        </plugin>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
-        </plugin>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-jar-plugin</artifactId>
-        </plugin>
-        <plugin>
-          <groupId>org.apache.felix</groupId>
-          <artifactId>maven-bundle-plugin</artifactId>
-          <version>3.3.0</version>
-          <inherited>true</inherited>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5.3</version>
-        <dependencies>
-          <dependency>
-            <groupId>org.apache.maven.scm</groupId>
-            <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9.5</version>
-          </dependency>
-        </dependencies>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <profiles>
-    <profile>
-      <id>doclint-java8-disable</id>
-      <activation>
-        <jdk>[1.8,)</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-            <configuration>
-              <additionalparam>-Xdoclint:none</additionalparam>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
+	<build>
+     <extensions>
+	    <extension>
+	       <groupId>com.gkatzioura.maven.cloud</groupId>
+	       <artifactId>google-storage-wagon</artifactId>
+	       <version>1.2</version>
+	    </extension>
+	 </extensions>	
+		<pluginManagement>
+			<plugins>
+				<plugin>
+					<groupId>org.apache.maven.plugins</groupId>
+					<artifactId>maven-compiler-plugin</artifactId>
+					<version>3.8.0</version>
+					<executions>
+						<execution>
+							<id>default-compile</id>
+							<configuration>
+								<release>9</release>
+							</configuration>
+						</execution>
+						<execution>
+							<id>base-compile</id>
+							<goals>
+								<goal>compile</goal>
+							</goals>
+							<configuration>
+								<excludes>
+									<exclude>module-info.java</exclude>
+								</excludes>
+							</configuration>
+						</execution>
+					</executions>
+					<configuration>
+						<release>6</release>
+					</configuration>
+				</plugin>
+				<plugin>
+					<groupId>org.apache.maven.plugins</groupId>
+					<artifactId>maven-javadoc-plugin</artifactId>
+					<version>2.10.4</version>
+				</plugin>
+				<plugin>
+					<groupId>org.apache.maven.plugins</groupId>
+					<artifactId>maven-jar-plugin</artifactId>
+				</plugin>
+				<plugin>
+					<groupId>org.apache.felix</groupId>
+					<artifactId>maven-bundle-plugin</artifactId>
+					<version>3.3.0</version>
+					<inherited>true</inherited>
+				</plugin>
+			</plugins>
+		</pluginManagement>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-release-plugin</artifactId>
+				<version>2.5.3</version>
+				<dependencies>
+					<dependency>
+						<groupId>org.apache.maven.scm</groupId>
+						<artifactId>maven-scm-provider-gitexe</artifactId>
+						<version>1.9.5</version>
+					</dependency>
+				</dependencies>
+				<configuration>
+					<autoVersionSubmodules>true</autoVersionSubmodules>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
+	<profiles>
+		<profile>
+			<id>doclint-java8-disable</id>
+			<activation>
+				<jdk>[1.8,)</jdk>
+			</activation>
+			<build>
+				<plugins>
+					<plugin>
+						<groupId>org.apache.maven.plugins</groupId>
+						<artifactId>maven-javadoc-plugin</artifactId>
+						<configuration>
+							<additionalparam>-Xdoclint:none</additionalparam>
+						</configuration>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+	</profiles>
+	<distributionManagement>
+     <snapshotRepository>
+	    <id>praxar-maven-bucket-snapshot</id>
+	    <url>gs://praxar-maven-repo/snapshot</url>
+	 </snapshotRepository>
+	 <repository>
+	    <id>praxar-maven-bucket-release</id>
+	    <url>gs://praxar-maven-repo/release</url>
+	 </repository>
+  </distributionManagement>	
+  <repositories>
+     <repository>
+	    <id>praxar-maven-bucket-snapshot</id>
+	    <url>gs://praxar-maven-repo/snapshot</url>
+	    <snapshots>
+	       <enabled>true</enabled>
+	    </snapshots>
+     </repository>
+     <repository>
+	    <id>praxar-maven-bucket-release</id>
+	    <url>gs://praxar-maven-repo/release</url>
+	    <releases>
+	       <enabled>true</enabled>
+	    </releases>
+     </repository>
+  </repositories>  
+</project>
\ No newline at end of file
diff --git a/proto/.gitignore b/proto/.gitignore
deleted file mode 100644
index f44578ac2..000000000
--- a/proto/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-src/main/java/com/google/gson/protobuf/generated/
diff --git a/proto/pom.xml b/proto/pom.xml
deleted file mode 100644
index 99f7791d5..000000000
--- a/proto/pom.xml
+++ /dev/null
@@ -1,218 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>proto</artifactId>
-  <packaging>jar</packaging>
-  <version>0.6-SNAPSHOT</version>
-  <name>Gson Protobuf Support</name>
-  <description>Gson support for Protobufs</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <distributionManagement>
-    <repository>
-      <id>local.repo</id>
-      <name>file repository to svn</name>
-      <url>file://${basedir}/../../mavenrepo</url>
-    </repository>
-  </distributionManagement>
-  <repositories>
-    <repository>
-      <id>gson</id>
-      <url>http://google-gson.googlecode.com/svn/mavenrepo</url>
-      <snapshots>
-        <enabled>true</enabled>
-      </snapshots>
-      <releases>
-        <enabled>true</enabled>
-      </releases>
-    </repository>
-  </repositories>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:svn:http://google-gson.googlecode.com/svn/trunk/proto</connection>
-    <developerConnection>scm:svn:https://google-gson.googlecode.com/svn/trunk/proto</developerConnection>
-    <url>http://google-gson.codegoogle.com/svn/trunk/proto</url>
-  </scm>
-  <issueManagement>
-    <system>Google Code Issue Tracking</system>
-    <url>http://code.google.com/p/google-gson/issues/list</url>
-  </issueManagement>
-
-  <dependencies>
-
-    <!--  Gson: Java to Json conversion -->
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <version>2.4</version>
-      <scope>compile</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.google.protobuf</groupId>
-      <artifactId>protobuf-java</artifactId>
-      <version>2.6.1</version>
-      <scope>compile</scope>
-    </dependency>
-    
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>18.0</version>
-      <scope>compile</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>4.12</version>
-      <scope>test</scope>
-    </dependency>
-    
-    <dependency>
-      <groupId>com.google.truth</groupId>
-      <artifactId>truth</artifactId>
-      <version>0.27</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <finalName>gson-proto</finalName>
-    <plugins>
-      <plugin>
-        <artifactId>maven-antrun-plugin</artifactId>
-        <version>1.8</version>
-        <executions>
-          <execution>
-            <id>compile-protoc</id>
-            <phase>generate-sources</phase>
-            <configuration>
-              <tasks>
-                <mkdir dir="target/generated" />
-                <path id="proto.path">
-                  <fileset dir="src/main/protobuf">
-                    <include name="**/*.proto" />
-                  </fileset>
-                </path>
-                <pathconvert pathsep=" " property="proto.files" refid="proto.path" />
-                <exec executable="protoc" failonerror="true">
-                  <arg value="--java_out=src/main/java" />
-                  <arg value="--proto_path=/usr/include" />
-                  <arg value="-I${project.basedir}/src/main/protobuf" />
-                  <arg line="${proto.files}" />
-                </exec>
-              </tasks>
-            </configuration>
-            <goals>
-              <goal>run</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.3.2</version>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-eclipse-plugin</artifactId>
-        <version>2.8</version>
-        <configuration>
-          <downloadSources>true</downloadSources>
-          <downloadJavadocs>true</downloadJavadocs>
-          <workspace>../eclipse-ws</workspace>
-          <workspaceCodeStylesURL>file:///${basedir}/../lib/gson-formatting-styles.xml</workspaceCodeStylesURL>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-install-plugin</artifactId>
-        <version>2.5.2</version>
-        <!-- configuration>
-          <updateReleaseInfo>true</updateReleaseInfo>
-          <createChecksum>true</createChecksum>
-          <groupId>${groupId}</groupId>
-          <artifactId>${artifactId}</artifactId>
-          <version>${version}</version>
-          <packaging>jar</packaging>
-          <classifier>sources</classifier>
-          <file>target/proto-sources.jar</file>
-        </configuration -->
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.1</version>
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-          <tagBase>https://google-gson.googlecode.com/svn/tags/</tagBase>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-source-plugin</artifactId>
-        <version>2.1.2</version>
-        <executions>
-          <execution>
-            <id>attach-sources</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.7</version>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <links>
-            <link>http://download.oracle.com/javase/1.5.0/docs/api/</link>
-          </links>
-          <version>true</version>
-          <show>public</show>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptor>src/main/resources/assembly-descriptor.xml</descriptor>
-          <finalName>proto-${project.version}</finalName>
-          <outputDirectory>target/dist</outputDirectory>
-          <workDirectory>target/assembly/work</workDirectory>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-      <organization>Google Inc.</organization>
-    </developer>
-  </developers>
-</project>
diff --git a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
deleted file mode 100644
index c378685c8..000000000
--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.protobuf;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.common.base.CaseFormat;
-import com.google.common.collect.MapMaker;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.google.protobuf.DescriptorProtos.EnumValueOptions;
-import com.google.protobuf.DescriptorProtos.FieldOptions;
-import com.google.protobuf.Descriptors.Descriptor;
-import com.google.protobuf.Descriptors.EnumDescriptor;
-import com.google.protobuf.Descriptors.EnumValueDescriptor;
-import com.google.protobuf.Descriptors.FieldDescriptor;
-import com.google.protobuf.DynamicMessage;
-import com.google.protobuf.Extension;
-import com.google.protobuf.Message;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentMap;
-
-/**
- * GSON type adapter for protocol buffers that knows how to serialize enums either by using their
- * values or their names, and also supports custom proto field names.
- * <p>
- * You can specify which case representation is used for the proto fields when writing/reading the
- * JSON payload by calling {@link Builder#setFieldNameSerializationFormat(CaseFormat, CaseFormat)}.
- * <p>
- * An example of default serialization/deserialization using custom proto field names is shown
- * below:
- *
- * <pre>
- * message MyMessage {
- *   // Will be serialized as 'osBuildID' instead of the default 'osBuildId'.
- *   string os_build_id = 1 [(serialized_name) = "osBuildID"];
- * }
- * </pre>
- * <p>
- *
- * @author Inderjeet Singh
- * @author Emmanuel Cron
- * @author Stanley Wang
- */
-public class ProtoTypeAdapter
-    implements JsonSerializer<Message>, JsonDeserializer<Message> {
-  /**
-   * Determines how enum <u>values</u> should be serialized.
-   */
-  public static enum EnumSerialization {
-    /**
-     * Serializes and deserializes enum values using their <b>number</b>. When this is used, custom
-     * value names set on enums are ignored.
-     */
-    NUMBER,
-    /** Serializes and deserializes enum values using their <b>name</b>. */
-    NAME;
-  }
-
-  /**
-   * Builder for {@link ProtoTypeAdapter}s.
-   */
-  public static class Builder {
-    private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
-    private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
-    private EnumSerialization enumSerialization;
-    private CaseFormat protoFormat;
-    private CaseFormat jsonFormat;
-
-    private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,
-        CaseFormat toFieldNameFormat) {
-      this.serializedNameExtensions = new HashSet<Extension<FieldOptions, String>>();
-      this.serializedEnumValueExtensions = new HashSet<Extension<EnumValueOptions, String>>();
-      setEnumSerialization(enumSerialization);
-      setFieldNameSerializationFormat(fromFieldNameFormat, toFieldNameFormat);
-    }
-
-    public Builder setEnumSerialization(EnumSerialization enumSerialization) {
-      this.enumSerialization = checkNotNull(enumSerialization);
-      return this;
-    }
-
-    /**
-     * Sets the field names serialization format. The first parameter defines how to read the format
-     * of the proto field names you are converting to JSON. The second parameter defines which
-     * format to use when serializing them.
-     * <p>
-     * For example, if you use the following parameters: {@link CaseFormat#LOWER_UNDERSCORE},
-     * {@link CaseFormat#LOWER_CAMEL}, the following conversion will occur:
-     *
-     * <pre>
-     * PROTO     <->  JSON
-     * my_field       myField
-     * foo            foo
-     * n__id_ct       nIdCt
-     * </pre>
-     */
-    public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,
-        CaseFormat toFieldNameFormat) {
-      this.protoFormat = fromFieldNameFormat;
-      this.jsonFormat = toFieldNameFormat;
-      return this;
-    }
-
-    /**
-     * Adds a field proto annotation that, when set, overrides the default field name
-     * serialization/deserialization. For example, if you add the '{@code serialized_name}'
-     * annotation and you define a field in your proto like the one below:
-     *
-     * <pre>
-     * string client_app_id = 1 [(serialized_name) = "appId"];
-     * </pre>
-     *
-     * ...the adapter will serialize the field using '{@code appId}' instead of the default '
-     * {@code clientAppId}'. This lets you customize the name serialization of any proto field.
-     */
-    public Builder addSerializedNameExtension(
-        Extension<FieldOptions, String> serializedNameExtension) {
-      serializedNameExtensions.add(checkNotNull(serializedNameExtension));
-      return this;
-    }
-
-    /**
-     * Adds an enum value proto annotation that, when set, overrides the default <b>enum</b> value
-     * serialization/deserialization of this adapter. For example, if you add the '
-     * {@code serialized_value}' annotation and you define an enum in your proto like the one below:
-     *
-     * <pre>
-     * enum MyEnum {
-     *   UNKNOWN = 0;
-     *   CLIENT_APP_ID = 1 [(serialized_value) = "APP_ID"];
-     *   TWO = 2 [(serialized_value) = "2"];
-     * }
-     * </pre>
-     *
-     * ...the adapter will serialize the value {@code CLIENT_APP_ID} as "{@code APP_ID}" and the
-     * value {@code TWO} as "{@code 2}". This works for both serialization and deserialization.
-     * <p>
-     * Note that you need to set the enum serialization of this adapter to
-     * {@link EnumSerialization#NAME}, otherwise these annotations will be ignored.
-     */
-    public Builder addSerializedEnumValueExtension(
-        Extension<EnumValueOptions, String> serializedEnumValueExtension) {
-      serializedEnumValueExtensions.add(checkNotNull(serializedEnumValueExtension));
-      return this;
-    }
-
-    public ProtoTypeAdapter build() {
-      return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat,
-          serializedNameExtensions, serializedEnumValueExtensions);
-    }
-  }
-
-  /**
-   * Creates a new {@link ProtoTypeAdapter} builder, defaulting enum serialization to
-   * {@link EnumSerialization#NAME} and converting field serialization from
-   * {@link CaseFormat#LOWER_UNDERSCORE} to {@link CaseFormat#LOWER_CAMEL}.
-   */
-  public static Builder newBuilder() {
-    return new Builder(EnumSerialization.NAME, CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_CAMEL);
-  }
-
-  private static final com.google.protobuf.Descriptors.FieldDescriptor.Type ENUM_TYPE =
-      com.google.protobuf.Descriptors.FieldDescriptor.Type.ENUM;
-
-  private static final ConcurrentMap<String, Map<Class<?>, Method>> mapOfMapOfMethods =
-      new MapMaker().makeMap();
-
-  private final EnumSerialization enumSerialization;
-  private final CaseFormat protoFormat;
-  private final CaseFormat jsonFormat;
-  private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
-  private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
-
-  private ProtoTypeAdapter(EnumSerialization enumSerialization,
-      CaseFormat protoFormat,
-      CaseFormat jsonFormat,
-      Set<Extension<FieldOptions, String>> serializedNameExtensions,
-      Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {
-    this.enumSerialization = enumSerialization;
-    this.protoFormat = protoFormat;
-    this.jsonFormat = jsonFormat;
-    this.serializedNameExtensions = serializedNameExtensions;
-    this.serializedEnumValueExtensions = serializedEnumValueExtensions;
-  }
-
-  @Override
-  public JsonElement serialize(Message src, Type typeOfSrc,
-      JsonSerializationContext context) {
-    JsonObject ret = new JsonObject();
-    final Map<FieldDescriptor, Object> fields = src.getAllFields();
-
-    for (Map.Entry<FieldDescriptor, Object> fieldPair : fields.entrySet()) {
-      final FieldDescriptor desc = fieldPair.getKey();
-      String name = getCustSerializedName(desc.getOptions(), desc.getName());
-
-      if (desc.getType() == ENUM_TYPE) {
-        // Enum collections are also returned as ENUM_TYPE
-        if (fieldPair.getValue() instanceof Collection) {
-          // Build the array to avoid infinite loop
-          JsonArray array = new JsonArray();
-          @SuppressWarnings("unchecked")
-          Collection<EnumValueDescriptor> enumDescs =
-              (Collection<EnumValueDescriptor>) fieldPair.getValue();
-          for (EnumValueDescriptor enumDesc : enumDescs) {
-            array.add(context.serialize(getEnumValue(enumDesc)));
-            ret.add(name, array);
-          }
-        } else {
-          EnumValueDescriptor enumDesc = ((EnumValueDescriptor) fieldPair.getValue());
-          ret.add(name, context.serialize(getEnumValue(enumDesc)));
-        }
-      } else {
-        ret.add(name, context.serialize(fieldPair.getValue()));
-      }
-    }
-    return ret;
-  }
-
-  @Override
-  public Message deserialize(JsonElement json, Type typeOfT,
-      JsonDeserializationContext context) throws JsonParseException {
-    try {
-      JsonObject jsonObject = json.getAsJsonObject();
-      @SuppressWarnings("unchecked")
-      Class<? extends Message> protoClass = (Class<? extends Message>) typeOfT;
-
-      if (DynamicMessage.class.isAssignableFrom(protoClass)) {
-        throw new IllegalStateException("only generated messages are supported");
-      }
-
-      try {
-        // Invoke the ProtoClass.newBuilder() method
-        Message.Builder protoBuilder =
-            (Message.Builder) getCachedMethod(protoClass, "newBuilder").invoke(null);
-
-        Message defaultInstance =
-            (Message) getCachedMethod(protoClass, "getDefaultInstance").invoke(null);
-
-        Descriptor protoDescriptor =
-            (Descriptor) getCachedMethod(protoClass, "getDescriptor").invoke(null);
-        // Call setters on all of the available fields
-        for (FieldDescriptor fieldDescriptor : protoDescriptor.getFields()) {
-          String jsonFieldName =
-              getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());
-
-          JsonElement jsonElement = jsonObject.get(jsonFieldName);
-          if (jsonElement != null && !jsonElement.isJsonNull()) {
-            // Do not reuse jsonFieldName here, it might have a custom value
-            Object fieldValue;
-            if (fieldDescriptor.getType() == ENUM_TYPE) {
-              if (jsonElement.isJsonArray()) {
-                // Handling array
-                Collection<EnumValueDescriptor> enumCollection =
-                    new ArrayList<EnumValueDescriptor>(jsonElement.getAsJsonArray().size());
-                for (JsonElement element : jsonElement.getAsJsonArray()) {
-                  enumCollection.add(
-                      findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));
-                }
-                fieldValue = enumCollection;
-              } else {
-                // No array, just a plain value
-                fieldValue =
-                    findValueByNameAndExtension(fieldDescriptor.getEnumType(), jsonElement);
-              }
-              protoBuilder.setField(fieldDescriptor, fieldValue);
-            } else if (fieldDescriptor.isRepeated()) {
-              // If the type is an array, then we have to grab the type from the class.
-              // protobuf java field names are always lower camel case
-              String protoArrayFieldName =
-                  protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + "_";
-              Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);
-              Type protoArrayFieldType = protoArrayField.getGenericType();
-              fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
-              protoBuilder.setField(fieldDescriptor, fieldValue);
-            } else {
-              Object field = defaultInstance.getField(fieldDescriptor);
-              fieldValue = context.deserialize(jsonElement, field.getClass());
-              protoBuilder.setField(fieldDescriptor, fieldValue);
-            }
-          }
-        }
-        return (Message) protoBuilder.build();
-      } catch (SecurityException e) {
-        throw new JsonParseException(e);
-      } catch (NoSuchMethodException e) {
-        throw new JsonParseException(e);
-      } catch (IllegalArgumentException e) {
-        throw new JsonParseException(e);
-      } catch (IllegalAccessException e) {
-        throw new JsonParseException(e);
-      } catch (InvocationTargetException e) {
-        throw new JsonParseException(e);
-      }
-    } catch (Exception e) {
-      throw new JsonParseException("Error while parsing proto", e);
-    }
-  }
-
-  /**
-   * Retrieves the custom field name from the given options, and if not found, returns the specified
-   * default name.
-   */
-  private String getCustSerializedName(FieldOptions options, String defaultName) {
-    for (Extension<FieldOptions, String> extension : serializedNameExtensions) {
-      if (options.hasExtension(extension)) {
-        return options.getExtension(extension);
-      }
-    }
-    return protoFormat.to(jsonFormat, defaultName);
-  }
-
-  /**
-   * Retrieves the custom enum value name from the given options, and if not found, returns the
-   * specified default value.
-   */
-  private String getCustSerializedEnumValue(EnumValueOptions options, String defaultValue) {
-    for (Extension<EnumValueOptions, String> extension : serializedEnumValueExtensions) {
-      if (options.hasExtension(extension)) {
-        return options.getExtension(extension);
-      }
-    }
-    return defaultValue;
-  }
-
-  /**
-   * Returns the enum value to use for serialization, depending on the value of
-   * {@link EnumSerialization} that was given to this adapter.
-   */
-  private Object getEnumValue(EnumValueDescriptor enumDesc) {
-    if (enumSerialization == EnumSerialization.NAME) {
-      return getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());
-    } else {
-      return enumDesc.getNumber();
-    }
-  }
-
-  /**
-   * Finds an enum value in the given {@link EnumDescriptor} that matches the given JSON element,
-   * either by name if the current adapter is using {@link EnumSerialization#NAME}, otherwise by
-   * number. If matching by name, it uses the extension value if it is defined, otherwise it uses
-   * its default value.
-   *
-   * @throws IllegalArgumentException if a matching name/number was not found
-   */
-  private EnumValueDescriptor findValueByNameAndExtension(EnumDescriptor desc,
-      JsonElement jsonElement) {
-    if (enumSerialization == EnumSerialization.NAME) {
-      // With enum name
-      for (EnumValueDescriptor enumDesc : desc.getValues()) {
-        String enumValue = getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());
-        if (enumValue.equals(jsonElement.getAsString())) {
-          return enumDesc;
-        }
-      }
-      throw new IllegalArgumentException(
-          String.format("Unrecognized enum name: %s", jsonElement.getAsString()));
-    } else {
-      // With enum value
-      EnumValueDescriptor fieldValue = desc.findValueByNumber(jsonElement.getAsInt());
-      if (fieldValue == null) {
-        throw new IllegalArgumentException(
-            String.format("Unrecognized enum value: %s", jsonElement.getAsInt()));
-      }
-      return fieldValue;
-    }
-  }
-
-  private static Method getCachedMethod(Class<?> clazz, String methodName,
-      Class<?>... methodParamTypes) throws NoSuchMethodException {
-    Map<Class<?>, Method> mapOfMethods = mapOfMapOfMethods.get(methodName);
-    if (mapOfMethods == null) {
-      mapOfMethods = new MapMaker().makeMap();
-      Map<Class<?>, Method> previous =
-          mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);
-      mapOfMethods = previous == null ? mapOfMethods : previous;
-    }
-
-    Method method = mapOfMethods.get(clazz);
-    if (method == null) {
-      method = clazz.getMethod(methodName, methodParamTypes);
-      mapOfMethods.putIfAbsent(clazz, method);
-      // NB: it doesn't matter which method we return in the event of a race.
-    }
-    return method;
-  }
-
-}
diff --git a/proto/src/main/protobuf/annotations.proto b/proto/src/main/protobuf/annotations.proto
deleted file mode 100644
index 53b727a66..000000000
--- a/proto/src/main/protobuf/annotations.proto
+++ /dev/null
@@ -1,32 +0,0 @@
-//
-// Copyright (C) 2010 Google Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-syntax = "proto2";
-
-package google.gson.protobuf.generated;
-option java_package = "com.google.gson.protobuf.generated";
-
-import "google/protobuf/descriptor.proto";
-
-extend google.protobuf.FieldOptions {
-  // Indicates a field name that overrides the default for serialization
-  optional string serialized_name = 92066888;
-}
-
-extend google.protobuf.EnumValueOptions {
-  // Indicates a field value that overrides the default for serialization
-  optional string serialized_value = 92066888;
-}
diff --git a/proto/src/main/protobuf/bag.proto b/proto/src/main/protobuf/bag.proto
deleted file mode 100644
index 48cc96397..000000000
--- a/proto/src/main/protobuf/bag.proto
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-// Copyright (C) 2010 Google Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-package google.gson.protobuf.generated;
-option java_package = "com.google.gson.protobuf.generated";
-
-import "annotations.proto";
-
-message SimpleProto {
-  optional string msg = 1;
-  optional int32 count = 2;
-}
-
-message ProtoWithDifferentCaseFormat {
-  repeated string name_that_tests_case_format = 1;
-  optional string another_field = 2;
-}
-
-message ProtoWithRepeatedFields {
-  repeated int64 numbers = 1;
-  repeated SimpleProto simples = 2;
-  optional string name = 3;
-}
-
-// -- A more complex message with annotations and nested protos
-
-message OuterMessage {
-  optional int32 month = 1;
-  optional int32 year = 2;
-  optional int64 long_timestamp = 3 [(serialized_name) = "timeStamp"];
-  optional string country_code_5f55 = 4;
-}
-
-message ProtoWithAnnotations {
-  optional string id = 1;
-  optional OuterMessage outer_message = 2 [(serialized_name) = "expiration_date"];
-
-  message InnerMessage {
-    optional int32 n__id_ct = 1;
-
-    enum Type {
-      UNKNOWN = 0;
-      TEXT = 1 [(serialized_value) = "text/plain"];
-      IMAGE = 2 [(serialized_value) = "image/png"];
-    }
-    optional Type content = 2;
-
-    message Data {
-      optional string data = 1;
-      optional int32 width = 2;
-      optional int32 height = 3;
-    }
-    repeated Data data = 3 [(serialized_name) = "$binary_data$"];
-  }
-  optional InnerMessage inner_message_1 = 3;
-  optional InnerMessage inner_message_2 = 4;
-}
\ No newline at end of file
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java
deleted file mode 100644
index 2bb6f183a..000000000
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.protobuf.functional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assert_;
-
-import com.google.common.base.CaseFormat;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonParseException;
-import com.google.gson.protobuf.ProtoTypeAdapter;
-import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
-import com.google.gson.protobuf.generated.Annotations;
-import com.google.gson.protobuf.generated.Bag.OuterMessage;
-import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations;
-import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage;
-import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data;
-import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type;
-import com.google.protobuf.GeneratedMessage;
-
-import junit.framework.TestCase;
-
-/**
- * Functional tests for protocol buffers using annotations for field names and enum values.
- *
- * @author Emmanuel Cron
- */
-public class ProtosWithAnnotationsTest extends TestCase {
-  private Gson gson;
-  private Gson gsonWithEnumNumbers;
-  private Gson gsonWithLowerHyphen;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    ProtoTypeAdapter.Builder protoTypeAdapter = ProtoTypeAdapter.newBuilder()
-        .setEnumSerialization(EnumSerialization.NAME)
-        .addSerializedNameExtension(Annotations.serializedName)
-        .addSerializedEnumValueExtension(Annotations.serializedValue);
-    gson = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter.build())
-        .create();
-    gsonWithEnumNumbers = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
-            .setEnumSerialization(EnumSerialization.NUMBER)
-            .build())
-        .create();
-    gsonWithLowerHyphen = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
-            .setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN)
-            .build())
-        .create();
-  }
-
-  public void testProtoWithAnnotations_deserialize() {
-    String json = String.format("{  %n"
-        + "   \"id\":\"41e5e7fd6065d101b97018a465ffff01\",%n"
-        + "   \"expiration_date\":{  %n"
-        + "      \"month\":\"12\",%n"
-        + "      \"year\":\"2017\",%n"
-        + "      \"timeStamp\":\"9864653135687\",%n"
-        + "      \"countryCode5f55\":\"en_US\"%n"
-        + "   },%n"
-        // Don't define innerMessage1
-        + "   \"innerMessage2\":{  %n"
-        // Set a number as a string; it should work
-        + "      \"nIdCt\":\"98798465\",%n"
-        + "      \"content\":\"text/plain\",%n"
-        + "      \"$binary_data$\":[  %n"
-        + "         {  %n"
-        + "            \"data\":\"OFIN8e9fhwoeh8((⁹8efywoih\",%n"
-        // Don't define width
-        + "            \"height\":665%n"
-        + "         },%n"
-        + "         {  %n"
-        // Define as an int; it should work
-        + "            \"data\":65,%n"
-        + "            \"width\":-56684%n"
-        // Don't define height
-        + "         }%n"
-        + "      ]%n"
-        + "   },%n"
-        // Define a bunch of non recognizable data
-        + "   \"non_existing\":\"foobar\",%n"
-        + "   \"stillNot\":{  %n"
-        + "      \"bunch\":\"of_useless data\"%n"
-        + "   }%n"
-        + "}");
-    ProtoWithAnnotations proto = gson.fromJson(json, ProtoWithAnnotations.class);
-    assertThat(proto.getId()).isEqualTo("41e5e7fd6065d101b97018a465ffff01");
-    assertThat(proto.getOuterMessage()).isEqualTo(OuterMessage.newBuilder()
-        .setMonth(12)
-        .setYear(2017)
-        .setLongTimestamp(9864653135687L)
-        .setCountryCode5F55("en_US")
-        .build());
-    assertThat(proto.hasInnerMessage1()).isFalse();
-    assertThat(proto.getInnerMessage2()).isEqualTo(InnerMessage.newBuilder()
-        .setNIdCt(98798465)
-        .setContent(Type.TEXT)
-        .addData(Data.newBuilder()
-            .setData("OFIN8e9fhwoeh8((⁹8efywoih")
-            .setHeight(665))
-        .addData(Data.newBuilder()
-            .setData("65")
-            .setWidth(-56684))
-        .build());
-
-    String rebuilt = gson.toJson(proto);
-    assertThat(rebuilt).isEqualTo("{"
-        + "\"id\":\"41e5e7fd6065d101b97018a465ffff01\","
-        + "\"expiration_date\":{"
-        + "\"month\":12,"
-        + "\"year\":2017,"
-        + "\"timeStamp\":9864653135687,"
-        + "\"countryCode5f55\":\"en_US\""
-        + "},"
-        + "\"innerMessage2\":{"
-        + "\"nIdCt\":98798465,"
-        + "\"content\":\"text/plain\","
-        + "\"$binary_data$\":["
-        + "{"
-        + "\"data\":\"OFIN8e9fhwoeh8((⁹8efywoih\","
-        + "\"height\":665"
-        + "},"
-        + "{"
-        + "\"data\":\"65\","
-        + "\"width\":-56684"
-        + "}]}}");
-  }
-
-  public void testProtoWithAnnotations_deserializeUnknownEnumValue() {
-    String json = String.format("{  %n"
-        + "   \"content\":\"UNKNOWN\"%n"
-        + "}");
-    InnerMessage proto = gson.fromJson(json, InnerMessage.class);
-    assertThat(proto.getContent()).isEqualTo(Type.UNKNOWN);
-  }
-
-  public void testProtoWithAnnotations_deserializeUnrecognizedEnumValue() {
-    String json = String.format("{  %n"
-        + "   \"content\":\"UNRECOGNIZED\"%n"
-        + "}");
-    try {
-      gson.fromJson(json, InnerMessage.class);
-      assert_().fail("Should have thrown");
-    } catch (JsonParseException e) {
-      // expected
-    }
-  }
-
-  public void testProtoWithAnnotations_deserializeWithEnumNumbers() {
-    String json = String.format("{  %n"
-        + "   \"content\":\"0\"%n"
-        + "}");
-    InnerMessage proto = gsonWithEnumNumbers.fromJson(json, InnerMessage.class);
-    assertThat(proto.getContent()).isEqualTo(Type.UNKNOWN);
-    String rebuilt = gsonWithEnumNumbers.toJson(proto);
-    assertThat(rebuilt).isEqualTo("{\"content\":0}");
-
-    json = String.format("{  %n"
-        + "   \"content\":\"2\"%n"
-        + "}");
-    proto = gsonWithEnumNumbers.fromJson(json, InnerMessage.class);
-    assertThat(proto.getContent()).isEqualTo(Type.IMAGE);
-    rebuilt = gsonWithEnumNumbers.toJson(proto);
-    assertThat(rebuilt).isEqualTo("{\"content\":2}");
-  }
-
-  public void testProtoWithAnnotations_serialize() {
-    ProtoWithAnnotations proto = ProtoWithAnnotations.newBuilder()
-        .setId("09f3j20839h032y0329hf30932h0nffn")
-        .setOuterMessage(OuterMessage.newBuilder()
-            .setMonth(14)
-            .setYear(6650)
-            .setLongTimestamp(468406876880768L))
-        .setInnerMessage1(InnerMessage.newBuilder()
-            .setNIdCt(12)
-            .setContent(Type.IMAGE)
-            .addData(Data.newBuilder()
-                .setData("data$$")
-                .setWidth(200))
-            .addData(Data.newBuilder()
-                .setHeight(56)))
-        .build();
-
-    String json = gsonWithLowerHyphen.toJson(proto);
-    assertThat(json).isEqualTo(
-        "{\"id\":\"09f3j20839h032y0329hf30932h0nffn\","
-        + "\"expiration_date\":{"
-            + "\"month\":14,"
-            + "\"year\":6650,"
-            + "\"timeStamp\":468406876880768"
-        + "},"
-        // This field should be using hyphens
-        + "\"inner-message-1\":{"
-            + "\"n--id-ct\":12,"
-            + "\"content\":2,"
-            + "\"$binary_data$\":["
-              + "{"
-                  + "\"data\":\"data$$\","
-                  + "\"width\":200"
-              + "},"
-              + "{"
-                  + "\"height\":56"
-              + "}]"
-            + "}"
-        + "}");
-
-    ProtoWithAnnotations rebuilt = gsonWithLowerHyphen.fromJson(json, ProtoWithAnnotations.class);
-    assertThat(rebuilt).isEqualTo(proto);
-  }
-}
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
deleted file mode 100644
index b61d3f509..000000000
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.protobuf.functional;
-
-import com.google.common.base.CaseFormat;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonObject;
-import com.google.gson.protobuf.ProtoTypeAdapter;
-import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
-import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
-import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
-import com.google.gson.protobuf.generated.Bag.SimpleProto;
-import com.google.protobuf.GeneratedMessage;
-
-import junit.framework.TestCase;
-
-/**
- * Functional tests for protocol buffers using complex and repeated fields
- *
- * @author Inderjeet Singh
- */
-public class ProtosWithComplexAndRepeatedFieldsTest extends TestCase {
-  private Gson gson;
-  private Gson upperCamelGson;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    gson =
-        new GsonBuilder()
-            .registerTypeHierarchyAdapter(GeneratedMessage.class,
-                ProtoTypeAdapter.newBuilder()
-                    .setEnumSerialization(EnumSerialization.NUMBER)
-                    .build())
-            .create();
-    upperCamelGson =
-        new GsonBuilder()
-            .registerTypeHierarchyAdapter(
-                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
-                    .setFieldNameSerializationFormat(
-                        CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
-                    .build())
-            .create();
-  }
-
-  public void testSerializeRepeatedFields() {
-    ProtoWithRepeatedFields proto = ProtoWithRepeatedFields.newBuilder()
-      .addNumbers(2)
-      .addNumbers(3)
-      .addSimples(SimpleProto.newBuilder().setMsg("foo").build())
-      .addSimples(SimpleProto.newBuilder().setCount(3).build())
-      .build();
-    String json = gson.toJson(proto);
-    assertTrue(json.contains("[2,3]"));
-    assertTrue(json.contains("foo"));
-    assertTrue(json.contains("count"));
-  }
-
-  public void testDeserializeRepeatedFieldsProto() {
-    String json = "{numbers:[4,6],simples:[{msg:'bar'},{count:7}]}";
-    ProtoWithRepeatedFields proto =
-      gson.fromJson(json, ProtoWithRepeatedFields.class);
-    assertEquals(4, proto.getNumbers(0));
-    assertEquals(6, proto.getNumbers(1));
-    assertEquals("bar", proto.getSimples(0).getMsg());
-    assertEquals(7, proto.getSimples(1).getCount());
-  }
-
-  public void testSerializeDifferentCaseFormat() {
-    final ProtoWithDifferentCaseFormat proto =
-      ProtoWithDifferentCaseFormat.newBuilder()
-        .setAnotherField("foo")
-        .addNameThatTestsCaseFormat("bar")
-        .build();
-    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
-    assertEquals("foo", json.get("AnotherField").getAsString());
-    assertEquals("bar", json.get("NameThatTestsCaseFormat").getAsJsonArray().get(0).getAsString());
-  }
-
-  public void testDeserializeDifferentCaseFormat() {
-    final String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
-    ProtoWithDifferentCaseFormat proto =
-      upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
-    assertEquals("foo", proto.getAnotherField());
-    assertEquals("bar", proto.getNameThatTestsCaseFormat(0));
-  }
-}
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
deleted file mode 100644
index 69b877e60..000000000
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.gson.protobuf.functional;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.protobuf.ProtoTypeAdapter;
-import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
-import com.google.gson.protobuf.generated.Bag.SimpleProto;
-import com.google.protobuf.Descriptors.Descriptor;
-import com.google.protobuf.GeneratedMessage;
-
-import junit.framework.TestCase;
-
-public class ProtosWithPrimitiveTypesTest extends TestCase {
-  private Gson gson;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    gson = new GsonBuilder().registerTypeHierarchyAdapter(
-      GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
-          .setEnumSerialization(EnumSerialization.NUMBER)
-          .build())
-      .create();
-  }
-
-  public void testSerializeEmptyProto() {
-    SimpleProto proto = SimpleProto.newBuilder().build();
-    String json = gson.toJson(proto);
-    assertEquals("{}", json);
-  }
-
-  public void testDeserializeEmptyProto() {
-    SimpleProto proto = gson.fromJson("{}", SimpleProto.class);
-    assertFalse(proto.hasCount());
-    assertFalse(proto.hasMsg());
-  }
-
-  public void testSerializeProto() {
-    Descriptor descriptor = SimpleProto.getDescriptor();
-    SimpleProto proto = SimpleProto.newBuilder()
-      .setCount(3)
-      .setMsg("foo")
-      .build();
-    String json = gson.toJson(proto);
-    assertTrue(json.contains("\"msg\":\"foo\""));
-    assertTrue(json.contains("\"count\":3"));
-  }
-
-  public void testDeserializeProto() {
-    SimpleProto proto = gson.fromJson("{msg:'foo',count:3}", SimpleProto.class);
-    assertEquals("foo", proto.getMsg());
-    assertEquals(3, proto.getCount());
-  }
-
-  public void testDeserializeWithExplicitNullValue() {
-    SimpleProto proto = gson.fromJson("{msg:'foo',count:null}", SimpleProto.class);
-    assertEquals("foo", proto.getMsg());
-    assertEquals(0, proto.getCount());
-  }
-
-}
