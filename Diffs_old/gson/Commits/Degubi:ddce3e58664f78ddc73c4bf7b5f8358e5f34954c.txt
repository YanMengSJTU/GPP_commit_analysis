diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 0e963e197..144376968 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -26,6 +26,7 @@
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.function.*;
+import java.util.stream.*;
 
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
@@ -97,7 +98,7 @@
 
 	final Excluder excluder;
 	final Function<Field, String> fieldNamingStrategy;
-	final Map<Type, InstanceCreator<?>> instanceCreators;
+	final Map<Type, Function<Class<?>, ?>> instanceCreators;
 	final boolean serializeNulls;
 	final boolean complexMapKeySerialization;
 	final boolean generateNonExecutableJson;
@@ -107,7 +108,7 @@
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
 	Gson(Excluder excluder, Function<Field, String> fieldNamingStrategy,
-			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+			Map<Type, Function<Class<?>, ?>> instanceCreators, boolean serializeNulls,
 			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
 			boolean prettyPrinting,
 			List<TypeAdapterFactory> builderFactories,
@@ -231,6 +232,10 @@ public static JsonElement parseReader(Reader reader) throws JsonIOException, Jso
 		}
 	}
 
+	public static Stream<JsonElement> parsing(String json){
+		return StreamSupport.stream(new JsonSpliterator(json), false);
+	}
+	
 	/**
 	 * Returns the next value from the JSON stream as a parse tree.
 	 *
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 2180891a5..8294b4087 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -62,7 +62,7 @@
 public final class GsonBuilder {
 	private Excluder excluder;
 	private Function<Field, String> fieldNamingPolicy;
-	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, Function<Class<?>, ?>> instanceCreators;
 	private final List<TypeAdapterFactory> factories;
 	/** tree-style hierarchy factories. These come after factories for backwards compatibility. */
 	private final List<TypeAdapterFactory> hierarchyFactories;
@@ -373,8 +373,8 @@ public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
 		return this;
 	}
 	
-	public GsonBuilder registerInstanceCreator(Type type, InstanceCreator<?> instanceCreator) {
-		instanceCreators.put(type, instanceCreator);
+	public<T> GsonBuilder registerInstanceCreator(Type type, Function<Class<T>, T> instanceCreator) {
+		instanceCreators.put(type, (Function) instanceCreator);
 		return this;
 	}
 
diff --git a/gson/src/main/java/com/google/gson/InstanceCreator.java b/gson/src/main/java/com/google/gson/InstanceCreator.java
deleted file mode 100644
index c71d11ab5..000000000
--- a/gson/src/main/java/com/google/gson/InstanceCreator.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import java.lang.reflect.Type;
-
-/**
- * This interface is implemented to create instances of a class that does not define a no-args
- * constructor. If you can modify the class, you should instead add a private, or public
- * no-args constructor. However, that is not possible for library classes, such as JDK classes, or
- * a third-party library that you do not have source-code of. In such cases, you should define an
- * instance creator for the class. Implementations of this interface should be registered with
- * {@link GsonBuilder#registerTypeAdapter(Type, Object)} method before Gson will be able to use
- * them.
- * <p>Let us look at an example where defining an InstanceCreator might be useful. The
- * {@code Id} class defined below does not have a default no-args constructor.</p>
- *
- * <pre>
- * public class Id&lt;T&gt; {
- *   private final Class&lt;T&gt; clazz;
- *   private final long value;
- *   public Id(Class&lt;T&gt; clazz, long value) {
- *     this.clazz = clazz;
- *     this.value = value;
- *   }
- * }
- * </pre>
- *
- * <p>If Gson encounters an object of type {@code Id} during deserialization, it will throw an
- * exception. The easiest way to solve this problem will be to add a (public or private) no-args
- * constructor as follows:</p>
- *
- * <pre>
- * private Id() {
- *   this(Object.class, 0L);
- * }
- * </pre>
- *
- * <p>However, let us assume that the developer does not have access to the source-code of the
- * {@code Id} class, or does not want to define a no-args constructor for it. The developer
- * can solve this problem by defining an {@code InstanceCreator} for {@code Id}:</p>
- *
- * <pre>
- * class IdInstanceCreator implements InstanceCreator&lt;Id&gt; {
- *   public Id createInstance(Type type) {
- *     return new Id(Object.class, 0L);
- *   }
- * }
- * </pre>
- *
- * <p>Note that it does not matter what the fields of the created instance contain since Gson will
- * overwrite them with the deserialized values specified in Json. You should also ensure that a
- * <i>new</i> object is returned, not a common object since its fields will be overwritten.
- * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>
- *
- * <pre>
- * Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).build();
- * </pre>
- *
- * @param <T> the type of object that will be created by this implementation.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public interface InstanceCreator<T> {
-
-  /**
-   * Gson invokes this call-back method during deserialization to create an instance of the
-   * specified type. The fields of the returned instance are overwritten with the data present
-   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not
-   * return an instance that is useful elsewhere. In particular, do not return a common instance,
-   * always use {@code new} to create a new instance.
-   *
-   * @param type the parameterized T represented as a {@link Type}.
-   * @return a default object instance of type T.
-   */
-  public T createInstance(Class<T> type);
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/JsonStreamParser.java b/gson/src/main/java/com/google/gson/JsonStreamParser.java
index 801487b76..7aa221aa1 100644
--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java
@@ -18,7 +18,6 @@
 import com.google.gson.stream.*;
 import java.io.*;
 import java.util.*;
-import java.util.stream.*;
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
@@ -64,10 +63,6 @@ public JsonStreamParser(Reader reader) {
 		lock = new Object();
 	}
 	
-	public static Stream<JsonElement> fromString(String json){
-		return StreamSupport.stream(Spliterators.spliteratorUnknownSize(new JsonStreamParser(json), Spliterator.ORDERED), false);
-	}
-
 	/**
 	 * Returns the next available {@link JsonElement} on the reader. Null if none available.
 	 * 
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index 7150c5cf6..d1ddc07ae 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -28,24 +28,23 @@
  */
 public final class ConstructorConstructor {
 
-  public static <T> Supplier<T> get(TypeToken<T> typeToken, Map<Type, InstanceCreator<?>> instanceCreators) {
+  public static <T> Supplier<T> get(TypeToken<T> typeToken, Map<Type, Function<Class<?>, ?>> instanceCreators) {
     final Type type = typeToken.getType();
     final Class<T> rawType = (Class<T>) typeToken.getRawType();
 
     // first try an instance creator
 
     @SuppressWarnings("unchecked") // types must agree
-    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
+    Function<Class<T>, T> typeCreator = (Function) instanceCreators.get(type);
     if (typeCreator != null) {
-      return () -> typeCreator.createInstance(rawType);
+      return () -> typeCreator.apply(rawType);
     }
 
     // Next try raw type match for instance creators
     @SuppressWarnings("unchecked") // types must agree
-    final InstanceCreator<T> rawTypeCreator =
-        (InstanceCreator<T>) instanceCreators.get(rawType);
+    Function<Class<T>, T> rawTypeCreator = (Function) instanceCreators.get(rawType);
     if (rawTypeCreator != null) {
-      return () -> rawTypeCreator.createInstance(rawType);
+      return () -> rawTypeCreator.apply(rawType);
     }
 
     Supplier<T> defaultConstructor = newDefaultConstructor(rawType);
@@ -104,12 +103,10 @@
               Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
               if (elementType instanceof Class) {
                 return (T) EnumSet.noneOf((Class)elementType);
-              } else {
-                throw new JsonIOException("Invalid EnumSet type: " + type.toString());
               }
-            } else {
-              throw new JsonIOException("Invalid EnumSet type: " + type.toString());
+			throw new JsonIOException("Invalid EnumSet type: " + type.toString());
             }
+			throw new JsonIOException("Invalid EnumSet type: " + type.toString());
           };
       } else if (Set.class.isAssignableFrom(rawType)) {
         return () -> (T) new LinkedHashSet<>();
diff --git a/gson/src/main/java/com/google/gson/internal/JsonSpliterator.java b/gson/src/main/java/com/google/gson/internal/JsonSpliterator.java
new file mode 100644
index 000000000..481e8f256
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/JsonSpliterator.java
@@ -0,0 +1,41 @@
+package com.google.gson.internal;
+
+import com.google.gson.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.util.*;
+import java.util.function.*;
+
+public class JsonSpliterator implements Spliterator<JsonElement>{
+	private final JsonReader parser;
+	
+	public JsonSpliterator(String json) {
+		this.parser = new JsonReader(new StringReader(json));
+	}
+	
+	@Override
+	public boolean tryAdvance(Consumer<? super JsonElement> action) {
+		try {
+			return parser.peek() != JsonToken.END_DOCUMENT;
+		} catch (MalformedJsonException e) {
+			throw new JsonSyntaxException(e);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
+
+	@Override
+	public Spliterator<JsonElement> trySplit() {
+		return null;
+	}
+
+	@Override
+	public long estimateSize() {
+		return Long.MAX_VALUE;
+	}
+
+	@Override
+	public int characteristics() {
+		return Spliterator.ORDERED;
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
index 9181cd483..2e3e29e1e 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
@@ -36,273 +36,271 @@
  * @author Jesse Wilson
  */
 public final class JsonTreeReader extends JsonReader {
-  private static final Object SENTINEL_CLOSED = new Object();
+	private static final Object SENTINEL_CLOSED = new Object();
 
-  /*
-   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
-   */
-  private Object[] stack = new Object[32];
-  private int stackSize = 0;
+	/*
+	 * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+	 */
+	private Object[] stack = new Object[32];
+	private int stackSize = 0;
 
-  /*
-   * The path members. It corresponds directly to stack: At indices where the
-   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
-   * pathNames contains the name at this scope. Where it contains an array
-   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
-   * that array. Otherwise the value is undefined, and we take advantage of that
-   * by incrementing pathIndices when doing so isn't useful.
-   */
-  private String[] pathNames = new String[32];
-  private int[] pathIndices = new int[32];
+	/*
+	 * The path members. It corresponds directly to stack: At indices where the
+	 * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+	 * pathNames contains the name at this scope. Where it contains an array
+	 * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+	 * that array. Otherwise the value is undefined, and we take advantage of that
+	 * by incrementing pathIndices when doing so isn't useful.
+	 */
+	private String[] pathNames = new String[32];
+	private int[] pathIndices = new int[32];
 
-  public JsonTreeReader(JsonElement element) {
-    super(Reader.nullReader());
-    push(element);
-  }
+	public JsonTreeReader(JsonElement element) {
+		super(Reader.nullReader());
+		push(element);
+	}
 
-  @Override public void beginArray() throws IOException {
-    expect(JsonToken.BEGIN_ARRAY);
-    JsonArray array = (JsonArray) peekStack();
-    push(array.iterator());
-    pathIndices[stackSize - 1] = 0;
-  }
+	@Override public void beginArray() throws IOException {
+		expect(JsonToken.BEGIN_ARRAY);
+		JsonArray array = (JsonArray) peekStack();
+		push(array.iterator());
+		pathIndices[stackSize - 1] = 0;
+	}
 
-  @Override public void endArray() throws IOException {
-    expect(JsonToken.END_ARRAY);
-    popStack(); // empty iterator
-    popStack(); // array
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-  }
+	@Override public void endArray() throws IOException {
+		expect(JsonToken.END_ARRAY);
+		popStack(); // empty iterator
+		popStack(); // array
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+	}
 
-  @Override public void beginObject() throws IOException {
-    expect(JsonToken.BEGIN_OBJECT);
-    JsonObject object = (JsonObject) peekStack();
-    push(object.entrySet().iterator());
-  }
+	@Override public void beginObject() throws IOException {
+		expect(JsonToken.BEGIN_OBJECT);
+		JsonObject object = (JsonObject) peekStack();
+		push(object.entrySet().iterator());
+	}
 
-  @Override public void endObject() throws IOException {
-    expect(JsonToken.END_OBJECT);
-    popStack(); // empty iterator
-    popStack(); // object
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-  }
+	@Override public void endObject() throws IOException {
+		expect(JsonToken.END_OBJECT);
+		popStack(); // empty iterator
+		popStack(); // object
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+	}
 
-  @Override public boolean hasNext() throws IOException {
-    JsonToken token = peek();
-    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
-  }
+	@Override public boolean hasNext() throws IOException {
+		JsonToken token = peek();
+		return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
+	}
 
-  @Override public JsonToken peek() throws IOException {
-    if (stackSize == 0) {
-      return JsonToken.END_DOCUMENT;
-    }
+	@Override public JsonToken peek() throws IOException {
+		if (stackSize == 0) {
+			return JsonToken.END_DOCUMENT;
+		}
 
-    Object o = peekStack();
-    if (o instanceof Iterator) {
-      boolean isObject = stack[stackSize - 2] instanceof JsonObject;
-      Iterator<?> iterator = (Iterator<?>) o;
-      if (iterator.hasNext()) {
-        if (isObject) {
-          return JsonToken.NAME;
-        } else {
-          push(iterator.next());
-          return peek();
-        }
-      } else {
-        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
-      }
-    } else if (o instanceof JsonObject) {
-      return JsonToken.BEGIN_OBJECT;
-    } else if (o instanceof JsonArray) {
-      return JsonToken.BEGIN_ARRAY;
-    } else if (o instanceof JsonPrimitive) {
-      JsonPrimitive primitive = (JsonPrimitive) o;
-      if (primitive.isString()) {
-        return JsonToken.STRING;
-      } else if (primitive.isBoolean()) {
-        return JsonToken.BOOLEAN;
-      } else if (primitive.isNumber()) {
-        return JsonToken.NUMBER;
-      } else {
-        throw new AssertionError();
-      }
-    } else if (o instanceof JsonNull) {
-      return JsonToken.NULL;
-    } else if (o == SENTINEL_CLOSED) {
-      throw new IllegalStateException("JsonReader is closed");
-    } else {
-      throw new AssertionError();
-    }
-  }
+		Object o = peekStack();
+		if (o instanceof Iterator) {
+			boolean isObject = stack[stackSize - 2] instanceof JsonObject;
+			Iterator<?> iterator = (Iterator<?>) o;
+			if (iterator.hasNext()) {
+				if (isObject) {
+					return JsonToken.NAME;
+				}
+				push(iterator.next());
+				return peek();
+			}
+			return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
+		} else if (o instanceof JsonObject) {
+			return JsonToken.BEGIN_OBJECT;
+		} else if (o instanceof JsonArray) {
+			return JsonToken.BEGIN_ARRAY;
+		} else if (o instanceof JsonPrimitive) {
+			JsonPrimitive primitive = (JsonPrimitive) o;
+			if (primitive.isString()) {
+				return JsonToken.STRING;
+			} else if (primitive.isBoolean()) {
+				return JsonToken.BOOLEAN;
+			} else if (primitive.isNumber()) {
+				return JsonToken.NUMBER;
+			} else {
+				throw new AssertionError();
+			}
+		} else if (o instanceof JsonNull) {
+			return JsonToken.NULL;
+		} else if (o == SENTINEL_CLOSED) {
+			throw new IllegalStateException("JsonReader is closed");
+		} else {
+			throw new AssertionError();
+		}
+	}
 
-  private Object peekStack() {
-    return stack[stackSize - 1];
-  }
+	private Object peekStack() {
+		return stack[stackSize - 1];
+	}
 
-  private Object popStack() {
-    Object result = stack[--stackSize];
-    stack[stackSize] = null;
-    return result;
-  }
+	private Object popStack() {
+		Object result = stack[--stackSize];
+		stack[stackSize] = null;
+		return result;
+	}
 
-  private void expect(JsonToken expected) throws IOException {
-    if (peek() != expected) {
-      throw new IllegalStateException(
-          "Expected " + expected + " but was " + peek() + locationString());
-    }
-  }
+	private void expect(JsonToken expected) throws IOException {
+		if (peek() != expected) {
+			throw new IllegalStateException(
+					"Expected " + expected + " but was " + peek() + locationString());
+		}
+	}
 
-  @Override public String nextName() throws IOException {
-    expect(JsonToken.NAME);
-    Iterator<?> i = (Iterator<?>) peekStack();
-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    String result = (String) entry.getKey();
-    pathNames[stackSize - 1] = result;
-    push(entry.getValue());
-    return result;
-  }
+	@Override public String nextName() throws IOException {
+		expect(JsonToken.NAME);
+		Iterator<?> i = (Iterator<?>) peekStack();
+		Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
+		String result = (String) entry.getKey();
+		pathNames[stackSize - 1] = result;
+		push(entry.getValue());
+		return result;
+	}
 
-  @Override public String nextString() throws IOException {
-    JsonToken token = peek();
-    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
-      throw new IllegalStateException(
-          "Expected " + JsonToken.STRING + " but was " + token + locationString());
-    }
-    String result = ((JsonPrimitive) popStack()).getAsString();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-    return result;
-  }
+	@Override public String nextString() throws IOException {
+		JsonToken token = peek();
+		if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
+			throw new IllegalStateException(
+					"Expected " + JsonToken.STRING + " but was " + token + locationString());
+		}
+		String result = ((JsonPrimitive) popStack()).getAsString();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+		return result;
+	}
 
-  @Override public boolean nextBoolean() throws IOException {
-    expect(JsonToken.BOOLEAN);
-    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-    return result;
-  }
+	@Override public boolean nextBoolean() throws IOException {
+		expect(JsonToken.BOOLEAN);
+		boolean result = ((JsonPrimitive) popStack()).getAsBoolean();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+		return result;
+	}
 
-  @Override public void nextNull() throws IOException {
-    expect(JsonToken.NULL);
-    popStack();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-  }
+	@Override public void nextNull() throws IOException {
+		expect(JsonToken.NULL);
+		popStack();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+	}
 
-  @Override public double nextDouble() throws IOException {
-    JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(
-          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
-    }
-    double result = ((JsonPrimitive) peekStack()).getAsDouble();
-    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
-    }
-    popStack();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-    return result;
-  }
+	@Override public double nextDouble() throws IOException {
+		JsonToken token = peek();
+		if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
+			throw new IllegalStateException(
+					"Expected " + JsonToken.NUMBER + " but was " + token + locationString());
+		}
+		double result = ((JsonPrimitive) peekStack()).getAsDouble();
+		if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
+			throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
+		}
+		popStack();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+		return result;
+	}
 
-  @Override public long nextLong() throws IOException {
-    JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(
-          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
-    }
-    long result = ((JsonPrimitive) peekStack()).getAsLong();
-    popStack();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-    return result;
-  }
+	@Override public long nextLong() throws IOException {
+		JsonToken token = peek();
+		if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
+			throw new IllegalStateException(
+					"Expected " + JsonToken.NUMBER + " but was " + token + locationString());
+		}
+		long result = ((JsonPrimitive) peekStack()).getAsLong();
+		popStack();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+		return result;
+	}
 
-  @Override public int nextInt() throws IOException {
-    JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(
-          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
-    }
-    int result = ((JsonPrimitive) peekStack()).getAsInt();
-    popStack();
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-    return result;
-  }
+	@Override public int nextInt() throws IOException {
+		JsonToken token = peek();
+		if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
+			throw new IllegalStateException(
+					"Expected " + JsonToken.NUMBER + " but was " + token + locationString());
+		}
+		int result = ((JsonPrimitive) peekStack()).getAsInt();
+		popStack();
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+		return result;
+	}
 
-  @Override public void close() throws IOException {
-    stack = new Object[] { SENTINEL_CLOSED };
-    stackSize = 1;
-  }
+	@Override public void close() throws IOException {
+		stack = new Object[] { SENTINEL_CLOSED };
+		stackSize = 1;
+	}
 
-  @Override public void skipValue() throws IOException {
-    if (peek() == JsonToken.NAME) {
-      nextName();
-      pathNames[stackSize - 2] = "null";
-    } else {
-      popStack();
-      if (stackSize > 0) {
-        pathNames[stackSize - 1] = "null";
-      }
-    }
-    if (stackSize > 0) {
-      pathIndices[stackSize - 1]++;
-    }
-  }
+	@Override public void skipValue() throws IOException {
+		if (peek() == JsonToken.NAME) {
+			nextName();
+			pathNames[stackSize - 2] = "null";
+		} else {
+			popStack();
+			if (stackSize > 0) {
+				pathNames[stackSize - 1] = "null";
+			}
+		}
+		if (stackSize > 0) {
+			pathIndices[stackSize - 1]++;
+		}
+	}
 
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
+	@Override public String toString() {
+		return getClass().getSimpleName();
+	}
 
-  public void promoteNameToValue() throws IOException {
-    expect(JsonToken.NAME);
-    Iterator<?> i = (Iterator<?>) peekStack();
-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    push(entry.getValue());
-    push(new JsonPrimitive((String) entry.getKey()));
-  }
+	public void promoteNameToValue() throws IOException {
+		expect(JsonToken.NAME);
+		Iterator<?> i = (Iterator<?>) peekStack();
+		Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
+		push(entry.getValue());
+		push(new JsonPrimitive((String) entry.getKey()));
+	}
 
-  private void push(Object newTop) {
-    if (stackSize == stack.length) {
-      int newLength = stackSize * 2;
-      stack = Arrays.copyOf(stack, newLength);
-      pathIndices = Arrays.copyOf(pathIndices, newLength);
-      pathNames = Arrays.copyOf(pathNames, newLength);
-    }
-    stack[stackSize++] = newTop;
-  }
+	private void push(Object newTop) {
+		if (stackSize == stack.length) {
+			int newLength = stackSize * 2;
+			stack = Arrays.copyOf(stack, newLength);
+			pathIndices = Arrays.copyOf(pathIndices, newLength);
+			pathNames = Arrays.copyOf(pathNames, newLength);
+		}
+		stack[stackSize++] = newTop;
+	}
 
-  @Override public String getPath() {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0; i < stackSize; i++) {
-      if (stack[i] instanceof JsonArray) {
-        if (stack[++i] instanceof Iterator) {
-          result.append('[').append(pathIndices[i]).append(']');
-        }
-      } else if (stack[i] instanceof JsonObject) {
-        if (stack[++i] instanceof Iterator) {
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-        }
-      }
-    }
-    return result.toString();
-  }
+	@Override public String getPath() {
+		StringBuilder result = new StringBuilder().append('$');
+		for (int i = 0; i < stackSize; i++) {
+			if (stack[i] instanceof JsonArray) {
+				if (stack[++i] instanceof Iterator) {
+					result.append('[').append(pathIndices[i]).append(']');
+				}
+			} else if (stack[i] instanceof JsonObject) {
+				if (stack[++i] instanceof Iterator) {
+					result.append('.');
+					if (pathNames[i] != null) {
+						result.append(pathNames[i]);
+					}
+				}
+			}
+		}
+		return result.toString();
+	}
 
-  private String locationString() {
-    return " at path " + getPath();
-  }
+	private String locationString() {
+		return " at path " + getPath();
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
index 6dc083bc6..a1eccbe77 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
@@ -118,7 +118,8 @@ private void put(JsonElement value) {
 		throw new IllegalStateException();
 	}
 
-	@Override public JsonWriter name(String name) throws IOException {
+	@Override 
+	public JsonWriter name(String name) {
 		if (stack.isEmpty() || pendingName != null) {
 			throw new IllegalStateException();
 		}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
index 58d01b891..1398e0b56 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -29,9 +29,9 @@
  * Adapt a homogeneous collection of objects.
  */
 public final class CollectionTypeAdapterFactory implements TypeAdapterFactory {
-	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, Function<Class<?>, ?>> instanceCreators;
 
-	public CollectionTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators) {
+	public CollectionTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators) {
 		this.instanceCreators = instanceCreators;
 	}
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 9b6a111ae..8b4aa71ec 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -22,6 +22,7 @@
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.*;
 import java.util.*;
+import java.util.function.*;
 
 /**
  * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the
@@ -30,9 +31,9 @@
  * @since 2.3
  */
 public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {
-	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, Function<Class<?>, ?>> instanceCreators;
 
-	public JsonAdapterAnnotationTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators) {
+	public JsonAdapterAnnotationTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators) {
 		this.instanceCreators = instanceCreators;
 	}
 
@@ -48,8 +49,7 @@ public JsonAdapterAnnotationTypeAdapterFactory(Map<Type, InstanceCreator<?>> ins
 	}
 
 	@SuppressWarnings({ "unchecked", "rawtypes" }) // Casts guarded by conditionals.
-	static TypeAdapter<?> getTypeAdapter(Map<Type, InstanceCreator<?>> instanceCreators, Gson gson,
-			TypeToken<?> type, JsonAdapter annotation) {
+	public static TypeAdapter<?> getTypeAdapter(Map<Type, Function<Class<?>, ?>> instanceCreators, Gson gson, TypeToken<?> type, JsonAdapter annotation) {
 		Object instance = ConstructorConstructor.get(TypeToken.get(annotation.value()), instanceCreators).get();
 
 		TypeAdapter<?> typeAdapter;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index a9fe1ee50..b991e8e59 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -91,10 +91,10 @@
  * is registered.
  */
 public final class MapTypeAdapterFactory implements TypeAdapterFactory {
-	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, Function<Class<?>, ?>> instanceCreators;
 	final boolean complexMapKeySerialization;
 
-	public MapTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators,
+	public MapTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators,
 			boolean complexMapKeySerialization) {
 		this.instanceCreators = instanceCreators;
 		this.complexMapKeySerialization = complexMapKeySerialization;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index 3e3519b4a..f055dae49 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -55,7 +55,7 @@
 		JsonToken token = in.peek();
 		switch (token) {
 		case BEGIN_ARRAY:
-			List<Object> list = new ArrayList<Object>();
+			List<Object> list = new ArrayList<>();
 			in.beginArray();
 			while (in.hasNext()) {
 				list.add(read(in));
@@ -64,7 +64,7 @@
 			return list;
 
 		case BEGIN_OBJECT:
-			Map<String, Object> map = new LinkedTreeMap<String, Object>();
+			Map<String, Object> map = new LinkedTreeMap<>();
 			in.beginObject();
 			while (in.hasNext()) {
 				map.put(in.nextName(), read(in));
@@ -106,4 +106,4 @@
 
 		typeAdapter.write(out, value);
 	}
-}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index b50da91b5..5cd8ae00a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -30,11 +30,11 @@
  * Type adapter that reflects over the fields and methods of a class.
  */
 public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
-	private final Map<Type, InstanceCreator<?>> instanceCreators;
+	private final Map<Type, Function<Class<?>, ?>> instanceCreators;
 	private final Function<Field, String> fieldNamingPolicy;
 	private final Excluder excluder;
 
-	public ReflectiveTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators,
+	public ReflectiveTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators,
 			Function<Field, String> fieldNamingPolicy, Excluder excluder) {
 		this.instanceCreators = instanceCreators;
 		this.fieldNamingPolicy = fieldNamingPolicy;
@@ -93,15 +93,15 @@ public boolean excludeField(Field f, boolean serialize) {
 		TypeAdapter<?> typeAdapter = mapped;
 		return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
 			@SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
-			@Override void write(JsonWriter writer, Object value)
-					throws IOException, IllegalAccessException {
+			@Override 
+			void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException {
 				Object fieldValue = field.get(value);
 				TypeAdapter t = jsonAdapterPresent ? typeAdapter
 						: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
 				t.write(writer, fieldValue);
 			}
-			@Override void read(JsonReader reader, Object value)
-					throws IOException, IllegalAccessException {
+			@Override 
+			void read(JsonReader reader, Object value) throws IOException, IllegalAccessException {
 				Object fieldValue = typeAdapter.read(reader);
 				if (fieldValue != null || !isPrimitive) {
 					field.set(value, fieldValue);
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index 21b34b882..1167df01f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -48,7 +48,8 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
 		this.skipPast = skipPast;
 	}
 
-	@Override public T read(JsonReader in) throws IOException {
+	@Override 
+	public T read(JsonReader in) throws IOException {
 		if (deserializer == null) {
 			return delegate().read(in);
 		}
@@ -59,7 +60,8 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
 		return deserializer.deserialize(value, typeToken.getType(), context);
 	}
 
-	@Override public void write(JsonWriter out, T value) throws IOException {
+	@Override 
+	public void write(JsonWriter out, T value) throws IOException {
 		if (serializer == null) {
 			delegate().write(out, value);
 			return;
@@ -74,9 +76,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
 
 	private TypeAdapter<T> delegate() {
 		TypeAdapter<T> d = delegate;
-		return d != null
-				? d
-						: (delegate = gson.getDelegateAdapter(skipPast, typeToken));
+		return d != null ? d : (delegate = gson.getDelegateAdapter(skipPast, typeToken));
 	}
 
 	/**
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index ee81665ce..f97a7b23a 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -499,17 +499,15 @@ int doPeek() throws IOException {
 			case '}':
 				if (peekStack != JsonScope.NONEMPTY_OBJECT) {
 					return peeked = PEEKED_END_OBJECT;
-				} else {
-					throw syntaxError("Expected name");
 				}
+				throw syntaxError("Expected name");
 			default:
 				checkLenient();
 				pos--; // Don't consume the first character in an unquoted string.
 				if (isLiteral((char) c)) {
 					return peeked = PEEKED_UNQUOTED_NAME;
-				} else {
-					throw syntaxError("Expected name");
 				}
+				throw syntaxError("Expected name");
 			}
 		} else if (peekStack == JsonScope.DANGLING_NAME) {
 			stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
@@ -536,10 +534,9 @@ int doPeek() throws IOException {
 			int c = nextNonWhitespace(false);
 			if (c == -1) {
 				return peeked = PEEKED_EOF;
-			} else {
-				checkLenient();
-				pos--;
 			}
+			checkLenient();
+			pos--;
 		} else if (peekStack == JsonScope.CLOSED) {
 			throw new IllegalStateException("JsonReader is closed");
 		}
@@ -558,9 +555,8 @@ int doPeek() throws IOException {
 				checkLenient();
 				pos--;
 				return peeked = PEEKED_NULL;
-			} else {
-				throw syntaxError("Unexpected value");
 			}
+			throw syntaxError("Unexpected value");
 		case '\'':
 			checkLenient();
 			return peeked = PEEKED_SINGLE_QUOTED;
@@ -1505,7 +1501,6 @@ private char readEscapeCharacter() throws IOException {
 			if (pos + 4 > limit && !fillBuffer(4)) {
 				throw syntaxError("Unterminated escape sequence");
 			}
-			// Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
 			char result = 0;
 			for (int i = pos, end = i + 4; i < end; i++) {
 				char c = buffer[i];
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index f365951a8..2cc6212e9 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -128,503 +128,504 @@
  * @author Jesse Wilson
  * @since 1.6
  */
+@SuppressWarnings("boxing")
 public class JsonWriter implements Closeable, Flushable {
 
-  /*
-   * From RFC 7159, "All Unicode characters may be placed within the
-   * quotation marks except for the characters that must be escaped:
-   * quotation mark, reverse solidus, and the control characters
-   * (U+0000 through U+001F)."
-   *
-   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
-   * newline characters. This prevents eval() from failing with a syntax
-   * error. http://code.google.com/p/google-gson/issues/detail?id=341
-   */
-  private static final String[] REPLACEMENT_CHARS;
-  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;
-  static {
-    REPLACEMENT_CHARS = new String[128];
-    for (int i = 0; i <= 0x1f; i++) {
-      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
-    }
-    REPLACEMENT_CHARS['"'] = "\\\"";
-    REPLACEMENT_CHARS['\\'] = "\\\\";
-    REPLACEMENT_CHARS['\t'] = "\\t";
-    REPLACEMENT_CHARS['\b'] = "\\b";
-    REPLACEMENT_CHARS['\n'] = "\\n";
-    REPLACEMENT_CHARS['\r'] = "\\r";
-    REPLACEMENT_CHARS['\f'] = "\\f";
-    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
-    HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
-    HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
-    HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
-    HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
-    HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
-  }
-
-  /** The output data, containing at most one top-level array or object. */
-  private final Writer out;
-
-  private int[] stack = new int[32];
-  private int stackSize = 0;
-  {
-    push(EMPTY_DOCUMENT);
-  }
-
-  /**
-   * A string containing a full set of spaces for a single level of
-   * indentation, or null for no pretty printing.
-   */
-  private String indent;
-
-  /**
-   * The name/value separator; either ":" or ": ".
-   */
-  private String separator = ":";
-
-  private boolean htmlSafe;
-
-  private String deferredName;
-
-  private boolean serializeNulls = true;
-
-  /**
-   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
-   * For best performance, ensure {@link Writer} is buffered; wrapping in
-   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
-   */
-  public JsonWriter(Writer out) {
-    if (out == null) {
-      throw new NullPointerException("out == null");
-    }
-    this.out = out;
-  }
-
-  /**
-   * Sets the indentation string to be repeated for each level of indentation
-   * in the encoded document. If {@code indent.isEmpty()} the encoded document
-   * will be compact. Otherwise the encoded document will be more
-   * human-readable.
-   *
-   * @param indent a string containing only whitespace.
-   */
-  public final void setIndent(String indent) {
-    if (indent.length() == 0) {
-      this.indent = null;
-      this.separator = ":";
-    } else {
-      this.indent = indent;
-      this.separator = ": ";
-    }
-  }
-
-  /**
-   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
-   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
-   * {@code &} and {@code =} before writing them to the stream. Without this
-   * setting, your XML/HTML encoder should replace these characters with the
-   * corresponding escape sequences.
-   */
-  public final void setHtmlSafe(boolean htmlSafe) {
-    this.htmlSafe = htmlSafe;
-  }
-
-  /**
-   * Returns true if this writer writes JSON that's safe for inclusion in HTML
-   * and XML documents.
-   */
-  public final boolean isHtmlSafe() {
-    return htmlSafe;
-  }
-
-  /**
-   * Sets whether object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-  public final void setSerializeNulls(boolean serializeNulls) {
-    this.serializeNulls = serializeNulls;
-  }
-
-  /**
-   * Returns true if object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-  public final boolean getSerializeNulls() {
-    return serializeNulls;
-  }
-
-  /**
-   * Begins encoding a new array. Each call to this method must be paired with
-   * a call to {@link #endArray}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter beginArray() throws IOException {
-    writeDeferredName();
-    return open(EMPTY_ARRAY, "[");
-  }
-
-  /**
-   * Ends encoding the current array.
-   *
-   * @return this writer.
-   */
-  public JsonWriter endArray() throws IOException {
-    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
-  }
-
-  /**
-   * Begins encoding a new object. Each call to this method must be paired
-   * with a call to {@link #endObject}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter beginObject() throws IOException {
-    writeDeferredName();
-    return open(EMPTY_OBJECT, "{");
-  }
-
-  /**
-   * Ends encoding the current object.
-   *
-   * @return this writer.
-   */
-  public JsonWriter endObject() throws IOException {
-    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
-  }
-
-  /**
-   * Enters a new scope by appending any necessary whitespace and the given
-   * bracket.
-   */
-  private JsonWriter open(int empty, String openBracket) throws IOException {
-    beforeValue();
-    push(empty);
-    out.write(openBracket);
-    return this;
-  }
-
-  /**
-   * Closes the current scope by appending any necessary whitespace and the
-   * given bracket.
-   */
-  private JsonWriter close(int empty, int nonempty, String closeBracket)
-      throws IOException {
-    int context = peek();
-    if (context != nonempty && context != empty) {
-      throw new IllegalStateException("Nesting problem.");
-    }
-    if (deferredName != null) {
-      throw new IllegalStateException("Dangling name: " + deferredName);
-    }
-
-    stackSize--;
-    if (context == nonempty) {
-      newline();
-    }
-    out.write(closeBracket);
-    return this;
-  }
-
-  private void push(int newTop) {
-    if (stackSize == stack.length) {
-      stack = Arrays.copyOf(stack, stackSize * 2);
-    }
-    stack[stackSize++] = newTop;
-  }
-
-  /**
-   * Returns the value on the top of the stack.
-   */
-  private int peek() {
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    return stack[stackSize - 1];
-  }
-
-  /**
-   * Replace the value on the top of the stack with the given value.
-   */
-  private void replaceTop(int topOfStack) {
-    stack[stackSize - 1] = topOfStack;
-  }
-
-  /**
-   * Encodes the property name.
-   *
-   * @param name the name of the forthcoming value. May not be null.
-   * @return this writer.
-   */
-  public JsonWriter name(String name) throws IOException {
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    if (deferredName != null) {
-      throw new IllegalStateException();
-    }
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    deferredName = name;
-    return this;
-  }
-
-  private void writeDeferredName() throws IOException {
-    if (deferredName != null) {
-      beforeName();
-      string(deferredName);
-      deferredName = null;
-    }
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  public JsonWriter value(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    string(value);
-    return this;
-  }
-
-  /**
-   * Writes {@code value} directly to the writer without quoting or
-   * escaping.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  public JsonWriter jsonValue(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    out.append(value);
-    return this;
-  }
-
-  /**
-   * Encodes {@code null}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter nullValue() throws IOException {
-    if (deferredName != null) {
-      if (serializeNulls) {
-        writeDeferredName();
-      } else {
-        deferredName = null;
-        return this; // skip the name and the value
-      }
-    }
-    beforeValue();
-    out.write("null");
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter value(boolean value) throws IOException {
-    writeDeferredName();
-    beforeValue();
-    out.write(value ? "true" : "false");
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter value(Boolean value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    out.write(value ? "true" : "false");
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
-  public JsonWriter value(double value) throws IOException {
-    writeDeferredName();
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
-    }
-    beforeValue();
-    out.append(Double.toString(value));
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  public JsonWriter value(long value) throws IOException {
-    writeDeferredName();
-    beforeValue();
-    out.write(Long.toString(value));
-    return this;
-  }
-
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
-  public JsonWriter value(Number value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-
-    writeDeferredName();
-    String string = value.toString();
-    if (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN")) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
-    }
-    beforeValue();
-    out.append(string);
-    return this;
-  }
-
-  /**
-   * Ensures all buffered data is written to the underlying {@link Writer}
-   * and flushes that writer.
-   */
-  public void flush() throws IOException {
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    out.flush();
-  }
-
-  /**
-   * Flushes and closes this writer and the underlying {@link Writer}.
-   *
-   * @throws IOException if the JSON document is incomplete.
-   */
-  public void close() throws IOException {
-    out.close();
-
-    int size = stackSize;
-    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
-      throw new IOException("Incomplete document");
-    }
-    stackSize = 0;
-  }
-
-  private void string(String value) throws IOException {
-    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
-    out.write("\"");
-    int last = 0;
-    int length = value.length();
-    for (int i = 0; i < length; i++) {
-      char c = value.charAt(i);
-      String replacement;
-      if (c < 128) {
-        replacement = replacements[c];
-        if (replacement == null) {
-          continue;
-        }
-      } else if (c == '\u2028') {
-        replacement = "\\u2028";
-      } else if (c == '\u2029') {
-        replacement = "\\u2029";
-      } else {
-        continue;
-      }
-      if (last < i) {
-        out.write(value, last, i - last);
-      }
-      out.write(replacement);
-      last = i + 1;
-    }
-    if (last < length) {
-      out.write(value, last, length - last);
-    }
-    out.write("\"");
-  }
-
-  private void newline() throws IOException {
-    if (indent == null) {
-      return;
-    }
-
-    out.write("\n");
-    for (int i = 1, size = stackSize; i < size; i++) {
-      out.write(indent);
-    }
-  }
-
-  /**
-   * Inserts any necessary separators and whitespace before a name. Also
-   * adjusts the stack to expect the name's value.
-   */
-  private void beforeName() throws IOException {
-    int context = peek();
-    if (context == NONEMPTY_OBJECT) { // first in object
-      out.write(',');
-    } else if (context != EMPTY_OBJECT) { // not in an object!
-      throw new IllegalStateException("Nesting problem.");
-    }
-    newline();
-    replaceTop(DANGLING_NAME);
-  }
-
-  /**
-   * Inserts any necessary separators and whitespace before a literal value,
-   * inline array, or inline object. Also adjusts the stack to expect either a
-   * closing bracket or another element.
-   */
-  @SuppressWarnings("fallthrough")
-  private void beforeValue() throws IOException {
-    switch (peek()) {
-    case NONEMPTY_DOCUMENT:
-        throw new IllegalStateException(
-            "JSON must have only one top-level value.");
-      // fall-through
-    case EMPTY_DOCUMENT: // first in document
-      replaceTop(NONEMPTY_DOCUMENT);
-      break;
-
-    case EMPTY_ARRAY: // first in array
-      replaceTop(NONEMPTY_ARRAY);
-      newline();
-      break;
-
-    case NONEMPTY_ARRAY: // another in array
-      out.append(',');
-      newline();
-      break;
-
-    case DANGLING_NAME: // value for name
-      out.append(separator);
-      replaceTop(NONEMPTY_OBJECT);
-      break;
-
-    default:
-      throw new IllegalStateException("Nesting problem.");
-    }
-  }
+	/*
+	 * From RFC 7159, "All Unicode characters may be placed within the
+	 * quotation marks except for the characters that must be escaped:
+	 * quotation mark, reverse solidus, and the control characters
+	 * (U+0000 through U+001F)."
+	 *
+	 * We also escape '\u2028' and '\u2029', which JavaScript interprets as
+	 * newline characters. This prevents eval() from failing with a syntax
+	 * error. http://code.google.com/p/google-gson/issues/detail?id=341
+	 */
+	private static final String[] REPLACEMENT_CHARS;
+	private static final String[] HTML_SAFE_REPLACEMENT_CHARS;
+	static {
+		REPLACEMENT_CHARS = new String[128];
+		for (int i = 0; i <= 0x1f; i++) {
+			REPLACEMENT_CHARS[i] = String.format("\\u%04x", i);
+		}
+		REPLACEMENT_CHARS['"'] = "\\\"";
+		REPLACEMENT_CHARS['\\'] = "\\\\";
+		REPLACEMENT_CHARS['\t'] = "\\t";
+		REPLACEMENT_CHARS['\b'] = "\\b";
+		REPLACEMENT_CHARS['\n'] = "\\n";
+		REPLACEMENT_CHARS['\r'] = "\\r";
+		REPLACEMENT_CHARS['\f'] = "\\f";
+		HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
+		HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
+		HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
+		HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
+		HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
+		HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
+	}
+
+	/** The output data, containing at most one top-level array or object. */
+	private final Writer out;
+
+	private int[] stack = new int[32];
+	private int stackSize = 0;
+	{
+		push(EMPTY_DOCUMENT);
+	}
+
+	/**
+	 * A string containing a full set of spaces for a single level of
+	 * indentation, or null for no pretty printing.
+	 */
+	private String indent;
+
+	/**
+	 * The name/value separator; either ":" or ": ".
+	 */
+	private String separator = ":";
+
+	private boolean htmlSafe;
+
+	private String deferredName;
+
+	private boolean serializeNulls = true;
+
+	/**
+	 * Creates a new instance that writes a JSON-encoded stream to {@code out}.
+	 * For best performance, ensure {@link Writer} is buffered; wrapping in
+	 * {@link java.io.BufferedWriter BufferedWriter} if necessary.
+	 */
+	public JsonWriter(Writer out) {
+		if (out == null) {
+			throw new NullPointerException("out == null");
+		}
+		this.out = out;
+	}
+
+	/**
+	 * Sets the indentation string to be repeated for each level of indentation
+	 * in the encoded document. If {@code indent.isEmpty()} the encoded document
+	 * will be compact. Otherwise the encoded document will be more
+	 * human-readable.
+	 *
+	 * @param indent a string containing only whitespace.
+	 */
+	public final void setIndent(String indent) {
+		if (indent.length() == 0) {
+			this.indent = null;
+			this.separator = ":";
+		} else {
+			this.indent = indent;
+			this.separator = ": ";
+		}
+	}
+
+	/**
+	 * Configure this writer to emit JSON that's safe for direct inclusion in HTML
+	 * and XML documents. This escapes the HTML characters {@code <}, {@code >},
+	 * {@code &} and {@code =} before writing them to the stream. Without this
+	 * setting, your XML/HTML encoder should replace these characters with the
+	 * corresponding escape sequences.
+	 */
+	public final void setHtmlSafe(boolean htmlSafe) {
+		this.htmlSafe = htmlSafe;
+	}
+
+	/**
+	 * Returns true if this writer writes JSON that's safe for inclusion in HTML
+	 * and XML documents.
+	 */
+	public final boolean isHtmlSafe() {
+		return htmlSafe;
+	}
+
+	/**
+	 * Sets whether object members are serialized when their value is null.
+	 * This has no impact on array elements. The default is true.
+	 */
+	public final void setSerializeNulls(boolean serializeNulls) {
+		this.serializeNulls = serializeNulls;
+	}
+
+	/**
+	 * Returns true if object members are serialized when their value is null.
+	 * This has no impact on array elements. The default is true.
+	 */
+	public final boolean getSerializeNulls() {
+		return serializeNulls;
+	}
+
+	/**
+	 * Begins encoding a new array. Each call to this method must be paired with
+	 * a call to {@link #endArray}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter beginArray() throws IOException {
+		writeDeferredName();
+		return open(EMPTY_ARRAY, "[");
+	}
+
+	/**
+	 * Ends encoding the current array.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter endArray() throws IOException {
+		return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+	}
+
+	/**
+	 * Begins encoding a new object. Each call to this method must be paired
+	 * with a call to {@link #endObject}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter beginObject() throws IOException {
+		writeDeferredName();
+		return open(EMPTY_OBJECT, "{");
+	}
+
+	/**
+	 * Ends encoding the current object.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter endObject() throws IOException {
+		return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+	}
+
+	/**
+	 * Enters a new scope by appending any necessary whitespace and the given
+	 * bracket.
+	 */
+	private JsonWriter open(int empty, String openBracket) throws IOException {
+		beforeValue();
+		push(empty);
+		out.write(openBracket);
+		return this;
+	}
+
+	/**
+	 * Closes the current scope by appending any necessary whitespace and the
+	 * given bracket.
+	 */
+	private JsonWriter close(int empty, int nonempty, String closeBracket)
+			throws IOException {
+		int context = peek();
+		if (context != nonempty && context != empty) {
+			throw new IllegalStateException("Nesting problem.");
+		}
+		if (deferredName != null) {
+			throw new IllegalStateException("Dangling name: " + deferredName);
+		}
+
+		stackSize--;
+		if (context == nonempty) {
+			newline();
+		}
+		out.write(closeBracket);
+		return this;
+	}
+
+	private void push(int newTop) {
+		if (stackSize == stack.length) {
+			stack = Arrays.copyOf(stack, stackSize * 2);
+		}
+		stack[stackSize++] = newTop;
+	}
+
+	/**
+	 * Returns the value on the top of the stack.
+	 */
+	private int peek() {
+		if (stackSize == 0) {
+			throw new IllegalStateException("JsonWriter is closed.");
+		}
+		return stack[stackSize - 1];
+	}
+
+	/**
+	 * Replace the value on the top of the stack with the given value.
+	 */
+	private void replaceTop(int topOfStack) {
+		stack[stackSize - 1] = topOfStack;
+	}
+
+	/**
+	 * Encodes the property name.
+	 *
+	 * @param name the name of the forthcoming value. May not be null.
+	 * @return this writer.
+	 */
+	public JsonWriter name(String name) {
+		if (name == null) {
+			throw new NullPointerException("name == null");
+		}
+		if (deferredName != null) {
+			throw new IllegalStateException();
+		}
+		if (stackSize == 0) {
+			throw new IllegalStateException("JsonWriter is closed.");
+		}
+		deferredName = name;
+		return this;
+	}
+
+	private void writeDeferredName() throws IOException {
+		if (deferredName != null) {
+			beforeName();
+			string(deferredName);
+			deferredName = null;
+		}
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @param value the literal string value, or null to encode a null literal.
+	 * @return this writer.
+	 */
+	public JsonWriter value(String value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+		writeDeferredName();
+		beforeValue();
+		string(value);
+		return this;
+	}
+
+	/**
+	 * Writes {@code value} directly to the writer without quoting or
+	 * escaping.
+	 *
+	 * @param value the literal string value, or null to encode a null literal.
+	 * @return this writer.
+	 */
+	public JsonWriter jsonValue(String value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+		writeDeferredName();
+		beforeValue();
+		out.append(value);
+		return this;
+	}
+
+	/**
+	 * Encodes {@code null}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter nullValue() throws IOException {
+		if (deferredName != null) {
+			if (serializeNulls) {
+				writeDeferredName();
+			} else {
+				deferredName = null;
+				return this; // skip the name and the value
+			}
+		}
+		beforeValue();
+		out.write("null");
+		return this;
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter value(boolean value) throws IOException {
+		writeDeferredName();
+		beforeValue();
+		out.write(value ? "true" : "false");
+		return this;
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter value(Boolean value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+		writeDeferredName();
+		beforeValue();
+		out.write(value ? "true" : "false");
+		return this;
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+	 *     {@link Double#isInfinite() infinities}.
+	 * @return this writer.
+	 */
+	public JsonWriter value(double value) throws IOException {
+		writeDeferredName();
+		if (Double.isNaN(value) || Double.isInfinite(value)) {
+			throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+		}
+		beforeValue();
+		out.append(Double.toString(value));
+		return this;
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @return this writer.
+	 */
+	public JsonWriter value(long value) throws IOException {
+		writeDeferredName();
+		beforeValue();
+		out.write(Long.toString(value));
+		return this;
+	}
+
+	/**
+	 * Encodes {@code value}.
+	 *
+	 * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+	 *     {@link Double#isInfinite() infinities}.
+	 * @return this writer.
+	 */
+	public JsonWriter value(Number value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+
+		writeDeferredName();
+		String string = value.toString();
+		if (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN")) {
+			throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+		}
+		beforeValue();
+		out.append(string);
+		return this;
+	}
+
+	/**
+	 * Ensures all buffered data is written to the underlying {@link Writer}
+	 * and flushes that writer.
+	 */
+	@Override
+	public void flush() throws IOException {
+		if (stackSize == 0) {
+			throw new IllegalStateException("JsonWriter is closed.");
+		}
+		out.flush();
+	}
+
+	/**
+	 * Flushes and closes this writer and the underlying {@link Writer}.
+	 *
+	 * @throws IOException if the JSON document is incomplete.
+	 */
+	@Override
+	public void close() throws IOException {
+		out.close();
+
+		int size = stackSize;
+		if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
+			throw new IOException("Incomplete document");
+		}
+		stackSize = 0;
+	}
+
+	private void string(String value) throws IOException {
+		String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
+		out.write("\"");
+		int last = 0;
+		int length = value.length();
+		for (int i = 0; i < length; i++) {
+			char c = value.charAt(i);
+			String replacement;
+			if (c < 128) {
+				replacement = replacements[c];
+				if (replacement == null) {
+					continue;
+				}
+			} else if (c == '\u2028') {
+				replacement = "\\u2028";
+			} else if (c == '\u2029') {
+				replacement = "\\u2029";
+			} else {
+				continue;
+			}
+			if (last < i) {
+				out.write(value, last, i - last);
+			}
+			out.write(replacement);
+			last = i + 1;
+		}
+		if (last < length) {
+			out.write(value, last, length - last);
+		}
+		out.write("\"");
+	}
+
+	private void newline() throws IOException {
+		if (indent == null) {
+			return;
+		}
+
+		out.write("\n");
+		for (int i = 1, size = stackSize; i < size; i++) {
+			out.write(indent);
+		}
+	}
+
+	/**
+	 * Inserts any necessary separators and whitespace before a name. Also
+	 * adjusts the stack to expect the name's value.
+	 */
+	private void beforeName() throws IOException {
+		int context = peek();
+		if (context == NONEMPTY_OBJECT) { // first in object
+			out.write(',');
+		} else if (context != EMPTY_OBJECT) { // not in an object!
+			throw new IllegalStateException("Nesting problem.");
+		}
+		newline();
+		replaceTop(DANGLING_NAME);
+	}
+
+	/**
+	 * Inserts any necessary separators and whitespace before a literal value,
+	 * inline array, or inline object. Also adjusts the stack to expect either a
+	 * closing bracket or another element.
+	 */
+	private void beforeValue() throws IOException {
+		switch (peek()) {
+		case NONEMPTY_DOCUMENT:
+			throw new IllegalStateException("JSON must have only one top-level value.");
+			// fall-through
+		case EMPTY_DOCUMENT: // first in document
+			replaceTop(NONEMPTY_DOCUMENT);
+			break;
+
+		case EMPTY_ARRAY: // first in array
+			replaceTop(NONEMPTY_ARRAY);
+			newline();
+			break;
+
+		case NONEMPTY_ARRAY: // another in array
+			out.append(',');
+			newline();
+			break;
+
+		case DANGLING_NAME: // value for name
+			out.append(separator);
+			replaceTop(NONEMPTY_OBJECT);
+			break;
+
+		default:
+			throw new IllegalStateException("Nesting problem.");
+		}
+	}
 }
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 8f0361581..7cea52ce2 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -39,7 +39,7 @@
 
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
-        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        new HashMap<Type, Function<Class<?>, ?>>(), true, false, true, false,
         true, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
@@ -51,7 +51,7 @@ public void testOverridesDefaultExcluder() {
 
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
-        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        new HashMap<Type, Function<Class<?>, ?>>(), true, false, true, false,
         true, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index d22016761..9ddf872df 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -23,6 +23,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.function.*;
 
 
 /**
@@ -108,8 +109,7 @@ public boolean equals(Object obj) {
     }
   }
 
-  public static class MyParameterizedTypeInstanceCreator<T>
-      implements InstanceCreator<MyParameterizedType<T>>{
+  public static class MyParameterizedTypeInstanceCreator<T> implements Function<Class<MyParameterizedType<T>>, MyParameterizedType<T>>{
     private final T instanceOfT;
     /**
      * Caution the specified instance is reused by the instance creator for each call.
@@ -122,7 +122,7 @@ public boolean equals(Object obj) {
     public MyParameterizedTypeInstanceCreator(T instanceOfT) {
       this.instanceOfT = instanceOfT;
     }
-    @Override public MyParameterizedType<T> createInstance(Class<MyParameterizedType<T>> type) {
+    @Override public MyParameterizedType<T> apply(Class<MyParameterizedType<T>> type) {
       return new MyParameterizedType<T>(instanceOfT);
     }
   }
diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index 38b03683a..045321c3b 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -15,29 +15,13 @@
  */
 package com.google.gson.functional;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.google.gson.common.TestTypes.BagOfPrimitives;
-import com.google.gson.common.TestTypes.ClassWithCustomTypeConverter;
-import com.google.gson.reflect.TypeToken;
-
-import java.util.Date;
-import junit.framework.TestCase;
-
-import java.lang.reflect.Type;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+import com.google.gson.*;
+import com.google.gson.common.TestTypes.*;
+import com.google.gson.reflect.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.function.*;
+import junit.framework.*;
 
 /**
  * Functional tests for the support of custom serializer and deserializers.
@@ -287,10 +271,9 @@ public StringHolder(String part1, String part2) {
     }
   }
 
-  private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>,
-      JsonDeserializer<StringHolder>, InstanceCreator<StringHolder> {
+  private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>, JsonDeserializer<StringHolder>, Function<Class<StringHolder>, StringHolder> {
 
-    @Override public StringHolder createInstance(Class<StringHolder> type) {
+    @Override public StringHolder apply(Class<StringHolder> type) {
       //Fill up with objects that will be thrown away
       return new StringHolder("unknown:thing");
     }
diff --git a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
index dd361df90..61ecc01ee 100644
--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
@@ -16,14 +16,9 @@
 
 package com.google.gson.functional;
 
-import java.lang.reflect.Type;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.InstanceCreator;
-import com.google.gson.annotations.Expose;
-
-import junit.framework.TestCase;
+import com.google.gson.*;
+import com.google.gson.annotations.*;
+import junit.framework.*;
 
 /**
  * Unit tests for the regarding functional "@Expose" type tests.
diff --git a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
index 3eb160da3..db9c1f555 100644
--- a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
@@ -16,21 +16,13 @@
 
 package com.google.gson.functional;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.InstanceCreator;
-import com.google.gson.common.TestTypes.Base;
-import com.google.gson.common.TestTypes.ClassWithBaseField;
-import com.google.gson.common.TestTypes.Sub;
-
-import com.google.gson.reflect.TypeToken;
-import java.util.ArrayList;
-import java.util.List;
-import junit.framework.TestCase;
-
-import java.lang.reflect.Type;
-import java.util.SortedSet;
-import java.util.TreeSet;
+import com.google.gson.*;
+import com.google.gson.common.TestTypes.*;
+import com.google.gson.reflect.*;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.function.*;
+import junit.framework.*;
 
 /**
  * Functional Test exercising custom serialization only. When test applies to both
@@ -89,8 +81,8 @@ public void testInstanceCreatorForCollectionType() {
   public void testInstanceCreatorForParametrizedType() throws Exception {
     @SuppressWarnings("serial")
     class SubTreeSet<T> extends TreeSet<T> {}
-    InstanceCreator<SortedSet> sortedSetCreator = new InstanceCreator<SortedSet>() {
-      @Override public SortedSet createInstance(Class<SortedSet> type) {
+    Function<Class<SortedSet>, SortedSet> sortedSetCreator = new Function<>() {
+      @Override public SortedSet apply(Class<SortedSet> type) {
         return new SubTreeSet();
       }
     };
