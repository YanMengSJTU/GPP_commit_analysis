diff --git a/LICENSE b/LICENSE
index 52de5f843..d1edb3147 100644
--- a/LICENSE
+++ b/LICENSE
@@ -189,7 +189,7 @@ Vinz Jsoncore (based on Google Gson)
       identification within third-party archives.
 
    Copyright 2008-2011 Google Inc.
-   Copyright 2016 Copyright (C) 2016 Vinz (https://github.com/gv2011) (https://github.com/gv2011)
+   Copyright 2016      Vinz (https://github.com/gv2011)
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java
new file mode 100644
index 000000000..93c4b4601
--- /dev/null
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java
@@ -0,0 +1,9 @@
+package com.github.gv2011.jsoncore;
+
+public interface JsonEncoder<T> {
+
+  String encode(T value);
+
+  void encode(T value, Appendable out);
+
+}
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java
new file mode 100644
index 000000000..d97048034
--- /dev/null
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java
@@ -0,0 +1,13 @@
+package com.github.gv2011.jsoncore;
+
+import java.io.Reader;
+
+public interface JsonFactory {
+
+  JsonParser newJsonParser(Reader reader, JsonOption... jsonOptions);
+
+  JsonSerializer newJsonSerializer(Reader reader, JsonOption... jsonOptions);
+
+  <T> JsonEncoder<T> newJsonEncoder(Class<T> primitive, JsonOption... jsonOptions);
+
+}
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
new file mode 100644
index 000000000..084a0b4d5
--- /dev/null
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
@@ -0,0 +1,64 @@
+package com.github.gv2011.jsoncore;
+
+public enum JsonOption {
+
+  /**
+   * <h2>Parser</h2>
+   *
+   * <p>Configure parser to be liberal in what it accepts. By default,
+   * a parser is strict and only accepts JSON as specified by <a
+   * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
+   * parser to lenient causes it to ignore the following syntax errors:</p>
+   *
+   * <ul>
+   *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
+   *       prefix</a>, <code>")]}'\n"</code>.
+   *   <li>Streams that include multiple top-level values. With strict parsing,
+   *       each stream must contain exactly one top-level value.
+   *   <li>Top-level values of any type. With strict parsing, the top-level
+   *       value must be an object or an array.
+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+   *       Double#isInfinite() infinities}.
+   *   <li>End of line comments starting with {@code //} or {@code #} and
+   *       ending with a newline character.
+   *   <li>C-style comments starting with {@code /*} and ending with
+   *       {@code *}{@code /}. Such comments may not be nested.
+   *   <li>Names that are unquoted or {@code 'single quoted'}.
+   *   <li>Strings that are unquoted or {@code 'single quoted'}.
+   *   <li>Array elements separated by {@code ;} instead of {@code ,}.
+   *   <li>Unnecessary array separators. These are interpreted as if null
+   *       was the omitted value.
+   *   <li>Names and values separated by {@code =} or {@code =>} instead of
+   *       {@code :}.
+   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
+   * </ul>
+   *
+   * <h2>Serializer</h2>
+   *
+   * <p>Configures a serializer to relax its syntax rules. By default, a serializer
+   * only emits well-formed JSON as specified by <a
+   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the serializer
+   * to lenient permits the following:</p>
+   *
+   * <ul>
+   *   <li>Top-level values of any type. With strict writing, the top-level
+   *       value must be an object or an array.
+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+   *       Double#isInfinite() infinities}.
+   * </ul>
+   *
+   */
+  LENIENT,
+
+  /**
+   *
+   */
+  HTML_SAFE,
+
+  /**
+   *
+   */
+  OMIT_NULLS
+}
+
+
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java
new file mode 100644
index 000000000..e81a4bb73
--- /dev/null
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.jsoncore;
+
+import java.io.Closeable;
+import java.io.Flushable;
+
+import net.jcip.annotations.NotThreadSafe;
+
+/**
+ * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
+ * encoded value to a stream, one token at a time. The stream includes both
+ * literal values (strings, numbers, booleans and nulls) as well as the begin
+ * and end delimiters of objects and arrays.
+ *
+ * <h3>Encoding JSON</h3>
+ * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
+ * document must contain one top-level array or object. Call methods on the
+ * writer as you walk the structure's contents, nesting arrays and objects as
+ * necessary:
+ * <ul>
+ *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.
+ *       Write each of the array's elements with the appropriate {@link #value}
+ *       methods or by nesting other arrays and objects. Finally close the array
+ *       using {@link #endArray()}.
+ *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.
+ *       Write each of the object's properties by alternating calls to
+ *       {@link #name} with the property's value. Write property values with the
+ *       appropriate {@link #value} method or by nesting other objects or arrays.
+ *       Finally close the object using {@link #endObject()}.
+ * </ul>
+ *
+ * <h3>Example</h3>
+ * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
+ * [
+ *   {
+ *     "id": 912345678901,
+ *     "text": "How do I stream JSON in Java?",
+ *     "geo": null,
+ *     "user": {
+ *       "name": "json_newb",
+ *       "followers_count": 41
+ *      }
+ *   },
+ *   {
+ *     "id": 912345678902,
+ *     "text": "@json_newb just use JsonWriter!",
+ *     "geo": [50.454722, -104.606667],
+ *     "user": {
+ *       "name": "jesse",
+ *       "followers_count": 2
+ *     }
+ *   }
+ * ]}</pre>
+ * This code encodes the above structure: <pre>   {@code
+ *   public void writeJsonStream(OutputStream out, List<Message> messages){
+ *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
+ *     writer.setIndent("    ");
+ *     writeMessagesArray(writer, messages);
+ *     writer.close();
+ *   }
+ *
+ *   public void writeMessagesArray(JsonWriter writer, List<Message> messages){
+ *     writer.beginArray();
+ *     for (Message message : messages) {
+ *       writeMessage(writer, message);
+ *     }
+ *     writer.endArray();
+ *   }
+ *
+ *   public void writeMessage(JsonWriter writer, Message message){
+ *     writer.beginObject();
+ *     writer.name("id").value(message.getId());
+ *     writer.name("text").value(message.getText());
+ *     if (message.getGeo() != null) {
+ *       writer.name("geo");
+ *       writeDoublesArray(writer, message.getGeo());
+ *     } else {
+ *       writer.name("geo").nullValue();
+ *     }
+ *     writer.name("user");
+ *     writeUser(writer, message.getUser());
+ *     writer.endObject();
+ *   }
+ *
+ *   public void writeUser(JsonWriter writer, User user){
+ *     writer.beginObject();
+ *     writer.name("name").value(user.getName());
+ *     writer.name("followers_count").value(user.getFollowersCount());
+ *     writer.endObject();
+ *   }
+ *
+ *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles){
+ *     writer.beginArray();
+ *     for (Double value : doubles) {
+ *       writer.value(value);
+ *     }
+ *     writer.endArray();
+ *   }}</pre>
+ *
+ * <p>Each {@code JsonWriter} may be used to write a single JSON stream.
+ * Instances of this class are not thread safe. Calls that would result in a
+ * malformed JSON string will fail with an {@link IllegalStateException}.
+ *
+ * @author Jesse Wilson
+ * @author Vinz
+ * @since 1.6
+ */
+@NotThreadSafe
+public interface JsonSerializer extends Closeable, Flushable {
+
+  /**
+   * Begins encoding a new array. Each call to this method must be paired with
+   * a call to {@link #endArray}.
+   *
+   * @return this writer.
+   */
+  JsonSerializer beginArray();
+
+  /**
+   * Ends encoding the current array.
+   *
+   * @return this writer.
+   */
+  JsonSerializer endArray();
+
+  /**
+   * Begins encoding a new object. Each call to this method must be paired
+   * with a call to {@link #endObject}.
+   *
+   * @return this writer.
+   */
+  JsonSerializer beginObject();
+
+  /**
+   * Ends encoding the current object.
+   *
+   * @return this writer.
+   */
+  public JsonSerializer endObject();
+
+
+
+  /**
+   * Encodes the property name.
+   *
+   * @param name the name of the forthcoming value. May not be null.
+   * @return this writer.
+   */
+  public JsonSerializer name(final String name);
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonSerializer value(final String value);
+
+  /**
+   * Writes {@code value} directly to the writer without quoting or
+   * escaping.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonSerializer jsonValue(final String value);
+
+
+  /**
+   * Encodes {@code null}.
+   *
+   * @return this writer.
+   */
+  public JsonSerializer nullValue();
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonSerializer value(final boolean value);
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonSerializer value(final Boolean value);
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  public JsonSerializer value(final double value);
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonSerializer value(final long value);
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  public JsonSerializer value(final Number value);
+
+
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
index 141d77d92..c2b0aa1d7 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
@@ -23,6 +23,8 @@
 import java.math.BigInteger;
 import java.util.Map;
 
+import com.github.gv2011.jsoncore.JsonOption;
+
 /**
  * A class representing an element of Json. It could either be a {@link JsonObject}, a
  * {@link JsonArray}, a {@link JsonPrimitive} or a {@link JsonNull}.
@@ -319,8 +321,7 @@ public short getAsShort() {
   public String toString() {
     try {
       final StringWriter stringWriter = new StringWriter();
-      final JsonWriter jsonWriter = new JsonWriter(stringWriter);
-      jsonWriter.setLenient(true);
+      final JsonWriter jsonWriter = new JsonWriter(stringWriter, JsonOption.LENIENT);
       write(jsonWriter, this);
       return stringWriter.toString();
     } catch (final IOException e) {
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java
new file mode 100644
index 000000000..70875c758
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java
@@ -0,0 +1,30 @@
+package com.github.gv2011.jsoncore.imp;
+
+import java.io.Reader;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.jsoncore.JsonFactory;
+import com.github.gv2011.jsoncore.JsonOption;
+import com.github.gv2011.jsoncore.JsonParser;
+import com.github.gv2011.jsoncore.JsonSerializer;
+
+public class JsonFactoryImp implements JsonFactory{
+
+  @Override
+  public JsonParser newJsonParser(final Reader reader, final JsonOption... jsonOptions) {
+    return new JsonReader(reader);
+  }
+
+  @Override
+  public JsonSerializer newJsonSerializer(final Reader reader, final JsonOption... jsonOptions) {
+    // TODO Auto-generated method stub
+    return null;
+  }
+
+  @Override
+  public <T> JsonEncoder<T> newJsonEncoder(final Class<T> primitive, final JsonOption... jsonOptions) {
+    // TODO Auto-generated method stub
+    return null;
+  }
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
index 81c9be425..3d5ad9c2e 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
@@ -21,7 +21,9 @@
 import static com.github.gv2011.util.ex.Exceptions.run;
 
 import java.io.Reader;
+import java.util.Arrays;
 
+import com.github.gv2011.jsoncore.JsonOption;
 import com.github.gv2011.jsoncore.JsonParser;
 import com.github.gv2011.jsoncore.JsonToken;
 
@@ -229,7 +231,7 @@
   private final Reader in;
 
   /** True to accept non-spec compliant JSON */
-  private boolean lenient = false;
+  private final boolean lenient;
 
   /**
    * Use a manual buffer to easily read and unread upcoming characters, and
@@ -288,45 +290,11 @@
   /**
    * Creates a new instance that reads a JSON-encoded stream from {@code in}.
    */
-  public JsonReader(final Reader in) {
-    if (in == null) {
-      throw new NullPointerException("in == null");
-    }
+  public JsonReader(final Reader in, final JsonOption... options) {
     this.in = in;
+    lenient = Arrays.asList(options).contains(JsonOption.LENIENT);
   }
 
-  /**
-   * Configure this parser to be liberal in what it accepts. By default,
-   * this parser is strict and only accepts JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
-   * parser to lenient causes it to ignore the following syntax errors:
-   *
-   * <ul>
-   *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
-   *       prefix</a>, <code>")]}'\n"</code>.
-   *   <li>Streams that include multiple top-level values. With strict parsing,
-   *       each stream must contain exactly one top-level value.
-   *   <li>Top-level values of any type. With strict parsing, the top-level
-   *       value must be an object or an array.
-   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
-   *       Double#isInfinite() infinities}.
-   *   <li>End of line comments starting with {@code //} or {@code #} and
-   *       ending with a newline character.
-   *   <li>C-style comments starting with {@code /*} and ending with
-   *       {@code *}{@code /}. Such comments may not be nested.
-   *   <li>Names that are unquoted or {@code 'single quoted'}.
-   *   <li>Strings that are unquoted or {@code 'single quoted'}.
-   *   <li>Array elements separated by {@code ;} instead of {@code ,}.
-   *   <li>Unnecessary array separators. These are interpreted as if null
-   *       was the omitted value.
-   *   <li>Names and values separated by {@code =} or {@code =>} instead of
-   *       {@code :}.
-   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
-   * </ul>
-   */
-  public final void setLenient(final boolean lenient) {
-    this.lenient = lenient;
-  }
 
   /**
    * Returns true if this parser is liberal in what it accepts.
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java
new file mode 100644
index 000000000..0fd51eb48
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java
@@ -0,0 +1,102 @@
+package com.github.gv2011.jsoncore.imp;
+
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.StringWriter;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+
+class JsonStringEncoder implements JsonEncoder<String>{
+
+    /*
+   * From RFC 7159, "All Unicode characters may be placed within the
+   * quotation marks except for the characters that must be escaped:
+   * quotation mark, reverse solidus, and the control characters
+   * (U+0000 through U+001F)."
+   *
+   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
+   * newline characters. This prevents eval() from failing with a syntax
+   * error. http://code.google.com/p/google-gson/issues/detail?id=341
+   */
+  static final String[] REPLACEMENT_CHARS;
+  static final String[] HTML_SAFE_REPLACEMENT_CHARS;
+  static {
+    REPLACEMENT_CHARS = new String[128];
+    for (int i = 0; i <= 0x1f; i++) {
+      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
+    }
+    REPLACEMENT_CHARS['"'] = "\\\"";
+    REPLACEMENT_CHARS['\\'] = "\\\\";
+    REPLACEMENT_CHARS['\t'] = "\\t";
+    REPLACEMENT_CHARS['\b'] = "\\b";
+    REPLACEMENT_CHARS['\n'] = "\\n";
+    REPLACEMENT_CHARS['\r'] = "\\r";
+    REPLACEMENT_CHARS['\f'] = "\\f";
+    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
+    HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
+    HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
+    HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
+    HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
+    HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
+  }
+
+
+  private final boolean htmlSafe;
+
+  JsonStringEncoder() {
+    this(false);
+  }
+
+  JsonStringEncoder(final boolean htmlSafe) {
+    this.htmlSafe = htmlSafe;
+  }
+
+  @Override
+  public String encode(final String value) {
+    final StringWriter w = new StringWriter();
+    encode(value, w);
+    return w.toString();
+  }
+
+  @Override
+  public void encode(final String value, final Appendable out) {
+    final String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
+    write(out, "\"");
+    int last = 0;
+    final int length = value.length();
+    for (int i = 0; i < length; i++) {
+      final char c = value.charAt(i);
+      String replacement;
+      if (c < 128) {
+        replacement = replacements[c];
+        if (replacement == null) {
+          continue;
+        }
+      } else if (c == '\u2028') {
+        replacement = "\\u2028";
+      } else if (c == '\u2029') {
+        replacement = "\\u2029";
+      } else {
+        continue;
+      }
+      if (last < i) {
+        write(out, value, last, i - last);
+      }
+      write(out, replacement);
+      last = i + 1;
+    }
+    if (last < length) {
+      write(out, value, last, length - last);
+    }
+    write(out, "\"");
+  }
+
+  private void write(final Appendable out, final String str) {
+    run(()->out.append(str));
+  }
+
+  private void write(final Appendable out, final String cbuf, final int off, final int len) {
+    run(()->out.append(cbuf, off, off+len));
+  }
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
index 5af60d028..1c60ed6c0 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
@@ -24,143 +24,22 @@
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_ARRAY;
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_OBJECT;
+import static com.github.gv2011.util.ex.Exceptions.run;
 
-import java.io.Closeable;
-import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 
-/**
- * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
- * encoded value to a stream, one token at a time. The stream includes both
- * literal values (strings, numbers, booleans and nulls) as well as the begin
- * and end delimiters of objects and arrays.
- *
- * <h3>Encoding JSON</h3>
- * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
- * document must contain one top-level array or object. Call methods on the
- * writer as you walk the structure's contents, nesting arrays and objects as
- * necessary:
- * <ul>
- *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.
- *       Write each of the array's elements with the appropriate {@link #value}
- *       methods or by nesting other arrays and objects. Finally close the array
- *       using {@link #endArray()}.
- *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.
- *       Write each of the object's properties by alternating calls to
- *       {@link #name} with the property's value. Write property values with the
- *       appropriate {@link #value} method or by nesting other objects or arrays.
- *       Finally close the object using {@link #endObject()}.
- * </ul>
- *
- * <h3>Example</h3>
- * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
- * [
- *   {
- *     "id": 912345678901,
- *     "text": "How do I stream JSON in Java?",
- *     "geo": null,
- *     "user": {
- *       "name": "json_newb",
- *       "followers_count": 41
- *      }
- *   },
- *   {
- *     "id": 912345678902,
- *     "text": "@json_newb just use JsonWriter!",
- *     "geo": [50.454722, -104.606667],
- *     "user": {
- *       "name": "jesse",
- *       "followers_count": 2
- *     }
- *   }
- * ]}</pre>
- * This code encodes the above structure: <pre>   {@code
- *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
- *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
- *     writer.setIndent("    ");
- *     writeMessagesArray(writer, messages);
- *     writer.close();
- *   }
- *
- *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {
- *     writer.beginArray();
- *     for (Message message : messages) {
- *       writeMessage(writer, message);
- *     }
- *     writer.endArray();
- *   }
- *
- *   public void writeMessage(JsonWriter writer, Message message) throws IOException {
- *     writer.beginObject();
- *     writer.name("id").value(message.getId());
- *     writer.name("text").value(message.getText());
- *     if (message.getGeo() != null) {
- *       writer.name("geo");
- *       writeDoublesArray(writer, message.getGeo());
- *     } else {
- *       writer.name("geo").nullValue();
- *     }
- *     writer.name("user");
- *     writeUser(writer, message.getUser());
- *     writer.endObject();
- *   }
- *
- *   public void writeUser(JsonWriter writer, User user) throws IOException {
- *     writer.beginObject();
- *     writer.name("name").value(user.getName());
- *     writer.name("followers_count").value(user.getFollowersCount());
- *     writer.endObject();
- *   }
- *
- *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {
- *     writer.beginArray();
- *     for (Double value : doubles) {
- *       writer.value(value);
- *     }
- *     writer.endArray();
- *   }}</pre>
- *
- * <p>Each {@code JsonWriter} may be used to write a single JSON stream.
- * Instances of this class are not thread safe. Calls that would result in a
- * malformed JSON string will fail with an {@link IllegalStateException}.
- *
- * @author Jesse Wilson
- * @since 1.6
- */
-public class JsonWriter implements Closeable, Flushable {
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.jsoncore.JsonOption;
+import com.github.gv2011.jsoncore.JsonSerializer;
+
+
+public class JsonWriter implements JsonSerializer {
 
-  /*
-   * From RFC 7159, "All Unicode characters may be placed within the
-   * quotation marks except for the characters that must be escaped:
-   * quotation mark, reverse solidus, and the control characters
-   * (U+0000 through U+001F)."
-   *
-   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
-   * newline characters. This prevents eval() from failing with a syntax
-   * error. http://code.google.com/p/google-gson/issues/detail?id=341
-   */
-  private static final String[] REPLACEMENT_CHARS;
-  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;
-  static {
-    REPLACEMENT_CHARS = new String[128];
-    for (int i = 0; i <= 0x1f; i++) {
-      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
-    }
-    REPLACEMENT_CHARS['"'] = "\\\"";
-    REPLACEMENT_CHARS['\\'] = "\\\\";
-    REPLACEMENT_CHARS['\t'] = "\\t";
-    REPLACEMENT_CHARS['\b'] = "\\b";
-    REPLACEMENT_CHARS['\n'] = "\\n";
-    REPLACEMENT_CHARS['\r'] = "\\r";
-    REPLACEMENT_CHARS['\f'] = "\\f";
-    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
-    HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
-    HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
-    HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
-    HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
-    HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
-  }
 
   /** The output data, containing at most one top-level array or object. */
   private final Writer out;
@@ -182,24 +61,29 @@
    */
   private String separator = ":";
 
-  private boolean lenient;
+  private final boolean lenient;
 
-  private boolean htmlSafe;
+  private final boolean htmlSafe;
 
   private String deferredName;
 
-  private boolean serializeNulls = true;
+  private final boolean serializeNulls;
+  private final Set<JsonOption> optList;
+
+  private final JsonEncoder<String> stringEncoder;
 
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code out}.
    * For best performance, ensure {@link Writer} is buffered; wrapping in
    * {@link java.io.BufferedWriter BufferedWriter} if necessary.
    */
-  public JsonWriter(final Writer out) {
-    if (out == null) {
-      throw new NullPointerException("out == null");
-    }
+  public JsonWriter(final Writer out, final JsonOption... options) {
     this.out = out;
+    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
+    lenient = optList.contains(JsonOption.LENIENT);
+    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
+    serializeNulls = !optList.contains(JsonOption.OMIT_NULLS);
+    stringEncoder = new JsonStringEncoder(htmlSafe);
   }
 
   /**
@@ -232,9 +116,9 @@ public final void setIndent(final String indent) {
    *       Double#isInfinite() infinities}.
    * </ul>
    */
-  public final void setLenient(final boolean lenient) {
-    this.lenient = lenient;
-  }
+//  public final void setLenient(final boolean lenient) {
+//    this.lenient = lenient;
+//  }
 
   /**
    * Returns true if this writer has relaxed syntax rules.
@@ -250,9 +134,9 @@ public boolean isLenient() {
    * setting, your XML/HTML encoder should replace these characters with the
    * corresponding escape sequences.
    */
-  public final void setHtmlSafe(final boolean htmlSafe) {
-    this.htmlSafe = htmlSafe;
-  }
+//  public final void setHtmlSafe(final boolean htmlSafe) {
+//    this.htmlSafe = htmlSafe;
+//  }
 
   /**
    * Returns true if this writer writes JSON that's safe for inclusion in HTML
@@ -266,9 +150,9 @@ public final boolean isHtmlSafe() {
    * Sets whether object members are serialized when their value is null.
    * This has no impact on array elements. The default is true.
    */
-  public final void setSerializeNulls(final boolean serializeNulls) {
-    this.serializeNulls = serializeNulls;
-  }
+//  public final void setSerializeNulls(final boolean serializeNulls) {
+//    this.serializeNulls = serializeNulls;
+//  }
 
   /**
    * Returns true if object members are serialized when their value is null.
@@ -284,7 +168,8 @@ public final boolean getSerializeNulls() {
    *
    * @return this writer.
    */
-  public JsonWriter beginArray() throws IOException {
+  @Override
+  public JsonWriter beginArray(){
     writeDeferredName();
     return open(EMPTY_ARRAY, "[");
   }
@@ -294,7 +179,8 @@ public JsonWriter beginArray() throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter endArray() throws IOException {
+  @Override
+  public JsonWriter endArray(){
     return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
   }
 
@@ -304,7 +190,8 @@ public JsonWriter endArray() throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter beginObject() throws IOException {
+  @Override
+  public JsonWriter beginObject(){
     writeDeferredName();
     return open(EMPTY_OBJECT, "{");
   }
@@ -314,7 +201,8 @@ public JsonWriter beginObject() throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter endObject() throws IOException {
+  @Override
+  public JsonWriter endObject(){
     return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
   }
 
@@ -322,19 +210,23 @@ public JsonWriter endObject() throws IOException {
    * Enters a new scope by appending any necessary whitespace and the given
    * bracket.
    */
-  private JsonWriter open(final int empty, final String openBracket) throws IOException {
+  private JsonWriter open(final int empty, final String openBracket){
     beforeValue();
     push(empty);
-    out.write(openBracket);
+    write(openBracket);
     return this;
   }
 
+  private void write(final String str) {
+    run(()->out.write(str));
+  }
+
   /**
    * Closes the current scope by appending any necessary whitespace and the
    * given bracket.
    */
   private JsonWriter close(final int empty, final int nonempty, final String closeBracket)
-      throws IOException {
+     {
     final int context = peek();
     if (context != nonempty && context != empty) {
       throw new IllegalStateException("Nesting problem.");
@@ -347,7 +239,7 @@ private JsonWriter close(final int empty, final int nonempty, final String close
     if (context == nonempty) {
       newline();
     }
-    out.write(closeBracket);
+    write(closeBracket);
     return this;
   }
 
@@ -383,7 +275,8 @@ private void replaceTop(final int topOfStack) {
    * @param name the name of the forthcoming value. May not be null.
    * @return this writer.
    */
-  public JsonWriter name(final String name) throws IOException {
+  @Override
+  public JsonWriter name(final String name){
     if (name == null) {
       throw new NullPointerException("name == null");
     }
@@ -397,10 +290,10 @@ public JsonWriter name(final String name) throws IOException {
     return this;
   }
 
-  private void writeDeferredName() throws IOException {
+  private void writeDeferredName(){
     if (deferredName != null) {
       beforeName();
-      string(deferredName);
+      stringEncoder.encode(deferredName, out);
       deferredName = null;
     }
   }
@@ -411,13 +304,14 @@ private void writeDeferredName() throws IOException {
    * @param value the literal string value, or null to encode a null literal.
    * @return this writer.
    */
-  public JsonWriter value(final String value) throws IOException {
+  @Override
+  public JsonWriter value(final String value){
     if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue();
-    string(value);
+    stringEncoder.encode(value, out);
     return this;
   }
 
@@ -428,22 +322,28 @@ public JsonWriter value(final String value) throws IOException {
    * @param value the literal string value, or null to encode a null literal.
    * @return this writer.
    */
-  public JsonWriter jsonValue(final String value) throws IOException {
+  @Override
+  public JsonWriter jsonValue(final String value){
     if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue();
-    out.append(value);
+    append(value);
     return this;
   }
 
+  private void append(final String str) {
+    run(()->out.append(str));
+  }
+
   /**
    * Encodes {@code null}.
    *
    * @return this writer.
    */
-  public JsonWriter nullValue() throws IOException {
+  @Override
+  public JsonWriter nullValue(){
     if (deferredName != null) {
       if (serializeNulls) {
         writeDeferredName();
@@ -453,7 +353,7 @@ public JsonWriter nullValue() throws IOException {
       }
     }
     beforeValue();
-    out.write("null");
+    write("null");
     return this;
   }
 
@@ -462,10 +362,11 @@ public JsonWriter nullValue() throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(final boolean value) throws IOException {
+  @Override
+  public JsonWriter value(final boolean value){
     writeDeferredName();
     beforeValue();
-    out.write(value ? "true" : "false");
+    write(value ? "true" : "false");
     return this;
   }
 
@@ -474,13 +375,14 @@ public JsonWriter value(final boolean value) throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(final Boolean value) throws IOException {
+  @Override
+  public JsonWriter value(final Boolean value){
     if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue();
-    out.write(value ? "true" : "false");
+    write(value ? "true" : "false");
     return this;
   }
 
@@ -491,13 +393,14 @@ public JsonWriter value(final Boolean value) throws IOException {
    *     {@link Double#isInfinite() infinities}.
    * @return this writer.
    */
-  public JsonWriter value(final double value) throws IOException {
+  @Override
+  public JsonWriter value(final double value){
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     writeDeferredName();
     beforeValue();
-    out.append(Double.toString(value));
+    append(Double.toString(value));
     return this;
   }
 
@@ -506,10 +409,11 @@ public JsonWriter value(final double value) throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(final long value) throws IOException {
+  @Override
+  public JsonWriter value(final long value){
     writeDeferredName();
     beforeValue();
-    out.write(Long.toString(value));
+    write(Long.toString(value));
     return this;
   }
 
@@ -520,7 +424,8 @@ public JsonWriter value(final long value) throws IOException {
    *     {@link Double#isInfinite() infinities}.
    * @return this writer.
    */
-  public JsonWriter value(final Number value) throws IOException {
+  @Override
+  public JsonWriter value(final Number value){
     if (value == null) {
       return nullValue();
     }
@@ -532,7 +437,7 @@ public JsonWriter value(final Number value) throws IOException {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     beforeValue();
-    out.append(string);
+    append(string);
     return this;
   }
 
@@ -541,11 +446,11 @@ public JsonWriter value(final Number value) throws IOException {
    * and flushes that writer.
    */
   @Override
-  public void flush() throws IOException {
+  public void flush(){
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
-    out.flush();
+    run(out::flush);
   }
 
   /**
@@ -554,56 +459,25 @@ public void flush() throws IOException {
    * @throws IOException if the JSON document is incomplete.
    */
   @Override
-  public void close() throws IOException {
-    out.close();
+  public void close(){
+    run(out::close);
 
     final int size = stackSize;
     if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
-      throw new IOException("Incomplete document");
+      throw new IllegalStateException("Incomplete document");
     }
     stackSize = 0;
   }
 
-  private void string(final String value) throws IOException {
-    final String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
-    out.write("\"");
-    int last = 0;
-    final int length = value.length();
-    for (int i = 0; i < length; i++) {
-      final char c = value.charAt(i);
-      String replacement;
-      if (c < 128) {
-        replacement = replacements[c];
-        if (replacement == null) {
-          continue;
-        }
-      } else if (c == '\u2028') {
-        replacement = "\\u2028";
-      } else if (c == '\u2029') {
-        replacement = "\\u2029";
-      } else {
-        continue;
-      }
-      if (last < i) {
-        out.write(value, last, i - last);
-      }
-      out.write(replacement);
-      last = i + 1;
-    }
-    if (last < length) {
-      out.write(value, last, length - last);
-    }
-    out.write("\"");
-  }
 
-  private void newline() throws IOException {
+  private void newline(){
     if (indent == null) {
       return;
     }
 
-    out.write("\n");
+    write("\n");
     for (int i = 1, size = stackSize; i < size; i++) {
-      out.write(indent);
+      write(indent);
     }
   }
 
@@ -611,10 +485,10 @@ private void newline() throws IOException {
    * Inserts any necessary separators and whitespace before a name. Also
    * adjusts the stack to expect the name's value.
    */
-  private void beforeName() throws IOException {
+  private void beforeName(){
     final int context = peek();
     if (context == NONEMPTY_OBJECT) { // first in object
-      out.write(',');
+      run(()->out.write(','));
     } else if (context != EMPTY_OBJECT) { // not in an object!
       throw new IllegalStateException("Nesting problem.");
     }
@@ -628,7 +502,7 @@ private void beforeName() throws IOException {
    * closing bracket or another element.
    */
   @SuppressWarnings("fallthrough")
-  private void beforeValue() throws IOException {
+  private void beforeValue(){
     switch (peek()) {
     case NONEMPTY_DOCUMENT:
       if (!lenient) {
@@ -646,12 +520,12 @@ private void beforeValue() throws IOException {
       break;
 
     case NONEMPTY_ARRAY: // another in array
-      out.append(',');
+      run(()->out.append(','));
       newline();
       break;
 
     case DANGLING_NAME: // value for name
-      out.append(separator);
+      append(separator);
       replaceTop(NONEMPTY_OBJECT);
       break;
 
diff --git a/imp/src/main/resources/META-INF/services/com.github.gv2011.jsoncore.JsonFactory b/imp/src/main/resources/META-INF/services/com.github.gv2011.jsoncore.JsonFactory
new file mode 100644
index 000000000..479e22b8c
--- /dev/null
+++ b/imp/src/main/resources/META-INF/services/com.github.gv2011.jsoncore.JsonFactory
@@ -0,0 +1 @@
+com.github.gv2011.jsoncore.imp.JsonFactoryImp
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
index 04b589525..714125cda 100644
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderPathTest.java
@@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.io.StringReader;
 
-import com.github.gv2011.jsoncore.imp.JsonReader;
+import com.github.gv2011.jsoncore.JsonOption;
 
 import junit.framework.TestCase;
 
@@ -137,8 +137,7 @@ public void testArrayPath() throws IOException {
   }
 
   public void testMultipleTopLevelValuesInOneDocument() throws IOException {
-    final JsonReader reader = new JsonReader(new StringReader("[][]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(new StringReader("[][]"), JsonOption.LENIENT);
     reader.beginArray();
     reader.endArray();
     assertEquals("$", reader.getPath());
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
index a306a74cb..16c853255 100644
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonReaderTest.java
@@ -31,6 +31,7 @@
 import java.io.StringReader;
 import java.util.Arrays;
 
+import com.github.gv2011.jsoncore.JsonOption;
 import com.github.gv2011.jsoncore.JsonToken;
 
 import junit.framework.TestCase;
@@ -176,14 +177,6 @@ public void testHelloWorld() throws MalformedJsonException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
-  public void testNulls() {
-    try {
-      new JsonReader(null);
-      fail();
-    } catch (final NullPointerException expected) {
-    }
-  }
-
   public void testEmptyString() {
     try {
       new JsonReader(reader("")).beginArray();
@@ -333,8 +326,7 @@ public void testStrictQuotedNonFiniteDoubles() throws MalformedJsonException {
 
   public void testLenientNonFiniteDoubles() throws MalformedJsonException {
     final String json = "[NaN, -Infinity, Infinity]";
-    final JsonReader reader = new JsonReader(reader(json));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
     reader.beginArray();
     assertTrue(Double.isNaN(reader.nextDouble()));
     assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());
@@ -344,8 +336,7 @@ public void testLenientNonFiniteDoubles() throws MalformedJsonException {
 
   public void testLenientQuotedNonFiniteDoubles() throws MalformedJsonException {
     final String json = "[\"NaN\", \"-Infinity\", \"Infinity\"]";
-    final JsonReader reader = new JsonReader(reader(json));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
     reader.beginArray();
     assertTrue(Double.isNaN(reader.nextDouble()));
     assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());
@@ -436,8 +427,7 @@ public void testBooleans() throws MalformedJsonException {
   }
 
   public void testPeekingUnquotedStringsPrefixedWithBooleans() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[truey]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[truey]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     try {
@@ -487,8 +477,7 @@ public void testMalformedNumbers() throws MalformedJsonException {
   }
 
   private void assertNotANumber(final String s) throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[" + s + "]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[" + s + "]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
     assertEquals(s, reader.nextString());
@@ -496,8 +485,7 @@ private void assertNotANumber(final String s) throws MalformedJsonException {
   }
 
   public void testPeekingUnquotedStringsPrefixedWithIntegers() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[12.34e5x]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[12.34e5x]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     try {
@@ -509,24 +497,21 @@ public void testPeekingUnquotedStringsPrefixedWithIntegers() throws MalformedJso
   }
 
   public void testPeekLongMinValue() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[-9223372036854775808]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775808]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     assertEquals(-9223372036854775808L, reader.nextLong());
   }
 
   public void testPeekLongMaxValue() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[9223372036854775807]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[9223372036854775807]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     assertEquals(9223372036854775807L, reader.nextLong());
   }
 
   public void testLongLargerThanMaxLongThatWrapsAround() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[22233720368547758070]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[22233720368547758070]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
@@ -537,8 +522,7 @@ public void testLongLargerThanMaxLongThatWrapsAround() throws MalformedJsonExcep
   }
 
   public void testLongLargerThanMinLongThatWrapsAround() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[-22233720368547758070]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[-22233720368547758070]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
@@ -553,8 +537,7 @@ public void testLongLargerThanMinLongThatWrapsAround() throws MalformedJsonExcep
    * long parsing uses Double.parseDouble() for fractional values.
    */
   public void disabled_testPeekLargerThanLongMaxValue() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[9223372036854775808]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[9223372036854775808]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
@@ -569,8 +552,7 @@ public void disabled_testPeekLargerThanLongMaxValue() throws MalformedJsonExcept
    * long parsing uses Double.parseDouble() for fractional values.
    */
   public void disabled_testPeekLargerThanLongMinValue() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[-9223372036854775809]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775809]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
@@ -594,8 +576,7 @@ public void disabled_testHighPrecisionLong() throws MalformedJsonException {
   }
 
   public void testPeekMuchLargerThanLongMinValue() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[-92233720368547758080]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[-92233720368547758080]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(NUMBER, reader.peek());
     try {
@@ -607,8 +588,7 @@ public void testPeekMuchLargerThanLongMinValue() throws MalformedJsonException {
   }
 
   public void testQuotedNumberWithEscape() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[\"12\u00334\"]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[\"12\u00334\"]"), JsonOption.LENIENT);
     reader.beginArray();
     assertEquals(STRING, reader.peek());
     assertEquals(1234, reader.nextInt());
@@ -793,14 +773,12 @@ public void testStrictNameValueSeparator() throws MalformedJsonException {
   }
 
   public void testLenientNameValueSeparator() throws MalformedJsonException {
-    JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
-    reader.setLenient(true);
+    JsonReader reader = new JsonReader(reader("{\"a\"=true}"), JsonOption.LENIENT);
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals(true, reader.nextBoolean());
 
-    reader = new JsonReader(reader("{\"a\"=>true}"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("{\"a\"=>true}"), JsonOption.LENIENT);
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals(true, reader.nextBoolean());
@@ -872,18 +850,18 @@ public void testStrictComments() throws MalformedJsonException {
   }
 
   public void testLenientComments() throws MalformedJsonException {
-    JsonReader reader = new JsonReader(reader("[// comment \n true]"));
-    reader.setLenient(true);
+    JsonReader reader = new JsonReader(reader("[// comment \n true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
 
-    reader = new JsonReader(reader("[# comment \n true]"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("[# comment \n true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
 
-    reader = new JsonReader(reader("[/* comment */ true]"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("[/* comment */ true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
   }
@@ -925,8 +903,8 @@ public void testStrictUnquotedNames() throws MalformedJsonException {
   }
 
   public void testLenientUnquotedNames() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{a:true}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{a:true}"), JsonOption.LENIENT);
+
     reader.beginObject();
     assertEquals("a", reader.nextName());
   }
@@ -952,8 +930,8 @@ public void testStrictSingleQuotedNames() throws MalformedJsonException {
   }
 
   public void testLenientSingleQuotedNames() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{'a':true}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{'a':true}"), JsonOption.LENIENT);
+
     reader.beginObject();
     assertEquals("a", reader.nextName());
   }
@@ -989,8 +967,8 @@ public void testStrictUnquotedStringsWithSkipValue() throws MalformedJsonExcepti
   }
 
   public void testLenientUnquotedStrings() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[a]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[a]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals("a", reader.nextString());
   }
@@ -1006,8 +984,8 @@ public void testStrictSingleQuotedStrings() throws MalformedJsonException {
   }
 
   public void testLenientSingleQuotedStrings() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("['a']"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("['a']"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals("a", reader.nextString());
   }
@@ -1034,8 +1012,8 @@ public void testStrictSemicolonDelimitedArray() throws MalformedJsonException {
   }
 
   public void testLenientSemicolonDelimitedArray() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[true;true]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[true;true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     assertEquals(true, reader.nextBoolean());
@@ -1065,8 +1043,8 @@ public void testStrictSemicolonDelimitedNameValuePair() throws MalformedJsonExce
   }
 
   public void testLenientSemicolonDelimitedNameValuePair() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"), JsonOption.LENIENT);
+
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals(true, reader.nextBoolean());
@@ -1122,30 +1100,30 @@ public void testStrictUnnecessaryArraySeparators() throws MalformedJsonException
   }
 
   public void testLenientUnnecessaryArraySeparators() throws MalformedJsonException {
-    JsonReader reader = new JsonReader(reader("[true,,true]"));
-    reader.setLenient(true);
+    JsonReader reader = new JsonReader(reader("[true,,true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     reader.nextNull();
     assertEquals(true, reader.nextBoolean());
     reader.endArray();
 
-    reader = new JsonReader(reader("[,true]"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("[,true]"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.nextNull();
     assertEquals(true, reader.nextBoolean());
     reader.endArray();
 
-    reader = new JsonReader(reader("[true,]"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("[true,]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
     reader.nextNull();
     reader.endArray();
 
-    reader = new JsonReader(reader("[,]"));
-    reader.setLenient(true);
+    reader = new JsonReader(reader("[,]"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.nextNull();
     reader.nextNull();
@@ -1200,8 +1178,8 @@ public void testStrictMultipleTopLevelValues() throws MalformedJsonException {
   }
 
   public void testLenientMultipleTopLevelValues() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[] true {}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[] true {}"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.endArray();
     assertEquals(true, reader.nextBoolean());
@@ -1273,24 +1251,24 @@ public void testStrictNonExecutePrefixWithSkipValue() {
   }
 
   public void testLenientNonExecutePrefix() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testLenientNonExecutePrefixWithLeadingWhitespace() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("\r\n \t)]}'\n []"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("\r\n \t)]}'\n []"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.endArray();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testLenientPartialNonExecutePrefix() {
-    final JsonReader reader = new JsonReader(reader(")]}' []"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(")]}' []"), JsonOption.LENIENT);
+
     try {
       assertEquals(")", reader.nextString());
       reader.nextString();
@@ -1361,8 +1339,7 @@ public void testFailWithPositionIsOffsetByBom() throws MalformedJsonException {
 
   private void testFailWithPosition(final String message, final String json) throws MalformedJsonException {
     // Validate that it works reading the string normally.
-    final JsonReader reader1 = new JsonReader(reader(json));
-    reader1.setLenient(true);
+    final JsonReader reader1 = new JsonReader(reader(json), JsonOption.LENIENT);
     reader1.beginArray();
     reader1.nextString();
     try {
@@ -1373,8 +1350,7 @@ private void testFailWithPosition(final String message, final String json) throw
     }
 
     // Also validate that it works when skipping.
-    final JsonReader reader2 = new JsonReader(reader(json));
-    reader2.setLenient(true);
+    final JsonReader reader2 = new JsonReader(reader(json), JsonOption.LENIENT);
     reader2.beginArray();
     reader2.skipValue();
     try {
@@ -1413,8 +1389,8 @@ public void testStrictVeryLongNumber() throws MalformedJsonException {
   }
 
   public void testLenientVeryLongNumber() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
     assertEquals(1d, reader.nextDouble());
@@ -1424,8 +1400,8 @@ public void testLenientVeryLongNumber() throws MalformedJsonException {
 
   public void testVeryLongUnquotedLiteral() throws MalformedJsonException {
     final String literal = "a" + repeat('b', 8192) + "c";
-    final JsonReader reader = new JsonReader(reader("[" + literal + "]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[" + literal + "]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(literal, reader.nextString());
     reader.endArray();
@@ -1470,8 +1446,8 @@ public void testDeeplyNestedObjects() throws MalformedJsonException {
 
   // http://code.google.com/p/google-gson/issues/detail?id=409
   public void testStringEndingInSlash() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("/"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("/"), JsonOption.LENIENT);
+
     try {
       reader.peek();
       fail();
@@ -1480,8 +1456,8 @@ public void testStringEndingInSlash() throws MalformedJsonException {
   }
 
   public void testDocumentWithCommentEndingInSlash() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("/* foo *//"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("/* foo *//"), JsonOption.LENIENT);
+
     try {
       reader.peek();
       fail();
@@ -1490,8 +1466,8 @@ public void testDocumentWithCommentEndingInSlash() throws MalformedJsonException
   }
 
   public void testStringWithLeadingSlash() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("/x"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("/x"), JsonOption.LENIENT);
+
     try {
       reader.peek();
       fail();
@@ -1500,8 +1476,8 @@ public void testStringWithLeadingSlash() throws MalformedJsonException {
   }
 
   public void testUnterminatedObject() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{\"a\":\"android\"x"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"android\"x"), JsonOption.LENIENT);
+
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals("android", reader.nextString());
@@ -1528,8 +1504,8 @@ public void testVeryLongUnquotedString() throws MalformedJsonException {
     Arrays.fill(stringChars, 'x');
     final String string = new String(stringChars);
     final String json = "[" + string + "]";
-    final JsonReader reader = new JsonReader(reader(json));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(string, reader.nextString());
     reader.endArray();
@@ -1540,8 +1516,8 @@ public void testVeryLongUnterminatedString() throws MalformedJsonException {
     Arrays.fill(stringChars, 'x');
     final String string = new String(stringChars);
     final String json = "[" + string;
-    final JsonReader reader = new JsonReader(reader(json));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(string, reader.nextString());
     try {
@@ -1552,16 +1528,16 @@ public void testVeryLongUnterminatedString() throws MalformedJsonException {
   }
 
   public void testSkipVeryLongUnquotedString() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[" + repeat('x', 8192) + "]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[" + repeat('x', 8192) + "]"), JsonOption.LENIENT);
+
     reader.beginArray();
     reader.skipValue();
     reader.endArray();
   }
 
   public void testSkipTopLevelUnquotedString() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader(repeat('x', 8192)));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(repeat('x', 8192)), JsonOption.LENIENT);
+
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
@@ -1574,36 +1550,36 @@ public void testSkipVeryLongQuotedString() throws MalformedJsonException {
   }
 
   public void testSkipTopLevelQuotedString() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("\"" + repeat('x', 8192) + "\""));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("\"" + repeat('x', 8192) + "\""), JsonOption.LENIENT);
+
     reader.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testStringAsNumberWithTruncatedExponent() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[123e]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[123e]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
   public void testStringAsNumberWithDigitAndNonDigitExponent() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[123e4b]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[123e4b]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
   public void testStringAsNumberWithNonDigitExponent() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[123eb]"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[123eb]"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(STRING, reader.peek());
   }
 
   public void testEmptyStringName() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{\"\":true}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{\"\":true}"), JsonOption.LENIENT);
+
     assertEquals(BEGIN_OBJECT, reader.peek());
     reader.beginObject();
     assertEquals(NAME, reader.peek());
@@ -1628,8 +1604,8 @@ public void testStrictExtraCommasInMaps() throws MalformedJsonException {
   }
 
   public void testLenientExtraCommasInMaps() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"), JsonOption.LENIENT);
+
     reader.beginObject();
     assertEquals("a", reader.nextName());
     assertEquals("b", reader.nextString());
@@ -1693,8 +1669,8 @@ public void testMalformedDocuments() throws MalformedJsonException {
    * during peek rather than during nextString().
    */
   public void testUnterminatedStringFailure() throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader("[\"string"));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader("[\"string"), JsonOption.LENIENT);
+
     reader.beginArray();
     assertEquals(JsonToken.STRING, reader.peek());
     try {
@@ -1705,8 +1681,8 @@ public void testUnterminatedStringFailure() throws MalformedJsonException {
   }
 
   private void assertDocument(final String document, final Object... expectations) throws MalformedJsonException {
-    final JsonReader reader = new JsonReader(reader(document));
-    reader.setLenient(true);
+    final JsonReader reader = new JsonReader(reader(document), JsonOption.LENIENT);
+
     for (final Object expectation : expectations) {
       if (expectation == BEGIN_OBJECT) {
         reader.beginObject();
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java
new file mode 100644
index 000000000..3b0911bc0
--- /dev/null
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java
@@ -0,0 +1,16 @@
+package com.github.gv2011.jsoncore.imp;
+
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+
+import org.junit.Test;
+
+public class JsonStringEncoderTest {
+
+  @Test
+  public void testEncodeString() {
+    final JsonStringEncoder encoder = new JsonStringEncoder();
+    assertThat(encoder.encode("abc\"d"), is("\"abc\\\"d\""));
+  }
+
+}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
index 2e7ba7394..bea9169f1 100644
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
@@ -22,7 +22,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
-import com.github.gv2011.jsoncore.imp.JsonWriter;
+import com.github.gv2011.jsoncore.JsonOption;
 
 import junit.framework.TestCase;
 
@@ -30,132 +30,132 @@
 public final class JsonWriterTest extends TestCase {
 
   public void testTopLevelValueTypes() throws IOException {
-    StringWriter string1 = new StringWriter();
-    JsonWriter writer1 = new JsonWriter(string1);
+    final StringWriter string1 = new StringWriter();
+    final JsonWriter writer1 = new JsonWriter(string1);
     writer1.value(true);
     writer1.close();
     assertEquals("true", string1.toString());
 
-    StringWriter string2 = new StringWriter();
-    JsonWriter writer2 = new JsonWriter(string2);
+    final StringWriter string2 = new StringWriter();
+    final JsonWriter writer2 = new JsonWriter(string2);
     writer2.nullValue();
     writer2.close();
     assertEquals("null", string2.toString());
 
-    StringWriter string3 = new StringWriter();
-    JsonWriter writer3 = new JsonWriter(string3);
+    final StringWriter string3 = new StringWriter();
+    final JsonWriter writer3 = new JsonWriter(string3);
     writer3.value(123);
     writer3.close();
     assertEquals("123", string3.toString());
 
-    StringWriter string4 = new StringWriter();
-    JsonWriter writer4 = new JsonWriter(string4);
+    final StringWriter string4 = new StringWriter();
+    final JsonWriter writer4 = new JsonWriter(string4);
     writer4.value(123.4);
     writer4.close();
     assertEquals("123.4", string4.toString());
 
-    StringWriter string5 = new StringWriter();
-    JsonWriter writert = new JsonWriter(string5);
+    final StringWriter string5 = new StringWriter();
+    final JsonWriter writert = new JsonWriter(string5);
     writert.value("a");
     writert.close();
     assertEquals("\"a\"", string5.toString());
   }
 
   public void testInvalidTopLevelTypes() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.name("hello");
     try {
       jsonWriter.value("world");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testTwoNames() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
     try {
       jsonWriter.name("a");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testNameWithoutValue() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
     try {
       jsonWriter.endObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testValueWithoutName() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     try {
       jsonWriter.value(true);
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testMultipleTopLevelValues() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray().endArray();
     try {
       jsonWriter.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testBadNestingObject() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.beginObject();
     try {
       jsonWriter.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testBadNestingArray() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.beginArray();
     try {
       jsonWriter.endObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testNullName() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     try {
       jsonWriter.name(null);
       fail();
-    } catch (NullPointerException expected) {
+    } catch (final NullPointerException expected) {
     }
   }
 
   public void testNullStringValue() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
     jsonWriter.value((String) null);
@@ -164,8 +164,8 @@ public void testNullStringValue() throws IOException {
   }
 
   public void testJsonValue() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
     jsonWriter.jsonValue("{\"b\":true}");
@@ -176,50 +176,50 @@ public void testJsonValue() throws IOException {
   }
 
   public void testNonFiniteDoubles() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     try {
       jsonWriter.value(Double.NaN);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
     try {
       jsonWriter.value(Double.NEGATIVE_INFINITY);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
     try {
       jsonWriter.value(Double.POSITIVE_INFINITY);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
   }
 
   public void testNonFiniteBoxedDoubles() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     try {
       jsonWriter.value(new Double(Double.NaN));
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
     try {
       jsonWriter.value(new Double(Double.NEGATIVE_INFINITY));
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
     try {
       jsonWriter.value(new Double(Double.POSITIVE_INFINITY));
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (final IllegalArgumentException expected) {
     }
   }
 
   public void testDoubles() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value(-0.0);
     jsonWriter.value(1.0);
@@ -244,8 +244,8 @@ public void testDoubles() throws IOException {
   }
 
   public void testLongs() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value(0);
     jsonWriter.value(1);
@@ -262,8 +262,8 @@ public void testLongs() throws IOException {
   }
 
   public void testNumbers() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value(new BigInteger("0"));
     jsonWriter.value(new BigInteger("9223372036854775808"));
@@ -278,8 +278,8 @@ public void testNumbers() throws IOException {
   }
 
   public void testBooleans() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value(true);
     jsonWriter.value(false);
@@ -288,8 +288,8 @@ public void testBooleans() throws IOException {
   }
 
   public void testBoxedBooleans() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value((Boolean) true);
     jsonWriter.value((Boolean) false);
@@ -299,8 +299,8 @@ public void testBoxedBooleans() throws IOException {
   }
 
   public void testNulls() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.nullValue();
     jsonWriter.endArray();
@@ -308,8 +308,8 @@ public void testNulls() throws IOException {
   }
 
   public void testStrings() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value("a");
     jsonWriter.value("a\"");
@@ -351,8 +351,8 @@ public void testStrings() throws IOException {
   }
 
   public void testUnicodeLineBreaksEscaped() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.value("\u2028 \u2029");
     jsonWriter.endArray();
@@ -360,24 +360,24 @@ public void testUnicodeLineBreaksEscaped() throws IOException {
   }
 
   public void testEmptyArray() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.endArray();
     assertEquals("[]", stringWriter.toString());
   }
 
   public void testEmptyObject() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.endObject();
     assertEquals("{}", stringWriter.toString());
   }
 
   public void testObjectsInArrays() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     jsonWriter.beginObject();
     jsonWriter.name("a").value(5);
@@ -393,8 +393,8 @@ public void testObjectsInArrays() throws IOException {
   }
 
   public void testArraysInObjects() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
     jsonWriter.beginArray();
@@ -412,8 +412,8 @@ public void testArraysInObjects() throws IOException {
   }
 
   public void testDeepNestingArrays() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     for (int i = 0; i < 20; i++) {
       jsonWriter.beginArray();
     }
@@ -424,8 +424,8 @@ public void testDeepNestingArrays() throws IOException {
   }
 
   public void testDeepNestingObjects() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     for (int i = 0; i < 20; i++) {
       jsonWriter.name("a");
@@ -441,8 +441,8 @@ public void testDeepNestingObjects() throws IOException {
   }
 
   public void testRepeatedName() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a").value(true);
     jsonWriter.name("a").value(false);
@@ -452,8 +452,8 @@ public void testRepeatedName() throws IOException {
   }
 
   public void testPrettyPrintObject() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.setIndent("   ");
 
     jsonWriter.beginObject();
@@ -471,7 +471,7 @@ public void testPrettyPrintObject() throws IOException {
     jsonWriter.endObject();
     jsonWriter.endObject();
 
-    String expected = "{\n"
+    final String expected = "{\n"
         + "   \"a\": true,\n"
         + "   \"b\": false,\n"
         + "   \"c\": 5.0,\n"
@@ -489,8 +489,8 @@ public void testPrettyPrintObject() throws IOException {
   }
 
   public void testPrettyPrintArray() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.setIndent("   ");
 
     jsonWriter.beginArray();
@@ -508,7 +508,7 @@ public void testPrettyPrintArray() throws IOException {
     jsonWriter.endArray();
     jsonWriter.endArray();
 
-    String expected = "[\n"
+    final String expected = "[\n"
         + "   true,\n"
         + "   false,\n"
         + "   5.0,\n"
@@ -526,9 +526,8 @@ public void testPrettyPrintArray() throws IOException {
   }
 
   public void testLenientWriterPermitsMultipleTopLevelValues() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
-    writer.setLenient(true);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter, JsonOption.LENIENT);
     writer.beginArray();
     writer.endArray();
     writer.beginArray();
@@ -538,87 +537,87 @@ public void testLenientWriterPermitsMultipleTopLevelValues() throws IOException
   }
 
   public void testStrictWriterDoesNotPermitMultipleTopLevelValues() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     try {
       writer.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testClosedWriterThrowsOnStructure() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     writer.close();
     try {
       writer.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       writer.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       writer.beginObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
     try {
       writer.endObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testClosedWriterThrowsOnName() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     writer.close();
     try {
       writer.name("a");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testClosedWriterThrowsOnValue() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     writer.close();
     try {
       writer.value("a");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testClosedWriterThrowsOnFlush() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     writer.close();
     try {
       writer.flush();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (final IllegalStateException expected) {
     }
   }
 
   public void testWriterCloseIsIdempotent() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = new JsonWriter(stringWriter);
     writer.beginArray();
     writer.endArray();
     writer.close();
