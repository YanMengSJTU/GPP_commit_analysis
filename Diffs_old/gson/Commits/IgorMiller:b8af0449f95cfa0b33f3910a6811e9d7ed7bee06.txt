diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2029e6b4..baf75f126 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,10 +1,15 @@
 Change Log
 ==========
 
-## Version 2.4.0
+## Version 2.5
+_2015-11-24_
+ * Updated minimum JDK version to 1.6
+ * Improved Date Deserialization by accepting many date formats
+ * Added support for `java.util.Currency`, `AtomicLong`, `AtomicLongArray`, `AtomicInteger`, `AtomicIntegerArray`, `AtomicBoolean`. This change is backward-incompatible because the earlier version of Gson used the default serialization which wasn't intuitive. We hope that these classes are not used enough to actually cause problems in the field.
+ * Improved debugging information when some exceptions are thrown
 
+## Version 2.4
 _2015-10-04_
-
  * **Drop `IOException` from `TypeAdapter.toJson()`.** This is a binary-compatible change, but may
    cause compiler errors where `IOExceptions` are being caught but no longer thrown. The correct fix
    for this problem is to remove the unnecessary `catch` clause.
@@ -15,6 +20,215 @@ _2015-10-04_
  * New: APIs to add primitives directly to `JsonArray` instances.
  * New: ISO 8601 date type adapter. Find this in _extras_.
  * Fix: `FieldNamingPolicy` now works properly when running on a device with a Turkish locale.
-
   [autovalue]: https://github.com/google/auto/tree/master/value
 
+## Version 2.3.1
+__2014-11-20__
+ * Added support to serialize objects with self-referential fields. The self-referential field is set to null in JSON. Previous version of Gson threw a StackOverflowException on encountering any self-referential fields.
+   * The most visible impact of this is that Gson can now serialize Throwable (Exception and Error)
+ * Added support for @JsonAdapter annotation on enums which are user defined types
+ * Fixed bug in getPath() with array of objects and arrays of arrays
+ * Other smaller bug fixes
+
+## Version 2.3
+__2014-08-11__
+ * The new @JsonAdapter annotation to specify a Json TypeAdapter for a class field
+ * JsonPath support: JsonReader.getPath() method returns the JsonPath expression
+ * New public methods in JsonArray (similar to the java.util.List): `contains(JsonElement), remove(JsonElement), remove(int index), set(int index, JsonElement element)`
+ * Many other smaller bug fixes
+
+## Version 2.2.4
+__2013-05-13__
+ * Fix internal map (LinkedHashTreeMap) hashing bug.
+ * Bug fix (Issue 511)
+
+## Version 2.2.3
+__2013-04-12__
+ * Fixes for possible DoS attack due to poor String hashing
+
+## Version 2.2.2
+__2012-07-02__
+ * Gson now allows a user to override default type adapters for Primitives and Strings. This behavior was allowed in earlier versions of Gson but was prohibited started Gson 2.0. We decided to allow it again: This enables a user to parse 1/0 as boolean values for compatibility with iOS JSON libraries.
+ * (Incompatible behavior change in `JsonParser`): In the past, if `JsonParser` encountered a stream that terminated prematurely, it returned `JsonNull`. This behavior wasn't correct because the stream had invalid JSON, not a null. `JsonParser` is now changed to throw `JsonSyntaxException` in this case. Note that if JsonParser (or Gson) encounter an empty stream, they still return `JsonNull`.
+
+## Version 2.2.1
+__2012-05-05__
+ * Very minor fixes
+
+## Version 2.2
+__2012-05-05__
+ * Added getDelegateAdapter in Gson class
+ * Fixed a security bug related to denial of service attack with Java HashMap String collisions.
+
+## Version 2.1
+__2011-12-30__ (Targeted Dec 31, 2011)
+ * Support for user-defined streaming type adapters
+ * continued performance enhancements
+ * Dropped support for type hierarchy instance creators. We don't expect this to be a problem. We'll also detect fewer errors where multiple type adapters can serialize the same type. With APIs like getNextTypeAdapter, this might actually be an improvement!
+
+## Version 2.0
+__2011-11-13__
+ **Faster**
+ * Previous versions first parsed complete document into a DOM-style model (JsonObject or JsonArray) and then bound data against that. Gson 2 does data binding directly from the stream parser.
+
+ **More Predictable**
+ * Objects are serialized and deserialized in the same way, regardless of where they occur in the object graph.
+
+ **Changes to watch out for**
+* Gson 1.7 would serialize top-level nulls as "". 2.0 serializes them as "null".
+```
+String json = gson.toJson(null, Foo.class);
+1.7: json == ""
+2.0: json == "null"
+```
+Gson 1.7 permitted duplicate map keys. 2.0 forbids them.
+```
+String json = "{'a':1,'a':2}";
+Map<String, Integer> map = gson.fromJson(json, mapType);
+1.7: map == {a=2}
+2.0: JsonSyntaxException thrown
+```
+Gson 1.7 won’t serialize subclass fields in collection elements. 2.0 adds this extra information.
+```
+List<Point2d> points = new ArrayList<Point2d>();
+points.add(new Point3d(1, 2, 3));
+String json = gson.toJson(points, 
+    new TypeToken<List<Point2d>>() {}.getType());
+1.7: json == "[{'x':1,'y':2}]"
+2.0: json == "[{'x':1,'y':2,'z':3}]"
+```
+Gson 1.7 binds single-element arrays as their contents. 2.0 doesn’t.
+```
+Integer i = gson.fromJson("[42]", Integer.class);
+1.7: i == 42
+2.0: JsonSyntaxException thrown
+```
+ **Other changes to be aware of**
+ * Gson 2.0 doesn’t support type adapters for primitive types.
+ * Gson 1.7 uses arbitrary precision for primitive type conversion (so -122.08e-2132 != 0). Gson 2.0 uses double precision (so -122.08e-2132 == 0).
+ * Gson 1.7 sets subclass fields when an InstanceCreator returns a subclass when the value is a field of another object. Gson 2.0 sets fields of the requested type only.
+ * Gson 1.7 versioning never skips the top-level object. Gson 2.0 versioning applies to all objects.
+ * Gson 1.7 truncates oversized large integers. Gson 2.0 fails on them.
+ * Gson 2.0 permits integers to have .0 fractions like "1.0".
+ * Gson 1.7 throws IllegalStateException on circular references. Gson 2.0 lets the runtime throw a StackOverflowError.
+
+## Version 1.7.2
+__2011-09-30__ (Unplanned release)
+ * Fixed a threading issue in FieldAttributes (Issue 354)
+
+## Version 1.7.1
+__2011-04-13__ (Unplanned release)
+ * Fixed Gson jars in Maven Central repository
+ * Removed assembly-descriptor.xml and maven pom.xml/pom.properties files from Gson binary jar. This also ensures that jarjar can be run correctly on Gson.
+
+## Version 1.7
+__2011-04-12__ (Targeted: Jan 2011)
+ * No need to define no-args constructors for classes serialized with Gson
+ * Ability to register a hierarchical type adapter
+ * Support for serialization and deserialization of maps with complex keys
+ * Serialization and deserialization specific exclusion strategies
+ * Allow concrete data structure fields without type adapters
+ * Fixes "type" management (i.e. Wildcards, etc.)
+ * Major performance enhancements by reducing the need for Java reflection
+See detailed announcement at this thread in the Gson Google Group.
+
+## Version 1.6
+__2010-11-24__ (Targeted: Oct, 2010)
+ * New stream parser APIs
+ * New parser that improves parsing performance significantly
+
+## Version 1.5
+__2010-08-19__ (Target Date: Aug 18, 2010)
+ * Added `UPPER_CAMEL_CASE_WITH_SPACES` naming policy
+ * Added SQL date and time support
+ * A number of performance improvements: Using caching of field annotations for speeding up reflection, replacing recursive calls in the parser with a for loop.
+
+## Version 1.4 BETA
+__2009_10_09__
+ * JsonStreamParser: A streaming parser API class to deserialize multiple JSON objects on a stream (such as a pipelined HTTP response)
+ * Raised the deserialization limit for byte and object arrays and collection to over 11MB from 80KB. See issue 96.
+ * While serializing, Gson now uses the actual type of a field. This allows serialization of base-class references holding sub-classes to the JSON for the sub-class. It also allows serialization of raw collections. See Issue 155, 156.
+ * Added a `Gson.toJsonTree()` method that serializes a Java object to a tree of JsonElements. See issue 110.
+ * Added a `Gson.fromJson(JsonElement)` method that deserializes from a Json parse tree.
+ * Updated `Expose` annotation to contain parameters serialize and deserialize to control whether a field gets serialized or deserialized. See issue 146.
+ * Added a new naming policy `LOWER_CASE_WITH_DASHES`
+ * Default date type adapter is now thread-safe. See Issue 162.
+ * `JsonElement.toString()` now outputs valid JSON after escaping characters properly. See issue 154.
+ * `JsonPrimitive.equals()` now returns true for two numbers if their values are equal. All integral types (long, int, short, byte, BigDecimal, Long, Integer, Short, Byte) are treated equivalent for comparison. Similarly, floating point types (double, float, BigDecimal, Double, Float) are treated equivalent as well. See issue 147.
+ * Fixed bugs in pretty printing. See issue 153.
+ * If a field causes circular reference error, Gson lists the field name instead of the object value. See issue 118.
+ * Gson now serializes a list with null elements correctly. See issue 117.
+ * Fixed issue 121, 123, 126.
+ * Support user defined exclusion strategies (Feature Request 138).
+
+## Version 1.3
+__2009-04-01__
+ * Fix security token to remove the `<data>` element.
+ * Changed JsonParser.parse method to be non-static
+ * Throw JsonParseExceptions instead of ClassCastExceptions and UnsupportedOperationExceptions
+
+## Version 1.3 beta3
+__2009-03-17__
+ * Supported custom mapping of field names by making `FieldNamingStrategy` public and allowing `FieldNamingStrategy` to be set in GsonBuilder. See issue 104.
+ * Added a new GsonBuilder setting `generateNonExecutableJson()` that prefixes the generated JSON with some text to make the output non-executable Javascript. Gson now recognizes this text from input while deserializing and filters it out. This feature is meant to prevent script sourcing attacks. See Issue 42.
+ * Supported deserialization of sets with elements that do not implement Comparable. See Issue 100
+ * Supported deserialization of floating point numbers without a sign after E. See Issue 94
+
+## Version 1.3 beta2
+__2009-02-05__
+ * Added a new Parser API. See issue 65
+ * Supported deserialization of java.util.Properties. See Issue 87
+ * Fixed the pretty printing of maps. See Issue 93
+ * Supported automatic conversion of strings into numeric and boolean types if possible. See Issue 89
+ * Supported deserialization of longs into strings. See Issue 82
+
+## Version 1.3 beta1
+__2009_01__ (Target Date Friday, Dec 15, 2008)
+ * Made JSON parser lenient by allowing unquoted member names while parsing. See Issue 41
+ * Better precision handling for floating points. See Issue 71, 72
+ * Support for deserialization of special double values: NaN, infinity and negative infinity. See Issue 81
+ * Backward compatibility issue found with serialization of Collection<Object> type.  See Issue 73 and 83.
+ * Able to serialize null keys and/or values within a Map.  See Issue 77.
+ * Deserializing non-String value keys for Maps.  See Issue 85.
+ * Support for clashing field name.  See Issue 76.
+ * Removed the need to invoke instance creator if a deserializer is registered. See issues 37 and 69.
+ * Added default support for java.util.UUID. See Issue 79
+ * Changed `Gson.toJson()` methods to use `Appendable` instead of `Writer`. Issue 52. This requires that clients recompile their source code that uses Gson.
+
+## Version 1.2.3
+__2008-11-15__ (Target Date Friday, Oct 31, 2008)
+ * Added support to serialize raw maps. See issue 45
+ * Made Gson thread-safe by fixing Issue 63
+ * Fixed Issue 68 to allow default type adapters for primitive types to be replaced by custom type adapters.
+ * Relaxed the JSON parser to accept escaped slash (\/) as a valid character in the string. See Issue 66
+
+## Version 1.2.2
+__2008-10-14__ (Target Date: None, Unplanned)
+ * This version was released to fix Issue 58 which caused a regression bug in version 1.2.1. It includes the contents from the release 1.2.1
+
+## Version 1.2.1
+__2008-10-13__ (Target Date Friday, Oct 7, 2008)
+Note: This release was abandoned since it caused a regression (Issue 58) bug.
+ * Includes updated parser for JSON that supports much larger strings. For example, Gson 1.2 failed at parsing a 100k string, Gson 1.2.1 has successfully parsed strings of size 15-20MB. The parser also is faster and consumes less memory since it uses a token match instead of a recursion-based Grammar production match. See Issue 47.
+ * Gson now supports field names with single quotes ' in addition to double quotes ". See Issue 55.
+ * Includes bug fixes for issue 46, 49, 51, 53, 54, and 56.
+
+## Version 1.2
+__2008-08-29__ (Target Date Tuesday Aug 26, 2008)
+ * Includes support for feature requests 21, 24, 29
+ * Includes bug fixes for Issue 22, Issue 23, Issue 25, Issue 26, Issue 32 , Issue 34, Issue 35, Issue 36, Issue 37, Issue 38, Issue 39
+ * Performance enhancements (see r137)
+ * Documentation updates
+
+## Version 1.1.1
+__2008-07-18__ (Target Date Friday, Aug 1, 2008)
+ * Includes fixes for Issue 19, Partial fix for Issue 20
+
+## Version 1.1
+__2008-07-01__ (Target Date Thursday, July 3, 2008)
+ * Includes fixes for Issue 9, Issue 16, Issue 18
+
+## Version 1.0.1
+__2008-06-17__ (Target Date Friday,  Jun 13, 2008)
+ * Includes fixes for Issue 15, Issue 14, Issue 3, Issue 8
+ * Javadoc improvements
diff --git a/GsonDesignDocument.md b/GsonDesignDocument.md
new file mode 100644
index 000000000..51f150a92
--- /dev/null
+++ b/GsonDesignDocument.md
@@ -0,0 +1,57 @@
+#Gson Design Document
+
+This document presents issues that we faced while designing Gson. It is meant for advanced users or developers working on Gson. If you are interested in learning how to use Gson, see its user guide. 
+
+**Navigating the Json tree or the target Type Tree while deserializing**
+
+When you are deserializing a Json string into an object of desired type, you can either navigate the tree of the input, or the type tree of the desired type. Gson uses the latter approach of navigating the type of the target object. This keeps you in tight control of instantiating only the type of objects that you are expecting (essentially validating the input against the expected "schema"). By doing this, you also ignore any extra fields that the Json input has but were not expected. 
+
+As part of Gson, we wrote a general purpose ObjectNavigator that can take any object and navigate through its fields calling a visitor of your choice. 
+
+**Supporting richer serialization semantics than deserialization semantics**
+
+Gson supports serialization of arbitrary collections, but can only deserialize genericized collections. this means that Gson can, in some cases, fail to deserialize Json that it wrote. This is primarily a limitation of the Java type system since when you encounter a Json array of arbitrary types there is no way to detect the types of individual elements. We could have chosen to restrict the serialization to support only generic collections, but chose not to.This is because often the user of the library are concerned with either serialization or deserialization, but not both. In such cases, there is no need to artificially restrict the serialization capabilities. 
+
+**Supporting serialization and deserialization of classes that are not under your control and hence can not be modified**
+
+Some Json libraries use annotations on fields or methods to indicate which fields should be used for Json serialization. That approach essentially precludes the use of classes from JDK or third-party libraries. We solved this problem by defining the notion of Custom serializers and deserializers. This approach is not new, and was used by the JAX-RPC technology to solve essentially the same problem. 
+
+**Using Checked vs Unchecked exceptions to indicate a parsing error**
+
+We chose to use unchecked exceptions to indicate a parsing failure. This is primarily done because usually the client can not recover from bad input, and hence forcing them to catch a checked exception results in sloppy code in the catch() block. 
+
+**Creating class instances for deserialization**
+
+Gson needs to create a dummy class instance before it can deserialize Json data into its fields. We could have used Guice to get such an instance, but that would have resulted in a dependency on Guice. Moreover, it probably would have done the wrong thing since Guice is expected to return a valid instance, whereas we need to create a dummy one. Worse, Gson would overwrite the fields of that instance with the incoming data there by modifying the instance for all subsequent Guice injections. This is clearly not a desired behavior. Hence, we create class instances by invoking the parameterless constructor. We also handle the primitive types, enums, collections, sets, maps and trees as a special case. 
+
+To solve the problem of supporting unmodifiable types, we use custom instance creators. So, if you want to use a library types that does not define a default constructor (for example, Money class), then you can register an instance creator that returns a dummy instance when asked.
+
+**Using fields vs getters to indicate Json elements**
+
+Some Json libraries use the getters of a type to deduce the Json elements. We chose to use all fields (up the inheritance hierarchy) that are not transient, static, or synthetic. We did this because not all classes are written with suitably named getters. Moreover, getXXX or isXXX might be semantic rather than indicating properties. 
+
+However, there are good arguments to support properties as well. We intend to enhance Gson in a latter version to support properties as an alternate mapping for indicating Json fields. For now, Gson is fields-based. 
+
+**Why are most classes in Gson marked as final?**
+
+While Gson provides a fairly extensible architecture by providing pluggable serializers and deserializers, Gson classes were not specifically designed to be extensible. Providing non-final classes would have allowed a user to legitimately extend Gson classes, and then expect that behavior to work in all subsequent revisions. We chose to limit such use-cases by marking classes as final, and waiting until a good use-case emerges to allow extensibility. Marking a class final also has a minor benefit of providing additional optimization opportunities to Java compiler and virtual machine. 
+
+**Why are inner interfaces and classes used heavily in Gson?**
+
+Gson uses inner classes substantially. Many of the public interfaces are inner interfaces too (see JsonSerializer.Context or JsonDeserializer.Context as an example). These are primarily done as a matter of style. For example, we could have moved JsonSerializer.Context to be a top-level class JsonSerializerContext, but chose not to do so. However, if you can give us good reasons to rename it alternately, we are open to changing this philosophy. 
+
+**Why do you provide two ways of constructing Gson?**
+
+Gson can be constructed in two ways: by invoking new Gson() or by using a GsonBuilder. We chose to provide a simple no-args constructor to handle simple use-cases for Gson where you want to use default options, and quickly want to get going with writing code. For all other situations, where you need to configure Gson with options such as formatters, version controls etc, we use a builder pattern. The builder pattern allows a user to specify multiple optional settings for what essentially become constructor parameters for Gson. 
+
+**Comparing Gson with Alternate Approaches**
+
+Note that these comparisons were done while developing Gson so these date back to mid to late 2007.
+
+__Comparing Gson with org.json library__
+
+org.json is a much lower-level library that can be used to write a toJson() method in a class. If you can not use Gson directly (may be because of platform restrictions regarding reflection), you could use org.json to hand-code a toJson method in each object. 
+
+__Comparing Gson with org.json.simple library__
+
+org.json.simple library is very similar to org.json library and hence fairly low level. The key issue with this library is that it does not handle exceptions very well. In some cases it appeared to just eat the exception while in other cases it throws an "Error" rather than an exception.
diff --git a/README.md b/README.md
index 2c0388c3e..bcc6ebdc8 100644
--- a/README.md
+++ b/README.md
@@ -12,13 +12,13 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
 *Gson Downloads*
-  * [Gson 2.4 Download](http://search.maven.org/#artifactdetails%7Ccom.google.code.gson%7Cgson%7C2.4%7Cjar) downloads at Maven Central
+  * [Gson 2.5 Download](http://search.maven.org/#artifactdetails%7Ccom.google.code.gson%7Cgson%7C2.5%7Cjar) downloads at Maven Central
 
 *Gson Documentation*
   * Gson [API](http://google.github.io/gson/apidocs/): Javadocs for the current Gson release
-  * Gson [user guide](http://sites.google.com/site/gson/gson-user-guide): This guide contains examples on how to use Gson in your code.
-  * Gson [Roadmap](https://sites.google.com/site/gson/gson-roadmap): Details on upcoming releases 
-  * Gson [design document](https://sites.google.com/site/gson/gson-design-document): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+  * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
+  * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
+  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
 
 Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
 
diff --git a/ReleaseProcess.md b/ReleaseProcess.md
new file mode 100644
index 000000000..4f541136b
--- /dev/null
+++ b/ReleaseProcess.md
@@ -0,0 +1,56 @@
+#Gson Release Process
+
+The following is a step-by-step procedure for releasing a new version of Google-Gson.
+
+1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
+2. Edit pom.xml and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
+3. Ensure all changelists are code-reviewed and have +1
+4. Ensure that your ~/.m2/settings.xml is configured properly (see steps below)
+5. cd gson. Ensure there are no open files and all changes are committed. 
+6. Run `mvn release:clean`
+7. Do a dry run: `mvn release:prepare -DdryRun=true`
+8. Start the release: `mvn release:prepare`
+  * Answer questions: usually the defaults are fine. 
+  * This will do a full build, change version from -SNAPSHOT to the released version, commit and create the tags. It will then change the version to -SNAPSHOT for the next release.
+9. Ensure you have defined `sonatype-nexus-staging` in your maven `settings.xml` and run `mvn -s /home/<username>/.m2/settings.xml  release:perform`
+10. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and javadoc jars.
+  * `cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2  /tmp; cd /tmp/1.7.2`
+  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2-javadoc.jar -Dclassifier=javadoc`
+  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2-sources.jar -Dclassifier=sources`
+  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2.jar`
+11. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+12. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
+13. Publishing Javadocs
+  * Switch to the branch `gh-pages`
+  * `jar xvf /tmp/2.5/gson-2.5-javadoc.jar`
+  * `git commit -m 'updated javadocs to 2.5'`
+14. Update the version in the [Using Gson with Maven2 page](https://sites.google.com/site/gson/gson-user-guide/using-gson-with-maven2)
+15. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
+16. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
+17. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current "stable" release.
+
+## Configuring a machine for deployment to Sonatype Repository
+
+(Borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease)).
+
+1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
+2. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+3. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
+4. Now for deploying a snapshot repository, use `mvn deploy`.
+
+## Getting Maven Publishing Privileges
+Based on Gson group thread: https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion
+
+1. Signup for a Sonatype account following instructions under 2) at https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
+2. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
+
+## Running Benchmarks or Tests on Android
+Download vogar
+Put `adb` on your `$PATH` and run:
+`vogar --benchmark --classpath gson.jar path/to/Benchmark.java`
+
+For example, here is how to run the CollectionsDeserializationBenchmark:
+
+`export ANDROID_HOME=~/apps/android-sdk-mac_x86
+export PATH=$PATH:$ANDROID_HOME/platform-tools/:$ANDROID_HOME/android-sdk-mac_x86/tools/
+$VOGAR_HOME/bin/vogar  --benchmark --sourcepath ../gson/src/main/java/  src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java -- --vm "app_process -Xgc:noconcurrent,app_process"`
diff --git a/UserGuide.md b/UserGuide.md
new file mode 100644
index 000000000..dbf9af6b2
--- /dev/null
+++ b/UserGuide.md
@@ -0,0 +1,625 @@
+#Gson User Guide
+
+1. [Overview](#TOC-Overview)
+2. [Goals for Gson](#TOC-Goals-for-Gson)
+3. [Gson Performance and Scalability](#TOC-Gson-Performance-and-Scalability)
+4. [Gson Users](#TOC-Gson-Users)
+5. [Using Gson](#TOC-Using-Gson)
+  * [Using Gson with Maven](#TOC-Gson-With-Maven)
+  * [Primitives Examples](#TOC-Primitives-Examples)
+  * [Object Examples](#TOC-Object-Examples)
+  * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
+  * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
+  * [Array Examples](#TOC-Array-Examples)
+  * [Collections Examples](#TOC-Collections-Examples)
+    * [Collections Limitations](#TOC-Collections-Limitations)
+  * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
+  * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
+  * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
+  * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
+    * [Writing a Serializer](#TOC-Writing-a-Serializer)
+    * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
+  * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
+    * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
+  * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
+  * [Null Object Support](#TOC-Null-Object-Support)
+  * [Versioning Support](#TOC-Versioning-Support)
+  * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
+    * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
+    * [Gson's @Expose](#TOC-Gson-s-Expose)
+    * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
+  * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
+  * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
+  * [Streaming](#TOC-Streaming)
+6. [Issues in Designing Gson](#TOC-Issues-in-Designing-Gson)
+7. [Future Enhancements to Gson](#TOC-Future-Enhancements-to-Gson)
+
+## <a name="TOC-Overview"></a>Overview
+
+Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
+
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
+
+## <a name="TOC-Goals-for-Gson"></a>Goals for Gson
+
+*   Provide easy to use mechanisms like `toString()` and constructor (factory method) to convert Java to JSON and vice-versa
+*   Allow pre-existing unmodifiable objects to be converted to and from JSON
+*   Allow custom representations for objects
+*   Support arbitrarily complex object
+*   Generate compact and readability JSON output
+
+## <a name="TOC-Gson-Performance-and-Scalability"></a>Gson Performance and Scalability
+
+Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class [PerformanceTest](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java).
+
+*   Strings: Deserialized strings of over 25MB without any problems (see <span style="font-family:courier new,monospace">disabled_testStringDeserializationPerformance</span> method in <span style="font-family:courier new,monospace">PerformanceTest</span>)
+
+*   Large collections:
+
+*   Serialized a collection of 1.4 million objects (see <span style="font-family:courier new,monospace">disabled_testLargeCollectionSerialization</span> method in <span style="font-family:courier new,monospace">PerformanceTest</span>)
+
+*   Deserialized a collection of 87,000 objects (see <span style="font-family:courier new,monospace">disabled_testLargeCollectionDeserialization</span> in <span style="font-family:courier new,monospace">PerformanceTest</span>)
+
+*   Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.
+
+Note: Delete the <span style="font-family:courier new,monospace">disabled_</span> prefix to run these tests. We use this prefix to prevent running these tests every time we run junit tests.
+
+## <a name="TOC-Gson-Users"></a>Gson Users
+
+Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details [here](https://sites.google.com/site/gson/gson-users).
+
+## <a name="TOC-Using-Gson"></a>Using Gson
+
+The primary class to use is [Gson](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/Gson.java "Gson") which you can just create by calling new Gson(). There is also a class [GsonBuilder](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/GsonBuilder.java "GsonBuilder") available that can be used to create a Gson instance with various settings like version control and so on.
+
+The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.
+
+## <a name="TOC-Gson-With-Maven"></a>Using Gson with Maven
+To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:
+```
+<dependencies>
+    <!--  Gson: Java to Json conversion -->
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.5</version>
+      <scope>compile</scope>
+    </dependency>
+</dependencies>
+```
+That is it, now your maven project is Gson enabled. 
+
+### <a name="TOC-Primitives-Examples"></a>Primitives Examples
+```
+(Serialization)
+Gson gson = new Gson();
+gson.toJson(1);            ==> prints 1
+gson.toJson("abcd");       ==> prints "abcd"
+gson.toJson(new Long(10)); ==> prints 10
+int[] values = { 1 };
+gson.toJson(values);       ==> prints [1]
+
+(Deserialization)
+int one = gson.fromJson("1", int.class);
+Integer one = gson.fromJson("1", Integer.class);
+Long one = gson.fromJson("1", Long.class);
+Boolean false = gson.fromJson("false", Boolean.class);
+String str = gson.fromJson("\"abc\"", String.class);
+String anotherStr = gson.fromJson("[\"abc\"]", String.class);
+```
+
+### <a name="TOC-Object-Examples"></a>Object Examples
+```
+class BagOfPrimitives {
+  private int value1 = 1;
+  private String value2 = "abc";
+  private transient int value3 = 3;
+  BagOfPrimitives() {
+    // no-args constructor
+  }
+}
+(Serialization)
+BagOfPrimitives obj = new BagOfPrimitives();
+Gson gson = new Gson();
+String json = gson.toJson(obj);  
+
+==> json is {"value1":1,"value2":"abc"}
+```
+
+Note that you can not serialize objects with circular references since that will result in infinite recursion.
+```
+(Deserialization)
+BagOfPrimitives obj2 =gson.fromJson(json, BagOfPrimitives.class);
+==> obj2 is just like obj
+```
+
+#### <a name="TOC-Finer-Points-with-Objects"></a>**Finer Points with Objects**
+
+*   It is perfectly fine (and recommended) to use private fields
+*   There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
+*   If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
+*   This implementation handles nulls correctly
+*   While serialization, a null field is skipped from the output
+*   While deserialization, a missing entry in JSON results in setting the corresponding field in the object to null
+*   If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
+*   Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
+
+### <a name="TOC-Nested-Classes-including-Inner-Classes-"></a>Nested Classes (including Inner Classes)
+
+Gson can serialize static nested classes quite easily.
+
+Gson can also deserialize static nested classes. However, Gson can **not** automatically deserialize the **pure inner classes since their no-args constructor also need a reference to the containing Object** which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:
+
+```
+public class A { 
+  public String a; 
+
+  class B { 
+
+    public String b; 
+
+    public B() {
+      // No args constructor for B
+    }
+  } 
+}
+```
+**NOTE**: The above class B can not (by default) be serialized with Gson.
+
+Gson can not deserialize `{"b":"abc"}` into an instance of B since the class B is an inner class. if it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B. 
+
+```
+public class InstanceCreatorForB implements InstanceCreator<A.B> {
+  private final A a;
+  public InstanceCreatorForB(A a)  {
+    this.a = a;
+  }
+  public A.B createInstance(Type type) {
+    return a.new B();
+  }
+}
+```
+The above is possible, but not recommended.
+
+### <a name="TOC-Array-Examples"></a>Array Examples
+```
+Gson gson = new Gson();
+int[] ints = {1, 2, 3, 4, 5};
+String[] strings = {"abc", "def", "ghi"};
+
+(Serialization)
+gson.toJson(ints);     ==> prints [1,2,3,4,5]
+gson.toJson(strings);  ==> prints ["abc", "def", "ghi"]
+
+(Deserialization)
+int[] ints2 = gson.fromJson("[1,2,3,4,5]", int[].class); 
+==> ints2 will be same as ints
+```
+We also support multi-dimensional arrays, with arbitrarily complex element types.
+
+### <a name="TOC-Collections-Examples"></a>Collections Examples
+```
+Gson gson = new Gson();
+Collection<Integer> ints = Lists.immutableList(1,2,3,4,5);
+
+(Serialization)
+String json = gson.toJson(ints); ==> json is [1,2,3,4,5]
+
+(Deserialization)
+Type collectionType = new TypeToken<Collection<Integer>>(){}.getType();
+Collection<Integer> ints2 = gson.fromJson(json, collectionType);
+ints2 is same as ints
+```
+
+Fairly hideous: note how we define the type of collection
+Unfortunately, no way to get around this in Java</font></span>
+
+#### <a name="TOC-Collections-Limitations"></a>Collections Limitations
+
+*   Can serialize collection of arbitrary objects but can not deserialize from it
+*   Because there is no way for the user to indicate the type of the resulting object
+*   While deserializing, Collection must be of a specific generic type
+
+All of this makes sense, and is rarely a problem when following good Java coding practices
+
+### <a name="TOC-Serializing-and-Deserializing-Generic-Types"></a>Serializing and Deserializing Generic Types
+
+When you call `toJson(obj)`, Gson calls `obj.getClass()` to get information on the fields to serialize. Similarly, you can typically pass <span style="font-family:courier new,monospace">MyClass.class</span> object in the <span style="font-family:courier new,monospace">fromJson(json, MyClass.class)</span> method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:
+```
+class Foo<T> {
+  T value;
+}
+Gson gson = new Gson();
+Foo<Bar> foo = new Foo<Bar>();
+gson.toJson(foo); // May not serialize foo.value correctly
+
+gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
+```
+
+The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, <span style="font-family:courier new,monospace">Foo.class</span>. This means that Gson has no way of knowing that this is an object of type Foo<Bar>, and not just plain Foo.
+
+You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [TypeToken](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
+```
+Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
+gson.toJson(foo, fooType);
+
+gson.fromJson(json, fooType);
+```
+The idiom used to get `fooType` actually defines an anonymous local inner class containing a method `getType()` that returns the fully parameterized type.
+
+### <a name="TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types"></a>Serializing and Deserializing Collection with Objects of Arbitrary Types
+
+Sometimes you are dealing with JSON array that contains mixed types. For example:
+`['hello',5,{name:'GREETINGS',source:'guest'}]`
+
+The equivalent Collection containing this is:
+```
+Collection collection = new ArrayList();
+collection.add("hello");
+collection.add(5);
+collection.add(new Event("GREETINGS", "guest"));
+```
+Where the Event class is defined as:
+```
+class Event {
+  private String name;
+  private String source;
+  private Event(String name, String source) {
+    this.name = name;
+    this.source = source;
+  }
+}
+```
+
+You can serialize the collection with Gson without doing anything specific: `toJson(collection)` would write out the desired output.
+
+However, deserialization with `fromJson(json, Collection.class)` will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in fromJson. So, you have three options:
+
+Option 1: Use Gson's parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use Gson.fromJson() on each of the array elements.This is the preferred approach. [Here is an example](http://code.google.com/p/google-gson/source/browse/trunk/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java) that demonstrates how to do this.
+
+Option 2: Register a type adapter for Collection.class that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.
+
+Option 3: Register a type adapter for MyCollectionMemberType and use fromJson with Collection<MyCollectionMemberType>
+
+This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type `Collection<MyCollectionMemberType>`.
+
+### <a name="TOC-Built-in-Serializers-and-Deserializers"></a>Built-in Serializers and Deserializers
+
+Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
+Here is a list of such classes:
+
+1.  `java.net.URL` to match it with strings like "http://code.google.com/p/google-gson/".
+2.  `java.net.URI` to match it with strings like "/p/google-gson/".
+
+You can also find source-code for some commonly used classes such as JodaTime at [this page](https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1).
+
+### <a name="TOC-Custom-Serialization-and-Deserialization"></a>Custom Serialization and Deserialization
+
+Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
+Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:
+
+*   Json Serialiers: Need to define custom serialization for an object
+*   Json Deserializers: Needed to define custom deserialization for a type
+
+*   Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
+```
+GsonBuilder gson = new GsonBuilder();
+gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
+gson.registerTypeAdapter(MyType.class, new MySerializer());
+gson.registerTypeAdapter(MyType.class, new MyDeserializer());
+gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());
+```
+
+`registerTypeAdapter` call checks if the type adapter implements more than one of these interfaces and register it for all of them.
+
+#### <a name="TOC-Writing-a-Serializer"></a>Writing a Serializer
+
+Here is an example of how to write a custom serializer for JodaTime `DateTime` class.
+```
+private class DateTimeSerializer implements JsonSerializer<DateTime> {
+  public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
+    return new JsonPrimitive(src.toString());
+  }
+}
+```
+
+Gson calls `serialize()` when it runs into a `DateTime` object during serialization.
+
+#### <a name="TOC-Writing-a-Deserializer"></a>Writing a Deserializer
+
+Here is an example of how to write a custom deserializer for JodaTime DateTime class.
+```
+private class DateTimeDeserializer implements JsonDeserializer<DateTime> {
+  public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+      throws JsonParseException {
+    return new DateTime(json.getAsJsonPrimitive().getAsString());
+  }
+}
+```
+
+Gson calls `deserialize` when it needs to deserialize a JSON string fragment into a DateTime object
+
+**Finer points with Serializers and Deserializers**
+
+Often you want to register a single handler for all generic types corresponding to a raw type
+
+*   For example, suppose you have an "Id" class for Id representation/translation (i.e. an internal vs. external representation).
+*   `Id<T>` type that has same serialization for all generic types
+  *   Essentially write out the id value
+
+*   Deserialization is very similar but not exactly the same
+  *   Need to call <span style="font-family:courier new,monospace">"new Id(Class<T>, String)"</span> which returns an instance of Id<T>
+
+Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say <span style="font-family:courier new,monospace">Id<RequiresSpecialHandling></span> needed special handling).
+The <span style="font-family:courier new,monospace">Type</span> parameter for the <span style="font-family:courier new,monospace">toJson</span> and <span style="font-family:courier new,monospace">fromJson</span> contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type
+
+### <a name="TOC-Writing-an-Instance-Creator"></a>Writing an Instance Creator
+
+While deserializing an Object, Gson needs to create a default instance of the class
+Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor
+
+*   Doesn't matter whether public or private
+
+Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor
+
+**
+Instance Creator Example**
+
+```
+private class MoneyInstanceCreator implements InstanceCreator<Money> {
+  public Money createInstance(Type type) {
+    return new Money("1000000", CurrencyCode.USD);
+  }
+}
+```
+
+Type could be of a corresponding generic type
+
+*   Very useful to invoke constructors which need specific generic type information
+*   For example, if the `Id` class stores the class for which the Id is being created
+
+#### <a name="TOC-InstanceCreator-for-a-Parameterized-Type"></a>InstanceCreator for a Parameterized Type
+
+Sometimes that the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:
+```
+class MyList<T> extends ArrayList<T> {
+}
+
+class MyListInstanceCreator implements InstanceCreator<MyList<?>> {
+    @SuppressWarnings("unchecked")
+  public MyList<?> createInstance(Type type) {
+    // No need to use a parameterized list since the actual instance will have the raw type anyway.
+    return new MyList();
+  }
+}
+```
+However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the <span style="font-family:courier new,monospace">createInstance</span> method. Here is an example:
+```
+public class Id<T> {
+  private final Class<T> classOfId;
+  private final long value;
+  public Id(Class<T> classOfId, long value) {
+    this.classOfId = classOfId;
+    this.value = value;
+  }
+}
+
+class IdInstanceCreator implements InstanceCreator<Id<?>> {
+  public Id<?> createInstance(Type type) {
+    Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments();
+    Type idType = typeParameters[0]; // Id has only one parameterized type T
+    return Id.get((Class)idType, 0L);
+  }
+}
+```
+
+In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, <span style="font-family:courier new,monospace">type</span>. The <span style="font-family:courier new,monospace">type</span> object in this case is the Java parameterized type representation of <span style="font-family:courier new,monospace">Id<Foo></span> where the actual instance should be bound to <span style="font-family:courier new,monospace">Id<Foo></span>. Since <span style="font-family:courier new,monospace">Id</span> class has just one parameterized type parameter, <span style="font-family:courier new,monospace">T</span>, we use the zeroth element of the type array returned by <span style="font-family:courier new,monospace">getActualTypeArgument()</span> which will hold <span style="font-family:courier new,monospace">Foo.class</span> in this case.
+
+### <a name="TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format"></a>Compact Vs. Pretty Printing for JSON Output Format
+
+The default JSON output that is provide by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, "null" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the [Null Object Support](#TOC-Null-Object-Support) section for information on configure Gson to output all null values.
+
+If you like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default <span style="font-family:courier new,monospace">JsonPrintFormatter</span> that has default line length of 80 character, 2 character indentation, and 4 character right margin.
+
+The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the <span style="font-family:courier new,monospace">JsonCompactFormatter</span>:
+```
+Gson gson = new GsonBuilder().setPrettyPrinting().create();
+String jsonOutput = gson.toJson(someObject);
+```
+### <a name="TOC-Null-Object-Support"></a>Null Object Support
+
+The default behaviour that is implemented in Gson is that `null` object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java.
+
+Here's how you would configure a `Gson` instance to output null:
+`Gson gson = new GsonBuilder().serializeNulls().create();`
+
+NOTE: when serializing `null`s with Gson, it will add a `JsonNull` element to the `JsonElement` structure. Therefore, this object can be used in custom serialization/deserialization.
+
+Here's an example:
+```
+public class Foo {
+  private final String s;
+  private final int i;
+
+  public Foo() {
+    this(null, 5);
+  }
+
+  public Foo(String s, int i) {
+    this.s = s;
+    this.i = i;
+  }
+}
+
+Gson gson = new GsonBuilder().serializeNulls().create();
+Foo foo = new Foo();
+String json = gson.toJson(foo);
+System.out.println(json);
+
+json = gson.toJson(null);
+System.out.println(json);
+
+======== OUTPUT ========
+{"s":null,"i":5}
+null
+```
+### <a name="TOC-Versioning-Support"></a>Versioning Support
+
+Multiple versions of the same object can be maintained by using [@Since](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/annotations/Since.java "@Since") annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your <span style="font-family:courier new,monospace">Gson</span> instance to ignore any field/object that is greater than some version number. If no version is set on the <span style="font-family:courier new,monospace">Gson</span> instance then it will serialize and deserialize all fields and classes regardless of the version.
+```
+public class VersionedClass {
+  @Since(1.1) private final String newerField;
+  @Since(1.0) private final String newField;
+  private final String field;
+
+  public VersionedClass() {
+    this.newerField = "newer";
+    this.newField = "new";
+    this.field = "old";
+  }
+}
+
+VersionedClass versionedObject = new VersionedClass();
+Gson gson = new GsonBuilder().setVersion(1.0).create();
+String jsonOutput = gson.toJson(someObject);
+System.out.println(jsonOutput);
+System.out.println();
+
+gson = new Gson();
+jsonOutput = gson.toJson(someObject);
+System.out.println(jsonOutput);
+
+======== OUTPUT ========
+{"newField":"new","field":"old"}
+
+{"newerField":"newer","newField":"new","field":"old"}
+```
+
+### <a name="TOC-Excluding-Fields-From-Serialization-and-Deserialization"></a>Excluding Fields From Serialization and Deserialization
+
+Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanism that allow field and class exclusion. If none of the below mechanism satisfy your needs then you can always use [custom serializers and deserializers](#TOC-Custom-Serialization-and-Deserializ).
+
+#### <a name="TOC-Java-Modifier-Exclusion"></a>Java Modifier Exclusion
+
+By default, if you mark a field as `transient`, it will be excluded. As well, if a field is marked as `static` then by default it will be excluded. If you want to include some transient fields then you can do the following:
+```
+import java.lang.reflect.Modifier;
+Gson gson = new GsonBuilder()
+    .excludeFieldsWithModifiers(Modifier.STATIC)
+    .create();
+```
+NOTE: you can use any number of the `Modifier` constants to `excludeFieldsWithModifiers` method. For example:
+```
+Gson gson = new GsonBuilder()
+    .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
+    .create();
+```
+
+#### <a name="TOC-Gson-s-Expose"></a>Gson's @Expose
+
+This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using <span style="font-family:courier new,monospace">new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</span>. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
+
+#### <a name="TOC-User-Defined-Exclusion-Strategies"></a>User Defined Exclusion Strategies
+
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [<span style="font-family:courier new,monospace">ExclusionStrategy</span>](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+
+The following example shows how to exclude fields marked with a specific "@Foo" annotation and excludes top-level types (or declared field type) of class String.
+```
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({ElementType.FIELD})
+  public @interface Foo {
+    // Field tag only annotation
+  }
+
+  public class SampleObjectForTest {
+    @Foo private final int annotatedField;
+    private final String stringField;
+    private final long longField;
+    private final Class<?> clazzField;
+
+    public SampleObjectForTest() {
+      annotatedField = 5;
+      stringField = "someDefaultValue";
+      longField = 1234;
+    }
+  }
+
+  public class MyExclusionStrategy implements ExclusionStrategy {
+    private final Class<?> typeToSkip;
+
+    private MyExclusionStrategy(Class<?> typeToSkip) {
+      this.typeToSkip = typeToSkip;
+    }
+
+    public boolean shouldSkipClass(Class<?> clazz) {
+      return (clazz == typeToSkip);
+    }
+
+    public boolean shouldSkipField(FieldAttributes f) {
+      return f.getAnnotation(Foo.class) != null;
+    }
+  }
+
+  public static void main(String[] args) {
+    Gson gson = new GsonBuilder()
+        .setExclusionStrategies(new MyExclusionStrategy(String.class))
+        .serializeNulls()
+        .create();
+    SampleObjectForTest src = new SampleObjectForTest();
+    String json = gson.toJson(src);
+    System.out.println(json);
+  }
+
+======== OUTPUT ========
+{"longField":1234}
+```
+### <a name="TOC-JSON-Field-Naming-Support"></a>JSON Field Naming Support
+
+Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e. camel cased names starting with lower case --- "sampleFieldNameInJava") to a Json field name (i.e. sample_field_name_in_java or SampleFieldNameInJava). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
+
+It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise "Runtime" exceptions if an invalid field name is provided as the annotation value.
+
+The following is an example of how to use both Gson naming policy features:
+```
+private class SomeObject {
+  @SerializedName("custom_naming") private final String someField;
+  private final String someOtherField;
+
+  public SomeObject(String a, String b) {
+    this.someField = a;
+    this.someOtherField = b;
+  }
+}
+
+SomeObject someObject = new SomeObject("first", "second");
+Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
+String jsonRepresentation = gson.toJson(someObject);
+System.out.println(jsonRepresentation);
+
+======== OUTPUT ========
+{"custom_naming":"first","SomeOtherField":"second"}
+```
+
+If you have a need for custom naming policy ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](http://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html) annotation.
+
+### <a name="TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers"></a>Sharing State Across Custom Serializers and Deserializers
+
+Sometimes you need to share state across custom serializers/deserializers ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb)). You can use the following three strategies to accomplish this:
+
+1.  Store shared state in static fields
+2.  Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state
+3.  Use Java ThreadLocal
+
+1 and 2 are not thread-safe options, but 3 is.
+
+### <a name="TOC-Streaming"></a>Streaming
+
+In addition Gson's object model and data binding, you can use Gson to read from and write to a [stream](https://sites.google.com/site/gson/streaming). You can also combine streaming and object model access to get the best of both approaches.
+
+## <a name="TOC-Issues-in-Designing-Gson"></a>Issues in Designing Gson
+
+See the [Gson design document](https://sites.google.com/site/gson/gson-design-document "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
+
+## <a name="TOC-Future-Enhancements-to-Gson"></a>Future Enhancements to Gson
+
+For the latest list of proposed enhancements or if you'd like to suggest new ones, see the [Issues section](http://code.google.com/p/google-gson/issues/list "Issues section") under the project website.
diff --git a/gson/pom.xml b/gson/pom.xml
index 74f886e85..cb171c711 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -3,7 +3,7 @@
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
   <packaging>jar</packaging>
-  <version>2.5-SNAPSHOT</version>
+  <version>2.6-SNAPSHOT</version>
   <inceptionYear>2008</inceptionYear>
   <name>Gson</name>
   <parent>
diff --git a/pom.xml b/pom.xml
index e8edde909..8a2ceffae 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,7 +3,7 @@
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.5-SNAPSHOT</version>
+  <version>2.6-SNAPSHOT</version>
   <inceptionYear>2008</inceptionYear>
   <name>Gson Parent</name>
   <parent>
