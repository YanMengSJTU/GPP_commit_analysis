diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index a65c7d3b2..dabcbd705 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -98,111 +98,6 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
   }
 
-  private ReflectiveTypeAdapterFactory.BoundField createBoundField(
-          final Gson context, final Field field, final String name,
-          final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
-    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
-    // special casing primitives here saves ~5% on Android...
-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
-    TypeAdapter<?> mapped = null;
-    if (annotation != null) {
-      mapped = jsonAdapterFactory.getTypeAdapter(
-              constructorConstructor, context, fieldType, annotation);
-    }
-    final boolean jsonAdapterPresent = mapped != null;
-    if (mapped == null) mapped = context.getAdapter(fieldType);
-
-    final TypeAdapter<?> typeAdapter = mapped;
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
-      @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
-      @Override void write(JsonWriter writer, Object value)
-              throws IOException, IllegalAccessException {
-        Object fieldValue;
-
-        if(context.useGetterSetter()) {
-          String fieldName = field.getName();
-          String getterPrefix = field.getType() == boolean.class || field.getType() == Boolean.class ? "is" : "get";
-          String getterName = getterPrefix + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
-
-          try {
-            Method method = value.getClass().getMethod(getterName);
-            fieldValue = method.invoke(value);
-
-          } catch (NoSuchMethodException ignored) {
-              /*
-                Getting field via reflection if no setter method is found in the class for that field
-              */
-            fieldValue = field.get(value);
-
-          } catch (InvocationTargetException ignored) {
-              /*
-                TODO : Needs to be revisited
-                If use of getter is enabled & Gson is unable to call getter, then throw error or just use reflection?
-                Since earlier Gson version worked in all cases, using reflection to get field value for now.
-              */
-            fieldValue = field.get(value);
-          } catch (IllegalAccessException ignored) {
-              /*
-                TODO : Needs to be revisited
-                If use of getter is enabled & Gson is unable to call getter, then throw error or just use reflection?
-                Since earlier Gson version worked in all cases, using reflection to get field value for now.
-              */
-            fieldValue = field.get(value);
-          }
-        } else {
-          fieldValue = field.get(value);
-        }
-
-        TypeAdapter t = jsonAdapterPresent ? typeAdapter
-                : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
-        t.write(writer, fieldValue);
-      }
-      @Override void read(JsonReader reader, Object value)
-              throws IOException, IllegalAccessException {
-        Object fieldValue = typeAdapter.read(reader);
-        if (fieldValue != null || !isPrimitive) {
-
-          if (context.useGetterSetter()) {
-            String fieldName = field.getName();
-            String setterName = "set" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
-
-            try {
-              Method method = value.getClass().getMethod(setterName, field.getType());
-              method.invoke(value, fieldValue);
-
-            } catch (NoSuchMethodException ignored) {
-              /*
-                Setting field via reflection if no setter method is found in the class for that field
-              */
-              field.set(value, fieldValue);
-
-            } catch (InvocationTargetException ignored) {
-              /*
-                TODO : Needs to be revisited
-                If use of setter is enabled & Gson is unable to call setter, then throw error or just use reflection?
-                Since earlier Gson version worked in all cases, using reflection to set field value for now.
-              */
-              field.set(value, fieldValue);
-            } catch (IllegalAccessException ignored) {
-              /*
-                TODO : Needs to be revisited
-                If use of setter is enabled & Gson is unable to call setter, then throw error or just use reflection?
-                Since earlier Gson version worked in all cases, using reflection to set field value for now.
-              */
-              field.set(value, fieldValue);
-            }
-          } else {
-            field.set(value, fieldValue);
-          }
-        }
-      }
-      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
-        if (!serialized) return false;
-        Object fieldValue = field.get(value);
-        return fieldValue != value; // avoid recursion for example for Throwable.cause
-      }
-    };
-  }
 
   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
@@ -332,7 +227,7 @@ static String fieldNameFromGetter(Method getter) {
         boolean writeField(Object value) throws IOException, IllegalAccessException {
           if (!serialized) return false;
           Object fieldValue = getValue(value);
-          return fieldValue != value; //
+          return fieldValue != value; // avoid recursion for example for Throwable.cause
         }
 
         @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
