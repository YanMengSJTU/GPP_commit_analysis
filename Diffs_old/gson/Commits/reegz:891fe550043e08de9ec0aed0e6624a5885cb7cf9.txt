diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 354ce5a1f..7ff333ce1 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -16,6 +16,15 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.*;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.internal.LazilyParsedNumber;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import guru.mmp.common.util.ISO8601;
+
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -24,39 +33,15 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Calendar;
-import java.util.Currency;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.UUID;
+import java.text.ParseException;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerArray;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.LazilyParsedNumber;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-
 /**
  * Type adapters for basic types.
  */
@@ -693,6 +678,104 @@ public void write(JsonWriter out, Locale value) throws IOException {
     }
   };
 
+  public static final TypeAdapter<LocalDateTime> LOCAL_DATE_TIME = new TypeAdapter<LocalDateTime>() {
+
+    @Override
+    public LocalDateTime read(JsonReader reader) throws IOException {
+      if (reader.peek() == JsonToken.NULL) {
+        reader.nextNull();
+        return null;
+      }
+      try {
+        return ISO8601.toLocalDateTime(reader.nextString());
+      } catch (ParseException e) {
+        throw new IOException("Unable to convert value into LocalDateTime.", e);
+      }
+    }
+
+    @Override
+    public void write(JsonWriter writer, LocalDateTime value) throws IOException {
+      if (value == null) {
+        writer.nullValue();
+        return;
+      }
+      writer.value(ISO8601.fromLocalDateTime(value));
+    }
+  };
+
+  public static final TypeAdapterFactory LOCALDATETIME_FACTORY =
+          newFactory(LocalDateTime.class, LOCAL_DATE_TIME);
+
+  public static class LocalDateAdapter extends TypeAdapter<LocalDate> {
+
+    public LocalDate read(JsonReader reader) throws IOException {
+      if (reader.peek() == JsonToken.NULL) {
+        reader.nextNull();
+        return null;
+      }
+      try {
+        return ISO8601.toLocalDate(reader.nextString());
+      } catch (ParseException e) {
+        throw new IOException("Unable to convert value into LocalDate.", e);
+      }
+    }
+
+    public void write(JsonWriter writer, LocalDate value) throws IOException {
+      if (value == null) {
+        writer.nullValue();
+        return;
+      }
+      writer.value(ISO8601.fromLocalDate(value));
+    }
+  }
+
+
+  public static class LocalTimeAdapter extends TypeAdapter<LocalTime> {
+
+    public LocalTime read(JsonReader reader) throws IOException {
+      if (reader.peek() == JsonToken.NULL) {
+        reader.nextNull();
+        return null;
+      }
+      try {
+        return ISO8601.toLocalTime(reader.nextString());
+      } catch (ParseException e) {
+        throw new IOException("Unable to convert value into LocalTime.", e);
+      }
+    }
+
+    public void write(JsonWriter writer, LocalTime value) throws IOException {
+      if (value == null) {
+        writer.nullValue();
+        return;
+      }
+      writer.value(ISO8601.fromLocalTime(value));
+    }
+  }
+
+  public static class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {
+
+    public LocalDateTime read(JsonReader reader) throws IOException {
+      if (reader.peek() == JsonToken.NULL) {
+        reader.nextNull();
+        return null;
+      }
+      try {
+        return ISO8601.toLocalDateTime(reader.nextString());
+      } catch (ParseException e) {
+        throw new IOException("Unable to convert value into LocalDateTime.", e);
+      }
+    }
+
+    public void write(JsonWriter writer, LocalDateTime value) throws IOException {
+      if (value == null) {
+        writer.nullValue();
+        return;
+      }
+      writer.value(ISO8601.fromLocalDateTime(value));
+    }
+  }
+
   public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);
 
   public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {
diff --git a/gson/src/main/java/guru/mmp/common/util/ISO8601.java b/gson/src/main/java/guru/mmp/common/util/ISO8601.java
new file mode 100644
index 000000000..59bd3ba08
--- /dev/null
+++ b/gson/src/main/java/guru/mmp/common/util/ISO8601.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2017 Marcus Portmann
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package guru.mmp.common.util;
+
+//~--- JDK imports ------------------------------------------------------------
+
+import java.text.ParseException;
+import java.time.*;
+import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeFormatterBuilder;
+import java.time.temporal.ChronoField;
+import java.time.temporal.TemporalAccessor;
+
+/**
+ * The <code>ISO8601</code> class provides a helper class for handling ISO 8601 strings of the
+ * following format: "2008-03-01T13:00:00+01:00". It also supports parsing the "Z" timezone.
+ *
+ * @author Marcus Portmann
+ */
+public final class ISO8601
+{
+    private static final ThreadLocal<DateTimeFormatter> threadLocalDateTimeFormatter =
+            new ThreadLocal<DateTimeFormatter>() {
+                @Override public DateTimeFormatter initialValue() {
+                    return new DateTimeFormatterBuilder().appendPattern(
+                            "yyyy-MM-dd'T'HH:mm:ss").parseLenient().optionalStart().appendPattern(".SSS").optionalEnd()
+                            .optionalStart().appendOffset("+HH:MM", "Z").optionalEnd().toFormatter();
+                    }
+            };
+
+    private static final ThreadLocal<DateTimeFormatter> threadLocalDateFormatter =
+            new ThreadLocal<DateTimeFormatter>() {
+                @Override public DateTimeFormatter initialValue() {
+                    return DateTimeFormatter.ISO_DATE;
+                }
+            };
+
+    private static final ThreadLocal<DateTimeFormatter> threadLocalTimeFormatter =
+            new ThreadLocal<DateTimeFormatter>() {
+                @Override public DateTimeFormatter initialValue() {
+                    return DateTimeFormatter.ISO_DATE;
+                }
+            };
+
+    /**
+     * Transform the <code>LocalDate</code> instance into an ISO 8601 string.
+     *
+     * @param localDate the <code>LocalDate</code> instance to transform into an ISO 8601 string
+     *
+     * @return the ISO 8601 string for the <code>LocalDate</code> instance
+     */
+    public static String fromLocalDate(LocalDate localDate)
+    {
+        return localDate.format(threadLocalDateFormatter.get());
+    }
+
+    /**
+     * Transform the <code>LocalDateTime</code> instance into an ISO 8601 string.
+     *
+     * @param localDateTime the <code>LocalDateTime</code> instance to transform into an ISO 8601 string
+     *
+     * @return the ISO 8601 string for the <code>LocalDateTime</code> instance
+     */
+    public static String fromLocalDateTime(LocalDateTime localDateTime)
+    {
+        return localDateTime.format(threadLocalDateTimeFormatter.get());
+    }
+
+    /**
+     * Transform the <code>LocalTime</code> instance into an ISO 8601 string.
+     *
+     * @param localTime the <code>LocalTime</code> instance to transform into an ISO 8601 string
+     *
+     * @return the ISO 8601 string for the <code>LocalTime</code> instance
+     */
+    public static String fromLocalTime(LocalTime localTime)
+    {
+        return localTime.format(threadLocalTimeFormatter.get());
+    }
+
+    /**
+     * Transform the <code>ZonedDateTime</code> instance into an ISO 8601 string.
+     *
+     * @param zonedDateTime the <code>ZonedDateTime</code> instance to transform into an ISO 8601
+     *                      string
+     *
+     * @return the ISO 8601 string for the <code>ZonedDateTime</code> instance
+     */
+    public static String fromZonedDateTime(ZonedDateTime zonedDateTime)
+    {
+        return zonedDateTime.format(threadLocalDateTimeFormatter.get());
+    }
+
+    /**
+     * Main.
+     *
+     * @param args the command line arguments
+     *
+     * @throws Exception
+     */
+    public static void main(String[] args)
+            throws Exception
+    {
+        System.out.println(fromLocalDateTime(LocalDateTime.now()));
+
+        System.out.println(fromZonedDateTime(ZonedDateTime.now(ZoneId.of("UTC"))));
+
+        System.out.println(fromZonedDateTime(ZonedDateTime.now(ZoneId.systemDefault())));
+
+        System.out.println("Local Date Time 2017-08-14T19:14:53.120Z = " + toLocalDateTime("2017-08-14T19:14:53.120Z"));
+
+        System.out.println("Local Date Time 2017-08-14T22:14:53.120+02:00 = " + toLocalDateTime(
+                "2017-08-14T22:14:53.120+02:00"));
+
+        System.out.println("Local Date Time 2017-08-14T19:14:53.120 = " + toLocalDateTime("2017-08-14T19:14:53.120"));
+
+        System.out.println("Local Date Time 2017-08-14T19:14:53 = " + toLocalDateTime("2017-08-14T19:14:53"));
+
+        System.out.println("Zoned Date Time 2017-08-14T19:14:53.120Z = " + toZonedDateTime("2017-08-14T19:14:53.120Z"));
+
+        System.out.println("Zoned Date Time 2017-08-14T22:14:53.120+02:00 = " + toZonedDateTime(
+                "2017-08-14T22:14:53.120+02:00"));
+
+        System.out.println("Zoned Date Time 2017-08-14T19:14:53.120 = " + toZonedDateTime("2017-08-14T19:14:53.120"));
+
+        System.out.println("Zoned Date Time 2017-08-14T19:14:53 = " + toZonedDateTime("2017-08-14T19:14:53"));
+    }
+
+    /**
+     * Get current date and time formatted as ISO 8601 string.
+     *
+     * @return the current date and time formatted as ISO 8601 string
+     */
+    public static String now()
+    {
+        return fromLocalDateTime(LocalDateTime.now());
+    }
+
+    /**
+     * Transform ISO 8601 string into a <code>LocalDate</code> instance.
+     *
+     * @param iso8601string the ISO 8601 string to transform
+     *
+     * @return the <code>LocalDate</code> instance for the ISO 8601 string
+     *
+     * @throws ParseException
+     */
+    public static LocalDate toLocalDate(String iso8601string)
+            throws ParseException
+    {
+        return LocalDate.parse(iso8601string, threadLocalDateFormatter.get());
+    }
+
+    /**
+     * Transform ISO 8601 string into a <code>LocalDateTime</code> instance.
+     *
+     * @param iso8601string the ISO 8601 string to transform
+     *
+     * @return the <code>LocalDateTime</code> instance for the ISO 8601 string
+     *
+     * @throws ParseException
+     */
+    public static LocalDateTime toLocalDateTime(String iso8601string)
+            throws ParseException
+    {
+        TemporalAccessor temporalAccessor = threadLocalDateTimeFormatter.get().parse(iso8601string);
+
+        if (temporalAccessor.isSupported(ChronoField.OFFSET_SECONDS))
+        {
+            return ZonedDateTime.parse(iso8601string, threadLocalDateTimeFormatter.get())
+                    .withZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();
+        }
+        else
+        {
+            return LocalDateTime.parse(iso8601string, threadLocalDateTimeFormatter.get());
+        }
+    }
+
+    /**
+     * Transform ISO 8601 string into a <code>LocalTime</code> instance.
+     *
+     * @param iso8601string the ISO 8601 string to transform
+     *
+     * @return the <code>LocalTime</code> instance for the ISO 8601 string
+     *
+     * @throws ParseException
+     */
+    public static LocalTime toLocalTime(String iso8601string)
+            throws ParseException
+    {
+        return LocalTime.parse(iso8601string, threadLocalTimeFormatter.get());
+    }
+
+    /**
+     * Transform ISO 8601 string into a <code>ZonedDateTime</code> instance.
+     *
+     * @param iso8601string the ISO 8601 string to transform
+     *
+     * @return the <code>ZonedDateTime</code> instance for the ISO 8601 string
+     *
+     * @throws ParseException
+     */
+    public static ZonedDateTime toZonedDateTime(String iso8601string)
+            throws ParseException
+    {
+        TemporalAccessor temporalAccessor = threadLocalDateTimeFormatter.get().parse(iso8601string);
+
+        if (temporalAccessor.isSupported(ChronoField.OFFSET_SECONDS))
+        {
+            return ZonedDateTime.parse(iso8601string, threadLocalDateTimeFormatter.get()).withZoneSameInstant(ZoneId.systemDefault());
+        }
+        else
+        {
+            return LocalDateTime.parse(iso8601string, threadLocalDateTimeFormatter.get()).atZone(ZoneId.systemDefault());
+        }
+    }
+}
\ No newline at end of file
diff --git a/gson/src/test/java/com/google/gson/LocalDateTimeTypeAdapterTest.java b/gson/src/test/java/com/google/gson/LocalDateTimeTypeAdapterTest.java
new file mode 100644
index 000000000..0f16ea60d
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/LocalDateTimeTypeAdapterTest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import com.google.gson.internal.bind.TypeAdapters;
+import junit.framework.TestCase;
+
+import java.time.LocalDateTime;
+import java.time.ZoneOffset;
+import java.time.format.DateTimeFormatter;
+
+/**
+ * A basic unit test for the {@link TypeAdapters.LocalDateTimeAdapter} class.
+ *
+ * @author Raihaan Cassim
+ */
+public class LocalDateTimeTypeAdapterTest extends TestCase {
+
+
+  public void testDatePattern() throws Exception {
+    String pattern = "yyyy-MM-ddTHH:mm:ss";
+    TypeAdapters.LocalDateTimeAdapter adapter = new TypeAdapters.LocalDateTimeAdapter();
+    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
+    LocalDateTime currentDate = LocalDateTime.now();
+
+    String dateString = adapter.toJson(currentDate);
+    assertEquals(toLiteral(currentDate.format(dateTimeFormatter)), dateString);
+  }
+
+  public void testNullValue() throws Exception {
+    TypeAdapters.LocalDateTimeAdapter adapter = new TypeAdapters.LocalDateTimeAdapter();
+    assertNull(adapter.fromJson("null"));
+    assertEquals("null", adapter.toJson(null));
+  }
+
+  public void testUnexpectedToken() throws Exception {
+    try {
+      TypeAdapters.LocalDateTimeAdapter adapter = new TypeAdapters.LocalDateTimeAdapter();
+      adapter.fromJson("{}");
+      fail("Unexpected token should fail.");
+    } catch (IllegalStateException expected) { }
+  }
+
+  public void testDateDeserializationISO8601() throws Exception {
+    TypeAdapters.LocalDateTimeAdapter adapter = new TypeAdapters.LocalDateTimeAdapter();
+    assertEquals("1969-12-31T06:00", LocalDateTime.ofEpochSecond(0,0, ZoneOffset.MIN),
+            adapter.fromJson(toLiteral("1969-12-31T06:00:00")));
+    assertEquals("1970-01-01T00:00:00", LocalDateTime.ofEpochSecond(0,0, ZoneOffset.UTC),
+            adapter.fromJson(toLiteral("1970-01-01T00:00:00")));
+    assertEquals("1970-01-01T18:00", LocalDateTime.ofEpochSecond(0,0, ZoneOffset.MAX),
+            adapter.fromJson(toLiteral("1970-01-01T18:00:00")));
+  }
+  
+  private static String toLiteral(String s) {
+    return '"' + s + '"';
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/LocalDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/LocalDateTypeAdapterTest.java
new file mode 100644
index 000000000..2a79d870a
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/LocalDateTypeAdapterTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import com.google.gson.internal.bind.TypeAdapters;
+import junit.framework.TestCase;
+
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+
+/**
+ * A basic unit test for the {@link TypeAdapters.LocalDateAdapter} class.
+ *
+ * @author Raihaan Cassim
+ */
+public class LocalDateTypeAdapterTest extends TestCase {
+
+
+  public void testDatePattern() throws Exception {
+    String pattern = "yyyy-MM-dd";
+    TypeAdapters.LocalDateAdapter adapter = new TypeAdapters.LocalDateAdapter();
+    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE;
+    LocalDate currentDate = LocalDate.now();
+
+    String dateString = adapter.toJson(currentDate);
+    assertEquals(toLiteral(currentDate.format(dateTimeFormatter)), dateString);
+  }
+
+  public void testNullValue() throws Exception {
+    TypeAdapters.LocalDateAdapter adapter = new TypeAdapters.LocalDateAdapter();
+    assertNull(adapter.fromJson("null"));
+    assertEquals("null", adapter.toJson(null));
+  }
+
+  public void testUnexpectedToken() throws Exception {
+    try {
+      TypeAdapters.LocalDateAdapter adapter = new TypeAdapters.LocalDateAdapter();
+      adapter.fromJson("{}");
+      fail("Unexpected token should fail.");
+    } catch (IllegalStateException expected) { }
+  }
+
+  public void testDateDeserializationISO8601() throws Exception {
+    TypeAdapters.LocalDateAdapter adapter = new TypeAdapters.LocalDateAdapter();
+    assertEquals("1970-01-01", LocalDate.ofEpochDay(0), adapter.fromJson(toLiteral("1970-01-01")));
+  }
+
+  private static String toLiteral(String s) {
+    return '"' + s + '"';
+  }
+}
