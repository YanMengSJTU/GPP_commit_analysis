diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
index 99ec679a7..dc092b9a9 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
@@ -156,46 +156,9 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
             }
 
             if (hasT) {
-
-                // extract hours, minutes, seconds and milliseconds
-                hour = parseInt(date, offset += 1, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-
-                minutes = parseInt(date, offset, offset += 2);
-                if (checkOffset(date, offset, ':')) {
-                    offset += 1;
-                }
-                // second and milliseconds can be optional
-                if (date.length() > offset) {
-                    char c = date.charAt(offset);
-                    if (c != 'Z' && c != '+' && c != '-') {
-                        seconds = parseInt(date, offset, offset += 2);
-                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
-                        // milliseconds can be optional in the format
-                        if (checkOffset(date, offset, '.')) {
-                            offset += 1;
-                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
-                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
-                            int fraction = parseInt(date, offset, parseEndOffset);
-                            // compensate for "missing" digits
-                            switch (parseEndOffset - offset) { // number of digits parsed
-                            case 2:
-                                milliseconds = fraction * 10;
-                                break;
-                            case 1:
-                                milliseconds = fraction * 100;
-                                break;
-                            default:
-                                milliseconds = fraction;
-                            }
-                            offset = endOffset;
-                        }
-                    }
-                }
+                extatHours();
             }
-
+           
             // extract timezone
             if (date.length() <= offset) {
                 throw new IllegalArgumentException("No time zone indicator");
@@ -348,5 +311,47 @@ private static int indexOfNonDigit(String string, int offset) {
         }
         return string.length();
     }
+    
+     private void extatHours(){
+                
+                // extract hours, minutes, seconds and milliseconds
+                hour = parseInt(date, offset += 1, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+
+                minutes = parseInt(date, offset, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+                // second and milliseconds can be optional
+                if (date.length() > offset) {
+                    char c = date.charAt(offset);
+                    if (c != 'Z' && c != '+' && c != '-') {
+                        seconds = parseInt(date, offset, offset += 2);
+                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
+                        // milliseconds can be optional in the format
+                        if (checkOffset(date, offset, '.')) {
+                            offset += 1;
+                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
+                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
+                            int fraction = parseInt(date, offset, parseEndOffset);
+                            // compensate for "missing" digits
+                            switch (parseEndOffset - offset) { // number of digits parsed
+                            case 2:
+                                milliseconds = fraction * 10;
+                                break;
+                            case 1:
+                                milliseconds = fraction * 100;
+                                break;
+                            default:
+                                milliseconds = fraction;
+                            }
+                            offset = endOffset;
+                        }
+                    }
+                }
+            }
+
 
 }
