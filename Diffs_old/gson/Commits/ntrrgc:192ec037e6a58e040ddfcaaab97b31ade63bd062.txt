diff --git a/gson/src/main/java/com/google/gson/DummyNullableChecker.java b/gson/src/main/java/com/google/gson/DummyNullableChecker.java
new file mode 100644
index 000000000..f1c3b02c5
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/DummyNullableChecker.java
@@ -0,0 +1,23 @@
+package com.google.gson;
+
+import java.lang.reflect.Field;
+
+/**
+ * Dummy NullableChecker that does not check anything.
+ */
+class DummyNullableChecker {
+  private static NullableChecker nullableChecker = null;
+
+  static NullableChecker getInstance() {
+    if (nullableChecker == null) {
+      nullableChecker = new NullableChecker() {
+        @Override
+        public boolean fieldIsNullable(Field field) {
+          return true;
+        }
+      };
+    }
+
+    return nullableChecker;
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index e97b16279..055eabdbd 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -16,46 +16,26 @@
 
 package com.google.gson;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.lang.reflect.Type;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicLongArray;
-
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
 import com.google.gson.internal.Streams;
-import com.google.gson.internal.bind.ArrayTypeAdapter;
-import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
-import com.google.gson.internal.bind.DateTypeAdapter;
-import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
-import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.internal.bind.JsonTreeWriter;
-import com.google.gson.internal.bind.MapTypeAdapterFactory;
-import com.google.gson.internal.bind.ObjectTypeAdapter;
-import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
-import com.google.gson.internal.bind.SqlDateTypeAdapter;
-import com.google.gson.internal.bind.TimeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
+import com.google.gson.internal.bind.*;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
 
+import java.io.*;
+import java.lang.reflect.Type;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
  * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}
@@ -134,6 +114,7 @@
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
   private final boolean lenient;
+  private final NullableChecker nullableChecker;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   /**
@@ -175,7 +156,8 @@ public Gson() {
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList(),
+        DummyNullableChecker.getInstance());
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
@@ -183,7 +165,8 @@ public Gson() {
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
+      List<TypeAdapterFactory> typeAdapterFactories,
+      NullableChecker nullableChecker) {
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
@@ -192,6 +175,7 @@ public Gson() {
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.nullableChecker = nullableChecker;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -250,7 +234,8 @@ public Gson() {
     factories.add(jsonAdapterFactory);
     factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(new ReflectiveTypeAdapterFactory(
-        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory,
+      nullableChecker));
 
     this.factories = Collections.unmodifiableList(factories);
   }
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 0c917d46f..3527bf279 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,30 +16,19 @@
 
 package com.google.gson;
 
-import com.google.gson.stream.JsonReader;
-import java.lang.reflect.Type;
-import java.sql.Timestamp;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
 
-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
-import static com.google.gson.Gson.DEFAULT_LENIENT;
-import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+import java.lang.reflect.Type;
+import java.sql.Timestamp;
+import java.text.DateFormat;
+import java.util.*;
+
+import static com.google.gson.Gson.*;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -94,6 +83,7 @@
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
   private boolean lenient = DEFAULT_LENIENT;
+  private NullableChecker nullableChecker = DummyNullableChecker.getInstance();
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -553,6 +543,18 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
     return this;
   }
 
+  /**
+   * Enables a custom nullable checker that can use reflection to ensure fields annotated as not
+   * null never receive null values.
+   *
+   * @param nullableChecker A concrete nullableChecker. Gson does not provide any by default.
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   */
+  public GsonBuilder setNullableChecker(NullableChecker nullableChecker) {
+    this.nullableChecker = nullableChecker;
+    return this;
+  }
+
   /**
    * Creates a {@link Gson} instance based on the current configuration. This method is free of
    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
@@ -569,7 +571,8 @@ public Gson create() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        serializeSpecialFloatingPointValues, longSerializationPolicy, factories,
+      nullableChecker);
   }
 
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
diff --git a/gson/src/main/java/com/google/gson/NullableChecker.java b/gson/src/main/java/com/google/gson/NullableChecker.java
new file mode 100644
index 000000000..69b8a014b
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/NullableChecker.java
@@ -0,0 +1,23 @@
+package com.google.gson;
+
+import java.lang.reflect.Field;
+
+/**
+ * This interface is used to check if a field supports null values.
+ *
+ * The implementor is expected to search for custom annotations in fields.
+ * For instance, the following example uses the
+ * {@code javax.validation.constraints.NotNull annotation}:
+ *
+ * <pre>{@code
+ * class AnnotationNullableChecker implements NullableChecker {
+ *   public boolean fieldIsNullable(Field field) {
+ *     return field.getAnnotation(javax.validation.constraints.NotNull.class)
+ *       != null;
+ *   }
+ * }
+ * }</pre>
+ */
+public interface NullableChecker {
+  boolean fieldIsNullable(Field field);
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 34e97664e..ade46560f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -16,11 +16,7 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.FieldNamingStrategy;
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
+import com.google.gson.*;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.annotations.SerializedName;
 import com.google.gson.internal.$Gson$Types;
@@ -49,14 +45,19 @@
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final NullableChecker nullableChecker;
 
-  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
+  public ReflectiveTypeAdapterFactory(
+      ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
-      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory,
+      NullableChecker nullableChecker)
+  {
     this.constructorConstructor = constructorConstructor;
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.excluder = excluder;
     this.jsonAdapterFactory = jsonAdapterFactory;
+    this.nullableChecker = nullableChecker;
   }
 
   public boolean excludeField(Field f, boolean serialize) {
@@ -102,7 +103,8 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 
   private ReflectiveTypeAdapterFactory.BoundField createBoundField(
       final Gson context, final Field field, final String name,
-      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
+      final TypeToken<?> fieldType, boolean serialize, boolean deserialize,
+      boolean nullable) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
@@ -115,7 +117,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     if (mapped == null) mapped = context.getAdapter(fieldType);
 
     final TypeAdapter<?> typeAdapter = mapped;
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize, nullable) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
@@ -127,6 +129,9 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       @Override void read(JsonReader reader, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
+        if (fieldValue == null && !nullable) {
+          throw new JsonSyntaxException("Non-nullable field was read as null: " + name);
+        }
         if (fieldValue != null || !isPrimitive) {
           field.set(value, fieldValue);
         }
@@ -134,6 +139,9 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
         if (!serialized) return false;
         Object fieldValue = field.get(value);
+        if (fieldValue == null && !nullable) {
+          throw new JsonSyntaxException("Non-nullable field was requested to be written as null: " + name);
+        }
         return fieldValue != value; // avoid recursion for example for Throwable.cause
       }
     };
@@ -151,6 +159,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       for (Field field : fields) {
         boolean serialize = excludeField(field, true);
         boolean deserialize = excludeField(field, false);
+        boolean nullable = nullableChecker.fieldIsNullable(field);
         if (!serialize && !deserialize) {
           continue;
         }
@@ -162,7 +171,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
           String name = fieldNames.get(i);
           if (i != 0) serialize = false; // only serialize the default name
           BoundField boundField = createBoundField(context, field, name,
-              TypeToken.get(fieldType), serialize, deserialize);
+              TypeToken.get(fieldType), serialize, deserialize, nullable);
           BoundField replaced = result.put(name, boundField);
           if (previous == null) previous = replaced;
         }
@@ -181,11 +190,13 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     final String name;
     final boolean serialized;
     final boolean deserialized;
+    final boolean nullable;
 
-    protected BoundField(String name, boolean serialized, boolean deserialized) {
+    protected BoundField(String name, boolean serialized, boolean deserialized, boolean nullable) {
       this.name = name;
       this.serialized = serialized;
       this.deserialized = deserialized;
+      this.nullable = nullable;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
