diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index e97b16279..d70d90b7e 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -119,8 +119,8 @@
    * lookup would stack overflow. We cheat by returning a proxy type adapter.
    * The proxy is wired up once the initial adapter has been created.
    */
-  private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls
-      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();
+  private final ThreadLocal<Map<TypeToken<?>, TypeAdapter<?>>> calls
+      = new ThreadLocal<Map<TypeToken<?>, TypeAdapter<?>>>();
 
   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
 
@@ -401,37 +401,41 @@ static void checkValidFloatingPoint(double value) {
       return (TypeAdapter<T>) cached;
     }
 
-    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();
-    boolean requiresThreadLocalCleanup = false;
+    Map<TypeToken<?>, TypeAdapter<?>> threadCalls = calls.get();
+    boolean firstThreadLocal = false;
     if (threadCalls == null) {
-      threadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();
+      threadCalls = new HashMap<TypeToken<?>, TypeAdapter<?>>();
       calls.set(threadCalls);
-      requiresThreadLocalCleanup = true;
+      firstThreadLocal = true;
     }
 
     // the key and value type parameters always agree
-    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);
+    TypeAdapter<T> ongoingCall = (TypeAdapter<T>) threadCalls.get(type);
     if (ongoingCall != null) {
       return ongoingCall;
     }
 
     try {
-      FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();
-      threadCalls.put(type, call);
+      FutureTypeAdapter<T> futureTypeAdapter = new FutureTypeAdapter<T>();
+      threadCalls.put(type, futureTypeAdapter);
 
       for (TypeAdapterFactory factory : factories) {
         TypeAdapter<T> candidate = factory.create(this, type);
         if (candidate != null) {
-          call.setDelegate(candidate);
-          typeTokenCache.put(type, candidate);
+          // overwrite future type adapter with real type adapter
+          threadCalls.put(type, candidate);
+          // set delegate on future type adapter so that any type adapter that
+          // refers to it will be able to use this candidate through delegation
+          futureTypeAdapter.setDelegate(candidate);
           return candidate;
         }
       }
       throw new IllegalArgumentException("GSON cannot handle " + type);
     } finally {
-      threadCalls.remove(type);
-
-      if (requiresThreadLocalCleanup) {
+      if (firstThreadLocal) {
+        // move thread local type adapters to cache on instance
+        typeTokenCache.putAll(threadCalls);
+        // clear thread local
         calls.remove();
       }
     }
diff --git a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
index 2dccf4b61..a77301ee1 100755
--- a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
@@ -19,6 +19,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 import junit.framework.TestCase;
 
@@ -120,6 +121,42 @@ public void run() {
     finishedLatch.await();
     assertFalse(failed.get());
   }
+
+  /**
+   * Test for:
+   * https://github.com/google/gson/issues/764
+   */
+  public void testMultiThreadRecursiveObjectSerialization() throws InterruptedException {
+    final int threads = 4;
+    final ExecutorService executor = Executors.newFixedThreadPool(threads);
+    final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+
+    for (int i = 0; i < 1000; i++) {
+      final CountDownLatch startLatch = new CountDownLatch(1);
+      final CountDownLatch finishedLatch = new CountDownLatch(threads);
+      final Gson gson = new Gson();
+      final MyRecursiveObject obj = new MyRecursiveObject();
+
+      for (int j = 0; j < threads; j++) {
+        executor.execute(new Runnable() {
+          public void run() {
+            try {
+              startLatch.await();
+              gson.toJson(obj);
+            } catch (Throwable t) {
+              throwable.set(t);
+            } finally {
+              finishedLatch.countDown();
+            }
+          }
+        });
+      }
+
+      startLatch.countDown();
+      finishedLatch.await();
+      assertNull(throwable.get());
+    }
+  }
   
   @SuppressWarnings("unused")
   private static class MyObject {
@@ -137,4 +174,33 @@ public MyObject(String a, String b, int i) {
       this.i = i;
     }
   }
+
+  private static class MyRecursiveObject {
+    MyNestedObject obj;
+
+    MyRecursiveObject() {
+      this(true);
+    }
+
+    MyRecursiveObject(boolean init) {
+      if (init) {
+        this.obj = new MyNestedObject();
+      }
+    }
+
+    private static class MyNestedObject {
+      MyRecursiveObject obj;
+
+      MyNestedObject() {
+        this(true);
+      }
+
+      MyNestedObject(boolean init) {
+        if (init) {
+          this.obj = new MyRecursiveObject(false);
+        }
+      }
+    }
+  }
+
 }
