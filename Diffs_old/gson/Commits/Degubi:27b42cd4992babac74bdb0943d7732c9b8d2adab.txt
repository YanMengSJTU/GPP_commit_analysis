diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index c25329466..2579862c5 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -106,7 +106,6 @@
 	final String datePattern;
 	final int dateStyle;
 	final int timeStyle;
-	final LongSerializationPolicy longSerializationPolicy;
 	final List<TypeAdapterFactory> builderFactories;
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
@@ -114,7 +113,7 @@
 			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
 			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
 			boolean prettyPrinting,
-			LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
+			String datePattern, int dateStyle,
 			int timeStyle, List<TypeAdapterFactory> builderFactories,
 			List<TypeAdapterFactory> builderHierarchyFactories,
 			List<TypeAdapterFactory> factoriesToBeAdded) {
@@ -126,7 +125,6 @@
 		this.generateNonExecutableJson = generateNonExecutableGson;
 		this.htmlSafe = htmlSafe;
 		this.prettyPrinting = prettyPrinting;
-		this.longSerializationPolicy = longSerializationPolicy;
 		this.datePattern = datePattern;
 		this.dateStyle = dateStyle;
 		this.timeStyle = timeStyle;
@@ -151,7 +149,7 @@
 		factories.add(TypeAdapters.BOOLEAN_FACTORY);
 		factories.add(TypeAdapters.BYTE_FACTORY);
 		factories.add(TypeAdapters.SHORT_FACTORY);
-		TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);
+		TypeAdapter<Number> longAdapter = TypeAdapters.LONG;
 		factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));
 		factories.add(TypeAdapters.newFactory(double.class, Double.class,
 				TypeAdapters.DOUBLE));
@@ -175,11 +173,11 @@
 		factories.add(TypeAdapters.LOCALE_FACTORY);
 		factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
 		factories.add(TypeAdapters.BIT_SET_FACTORY);
-		factories.add(DateTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.TIMESTAMP_FACTORY);
 		factories.add(ArrayTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.CLASS_FACTORY);
 		factories.add(LocalTimeAdapter.factory);
+		factories.add(LocalDateTimeAdapter.factory);
 		factories.add(InstantTypeAdapter.factory);
 
 		// type adapters for composite and user-defined types
@@ -283,28 +281,6 @@ public boolean htmlSafe() {
 		return htmlSafe;
 	}
 
-	private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {
-		if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {
-			return TypeAdapters.LONG;
-		}
-		return new TypeAdapter<>() {
-			@Override public Number read(JsonReader in) throws IOException {
-				if (in.peek() == JsonToken.NULL) {
-					in.nextNull();
-					return null;
-				}
-				return in.nextLong();
-			}
-			@Override public void write(JsonWriter out, Number value) throws IOException {
-				if (value == null) {
-					out.nullValue();
-					return;
-				}
-				out.value(value.toString());
-			}
-		};
-	}
-
 	private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
 		return new TypeAdapter<AtomicLong>() {
 			@Override public void write(JsonWriter out, AtomicLong value) throws IOException {
@@ -574,7 +550,7 @@ public String toJson(Object src, Type typeOfSrc) {
 	 * @throws JsonIOException if there was a problem writing to the writer
 	 * @since 1.2
 	 */
-	public void toJson(Object src, Appendable writer) throws JsonIOException {
+	public void toJson(Object src, Writer writer) throws JsonIOException {
 		if (src != null) {
 			toJson(src, src.getClass(), writer);
 		} else {
@@ -598,9 +574,9 @@ public void toJson(Object src, Appendable writer) throws JsonIOException {
 	 * @throws JsonIOException if there was a problem writing to the writer
 	 * @since 1.2
 	 */
-	public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {
+	public void toJson(Object src, Type typeOfSrc, Writer writer) throws JsonIOException {
 		try {
-			JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
+			JsonWriter jsonWriter = newJsonWriter(writer);
 			toJson(src, typeOfSrc, jsonWriter);
 		} catch (IOException e) {
 			throw new JsonIOException(e);
@@ -656,9 +632,9 @@ public String toJson(JsonElement jsonElement) {
 	 * @throws JsonIOException if there was a problem writing to the writer
 	 * @since 1.4
 	 */
-	public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {
+	public void toJson(JsonElement jsonElement, Writer writer) throws JsonIOException {
 		try {
-			JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
+			JsonWriter jsonWriter = newJsonWriter(writer);
 			toJson(jsonElement, jsonWriter);
 		} catch (IOException e) {
 			throw new JsonIOException(e);
@@ -700,7 +676,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
 		boolean oldSerializeNulls = writer.getSerializeNulls();
 		writer.setSerializeNulls(serializeNulls);
 		try {
-			Streams.write(jsonElement, writer);
+			TypeAdapters.JSON_ELEMENT.write(writer, jsonElement);
 		} catch (IOException e) {
 			throw new JsonIOException(e);
 		} catch (AssertionError e) {
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 627ed5667..b9d716ab0 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -63,7 +63,6 @@
  */
 public final class GsonBuilder {
   private Excluder excluder = Excluder.DEFAULT;
-  private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;
   private FieldNamingStrategy fieldNamingPolicy = FieldNamingStrategy.IDENTITY;
   private final Map<Type, InstanceCreator<?>> instanceCreators
       = new HashMap<>();
@@ -102,7 +101,6 @@
     this.generateNonExecutableJson = gson.generateNonExecutableJson;
     this.escapeHtmlChars = gson.htmlSafe;
     this.prettyPrinting = gson.prettyPrinting;
-    this.longSerializationPolicy = gson.longSerializationPolicy;
     this.datePattern = gson.datePattern;
     this.dateStyle = gson.dateStyle;
     this.timeStyle = gson.timeStyle;
@@ -267,19 +265,6 @@ public GsonBuilder disableInnerClassSerialization() {
     return this;
   }
 
-  /**
-   * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}
-   * objects.
-   *
-   * @param serializationPolicy the particular policy to use for serializing longs.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {
-    this.longSerializationPolicy = serializationPolicy;
-    return this;
-  }
-
   /**
    * Configures Gson to apply a specific naming policy strategy to an object's field during
    * serialization and deserialization.
@@ -527,7 +512,6 @@ public Gson build() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
-        longSerializationPolicy,
         datePattern, dateStyle, timeStyle,
         this.factories, this.hierarchyFactories, factories);
   }
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index ead3e100a..9dd16f539 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.internal.*;
+import com.google.gson.internal.bind.*;
 import com.google.gson.stream.*;
 import java.io.*;
 import java.math.BigDecimal;
@@ -357,7 +358,7 @@ public String toString() {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
 			jsonWriter.setLenient(true);
-			Streams.write(this, jsonWriter);
+			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
 			throw new AssertionError(e);
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index cc2138cad..6bf6af6b3 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.internal.*;
+import com.google.gson.internal.bind.*;
 import com.google.gson.stream.*;
 import java.io.*;
 import java.util.Map;
@@ -201,7 +202,7 @@ public String toString() {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
 			jsonWriter.setLenient(true);
-			Streams.write(this, jsonWriter);
+			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
 			throw new AssertionError(e);
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index 35b5e610e..d74665b89 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.internal.*;
+import com.google.gson.internal.bind.*;
 import com.google.gson.stream.*;
 import java.io.*;
 import java.math.BigDecimal;
@@ -243,7 +244,7 @@ public String toString() {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
 			jsonWriter.setLenient(true);
-			Streams.write(this, jsonWriter);
+			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
 			throw new AssertionError(e);
diff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
deleted file mode 100644
index 11db0a748..000000000
--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-/**
- * Defines the expected format for a {@code long} or {@code Long} type when its serialized.
- *
- * @since 1.3
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public enum LongSerializationPolicy {
-	/**
-	 * This is the "default" serialization policy that will output a {@code long} object as a JSON
-	 * number. For example, assume an object has a long field named "f" then the serialized output
-	 * would be:
-	 * {@code {"f":123}}.
-	 */
-	DEFAULT() {
-		@Override public JsonElement serialize(Long value) {
-			return new JsonPrimitive(value);
-		}
-	},
-
-	/**
-	 * Serializes a long value as a quoted string. For example, assume an object has a long field 
-	 * named "f" then the serialized output would be:
-	 * {@code {"f":"123"}}.
-	 */
-	STRING() {
-		@Override public JsonElement serialize(Long value) {
-			return new JsonPrimitive(String.valueOf(value));
-		}
-	};
-
-	/**
-	 * Serialize this {@code value} using this serialization policy.
-	 *
-	 * @param value the long value to be serialized into a {@link JsonElement}
-	 * @return the serialized version of {@code value}
-	 */
-	public abstract JsonElement serialize(Long value);
-}
diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java
index ac99910a9..71360c6fe 100644
--- a/gson/src/main/java/com/google/gson/internal/Streams.java
+++ b/gson/src/main/java/com/google/gson/internal/Streams.java
@@ -16,45 +16,23 @@
 
 package com.google.gson.internal;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import com.google.gson.stream.MalformedJsonException;
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.Writer;
+import com.google.gson.*;
+import com.google.gson.internal.bind.*;
+import com.google.gson.stream.*;
+import java.io.*;
 
 /**
  * Reads and writes GSON parse trees over streams.
  */
 public final class Streams {
-  private Streams() {
-    throw new UnsupportedOperationException();
-  }
 
   /**
    * Takes a reader in any state and returns the next value as a JsonElement.
    */
   public static JsonElement parse(JsonReader reader) throws JsonParseException {
-    boolean isEmpty = true;
     try {
-      reader.peek();
-      isEmpty = false;
       return TypeAdapters.JSON_ELEMENT.read(reader);
     } catch (EOFException e) {
-      /*
-       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for
-       * empty documents instead of throwing.
-       */
-      if (isEmpty) {
-        return JsonNull.INSTANCE;
-      }
-      // The stream ended prematurely so it is likely a syntax error.
       throw new JsonSyntaxException(e);
     } catch (MalformedJsonException e) {
       throw new JsonSyntaxException(e);
@@ -64,57 +42,4 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
       throw new JsonSyntaxException(e);
     }
   }
-
-  /**
-   * Writes the JSON element to the writer, recursively.
-   */
-  public static void write(JsonElement element, JsonWriter writer) throws IOException {
-    TypeAdapters.JSON_ELEMENT.write(writer, element);
-  }
-
-  public static Writer writerForAppendable(Appendable appendable) {
-    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
-  }
-
-  /**
-   * Adapts an {@link Appendable} so it can be passed anywhere a {@link Writer}
-   * is used.
-   */
-  private static final class AppendableWriter extends Writer {
-    private final Appendable appendable;
-    private final CurrentWrite currentWrite = new CurrentWrite();
-
-    AppendableWriter(Appendable appendable) {
-      this.appendable = appendable;
-    }
-
-    @Override public void write(char[] chars, int offset, int length) throws IOException {
-      currentWrite.chars = chars;
-      appendable.append(currentWrite, offset, offset + length);
-    }
-
-    @Override public void write(int i) throws IOException {
-      appendable.append((char) i);
-    }
-
-    @Override public void flush() {}
-    @Override public void close() {}
-
-    /**
-     * A mutable char sequence pointing at a single char[].
-     */
-    static class CurrentWrite implements CharSequence {
-      char[] chars;
-      public int length() {
-        return chars.length;
-      }
-      public char charAt(int i) {
-        return chars[i];
-      }
-      public CharSequence subSequence(int start, int end) {
-        return new String(chars, start, end - start);
-      }
-    }
-  }
-
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
deleted file mode 100644
index 6e849690e..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal.bind;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.JavaVersion;
-import com.google.gson.internal.PreJava9DateFormatProvider;
-import com.google.gson.internal.bind.util.ISO8601Utils;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-
-import java.io.IOException;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.ParsePosition;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-
-/**
- * Adapter for Date. Although this class appears stateless, it is not.
- * DateFormat captures its time zone and locale when it is created, which gives
- * this class state. DateFormat isn't thread safe either, so this class has
- * to synchronize its read and write methods.
- */
-public final class DateTypeAdapter extends TypeAdapter<Date> {
-  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-      return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;
-    }
-  };
-
-  /**
-   * List of 1 or more different date formats used for de-serialization attempts.
-   * The first of them (default US format) is used for serialization as well.
-   */
-  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
-
-  public DateTypeAdapter() {
-    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
-    if (!Locale.getDefault().equals(Locale.US)) {
-      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
-    }
-    if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
-    }
-  }
-
-  @Override public Date read(JsonReader in) throws IOException {
-    if (in.peek() == JsonToken.NULL) {
-      in.nextNull();
-      return null;
-    }
-    return deserializeToDate(in.nextString());
-  }
-
-  private synchronized Date deserializeToDate(String json) {
-    for (DateFormat dateFormat : dateFormats) {
-      try {
-        return dateFormat.parse(json);
-      } catch (ParseException ignored) {}
-    }
-    try {
-    	return ISO8601Utils.parse(json, new ParsePosition(0));
-    } catch (ParseException e) {
-      throw new JsonSyntaxException(json, e);
-    }
-  }
-
-  @Override public synchronized void write(JsonWriter out, Date value) throws IOException {
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-    String dateFormatAsString = dateFormats.get(0).format(value);
-    out.value(dateFormatAsString);
-  }
-  
-  
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
new file mode 100644
index 000000000..bb557eff8
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
@@ -0,0 +1,35 @@
+package com.google.gson.internal.bind;
+
+import com.google.gson.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.time.*;
+
+public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime>{
+
+	public static final TypeAdapterFactory factory = new TypeAdapterFactory() {
+		@Override
+		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+			return type.getRawType() == LocalDateTime.class ? (TypeAdapter<T>) new LocalDateTimeAdapter() : null;
+		}
+	};
+	
+	@Override
+	public void write(JsonWriter out, LocalDateTime value) throws IOException {
+		if(value == null) {
+			out.nullValue();
+		}else{
+			out.value(value.toString());
+		}
+	}
+
+	@Override
+	public LocalDateTime read(JsonReader in) throws IOException {
+		if (in.peek() == JsonToken.NULL) {
+			in.nextNull();
+			return null;
+		}
+		return LocalDateTime.parse(in.nextString());
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 985882955..a9fe1ee50 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -214,7 +214,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 				out.beginArray();
 				for (int i = 0, size = keys.size(); i < size; i++) {
 					out.beginArray(); // entry array
-					Streams.write(keys.get(i), out);
+					TypeAdapters.JSON_ELEMENT.write(out, keys.get(i));
 					valueTypeAdapter.write(out, values.get(i));
 					out.endArray();
 				}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index a5c6c5dcd..befe9b7b9 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -39,127 +39,127 @@
  * has a facility to lookup a delegate type adapter on demand.
  */
 public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
-  private final JsonSerializer<T> serializer;
-  private final JsonDeserializer<T> deserializer;
-  final Gson gson;
-  private final TypeToken<T> typeToken;
-  private final TypeAdapterFactory skipPast;
-  private final GsonContextImpl context = new GsonContextImpl();
+	private final JsonSerializer<T> serializer;
+	private final JsonDeserializer<T> deserializer;
+	final Gson gson;
+	private final TypeToken<T> typeToken;
+	private final TypeAdapterFactory skipPast;
+	private final GsonContextImpl context = new GsonContextImpl();
 
-  /** The delegate is lazily created because it may not be needed, and creating it may fail. */
-  private TypeAdapter<T> delegate;
+	/** The delegate is lazily created because it may not be needed, and creating it may fail. */
+	private TypeAdapter<T> delegate;
 
-  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
-      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
-    this.serializer = serializer;
-    this.deserializer = deserializer;
-    this.gson = gson;
-    this.typeToken = typeToken;
-    this.skipPast = skipPast;
-  }
+	public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
+			Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
+		this.serializer = serializer;
+		this.deserializer = deserializer;
+		this.gson = gson;
+		this.typeToken = typeToken;
+		this.skipPast = skipPast;
+	}
 
-  @Override public T read(JsonReader in) throws IOException {
-    if (deserializer == null) {
-      return delegate().read(in);
-    }
-    JsonElement value = Streams.parse(in);
-    if (value.isJsonNull()) {
-      return null;
-    }
-    return deserializer.deserialize(value, typeToken.getType(), context);
-  }
+	@Override public T read(JsonReader in) throws IOException {
+		if (deserializer == null) {
+			return delegate().read(in);
+		}
+		JsonElement value = Streams.parse(in);
+		if (value.isJsonNull()) {
+			return null;
+		}
+		return deserializer.deserialize(value, typeToken.getType(), context);
+	}
 
-  @Override public void write(JsonWriter out, T value) throws IOException {
-    if (serializer == null) {
-      delegate().write(out, value);
-      return;
-    }
-    if (value == null) {
-      out.nullValue();
-      return;
-    }
-    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);
-    Streams.write(tree, out);
-  }
+	@Override public void write(JsonWriter out, T value) throws IOException {
+		if (serializer == null) {
+			delegate().write(out, value);
+			return;
+		}
+		if (value == null) {
+			out.nullValue();
+			return;
+		}
+		JsonElement tree = serializer.serialize(value, typeToken.getType(), context);
+		TypeAdapters.JSON_ELEMENT.write(out, tree);
+	}
 
-  private TypeAdapter<T> delegate() {
-    TypeAdapter<T> d = delegate;
-    return d != null
-        ? d
-        : (delegate = gson.getDelegateAdapter(skipPast, typeToken));
-  }
+	private TypeAdapter<T> delegate() {
+		TypeAdapter<T> d = delegate;
+		return d != null
+				? d
+						: (delegate = gson.getDelegateAdapter(skipPast, typeToken));
+	}
 
-  /**
-   * Returns a new factory that will match each type against {@code exactType}.
-   */
-  public static TypeAdapterFactory newFactory(TypeToken<?> exactType, Object typeAdapter) {
-    return new SingleTypeFactory(typeAdapter, exactType, false, null);
-  }
+	/**
+	 * Returns a new factory that will match each type against {@code exactType}.
+	 */
+	public static TypeAdapterFactory newFactory(TypeToken<?> exactType, Object typeAdapter) {
+		return new SingleTypeFactory(typeAdapter, exactType, false, null);
+	}
 
-  /**
-   * Returns a new factory that will match each type and its raw type against
-   * {@code exactType}.
-   */
-  public static TypeAdapterFactory newFactoryWithMatchRawType(
-      TypeToken<?> exactType, Object typeAdapter) {
-    // only bother matching raw types if exact type is a raw type
-    boolean matchRawType = exactType.getType() == exactType.getRawType();
-    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);
-  }
+	/**
+	 * Returns a new factory that will match each type and its raw type against
+	 * {@code exactType}.
+	 */
+	public static TypeAdapterFactory newFactoryWithMatchRawType(
+			TypeToken<?> exactType, Object typeAdapter) {
+		// only bother matching raw types if exact type is a raw type
+		boolean matchRawType = exactType.getType() == exactType.getRawType();
+		return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);
+	}
 
-  /**
-   * Returns a new factory that will match each type's raw type for assignability
-   * to {@code hierarchyType}.
-   */
-  public static TypeAdapterFactory newTypeHierarchyFactory(
-      Class<?> hierarchyType, Object typeAdapter) {
-    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);
-  }
+	/**
+	 * Returns a new factory that will match each type's raw type for assignability
+	 * to {@code hierarchyType}.
+	 */
+	public static TypeAdapterFactory newTypeHierarchyFactory(
+			Class<?> hierarchyType, Object typeAdapter) {
+		return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);
+	}
 
-  private static final class SingleTypeFactory implements TypeAdapterFactory {
-    private final TypeToken<?> exactType;
-    private final boolean matchRawType;
-    private final Class<?> hierarchyType;
-    private final JsonSerializer<?> serializer;
-    private final JsonDeserializer<?> deserializer;
+	private static final class SingleTypeFactory implements TypeAdapterFactory {
+		private final TypeToken<?> exactType;
+		private final boolean matchRawType;
+		private final Class<?> hierarchyType;
+		private final JsonSerializer<?> serializer;
+		private final JsonDeserializer<?> deserializer;
 
-    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
-        Class<?> hierarchyType) {
-      serializer = typeAdapter instanceof JsonSerializer
-          ? (JsonSerializer<?>) typeAdapter
-          : null;
-      deserializer = typeAdapter instanceof JsonDeserializer
-          ? (JsonDeserializer<?>) typeAdapter
-          : null;
-      $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);
-      this.exactType = exactType;
-      this.matchRawType = matchRawType;
-      this.hierarchyType = hierarchyType;
-    }
+		SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
+				Class<?> hierarchyType) {
+			serializer = typeAdapter instanceof JsonSerializer
+					? (JsonSerializer<?>) typeAdapter
+							: null;
+					deserializer = typeAdapter instanceof JsonDeserializer
+							? (JsonDeserializer<?>) typeAdapter
+									: null;
+							$Gson$Preconditions.checkArgument(serializer != null || deserializer != null);
+							this.exactType = exactType;
+							this.matchRawType = matchRawType;
+							this.hierarchyType = hierarchyType;
+		}
 
-    @SuppressWarnings("unchecked") // guarded by typeToken.equals() call
-    @Override
-    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-      boolean matches = exactType != null
-          ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()
-          : hierarchyType.isAssignableFrom(type.getRawType());
-      return matches
-          ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,
-              (JsonDeserializer<T>) deserializer, gson, type, this)
-          : null;
-    }
-  }
+		@SuppressWarnings("unchecked") // guarded by typeToken.equals() call
+		@Override
+		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+			boolean matches = exactType != null
+					? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()
+					: hierarchyType.isAssignableFrom(type.getRawType());
+					return matches
+							? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,
+									(JsonDeserializer<T>) deserializer, gson, type, this)
+									: null;
+		}
+	}
 
-  private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
-    @Override public JsonElement serialize(Object src) {
-      return gson.toJsonTree(src);
-    }
-    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
-      return gson.toJsonTree(src, typeOfSrc);
-    }
-    @SuppressWarnings("unchecked")
-    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-      return (R) gson.fromJson(json, typeOfT);
-    }
-  };
+	private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
+		@Override public JsonElement serialize(Object src) {
+			return gson.toJsonTree(src);
+		}
+		@Override public JsonElement serialize(Object src, Type typeOfSrc) {
+			return gson.toJsonTree(src, typeOfSrc);
+		}
+		@SuppressWarnings("unchecked")
+		@Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
+			return (R) gson.fromJson(json, typeOfT);
+		}
+	};
 }
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index fa2711a00..94de28ed2 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -47,7 +47,7 @@
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        true, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
@@ -60,7 +60,7 @@ public void testOverridesDefaultExcluder() {
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        true, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
diff --git a/gson/src/test/java/com/google/gson/JsonParserTest.java b/gson/src/test/java/com/google/gson/JsonParserTest.java
index 5ae56d2b1..c7355c709 100644
--- a/gson/src/test/java/com/google/gson/JsonParserTest.java
+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java
@@ -62,11 +62,6 @@ public void testParseEmptyString() {
     assertEquals("   ", e.getAsString());
   }
 
-  public void testParseEmptyWhitespaceInput() {
-    JsonElement e = Gson.parseString("     ");
-    assertTrue(e.isJsonNull());
-  }
-
   public void testParseUnquotedSingleWordStringFails() {
     assertEquals("Test", Gson.parseString("Test").getAsString());
   }
diff --git a/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java b/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java
deleted file mode 100644
index a0de28063..000000000
--- a/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2009 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson;
-
-import junit.framework.TestCase;
-
-/**
- * Unit test for the {@link LongSerializationPolicy} class.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public class LongSerializationPolicyTest extends TestCase {
-
-  public void testDefaultLongSerialization() throws Exception {
-    JsonElement element = LongSerializationPolicy.DEFAULT.serialize(1556L);
-    assertTrue(element.isJsonPrimitive());
-    
-    JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();
-    assertFalse(jsonPrimitive.isString());
-    assertTrue(jsonPrimitive.isNumber());
-    assertEquals(1556L, element.getAsLong());
-  }
-  
-  public void testDefaultLongSerializationIntegration() {
-    Gson gson = Gson.newBuilder()
-        .setLongSerializationPolicy(LongSerializationPolicy.DEFAULT)
-        .build();
-    assertEquals("[1]", gson.toJson(new long[] { 1L }, long[].class));
-    assertEquals("[1]", gson.toJson(new Long[] { 1L }, Long[].class));
-  }
-
-  public void testStringLongSerialization() throws Exception {
-    JsonElement element = LongSerializationPolicy.STRING.serialize(1556L);
-    assertTrue(element.isJsonPrimitive());
-
-    JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();
-    assertFalse(jsonPrimitive.isNumber());
-    assertTrue(jsonPrimitive.isString());
-    assertEquals("1556", element.getAsString());
-  }
-
-  public void testStringLongSerializationIntegration() {
-    Gson gson = Gson.newBuilder()
-        .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .build();
-    assertEquals("[\"1\"]", gson.toJson(new long[] { 1L }, long[].class));
-    assertEquals("[\"1\"]", gson.toJson(new Long[] { 1L }, Long[].class));
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 846e70839..8a8969871 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -68,623 +68,561 @@
  * @author Joel Leitch
  */
 public class DefaultTypeAdaptersTest extends TestCase {
-  private Gson gson;
-  private TimeZone oldTimeZone;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    this.oldTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
-    Locale.setDefault(Locale.US);
-    gson = Gson.newGson();
-  }
-
-  @Override
-  protected void tearDown() throws Exception {
-    TimeZone.setDefault(oldTimeZone);
-    super.tearDown();
-  }
-
-  public void testClassSerialization() {
-    try {
-      gson.toJson(String.class);
-    } catch (UnsupportedOperationException expected) {}
-    // Override with a custom type adapter for class.
-    gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
-    assertEquals("\"java.lang.String\"", gson.toJson(String.class));
-  }
-
-  public void testClassDeserialization() {
-    try {
-      gson.fromJson("String.class", String.class.getClass());
-    } catch (UnsupportedOperationException expected) {}
-    // Override with a custom type adapter for class.
-    gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
-    assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
-  }
-
-  public void testUrlSerialization() throws Exception {
-    String urlValue = "http://google.com/";
-    URL url = new URL(urlValue);
-    assertEquals("\"http://google.com/\"", gson.toJson(url));
-  }
-
-  public void testUrlDeserialization() {
-    String urlValue = "http://google.com/";
-    String json = "'http:\\/\\/google.com\\/'";
-    URL target = gson.fromJson(json, URL.class);
-    assertEquals(urlValue, target.toExternalForm());
-
-    gson.fromJson('"' + urlValue + '"', URL.class);
-    assertEquals(urlValue, target.toExternalForm());
-  }
-
-  public void testUrlNullSerialization() throws Exception {
-    ClassWithUrlField target = new ClassWithUrlField();
-    assertEquals("{}", gson.toJson(target));
-  }
-
-  public void testUrlNullDeserialization() {
-    String json = "{}";
-    ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);
-    assertNull(target.url);
-  }
-
-  private static class ClassWithUrlField {
-    URL url;
-  }
-
-  public void testUriSerialization() throws Exception {
-    String uriValue = "http://google.com/";
-    URI uri = new URI(uriValue);
-    assertEquals("\"http://google.com/\"", gson.toJson(uri));
-  }
-
-  public void testUriDeserialization() {
-    String uriValue = "http://google.com/";
-    String json = '"' + uriValue + '"';
-    URI target = gson.fromJson(json, URI.class);
-    assertEquals(uriValue, target.toASCIIString());
-  }
-  
-  public void testNullSerialization() throws Exception {
-    testNullSerializationAndDeserialization(Boolean.class);
-    testNullSerializationAndDeserialization(Byte.class);
-    testNullSerializationAndDeserialization(Short.class);
-    testNullSerializationAndDeserialization(Integer.class);
-    testNullSerializationAndDeserialization(Long.class);
-    testNullSerializationAndDeserialization(Double.class);
-    testNullSerializationAndDeserialization(Float.class);
-    testNullSerializationAndDeserialization(Number.class);
-    testNullSerializationAndDeserialization(Character.class);
-    testNullSerializationAndDeserialization(String.class);
-    testNullSerializationAndDeserialization(StringBuilder.class);
-    testNullSerializationAndDeserialization(StringBuffer.class);
-    testNullSerializationAndDeserialization(BigDecimal.class);
-    testNullSerializationAndDeserialization(BigInteger.class);
-    testNullSerializationAndDeserialization(TreeSet.class);
-    testNullSerializationAndDeserialization(ArrayList.class);
-    testNullSerializationAndDeserialization(HashSet.class);
-    testNullSerializationAndDeserialization(Properties.class);
-    testNullSerializationAndDeserialization(URL.class);
-    testNullSerializationAndDeserialization(URI.class);
-    testNullSerializationAndDeserialization(UUID.class);
-    testNullSerializationAndDeserialization(Locale.class);
-    testNullSerializationAndDeserialization(InetAddress.class);
-    testNullSerializationAndDeserialization(BitSet.class);
-    testNullSerializationAndDeserialization(Date.class);
-    testNullSerializationAndDeserialization(GregorianCalendar.class);
-    testNullSerializationAndDeserialization(Calendar.class);
-    testNullSerializationAndDeserialization(Time.class);
-    testNullSerializationAndDeserialization(Timestamp.class);
-    testNullSerializationAndDeserialization(java.sql.Date.class);
-    testNullSerializationAndDeserialization(Enum.class);
-    testNullSerializationAndDeserialization(Class.class);
-  }
-
-  private void testNullSerializationAndDeserialization(Class<?> c) {
-    assertEquals("null", gson.toJson(null, c));
-    assertEquals(null, gson.fromJson("null", c));
-  }
-
-  public void testUuidSerialization() throws Exception {
-    String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
-    UUID uuid = UUID.fromString(uuidValue);
-    assertEquals('"' + uuidValue + '"', gson.toJson(uuid));
-  }
-
-  public void testUuidDeserialization() {
-    String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
-    String json = '"' + uuidValue + '"';
-    UUID target = gson.fromJson(json, UUID.class);
-    assertEquals(uuidValue, target.toString());
-  }
-
-  public void testLocaleSerializationWithLanguage() {
-    Locale target = new Locale("en");
-    assertEquals("\"en\"", gson.toJson(target));
-  }
-
-  public void testLocaleDeserializationWithLanguage() {
-    String json = "\"en\"";
-    Locale locale = gson.fromJson(json, Locale.class);
-    assertEquals("en", locale.getLanguage());
-  }
-
-  public void testLocaleSerializationWithLanguageCountry() {
-    Locale target = Locale.CANADA_FRENCH;
-    assertEquals("\"fr_CA\"", gson.toJson(target));
-  }
-
-  public void testLocaleDeserializationWithLanguageCountry() {
-    String json = "\"fr_CA\"";
-    Locale locale = gson.fromJson(json, Locale.class);
-    assertEquals(Locale.CANADA_FRENCH, locale);
-  }
-
-  public void testLocaleSerializationWithLanguageCountryVariant() {
-    Locale target = new Locale("de", "DE", "EURO");
-    String json = gson.toJson(target);
-    assertEquals("\"de_DE_EURO\"", json);
-  }
-
-  public void testLocaleDeserializationWithLanguageCountryVariant() {
-    String json = "\"de_DE_EURO\"";
-    Locale locale = gson.fromJson(json, Locale.class);
-    assertEquals("de", locale.getLanguage());
-    assertEquals("DE", locale.getCountry());
-    assertEquals("EURO", locale.getVariant());
-  }
-
-  public void testBigDecimalFieldSerialization() {
-    ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21");
-    String json = gson.toJson(target);
-    String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));
-    assertEquals(target.value, new BigDecimal(actual));
-  }
-
-  public void testBigDecimalFieldDeserialization() {
-    ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21");
-    String json = expected.getExpectedJson();
-    ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);
-    assertEquals(expected.value, actual.value);
-  }
-
-  public void testBadValueForBigDecimalDeserialization() {
-    try {
-      gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class);
-      fail("Exponent of a BigDecimal must be an integer value.");
-    } catch (JsonParseException expected) { }
-  }
-
-  public void testBigIntegerFieldSerialization() {
-    ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324");
-    String json = gson.toJson(target);
-    assertEquals(target.getExpectedJson(), json);
-  }
-
-  public void testBigIntegerFieldDeserialization() {
-    ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697");
-    String json = expected.getExpectedJson();
-    ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);
-    assertEquals(expected.value, actual.value);
-  }
-  
-  public void testOverrideBigIntegerTypeAdapter() throws Exception {
-    gson = Gson.newBuilder()
-        .registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class))
-        .build();
-    assertEquals("\"123\"", gson.toJson(new BigInteger("123"), BigInteger.class));
-    assertEquals(new BigInteger("123"), gson.fromJson("\"123\"", BigInteger.class));
-  }
-
-  public void testOverrideBigDecimalTypeAdapter() throws Exception {
-    gson = Gson.newBuilder()
-        .registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class))
-        .build();
-    assertEquals("\"1.1\"", gson.toJson(new BigDecimal("1.1"), BigDecimal.class));
-    assertEquals(new BigDecimal("1.1"), gson.fromJson("\"1.1\"", BigDecimal.class));
-  }
-
-  public void testSetSerialization() throws Exception {
-    Gson gson = Gson.newGson();
-    HashSet<String> s = new HashSet<String>();
-    s.add("blah");
-    String json = gson.toJson(s);
-    assertEquals("[\"blah\"]", json);
-
-    json = gson.toJson(s, Set.class);
-    assertEquals("[\"blah\"]", json);
-  }
-
-  public void testBitSetSerialization() throws Exception {
-    Gson gson = Gson.newGson();
-    BitSet bits = new BitSet();
-    bits.set(1);
-    bits.set(3, 6);
-    bits.set(9);
-    String json = gson.toJson(bits);
-    assertEquals("[0,1,0,1,1,1,0,0,0,1]", json);
-  }
-
-  public void testBitSetDeserialization() throws Exception {
-    BitSet expected = new BitSet();
-    expected.set(0);
-    expected.set(2, 6);
-    expected.set(8);
-
-    Gson gson = Gson.newGson();
-    String json = gson.toJson(expected);
-    assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-    json = "[1,0,1,1,1,1,0,0,1,0,0,0]";
-    assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-    json = "[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\"]";
-    assertEquals(expected, gson.fromJson(json, BitSet.class));
-
-    json = "[true,false,true,true,true,true,false,false,true,false,false]";
-    assertEquals(expected, gson.fromJson(json, BitSet.class));
-  }
-
-  public void testDefaultDateSerialization() {
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    if (JavaVersion.isJava9OrLater()) {
-      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
-    } else {
-      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
-    }
-  }
-
-  public void testDefaultDateDeserialization() {
-    String json = "'Dec 13, 2009 07:18:02 AM'";
-    Date extracted = gson.fromJson(json, Date.class);
-    assertEqualsDate(extracted, 2009, 11, 13);
-    assertEqualsTime(extracted, 7, 18, 2);
-  }
-
-  // Date can not directly be compared with another instance since the deserialization loses the
-  // millisecond portion.
-  @SuppressWarnings("deprecation")
-  private void assertEqualsDate(Date date, int year, int month, int day) {
-    assertEquals(year-1900, date.getYear());
-    assertEquals(month, date.getMonth());
-    assertEquals(day, date.getDate());
-  }
-
-  @SuppressWarnings("deprecation")
-  private void assertEqualsTime(Date date, int hours, int minutes, int seconds) {
-    assertEquals(hours, date.getHours());
-    assertEquals(minutes, date.getMinutes());
-    assertEquals(seconds, date.getSeconds());
-  }
-
-  public void testDefaultJavaSqlDateSerialization() {
-    Instant instant = Instant.ofEpochMilli(1259875082000L);
-    String json = gson.toJson(instant);
-    assertEquals("\"2009-12-03T21:18:02Z\"", json);
-  }
-  
-  public void testDefaultJavaSqlDateDeserialization() {
-    String json = "\"2009-12-03T21:18:02Z\"";
-    Instant extracted = gson.fromJson(json, Instant.class);
-    assertEquals(extracted, Instant.ofEpochMilli(1259875082000L));
-  }
-
-  public void testDefaultJavaSqlTimestampSerialization() {
-    Timestamp now = new java.sql.Timestamp(1259875082000L);
-    String json = gson.toJson(now);
-    if (JavaVersion.isJava9OrLater()) {
-      assertEquals("\"Dec 3, 2009, 1:18:02 PM\"", json);
-    } else {
-      assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
-    }
-  }
-
-  public void testDefaultJavaSqlTimestampDeserialization() {
-    String json = "'Dec 3, 2009 1:18:02 PM'";
-    Timestamp extracted = gson.fromJson(json, Timestamp.class);
-    assertEqualsDate(extracted, 2009, 11, 3);
-    assertEqualsTime(extracted, 13, 18, 2);
-  }
-
-  public void testDefaultDateSerializationUsingBuilder() throws Exception {
-    Gson gson = Gson.newBuilder().build();
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    if (JavaVersion.isJava9OrLater()) {
-      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
-    } else {
-      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
-    }
-  }
-
-  public void testDefaultDateDeserializationUsingBuilder() throws Exception {
-    Gson gson = Gson.newBuilder().build();
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    Date extracted = gson.fromJson(json, Date.class);
-    assertEquals(now.toString(), extracted.toString());
-  }
-
-  public void testDateSerializationWithPattern() throws Exception {
-    String pattern = "yyyy-MM-dd";
-    Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    assertEquals("\"2011-09-11\"", json);
-  }
-
-  @SuppressWarnings("deprecation")
-  public void testDateDeserializationWithPattern() throws Exception {
-    String pattern = "yyyy-MM-dd";
-    Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    Date extracted = gson.fromJson(json, Date.class);
-    assertEquals(now.getYear(), extracted.getYear());
-    assertEquals(now.getMonth(), extracted.getMonth());
-    assertEquals(now.getDay(), extracted.getDay());
-  }
-
-  public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {
-    String pattern = "yyyy-MM-dd";
-    Gson gson = Gson.newBuilder()
-        .setDateFormat(pattern)
-        .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
-          public Date deserialize(JsonElement json, Type typeOfT,
-              JsonDeserializationContext context)
-              throws JsonParseException {
-            return new Date(1315806903103L);
-          }
-        })
-        .build();
-
-    Date now = new Date(1315806903103L);
-    String json = gson.toJson(now);
-    assertEquals("\"2011-09-11\"", json);
-  }
-
-  // http://code.google.com/p/google-gson/issues/detail?id=230
-  public void testDateSerializationInCollection() throws Exception {
-    Type listOfDates = new TypeToken<List<Date>>() {}.getType();
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.US);
-    try {
-      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-      List<Date> dates = Arrays.asList(new Date(0));
-      String json = gson.toJson(dates, listOfDates);
-      assertEquals("[\"1970-01-01\"]", json);
-      assertEquals(0L, gson.<List<Date>>fromJson("[\"1970-01-01\"]", listOfDates).get(0).getTime());
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  // http://code.google.com/p/google-gson/issues/detail?id=230
-  public void testTimestampSerialization() throws Exception {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.US);
-    try {
-      Timestamp timestamp = new Timestamp(0L);
-      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-      String json = gson.toJson(timestamp, Timestamp.class);
-      assertEquals("\"1970-01-01\"", json);
-      assertEquals(0, gson.fromJson("\"1970-01-01\"", Timestamp.class).getTime());
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  // http://code.google.com/p/google-gson/issues/detail?id=230
-  public void testSqlDateSerialization() throws Exception {
-    TimeZone defaultTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-    Locale defaultLocale = Locale.getDefault();
-    Locale.setDefault(Locale.US);
-    try {
-      java.sql.Date sqlDate = new java.sql.Date(0L);
-      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
-      String json = gson.toJson(sqlDate, Timestamp.class);
-      assertEquals("\"1970-01-01\"", json);
-      assertEquals(0, gson.fromJson("\"1970-01-01\"", java.sql.Date.class).getTime());
-    } finally {
-      TimeZone.setDefault(defaultTimeZone);
-      Locale.setDefault(defaultLocale);
-    }
-  }
-
-  public void testJsonPrimitiveSerialization() {
-    assertEquals("5", gson.toJson(new JsonPrimitive(5), JsonElement.class));
-    assertEquals("true", gson.toJson(new JsonPrimitive(true), JsonElement.class));
-    assertEquals("\"foo\"", gson.toJson(new JsonPrimitive("foo"), JsonElement.class));
-    assertEquals("\"a\"", gson.toJson(new JsonPrimitive('a'), JsonElement.class));
-  }
-
-  public void testJsonPrimitiveDeserialization() {
-    assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonElement.class));
-    assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonPrimitive.class));
-    assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonElement.class));
-    assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonPrimitive.class));
-    assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonElement.class));
-    assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonPrimitive.class));
-    assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonElement.class));
-    assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonPrimitive.class));
-  }
-
-  public void testJsonNullSerialization() {
-    assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonElement.class));
-    assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonNull.class));
-  }
-
-  public void testNullJsonElementSerialization() {
-    assertEquals("null", gson.toJson(null, JsonElement.class));
-    assertEquals("null", gson.toJson(null, JsonNull.class));
-  }
-
-  public void testJsonArraySerialization() {
-    JsonArray array = new JsonArray();
-    array.add(new JsonPrimitive(1));
-    array.add(new JsonPrimitive(2));
-    array.add(new JsonPrimitive(3));
-    assertEquals("[1,2,3]", gson.toJson(array, JsonElement.class));
-  }
-
-  public void testJsonArrayDeserialization() {
-    JsonArray array = new JsonArray();
-    array.add(new JsonPrimitive(1));
-    array.add(new JsonPrimitive(2));
-    array.add(new JsonPrimitive(3));
-
-    String json = "[1,2,3]";
-    assertEquals(array, gson.fromJson(json, JsonElement.class));
-    assertEquals(array, gson.fromJson(json, JsonArray.class));
-  }
-
-  public void testJsonObjectSerialization() {
-    JsonObject object = new JsonObject();
-    object.add("foo", new JsonPrimitive(1));
-    object.add("bar", new JsonPrimitive(2));
-    assertEquals("{\"foo\":1,\"bar\":2}", gson.toJson(object, JsonElement.class));
-  }
-
-  public void testJsonObjectDeserialization() {
-    JsonObject object = new JsonObject();
-    object.add("foo", new JsonPrimitive(1));
-    object.add("bar", new JsonPrimitive(2));
-
-    String json = "{\"foo\":1,\"bar\":2}";
-    JsonElement actual = gson.fromJson(json, JsonElement.class);
-    assertEquals(object, actual);
-
-    JsonObject actualObj = gson.fromJson(json, JsonObject.class);
-    assertEquals(object, actualObj);
-  }
-
-  public void testJsonNullDeserialization() {
-    assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonElement.class));
-    assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonNull.class));
-  }
-
-  public void testJsonElementTypeMismatch() {
-    try {
-      gson.fromJson("\"abc\"", JsonObject.class);
-      fail();
-    } catch (JsonSyntaxException expected) {
-      assertEquals("Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive",
-          expected.getMessage());
-    }
-  }
-
-  private static class ClassWithBigDecimal {
-    BigDecimal value;
-    ClassWithBigDecimal(String value) {
-      this.value = new BigDecimal(value);
-    }
-    String getExpectedJson() {
-      return "{\"value\":" + value.toEngineeringString() + "}";
-    }
-  }
-
-  private static class ClassWithBigInteger {
-    BigInteger value;
-    ClassWithBigInteger(String value) {
-      this.value = new BigInteger(value);
-    }
-    String getExpectedJson() {
-      return "{\"value\":" + value + "}";
-    }
-  }
-
-  public void testPropertiesSerialization() {
-    Properties props = new Properties();
-    props.setProperty("foo", "bar");
-    String json = gson.toJson(props);
-    String expected = "{\"foo\":\"bar\"}";
-    assertEquals(expected, json);
-  }
-
-  public void testPropertiesDeserialization() {
-    String json = "{foo:'bar'}";
-    Properties props = gson.fromJson(json, Properties.class);
-    assertEquals("bar", props.getProperty("foo"));
-  }
-
-  public void testTreeSetSerialization() {
-    TreeSet<String> treeSet = new TreeSet<String>();
-    treeSet.add("Value1");
-    String json = gson.toJson(treeSet);
-    assertEquals("[\"Value1\"]", json);
-  }
-
-  public void testTreeSetDeserialization() {
-    String json = "['Value1']";
-    Type type = new TypeToken<TreeSet<String>>() {}.getType();
-    TreeSet<String> treeSet = gson.fromJson(json, type);
-    assertTrue(treeSet.contains("Value1"));
-  }
-
-  public void testStringBuilderSerialization() {
-    StringBuilder sb = new StringBuilder("abc");
-    String json = gson.toJson(sb);
-    assertEquals("\"abc\"", json);
-  }
-
-  public void testStringBuilderDeserialization() {
-    StringBuilder sb = gson.fromJson("'abc'", StringBuilder.class);
-    assertEquals("abc", sb.toString());
-  }
-
-  public void testStringBufferSerialization() {
-    StringBuffer sb = new StringBuffer("abc");
-    String json = gson.toJson(sb);
-    assertEquals("\"abc\"", json);
-  }
-
-  public void testStringBufferDeserialization() {
-    StringBuffer sb = gson.fromJson("'abc'", StringBuffer.class);
-    assertEquals("abc", sb.toString());
-  }
-
-  @SuppressWarnings("rawtypes")
-  private static class MyClassTypeAdapter extends TypeAdapter<Class> {
-    @Override
-    public void write(JsonWriter out, Class value) throws IOException {
-      out.value(value.getName());
-    }
-    @Override
-    public Class read(JsonReader in) throws IOException {
-      String className = in.nextString();
-      try {
-        return Class.forName(className);
-      } catch (ClassNotFoundException e) {
-        throw new IOException(e);
-      }
-    }
-  }
-
-  static class NumberAsStringAdapter extends TypeAdapter<Number> {
-    private final Constructor<? extends Number> constructor;
-    NumberAsStringAdapter(Class<? extends Number> type) throws Exception {
-      this.constructor = type.getConstructor(String.class);
-    }
-    @Override public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value.toString());
-    }
-    @Override public Number read(JsonReader in) throws IOException {
-      try {
-        return constructor.newInstance(in.nextString());
-      } catch (Exception e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
+	private Gson gson;
+	private TimeZone oldTimeZone;
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		this.oldTimeZone = TimeZone.getDefault();
+		TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+		Locale.setDefault(Locale.US);
+		gson = Gson.newGson();
+	}
+
+	@Override
+	protected void tearDown() throws Exception {
+		TimeZone.setDefault(oldTimeZone);
+		super.tearDown();
+	}
+
+	public void testClassSerialization() {
+		try {
+			gson.toJson(String.class);
+		} catch (UnsupportedOperationException expected) {}
+		// Override with a custom type adapter for class.
+		gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
+		assertEquals("\"java.lang.String\"", gson.toJson(String.class));
+	}
+
+	public void testClassDeserialization() {
+		try {
+			gson.fromJson("String.class", String.class.getClass());
+		} catch (UnsupportedOperationException expected) {}
+		// Override with a custom type adapter for class.
+		gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
+		assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
+	}
+
+	public void testUrlSerialization() throws Exception {
+		String urlValue = "http://google.com/";
+		URL url = new URL(urlValue);
+		assertEquals("\"http://google.com/\"", gson.toJson(url));
+	}
+
+	public void testUrlDeserialization() {
+		String urlValue = "http://google.com/";
+		String json = "'http:\\/\\/google.com\\/'";
+		URL target = gson.fromJson(json, URL.class);
+		assertEquals(urlValue, target.toExternalForm());
+
+		gson.fromJson('"' + urlValue + '"', URL.class);
+		assertEquals(urlValue, target.toExternalForm());
+	}
+
+	public void testUrlNullSerialization() throws Exception {
+		ClassWithUrlField target = new ClassWithUrlField();
+		assertEquals("{}", gson.toJson(target));
+	}
+
+	public void testUrlNullDeserialization() {
+		String json = "{}";
+		ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);
+		assertNull(target.url);
+	}
+
+	private static class ClassWithUrlField {
+		URL url;
+	}
+
+	public void testUriSerialization() throws Exception {
+		String uriValue = "http://google.com/";
+		URI uri = new URI(uriValue);
+		assertEquals("\"http://google.com/\"", gson.toJson(uri));
+	}
+
+	public void testUriDeserialization() {
+		String uriValue = "http://google.com/";
+		String json = '"' + uriValue + '"';
+		URI target = gson.fromJson(json, URI.class);
+		assertEquals(uriValue, target.toASCIIString());
+	}
+
+	public void testNullSerialization() throws Exception {
+		testNullSerializationAndDeserialization(Boolean.class);
+		testNullSerializationAndDeserialization(Byte.class);
+		testNullSerializationAndDeserialization(Short.class);
+		testNullSerializationAndDeserialization(Integer.class);
+		testNullSerializationAndDeserialization(Long.class);
+		testNullSerializationAndDeserialization(Double.class);
+		testNullSerializationAndDeserialization(Float.class);
+		testNullSerializationAndDeserialization(Number.class);
+		testNullSerializationAndDeserialization(Character.class);
+		testNullSerializationAndDeserialization(String.class);
+		testNullSerializationAndDeserialization(StringBuilder.class);
+		testNullSerializationAndDeserialization(StringBuffer.class);
+		testNullSerializationAndDeserialization(BigDecimal.class);
+		testNullSerializationAndDeserialization(BigInteger.class);
+		testNullSerializationAndDeserialization(TreeSet.class);
+		testNullSerializationAndDeserialization(ArrayList.class);
+		testNullSerializationAndDeserialization(HashSet.class);
+		testNullSerializationAndDeserialization(Properties.class);
+		testNullSerializationAndDeserialization(URL.class);
+		testNullSerializationAndDeserialization(URI.class);
+		testNullSerializationAndDeserialization(UUID.class);
+		testNullSerializationAndDeserialization(Locale.class);
+		testNullSerializationAndDeserialization(InetAddress.class);
+		testNullSerializationAndDeserialization(BitSet.class);
+		testNullSerializationAndDeserialization(Date.class);
+		testNullSerializationAndDeserialization(GregorianCalendar.class);
+		testNullSerializationAndDeserialization(Calendar.class);
+		testNullSerializationAndDeserialization(Time.class);
+		testNullSerializationAndDeserialization(Timestamp.class);
+		testNullSerializationAndDeserialization(java.sql.Date.class);
+		testNullSerializationAndDeserialization(Enum.class);
+		testNullSerializationAndDeserialization(Class.class);
+	}
+
+	private void testNullSerializationAndDeserialization(Class<?> c) {
+		assertEquals("null", gson.toJson(null, c));
+		assertEquals(null, gson.fromJson("null", c));
+	}
+
+	public void testUuidSerialization() throws Exception {
+		String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
+		UUID uuid = UUID.fromString(uuidValue);
+		assertEquals('"' + uuidValue + '"', gson.toJson(uuid));
+	}
+
+	public void testUuidDeserialization() {
+		String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";
+		String json = '"' + uuidValue + '"';
+		UUID target = gson.fromJson(json, UUID.class);
+		assertEquals(uuidValue, target.toString());
+	}
+
+	public void testLocaleSerializationWithLanguage() {
+		Locale target = new Locale("en");
+		assertEquals("\"en\"", gson.toJson(target));
+	}
+
+	public void testLocaleDeserializationWithLanguage() {
+		String json = "\"en\"";
+		Locale locale = gson.fromJson(json, Locale.class);
+		assertEquals("en", locale.getLanguage());
+	}
+
+	public void testLocaleSerializationWithLanguageCountry() {
+		Locale target = Locale.CANADA_FRENCH;
+		assertEquals("\"fr_CA\"", gson.toJson(target));
+	}
+
+	public void testLocaleDeserializationWithLanguageCountry() {
+		String json = "\"fr_CA\"";
+		Locale locale = gson.fromJson(json, Locale.class);
+		assertEquals(Locale.CANADA_FRENCH, locale);
+	}
+
+	public void testLocaleSerializationWithLanguageCountryVariant() {
+		Locale target = new Locale("de", "DE", "EURO");
+		String json = gson.toJson(target);
+		assertEquals("\"de_DE_EURO\"", json);
+	}
+
+	public void testLocaleDeserializationWithLanguageCountryVariant() {
+		String json = "\"de_DE_EURO\"";
+		Locale locale = gson.fromJson(json, Locale.class);
+		assertEquals("de", locale.getLanguage());
+		assertEquals("DE", locale.getCountry());
+		assertEquals("EURO", locale.getVariant());
+	}
+
+	public void testBigDecimalFieldSerialization() {
+		ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21");
+		String json = gson.toJson(target);
+		String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));
+		assertEquals(target.value, new BigDecimal(actual));
+	}
+
+	public void testBigDecimalFieldDeserialization() {
+		ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21");
+		String json = expected.getExpectedJson();
+		ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);
+		assertEquals(expected.value, actual.value);
+	}
+
+	public void testBadValueForBigDecimalDeserialization() {
+		try {
+			gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class);
+			fail("Exponent of a BigDecimal must be an integer value.");
+		} catch (JsonParseException expected) { }
+	}
+
+	public void testBigIntegerFieldSerialization() {
+		ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324");
+		String json = gson.toJson(target);
+		assertEquals(target.getExpectedJson(), json);
+	}
+
+	public void testBigIntegerFieldDeserialization() {
+		ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697");
+		String json = expected.getExpectedJson();
+		ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);
+		assertEquals(expected.value, actual.value);
+	}
+
+	public void testOverrideBigIntegerTypeAdapter() throws Exception {
+		gson = Gson.newBuilder()
+				.registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class))
+				.build();
+		assertEquals("\"123\"", gson.toJson(new BigInteger("123"), BigInteger.class));
+		assertEquals(new BigInteger("123"), gson.fromJson("\"123\"", BigInteger.class));
+	}
+
+	public void testOverrideBigDecimalTypeAdapter() throws Exception {
+		gson = Gson.newBuilder()
+				.registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class))
+				.build();
+		assertEquals("\"1.1\"", gson.toJson(new BigDecimal("1.1"), BigDecimal.class));
+		assertEquals(new BigDecimal("1.1"), gson.fromJson("\"1.1\"", BigDecimal.class));
+	}
+
+	public void testSetSerialization() throws Exception {
+		Gson gson = Gson.newGson();
+		HashSet<String> s = new HashSet<String>();
+		s.add("blah");
+		String json = gson.toJson(s);
+		assertEquals("[\"blah\"]", json);
+
+		json = gson.toJson(s, Set.class);
+		assertEquals("[\"blah\"]", json);
+	}
+
+	public void testBitSetSerialization() throws Exception {
+		Gson gson = Gson.newGson();
+		BitSet bits = new BitSet();
+		bits.set(1);
+		bits.set(3, 6);
+		bits.set(9);
+		String json = gson.toJson(bits);
+		assertEquals("[0,1,0,1,1,1,0,0,0,1]", json);
+	}
+
+	public void testBitSetDeserialization() throws Exception {
+		BitSet expected = new BitSet();
+		expected.set(0);
+		expected.set(2, 6);
+		expected.set(8);
+
+		Gson gson = Gson.newGson();
+		String json = gson.toJson(expected);
+		assertEquals(expected, gson.fromJson(json, BitSet.class));
+
+		json = "[1,0,1,1,1,1,0,0,1,0,0,0]";
+		assertEquals(expected, gson.fromJson(json, BitSet.class));
+
+		json = "[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\"]";
+		assertEquals(expected, gson.fromJson(json, BitSet.class));
+
+		json = "[true,false,true,true,true,true,false,false,true,false,false]";
+		assertEquals(expected, gson.fromJson(json, BitSet.class));
+	}
+
+	public void testDefaultDateDeserialization() {
+		String json = "'2009-12-03T01:18:02'";
+		LocalDateTime extracted = gson.fromJson(json, LocalDateTime.class);
+
+		assertEquals(LocalDateTime.of(2009, Month.DECEMBER, 3, 1, 18, 2), extracted);
+	}
+
+	public void testDefaultJavaSqlDateSerialization() {
+		Instant instant = Instant.ofEpochMilli(1259875082000L);
+		String json = gson.toJson(instant);
+		assertEquals("\"2009-12-03T21:18:02Z\"", json);
+	}
+
+	public void testDefaultJavaSqlDateDeserialization() {
+		String json = "\"2009-12-03T21:18:02Z\"";
+		Instant extracted = gson.fromJson(json, Instant.class);
+		assertEquals(extracted, Instant.ofEpochMilli(1259875082000L));
+	}
+
+	public void testDateSerializationWithPattern() throws Exception {
+		String pattern = "yyyy-MM-dd";
+		Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
+		Date now = new Date(1315806903103L);
+		String json = gson.toJson(now);
+		assertEquals("\"2011-09-11\"", json);
+	}
+
+	@SuppressWarnings("deprecation")
+	public void testDateDeserializationWithPattern() throws Exception {
+		String pattern = "yyyy-MM-dd";
+		Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
+		Date now = new Date(1315806903103L);
+		String json = gson.toJson(now);
+		Date extracted = gson.fromJson(json, Date.class);
+		assertEquals(now.getYear(), extracted.getYear());
+		assertEquals(now.getMonth(), extracted.getMonth());
+		assertEquals(now.getDay(), extracted.getDay());
+	}
+
+	public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {
+		String pattern = "yyyy-MM-dd";
+		Gson gson = Gson.newBuilder()
+				.setDateFormat(pattern)
+				.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
+					public Date deserialize(JsonElement json, Type typeOfT,
+							JsonDeserializationContext context)
+									throws JsonParseException {
+						return new Date(1315806903103L);
+					}
+				})
+				.build();
+
+		Date now = new Date(1315806903103L);
+		String json = gson.toJson(now);
+		assertEquals("\"2011-09-11\"", json);
+	}
+
+	// http://code.google.com/p/google-gson/issues/detail?id=230
+	public void testDateSerializationInCollection() throws Exception {
+		Type listOfDates = new TypeToken<List<Date>>() {}.getType();
+		TimeZone defaultTimeZone = TimeZone.getDefault();
+		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+		Locale defaultLocale = Locale.getDefault();
+		Locale.setDefault(Locale.US);
+		try {
+			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
+			List<Date> dates = Arrays.asList(new Date(0));
+			String json = gson.toJson(dates, listOfDates);
+			assertEquals("[\"1970-01-01\"]", json);
+			assertEquals(0L, gson.<List<Date>>fromJson("[\"1970-01-01\"]", listOfDates).get(0).getTime());
+		} finally {
+			TimeZone.setDefault(defaultTimeZone);
+			Locale.setDefault(defaultLocale);
+		}
+	}
+
+	// http://code.google.com/p/google-gson/issues/detail?id=230
+	public void testTimestampSerialization() throws Exception {
+		TimeZone defaultTimeZone = TimeZone.getDefault();
+		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+		Locale defaultLocale = Locale.getDefault();
+		Locale.setDefault(Locale.US);
+		try {
+			Timestamp timestamp = new Timestamp(0L);
+			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
+			String json = gson.toJson(timestamp, Timestamp.class);
+			assertEquals("\"1970-01-01\"", json);
+			assertEquals(0, gson.fromJson("\"1970-01-01\"", Timestamp.class).getTime());
+		} finally {
+			TimeZone.setDefault(defaultTimeZone);
+			Locale.setDefault(defaultLocale);
+		}
+	}
+
+	// http://code.google.com/p/google-gson/issues/detail?id=230
+	public void testSqlDateSerialization() throws Exception {
+		TimeZone defaultTimeZone = TimeZone.getDefault();
+		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+		Locale defaultLocale = Locale.getDefault();
+		Locale.setDefault(Locale.US);
+		try {
+			java.sql.Date sqlDate = new java.sql.Date(0L);
+			Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
+			String json = gson.toJson(sqlDate, Timestamp.class);
+			assertEquals("\"1970-01-01\"", json);
+			assertEquals(0, gson.fromJson("\"1970-01-01\"", java.sql.Date.class).getTime());
+		} finally {
+			TimeZone.setDefault(defaultTimeZone);
+			Locale.setDefault(defaultLocale);
+		}
+	}
+
+	public void testJsonPrimitiveSerialization() {
+		assertEquals("5", gson.toJson(new JsonPrimitive(5), JsonElement.class));
+		assertEquals("true", gson.toJson(new JsonPrimitive(true), JsonElement.class));
+		assertEquals("\"foo\"", gson.toJson(new JsonPrimitive("foo"), JsonElement.class));
+		assertEquals("\"a\"", gson.toJson(new JsonPrimitive('a'), JsonElement.class));
+	}
+
+	public void testJsonPrimitiveDeserialization() {
+		assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonElement.class));
+		assertEquals(new JsonPrimitive(5), gson.fromJson("5", JsonPrimitive.class));
+		assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonElement.class));
+		assertEquals(new JsonPrimitive(true), gson.fromJson("true", JsonPrimitive.class));
+		assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonElement.class));
+		assertEquals(new JsonPrimitive("foo"), gson.fromJson("\"foo\"", JsonPrimitive.class));
+		assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonElement.class));
+		assertEquals(new JsonPrimitive('a'), gson.fromJson("\"a\"", JsonPrimitive.class));
+	}
+
+	public void testJsonNullSerialization() {
+		assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonElement.class));
+		assertEquals("null", gson.toJson(JsonNull.INSTANCE, JsonNull.class));
+	}
+
+	public void testNullJsonElementSerialization() {
+		assertEquals("null", gson.toJson(null, JsonElement.class));
+		assertEquals("null", gson.toJson(null, JsonNull.class));
+	}
+
+	public void testJsonArraySerialization() {
+		JsonArray array = new JsonArray();
+		array.add(new JsonPrimitive(1));
+		array.add(new JsonPrimitive(2));
+		array.add(new JsonPrimitive(3));
+		assertEquals("[1,2,3]", gson.toJson(array, JsonElement.class));
+	}
+
+	public void testJsonArrayDeserialization() {
+		JsonArray array = new JsonArray();
+		array.add(new JsonPrimitive(1));
+		array.add(new JsonPrimitive(2));
+		array.add(new JsonPrimitive(3));
+
+		String json = "[1,2,3]";
+		assertEquals(array, gson.fromJson(json, JsonElement.class));
+		assertEquals(array, gson.fromJson(json, JsonArray.class));
+	}
+
+	public void testJsonObjectSerialization() {
+		JsonObject object = new JsonObject();
+		object.add("foo", new JsonPrimitive(1));
+		object.add("bar", new JsonPrimitive(2));
+		assertEquals("{\"foo\":1,\"bar\":2}", gson.toJson(object, JsonElement.class));
+	}
+
+	public void testJsonObjectDeserialization() {
+		JsonObject object = new JsonObject();
+		object.add("foo", new JsonPrimitive(1));
+		object.add("bar", new JsonPrimitive(2));
+
+		String json = "{\"foo\":1,\"bar\":2}";
+		JsonElement actual = gson.fromJson(json, JsonElement.class);
+		assertEquals(object, actual);
+
+		JsonObject actualObj = gson.fromJson(json, JsonObject.class);
+		assertEquals(object, actualObj);
+	}
+
+	public void testJsonNullDeserialization() {
+		assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonElement.class));
+		assertEquals(JsonNull.INSTANCE, gson.fromJson("null", JsonNull.class));
+	}
+
+	public void testJsonElementTypeMismatch() {
+		try {
+			gson.fromJson("\"abc\"", JsonObject.class);
+			fail();
+		} catch (JsonSyntaxException expected) {
+			assertEquals("Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive",
+					expected.getMessage());
+		}
+	}
+
+	private static class ClassWithBigDecimal {
+		BigDecimal value;
+		ClassWithBigDecimal(String value) {
+			this.value = new BigDecimal(value);
+		}
+		String getExpectedJson() {
+			return "{\"value\":" + value.toEngineeringString() + "}";
+		}
+	}
+
+	private static class ClassWithBigInteger {
+		BigInteger value;
+		ClassWithBigInteger(String value) {
+			this.value = new BigInteger(value);
+		}
+		String getExpectedJson() {
+			return "{\"value\":" + value + "}";
+		}
+	}
+
+	public void testPropertiesSerialization() {
+		Properties props = new Properties();
+		props.setProperty("foo", "bar");
+		String json = gson.toJson(props);
+		String expected = "{\"foo\":\"bar\"}";
+		assertEquals(expected, json);
+	}
+
+	public void testPropertiesDeserialization() {
+		String json = "{foo:'bar'}";
+		Properties props = gson.fromJson(json, Properties.class);
+		assertEquals("bar", props.getProperty("foo"));
+	}
+
+	public void testTreeSetSerialization() {
+		TreeSet<String> treeSet = new TreeSet<String>();
+		treeSet.add("Value1");
+		String json = gson.toJson(treeSet);
+		assertEquals("[\"Value1\"]", json);
+	}
+
+	public void testTreeSetDeserialization() {
+		String json = "['Value1']";
+		Type type = new TypeToken<TreeSet<String>>() {}.getType();
+		TreeSet<String> treeSet = gson.fromJson(json, type);
+		assertTrue(treeSet.contains("Value1"));
+	}
+
+	public void testStringBuilderSerialization() {
+		StringBuilder sb = new StringBuilder("abc");
+		String json = gson.toJson(sb);
+		assertEquals("\"abc\"", json);
+	}
+
+	public void testStringBuilderDeserialization() {
+		StringBuilder sb = gson.fromJson("'abc'", StringBuilder.class);
+		assertEquals("abc", sb.toString());
+	}
+
+	public void testStringBufferSerialization() {
+		StringBuffer sb = new StringBuffer("abc");
+		String json = gson.toJson(sb);
+		assertEquals("\"abc\"", json);
+	}
+
+	public void testStringBufferDeserialization() {
+		StringBuffer sb = gson.fromJson("'abc'", StringBuffer.class);
+		assertEquals("abc", sb.toString());
+	}
+
+	@SuppressWarnings("rawtypes")
+	private static class MyClassTypeAdapter extends TypeAdapter<Class> {
+		@Override
+		public void write(JsonWriter out, Class value) throws IOException {
+			out.value(value.getName());
+		}
+		@Override
+		public Class read(JsonReader in) throws IOException {
+			String className = in.nextString();
+			try {
+				return Class.forName(className);
+			} catch (ClassNotFoundException e) {
+				throw new IOException(e);
+			}
+		}
+	}
+
+	static class NumberAsStringAdapter extends TypeAdapter<Number> {
+		private final Constructor<? extends Number> constructor;
+		NumberAsStringAdapter(Class<? extends Number> type) throws Exception {
+			this.constructor = type.getConstructor(String.class);
+		}
+		@Override public void write(JsonWriter out, Number value) throws IOException {
+			out.value(value.toString());
+		}
+		@Override public Number read(JsonReader in) throws IOException {
+			try {
+				return constructor.newInstance(in.nextString());
+			} catch (Exception e) {
+				throw new AssertionError(e);
+			}
+		}
+	}
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
index 6d1a3642c..1c872cbaa 100644
--- a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
@@ -16,95 +16,85 @@
 
 package com.google.gson.functional;
 
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicIntegerArray;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicLongArray;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.LongSerializationPolicy;
-
-import junit.framework.TestCase;
+import com.google.gson.*;
+import java.util.concurrent.atomic.*;
+import junit.framework.*;
 
 /**
  * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
  */
 public class JavaUtilConcurrentAtomicTest extends TestCase {
-  private Gson gson;
+	private Gson gson;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    gson = Gson.newGson();
-  }
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		gson = Gson.newGson();
+	}
 
-  public void testAtomicBoolean() throws Exception {
-    AtomicBoolean target = gson.fromJson("true", AtomicBoolean.class);
-    assertTrue(target.get());
-    String json = gson.toJson(target);
-    assertEquals("true", json);
-  }
+	public void testAtomicBoolean() throws Exception {
+		AtomicBoolean target = gson.fromJson("true", AtomicBoolean.class);
+		assertTrue(target.get());
+		String json = gson.toJson(target);
+		assertEquals("true", json);
+	}
 
-  public void testAtomicInteger() throws Exception {
-    AtomicInteger target = gson.fromJson("10", AtomicInteger.class);
-    assertEquals(10, target.get());
-    String json = gson.toJson(target);
-    assertEquals("10", json);
-  }
+	public void testAtomicInteger() throws Exception {
+		AtomicInteger target = gson.fromJson("10", AtomicInteger.class);
+		assertEquals(10, target.get());
+		String json = gson.toJson(target);
+		assertEquals("10", json);
+	}
 
-  public void testAtomicLong() throws Exception {
-    AtomicLong target = gson.fromJson("10", AtomicLong.class);
-    assertEquals(10, target.get());
-    String json = gson.toJson(target);
-    assertEquals("10", json);
-  }
+	public void testAtomicLong() throws Exception {
+		AtomicLong target = gson.fromJson("10", AtomicLong.class);
+		assertEquals(10, target.get());
+		String json = gson.toJson(target);
+		assertEquals("10", json);
+	}
 
-  public void testAtomicLongWithStringSerializationPolicy() throws Exception {
-    Gson gson = Gson.newBuilder()
-        .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .build();
-    AtomicLongHolder target = gson.fromJson("{'value':'10'}", AtomicLongHolder.class);
-    assertEquals(10, target.value.get());
-    String json = gson.toJson(target);
-    assertEquals("{\"value\":\"10\"}", json);
-  }
+	public void testAtomicLongWithStringSerializationPolicy() throws Exception {
+		Gson gson = Gson.newBuilder()
+				.build();
+		AtomicLongHolder target = gson.fromJson("{'value':'10'}", AtomicLongHolder.class);
+		assertEquals(10, target.value.get());
+		String json = gson.toJson(target);
+		assertEquals("{\"value\":10}", json);
+	}
 
-  public void testAtomicIntegerArray() throws Exception {
-    AtomicIntegerArray target = gson.fromJson("[10, 13, 14]", AtomicIntegerArray.class);
-    assertEquals(3, target.length());
-    assertEquals(10, target.get(0));
-    assertEquals(13, target.get(1));
-    assertEquals(14, target.get(2));
-    String json = gson.toJson(target);
-    assertEquals("[10,13,14]", json);
-  }
+	public void testAtomicIntegerArray() throws Exception {
+		AtomicIntegerArray target = gson.fromJson("[10, 13, 14]", AtomicIntegerArray.class);
+		assertEquals(3, target.length());
+		assertEquals(10, target.get(0));
+		assertEquals(13, target.get(1));
+		assertEquals(14, target.get(2));
+		String json = gson.toJson(target);
+		assertEquals("[10,13,14]", json);
+	}
 
-  public void testAtomicLongArray() throws Exception {
-    AtomicLongArray target = gson.fromJson("[10, 13, 14]", AtomicLongArray.class);
-    assertEquals(3, target.length());
-    assertEquals(10, target.get(0));
-    assertEquals(13, target.get(1));
-    assertEquals(14, target.get(2));
-    String json = gson.toJson(target);
-    assertEquals("[10,13,14]", json);
-  }
+	public void testAtomicLongArray() throws Exception {
+		AtomicLongArray target = gson.fromJson("[10, 13, 14]", AtomicLongArray.class);
+		assertEquals(3, target.length());
+		assertEquals(10, target.get(0));
+		assertEquals(13, target.get(1));
+		assertEquals(14, target.get(2));
+		String json = gson.toJson(target);
+		assertEquals("[10,13,14]", json);
+	}
 
-  public void testAtomicLongArrayWithStringSerializationPolicy() throws Exception {
-    Gson gson = Gson.newBuilder()
-        .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .build();
-    AtomicLongArray target = gson.fromJson("['10', '13', '14']", AtomicLongArray.class);
-    assertEquals(3, target.length());
-    assertEquals(10, target.get(0));
-    assertEquals(13, target.get(1));
-    assertEquals(14, target.get(2));
-    String json = gson.toJson(target);
-    assertEquals("[\"10\",\"13\",\"14\"]", json);
-  }
+	public void testAtomicLongArrayWithStringSerializationPolicy() throws Exception {
+		Gson gson = Gson.newBuilder()
+				.build();
+		AtomicLongArray target = gson.fromJson("['10', '13', '14']", AtomicLongArray.class);
+		assertEquals(3, target.length());
+		assertEquals(10, target.get(0));
+		assertEquals(13, target.get(1));
+		assertEquals(14, target.get(2));
+		String json = gson.toJson(target);
+		assertEquals("[10,13,14]", json);
+	}
 
-  private static class AtomicLongHolder {
-    AtomicLong value;
-  }
+	private static class AtomicLongHolder {
+		AtomicLong value;
+	}
 }
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index 258baf7e8..9a1efb082 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -36,6 +36,7 @@
 import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
+import java.time.*;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
@@ -483,12 +484,9 @@ public void testSingletonLists() {
   // http://code.google.com/p/google-gson/issues/detail?id=270
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
-    a.map.put("date", new Date(0));
-    if (JavaVersion.isJava9OrLater()) {
-      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969, 4:00:00 PM\"}}", gson.toJson(a));
-    } else {
-      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
-    }
+    a.map.put("date", LocalDate.ofEpochDay(0L));
+    
+    assertEquals("{\"map\":{\"date\":{\"year\":1970,\"month\":1,\"day\":1}}}", gson.toJson(a));
   }
 
   public class HasObjectMap {
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 45020f0e9..884175be6 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -16,19 +16,12 @@
 
 package com.google.gson.functional;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.LongSerializationPolicy;
-import com.google.gson.reflect.TypeToken;
-import java.io.Serializable;
-import java.io.StringReader;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Arrays;
-import java.util.List;
-import junit.framework.TestCase;
+import com.google.gson.*;
+import com.google.gson.reflect.*;
+import java.io.*;
+import java.math.*;
+import java.util.*;
+import junit.framework.*;
 
 /**
  * Functional tests for Json primitive values: integers, and floating point numbers.
@@ -484,25 +477,6 @@ public void testBigDecimalNegativeInfinityDeserializationNotSupported() {
     }
   }
 
-  public void testLongAsStringSerialization() throws Exception {
-    gson = Gson.newBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).build();
-    String result = gson.toJson(15L);
-    assertEquals("\"15\"", result);
-
-    // Test with an integer and ensure its still a number
-    result = gson.toJson(2);
-    assertEquals("2", result);
-  }
-
-  public void testLongAsStringDeserialization() throws Exception {
-    long value = gson.fromJson("\"15\"", long.class);
-    assertEquals(15, value);
-
-    gson = Gson.newBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).build();
-    value = gson.fromJson("\"25\"", long.class);
-    assertEquals(25, value);
-  }
-
   public void testQuotedStringSerializationAndDeserialization() throws Exception {
     String value = "String Blah Blah Blah...1, 2, 3";
     String serializedForm = gson.toJson(value);
diff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index 0ff9579a9..a4fb661da 100644
--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -30,6 +30,7 @@
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.internal.Streams;
+import com.google.gson.internal.bind.*;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -197,7 +198,7 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
             }
             jsonObject = clone;
           }
-          Streams.write(jsonObject, out);
+          TypeAdapters.JSON_ELEMENT.write(out, jsonObject);
         }
       };
     }
