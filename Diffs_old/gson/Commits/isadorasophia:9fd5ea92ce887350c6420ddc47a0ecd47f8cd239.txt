diff --git a/gson/src/test/java/com/google/gson/internal/BoundaryValueTest.java b/gson/src/test/java/com/google/gson/internal/BoundaryValueTest.java
new file mode 100644
index 000000000..2598b7bf3
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/BoundaryValueTest.java
@@ -0,0 +1,97 @@
+package com.google.gson.internal;
+
+import java.lang.reflect.InvocationTargetException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import com.google.gson.internal.LinkedHashTreeMap.Node;
+import junit.framework.TestCase;
+
+/** Internal test cases for LinkedHashTreeMap -> doubleCapacity(), using boundary value analysis **/
+public class BoundaryValueTest extends TestCase {
+    public void testLowerBound() {
+        @SuppressWarnings("unchecked") // arrays and generics don't get along.
+        Node<String, String>[] oldTable = new Node[0];
+
+        Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);
+        assertEquals(0, newTable.length);
+    }
+    
+    public void testUpperBound() {
+        @SuppressWarnings("unchecked") // arrays and generics don't get along.
+        Node<String, String>[] oldTable = new Node[Integer.MAX_VALUE/32];
+        Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);
+        assertEquals(Integer.MAX_VALUE/16-1, newTable.length);
+    }
+    
+    public void testUpperBoundFails() {
+        @SuppressWarnings("unchecked") // arrays and generics don't get along.
+        Node<String, String>[] oldTable = new Node[Integer.MAX_VALUE/16];
+        
+        try {
+            LinkedHashTreeMap.doubleCapacity(oldTable);
+            fail();
+        } catch (OutOfMemoryError e) {
+            /* size not supported */
+        }
+    }
+    
+    /** Private helpers for helping with test validation **/
+    private static final Node<String, String> head = new Node<String, String>();
+    
+    private Node<String, String> node(String value) {
+        return new Node<String, String>(null, value, value.hashCode(), head, head);
+    }
+    
+    private Node<String, String> node(Node<String, String> left, String value,
+            Node<String, String> right) {
+        Node<String, String> result = node(value);
+        if (left != null) {
+            result.left = left;
+            left.parent = result;
+        }
+        if (right != null) {
+            result.right = right;
+            right.parent = result;
+        }
+        return result;
+    }
+    
+    private void assertTree(String expected, Node<?, ?> root) {
+        assertEquals(expected, toString(root));
+        assertConsistent(root);
+    }
+    
+    private void assertConsistent(Node<?, ?> node) {
+        int leftHeight = 0;
+        if (node.left != null) {
+            assertConsistent(node.left);
+            assertSame(node, node.left.parent);
+            leftHeight = node.left.height;
+        }
+        int rightHeight = 0;
+        if (node.right != null) {
+            assertConsistent(node.right);
+            assertSame(node, node.right.parent);
+            rightHeight = node.right.height;
+        }
+        if (node.parent != null) {
+            assertTrue(node.parent.left == node || node.parent.right == node);
+        }
+        if (Math.max(leftHeight, rightHeight) + 1 != node.height) {
+            fail();
+        }
+    }
+    
+    private String toString(Node<?, ?> root) {
+        if (root == null) {
+            return ".";
+        } else if (root.left == null && root.right == null) {
+            return String.valueOf(root.key);
+        } else {
+            return String.format("(%s %s %s)", toString(root.left), root.key, toString(root.right));
+        }
+    }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
index 0eb636204..8dab555c8 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
@@ -49,29 +49,4 @@ public void testSkipValue_filledJsonObject() throws IOException {
     in.skipValue();
     assertEquals(JsonToken.END_DOCUMENT, in.peek());
   }
-  
-  /** Test cases by applying the basic path algorithm **/
-  public void testPeek_basicPath() throws IOException {
-    /* path 1: json null object */
-    JsonTreeReader nullInstance = new JsonTreeReader(JsonNull.INSTANCE);
-    assertEquals(JsonToken.NULL, nullInstance.peek());
-    
-    /* path 2: json primitive */
-    JsonTreeReader primitiveInstance = new JsonTreeReader(new JsonPrimitive(5));
-    assertEquals(JsonToken.NUMBER, primitiveInstance.peek());
-    
-    /* path 3: json object */
-    JsonTreeReader objectInstance = new JsonTreeReader(new JsonObject());
-    assertEquals(JsonToken.BEGIN_OBJECT, objectInstance.peek());
-    
-    /* path 4: iterator */
-    /* create an object */
-    JsonArray jsonArray = new JsonArray();
-    jsonArray.add(1);
-    jsonArray.add("2");
-    
-    JsonTreeReader iteratorInstance = new JsonTreeReader(jsonArray);
-    iteratorInstance.beginArray();
-    assertEquals(JsonToken.NUMBER, iteratorInstance.peek());
-  }
 }
diff --git a/gson/src/test/java/com/google/gson/mc626/ControlFlowGraphTest.java b/gson/src/test/java/com/google/gson/mc626/ControlFlowGraphTest.java
index cadb0b5b0..91107853c 100644
--- a/gson/src/test/java/com/google/gson/mc626/ControlFlowGraphTest.java
+++ b/gson/src/test/java/com/google/gson/mc626/ControlFlowGraphTest.java
@@ -1,5 +1,57 @@
 package com.google.gson.mc626;
 
-public class ControlFlowGraphTest {
+import java.io.IOException;
 
+import com.google.gson.JsonArray;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.gson.stream.JsonToken;
+
+import junit.framework.TestCase;
+
+/** Test cases for JsonTreeReader, using control flow graph for test coverage **/
+@SuppressWarnings("resource")
+public class ControlFlowGraphTest extends TestCase {
+    public void testJsonObject() throws IOException {
+        JsonTreeReader objectInstance = new JsonTreeReader(new JsonObject());
+        assertEquals(JsonToken.BEGIN_OBJECT, objectInstance.peek());
+    }
+    
+    public void testJsonArray() throws IOException {
+        JsonTreeReader objectInstance = new JsonTreeReader(new JsonArray());
+        assertEquals(JsonToken.BEGIN_ARRAY, objectInstance.peek());
+    }
+    
+    public void testJsonIterator() throws IOException {
+        /* create an object */
+        JsonArray jsonArray = new JsonArray();
+        jsonArray.add(1);
+        jsonArray.add("2");
+        
+        JsonTreeReader iteratorInstance = new JsonTreeReader(jsonArray);
+        iteratorInstance.beginArray();
+        assertEquals(JsonToken.NUMBER, iteratorInstance.peek());
+    }
+    
+    public void testJsonPrimitiveNumber() throws IOException {
+        JsonTreeReader primitiveInstance = new JsonTreeReader(new JsonPrimitive(5));
+        assertEquals(JsonToken.NUMBER, primitiveInstance.peek());
+    }
+    
+    public void testJsonPrimitiveBoolean() throws IOException {
+        JsonTreeReader primitiveInstance = new JsonTreeReader(new JsonPrimitive(true));
+        assertEquals(JsonToken.BOOLEAN, primitiveInstance.peek());
+    }
+    
+    public void testJsonPrimitiveString() throws IOException {
+        JsonTreeReader primitiveInstance = new JsonTreeReader(new JsonPrimitive("string"));
+        assertEquals(JsonToken.STRING, primitiveInstance.peek());
+    }    
+
+    public void testJsonNull() throws IOException {
+        JsonTreeReader nullInstance = new JsonTreeReader(JsonNull.INSTANCE);
+        assertEquals(JsonToken.NULL, nullInstance.peek());
+    }
 }
