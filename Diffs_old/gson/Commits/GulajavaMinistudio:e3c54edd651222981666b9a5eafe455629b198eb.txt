diff --git a/gson/README b/gson/README
index ebae78030..a925a5cd0 100644
--- a/gson/README
+++ b/gson/README
@@ -1,5 +1,5 @@
-Gson is a Java library that can be used to convert a Java object into its 
-JSON representation. It can also be used to convert a JSON string into an 
+Gson is a Java library that can be used to convert Java Objects into their 
+JSON representation. It can also be used to convert a JSON string to an 
 equivalent Java object. Gson can work with arbitrary Java objects including 
 pre-existing objects that you do not have source-code of.
 
diff --git a/gson/src/main/java/com/google/gson/ExclusionStrategy.java b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
index 6a3f43fb5..ea452681c 100644
--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java
+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
@@ -20,7 +20,7 @@
  * A strategy (or policy) definition that is used to decide whether or not a field or top-level
  * class should be serialized or deserialized as part of the JSON output/input. For serialization,
  * if the {@link #shouldSkipClass(Class)} method returns true then that class or field type
- * will not be part of the JSON output.  For deserialization, if {@link #shouldSkipClass(Class)}
+ * will not be part of the JSON output. For deserialization, if {@link #shouldSkipClass(Class)}
  * returns true, then it will not be set as part of the Java object structure.
  *
  * <p>The following are a few examples that shows how you can use this exclusion mechanism.
diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
index 9be453ad1..f2f7c489a 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
@@ -19,9 +19,9 @@
 import java.lang.reflect.Field;
 
 /**
- * A mechanism for providing custom field naming in Gson.  This allows the client code to translate
+ * A mechanism for providing custom field naming in Gson. This allows the client code to translate
  * field names into a particular convention that is not supported as a normal Java field
- * declaration rules.  For example, Java does not support "-" characters in a field name.
+ * declaration rules. For example, Java does not support "-" characters in a field name.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index ba677e262..0cb171c71 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -80,7 +80,7 @@
  *
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
- * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
+ * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method. Here is an
  * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
diff --git a/gson/src/main/java/com/google/gson/JsonParseException.java b/gson/src/main/java/com/google/gson/JsonParseException.java
index 084f66127..c1f264d76 100644
--- a/gson/src/main/java/com/google/gson/JsonParseException.java
+++ b/gson/src/main/java/com/google/gson/JsonParseException.java
@@ -18,12 +18,12 @@
 
 /**
  * This exception is raised if there is a serious issue that occurs during parsing of a Json
- * string.  One of the main usages for this class is for the Gson infrastructure.  If the incoming
+ * string. One of the main usages for this class is for the Gson infrastructure. If the incoming
  * Json is bad/malicious, an instance of this exception is raised.
  *
- * <p>This exception is a {@link RuntimeException} because it is exposed to the client.  Using a
+ * <p>This exception is a {@link RuntimeException} because it is exposed to the client. Using a
  * {@link RuntimeException} avoids bad coding practices on the client side where they catch the
- * exception and do nothing.  It is often the case that you want to blow up if there is a parsing
+ * exception and do nothing. It is often the case that you want to blow up if there is a parsing
  * error (i.e. often clients do not know how to recover from a {@link JsonParseException}.</p>
  *
  * @author Inderjeet Singh
diff --git a/gson/src/main/java/com/google/gson/JsonStreamParser.java b/gson/src/main/java/com/google/gson/JsonStreamParser.java
index f0438db32..1c0c9b9d6 100644
--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java
@@ -33,7 +33,7 @@
  * 
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
- * synchronization.  For example:
+ * synchronization. For example:
  * 
  * <pre>
  * JsonStreamParser parser = new JsonStreamParser("['first'] {'second':10} 'third'");
diff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
index 7b732bab7..bb2b6666e 100644
--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
+++ b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java
@@ -27,7 +27,7 @@
 public enum LongSerializationPolicy {
   /**
    * This is the "default" serialization policy that will output a {@code long} object as a JSON
-   * number.  For example, assume an object has a long field named "f" then the serialized output
+   * number. For example, assume an object has a long field named "f" then the serialized output
    * would be:
    * {@code {"f":123}}.
    */
@@ -38,7 +38,7 @@
   },
   
   /**
-   * Serializes a long value as a quoted string.  For example, assume an object has a long field 
+   * Serializes a long value as a quoted string. For example, assume an object has a long field 
    * named "f" then the serialized output would be:
    * {@code {"f":"123"}}.
    */
diff --git a/gson/src/main/java/com/google/gson/annotations/SerializedName.java b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
index 9e8e4b8d4..82bb51cd5 100644
--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java
+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
@@ -28,7 +28,7 @@
  *
  * <p>This annotation will override any {@link com.google.gson.FieldNamingPolicy}, including
  * the default field naming policy, that may have been set on the {@link com.google.gson.Gson}
- * instance.  A different naming policy can set using the {@code GsonBuilder} class.  See
+ * instance. A different naming policy can set using the {@code GsonBuilder} class. See
  * {@link com.google.gson.GsonBuilder#setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)}
  * for more information.</p>
  *
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/gson/annotations/Until.java
index 676a4b959..8c38552b9 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/gson/annotations/Until.java
@@ -25,7 +25,7 @@
 /**
  * An annotation that indicates the version number until a member or a type should be present.
  * Basically, if Gson is created with a version number that exceeds the value stored in the
- * {@code Until} annotation then the field will be ignored from the JSON output.  This annotation
+ * {@code Until} annotation then the field will be ignored from the JSON output. This annotation
  * is useful to manage versioning of your JSON classes for a web-service.
  *
  * <p>
diff --git a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
index c53db7f23..8134ae2d1 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
@@ -31,7 +31,7 @@
 import java.lang.reflect.Type;
 
 /**
- * Functional Test exercising custom deserialization only.  When test applies to both
+ * Functional Test exercising custom deserialization only. When test applies to both
  * serialization and deserialization then add it to CustomTypeAdapterTest.
  *
  * @author Joel Leitch
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index f76dd18c3..b7307c6fc 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -87,20 +87,20 @@ protected void tearDown() throws Exception {
 
   public void testClassSerialization() {
     try {
-      gson.toJson(String.class);  
+      gson.toJson(String.class);
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals("\"java.lang.String\"", gson.toJson(String.class));  
+    assertEquals("\"java.lang.String\"", gson.toJson(String.class));
   }
 
   public void testClassDeserialization() {
     try {
-      gson.fromJson("String.class", String.class.getClass());  
+      gson.fromJson("String.class", String.class.getClass());
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));  
+    assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
   }
 
   public void testUrlSerialization() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
index b93ba0b59..475db8382 100644
--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
@@ -217,7 +217,7 @@ boolean queueContains(long... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     boolean setContains(float... values) {
@@ -235,7 +235,7 @@ boolean sortedSetContains(char... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     public String getExpectedJson() {
diff --git a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
index aad55eeb2..5437c876e 100644
--- a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
@@ -33,7 +33,7 @@
 import java.util.TreeSet;
 
 /**
- * Functional Test exercising custom serialization only.  When test applies to both
+ * Functional Test exercising custom serialization only. When test applies to both
  * serialization and deserialization then add it to CustomTypeAdapterTest.
  *
  * @author Inderjeet Singh
diff --git a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
index 7939a8c85..a9b77f1d8 100644
--- a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
@@ -163,7 +163,7 @@ public void testAbsentJsonElementsAreSetToNull() {
     assertFalse(target.bool2); // test the default value of a primitive boolean field per JVM spec
   }
 
-  public static class ClassWithInitializedMembers  {
+  public static class ClassWithInitializedMembers {
     // Using a mix of no-args constructor and field initializers
     // Also, some fields are intialized and some are not (so initialized per JVM spec)
     public static final String MY_STRING_DEFAULT = "string";
@@ -204,7 +204,7 @@ public void testExplicitNullSetsFieldToNullDuringDeserialization() {
     Gson gson = new Gson();
     String json = "{value:null}";
     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class);
-    assertNull(obj.value);    
+    assertNull(obj.value);
   }
 
   public void testCustomTypeAdapterPassesNullSerialization() {
diff --git a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
index 190603deb..85239c096 100644
--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
@@ -472,11 +472,11 @@ public boolean equals(Object obj) {
     @SuppressWarnings("unused")
     int q2 = 20;
   }
-  private interface Measurable<T> {    
+  private interface Measurable<T> {
   }
-  private interface Field<T> {    
+  private interface Field<T> {
   }
-  private interface Immutable {    
+  private interface Immutable {
   }
   
   public static final class Amount<Q extends Quantity> 
@@ -490,12 +490,12 @@ public void testDeepParameterizedTypeSerialization() {
     Amount<MyQuantity> amount = new Amount<MyQuantity>();
     String json = gson.toJson(amount);
     assertTrue(json.contains("value"));
-    assertTrue(json.contains("30"));    
+    assertTrue(json.contains("30"));
   }
   
   public void testDeepParameterizedTypeDeserialization() {
     String json = "{value:30}";
-    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();    
+    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();
     Amount<MyQuantity> amount = gson.fromJson(json, type);
     assertEquals(30, amount.value);
   }
diff --git a/gson/src/test/java/com/google/gson/functional/VersioningTest.java b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
index bc526de06..2416fc06d 100644
--- a/gson/src/test/java/com/google/gson/functional/VersioningTest.java
+++ b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
@@ -88,7 +88,7 @@ public void testIgnoreLaterVersionClassSerialization() {
   public void testIgnoreLaterVersionClassDeserialization() {
     Gson gson = builder.setVersion(1.0).create();
     String json = "{\"a\":3,\"b\":4,\"c\":5,\"d\":6}";
-    Version1_2 version1_2  = gson.fromJson(json, Version1_2.class);
+    Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);
     // Since the class is versioned to be after 1.0, we expect null
     // This is the new behavior in Gson 2.0
     assertNull(version1_2);
diff --git a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
index 431fc83dd..9e1807899 100644
--- a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
+++ b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
@@ -33,7 +33,7 @@
   }
 
   /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
    * to instantiate an interface
    */
   public void testInterfaceInstantiation() {
@@ -47,7 +47,7 @@ public void testInterfaceInstantiation() {
   }
 
   /**
-   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when trying
    * to instantiate an abstract class
    */
   public void testAbstractClassInstantiation() {
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
index aaa577b53..0f7c428d0 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -45,14 +45,16 @@
   /**
    * Test simplest case of recursion.
    */
+
   public void testRecursiveResolveSimple() {
     TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);
     assertNotNull(adapter);
   }
 
-  //
-  // Real-world samples, found in Issues #603 and #440.
-  //
+  /**
+   * Real-world samples, found in Issues #603 and #440.
+   */
+
   public void testIssue603PrintStream() {
     TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);
     assertNotNull(adapter);
@@ -63,9 +65,9 @@ public void testIssue440WeakReference() throws Exception {
     assertNotNull(adapter);
   }
 
-  //
-  // Tests belows check the behaviour of the methods changed for the fix
-  //
+  /**
+   * Tests belows check the behaviour of the methods changed for the fix.
+   */
 
   public void testDoubleSupertype() {
     assertEquals($Gson$Types.supertypeOf(Number.class),
@@ -87,9 +89,9 @@ public void testSubSupertype() {
             $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));
   }
 
-  //
-  // tests for recursion while resolving type variables
-  //
+  /**
+   * Tests for recursion while resolving type variables.
+   */
 
   private static class TestType<X> {
     TestType<? super X> superType;
diff --git a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
index cf444eee7..d05cf4be1 100644
--- a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
+++ b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
@@ -50,11 +50,11 @@ protected void setUp() throws Exception {
     gson = new Gson();
   }
   
-  public void testDummy() {    
+  public void testDummy() {
     // This is here to prevent Junit for complaining when we disable all tests.
-  }  
+  }
 
-  public void disabled_testStringDeserialization() {    
+  public void disabled_testStringDeserialization() {
     StringBuilder sb = new StringBuilder(8096);
     sb.append("Error Yippie");
 
@@ -138,8 +138,8 @@ public void disabled_testLargeCollectionDeserialization() {
     }    
     sb.append(']');
     String json = sb.toString();
-    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();    
-    List<CollectionEntry> list = gson.fromJson(json, collectionType);       
+    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();
+    List<CollectionEntry> list = gson.fromJson(json, collectionType);
     assertEquals(count, list.size());
   }
 
@@ -203,7 +203,7 @@ public void disabled_testSerializeClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Serialize classes avg time: %d ms\n", avg);     
+    System.out.printf("Serialize classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testDeserializeClasses() {
@@ -215,7 +215,7 @@ public void disabled_testDeserializeClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Deserialize classes avg time: %d ms\n", avg);     
+    System.out.printf("Deserialize classes avg time: %d ms\n", avg);
   }
   
   public void disable_testLargeObjectSerializationAndDeserialization() {
@@ -249,7 +249,7 @@ public void disabled_testSerializeExposedClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Serialize exposed classes avg time: %d ms\n", avg);     
+    System.out.printf("Serialize exposed classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testDeserializeExposedClasses() {
@@ -261,7 +261,7 @@ public void disabled_testDeserializeExposedClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf("Deserialize exposed classes avg time: %d ms\n", avg);     
+    System.out.printf("Deserialize exposed classes avg time: %d ms\n", avg);
   }
 
   public void disabled_testLargeGsonMapRoundTrip() throws Exception {
@@ -343,4 +343,4 @@ public ClassWithField(String field) {
       this.field = field; 
     } 
   }
-}
+}
\ No newline at end of file
