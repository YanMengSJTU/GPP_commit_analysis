diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index 315ff82e9..2ab1a1609 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -153,19 +153,6 @@ public boolean getAsBoolean() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
 
-  /**
-   * convenience method to get this element as a {@link Boolean} value.
-   *
-   * @return get this element as a {@link Boolean} value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * boolean value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  Boolean getAsBooleanWrapper() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
   /**
    * convenience method to get this element as a {@link Number}.
    *
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index d4640293e..5e95d5a82 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -91,16 +91,6 @@ public boolean isBoolean() {
     return value instanceof Boolean;
   }
 
-  /**
-   * convenience method to get this element as a {@link Boolean}.
-   *
-   * @return get this element as a {@link Boolean}.
-   */
-  @Override
-  Boolean getAsBooleanWrapper() {
-    return (Boolean) value;
-  }
-
   /**
    * convenience method to get this element as a boolean value.
    *
@@ -109,11 +99,10 @@ Boolean getAsBooleanWrapper() {
   @Override
   public boolean getAsBoolean() {
     if (isBoolean()) {
-      return getAsBooleanWrapper().booleanValue();
-    } else {
-      // Check to see if the value as a String is "true" in any case.
-      return Boolean.parseBoolean(getAsString());
+      return ((Boolean) value).booleanValue();
     }
+	// Check to see if the value as a String is "true" in any case.
+    return Boolean.parseBoolean(getAsString());
   }
 
   /**
@@ -155,7 +144,7 @@ public String getAsString() {
     if (isNumber()) {
       return getAsNumber().toString();
     } else if (isBoolean()) {
-      return getAsBooleanWrapper().toString();
+      return ((Boolean) value).toString();
     } else {
       return (String) value;
     }
diff --git a/gson/src/main/java/com/google/gson/internal/Primitives.java b/gson/src/main/java/com/google/gson/internal/Primitives.java
index a98f6242a..2506fd0a5 100644
--- a/gson/src/main/java/com/google/gson/internal/Primitives.java
+++ b/gson/src/main/java/com/google/gson/internal/Primitives.java
@@ -16,11 +16,7 @@
 
 package com.google.gson.internal;
 
-
 import java.lang.reflect.Type;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Contains static utility methods pertaining to primitive types and their
@@ -29,47 +25,13 @@
  * @author Kevin Bourrillion
  */
 public final class Primitives {
-  private Primitives() {
-    throw new UnsupportedOperationException();
-  }
-
-  /** A map from primitive types to their corresponding wrapper types. */
-  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;
-
-  /** A map from wrapper types to their corresponding primitive types. */
-  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;
-
-  // Sad that we can't use a BiMap. :(
-
-  static {
-    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);
-    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);
-
-    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
-    add(primToWrap, wrapToPrim, byte.class, Byte.class);
-    add(primToWrap, wrapToPrim, char.class, Character.class);
-    add(primToWrap, wrapToPrim, double.class, Double.class);
-    add(primToWrap, wrapToPrim, float.class, Float.class);
-    add(primToWrap, wrapToPrim, int.class, Integer.class);
-    add(primToWrap, wrapToPrim, long.class, Long.class);
-    add(primToWrap, wrapToPrim, short.class, Short.class);
-    add(primToWrap, wrapToPrim, void.class, Void.class);
-
-    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
-    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
-  }
-
-  private static void add(Map<Class<?>, Class<?>> forward,
-      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {
-    forward.put(key, value);
-    backward.put(value, key);
-  }
+  private Primitives() {}
 
   /**
    * Returns true if this type is a primitive.
    */
   public static boolean isPrimitive(Type type) {
-    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);
+    return type instanceof Class<?> && ((Class<?>) type).isPrimitive();
   }
 
   /**
@@ -79,8 +41,15 @@ public static boolean isPrimitive(Type type) {
    * @see Class#isPrimitive
    */
   public static boolean isWrapperType(Type type) {
-    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(
-        $Gson$Preconditions.checkNotNull(type));
+    return type == Integer.class
+        || type == Float.class
+        || type == Byte.class
+        || type == Double.class
+        || type == Long.class
+        || type == Character.class
+        || type == Boolean.class
+        || type == Short.class
+        || type == Void.class;
   }
 
   /**
@@ -92,12 +61,18 @@ public static boolean isWrapperType(Type type) {
    *     wrap(String.class) == String.class
    * </pre>
    */
+  @SuppressWarnings("unchecked")
   public static <T> Class<T> wrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(
-        $Gson$Preconditions.checkNotNull(type));
-    return (wrapped == null) ? type : wrapped;
+    if (type == int.class) return (Class<T>) Integer.class;
+    if (type == float.class) return (Class<T>) Float.class;
+    if (type == byte.class) return (Class<T>) Byte.class;
+    if (type == double.class) return (Class<T>) Double.class;
+    if (type == long.class) return (Class<T>) Long.class;
+    if (type == char.class) return (Class<T>) Character.class;
+    if (type == boolean.class) return (Class<T>) Boolean.class;
+    if (type == short.class) return (Class<T>) Short.class;
+    if (type == void.class) return (Class<T>) Void.class;
+    return type;
   }
 
   /**
@@ -109,11 +84,17 @@ public static boolean isWrapperType(Type type) {
    *     unwrap(String.class) == String.class
    * </pre>
    */
+  @SuppressWarnings("unchecked")
   public static <T> Class<T> unwrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(
-        $Gson$Preconditions.checkNotNull(type));
-    return (unwrapped == null) ? type : unwrapped;
+    if (type == Integer.class) return (Class<T>) int.class;
+    if (type == Float.class) return (Class<T>) float.class;
+    if (type == Byte.class) return (Class<T>) byte.class;
+    if (type == Double.class) return (Class<T>) double.class;
+    if (type == Long.class) return (Class<T>) long.class;
+    if (type == Character.class) return (Class<T>) char.class;
+    if (type == Boolean.class) return (Class<T>) boolean.class;
+    if (type == Short.class) return (Class<T>) short.class;
+    if (type == Void.class) return (Class<T>) void.class;
+    return type;
   }
 }
