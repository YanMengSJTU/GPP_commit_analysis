diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index bef790406..d9bb42cce 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -16,11 +16,7 @@
 
 package com.google.gson.internal;
 
-import com.google.gson.ExclusionStrategy;
-import com.google.gson.FieldAttributes;
-import com.google.gson.Gson;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
+import com.google.gson.*;
 import com.google.gson.annotations.Expose;
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
@@ -29,6 +25,7 @@
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -212,6 +209,28 @@ public boolean excludeClass(Class<?> clazz, boolean serialize) {
     return false;
   }
 
+  public boolean excludeGetterOrSetter(Method method, boolean serialize){
+    if (version != Excluder.IGNORE_VERSIONS
+            && !isValidVersion(method.getAnnotation(Since.class), method.getAnnotation(Until.class))) {
+      return true;
+    }
+    GetterSetterMethodAttributes gsatts;
+    try{
+      gsatts = new GetterSetterMethodAttributes(method);
+    } catch (IllegalArgumentException e){
+      return true;
+    }
+    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+    if (!list.isEmpty()) {
+      for (ExclusionStrategy exclusionStrategy : list) {
+        if (exclusionStrategy.shouldSkipGetterSetter(gsatts)){
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
   private boolean isAnonymousOrLocal(Class<?> clazz) {
     return !Enum.class.isAssignableFrom(clazz)
         && (clazz.isAnonymousClass() || clazz.isLocalClass());
