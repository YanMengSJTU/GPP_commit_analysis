diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 55f551d3d..76d35ac00 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -955,32 +955,9 @@ public long nextLong() throws IOException {
       return peekedLong;
     }
 
-    Long result = null;
-
-    slice: {
-      if (p == PEEKED_NUMBER) {
-        peekedString = new String(buffer, pos, peekedNumberLength);
-        pos += peekedNumberLength;
-      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
-      }
-    }
-
-    co_slice: {
-      if (p == PEEKED_NUMBER) {
-      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-        try {
-          result = Long.parseLong(peekedString);
-          peeked = PEEKED_NONE;
-          pathIndices[stackSize - 1]++;
-        } catch (NumberFormatException ignored) {
-          // Fall back to parse as a double below.
-        }
-      } else {
-        throw new IllegalStateException("Expected a long but was " + peek()
-                + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
-      }
-    }
+    Long result;
+    updatePeekedStringAndPos(p);
+    result = consumeAndGetLong(p);
 
     if (result != null) {
       return result;
@@ -999,6 +976,33 @@ public long nextLong() throws IOException {
     return result;
   }
 
+  private void updatePeekedStringAndPos(int p) throws IOException {
+    if (p == PEEKED_NUMBER) {
+      peekedString = new String(buffer, pos, peekedNumberLength);
+      pos += peekedNumberLength;
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+    }
+  }
+
+  private Long consumeAndGetLong(int p) throws IOException {
+    Long result = null;
+    if (p == PEEKED_NUMBER) {
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+      try {
+        result = Long.parseLong(peekedString);
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+      } catch (NumberFormatException ignored) {
+        // Fall back to parse as a double below.
+      }
+    } else {
+      throw new IllegalStateException("Expected a long but was " + peek()
+              + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    return result;
+  }
+
   /**
    * Returns the string up to but not including {@code quote}, unescaping any
    * character escape sequences encountered along the way. The opening quote
