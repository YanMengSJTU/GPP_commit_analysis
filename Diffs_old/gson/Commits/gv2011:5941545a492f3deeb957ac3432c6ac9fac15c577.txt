diff --git a/.gitignore b/.gitignore
index 14da0fac8..9947b6928 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
 /.settings/
 /.project
 /.classpath
-/target/
+/target/
\ No newline at end of file
diff --git a/LICENSE b/LICENSE
index d1edb3147..2343215ac 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Vinz Jsoncore (based on Google Gson)
+Vinz Gsoncore (based on Google Gson)
 
                                  Apache License
                            Version 2.0, January 2004
diff --git a/api/.gitignore b/api/.gitignore
deleted file mode 100644
index 9947b6928..000000000
--- a/api/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-/.settings/
-/.project
-/.classpath
-/target/
\ No newline at end of file
diff --git a/api/pom.xml b/api/pom.xml
deleted file mode 100644
index 7704415f9..000000000
--- a/api/pom.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-
-	<parent>
-		<groupId>com.github.gv2011</groupId>
-		<artifactId>jsoncore</artifactId>
-		<version>0.0.3-SNAPSHOT</version>
-	</parent>
-
-	<artifactId>jsoncore-api</artifactId>
-	
-	<dependencies>
-		<dependency>
-			<groupId>com.github.gv2011</groupId>
-			<artifactId>util</artifactId>
-		</dependency>
-	</dependencies>
-	
-</project>
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonNode.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonNode.java
deleted file mode 100644
index 5791671f9..000000000
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonNode.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package com.github.gv2011.jsoncore;
-
-public interface JsonNode {
-
-}
diff --git a/imp/pom.xml b/imp/pom.xml
index d537ab88a..f1133b203 100644
--- a/imp/pom.xml
+++ b/imp/pom.xml
@@ -4,11 +4,11 @@
 
 	<parent>
 		<groupId>com.github.gv2011</groupId>
-		<artifactId>jsoncore</artifactId>
+		<artifactId>gsoncore</artifactId>
 		<version>0.0.3-SNAPSHOT</version>
 	</parent>
 
-	<artifactId>jsoncore-imp</artifactId>
+	<artifactId>gsoncore-imp</artifactId>
 
 	<dependencies>
 		<dependency>
diff --git a/pom.xml b/pom.xml
index f335d38c9..df0ab9651 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,38 +1,48 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-
-	<parent>
-		<groupId>com.github.gv2011</groupId>
-		<artifactId>parent</artifactId>
-		<version>0.0.3-SNAPSHOT</version>
-	</parent>
-
-	<artifactId>jsoncore</artifactId>
-	<packaging>pom</packaging>
-
-	<name>Vinz Jsoncore</name>
-	<description>Json Reader and Writer (extracted from Gson)</description>
-	<url>https://github.com/gv2011/jsoncore</url>
-
-	<licenses>
-		<license>
-			<name>Apache 2.0</name>
-			<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-		</license>
-	</licenses>
-
-	<scm>
-		<connection>scm:git:git@github.com:gv2011/jsoncore.git</connection>
-		<developerConnection>scm:git:git@github.com:gv2011/jsoncore.git</developerConnection>
-		<url>https://github.com/gv2011/jsoncore</url>
-		<tag>HEAD</tag>
-	</scm>
-
-	<modules>
-		<module>api</module>
-		<module>imp</module>
-	</modules>
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.github.gv2011.jsoncore</groupId>
+    <artifactId>jsoncore-parent</artifactId>
+    <version>0.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>gsoncore</artifactId>
+
+  <name>Vinz Gsoncore</name>
+  <description>Json Reader and Writer (extracted from Gson)</description>
+  <url>https://github.com/gv2011/jsoncore</url>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <scm>
+    <connection>scm:git:git@github.com:gv2011/gsoncore.git</connection>
+    <developerConnection>scm:git:git@github.com:gv2011/gsoncore.git</developerConnection>
+    <url>https://github.com/gv2011/jsoncore</url>
+    <tag>HEAD</tag>
+  </scm>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.github.gv2011</groupId>
+      <artifactId>util</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.github.gv2011</groupId>
+      <artifactId>util-test</artifactId>
+    </dependency>
+      <dependency>
+        <groupId>com.google.code.gson</groupId>
+        <artifactId>gson</artifactId>
+        <scope>test</scope>
+      </dependency>
+  </dependencies>
 
 
 </project>
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java b/src/main/java/com/github/gv2011/gsoncore/JsonEncoder.java
similarity index 74%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonEncoder.java
index 93c4b4601..3108f427e 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonEncoder.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonEncoder.java
@@ -1,4 +1,4 @@
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 public interface JsonEncoder<T> {
 
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java b/src/main/java/com/github/gv2011/gsoncore/JsonFactory.java
similarity index 90%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonFactory.java
index 2d10b53c5..9c9bb02e3 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonFactory.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonFactory.java
@@ -1,4 +1,4 @@
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 import java.io.Reader;
 import java.io.Writer;
diff --git a/src/main/java/com/github/gv2011/gsoncore/JsonNode.java b/src/main/java/com/github/gv2011/gsoncore/JsonNode.java
new file mode 100644
index 000000000..03091c5c2
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonNode.java
@@ -0,0 +1,5 @@
+package com.github.gv2011.gsoncore;
+
+public interface JsonNode {
+
+}
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java b/src/main/java/com/github/gv2011/gsoncore/JsonOption.java
similarity index 98%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonOption.java
index f7a0443c6..ef576cb77 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonOption.java
@@ -1,4 +1,4 @@
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 public enum JsonOption {
 
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java b/src/main/java/com/github/gv2011/gsoncore/JsonParser.java
similarity index 88%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonParser.java
index 22db99c0c..f7e7348c7 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonParser.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonParser.java
@@ -1,4 +1,4 @@
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 import java.io.Closeable;
 
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonReader.java b/src/main/java/com/github/gv2011/gsoncore/JsonReader.java
similarity index 82%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonReader.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonReader.java
index 0afdd8c4a..cf3211c2d 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonReader.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonReader.java
@@ -1,4 +1,4 @@
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 import java.io.InputStream;
 
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java b/src/main/java/com/github/gv2011/gsoncore/JsonSerializer.java
similarity index 99%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonSerializer.java
index 76aa37239..e350630db 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonSerializer.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonSerializer.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 import java.io.Closeable;
 import java.io.Flushable;
diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java b/src/main/java/com/github/gv2011/gsoncore/JsonToken.java
similarity index 98%
rename from api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
rename to src/main/java/com/github/gv2011/gsoncore/JsonToken.java
index ae14fc243..ef93a4c55 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
+++ b/src/main/java/com/github/gv2011/gsoncore/JsonToken.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.github.gv2011.jsoncore;
+package com.github.gv2011.gsoncore;
 
 /**
  * A structure, name or value type in a JSON-encoded string.
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonFactoryImp.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonFactoryImp.java
new file mode 100644
index 000000000..888313642
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonFactoryImp.java
@@ -0,0 +1,56 @@
+package com.github.gv2011.gsoncore.imp;
+
+import static com.github.gv2011.util.ex.Exceptions.notYetImplementedException;
+
+import java.io.Reader;
+import java.io.Writer;
+import java.util.Arrays;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.gsoncore.JsonFactory;
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.JsonParser;
+import com.github.gv2011.gsoncore.JsonSerializer;
+import com.github.gv2011.gsoncore.imp.enc.EncoderSelector;
+import com.github.gv2011.gsoncore.imp.enc.StringEncoder;
+import com.github.gv2011.gsoncore.imp.enc.ToStringEncoder;
+
+public class JsonFactoryImp implements JsonFactory{
+
+
+  @Override
+  public JsonParser newJsonParser(final Reader reader, final JsonOption... jsonOptions) {
+    return new JsonReader(reader, jsonOptions);
+  }
+
+
+  @Override
+  public JsonSerializer newJsonSerializer(final Writer out, final JsonOption... jsonOptions) {
+    final boolean lenient = Arrays.asList(jsonOptions).contains(JsonOption.LENIENT);
+    return new JsonWriter(out, new EncoderSelector(lenient), 0, jsonOptions);
+  }
+
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public <T> JsonEncoder<T> newJsonEncoder(final Class<T> primitive, final JsonOption... jsonOptions) {
+    JsonEncoder<T> encoder;
+    if(primitive.equals(String.class)){
+      encoder = (JsonEncoder<T>)
+        new StringEncoder(Arrays.asList(jsonOptions).contains(JsonOption.HTML_SAFE))
+      ;
+    }
+    else if(primitive.equals(Long.class)||primitive.equals(long.class)){
+      encoder = new ToStringEncoder<>();
+    }
+    else throw new UnsupportedOperationException(primitive.getName());
+    return encoder;
+  }
+
+
+  @Override
+  public com.github.gv2011.gsoncore.JsonReader newJsonReader() {
+    throw notYetImplementedException();
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonParseException.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonParseException.java
new file mode 100644
index 000000000..f9862a2db
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonParseException.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+/**
+ * This exception is raised if there is a serious issue that occurs during parsing of a Json
+ * string.  One of the main usages for this class is for the Gson infrastructure.  If the incoming
+ * Json is bad/malicious, an instance of this exception is raised.
+ *
+ * <p>This exception is a {@link RuntimeException} because it is exposed to the client.  Using a
+ * {@link RuntimeException} avoids bad coding practices on the client side where they catch the
+ * exception and do nothing.  It is often the case that you want to blow up if there is a parsing
+ * error (i.e. often clients do not know how to recover from a {@link JsonParseException}.</p>
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+public class JsonParseException extends RuntimeException {
+  static final long serialVersionUID = -4086729973971783390L;
+
+  /**
+   * Creates exception with the specified message. If you are wrapping another exception, consider
+   * using {@link #JsonParseException(String, Throwable)} instead.
+   *
+   * @param msg error message describing a possible cause of this exception.
+   */
+  public JsonParseException(final String msg) {
+    super(msg);
+  }
+
+  /**
+   * Creates exception with the specified message and cause.
+   *
+   * @param msg error message describing what happened.
+   * @param cause root exception that caused this exception to be thrown.
+   */
+  public JsonParseException(final String msg, final Throwable cause) {
+    super(msg, cause);
+  }
+
+  /**
+   * Creates exception with the specified cause. Consider using
+   * {@link #JsonParseException(String, Throwable)} instead if you can describe what happened.
+   *
+   * @param cause root exception that caused this exception to be thrown.
+   */
+  public JsonParseException(final Throwable cause) {
+    super(cause);
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonReader.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonReader.java
new file mode 100644
index 000000000..8a5f839df
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonReader.java
@@ -0,0 +1,1580 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import static com.github.gv2011.util.ex.Exceptions.call;
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.Reader;
+import java.util.Arrays;
+
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.JsonParser;
+import com.github.gv2011.gsoncore.JsonToken;
+
+/**
+ * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
+ * encoded value as a stream of tokens. This stream includes both literal
+ * values (strings, numbers, booleans, and nulls) as well as the begin and
+ * end delimiters of objects and arrays. The tokens are traversed in
+ * depth-first order, the same order that they appear in the JSON document.
+ * Within JSON objects, name/value pairs are represented by a single token.
+ *
+ * <h3>Parsing JSON</h3>
+ * To create a recursive descent parser for your own JSON streams, first create
+ * an entry point method that creates a {@code JsonReader}.
+ *
+ * <p>Next, create handler methods for each structure in your JSON text. You'll
+ * need a method for each object type and for each array type.
+ * <ul>
+ *   <li>Within <strong>array handling</strong> methods, first call {@link
+ *       #beginArray} to consume the array's opening bracket. Then create a
+ *       while loop that accumulates values, terminating when {@link #hasNext}
+ *       is false. Finally, read the array's closing bracket by calling {@link
+ *       #endArray}.
+ *   <li>Within <strong>object handling</strong> methods, first call {@link
+ *       #beginObject} to consume the object's opening brace. Then create a
+ *       while loop that assigns values to local variables based on their name.
+ *       This loop should terminate when {@link #hasNext} is false. Finally,
+ *       read the object's closing brace by calling {@link #endObject}.
+ * </ul>
+ * <p>When a nested object or array is encountered, delegate to the
+ * corresponding handler method.
+ *
+ * <p>When an unknown name is encountered, strict parsers should fail with an
+ * exception. Lenient parsers should call {@link #skipValue()} to recursively
+ * skip the value's nested tokens, which may otherwise conflict.
+ *
+ * <p>If a value may be null, you should first check using {@link #peek()}.
+ * Null literals can be consumed using either {@link #nextNull()} or {@link
+ * #skipValue()}.
+ *
+ * <h3>Example</h3>
+ * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code
+ * [
+ *   {
+ *     "id": 912345678901,
+ *     "text": "How do I read a JSON stream in Java?",
+ *     "geo": null,
+ *     "user": {
+ *       "name": "json_newb",
+ *       "followers_count": 41
+ *      }
+ *   },
+ *   {
+ *     "id": 912345678902,
+ *     "text": "@json_newb just use JsonReader!",
+ *     "geo": [50.454722, -104.606667],
+ *     "user": {
+ *       "name": "jesse",
+ *       "followers_count": 2
+ *     }
+ *   }
+ * ]}</pre>
+ * This code implements the parser for the above structure: <pre>   {@code
+ *
+ *   public List<Message> readJsonStream(InputStream in) throws IOException {
+ *     JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+ *     try {
+ *       return readMessagesArray(reader);
+ *     } finally {
+ *       reader.close();
+ *     }
+ *   }
+ *
+ *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {
+ *     List<Message> messages = new ArrayList<Message>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       messages.add(readMessage(reader));
+ *     }
+ *     reader.endArray();
+ *     return messages;
+ *   }
+ *
+ *   public Message readMessage(JsonReader reader) throws IOException {
+ *     long id = -1;
+ *     String text = null;
+ *     User user = null;
+ *     List<Double> geo = null;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("id")) {
+ *         id = reader.nextLong();
+ *       } else if (name.equals("text")) {
+ *         text = reader.nextString();
+ *       } else if (name.equals("geo") && reader.peek() != JsonToken.NULL) {
+ *         geo = readDoublesArray(reader);
+ *       } else if (name.equals("user")) {
+ *         user = readUser(reader);
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new Message(id, text, user, geo);
+ *   }
+ *
+ *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {
+ *     List<Double> doubles = new ArrayList<Double>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       doubles.add(reader.nextDouble());
+ *     }
+ *     reader.endArray();
+ *     return doubles;
+ *   }
+ *
+ *   public User readUser(JsonReader reader) throws IOException {
+ *     String username = null;
+ *     int followersCount = -1;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("name")) {
+ *         username = reader.nextString();
+ *       } else if (name.equals("followers_count")) {
+ *         followersCount = reader.nextInt();
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new User(username, followersCount);
+ *   }}</pre>
+ *
+ * <h3>Number Handling</h3>
+ * This reader permits numeric values to be read as strings and string values to
+ * be read as numbers. For example, both elements of the JSON array {@code
+ * [1, "1"]} may be read using either {@link #nextInt} or {@link #nextString}.
+ * This behavior is intended to prevent lossy numeric conversions: double is
+ * JavaScript's only numeric type and very large values like {@code
+ * 9007199254740993} cannot be represented exactly on that platform. To minimize
+ * precision loss, extremely large values should be written and read as strings
+ * in JSON.
+ *
+ * <a name="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
+ * Web servers that serve private data using JSON may be vulnerable to <a
+ * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
+ * request forgery</a> attacks. In such an attack, a malicious site gains access
+ * to a private JSON file by executing it with an HTML {@code <script>} tag.
+ *
+ * <p>Prefixing JSON files with <code>")]}'\n"</code> makes them non-executable
+ * by {@code <script>} tags, disarming the attack. Since the prefix is malformed
+ * JSON, strict parsing fails when it is encountered. This class permits the
+ * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is
+ * enabled.
+ *
+ * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances
+ * of this class are not thread safe.
+ *
+ * @author Jesse Wilson
+ * @since 1.6
+ */
+public class JsonReader implements JsonParser {
+  /** The only non-execute prefix this parser permits */
+  private static final char[] NON_EXECUTE_PREFIX = ")]}'\n".toCharArray();
+  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
+
+  private static final int PEEKED_NONE = 0;
+  private static final int PEEKED_BEGIN_OBJECT = 1;
+  private static final int PEEKED_END_OBJECT = 2;
+  private static final int PEEKED_BEGIN_ARRAY = 3;
+  private static final int PEEKED_END_ARRAY = 4;
+  private static final int PEEKED_TRUE = 5;
+  private static final int PEEKED_FALSE = 6;
+  private static final int PEEKED_NULL = 7;
+  private static final int PEEKED_SINGLE_QUOTED = 8;
+  private static final int PEEKED_DOUBLE_QUOTED = 9;
+  private static final int PEEKED_UNQUOTED = 10;
+  /** When this is returned, the string value is stored in peekedString. */
+  private static final int PEEKED_BUFFERED = 11;
+  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
+  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
+  private static final int PEEKED_UNQUOTED_NAME = 14;
+  /** When this is returned, the integer value is stored in peekedLong. */
+  private static final int PEEKED_LONG = 15;
+  private static final int PEEKED_NUMBER = 16;
+  private static final int PEEKED_EOF = 17;
+
+  /* State machine when parsing numbers */
+  private static final int NUMBER_CHAR_NONE = 0;
+  private static final int NUMBER_CHAR_SIGN = 1;
+  private static final int NUMBER_CHAR_DIGIT = 2;
+  private static final int NUMBER_CHAR_DECIMAL = 3;
+  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;
+  private static final int NUMBER_CHAR_EXP_E = 5;
+  private static final int NUMBER_CHAR_EXP_SIGN = 6;
+  private static final int NUMBER_CHAR_EXP_DIGIT = 7;
+
+  /** The input JSON. */
+  private final Reader in;
+
+  /** True to accept non-spec compliant JSON */
+  private final boolean lenient;
+
+  /**
+   * Use a manual buffer to easily read and unread upcoming characters, and
+   * also so we can create strings without an intermediate StringBuilder.
+   * We decode literals directly out of this buffer, so it must be at least as
+   * long as the longest token that can be reported as a number.
+   */
+  private final char[] buffer = new char[1024];
+  private int pos = 0;
+  private int limit = 0;
+
+  private int lineNumber = 0;
+  private int lineStart = 0;
+
+  int peeked = PEEKED_NONE;
+
+  /**
+   * A peeked value that was composed entirely of digits with an optional
+   * leading dash. Positive values may not have a leading 0.
+   */
+  private long peekedLong;
+
+  /**
+   * The number of characters in a peeked number literal. Increment 'pos' by
+   * this after reading a number.
+   */
+  private int peekedNumberLength;
+
+  /**
+   * A peeked string that should be parsed on the next double, long or string.
+   * This is populated before a numeric value is parsed and used if that parsing
+   * fails.
+   */
+  private String peekedString;
+
+  /*
+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+   */
+  private int[] stack = new int[32];
+  private int stackSize = 0;
+  {
+    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
+  }
+
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
+
+  /**
+   * Creates a new instance that reads a JSON-encoded stream from {@code in}.
+   */
+  public JsonReader(final Reader in, final JsonOption... options) {
+    this.in = in;
+    lenient = Arrays.asList(options).contains(JsonOption.LENIENT);
+  }
+
+
+  /**
+   * Returns true if this parser is liberal in what it accepts.
+   */
+  public final boolean isLenient() {
+    return lenient;
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new array.
+   */
+  @Override
+  public void beginArray() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_BEGIN_ARRAY) {
+      push(JsonScope.EMPTY_ARRAY);
+      pathIndices[stackSize - 1] = 0;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * end of the current array.
+   */
+  @Override
+  public void endArray(){
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_END_ARRAY) {
+      stackSize--;
+      pathIndices[stackSize - 1]++;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new IllegalStateException("Expected END_ARRAY but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new object.
+   */
+  @Override
+  public void beginObject() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_BEGIN_OBJECT) {
+      push(JsonScope.EMPTY_OBJECT);
+      peeked = PEEKED_NONE;
+    } else {
+      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * end of the current object.
+   */
+  @Override
+  public void endObject(){
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_END_OBJECT) {
+      stackSize--;
+      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+      pathIndices[stackSize - 1]++;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new IllegalStateException("Expected END_OBJECT but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+  }
+
+  /**
+   * Returns true if the current array or object has another element.
+   */
+  public boolean hasNext() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
+  }
+
+  /**
+   * Returns the type of the next token without consuming it.
+   */
+  @Override
+  public JsonToken peek() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    switch (p) {
+    case PEEKED_BEGIN_OBJECT:
+      return JsonToken.BEGIN_OBJECT;
+    case PEEKED_END_OBJECT:
+      return JsonToken.END_OBJECT;
+    case PEEKED_BEGIN_ARRAY:
+      return JsonToken.BEGIN_ARRAY;
+    case PEEKED_END_ARRAY:
+      return JsonToken.END_ARRAY;
+    case PEEKED_SINGLE_QUOTED_NAME:
+    case PEEKED_DOUBLE_QUOTED_NAME:
+    case PEEKED_UNQUOTED_NAME:
+      return JsonToken.NAME;
+    case PEEKED_TRUE:
+    case PEEKED_FALSE:
+      return JsonToken.BOOLEAN;
+    case PEEKED_NULL:
+      return JsonToken.NULL;
+    case PEEKED_SINGLE_QUOTED:
+    case PEEKED_DOUBLE_QUOTED:
+    case PEEKED_UNQUOTED:
+    case PEEKED_BUFFERED:
+      return JsonToken.STRING;
+    case PEEKED_LONG:
+    case PEEKED_NUMBER:
+      return JsonToken.NUMBER;
+    case PEEKED_EOF:
+      return JsonToken.END_DOCUMENT;
+    default:
+      throw new AssertionError();
+    }
+  }
+
+  int doPeek(){
+    final int peekStack = stack[stackSize - 1];
+    if (peekStack == JsonScope.EMPTY_ARRAY) {
+      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
+    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
+      // Look for a comma before the next element.
+      final int c = nextNonWhitespace(true);
+      switch (c) {
+      case ']':
+        return peeked = PEEKED_END_ARRAY;
+      case ';':
+        checkLenient(); // fall-through
+      case ',':
+        break;
+      default:
+        throw syntaxError("Unterminated array");
+      }
+    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
+      stack[stackSize - 1] = JsonScope.DANGLING_NAME;
+      // Look for a comma before the next element.
+      if (peekStack == JsonScope.NONEMPTY_OBJECT) {
+        final int c = nextNonWhitespace(true);
+        switch (c) {
+        case '}':
+          return peeked = PEEKED_END_OBJECT;
+        case ';':
+          checkLenient(); // fall-through
+        case ',':
+          break;
+        default:
+          throw syntaxError("Unterminated object");
+        }
+      }
+      final int c = nextNonWhitespace(true);
+      switch (c) {
+      case '"':
+        return peeked = PEEKED_DOUBLE_QUOTED_NAME;
+      case '\'':
+        checkLenient();
+        return peeked = PEEKED_SINGLE_QUOTED_NAME;
+      case '}':
+        if (peekStack != JsonScope.NONEMPTY_OBJECT) {
+          return peeked = PEEKED_END_OBJECT;
+        } else {
+          throw syntaxError("Expected name");
+        }
+      default:
+        checkLenient();
+        pos--; // Don't consume the first character in an unquoted string.
+        if (isLiteral((char) c)) {
+          return peeked = PEEKED_UNQUOTED_NAME;
+        } else {
+          throw syntaxError("Expected name");
+        }
+      }
+    } else if (peekStack == JsonScope.DANGLING_NAME) {
+      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
+      // Look for a colon before the value.
+      final int c = nextNonWhitespace(true);
+      switch (c) {
+      case ':':
+        break;
+      case '=':
+        checkLenient();
+        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
+          pos++;
+        }
+        break;
+      default:
+        throw syntaxError("Expected ':'");
+      }
+    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
+      if (lenient) {
+        consumeNonExecutePrefix();
+      }
+      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
+    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
+      final int c = nextNonWhitespace(false);
+      if (c == -1) {
+        return peeked = PEEKED_EOF;
+      } else {
+        checkLenient();
+        pos--;
+      }
+    } else if (peekStack == JsonScope.CLOSED) {
+      throw new IllegalStateException("JsonReader is closed");
+    }
+
+    final int c = nextNonWhitespace(true);
+    switch (c) {
+    case ']':
+      if (peekStack == JsonScope.EMPTY_ARRAY) {
+        return peeked = PEEKED_END_ARRAY;
+      }
+      // fall-through to handle ",]"
+    case ';':
+    case ',':
+      // In lenient mode, a 0-length literal in an array means 'null'.
+      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
+        checkLenient();
+        pos--;
+        return peeked = PEEKED_NULL;
+      } else {
+        throw syntaxError("Unexpected value");
+      }
+    case '\'':
+      checkLenient();
+      return peeked = PEEKED_SINGLE_QUOTED;
+    case '"':
+      return peeked = PEEKED_DOUBLE_QUOTED;
+    case '[':
+      return peeked = PEEKED_BEGIN_ARRAY;
+    case '{':
+      return peeked = PEEKED_BEGIN_OBJECT;
+    default:
+      pos--; // Don't consume the first character in a literal value.
+    }
+
+    int result = peekKeyword();
+    if (result != PEEKED_NONE) {
+      return result;
+    }
+
+    result = peekNumber();
+    if (result != PEEKED_NONE) {
+      return result;
+    }
+
+    if (!isLiteral(buffer[pos])) {
+      throw syntaxError("Expected value");
+    }
+
+    checkLenient();
+    return peeked = PEEKED_UNQUOTED;
+  }
+
+  private int peekKeyword() {
+    // Figure out which keyword we're matching against by its first character.
+    char c = buffer[pos];
+    String keyword;
+    String keywordUpper;
+    int peeking;
+    if (c == 't' || c == 'T') {
+      keyword = "true";
+      keywordUpper = "TRUE";
+      peeking = PEEKED_TRUE;
+    } else if (c == 'f' || c == 'F') {
+      keyword = "false";
+      keywordUpper = "FALSE";
+      peeking = PEEKED_FALSE;
+    } else if (c == 'n' || c == 'N') {
+      keyword = "null";
+      keywordUpper = "NULL";
+      peeking = PEEKED_NULL;
+    } else {
+      return PEEKED_NONE;
+    }
+
+    // Confirm that chars [1..length) match the keyword.
+    final int length = keyword.length();
+    for (int i = 1; i < length; i++) {
+      if (pos + i >= limit && !fillBuffer(i + 1)) {
+        return PEEKED_NONE;
+      }
+      c = buffer[pos + i];
+      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {
+        return PEEKED_NONE;
+      }
+    }
+
+    if ((pos + length < limit || fillBuffer(length + 1))
+        && isLiteral(buffer[pos + length])) {
+      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!
+    }
+
+    // We've found the keyword followed either by EOF or by a non-literal character.
+    pos += length;
+    return peeked = peeking;
+  }
+
+  private int peekNumber() {
+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+    final char[] buffer = this.buffer;
+    int p = pos;
+    int l = limit;
+
+    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
+    boolean negative = false;
+    boolean fitsInLong = true;
+    int last = NUMBER_CHAR_NONE;
+
+    int i = 0;
+
+    charactersOfNumber:
+    for (; true; i++) {
+      if (p + i == l) {
+        if (i == buffer.length) {
+          // Though this looks like a well-formed number, it's too long to continue reading. Give up
+          // and let the application handle this as an unquoted literal.
+          return PEEKED_NONE;
+        }
+        if (!fillBuffer(i + 1)) {
+          break;
+        }
+        p = pos;
+        l = limit;
+      }
+
+      final char c = buffer[p + i];
+      switch (c) {
+      case '-':
+        if (last == NUMBER_CHAR_NONE) {
+          negative = true;
+          last = NUMBER_CHAR_SIGN;
+          continue;
+        } else if (last == NUMBER_CHAR_EXP_E) {
+          last = NUMBER_CHAR_EXP_SIGN;
+          continue;
+        }
+        return PEEKED_NONE;
+
+      case '+':
+        if (last == NUMBER_CHAR_EXP_E) {
+          last = NUMBER_CHAR_EXP_SIGN;
+          continue;
+        }
+        return PEEKED_NONE;
+
+      case 'e':
+      case 'E':
+        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
+          last = NUMBER_CHAR_EXP_E;
+          continue;
+        }
+        return PEEKED_NONE;
+
+      case '.':
+        if (last == NUMBER_CHAR_DIGIT) {
+          last = NUMBER_CHAR_DECIMAL;
+          continue;
+        }
+        return PEEKED_NONE;
+
+      default:
+        if (c < '0' || c > '9') {
+          if (!isLiteral(c)) {
+            break charactersOfNumber;
+          }
+          return PEEKED_NONE;
+        }
+        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
+          value = -(c - '0');
+          last = NUMBER_CHAR_DIGIT;
+        } else if (last == NUMBER_CHAR_DIGIT) {
+          if (value == 0) {
+            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
+          }
+          final long newValue = value * 10 - (c - '0');
+          fitsInLong &= value > MIN_INCOMPLETE_INTEGER
+              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
+          value = newValue;
+        } else if (last == NUMBER_CHAR_DECIMAL) {
+          last = NUMBER_CHAR_FRACTION_DIGIT;
+        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
+          last = NUMBER_CHAR_EXP_DIGIT;
+        }
+      }
+    }
+
+    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+      peekedLong = negative ? value : -value;
+      pos += i;
+      return peeked = PEEKED_LONG;
+    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
+        || last == NUMBER_CHAR_EXP_DIGIT) {
+      peekedNumberLength = i;
+      return peeked = PEEKED_NUMBER;
+    } else {
+      return PEEKED_NONE;
+    }
+  }
+
+  private boolean isLiteral(final char c) {
+    switch (c) {
+    case '/':
+    case '\\':
+    case ';':
+    case '#':
+    case '=':
+      checkLenient(); // fall-through
+    case '{':
+    case '}':
+    case '[':
+    case ']':
+    case ':':
+    case ',':
+    case ' ':
+    case '\t':
+    case '\f':
+    case '\r':
+    case '\n':
+      return false;
+    default:
+      return true;
+    }
+  }
+
+  /**
+   * Returns the next token, a {@link com.github.gv2011.gsoncore.JsonToken#NAME property name}, and
+   * consumes it.
+   *
+   * @throws java.io.IOException if the next token in the stream is not a property
+   *     name.
+   */
+  @Override
+  public String nextName() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    String result;
+    if (p == PEEKED_UNQUOTED_NAME) {
+      result = nextUnquotedValue();
+    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
+      result = nextQuotedValue('\'');
+    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
+      result = nextQuotedValue('"');
+    } else {
+      throw new IllegalStateException("Expected a name but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    peeked = PEEKED_NONE;
+    pathNames[stackSize - 1] = result;
+    return result;
+  }
+
+  /**
+   * Returns the {@link com.github.gv2011.gsoncore.JsonToken#STRING string} value of the next token,
+   * consuming it. If the next token is a number, this method will return its
+   * string form.
+   *
+   * @throws IllegalStateException if the next token is not a string or if
+   *     this reader is closed.
+   */
+  @Override
+  public String nextString() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    String result;
+    if (p == PEEKED_UNQUOTED) {
+      result = nextUnquotedValue();
+    } else if (p == PEEKED_SINGLE_QUOTED) {
+      result = nextQuotedValue('\'');
+    } else if (p == PEEKED_DOUBLE_QUOTED) {
+      result = nextQuotedValue('"');
+    } else if (p == PEEKED_BUFFERED) {
+      result = peekedString;
+      peekedString = null;
+    } else if (p == PEEKED_LONG) {
+      result = Long.toString(peekedLong);
+    } else if (p == PEEKED_NUMBER) {
+      result = new String(buffer, pos, peekedNumberLength);
+      pos += peekedNumberLength;
+    } else {
+      throw new IllegalStateException("Expected a string but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  /**
+   * Returns the {@link com.github.gv2011.gsoncore.JsonToken#BOOLEAN boolean} value of the next token,
+   * consuming it.
+   *
+   * @throws IllegalStateException if the next token is not a boolean or if
+   *     this reader is closed.
+   */
+  @Override
+  public boolean nextBoolean() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_TRUE) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return true;
+    } else if (p == PEEKED_FALSE) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return false;
+    }
+    throw new IllegalStateException("Expected a boolean but was " + peek()
+        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+  }
+
+  /**
+   * Consumes the next token from the JSON stream and asserts that it is a
+   * literal null.
+   *
+   * @throws IllegalStateException if the next token is not null or if this
+   *     reader is closed.
+   */
+  @Override
+  public void nextNull() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_NULL) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+    } else {
+      throw new IllegalStateException("Expected null but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+  }
+
+  /**
+   * Returns the {@link com.github.gv2011.gsoncore.JsonToken#NUMBER double} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a double using {@link Double#parseDouble(String)}.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a double, or is non-finite.
+   */
+  public double nextDouble() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    if (p == PEEKED_LONG) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return (double) peekedLong;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = new String(buffer, pos, peekedNumberLength);
+      pos += peekedNumberLength;
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+    } else if (p == PEEKED_UNQUOTED) {
+      peekedString = nextUnquotedValue();
+    } else if (p != PEEKED_BUFFERED) {
+      throw new IllegalStateException("Expected a double but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    final double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+      throw new MalformedJsonException("JSON forbids NaN and infinities: " + result
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  /**
+   * Returns the {@link com.github.gv2011.gsoncore.JsonToken#NUMBER long} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a long. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code long}, this method throws.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as a long.
+   */
+  public long nextLong() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    if (p == PEEKED_LONG) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return peekedLong;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = new String(buffer, pos, peekedNumberLength);
+      pos += peekedNumberLength;
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+      }
+      try {
+        final long result = Long.parseLong(peekedString);
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+        return result;
+      } catch (final NumberFormatException ignored) {
+        // Fall back to parse as a double below.
+      }
+    } else {
+      throw new IllegalStateException("Expected a long but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    final double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    final long result = (long) asDouble;
+    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
+      throw new NumberFormatException("Expected a long but was " + peekedString
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  /**
+   * Returns the string up to but not including {@code quote}, unescaping any
+   * character escape sequences encountered along the way. The opening quote
+   * should have already been read. This consumes the closing quote, but does
+   * not include it in the returned string.
+   *
+   * @param quote either ' or ".
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
+   */
+  private String nextQuotedValue(final char quote) {
+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+    final char[] buffer = this.buffer;
+    final StringBuilder builder = new StringBuilder();
+    while (true) {
+      int p = pos;
+      int l = limit;
+      /* the index of the first character not yet appended to the builder. */
+      int start = p;
+      while (p < l) {
+        final int c = buffer[p++];
+
+        if (c == quote) {
+          pos = p;
+          builder.append(buffer, start, p - start - 1);
+          return builder.toString();
+        } else if (c == '\\') {
+          pos = p;
+          builder.append(buffer, start, p - start - 1);
+          builder.append(readEscapeCharacter());
+          p = pos;
+          l = limit;
+          start = p;
+        } else if (c == '\n') {
+          lineNumber++;
+          lineStart = p;
+        }
+      }
+
+      builder.append(buffer, start, p - start);
+      pos = p;
+      if (!fillBuffer(1)) {
+        throw syntaxError("Unterminated string");
+      }
+    }
+  }
+
+  /**
+   * Returns an unquoted value as a string.
+   */
+  @SuppressWarnings("fallthrough")
+  private String nextUnquotedValue() {
+    StringBuilder builder = null;
+    int i = 0;
+
+    findNonLiteralCharacter:
+    while (true) {
+      for (; pos + i < limit; i++) {
+        switch (buffer[pos + i]) {
+        case '/':
+        case '\\':
+        case ';':
+        case '#':
+        case '=':
+          checkLenient(); // fall-through
+        case '{':
+        case '}':
+        case '[':
+        case ']':
+        case ':':
+        case ',':
+        case ' ':
+        case '\t':
+        case '\f':
+        case '\r':
+        case '\n':
+          break findNonLiteralCharacter;
+        }
+      }
+
+      // Attempt to load the entire literal into the buffer at once.
+      if (i < buffer.length) {
+        if (fillBuffer(i + 1)) {
+          continue;
+        } else {
+          break;
+        }
+      }
+
+      // use a StringBuilder when the value is too long. This is too long to be a number!
+      if (builder == null) {
+        builder = new StringBuilder();
+      }
+      builder.append(buffer, pos, i);
+      pos += i;
+      i = 0;
+      if (!fillBuffer(1)) {
+        break;
+      }
+    }
+
+    String result;
+    if (builder == null) {
+      result = new String(buffer, pos, i);
+    } else {
+      builder.append(buffer, pos, i);
+      result = builder.toString();
+    }
+    pos += i;
+    return result;
+  }
+
+  private void skipQuotedValue(final char quote) {
+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+    final char[] buffer = this.buffer;
+    do {
+      int p = pos;
+      int l = limit;
+      /* the index of the first character not yet appended to the builder. */
+      while (p < l) {
+        final int c = buffer[p++];
+        if (c == quote) {
+          pos = p;
+          return;
+        } else if (c == '\\') {
+          pos = p;
+          readEscapeCharacter();
+          p = pos;
+          l = limit;
+        } else if (c == '\n') {
+          lineNumber++;
+          lineStart = p;
+        }
+      }
+      pos = p;
+    } while (fillBuffer(1));
+    throw syntaxError("Unterminated string");
+  }
+
+  private void skipUnquotedValue() {
+    do {
+      int i = 0;
+      for (; pos + i < limit; i++) {
+        switch (buffer[pos + i]) {
+        case '/':
+        case '\\':
+        case ';':
+        case '#':
+        case '=':
+          checkLenient(); // fall-through
+        case '{':
+        case '}':
+        case '[':
+        case ']':
+        case ':':
+        case ',':
+        case ' ':
+        case '\t':
+        case '\f':
+        case '\r':
+        case '\n':
+          pos += i;
+          return;
+        }
+      }
+      pos += i;
+    } while (fillBuffer(1));
+  }
+
+  /**
+   * Returns the {@link com.github.gv2011.gsoncore.JsonToken#NUMBER int} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as an int. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code int}, this method throws.
+   *
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as an int.
+   */
+  public int nextInt() {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    int result;
+    if (p == PEEKED_LONG) {
+      result = (int) peekedLong;
+      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
+        throw new NumberFormatException("Expected an int but was " + peekedLong
+            + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      }
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return result;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = new String(buffer, pos, peekedNumberLength);
+      pos += peekedNumberLength;
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+      }
+      try {
+        result = Integer.parseInt(peekedString);
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+        return result;
+      } catch (final NumberFormatException ignored) {
+        // Fall back to parse as a double below.
+      }
+    } else {
+      throw new IllegalStateException("Expected an int but was " + peek()
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    final double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    result = (int) asDouble;
+    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
+      throw new NumberFormatException("Expected an int but was " + peekedString
+          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  /**
+   * Closes this JSON reader and the underlying {@link java.io.Reader}.
+   */
+  @Override
+  public void close() {
+    peeked = PEEKED_NONE;
+    stack[0] = JsonScope.CLOSED;
+    stackSize = 1;
+    run(in::close);
+  }
+
+  /**
+   * Skips the next value recursively. If it is an object or array, all nested
+   * elements are skipped. This method is intended for use when the JSON token
+   * stream contains unrecognized or unhandled values.
+   */
+  public void skipValue() {
+    int count = 0;
+    do {
+      int p = peeked;
+      if (p == PEEKED_NONE) {
+        p = doPeek();
+      }
+
+      if (p == PEEKED_BEGIN_ARRAY) {
+        push(JsonScope.EMPTY_ARRAY);
+        count++;
+      } else if (p == PEEKED_BEGIN_OBJECT) {
+        push(JsonScope.EMPTY_OBJECT);
+        count++;
+      } else if (p == PEEKED_END_ARRAY) {
+        stackSize--;
+        count--;
+      } else if (p == PEEKED_END_OBJECT) {
+        stackSize--;
+        count--;
+      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
+        skipUnquotedValue();
+      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
+        skipQuotedValue('\'');
+      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
+        skipQuotedValue('"');
+      } else if (p == PEEKED_NUMBER) {
+        pos += peekedNumberLength;
+      }
+      peeked = PEEKED_NONE;
+    } while (count != 0);
+
+    pathIndices[stackSize - 1]++;
+    pathNames[stackSize - 1] = "null";
+  }
+
+  private void push(final int newTop) {
+    if (stackSize == stack.length) {
+      final int[] newStack = new int[stackSize * 2];
+      final int[] newPathIndices = new int[stackSize * 2];
+      final String[] newPathNames = new String[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
+      stack = newStack;
+      pathIndices = newPathIndices;
+      pathNames = newPathNames;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns true once {@code limit - pos >= minimum}. If the data is
+   * exhausted before that many characters are available, this returns
+   * false.
+   */
+  private boolean fillBuffer(int minimum) {
+    final char[] buffer = this.buffer;
+    lineStart -= pos;
+    if (limit != pos) {
+      limit -= pos;
+      System.arraycopy(buffer, pos, buffer, 0, limit);
+    } else {
+      limit = 0;
+    }
+
+    pos = 0;
+    int total;
+    while ((total = call(()->in.read(buffer, limit, buffer.length - limit))) != -1) {
+      limit += total;
+
+      // if this is the first read, consume an optional byte order mark (BOM) if it exists
+      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\ufeff') {
+        pos++;
+        lineStart++;
+        minimum++;
+      }
+
+      if (limit >= minimum) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  int getLineNumber() {
+    return lineNumber + 1;
+  }
+
+  int getColumnNumber() {
+    return pos - lineStart + 1;
+  }
+
+  /**
+   * Returns the next character in the stream that is neither whitespace nor a
+   * part of a comment. When this returns, the returned character is always at
+   * {@code buffer[pos-1]}; this means the caller can always push back the
+   * returned character by decrementing {@code pos}.
+   */
+  private int nextNonWhitespace(final boolean throwOnEof) {
+    /*
+     * This code uses ugly local variables 'p' and 'l' representing the 'pos'
+     * and 'limit' fields respectively. Using locals rather than fields saves
+     * a few field reads for each whitespace character in a pretty-printed
+     * document, resulting in a 5% speedup. We need to flush 'p' to its field
+     * before any (potentially indirect) call to fillBuffer() and reread both
+     * 'p' and 'l' after any (potentially indirect) call to the same method.
+     */
+    final char[] buffer = this.buffer;
+    int p = pos;
+    int l = limit;
+    while (true) {
+      if (p == l) {
+        pos = p;
+        if (!fillBuffer(1)) {
+          break;
+        }
+        p = pos;
+        l = limit;
+      }
+
+      final int c = buffer[p++];
+      if (c == '\n') {
+        lineNumber++;
+        lineStart = p;
+        continue;
+      } else if (c == ' ' || c == '\r' || c == '\t') {
+        continue;
+      }
+
+      if (c == '/') {
+        pos = p;
+        if (p == l) {
+          pos--; // push back '/' so it's still in the buffer when this method returns
+          final boolean charsLoaded = fillBuffer(2);
+          pos++; // consume the '/' again
+          if (!charsLoaded) {
+            return c;
+          }
+        }
+
+        checkLenient();
+        final char peek = buffer[pos];
+        switch (peek) {
+        case '*':
+          // skip a /* c-style comment */
+          pos++;
+          if (!skipTo("*/")) {
+            throw syntaxError("Unterminated comment");
+          }
+          p = pos + 2;
+          l = limit;
+          continue;
+
+        case '/':
+          // skip a // end-of-line comment
+          pos++;
+          skipToEndOfLine();
+          p = pos;
+          l = limit;
+          continue;
+
+        default:
+          return c;
+        }
+      } else if (c == '#') {
+        pos = p;
+        /*
+         * Skip a # hash end-of-line comment. The JSON RFC doesn't
+         * specify this behaviour, but it's required to parse
+         * existing documents. See http://b/2571423.
+         */
+        checkLenient();
+        skipToEndOfLine();
+        p = pos;
+        l = limit;
+      } else {
+        pos = p;
+        return c;
+      }
+    }
+    if (throwOnEof) {
+      throw new MalformedJsonException("End of input"
+          + " at line " + getLineNumber() + " column " + getColumnNumber());
+    } else {
+      return -1;
+    }
+  }
+
+  private void checkLenient(){
+    if (!lenient) {
+      throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
+    }
+  }
+
+  /**
+   * Advances the position until after the next newline character. If the line
+   * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+   * caller.
+   */
+  private void skipToEndOfLine() {
+    while (pos < limit || fillBuffer(1)) {
+      final char c = buffer[pos++];
+      if (c == '\n') {
+        lineNumber++;
+        lineStart = pos;
+        break;
+      } else if (c == '\r') {
+        break;
+      }
+    }
+  }
+
+  /**
+   * @param toFind a string to search for. Must not contain a newline.
+   */
+  private boolean skipTo(final String toFind) {
+    outer:
+    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
+      if (buffer[pos] == '\n') {
+        lineNumber++;
+        lineStart = pos + 1;
+        continue;
+      }
+      for (int c = 0; c < toFind.length(); c++) {
+        if (buffer[pos + c] != toFind.charAt(c)) {
+          continue outer;
+        }
+      }
+      return true;
+    }
+    return false;
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName()
+        + " at line " + getLineNumber() + " column " + getColumnNumber();
+  }
+
+  /**
+   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
+   * the current location in the JSON value.
+   */
+  public String getPath() {
+    final StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0, size = stackSize; i < size; i++) {
+      switch (stack[i]) {
+        case JsonScope.EMPTY_ARRAY:
+        case JsonScope.NONEMPTY_ARRAY:
+          result.append('[').append(pathIndices[i]).append(']');
+          break;
+
+        case JsonScope.EMPTY_OBJECT:
+        case JsonScope.DANGLING_NAME:
+        case JsonScope.NONEMPTY_OBJECT:
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+          break;
+
+        case JsonScope.NONEMPTY_DOCUMENT:
+        case JsonScope.EMPTY_DOCUMENT:
+        case JsonScope.CLOSED:
+          break;
+      }
+    }
+    return result.toString();
+  }
+
+  /**
+   * Unescapes the character identified by the character or characters that
+   * immediately follow a backslash. The backslash '\' should have already
+   * been read. This supports both unicode escapes "u000A" and two-character
+   * escapes "\n".
+   *
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
+   */
+  private char readEscapeCharacter() {
+    if (pos == limit && !fillBuffer(1)) {
+      throw syntaxError("Unterminated escape sequence");
+    }
+
+    final char escaped = buffer[pos++];
+    switch (escaped) {
+    case 'u':
+      if (pos + 4 > limit && !fillBuffer(4)) {
+        throw syntaxError("Unterminated escape sequence");
+      }
+      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
+      char result = 0;
+      for (int i = pos, end = i + 4; i < end; i++) {
+        final char c = buffer[i];
+        result <<= 4;
+        if (c >= '0' && c <= '9') {
+          result += (c - '0');
+        } else if (c >= 'a' && c <= 'f') {
+          result += (c - 'a' + 10);
+        } else if (c >= 'A' && c <= 'F') {
+          result += (c - 'A' + 10);
+        } else {
+          throw new NumberFormatException("\\u" + new String(buffer, pos, 4));
+        }
+      }
+      pos += 4;
+      return result;
+
+    case 't':
+      return '\t';
+
+    case 'b':
+      return '\b';
+
+    case 'n':
+      return '\n';
+
+    case 'r':
+      return '\r';
+
+    case 'f':
+      return '\f';
+
+    case '\n':
+      lineNumber++;
+      lineStart = pos;
+      // fall-through
+
+    case '\'':
+    case '"':
+    case '\\':
+    default:
+      return escaped;
+    }
+  }
+
+  /**
+   * Throws a new IO exception with the given message and a context snippet
+   * with this reader's content.
+   */
+  private MalformedJsonException syntaxError(final String message) {
+    throw new MalformedJsonException(message
+        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+  }
+
+  /**
+   * Consumes the non-execute prefix if it exists.
+   */
+  private void consumeNonExecutePrefix() {
+    // fast forward through the leading whitespace
+    nextNonWhitespace(true);
+    pos--;
+
+    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {
+      return;
+    }
+
+    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {
+      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {
+        return; // not a security token!
+      }
+    }
+
+    // we consumed a security token!
+    pos += NON_EXECUTE_PREFIX.length;
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonScope.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonScope.java
new file mode 100644
index 000000000..cbaf3ecef
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonScope.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+/**
+ * Lexical scoping elements within a JSON reader or writer.
+ *
+ * @author Jesse Wilson
+ * @since 1.6
+ */
+final class JsonScope {
+
+    /**
+     * An array with no elements requires no separators or newlines before
+     * it is closed.
+     */
+    static final byte EMPTY_ARRAY = 1;
+
+    /**
+     * A array with at least one value requires a comma and newline before
+     * the next element.
+     */
+    static final byte NONEMPTY_ARRAY = 2;
+
+    /**
+     * An object with no name/value pairs requires no separators or newlines
+     * before it is closed.
+     */
+    static final byte EMPTY_OBJECT = 3;
+
+    /**
+     * An object whose most recent element is a key. The next element must
+     * be a value.
+     */
+    static final byte DANGLING_NAME = 4;
+
+    /**
+     * An object with at least one name/value pair requires a comma and
+     * newline before the next element.
+     */
+    static final byte NONEMPTY_OBJECT = 5;
+
+    /**
+     * No object or array has been started.
+     */
+    static final byte EMPTY_DOCUMENT = 6;
+
+    /**
+     * A document with at an array or object.
+     */
+    static final byte NONEMPTY_DOCUMENT = 7;
+
+    /**
+     * A document that's been closed and cannot be accessed.
+     */
+    static final byte CLOSED = 8;
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter.java
new file mode 100644
index 000000000..08e8a7ed6
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter.java
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import static com.github.gv2011.gsoncore.imp.JsonScope.DANGLING_NAME;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_ARRAY;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_DOCUMENT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_OBJECT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_ARRAY;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_OBJECT;
+import static com.github.gv2011.util.ex.Exceptions.format;
+import static com.github.gv2011.util.ex.Exceptions.notYetImplementedException;
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.JsonSerializer;
+import com.github.gv2011.gsoncore.imp.enc.EncoderSelector;
+import com.github.gv2011.util.StringUtils;
+import com.github.gv2011.util.ser.ElementarySerializer;
+
+
+public class JsonWriter implements ElementarySerializer<Object,String,Appendable>, JsonSerializer {
+
+
+  /** The output data, containing at most one top-level array or object. */
+  private final Appendable out;
+
+  private byte[] stack = new byte[32];
+  private int stackSize = 0;
+  {
+    push(EMPTY_DOCUMENT);
+  }
+
+  /**
+   * A string containing a full set of spaces for a single level of
+   * indentation, or an empty string for no pretty printing.
+   */
+  private final String indent;
+
+  /**
+   * The name/value separator; either ":" or ": ".
+   */
+  private final String separator;
+
+  private final boolean lenient;
+
+  private final boolean htmlSafe;
+
+  private final Set<JsonOption> optList;
+
+  private final JsonEncoder<Void> nullEncoder;
+  private final JsonEncoder<String> stringEncoder;
+
+  private final EncoderSelector encoderSelector;
+
+  private boolean inKey;
+
+
+  /**
+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
+   * For best performance, ensure {@link Writer} is buffered; wrapping in
+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
+   *
+   * Sets the indentation string to be repeated for each level of indentation
+   * in the encoded document. If {@code indent.isEmpty()} the encoded document
+   * will be compact. Otherwise the encoded document will be more
+   * human-readable.
+   *
+   * @param indent the width of indentation (number of blanks).
+   *   If indent==0 the encoded document will be compact. Otherwise the encoded document will be more
+   *   human-readable.
+   *
+   */
+  public JsonWriter(
+    final Writer out, final EncoderSelector encoderSelector, final int indent, final JsonOption... options
+  ) {
+    this.out = out;
+    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
+    lenient = optList.contains(JsonOption.LENIENT);
+    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
+    this.encoderSelector = encoderSelector;
+    nullEncoder = encoderSelector.tryGetEncoder(Void.class).get();
+    stringEncoder = encoderSelector.tryGetEncoder(String.class).get();
+
+    this.indent = StringUtils.multiply(" ",indent);
+    separator = indent<=0?":":": ";
+  }
+
+
+  /**
+   * Returns true if this writer has relaxed syntax rules.
+   */
+  public boolean isLenient() {
+    return lenient;
+  }
+
+
+  /**
+   * Returns true if this writer writes JSON that's safe for inclusion in HTML
+   * and XML documents.
+   */
+  public final boolean isHtmlSafe() {
+    return htmlSafe;
+  }
+
+
+  @Override
+  public void startList(){
+    checkNotInKey();
+    open(EMPTY_ARRAY, "[");
+  }
+
+
+  private void checkNotInKey() {
+    if(inKey) throw new IllegalStateException("Only strings may be used as keys.");
+  }
+
+
+  @Override
+  public void endList(){
+    close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+  }
+
+  @Override
+  public void startMap(){
+    checkNotInKey();
+    open(EMPTY_OBJECT, "{");
+  }
+
+
+  @Override
+  public void endMap(){
+    close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+  /**
+   * Enters a new scope by appending any necessary whitespace and the given
+   * bracket.
+   */
+  private JsonWriter open(final byte empty, final String openBracket){
+    beforeValue();
+    push(empty);
+    write(openBracket);
+    return this;
+  }
+
+  private void write(final String str) {
+    run(()->out.append(str));
+  }
+
+  /**
+   * Closes the current scope by appending any necessary whitespace and the
+   * given bracket.
+   */
+  private JsonWriter close(final int empty, final int nonempty, final String closeBracket)
+     {
+    final int context = peek();
+    if (context != nonempty && context != empty) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    if (inKey) {
+      throw new IllegalStateException("In key.");
+    }
+
+    stackSize--;
+    if (context == nonempty) {
+      newline();
+    }
+    write(closeBracket);
+    return this;
+  }
+
+  private void push(final byte newTop) {
+    if (stackSize == stack.length) {
+      final byte[] newStack = new byte[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      stack = newStack;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns the value on the top of the stack.
+   */
+  private int peek() {
+    if (isClosed()) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    return stack[stackSize - 1];
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(final byte topOfStack) {
+    stack[stackSize - 1] = topOfStack;
+  }
+
+
+
+  public boolean isClosed() {
+    return stackSize == 0;
+  }
+
+  private void checkNotClosed(){
+    if (isClosed()) throw new IllegalStateException("JsonWriter is closed.");
+  }
+
+
+  private void append(final String str) {
+    run(()->out.append(str));
+  }
+
+  private void append(final char c) {
+    run(()->out.append(c));
+  }
+
+
+
+  @Override
+  public void serializeElementary(final Object value){
+    if(inKey){
+      inKey=false;
+      if(value.getClass()!=String.class) throw new IllegalArgumentException(
+        format("Only strings allowed as keys.", value.getClass())
+      );
+    }
+    beforeValue();
+    encode(value, out);
+  }
+
+  private String encode(final Object value) {
+    return encoderSelector.selectEncoder(value).encode(value);
+  }
+
+  private void encode(final Object value, final Appendable out) {
+    encoderSelector.selectEncoder(value).encode(value, out);
+  }
+
+  /**
+   * Ensures all buffered data is written to the underlying {@link Appendable}.
+   */
+  @Override
+  public void flush(){
+    if (isClosed()) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+  }
+
+  /**
+   * Flushes and closes this writer and the underlying {@link Writer}.
+   *
+   * @throws IOException if the JSON document is incomplete.
+   */
+  @Override
+  public void endDocument(){
+    final int size = stackSize;
+    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IllegalStateException("Incomplete document");
+    }
+    stackSize = 0;
+  }
+
+
+  private void newline(){
+    if (indent.isEmpty()) {
+      return;
+    }
+
+    write("\n");
+    for (int i = 1, size = stackSize; i < size; i++) {
+      write(indent);
+    }
+  }
+
+  @Override
+  public void startBean(){
+    open(EMPTY_OBJECT, "{");
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a literal value,
+   * inline array, or inline object. Also adjusts the stack to expect either a
+   * closing bracket or another element.
+   */
+  @SuppressWarnings("fallthrough")
+  private void beforeValue(){
+    switch (peek()) {
+    case NONEMPTY_DOCUMENT:
+      if (!lenient) {
+        throw new IllegalStateException(
+            "JSON must have only one top-level value.");
+      }
+      // fall-through
+    case EMPTY_DOCUMENT: // first in document
+      replaceTop(NONEMPTY_DOCUMENT);
+      break;
+
+    case EMPTY_ARRAY: // first in array
+      replaceTop(NONEMPTY_ARRAY);
+      newline();
+      break;
+
+    case NONEMPTY_ARRAY: // another in array
+      run(()->out.append(','));
+      newline();
+      break;
+
+    case EMPTY_OBJECT: // first in object
+      replaceTop(DANGLING_NAME);
+      newline();
+      break;
+
+    case NONEMPTY_OBJECT: // another in object
+      replaceTop(DANGLING_NAME);
+      append(',');
+      newline();
+      break;
+
+    case DANGLING_NAME: // value for name
+      append(separator);
+      replaceTop(NONEMPTY_OBJECT);
+      break;
+
+    default:
+      throw new IllegalStateException("Nesting problem.");
+    }
+  }
+
+
+  @Override
+  public void startDocument() {
+  }
+
+
+
+  @Override
+  public void endBean() {
+    close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  @Override
+  public void startBeanEntry() {
+    final int context = peek();
+    if (context == NONEMPTY_OBJECT) { // first in object
+      this.
+      append(',');
+    } else if (context != EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem.");
+    }
+    newline();
+    replaceTop(DANGLING_NAME);
+  }
+
+
+
+  @Override
+  public void startBeanValue() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void endBeanEntry() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void startMapEntry() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void startMapValue() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void endMapEntry() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void serializeNull() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public void close() throws IOException {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer beginArray() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer endArray() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer beginObject() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer endObject() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer name(final String name) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final String value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer nullValue() {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final boolean value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final Boolean value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final double value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final long value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+  @Override
+  public JsonSerializer value(final Number value) {
+    // TODO Auto-generated method stub
+    throw notYetImplementedException();
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter3.java b/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter3.java
new file mode 100644
index 000000000..fb41cd3e8
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/JsonWriter3.java
@@ -0,0 +1,538 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import static com.github.gv2011.gsoncore.imp.JsonScope.DANGLING_NAME;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_ARRAY;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_DOCUMENT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.EMPTY_OBJECT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_ARRAY;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
+import static com.github.gv2011.gsoncore.imp.JsonScope.NONEMPTY_OBJECT;
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.gsoncore.JsonFactory;
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.JsonSerializer;
+
+
+public class JsonWriter3 implements JsonSerializer {
+
+
+  /** The output data, containing at most one top-level array or object. */
+  private final Writer out;
+
+  private int[] stack = new int[32];
+  private int stackSize = 0;
+  {
+    push(EMPTY_DOCUMENT);
+  }
+
+  /**
+   * A string containing a full set of spaces for a single level of
+   * indentation, or null for no pretty printing.
+   */
+  private String indent;
+
+  /**
+   * The name/value separator; either ":" or ": ".
+   */
+  private String separator = ":";
+
+  private final boolean lenient;
+
+  private final boolean htmlSafe;
+
+  private String deferredName;
+
+  private final boolean serializeNulls;
+  private final Set<JsonOption> optList;
+
+  private final JsonEncoder<String> stringEncoder;
+  private final JsonEncoder<Long> longEncoder;
+
+  /**
+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
+   * For best performance, ensure {@link Writer} is buffered; wrapping in
+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
+   */
+  public JsonWriter3(final Writer out, final JsonFactory factory, final JsonOption... options) {
+    this.out = out;
+    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
+    lenient = optList.contains(JsonOption.LENIENT);
+    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
+    serializeNulls = true;
+    stringEncoder = factory.newJsonEncoder(String.class, options);
+    longEncoder = factory.newJsonEncoder(Long.class, options);
+  }
+
+  /**
+   * Sets the indentation string to be repeated for each level of indentation
+   * in the encoded document. If {@code indent.isEmpty()} the encoded document
+   * will be compact. Otherwise the encoded document will be more
+   * human-readable.
+   *
+   * @param indent a string containing only whitespace.
+   */
+  public final void setIndent(final String indent) {
+    if (indent.length() == 0) {
+      this.indent = null;
+      separator = ":";
+    } else {
+      this.indent = indent;
+      separator = ": ";
+    }
+  }
+
+  /**
+   * Configure this writer to relax its syntax rules. By default, this writer
+   * only emits well-formed JSON as specified by <a
+   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
+   * to lenient permits the following:
+   * <ul>
+   *   <li>Top-level values of any type. With strict writing, the top-level
+   *       value must be an object or an array.
+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+   *       Double#isInfinite() infinities}.
+   * </ul>
+   */
+//  public final void setLenient(final boolean lenient) {
+//    this.lenient = lenient;
+//  }
+
+  /**
+   * Returns true if this writer has relaxed syntax rules.
+   */
+  public boolean isLenient() {
+    return lenient;
+  }
+
+  /**
+   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
+   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
+   * {@code &} and {@code =} before writing them to the stream. Without this
+   * setting, your XML/HTML encoder should replace these characters with the
+   * corresponding escape sequences.
+   */
+//  public final void setHtmlSafe(final boolean htmlSafe) {
+//    this.htmlSafe = htmlSafe;
+//  }
+
+  /**
+   * Returns true if this writer writes JSON that's safe for inclusion in HTML
+   * and XML documents.
+   */
+  public final boolean isHtmlSafe() {
+    return htmlSafe;
+  }
+
+  /**
+   * Sets whether object members are serialized when their value is null.
+   * This has no impact on array elements. The default is true.
+   */
+//  public final void setSerializeNulls(final boolean serializeNulls) {
+//    this.serializeNulls = serializeNulls;
+//  }
+
+  /**
+   * Returns true if object members are serialized when their value is null.
+   * This has no impact on array elements. The default is true.
+   */
+  public final boolean getSerializeNulls() {
+    return serializeNulls;
+  }
+
+  /**
+   * Begins encoding a new array. Each call to this method must be paired with
+   * a call to {@link #endArray}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 beginArray(){
+    writeDeferredName();
+    return open(EMPTY_ARRAY, "[");
+  }
+
+  /**
+   * Ends encoding the current array.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 endArray(){
+    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+  }
+
+  /**
+   * Begins encoding a new object. Each call to this method must be paired
+   * with a call to {@link #endObject}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 beginObject(){
+    writeDeferredName();
+    return open(EMPTY_OBJECT, "{");
+  }
+
+  /**
+   * Ends encoding the current object.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 endObject(){
+    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+  /**
+   * Enters a new scope by appending any necessary whitespace and the given
+   * bracket.
+   */
+  private JsonWriter3 open(final int empty, final String openBracket){
+    beforeValue();
+    push(empty);
+    write(openBracket);
+    return this;
+  }
+
+  private void write(final String str) {
+    run(()->out.write(str));
+  }
+
+  /**
+   * Closes the current scope by appending any necessary whitespace and the
+   * given bracket.
+   */
+  private JsonWriter3 close(final int empty, final int nonempty, final String closeBracket)
+     {
+    final int context = peek();
+    if (context != nonempty && context != empty) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException("Dangling name: " + deferredName);
+    }
+
+    stackSize--;
+    if (context == nonempty) {
+      newline();
+    }
+    write(closeBracket);
+    return this;
+  }
+
+  private void push(final int newTop) {
+    if (stackSize == stack.length) {
+      final int[] newStack = new int[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      stack = newStack;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns the value on the top of the stack.
+   */
+  private int peek() {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    return stack[stackSize - 1];
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(final int topOfStack) {
+    stack[stackSize - 1] = topOfStack;
+  }
+
+  /**
+   * Encodes the property name.
+   *
+   * @param name the name of the forthcoming value. May not be null.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 name(final String name){
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException();
+    }
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    deferredName = name;
+    return this;
+  }
+
+  private void writeDeferredName(){
+    if (deferredName != null) {
+      beforeName();
+      stringEncoder.encode(deferredName, out);
+      deferredName = null;
+    }
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final String value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    stringEncoder.encode(value, out);
+    return this;
+  }
+
+  /**
+   * Writes {@code value} directly to the writer without quoting or
+   * escaping.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonWriter3 jsonValue(final String value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    append(value);
+    return this;
+  }
+
+  private void append(final String str) {
+    run(()->out.append(str));
+  }
+
+  /**
+   * Encodes {@code null}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 nullValue(){
+    if (deferredName != null) {
+      if (serializeNulls) {
+        writeDeferredName();
+      } else {
+        deferredName = null;
+        return this; // skip the name and the value
+      }
+    }
+    beforeValue();
+    write("null");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final boolean value){
+    writeDeferredName();
+    beforeValue();
+    write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final Boolean value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final double value){
+    if (Double.isNaN(value) || Double.isInfinite(value)) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    writeDeferredName();
+    beforeValue();
+    append(Double.toString(value));
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final long value){
+    writeDeferredName();
+    beforeValue();
+    longEncoder.encode(value, out);
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final Number value){
+    if (value == null) {
+      return nullValue();
+    }
+
+    writeDeferredName();
+    final String string = value.toString();
+    if (!lenient
+        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    beforeValue();
+    append(string);
+    return this;
+  }
+
+  /**
+   * Ensures all buffered data is written to the underlying {@link Writer}
+   * and flushes that writer.
+   */
+  @Override
+  public void flush(){
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    run(out::flush);
+  }
+
+  /**
+   * Flushes and closes this writer and the underlying {@link Writer}.
+   *
+   * @throws IOException if the JSON document is incomplete.
+   */
+  @Override
+  public void close(){
+    run(out::close);
+
+    final int size = stackSize;
+    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IllegalStateException("Incomplete document");
+    }
+    stackSize = 0;
+  }
+
+
+  private void newline(){
+    if (indent == null) {
+      return;
+    }
+
+    write("\n");
+    for (int i = 1, size = stackSize; i < size; i++) {
+      write(indent);
+    }
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  private void beforeName(){
+    final int context = peek();
+    if (context == NONEMPTY_OBJECT) { // first in object
+      run(()->out.write(','));
+    } else if (context != EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem.");
+    }
+    newline();
+    replaceTop(DANGLING_NAME);
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a literal value,
+   * inline array, or inline object. Also adjusts the stack to expect either a
+   * closing bracket or another element.
+   */
+  @SuppressWarnings("fallthrough")
+  private void beforeValue(){
+    switch (peek()) {
+    case NONEMPTY_DOCUMENT:
+      if (!lenient) {
+        throw new IllegalStateException(
+            "JSON must have only one top-level value.");
+      }
+      // fall-through
+    case EMPTY_DOCUMENT: // first in document
+      replaceTop(NONEMPTY_DOCUMENT);
+      break;
+
+    case EMPTY_ARRAY: // first in array
+      replaceTop(NONEMPTY_ARRAY);
+      newline();
+      break;
+
+    case NONEMPTY_ARRAY: // another in array
+      run(()->out.append(','));
+      newline();
+      break;
+
+    case DANGLING_NAME: // value for name
+      append(separator);
+      replaceTop(NONEMPTY_OBJECT);
+      break;
+
+    default:
+      throw new IllegalStateException("Nesting problem.");
+    }
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/MalformedJsonException.java b/src/main/java/com/github/gv2011/gsoncore/imp/MalformedJsonException.java
new file mode 100644
index 000000000..e6ed20d66
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/MalformedJsonException.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+/**
+ * Thrown when a reader encounters malformed JSON. Some syntax errors can be
+ * ignored by calling {@link JsonReader#setLenient(boolean)}.
+ */
+public final class MalformedJsonException extends RuntimeException {
+  private static final long serialVersionUID = 1L;
+
+  public MalformedJsonException(final String msg) {
+    super(msg);
+  }
+
+  public MalformedJsonException(final String msg, final Throwable throwable) {
+    super(msg);
+    // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
+    // with a constructor with Throwable. This was done in Java 1.6
+    initCause(throwable);
+  }
+
+  public MalformedJsonException(final Throwable throwable) {
+    // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
+    // with a constructor with Throwable. This was done in Java 1.6
+    initCause(throwable);
+  }
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/VisibleForTesting.java b/src/main/java/com/github/gv2011/gsoncore/imp/VisibleForTesting.java
new file mode 100644
index 000000000..4385f61ed
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/VisibleForTesting.java
@@ -0,0 +1,5 @@
+package com.github.gv2011.gsoncore.imp;
+
+public @interface VisibleForTesting {
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/AbstractJsonEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/AbstractJsonEncoder.java
new file mode 100644
index 000000000..ab649ff6f
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/AbstractJsonEncoder.java
@@ -0,0 +1,31 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.StringWriter;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.util.ann.Nullable;
+
+abstract class AbstractJsonEncoder<T> implements JsonEncoder<T>{
+
+
+  protected AbstractJsonEncoder() {}
+
+  @Override
+  public String encode(final @Nullable T value) {
+    final StringWriter w = new StringWriter();
+    encode(value, w);
+    return w.toString();
+  }
+
+  protected final void write(final Appendable out, final String str) {
+    run(()->out.append(str));
+  }
+
+  protected final void write(final Appendable out, final String cbuf, final int off, final int len) {
+    run(()->out.append(cbuf, off, off+len));
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/BytesEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/BytesEncoder.java
new file mode 100644
index 000000000..3c46db0b7
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/BytesEncoder.java
@@ -0,0 +1,18 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.notYetImplementedException;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.util.bytes.Bytes;
+
+public class BytesEncoder extends AbstractJsonEncoder<Bytes>{
+
+  public BytesEncoder(final JsonEncoder<String> stringEncoder) {
+  }
+
+  @Override
+  public void encode(final Bytes value, final Appendable out) {
+    throw notYetImplementedException();
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/DoubleEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/DoubleEncoder.java
new file mode 100644
index 000000000..622cd0689
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/DoubleEncoder.java
@@ -0,0 +1,19 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import com.github.gv2011.util.ann.Nullable;
+
+public class DoubleEncoder extends NumberEncoder<Double>{
+
+  public DoubleEncoder(final boolean lenient) {
+    super(lenient);
+  }
+
+  @Override
+  protected String toString(final @Nullable Double value) {
+    if(value!=null)checkFinite(value);
+    final String result = super.toString(value);
+    return result;
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/EncoderSelector.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/EncoderSelector.java
new file mode 100644
index 000000000..c0b6c70f4
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/EncoderSelector.java
@@ -0,0 +1,112 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.format;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.util.bytes.Bytes;
+import com.github.gv2011.util.ser.TypeSupport;
+
+public class EncoderSelector implements TypeSupport<String,Object>{
+
+  private final Map<Class<?>,JsonEncoder<?>> encoders;
+
+  public EncoderSelector(final boolean lenient) {
+    encoders = buildEncoderMap(lenient);
+  }
+
+
+  @SuppressWarnings("unchecked")
+  public <T> JsonEncoder<T> selectEncoder(final T obj){
+    final Class<? extends Object> clazz = obj.getClass();
+    return (JsonEncoder<T>) tryGetEncoder(clazz)
+      .orElseThrow(()->new IllegalArgumentException(format("{} is not supported.", clazz)))
+    ;
+  }
+
+  @SuppressWarnings("unchecked")
+  public <T> Optional<JsonEncoder<T>> tryGetEncoder(final Class<T> type){
+    return Optional.ofNullable((JsonEncoder<T>) encoders.get(type));
+  }
+
+  private static Map<Class<?>, JsonEncoder<?>> buildEncoderMap(final boolean lenient) {
+    final Map<Class<?>,JsonEncoder<?>> encoders = new HashMap<>();
+    put(encoders, Void.class, new ToStringEncoder<>());
+    put(encoders, Boolean.class, new ToStringEncoder<>());
+    final JsonEncoder<String> stringEncoder = new StringEncoder();
+    put(encoders, String.class, stringEncoder);
+    put(encoders, Bytes.class, new BytesEncoder(stringEncoder));
+    put(encoders, Byte.class, new ToStringEncoder<>());
+    put(encoders, Short.class, new ToStringEncoder<>());
+    put(encoders, Integer.class, new ToStringEncoder<>());
+    put(encoders, Long.class, new ToStringEncoder<>());
+    put(encoders, BigInteger.class, new ToStringEncoder<>());
+    put(encoders, Float.class, new FloatEncoder(lenient));
+    put(encoders, Double.class, new DoubleEncoder(lenient));
+    put(encoders, BigDecimal.class, new ToStringEncoder<>());
+    put(encoders, BigInteger.class, new ToStringEncoder<>());
+    return Collections.unmodifiableMap(encoders);
+  }
+
+
+  private static <T> void put(
+    final Map<Class<?>, JsonEncoder<?>> encoders, final Class<T> clazz, final JsonEncoder<T> encoder
+  ) {
+    encoders.put(clazz, encoder);
+  }
+
+
+
+  @Override
+  public boolean isMap(final Object obj) {
+    return obj instanceof Map;
+  }
+
+  @Override
+  public Map<?,?> asMap(final Object obj) {
+    return (Map<?, ?>) obj;
+  }
+
+  @Override
+  public boolean isList(final Object obj) {
+    return obj instanceof Iterable;
+  }
+
+  @Override
+  public Iterable<?> asList(final Object obj) {
+    return (Iterable<?>) obj;
+  }
+
+
+  @Override
+  public boolean isBean(final Object obj) {
+    if(!(obj instanceof Map)) return false;
+    else return ((Map<?,?>)obj).keySet().parallelStream().allMatch(k->k.getClass()==String.class);
+  }
+
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public Map<String,?> asBean(final Object obj) {
+    return (Map<String,?>) obj;
+  }
+
+
+  @Override
+  public Object asElementary(final Object obj) {
+    return obj;
+  }
+
+
+  @Override
+  public boolean isElementary(final Object obj) {
+    return tryGetEncoder(obj.getClass()).isPresent();
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/FloatEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/FloatEncoder.java
new file mode 100644
index 000000000..3dda1aca1
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/FloatEncoder.java
@@ -0,0 +1,18 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import com.github.gv2011.util.ann.Nullable;
+
+public class FloatEncoder extends NumberEncoder<Float>{
+
+  public FloatEncoder(final boolean lenient) {
+    super(lenient);
+  }
+
+  @Override
+  protected String toString(final @Nullable Float value) {
+    if(value!=null)checkFinite(value);
+    final String result = super.toString(value);
+    return result;
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/NonStreamingEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/NonStreamingEncoder.java
new file mode 100644
index 000000000..deb8b6bf0
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/NonStreamingEncoder.java
@@ -0,0 +1,37 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import com.github.gv2011.gsoncore.JsonEncoder;
+import com.github.gv2011.util.ann.Nullable;
+
+abstract class NonStreamingEncoder<T> implements JsonEncoder<T>{
+
+
+  protected NonStreamingEncoder() {}
+
+  @Override
+  public final String encode(final @Nullable T value) {
+    return toString(value);
+  }
+
+  protected String toString(final @Nullable T value) {
+    return String.valueOf(value);
+  }
+
+  @Override
+  public final void encode(final @Nullable T value, final Appendable out) {
+    write(out, toString(value));
+  }
+
+
+  protected final void write(final Appendable out, final String str) {
+    run(()->out.append(str));
+  }
+
+  protected final void write(final Appendable out, final String cbuf, final int off, final int len) {
+    run(()->out.append(cbuf, off, off+len));
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/NumberEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/NumberEncoder.java
new file mode 100644
index 000000000..67561b881
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/NumberEncoder.java
@@ -0,0 +1,33 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+public class NumberEncoder<T extends Number> extends NonStreamingEncoder<T>{
+
+
+
+  private final boolean lenient;
+
+  @Override
+  protected String toString(final T value) {
+    final String result = super.toString(value);
+    checkFiniteStr(result);
+    return result;
+  }
+
+  public NumberEncoder(final boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  protected void checkFiniteStr(final String value){
+    if (!lenient && (value.equals("-Infinity") || value.equals("Infinity") || value.equals("NaN"))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+  }
+
+  protected void checkFinite(final double value){
+    if (!lenient && (Double.isInfinite(value) || Double.isNaN(value))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+  }
+
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/StringEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/StringEncoder.java
new file mode 100644
index 000000000..399d8f733
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/StringEncoder.java
@@ -0,0 +1,81 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+public class StringEncoder extends AbstractJsonEncoder<String>{
+
+    /*
+   * From RFC 7159, "All Unicode characters may be placed within the
+   * quotation marks except for the characters that must be escaped:
+   * quotation mark, reverse solidus, and the control characters
+   * (U+0000 through U+001F)."
+   *
+   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
+   * newline characters. This prevents eval() from failing with a syntax
+   * error. http://code.google.com/p/google-gson/issues/detail?id=341
+   */
+  static final String[] REPLACEMENT_CHARS;
+  static final String[] HTML_SAFE_REPLACEMENT_CHARS;
+  static {
+    REPLACEMENT_CHARS = new String[128];
+    for (int i = 0; i <= 0x1f; i++) {
+      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
+    }
+    REPLACEMENT_CHARS['"'] = "\\\"";
+    REPLACEMENT_CHARS['\\'] = "\\\\";
+    REPLACEMENT_CHARS['\t'] = "\\t";
+    REPLACEMENT_CHARS['\b'] = "\\b";
+    REPLACEMENT_CHARS['\n'] = "\\n";
+    REPLACEMENT_CHARS['\r'] = "\\r";
+    REPLACEMENT_CHARS['\f'] = "\\f";
+    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();
+    HTML_SAFE_REPLACEMENT_CHARS['<'] = "\\u003c";
+    HTML_SAFE_REPLACEMENT_CHARS['>'] = "\\u003e";
+    HTML_SAFE_REPLACEMENT_CHARS['&'] = "\\u0026";
+    HTML_SAFE_REPLACEMENT_CHARS['='] = "\\u003d";
+    HTML_SAFE_REPLACEMENT_CHARS['\''] = "\\u0027";
+  }
+
+
+  private final boolean htmlSafe;
+
+  public StringEncoder() {
+    this(false);
+  }
+
+  public StringEncoder(final boolean htmlSafe) {
+    this.htmlSafe = htmlSafe;
+  }
+
+  @Override
+  public void encode(final String value, final Appendable out) {
+    final String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
+    write(out, "\"");
+    int last = 0;
+    final int length = value.length();
+    for (int i = 0; i < length; i++) {
+      final char c = value.charAt(i);
+      String replacement;
+      if (c < 128) {
+        replacement = replacements[c];
+        if (replacement == null) {
+          continue;
+        }
+      } else if (c == '\u2028') {
+        replacement = "\\u2028";
+      } else if (c == '\u2029') {
+        replacement = "\\u2029";
+      } else {
+        continue;
+      }
+      if (last < i) {
+        write(out, value, last, i - last);
+      }
+      write(out, replacement);
+      last = i + 1;
+    }
+    if (last < length) {
+      write(out, value, last, length - last);
+    }
+    write(out, "\"");
+  }
+
+}
diff --git a/src/main/java/com/github/gv2011/gsoncore/imp/enc/ToStringEncoder.java b/src/main/java/com/github/gv2011/gsoncore/imp/enc/ToStringEncoder.java
new file mode 100644
index 000000000..523cc4223
--- /dev/null
+++ b/src/main/java/com/github/gv2011/gsoncore/imp/enc/ToStringEncoder.java
@@ -0,0 +1,5 @@
+package com.github.gv2011.gsoncore.imp.enc;
+
+public class ToStringEncoder<T> extends NonStreamingEncoder<T>{
+
+}
diff --git a/src/main/resources/META-INF/services/com.github.gv2011.gsoncore.JsonFactory b/src/main/resources/META-INF/services/com.github.gv2011.gsoncore.JsonFactory
new file mode 100644
index 000000000..4f236e92c
--- /dev/null
+++ b/src/main/resources/META-INF/services/com.github.gv2011.gsoncore.JsonFactory
@@ -0,0 +1 @@
+com.github.gv2011.gsoncore.imp.JsonFactoryImp
diff --git a/src/test/java/com/github/gv2011/gsoncore/exp/GsonTest.java b/src/test/java/com/github/gv2011/gsoncore/exp/GsonTest.java
new file mode 100644
index 000000000..d50969bd7
--- /dev/null
+++ b/src/test/java/com/github/gv2011/gsoncore/exp/GsonTest.java
@@ -0,0 +1,26 @@
+package com.github.gv2011.gsoncore.exp;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.Test;
+
+import com.google.gson.Gson;
+
+public class GsonTest {
+
+  @Test
+  public void test() {
+    final Map<Object,Object> map = new HashMap<>();
+    final List<Object> list = new ArrayList<>();
+    list.add("i");
+    list.add(7);
+//    map.put("a", 2);
+    map.put(4, 3);
+//    map.put(null, 4);
+    System.out.println(new Gson().toJson(map));
+  }
+
+}
diff --git a/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderPathTest.java b/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderPathTest.java
new file mode 100644
index 000000000..f62b19de8
--- /dev/null
+++ b/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderPathTest.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.imp.JsonReader;
+
+import junit.framework.TestCase;
+
+@SuppressWarnings("resource")
+public class JsonReaderPathTest extends TestCase {
+  public void testPath() throws IOException {
+    final JsonReader reader = new JsonReader(
+        new StringReader("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}"));
+    assertEquals("$", reader.getPath());
+    reader.beginObject();
+    assertEquals("$.", reader.getPath());
+    reader.nextName();
+    assertEquals("$.a", reader.getPath());
+    reader.beginArray();
+    assertEquals("$.a[0]", reader.getPath());
+    reader.nextInt();
+    assertEquals("$.a[1]", reader.getPath());
+    reader.nextBoolean();
+    assertEquals("$.a[2]", reader.getPath());
+    reader.nextBoolean();
+    assertEquals("$.a[3]", reader.getPath());
+    reader.nextNull();
+    assertEquals("$.a[4]", reader.getPath());
+    reader.nextString();
+    assertEquals("$.a[5]", reader.getPath());
+    reader.beginObject();
+    assertEquals("$.a[5].", reader.getPath());
+    reader.nextName();
+    assertEquals("$.a[5].c", reader.getPath());
+    reader.nextString();
+    assertEquals("$.a[5].c", reader.getPath());
+    reader.endObject();
+    assertEquals("$.a[6]", reader.getPath());
+    reader.beginArray();
+    assertEquals("$.a[6][0]", reader.getPath());
+    reader.nextInt();
+    assertEquals("$.a[6][1]", reader.getPath());
+    reader.endArray();
+    assertEquals("$.a[7]", reader.getPath());
+    reader.endArray();
+    assertEquals("$.a", reader.getPath());
+    reader.endObject();
+    assertEquals("$", reader.getPath());
+  }
+
+  public void testObjectPath() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+    assertEquals("$", reader.getPath());
+
+    reader.peek();
+    assertEquals("$", reader.getPath());
+    reader.beginObject();
+    assertEquals("$.", reader.getPath());
+
+    reader.peek();
+    assertEquals("$.", reader.getPath());
+    reader.nextName();
+    assertEquals("$.a", reader.getPath());
+
+    reader.peek();
+    assertEquals("$.a", reader.getPath());
+    reader.nextInt();
+    assertEquals("$.a", reader.getPath());
+
+    reader.peek();
+    assertEquals("$.a", reader.getPath());
+    reader.nextName();
+    assertEquals("$.b", reader.getPath());
+
+    reader.peek();
+    assertEquals("$.b", reader.getPath());
+    reader.nextInt();
+    assertEquals("$.b", reader.getPath());
+
+    reader.peek();
+    assertEquals("$.b", reader.getPath());
+    reader.endObject();
+    assertEquals("$", reader.getPath());
+
+    reader.peek();
+    assertEquals("$", reader.getPath());
+    reader.close();
+    assertEquals("$", reader.getPath());
+  }
+
+  public void testArrayPath() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[1,2]"));
+    assertEquals("$", reader.getPath());
+
+    reader.peek();
+    assertEquals("$", reader.getPath());
+    reader.beginArray();
+    assertEquals("$[0]", reader.getPath());
+
+    reader.peek();
+    assertEquals("$[0]", reader.getPath());
+    reader.nextInt();
+    assertEquals("$[1]", reader.getPath());
+
+    reader.peek();
+    assertEquals("$[1]", reader.getPath());
+    reader.nextInt();
+    assertEquals("$[2]", reader.getPath());
+
+    reader.peek();
+    assertEquals("$[2]", reader.getPath());
+    reader.endArray();
+    assertEquals("$", reader.getPath());
+
+    reader.peek();
+    assertEquals("$", reader.getPath());
+    reader.close();
+    assertEquals("$", reader.getPath());
+  }
+
+  public void testMultipleTopLevelValuesInOneDocument() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[][]"), JsonOption.LENIENT);
+    reader.beginArray();
+    reader.endArray();
+    assertEquals("$", reader.getPath());
+    reader.beginArray();
+    reader.endArray();
+    assertEquals("$", reader.getPath());
+  }
+
+  public void testSkipArrayElements() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[1,2,3]"));
+    reader.beginArray();
+    reader.skipValue();
+    reader.skipValue();
+    assertEquals("$[2]", reader.getPath());
+  }
+
+  public void testSkipObjectNames() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1}"));
+    reader.beginObject();
+    reader.skipValue();
+    assertEquals("$.null", reader.getPath());
+  }
+
+  public void testSkipObjectValues() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+    reader.beginObject();
+    reader.nextName();
+    reader.skipValue();
+    assertEquals("$.null", reader.getPath());
+    reader.nextName();
+    assertEquals("$.b", reader.getPath());
+  }
+
+  public void testSkipNestedStructures() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[[1,2,3],4]"));
+    reader.beginArray();
+    reader.skipValue();
+    assertEquals("$[1]", reader.getPath());
+  }
+
+  public void testArrayOfObjects() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[{},{},{}]"));
+    reader.beginArray();
+    assertEquals("$[0]", reader.getPath());
+    reader.beginObject();
+    assertEquals("$[0].", reader.getPath());
+    reader.endObject();
+    assertEquals("$[1]", reader.getPath());
+    reader.beginObject();
+    assertEquals("$[1].", reader.getPath());
+    reader.endObject();
+    assertEquals("$[2]", reader.getPath());
+    reader.beginObject();
+    assertEquals("$[2].", reader.getPath());
+    reader.endObject();
+    assertEquals("$[3]", reader.getPath());
+    reader.endArray();
+    assertEquals("$", reader.getPath());
+  }
+
+  public void testArrayOfArrays() throws IOException {
+    final JsonReader reader = new JsonReader(new StringReader("[[],[],[]]"));
+    reader.beginArray();
+    assertEquals("$[0]", reader.getPath());
+    reader.beginArray();
+    assertEquals("$[0][0]", reader.getPath());
+    reader.endArray();
+    assertEquals("$[1]", reader.getPath());
+    reader.beginArray();
+    assertEquals("$[1][0]", reader.getPath());
+    reader.endArray();
+    assertEquals("$[2]", reader.getPath());
+    reader.beginArray();
+    assertEquals("$[2][0]", reader.getPath());
+    reader.endArray();
+    assertEquals("$[3]", reader.getPath());
+    reader.endArray();
+    assertEquals("$", reader.getPath());
+  }
+}
diff --git a/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderTest.java b/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderTest.java
new file mode 100644
index 000000000..a85a953a4
--- /dev/null
+++ b/src/test/java/com/github/gv2011/gsoncore/imp/JsonReaderTest.java
@@ -0,0 +1,1740 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import static com.github.gv2011.gsoncore.JsonToken.BEGIN_ARRAY;
+import static com.github.gv2011.gsoncore.JsonToken.BEGIN_OBJECT;
+import static com.github.gv2011.gsoncore.JsonToken.BOOLEAN;
+import static com.github.gv2011.gsoncore.JsonToken.END_ARRAY;
+import static com.github.gv2011.gsoncore.JsonToken.END_OBJECT;
+import static com.github.gv2011.gsoncore.JsonToken.NAME;
+import static com.github.gv2011.gsoncore.JsonToken.NULL;
+import static com.github.gv2011.gsoncore.JsonToken.NUMBER;
+import static com.github.gv2011.gsoncore.JsonToken.STRING;
+
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.Arrays;
+
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.JsonToken;
+import com.github.gv2011.gsoncore.imp.JsonReader;
+import com.github.gv2011.gsoncore.imp.MalformedJsonException;
+
+import junit.framework.TestCase;
+
+@SuppressWarnings("resource")
+public final class JsonReaderTest extends TestCase {
+  public void testReadArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true, true]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadEmptyArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[]"));
+    reader.beginArray();
+    assertFalse(reader.hasNext());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\": \"android\", \"b\": \"banana\"}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("android", reader.nextString());
+    assertEquals("b", reader.nextName());
+    assertEquals("banana", reader.nextString());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testReadEmptyObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{}"));
+    reader.beginObject();
+    assertFalse(reader.hasNext());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    assertEquals(123, reader.nextInt());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipArrayAfterPeek() throws Exception {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(BEGIN_ARRAY, reader.peek());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    assertEquals(123, reader.nextInt());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipTopLevelObject() throws Exception {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\": [\"one\", \"two\", \"three\"], \"b\": 123}"));
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\": { \"c\": [], \"d\": [true, true, {}] }, \"b\": \"banana\"}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    reader.skipValue();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipObjectAfterPeek() throws Exception {
+    final String json = "{" + "  \"one\": { \"num\": 1 }"
+        + ", \"two\": { \"num\": 2 }" + ", \"three\": { \"num\": 3 }" + "}";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginObject();
+    assertEquals("one", reader.nextName());
+    assertEquals(BEGIN_OBJECT, reader.peek());
+    reader.skipValue();
+    assertEquals("two", reader.nextName());
+    assertEquals(BEGIN_OBJECT, reader.peek());
+    reader.skipValue();
+    assertEquals("three", reader.nextName());
+    reader.skipValue();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipInteger() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\":123456789,\"b\":-123456789}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    reader.skipValue();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipDouble() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(
+        "{\"a\":-123.456e-789,\"b\":123456789.0}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    reader.skipValue();
+    assertEquals("b", reader.nextName());
+    reader.skipValue();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testHelloWorld() throws MalformedJsonException {
+    final String json = "{\n" +
+        "   \"hello\": true,\n" +
+        "   \"foo\": [\"world\"]\n" +
+        "}";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginObject();
+    assertEquals("hello", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals("foo", reader.nextName());
+    reader.beginArray();
+    assertEquals("world", reader.nextString());
+    reader.endArray();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testEmptyString() {
+    try {
+      new JsonReader(reader("")).beginArray();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+    try {
+      new JsonReader(reader("")).beginObject();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testCharacterUnescaping() throws MalformedJsonException {
+    final String json = "[\"a\","
+        + "\"a\\\"\","
+        + "\"\\\"\","
+        + "\":\","
+        + "\",\","
+        + "\"\\b\","
+        + "\"\\f\","
+        + "\"\\n\","
+        + "\"\\r\","
+        + "\"\\t\","
+        + "\" \","
+        + "\"\\\\\","
+        + "\"{\","
+        + "\"}\","
+        + "\"[\","
+        + "\"]\","
+        + "\"\\u0000\","
+        + "\"\\u0019\","
+        + "\"\\u20AC\""
+        + "]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+    assertEquals("a\"", reader.nextString());
+    assertEquals("\"", reader.nextString());
+    assertEquals(":", reader.nextString());
+    assertEquals(",", reader.nextString());
+    assertEquals("\b", reader.nextString());
+    assertEquals("\f", reader.nextString());
+    assertEquals("\n", reader.nextString());
+    assertEquals("\r", reader.nextString());
+    assertEquals("\t", reader.nextString());
+    assertEquals(" ", reader.nextString());
+    assertEquals("\\", reader.nextString());
+    assertEquals("{", reader.nextString());
+    assertEquals("}", reader.nextString());
+    assertEquals("[", reader.nextString());
+    assertEquals("]", reader.nextString());
+    assertEquals("\0", reader.nextString());
+    assertEquals("\u0019", reader.nextString());
+    assertEquals("\u20AC", reader.nextString());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testUnescapingInvalidCharacters() throws MalformedJsonException {
+    final String json = "[\"\\u000g\"]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+  }
+
+  public void testUnescapingTruncatedCharacters() throws MalformedJsonException {
+    final String json = "[\"\\u000";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testUnescapingTruncatedSequence() throws MalformedJsonException {
+    final String json = "[\"\\";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testIntegersWithFractionalPartSpecified() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1.0,1.0,1.0]"));
+    reader.beginArray();
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(1, reader.nextInt());
+    assertEquals(1L, reader.nextLong());
+  }
+
+  public void testDoubles() throws MalformedJsonException {
+    final String json = "[-0.0,"
+        + "1.0,"
+        + "1.7976931348623157E308,"
+        + "4.9E-324,"
+        + "0.0,"
+        + "-0.5,"
+        + "2.2250738585072014E-308,"
+        + "3.141592653589793,"
+        + "2.718281828459045]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    assertEquals(-0.0, reader.nextDouble());
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(1.7976931348623157E308, reader.nextDouble());
+    assertEquals(4.9E-324, reader.nextDouble());
+    assertEquals(0.0, reader.nextDouble());
+    assertEquals(-0.5, reader.nextDouble());
+    assertEquals(2.2250738585072014E-308, reader.nextDouble());
+    assertEquals(3.141592653589793, reader.nextDouble());
+    assertEquals(2.718281828459045, reader.nextDouble());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[NaN]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.nextDouble();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictQuotedNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[\"NaN\"]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.nextDouble();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[NaN, -Infinity, Infinity]";
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+    reader.beginArray();
+    assertTrue(Double.isNaN(reader.nextDouble()));
+    assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());
+    assertEquals(Double.POSITIVE_INFINITY, reader.nextDouble());
+    reader.endArray();
+  }
+
+  public void testLenientQuotedNonFiniteDoubles() throws MalformedJsonException {
+    final String json = "[\"NaN\", \"-Infinity\", \"Infinity\"]";
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+    reader.beginArray();
+    assertTrue(Double.isNaN(reader.nextDouble()));
+    assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());
+    assertEquals(Double.POSITIVE_INFINITY, reader.nextDouble());
+    reader.endArray();
+  }
+
+  public void testStrictNonFiniteDoublesWithSkipValue() throws MalformedJsonException {
+    final String json = "[NaN]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLongs() throws MalformedJsonException {
+    final String json = "[0,0,0,"
+        + "1,1,1,"
+        + "-1,-1,-1,"
+        + "-9223372036854775808,"
+        + "9223372036854775807]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    assertEquals(0L, reader.nextLong());
+    assertEquals(0, reader.nextInt());
+    assertEquals(0.0, reader.nextDouble());
+    assertEquals(1L, reader.nextLong());
+    assertEquals(1, reader.nextInt());
+    assertEquals(1.0, reader.nextDouble());
+    assertEquals(-1L, reader.nextLong());
+    assertEquals(-1, reader.nextInt());
+    assertEquals(-1.0, reader.nextDouble());
+    try {
+      reader.nextInt();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals(Long.MIN_VALUE, reader.nextLong());
+    try {
+      reader.nextInt();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals(Long.MAX_VALUE, reader.nextLong());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void disabled_testNumberWithOctalPrefix() throws MalformedJsonException {
+    final String json = "[01]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+    try {
+      reader.nextInt();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+    try {
+      reader.nextDouble();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+    assertEquals("01", reader.nextString());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testBooleans() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true,false]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testPeekingUnquotedStringsPrefixedWithBooleans() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[truey]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    assertEquals("truey", reader.nextString());
+    reader.endArray();
+  }
+
+  public void testMalformedNumbers() throws MalformedJsonException {
+    assertNotANumber("-");
+    assertNotANumber(".");
+
+    // exponent lacks digit
+    assertNotANumber("e");
+    assertNotANumber("0e");
+    assertNotANumber(".e");
+    assertNotANumber("0.e");
+    assertNotANumber("-.0e");
+
+    // no integer
+    assertNotANumber("e1");
+    assertNotANumber(".e1");
+    assertNotANumber("-e1");
+
+    // trailing characters
+    assertNotANumber("1x");
+    assertNotANumber("1.1x");
+    assertNotANumber("1e1x");
+    assertNotANumber("1ex");
+    assertNotANumber("1.1ex");
+    assertNotANumber("1.1e1x");
+
+    // fraction has no digit
+    assertNotANumber("0.");
+    assertNotANumber("-0.");
+    assertNotANumber("0.e1");
+    assertNotANumber("-0.e1");
+
+    // no leading digit
+    assertNotANumber(".0");
+    assertNotANumber("-.0");
+    assertNotANumber(".0e1");
+    assertNotANumber("-.0e1");
+  }
+
+  private void assertNotANumber(final String s) throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[" + s + "]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(JsonToken.STRING, reader.peek());
+    assertEquals(s, reader.nextString());
+    reader.endArray();
+  }
+
+  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[12.34e5x]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+    try {
+      reader.nextInt();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals("12.34e5x", reader.nextString());
+  }
+
+  public void testPeekLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775808]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    assertEquals(-9223372036854775808L, reader.nextLong());
+  }
+
+  public void testPeekLongMaxValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[9223372036854775807]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    assertEquals(9223372036854775807L, reader.nextLong());
+  }
+
+  public void testLongLargerThanMaxLongThatWrapsAround() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[22233720368547758070]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+  }
+
+  public void testLongLargerThanMinLongThatWrapsAround() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-22233720368547758070]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+  }
+
+  /**
+   * This test fails because there's no double for 9223372036854775808, and our
+   * long parsing uses Double.parseDouble() for fractional values.
+   */
+  public void disabled_testPeekLargerThanLongMaxValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[9223372036854775808]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final NumberFormatException e) {
+    }
+  }
+
+  /**
+   * This test fails because there's no double for -9223372036854775809, and our
+   * long parsing uses Double.parseDouble() for fractional values.
+   */
+  public void disabled_testPeekLargerThanLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-9223372036854775809]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals(-9223372036854775809d, reader.nextDouble());
+  }
+
+  /**
+   * This test fails because there's no double for 9223372036854775806, and
+   * our long parsing uses Double.parseDouble() for fractional values.
+   */
+  public void disabled_testHighPrecisionLong() throws MalformedJsonException {
+    final String json = "[9223372036854775806.000]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    assertEquals(9223372036854775806L, reader.nextLong());
+    reader.endArray();
+  }
+
+  public void testPeekMuchLargerThanLongMinValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[-92233720368547758080]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(NUMBER, reader.peek());
+    try {
+      reader.nextLong();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals(-92233720368547758080d, reader.nextDouble());
+  }
+
+  public void testQuotedNumberWithEscape() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"12\u00334\"]"), JsonOption.LENIENT);
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+    assertEquals(1234, reader.nextInt());
+  }
+
+  public void testMixedCaseLiterals() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[True,TruE,False,FALSE,NULL,nulL]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    assertEquals(false, reader.nextBoolean());
+    reader.nextNull();
+    reader.nextNull();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testMissingValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testPrematureEndOfInput() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true,"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextName();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testPrematurelyClosed() throws MalformedJsonException {
+    try {
+      final JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
+      reader.beginObject();
+      reader.close();
+      reader.nextName();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+
+    try {
+      final JsonReader reader = new JsonReader(reader("{\"a\":[]}"));
+      reader.close();
+      reader.beginObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+
+    try {
+      final JsonReader reader = new JsonReader(reader("{\"a\":true}"));
+      reader.beginObject();
+      reader.nextName();
+      reader.peek();
+      reader.close();
+      reader.nextBoolean();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testNextFailuresDoNotAdvance() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true}"));
+    reader.beginObject();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextName();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.beginArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.endArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.beginObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.endObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextString();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.nextName();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.beginArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      reader.endArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+    reader.close();
+  }
+
+  public void testIntegerMismatchFailuresDoNotAdvance() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1.5]"));
+    reader.beginArray();
+    try {
+      reader.nextInt();
+      fail();
+    } catch (final NumberFormatException expected) {
+    }
+    assertEquals(1.5d, reader.nextDouble());
+    reader.endArray();
+  }
+
+  public void testStringNullIsNotNull() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"null\"]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testNullLiteralIsNotAString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[null]"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testStrictNameValueSeparator() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("{\"a\"=>true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientNameValueSeparator() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("{\"a\"=true}"), JsonOption.LENIENT);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(reader("{\"a\"=>true}"), JsonOption.LENIENT);
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictNameValueSeparatorWithSkipValue() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("{\"a\"=true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("{\"a\"=>true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testCommentsInStringValue() throws Exception {
+    JsonReader reader = new JsonReader(reader("[\"// comment\"]"));
+    reader.beginArray();
+    assertEquals("// comment", reader.nextString());
+    reader.endArray();
+
+    reader = new JsonReader(reader("{\"a\":\"#someComment\"}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("#someComment", reader.nextString());
+    reader.endObject();
+
+    reader = new JsonReader(reader("{\"#//a\":\"#some //Comment\"}"));
+    reader.beginObject();
+    assertEquals("#//a", reader.nextName());
+    assertEquals("#some //Comment", reader.nextString());
+    reader.endObject();
+  }
+
+  public void testStrictComments() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[// comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[# comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[/* comment */ true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientComments() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[// comment \n true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(reader("[# comment \n true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+
+    reader = new JsonReader(reader("[/* comment */ true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictCommentsWithSkipValue() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[// comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[# comment \n true]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[/* comment */ true]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictUnquotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientUnquotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"), JsonOption.LENIENT);
+
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+  }
+
+  public void testStrictUnquotedNamesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{a:true}"));
+    reader.beginObject();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictSingleQuotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientSingleQuotedNames() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"), JsonOption.LENIENT);
+
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+  }
+
+  public void testStrictSingleQuotedNamesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{'a':true}"));
+    reader.beginObject();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictUnquotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictUnquotedStringsWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientUnquotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[a]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+  }
+
+  public void testStrictSingleQuotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"));
+    reader.beginArray();
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientSingleQuotedStrings() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals("a", reader.nextString());
+  }
+
+  public void testStrictSingleQuotedStringsWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("['a']"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictSemicolonDelimitedArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"));
+    reader.beginArray();
+    try {
+      reader.nextBoolean();
+      reader.nextBoolean();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientSemicolonDelimitedArray() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(true, reader.nextBoolean());
+  }
+
+  public void testStrictSemicolonDelimitedArrayWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[true;true]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictSemicolonDelimitedNameValuePair() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.nextBoolean();
+      reader.nextName();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientSemicolonDelimitedNameValuePair() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"), JsonOption.LENIENT);
+
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals("b", reader.nextName());
+  }
+
+  public void testStrictSemicolonDelimitedNameValuePairWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":true;\"b\":true}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    try {
+      reader.skipValue();
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictUnnecessaryArraySeparators() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[true,,true]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextNull();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[,true]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[true,]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.nextNull();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[,]"));
+    reader.beginArray();
+    try {
+      reader.nextNull();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientUnnecessaryArraySeparators() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[true,,true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.nextNull();
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+
+    reader = new JsonReader(reader("[,true]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.nextNull();
+    assertEquals(true, reader.nextBoolean());
+    reader.endArray();
+
+    reader = new JsonReader(reader("[true,]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.nextNull();
+    reader.endArray();
+
+    reader = new JsonReader(reader("[,]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.nextNull();
+    reader.nextNull();
+    reader.endArray();
+  }
+
+  public void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws MalformedJsonException {
+    JsonReader reader = new JsonReader(reader("[true,,true]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[,true]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[true,]"));
+    reader.beginArray();
+    assertEquals(true, reader.nextBoolean());
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+
+    reader = new JsonReader(reader("[,]"));
+    reader.beginArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictMultipleTopLevelValues() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] []"));
+    reader.beginArray();
+    reader.endArray();
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientMultipleTopLevelValues() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] true {}"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(true, reader.nextBoolean());
+    reader.beginObject();
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictMultipleTopLevelValuesWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[] []"));
+    reader.beginArray();
+    reader.endArray();
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testTopLevelValueTypes() throws MalformedJsonException {
+    final JsonReader reader1 = new JsonReader(reader("true"));
+    assertTrue(reader1.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());
+
+    final JsonReader reader2 = new JsonReader(reader("false"));
+    assertFalse(reader2.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());
+
+    final JsonReader reader3 = new JsonReader(reader("null"));
+    assertEquals(JsonToken.NULL, reader3.peek());
+    reader3.nextNull();
+    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());
+
+    final JsonReader reader4 = new JsonReader(reader("123"));
+    assertEquals(123, reader4.nextInt());
+    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());
+
+    final JsonReader reader5 = new JsonReader(reader("123.4"));
+    assertEquals(123.4, reader5.nextDouble());
+    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());
+
+    final JsonReader reader6 = new JsonReader(reader("\"a\""));
+    assertEquals("a", reader6.nextString());
+    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());
+  }
+
+  public void testTopLevelValueTypeWithSkipValue() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("true"));
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictNonExecutePrefix() {
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
+    try {
+      reader.beginArray();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStrictNonExecutePrefixWithSkipValue() {
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"));
+    try {
+      reader.skipValue();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientNonExecutePrefix() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(")]}'\n []"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testLenientNonExecutePrefixWithLeadingWhitespace() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\r\n \t)]}'\n []"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testLenientPartialNonExecutePrefix() {
+    final JsonReader reader = new JsonReader(reader(")]}' []"), JsonOption.LENIENT);
+
+    try {
+      assertEquals(")", reader.nextString());
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testBomIgnoredAsFirstCharacterOfDocument() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\ufeff[]"));
+    reader.beginArray();
+    reader.endArray();
+  }
+
+  public void testBomForbiddenAsOtherCharacterInDocument() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\ufeff]"));
+    reader.beginArray();
+    try {
+      reader.endArray();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testFailWithPosition() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 6 column 5 path $[1]",
+        "[\n\n\n\n\n\"a\",}]");
+  }
+
+  public void testFailWithPositionGreaterThanBufferSize() throws MalformedJsonException {
+    final String spaces = repeat(' ', 8192);
+    testFailWithPosition("Expected value at line 6 column 5 path $[1]",
+        "[\n\n" + spaces + "\n\n\n\"a\",}]");
+  }
+
+  public void testFailWithPositionOverSlashSlashEndOfLineComment() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 5 column 6 path $[1]",
+        "\n// foo\n\n//bar\r\n[\"a\",}");
+  }
+
+  public void testFailWithPositionOverHashEndOfLineComment() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 5 column 6 path $[1]",
+        "\n# foo\n\n#bar\r\n[\"a\",}");
+  }
+
+  public void testFailWithPositionOverCStyleComment() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 6 column 12 path $[1]",
+        "\n\n/* foo\n*\n*\r\nbar */[\"a\",}");
+  }
+
+  public void testFailWithPositionOverQuotedString() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 5 column 3 path $[1]",
+        "[\"foo\nbar\r\nbaz\n\",\n  }");
+  }
+
+  public void testFailWithPositionOverUnquotedString() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 5 column 2 path $[1]", "[\n\nabcd\n\n,}");
+  }
+
+  public void testFailWithEscapedNewlineCharacter() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 5 column 3 path $[1]", "[\n\n\"\\\n\n\",}");
+  }
+
+  public void testFailWithPositionIsOffsetByBom() throws MalformedJsonException {
+    testFailWithPosition("Expected value at line 1 column 6 path $[1]",
+        "\ufeff[\"a\",}]");
+  }
+
+  private void testFailWithPosition(final String message, final String json) throws MalformedJsonException {
+    // Validate that it works reading the string normally.
+    final JsonReader reader1 = new JsonReader(reader(json), JsonOption.LENIENT);
+    reader1.beginArray();
+    reader1.nextString();
+    try {
+      reader1.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+      assertEquals(message, expected.getMessage());
+    }
+
+    // Also validate that it works when skipping.
+    final JsonReader reader2 = new JsonReader(reader(json), JsonOption.LENIENT);
+    reader2.beginArray();
+    reader2.skipValue();
+    try {
+      reader2.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+      assertEquals(message, expected.getMessage());
+    }
+  }
+
+  public void testFailWithPositionDeepPath() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[1,{\"a\":[2,3,}"));
+    reader.beginArray();
+    reader.nextInt();
+    reader.beginObject();
+    reader.nextName();
+    reader.beginArray();
+    reader.nextInt();
+    reader.nextInt();
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+      assertEquals("Expected value at line 1 column 14 path $[1].a[2]", expected.getMessage());
+    }
+  }
+
+  public void testStrictVeryLongNumber() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"));
+    reader.beginArray();
+    try {
+      assertEquals(1d, reader.nextDouble());
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientVeryLongNumber() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[0." + repeat('9', 8192) + "]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(JsonToken.STRING, reader.peek());
+    assertEquals(1d, reader.nextDouble());
+    reader.endArray();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testVeryLongUnquotedLiteral() throws MalformedJsonException {
+    final String literal = "a" + repeat('b', 8192) + "c";
+    final JsonReader reader = new JsonReader(reader("[" + literal + "]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(literal, reader.nextString());
+    reader.endArray();
+  }
+
+  public void testDeeplyNestedArrays() throws MalformedJsonException {
+    // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer
+    final JsonReader reader = new JsonReader(reader(
+        "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]"));
+    for (int i = 0; i < 40; i++) {
+      reader.beginArray();
+    }
+    assertEquals("$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]"
+        + "[0][0][0][0][0][0][0][0][0][0][0][0][0][0]", reader.getPath());
+    for (int i = 0; i < 40; i++) {
+      reader.endArray();
+    }
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testDeeplyNestedObjects() throws MalformedJsonException {
+    // Build a JSON document structured like {"a":{"a":{"a":{"a":true}}}}, but 40 levels deep
+    final String array = "{\"a\":%s}";
+    String json = "true";
+    for (int i = 0; i < 40; i++) {
+      json = String.format(array, json);
+    }
+
+    final JsonReader reader = new JsonReader(reader(json));
+    for (int i = 0; i < 40; i++) {
+      reader.beginObject();
+      assertEquals("a", reader.nextName());
+    }
+    assertEquals("$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a"
+        + ".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a", reader.getPath());
+    assertEquals(true, reader.nextBoolean());
+    for (int i = 0; i < 40; i++) {
+      reader.endObject();
+    }
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  // http://code.google.com/p/google-gson/issues/detail?id=409
+  public void testStringEndingInSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/"), JsonOption.LENIENT);
+
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testDocumentWithCommentEndingInSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/* foo *//"), JsonOption.LENIENT);
+
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testStringWithLeadingSlash() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("/x"), JsonOption.LENIENT);
+
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testUnterminatedObject() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"android\"x"), JsonOption.LENIENT);
+
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("android", reader.nextString());
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testVeryLongQuotedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
+    Arrays.fill(stringChars, 'x');
+    final String string = new String(stringChars);
+    final String json = "[\"" + string + "\"]";
+    final JsonReader reader = new JsonReader(reader(json));
+    reader.beginArray();
+    assertEquals(string, reader.nextString());
+    reader.endArray();
+  }
+
+  public void testVeryLongUnquotedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
+    Arrays.fill(stringChars, 'x');
+    final String string = new String(stringChars);
+    final String json = "[" + string + "]";
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(string, reader.nextString());
+    reader.endArray();
+  }
+
+  public void testVeryLongUnterminatedString() throws MalformedJsonException {
+    final char[] stringChars = new char[1024 * 16];
+    Arrays.fill(stringChars, 'x');
+    final String string = new String(stringChars);
+    final String json = "[" + string;
+    final JsonReader reader = new JsonReader(reader(json), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(string, reader.nextString());
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testSkipVeryLongUnquotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[" + repeat('x', 8192) + "]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    reader.skipValue();
+    reader.endArray();
+  }
+
+  public void testSkipTopLevelUnquotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(repeat('x', 8192)), JsonOption.LENIENT);
+
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testSkipVeryLongQuotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"" + repeat('x', 8192) + "\"]"));
+    reader.beginArray();
+    reader.skipValue();
+    reader.endArray();
+  }
+
+  public void testSkipTopLevelQuotedString() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("\"" + repeat('x', 8192) + "\""), JsonOption.LENIENT);
+
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStringAsNumberWithTruncatedExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123e]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+  }
+
+  public void testStringAsNumberWithDigitAndNonDigitExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123e4b]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+  }
+
+  public void testStringAsNumberWithNonDigitExponent() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[123eb]"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(STRING, reader.peek());
+  }
+
+  public void testEmptyStringName() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"\":true}"), JsonOption.LENIENT);
+
+    assertEquals(BEGIN_OBJECT, reader.peek());
+    reader.beginObject();
+    assertEquals(NAME, reader.peek());
+    assertEquals("", reader.nextName());
+    assertEquals(JsonToken.BOOLEAN, reader.peek());
+    assertEquals(true, reader.nextBoolean());
+    assertEquals(JsonToken.END_OBJECT, reader.peek());
+    reader.endObject();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
+  }
+
+  public void testStrictExtraCommasInMaps() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"));
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("b", reader.nextString());
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  public void testLenientExtraCommasInMaps() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("{\"a\":\"b\",}"), JsonOption.LENIENT);
+
+    reader.beginObject();
+    assertEquals("a", reader.nextName());
+    assertEquals("b", reader.nextString());
+    try {
+      reader.peek();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  private String repeat(final char c, final int count) {
+    final char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+
+  public void testMalformedDocuments() throws MalformedJsonException {
+    assertDocument("{]", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{,", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{{", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{[", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{:", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\":}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"::", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\":,", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=>}", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\":", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\"=", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\"=>", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\",", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\"=>\"string\",\"name\"", BEGIN_OBJECT, NAME, STRING, NAME);
+    assertDocument("[}", BEGIN_ARRAY, MalformedJsonException.class);
+    assertDocument("[,]", BEGIN_ARRAY, NULL, NULL, END_ARRAY);
+    assertDocument("{", BEGIN_OBJECT, MalformedJsonException.class);
+    assertDocument("{\"name\"", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{\"name\",", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{'name'", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{'name',", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("{name", BEGIN_OBJECT, NAME, MalformedJsonException.class);
+    assertDocument("[", BEGIN_ARRAY, MalformedJsonException.class);
+    assertDocument("[string", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("[\"string\"", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("['string'", BEGIN_ARRAY, STRING, MalformedJsonException.class);
+    assertDocument("[123", BEGIN_ARRAY, NUMBER, MalformedJsonException.class);
+    assertDocument("[123,", BEGIN_ARRAY, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":123", BEGIN_OBJECT, NAME, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":123,", BEGIN_OBJECT, NAME, NUMBER, MalformedJsonException.class);
+    assertDocument("{\"name\":\"string\"", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":\"string\",", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":'string'", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":'string',", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);
+    assertDocument("{\"name\":false", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);
+    assertDocument("{\"name\":false,,", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);
+  }
+
+  /**
+   * This test behave slightly differently in Gson 2.2 and earlier. It fails
+   * during peek rather than during nextString().
+   */
+  public void testUnterminatedStringFailure() throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader("[\"string"), JsonOption.LENIENT);
+
+    reader.beginArray();
+    assertEquals(JsonToken.STRING, reader.peek());
+    try {
+      reader.nextString();
+      fail();
+    } catch (final MalformedJsonException expected) {
+    }
+  }
+
+  private void assertDocument(final String document, final Object... expectations) throws MalformedJsonException {
+    final JsonReader reader = new JsonReader(reader(document), JsonOption.LENIENT);
+
+    for (final Object expectation : expectations) {
+      if (expectation == BEGIN_OBJECT) {
+        reader.beginObject();
+      } else if (expectation == BEGIN_ARRAY) {
+        reader.beginArray();
+      } else if (expectation == END_OBJECT) {
+        reader.endObject();
+      } else if (expectation == END_ARRAY) {
+        reader.endArray();
+      } else if (expectation == NAME) {
+        assertEquals("name", reader.nextName());
+      } else if (expectation == BOOLEAN) {
+        assertEquals(false, reader.nextBoolean());
+      } else if (expectation == STRING) {
+        assertEquals("string", reader.nextString());
+      } else if (expectation == NUMBER) {
+        assertEquals(123, reader.nextInt());
+      } else if (expectation == NULL) {
+        reader.nextNull();
+      } else if (expectation == MalformedJsonException.class) {
+        try {
+          reader.peek();
+          fail();
+        } catch (final MalformedJsonException expected) {
+        }
+      } else {
+        throw new AssertionError();
+      }
+    }
+  }
+
+  /**
+   * Returns a reader that returns one character at a time.
+   */
+  private Reader reader(final String s) {
+    /* if (true) */ return new StringReader(s);
+    /* return new Reader() {
+      int position = 0;
+      @Override public int read(char[] buffer, int offset, int count) throws MalformedJsonException {
+        if (position == s.length()) {
+          return -1;
+        } else if (count > 0) {
+          buffer[offset] = s.charAt(position++);
+          return 1;
+        } else {
+          throw new IllegalArgumentException();
+        }
+      }
+      @Override public void close() throws MalformedJsonException {
+      }
+    }; */
+  }
+}
diff --git a/src/test/java/com/github/gv2011/gsoncore/imp/JsonStringEncoderTest.java b/src/test/java/com/github/gv2011/gsoncore/imp/JsonStringEncoderTest.java
new file mode 100644
index 000000000..6ae25aee5
--- /dev/null
+++ b/src/test/java/com/github/gv2011/gsoncore/imp/JsonStringEncoderTest.java
@@ -0,0 +1,18 @@
+package com.github.gv2011.gsoncore.imp;
+
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+
+import org.junit.Test;
+
+import com.github.gv2011.gsoncore.imp.enc.StringEncoder;
+
+public class JsonStringEncoderTest {
+
+  @Test
+  public void testEncodeString() {
+    final StringEncoder encoder = new StringEncoder();
+    assertThat(encoder.encode("abc\"d"), is("\"abc\\\"d\""));
+  }
+
+}
diff --git a/src/test/java/com/github/gv2011/gsoncore/imp/JsonWriterTest.java b/src/test/java/com/github/gv2011/gsoncore/imp/JsonWriterTest.java
new file mode 100644
index 000000000..3ceadf507
--- /dev/null
+++ b/src/test/java/com/github/gv2011/gsoncore/imp/JsonWriterTest.java
@@ -0,0 +1,631 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.gsoncore.imp;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Arrays;
+
+import org.junit.Ignore;
+
+import com.github.gv2011.gsoncore.JsonOption;
+import com.github.gv2011.gsoncore.imp.JsonWriter;
+import com.github.gv2011.gsoncore.imp.enc.EncoderSelector;
+
+import junit.framework.TestCase;
+
+@Ignore//TODO WIP
+public final class JsonWriterTest extends TestCase {
+
+  private JsonWriter newJsonWriter(final Writer w, final JsonOption... jsonOptions){
+    return newJsonWriter(w, 0, jsonOptions);
+  }
+
+  private JsonWriter newJsonWriter(final Writer w, final int indent, final JsonOption... jsonOptions){
+    final EncoderSelector encoders = new EncoderSelector(
+      Arrays.asList(jsonOptions).contains(JsonOption.LENIENT)
+    );
+    return new JsonWriter(w, encoders, indent, jsonOptions);
+  }
+
+  public void testTopLevelValueTypes() throws IOException {
+    final StringWriter string1 = new StringWriter();
+    final JsonWriter writer1 = newJsonWriter(string1);
+    writer1.serializeElementary(true);
+    writer1.endDocument();
+    assertEquals("true", string1.toString());
+
+    final StringWriter string2 = new StringWriter();
+    final JsonWriter writer2 = newJsonWriter(string2);
+    writer2.nullValue();
+    writer2.endDocument();
+    assertEquals("null", string2.toString());
+
+    final StringWriter string3 = new StringWriter();
+    final JsonWriter writer3 = newJsonWriter(string3);
+    writer3.serializeElementary(123);
+    writer3.endDocument();
+    assertEquals("123", string3.toString());
+
+    final StringWriter string4 = new StringWriter();
+    final JsonWriter writer4 = newJsonWriter(string4);
+    writer4.serializeElementary(123.4);
+    writer4.endDocument();
+    assertEquals("123.4", string4.toString());
+
+    final StringWriter string5 = new StringWriter();
+    final JsonWriter writert = newJsonWriter(string5);
+    writert.serializeElementary("a");
+    writert.endDocument();
+    assertEquals("\"a\"", string5.toString());
+  }
+
+  public void testInvalidTopLevelTypes() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.name("hello");
+    try {
+      jsonWriter.serializeElementary("world");
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testTwoNames() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    try {
+      jsonWriter.name("a");
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testNameWithoutValue() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    try {
+      jsonWriter.endObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testValueWithoutName() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.serializeElementary(true);
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testMultipleTopLevelValues() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginArray().endArray();
+    try {
+      jsonWriter.startList();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testBadNestingObject() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.endArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testBadNestingArray() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.startList();
+    try {
+      jsonWriter.endObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testNullName() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    try {
+      jsonWriter.name(null);
+      fail();
+    } catch (final NullPointerException expected) {
+    }
+  }
+
+//  public void testJsonValue() throws IOException {
+//    final StringWriter stringWriter = new StringWriter();
+//    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+//    jsonWriter.beginObject();
+//    jsonWriter.name("a");
+//    jsonWriter.jsonValue("{\"b\":true}");
+//    jsonWriter.name("c");
+//    jsonWriter.serializeElementary(1);
+//    jsonWriter.endObject();
+//    assertEquals("{\"a\":{\"b\":true},\"c\":1}", stringWriter.toString());
+//  }
+
+  public void testNonFiniteDoubles() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    try {
+      jsonWriter.serializeElementary(Double.NaN);
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.serializeElementary(Double.NEGATIVE_INFINITY);
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.serializeElementary(Double.POSITIVE_INFINITY);
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+  }
+
+  public void testNonFiniteBoxedDoubles() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    try {
+      jsonWriter.serializeElementary(new Double(Double.NaN));
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.serializeElementary(new Double(Double.NEGATIVE_INFINITY));
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+    try {
+      jsonWriter.serializeElementary(new Double(Double.POSITIVE_INFINITY));
+      fail();
+    } catch (final IllegalArgumentException expected) {
+    }
+  }
+
+  public void testDoubles() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(-0.0);
+    jsonWriter.serializeElementary(1.0);
+    jsonWriter.serializeElementary(Double.MAX_VALUE);
+    jsonWriter.serializeElementary(Double.MIN_VALUE);
+    jsonWriter.serializeElementary(0.0);
+    jsonWriter.serializeElementary(-0.5);
+    jsonWriter.serializeElementary(2.2250738585072014E-308);
+    jsonWriter.serializeElementary(Math.PI);
+    jsonWriter.serializeElementary(Math.E);
+    jsonWriter.endArray();
+    jsonWriter.endDocument();
+    assertEquals("[-0.0,"
+        + "1.0,"
+        + "1.7976931348623157E308,"
+        + "4.9E-324,"
+        + "0.0,"
+        + "-0.5,"
+        + "2.2250738585072014E-308,"
+        + "3.141592653589793,"
+        + "2.718281828459045]", stringWriter.toString());
+  }
+
+  public void testLongs() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(0);
+    jsonWriter.serializeElementary(1);
+    jsonWriter.serializeElementary(-1);
+    jsonWriter.serializeElementary(Long.MIN_VALUE);
+    jsonWriter.serializeElementary(Long.MAX_VALUE);
+    jsonWriter.endArray();
+    jsonWriter.endDocument();
+    assertEquals("[0,"
+        + "1,"
+        + "-1,"
+        + "-9223372036854775808,"
+        + "9223372036854775807]", stringWriter.toString());
+  }
+
+  public void testNumbers() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(new BigInteger("0"));
+    jsonWriter.serializeElementary(new BigInteger("9223372036854775808"));
+    jsonWriter.serializeElementary(new BigInteger("-9223372036854775809"));
+    jsonWriter.serializeElementary(new BigDecimal("3.141592653589793238462643383"));
+    jsonWriter.endArray();
+    jsonWriter.endDocument();
+    assertEquals("[0,"
+        + "9223372036854775808,"
+        + "-9223372036854775809,"
+        + "3.141592653589793238462643383]", stringWriter.toString());
+  }
+
+  public void testBooleans() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(true);
+    jsonWriter.serializeElementary(false);
+    jsonWriter.endArray();
+    assertEquals("[true,false]", stringWriter.toString());
+  }
+
+  public void testBoxedBooleans() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(true);
+    jsonWriter.serializeElementary(false);
+    jsonWriter.serializeElementary((Boolean) null);
+    jsonWriter.endArray();
+    assertEquals("[true,false,null]", stringWriter.toString());
+  }
+
+  public void testNulls() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.nullValue();
+    jsonWriter.endArray();
+    assertEquals("[null]", stringWriter.toString());
+  }
+
+  public void testStrings() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary("a");
+    jsonWriter.serializeElementary("a\"");
+    jsonWriter.serializeElementary("\"");
+    jsonWriter.serializeElementary(":");
+    jsonWriter.serializeElementary(",");
+    jsonWriter.serializeElementary("\b");
+    jsonWriter.serializeElementary("\f");
+    jsonWriter.serializeElementary("\n");
+    jsonWriter.serializeElementary("\r");
+    jsonWriter.serializeElementary("\t");
+    jsonWriter.serializeElementary(" ");
+    jsonWriter.serializeElementary("\\");
+    jsonWriter.serializeElementary("{");
+    jsonWriter.serializeElementary("}");
+    jsonWriter.serializeElementary("[");
+    jsonWriter.serializeElementary("]");
+    jsonWriter.serializeElementary("\0");
+    jsonWriter.serializeElementary("\u0019");
+    jsonWriter.endArray();
+    assertEquals("[\"a\","
+        + "\"a\\\"\","
+        + "\"\\\"\","
+        + "\":\","
+        + "\",\","
+        + "\"\\b\","
+        + "\"\\f\","
+        + "\"\\n\","
+        + "\"\\r\","
+        + "\"\\t\","
+        + "\" \","
+        + "\"\\\\\","
+        + "\"{\","
+        + "\"}\","
+        + "\"[\","
+        + "\"]\","
+        + "\"\\u0000\","
+        + "\"\\u0019\"]", stringWriter.toString());
+  }
+
+  public void testUnicodeLineBreaksEscaped() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary("\u2028 \u2029");
+    jsonWriter.endArray();
+    assertEquals("[\"\\u2028 \\u2029\"]", stringWriter.toString());
+  }
+
+  public void testEmptyArray() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.startList();
+    jsonWriter.endArray();
+    assertEquals("[]", stringWriter.toString());
+  }
+
+  public void testEmptyObject() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.endObject();
+    assertEquals("{}", stringWriter.toString());
+  }
+
+//  public void testObjectsInArrays() throws IOException {
+//    final StringWriter stringWriter = new StringWriter();
+//    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+//    jsonWriter.startList();
+//    jsonWriter.beginObject();
+//    jsonWriter.name("a").serializeElementary(5);
+//    jsonWriter.name("b").serializeElementary(false);
+//    jsonWriter.endObject();
+//    jsonWriter.beginObject();
+//    jsonWriter.name("c").serializeElementary(6);
+//    jsonWriter.name("d").serializeElementary(true);
+//    jsonWriter.endObject();
+//    jsonWriter.endArray();
+//    assertEquals("[{\"a\":5,\"b\":false},"
+//        + "{\"c\":6,\"d\":true}]", stringWriter.toString());
+//  }
+
+  public void testArraysInObjects() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name("a");
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(5);
+    jsonWriter.serializeElementary(false);
+    jsonWriter.endArray();
+    jsonWriter.name("b");
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(6);
+    jsonWriter.serializeElementary(true);
+    jsonWriter.endArray();
+    jsonWriter.endObject();
+    assertEquals("{\"a\":[5,false],"
+        + "\"b\":[6,true]}", stringWriter.toString());
+  }
+
+  public void testDeepNestingArrays() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.startList();
+    }
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.endArray();
+    }
+    assertEquals("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]", stringWriter.toString());
+  }
+
+  public void testDeepNestingObjects() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.name("a");
+      jsonWriter.beginObject();
+    }
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.endObject();
+    }
+    jsonWriter.endObject();
+    assertEquals("{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":"
+        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{"
+        + "}}}}}}}}}}}}}}}}}}}}}", stringWriter.toString());
+  }
+
+//  public void testRepeatedName() throws IOException {
+//    final StringWriter stringWriter = new StringWriter();
+//    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
+//    jsonWriter.beginObject();
+//    jsonWriter.name("a").serializeElementary(true);
+//    jsonWriter.name("a").serializeElementary(false);
+//    jsonWriter.endObject();
+//    // JsonWriter doesn't attempt to detect duplicate names
+//    assertEquals("{\"a\":true,\"a\":false}", stringWriter.toString());
+//  }
+
+//  public void testPrettyPrintObject() throws IOException {
+//    final StringWriter stringWriter = new StringWriter();
+//    final JsonWriter jsonWriter = newJsonWriter(stringWriter, 3);
+//
+//    jsonWriter.beginObject();
+//    jsonWriter.name("a").serializeElementary(true);
+//    jsonWriter.name("b").serializeElementary(false);
+//    jsonWriter.name("c").serializeElementary(5.0);
+//    jsonWriter.name("e").nullValue();
+//    jsonWriter.name("f").startList();
+//    jsonWriter.serializeElementary(6.0);
+//    jsonWriter.serializeElementary(7.0);
+//    jsonWriter.endArray();
+//    jsonWriter.name("g").beginObject();
+//    jsonWriter.name("h").serializeElementary(8.0);
+//    jsonWriter.name("i").serializeElementary(9.0);
+//    jsonWriter.endObject();
+//    jsonWriter.endObject();
+//
+//    final String expected = "{\n"
+//        + "   \"a\": true,\n"
+//        + "   \"b\": false,\n"
+//        + "   \"c\": 5.0,\n"
+//        + "   \"e\": null,\n"
+//        + "   \"f\": [\n"
+//        + "      6.0,\n"
+//        + "      7.0\n"
+//        + "   ],\n"
+//        + "   \"g\": {\n"
+//        + "      \"h\": 8.0,\n"
+//        + "      \"i\": 9.0\n"
+//        + "   }\n"
+//        + "}";
+//    assertEquals(expected, stringWriter.toString());
+//  }
+
+//  public void testPrettyPrintArray() throws IOException {
+//    final StringWriter stringWriter = new StringWriter();
+//    final JsonWriter jsonWriter = newJsonWriter(stringWriter, 3);
+//
+//    jsonWriter.startList();
+//    jsonWriter.serializeElementary(true);
+//    jsonWriter.serializeElementary(false);
+//    jsonWriter.serializeElementary(5.0);
+//    jsonWriter.nullValue();
+//    jsonWriter.beginObject();
+//    jsonWriter.name("a").serializeElementary(6.0);
+//    jsonWriter.name("b").serializeElementary(7.0);
+//    jsonWriter.endObject();
+//    jsonWriter.startList();
+//    jsonWriter.serializeElementary(8.0);
+//    jsonWriter.serializeElementary(9.0);
+//    jsonWriter.endArray();
+//    jsonWriter.endArray();
+//
+//    final String expected = "[\n"
+//        + "   true,\n"
+//        + "   false,\n"
+//        + "   5.0,\n"
+//        + "   null,\n"
+//        + "   {\n"
+//        + "      \"a\": 6.0,\n"
+//        + "      \"b\": 7.0\n"
+//        + "   },\n"
+//        + "   [\n"
+//        + "      8.0,\n"
+//        + "      9.0\n"
+//        + "   ]\n"
+//        + "]";
+//    assertEquals(expected, stringWriter.toString());
+//  }
+
+  public void testLenientWriterPermitsMultipleTopLevelValues() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter, JsonOption.LENIENT);
+    writer.startList();
+    writer.endArray();
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    assertEquals("[][]", stringWriter.toString());
+  }
+
+  public void testStrictWriterDoesNotPermitMultipleTopLevelValues() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    try {
+      writer.startList();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testClosedWriterThrowsOnStructure() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    try {
+      writer.startList();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      writer.endArray();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      writer.beginObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+    try {
+      writer.endObject();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testClosedWriterThrowsOnName() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    try {
+      writer.name("a");
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testClosedWriterThrowsOnValue() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    try {
+      writer.serializeElementary("a");
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testClosedWriterThrowsOnFlush() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    try {
+      writer.flush();
+      fail();
+    } catch (final IllegalStateException expected) {
+    }
+  }
+
+  public void testWriterCloseIsIdempotent() throws IOException {
+    final StringWriter stringWriter = new StringWriter();
+    final JsonWriter writer = newJsonWriter(stringWriter);
+    writer.startList();
+    writer.endArray();
+    writer.endDocument();
+    writer.endDocument();
+  }
+}
