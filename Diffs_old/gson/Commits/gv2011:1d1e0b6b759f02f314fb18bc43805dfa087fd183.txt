diff --git a/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java b/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
index 084a0b4d5..f7a0443c6 100644
--- a/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
+++ b/api/src/main/java/com/github/gv2011/jsoncore/JsonOption.java
@@ -51,14 +51,14 @@
   LENIENT,
 
   /**
-   *
+   * Configure a serializer to emit JSON that's safe for direct inclusion in HTML
+   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
+   * {@code &} and {@code =} before writing them to the stream. Without this
+   * setting, your XML/HTML encoder should replace these characters with the
+   * corresponding escape sequences.
    */
   HTML_SAFE,
 
-  /**
-   *
-   */
-  OMIT_NULLS
 }
 
 
diff --git a/imp/pom.xml b/imp/pom.xml
index 362db8005..d537ab88a 100644
--- a/imp/pom.xml
+++ b/imp/pom.xml
@@ -11,16 +11,22 @@
 	<artifactId>jsoncore-imp</artifactId>
 
 	<dependencies>
-    <dependency>
-      <groupId>com.github.gv2011</groupId>
-      <artifactId>jsoncore-api</artifactId>
-      <version>0.0.3-SNAPSHOT</version>
-    </dependency>
-    <dependency>
-      <groupId>com.github.gv2011</groupId>
-      <artifactId>util</artifactId>
-    </dependency>
-		
+		<dependency>
+			<groupId>com.github.gv2011</groupId>
+			<artifactId>jsoncore-api</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>com.github.gv2011</groupId>
+			<artifactId>util</artifactId>
+		</dependency>
+
+		<dependency>
+			<groupId>com.google.code.gson</groupId>
+			<artifactId>gson</artifactId>
+			<scope>test</scope>
+		</dependency>
+
+
 	</dependencies>
 
 </project>
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java
index 33c18f724..a006d7d75 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonFactoryImp.java
@@ -9,6 +9,9 @@
 import com.github.gv2011.jsoncore.JsonOption;
 import com.github.gv2011.jsoncore.JsonParser;
 import com.github.gv2011.jsoncore.JsonSerializer;
+import com.github.gv2011.jsoncore.imp.enc.EncoderSelector;
+import com.github.gv2011.jsoncore.imp.enc.StringEncoder;
+import com.github.gv2011.jsoncore.imp.enc.ToStringEncoder;
 
 public class JsonFactoryImp implements JsonFactory{
 
@@ -21,7 +24,8 @@ public JsonParser newJsonParser(final Reader reader, final JsonOption... jsonOpt
 
   @Override
   public JsonSerializer newJsonSerializer(final Writer out, final JsonOption... jsonOptions) {
-    return new JsonWriter(out, this, jsonOptions);
+    final boolean lenient = Arrays.asList(jsonOptions).contains(JsonOption.LENIENT);
+    return new JsonWriter(out, new EncoderSelector(lenient), 0, jsonOptions);
   }
 
 
@@ -31,7 +35,7 @@ public JsonSerializer newJsonSerializer(final Writer out, final JsonOption... js
     JsonEncoder<T> encoder;
     if(primitive.equals(String.class)){
       encoder = (JsonEncoder<T>)
-        new JsonStringEncoder(Arrays.asList(jsonOptions).contains(JsonOption.HTML_SAFE))
+        new StringEncoder(Arrays.asList(jsonOptions).contains(JsonOption.HTML_SAFE))
       ;
     }
     else if(primitive.equals(Long.class)||primitive.equals(long.class)){
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
index 96f003007..dc2e457df 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonScope.java
@@ -29,44 +29,44 @@
      * An array with no elements requires no separators or newlines before
      * it is closed.
      */
-    static final int EMPTY_ARRAY = 1;
+    static final byte EMPTY_ARRAY = 1;
 
     /**
      * A array with at least one value requires a comma and newline before
      * the next element.
      */
-    static final int NONEMPTY_ARRAY = 2;
+    static final byte NONEMPTY_ARRAY = 2;
 
     /**
      * An object with no name/value pairs requires no separators or newlines
      * before it is closed.
      */
-    static final int EMPTY_OBJECT = 3;
+    static final byte EMPTY_OBJECT = 3;
 
     /**
      * An object whose most recent element is a key. The next element must
      * be a value.
      */
-    static final int DANGLING_NAME = 4;
+    static final byte DANGLING_NAME = 4;
 
     /**
      * An object with at least one name/value pair requires a comma and
      * newline before the next element.
      */
-    static final int NONEMPTY_OBJECT = 5;
+    static final byte NONEMPTY_OBJECT = 5;
 
     /**
      * No object or array has been started.
      */
-    static final int EMPTY_DOCUMENT = 6;
+    static final byte EMPTY_DOCUMENT = 6;
 
     /**
      * A document with at an array or object.
      */
-    static final int NONEMPTY_DOCUMENT = 7;
+    static final byte NONEMPTY_DOCUMENT = 7;
 
     /**
      * A document that's been closed and cannot be accessed.
      */
-    static final int CLOSED = 8;
+    static final byte CLOSED = 8;
 }
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
index 29ff9a6b6..90253065a 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter.java
@@ -24,6 +24,7 @@
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_ARRAY;
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
 import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_OBJECT;
+import static com.github.gv2011.util.ex.Exceptions.format;
 import static com.github.gv2011.util.ex.Exceptions.run;
 
 import java.io.IOException;
@@ -34,18 +35,19 @@
 import java.util.Set;
 
 import com.github.gv2011.jsoncore.JsonEncoder;
-import com.github.gv2011.jsoncore.JsonFactory;
 import com.github.gv2011.jsoncore.JsonOption;
-import com.github.gv2011.jsoncore.JsonSerializer;
+import com.github.gv2011.jsoncore.imp.enc.EncoderSelector;
+import com.github.gv2011.util.StringUtils;
+import com.github.gv2011.util.ser.ElementarySerializer;
 
 
-public class JsonWriter implements JsonSerializer {
+public class JsonWriter implements ElementarySerializer<Object,String,Appendable> {
 
 
   /** The output data, containing at most one top-level array or object. */
-  private final Writer out;
+  private final Appendable out;
 
-  private int[] stack = new int[32];
+  private byte[] stack = new byte[32];
   private int stackSize = 0;
   {
     push(EMPTY_DOCUMENT);
@@ -53,75 +55,59 @@
 
   /**
    * A string containing a full set of spaces for a single level of
-   * indentation, or null for no pretty printing.
+   * indentation, or an empty string for no pretty printing.
    */
-  private String indent;
+  private final String indent;
 
   /**
    * The name/value separator; either ":" or ": ".
    */
-  private String separator = ":";
+  private final String separator;
 
   private final boolean lenient;
 
   private final boolean htmlSafe;
 
-  private String deferredName;
-
-  private final boolean serializeNulls;
   private final Set<JsonOption> optList;
 
+  private final JsonEncoder<Void> nullEncoder;
   private final JsonEncoder<String> stringEncoder;
-  private final JsonEncoder<Long> longEncoder;
+
+  private final EncoderSelector encoderSelector;
+
+  private boolean inKey;
+
 
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code out}.
    * For best performance, ensure {@link Writer} is buffered; wrapping in
    * {@link java.io.BufferedWriter BufferedWriter} if necessary.
-   */
-  public JsonWriter(final Writer out, final JsonFactory factory, final JsonOption... options) {
-    this.out = out;
-    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
-    lenient = optList.contains(JsonOption.LENIENT);
-    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
-    serializeNulls = !optList.contains(JsonOption.OMIT_NULLS);
-    stringEncoder = factory.newJsonEncoder(String.class, options);
-    longEncoder = factory.newJsonEncoder(Long.class, options);
-  }
-
-  /**
+   *
    * Sets the indentation string to be repeated for each level of indentation
    * in the encoded document. If {@code indent.isEmpty()} the encoded document
    * will be compact. Otherwise the encoded document will be more
    * human-readable.
    *
-   * @param indent a string containing only whitespace.
+   * @param indent the width of indentation (number of blanks).
+   *   If indent==0 the encoded document will be compact. Otherwise the encoded document will be more
+   *   human-readable.
+   *
    */
-  public final void setIndent(final String indent) {
-    if (indent.length() == 0) {
-      this.indent = null;
-      separator = ":";
-    } else {
-      this.indent = indent;
-      separator = ": ";
-    }
+  public JsonWriter(
+    final Writer out, final EncoderSelector encoderSelector, final int indent, final JsonOption... options
+  ) {
+    this.out = out;
+    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
+    lenient = optList.contains(JsonOption.LENIENT);
+    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
+    this.encoderSelector = encoderSelector;
+    nullEncoder = encoderSelector.tryGetEncoder(Void.class).get();
+    stringEncoder = encoderSelector.tryGetEncoder(String.class).get();
+
+    this.indent = StringUtils.multiply(" ",indent);
+    separator = indent<=0?":":": ";
   }
 
-  /**
-   * Configure this writer to relax its syntax rules. By default, this writer
-   * only emits well-formed JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
-   * to lenient permits the following:
-   * <ul>
-   *   <li>Top-level values of any type. With strict writing, the top-level
-   *       value must be an object or an array.
-   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
-   *       Double#isInfinite() infinities}.
-   * </ul>
-   */
-//  public final void setLenient(final boolean lenient) {
-//    this.lenient = lenient;
-//  }
 
   /**
    * Returns true if this writer has relaxed syntax rules.
@@ -130,16 +116,6 @@ public boolean isLenient() {
     return lenient;
   }
 
-  /**
-   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
-   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
-   * {@code &} and {@code =} before writing them to the stream. Without this
-   * setting, your XML/HTML encoder should replace these characters with the
-   * corresponding escape sequences.
-   */
-//  public final void setHtmlSafe(final boolean htmlSafe) {
-//    this.htmlSafe = htmlSafe;
-//  }
 
   /**
    * Returns true if this writer writes JSON that's safe for inclusion in HTML
@@ -149,71 +125,41 @@ public final boolean isHtmlSafe() {
     return htmlSafe;
   }
 
-  /**
-   * Sets whether object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-//  public final void setSerializeNulls(final boolean serializeNulls) {
-//    this.serializeNulls = serializeNulls;
-//  }
 
-  /**
-   * Returns true if object members are serialized when their value is null.
-   * This has no impact on array elements. The default is true.
-   */
-  public final boolean getSerializeNulls() {
-    return serializeNulls;
+  @Override
+  public void startList(){
+    checkNotInKey();
+    open(EMPTY_ARRAY, "[");
   }
 
-  /**
-   * Begins encoding a new array. Each call to this method must be paired with
-   * a call to {@link #endArray}.
-   *
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter beginArray(){
-    writeDeferredName();
-    return open(EMPTY_ARRAY, "[");
+
+  private void checkNotInKey() {
+    if(inKey) throw new IllegalStateException("Only strings may be used as keys.");
   }
 
-  /**
-   * Ends encoding the current array.
-   *
-   * @return this writer.
-   */
+
   @Override
-  public JsonWriter endArray(){
-    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+  public void endList(){
+    close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
   }
 
-  /**
-   * Begins encoding a new object. Each call to this method must be paired
-   * with a call to {@link #endObject}.
-   *
-   * @return this writer.
-   */
   @Override
-  public JsonWriter beginObject(){
-    writeDeferredName();
-    return open(EMPTY_OBJECT, "{");
+  public void startMap(){
+    checkNotInKey();
+    open(EMPTY_OBJECT, "{");
   }
 
-  /**
-   * Ends encoding the current object.
-   *
-   * @return this writer.
-   */
+
   @Override
-  public JsonWriter endObject(){
-    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  public void endMap(){
+    close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
   }
 
   /**
    * Enters a new scope by appending any necessary whitespace and the given
    * bracket.
    */
-  private JsonWriter open(final int empty, final String openBracket){
+  private JsonWriter open(final byte empty, final String openBracket){
     beforeValue();
     push(empty);
     write(openBracket);
@@ -221,7 +167,7 @@ private JsonWriter open(final int empty, final String openBracket){
   }
 
   private void write(final String str) {
-    run(()->out.write(str));
+    run(()->out.append(str));
   }
 
   /**
@@ -234,8 +180,8 @@ private JsonWriter close(final int empty, final int nonempty, final String close
     if (context != nonempty && context != empty) {
       throw new IllegalStateException("Nesting problem.");
     }
-    if (deferredName != null) {
-      throw new IllegalStateException("Dangling name: " + deferredName);
+    if (inKey) {
+      throw new IllegalStateException("In key.");
     }
 
     stackSize--;
@@ -246,9 +192,9 @@ private JsonWriter close(final int empty, final int nonempty, final String close
     return this;
   }
 
-  private void push(final int newTop) {
+  private void push(final byte newTop) {
     if (stackSize == stack.length) {
-      final int[] newStack = new int[stackSize * 2];
+      final byte[] newStack = new byte[stackSize * 2];
       System.arraycopy(stack, 0, newStack, 0, stackSize);
       stack = newStack;
     }
@@ -259,7 +205,7 @@ private void push(final int newTop) {
    * Returns the value on the top of the stack.
    */
   private int peek() {
-    if (stackSize == 0) {
+    if (isClosed()) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
     return stack[stackSize - 1];
@@ -268,191 +214,59 @@ private int peek() {
   /**
    * Replace the value on the top of the stack with the given value.
    */
-  private void replaceTop(final int topOfStack) {
+  private void replaceTop(final byte topOfStack) {
     stack[stackSize - 1] = topOfStack;
   }
 
-  /**
-   * Encodes the property name.
-   *
-   * @param name the name of the forthcoming value. May not be null.
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter name(final String name){
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    if (deferredName != null) {
-      throw new IllegalStateException();
-    }
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    deferredName = name;
-    return this;
-  }
 
-  private void writeDeferredName(){
-    if (deferredName != null) {
-      beforeName();
-      stringEncoder.encode(deferredName, out);
-      deferredName = null;
-    }
-  }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter value(final String value){
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    stringEncoder.encode(value, out);
-    return this;
+  public boolean isClosed() {
+    return stackSize == 0;
   }
 
-  /**
-   * Writes {@code value} directly to the writer without quoting or
-   * escaping.
-   *
-   * @param value the literal string value, or null to encode a null literal.
-   * @return this writer.
-   */
-  public JsonWriter jsonValue(final String value){
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    append(value);
-    return this;
+  private void checkNotClosed(){
+    if (isClosed()) throw new IllegalStateException("JsonWriter is closed.");
   }
 
+
   private void append(final String str) {
     run(()->out.append(str));
   }
 
-  /**
-   * Encodes {@code null}.
-   *
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter nullValue(){
-    if (deferredName != null) {
-      if (serializeNulls) {
-        writeDeferredName();
-      } else {
-        deferredName = null;
-        return this; // skip the name and the value
-      }
-    }
-    beforeValue();
-    write("null");
-    return this;
+  private void append(final char c) {
+    run(()->out.append(c));
   }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter value(final boolean value){
-    writeDeferredName();
-    beforeValue();
-    write(value ? "true" : "false");
-    return this;
-  }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter value(final Boolean value){
-    if (value == null) {
-      return nullValue();
-    }
-    writeDeferredName();
-    beforeValue();
-    write(value ? "true" : "false");
-    return this;
-  }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
   @Override
-  public JsonWriter value(final double value){
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+  public void serializeElementary(final Object value){
+    if(inKey){
+      inKey=false;
+      if(value.getClass()!=String.class) throw new IllegalArgumentException(
+        format("Only strings allowed as keys.", value.getClass())
+      );
     }
-    writeDeferredName();
     beforeValue();
-    append(Double.toString(value));
-    return this;
+    encode(value, out);
   }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter value(final long value){
-    writeDeferredName();
-    beforeValue();
-    longEncoder.encode(value, out);
-    return this;
+  private String encode(final Object value) {
+    return encoderSelector.selectEncoder(value).encode(value);
   }
 
-  /**
-   * Encodes {@code value}.
-   *
-   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
-   *     {@link Double#isInfinite() infinities}.
-   * @return this writer.
-   */
-  @Override
-  public JsonWriter value(final Number value){
-    if (value == null) {
-      return nullValue();
-    }
-
-    writeDeferredName();
-    final String string = value.toString();
-    if (!lenient
-        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
-      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
-    }
-    beforeValue();
-    append(string);
-    return this;
+  private void encode(final Object value, final Appendable out) {
+    encoderSelector.selectEncoder(value).encode(value, out);
   }
 
   /**
-   * Ensures all buffered data is written to the underlying {@link Writer}
-   * and flushes that writer.
+   * Ensures all buffered data is written to the underlying {@link Appendable}.
    */
   @Override
   public void flush(){
-    if (stackSize == 0) {
+    if (isClosed()) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
-    run(out::flush);
   }
 
   /**
@@ -461,9 +275,7 @@ public void flush(){
    * @throws IOException if the JSON document is incomplete.
    */
   @Override
-  public void close(){
-    run(out::close);
-
+  public void endDocument(){
     final int size = stackSize;
     if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
       throw new IllegalStateException("Incomplete document");
@@ -473,7 +285,7 @@ public void close(){
 
 
   private void newline(){
-    if (indent == null) {
+    if (indent.isEmpty()) {
       return;
     }
 
@@ -483,19 +295,9 @@ private void newline(){
     }
   }
 
-  /**
-   * Inserts any necessary separators and whitespace before a name. Also
-   * adjusts the stack to expect the name's value.
-   */
-  private void beforeName(){
-    final int context = peek();
-    if (context == NONEMPTY_OBJECT) { // first in object
-      run(()->out.write(','));
-    } else if (context != EMPTY_OBJECT) { // not in an object!
-      throw new IllegalStateException("Nesting problem.");
-    }
-    newline();
-    replaceTop(DANGLING_NAME);
+  @Override
+  public void startBean(){
+    open(EMPTY_OBJECT, "{");
   }
 
   /**
@@ -526,6 +328,17 @@ private void beforeValue(){
       newline();
       break;
 
+    case EMPTY_OBJECT: // first in object
+      replaceTop(DANGLING_NAME);
+      newline();
+      break;
+
+    case NONEMPTY_OBJECT: // another in object
+      replaceTop(DANGLING_NAME);
+      append(',');
+      newline();
+      break;
+
     case DANGLING_NAME: // value for name
       append(separator);
       replaceTop(NONEMPTY_OBJECT);
@@ -535,4 +348,79 @@ private void beforeValue(){
       throw new IllegalStateException("Nesting problem.");
     }
   }
+
+
+  @Override
+  public void startDocument() {
+  }
+
+
+
+  @Override
+  public void endBean() {
+    close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  @Override
+  public void startBeanEntry() {
+    final int context = peek();
+    if (context == NONEMPTY_OBJECT) { // first in object
+      this.
+      append(',');
+    } else if (context != EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem.");
+    }
+    newline();
+    replaceTop(DANGLING_NAME);
+  }
+
+
+
+  @Override
+  public void startBeanValue() {
+    // TODO Auto-generated method stub
+
+  }
+
+
+  @Override
+  public void endBeanEntry() {
+    // TODO Auto-generated method stub
+
+  }
+
+
+  @Override
+  public void startMapEntry() {
+    // TODO Auto-generated method stub
+
+  }
+
+
+  @Override
+  public void startMapValue() {
+    // TODO Auto-generated method stub
+
+  }
+
+
+  @Override
+  public void endMapEntry() {
+    // TODO Auto-generated method stub
+
+  }
+
+
+  @Override
+  public void serializeNull() {
+    // TODO Auto-generated method stub
+
+  }
+
+
 }
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter3.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter3.java
new file mode 100644
index 000000000..01d6271d4
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonWriter3.java
@@ -0,0 +1,538 @@
+/*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.github.gv2011.jsoncore.imp;
+
+import static com.github.gv2011.jsoncore.imp.JsonScope.DANGLING_NAME;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.EMPTY_OBJECT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.imp.JsonScope.NONEMPTY_OBJECT;
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.jsoncore.JsonFactory;
+import com.github.gv2011.jsoncore.JsonOption;
+import com.github.gv2011.jsoncore.JsonSerializer;
+
+
+public class JsonWriter3 implements JsonSerializer {
+
+
+  /** The output data, containing at most one top-level array or object. */
+  private final Writer out;
+
+  private int[] stack = new int[32];
+  private int stackSize = 0;
+  {
+    push(EMPTY_DOCUMENT);
+  }
+
+  /**
+   * A string containing a full set of spaces for a single level of
+   * indentation, or null for no pretty printing.
+   */
+  private String indent;
+
+  /**
+   * The name/value separator; either ":" or ": ".
+   */
+  private String separator = ":";
+
+  private final boolean lenient;
+
+  private final boolean htmlSafe;
+
+  private String deferredName;
+
+  private final boolean serializeNulls;
+  private final Set<JsonOption> optList;
+
+  private final JsonEncoder<String> stringEncoder;
+  private final JsonEncoder<Long> longEncoder;
+
+  /**
+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
+   * For best performance, ensure {@link Writer} is buffered; wrapping in
+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
+   */
+  public JsonWriter3(final Writer out, final JsonFactory factory, final JsonOption... options) {
+    this.out = out;
+    optList = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(options)));
+    lenient = optList.contains(JsonOption.LENIENT);
+    htmlSafe = optList.contains(JsonOption.HTML_SAFE);
+    serializeNulls = true;
+    stringEncoder = factory.newJsonEncoder(String.class, options);
+    longEncoder = factory.newJsonEncoder(Long.class, options);
+  }
+
+  /**
+   * Sets the indentation string to be repeated for each level of indentation
+   * in the encoded document. If {@code indent.isEmpty()} the encoded document
+   * will be compact. Otherwise the encoded document will be more
+   * human-readable.
+   *
+   * @param indent a string containing only whitespace.
+   */
+  public final void setIndent(final String indent) {
+    if (indent.length() == 0) {
+      this.indent = null;
+      separator = ":";
+    } else {
+      this.indent = indent;
+      separator = ": ";
+    }
+  }
+
+  /**
+   * Configure this writer to relax its syntax rules. By default, this writer
+   * only emits well-formed JSON as specified by <a
+   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
+   * to lenient permits the following:
+   * <ul>
+   *   <li>Top-level values of any type. With strict writing, the top-level
+   *       value must be an object or an array.
+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+   *       Double#isInfinite() infinities}.
+   * </ul>
+   */
+//  public final void setLenient(final boolean lenient) {
+//    this.lenient = lenient;
+//  }
+
+  /**
+   * Returns true if this writer has relaxed syntax rules.
+   */
+  public boolean isLenient() {
+    return lenient;
+  }
+
+  /**
+   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
+   * and XML documents. This escapes the HTML characters {@code <}, {@code >},
+   * {@code &} and {@code =} before writing them to the stream. Without this
+   * setting, your XML/HTML encoder should replace these characters with the
+   * corresponding escape sequences.
+   */
+//  public final void setHtmlSafe(final boolean htmlSafe) {
+//    this.htmlSafe = htmlSafe;
+//  }
+
+  /**
+   * Returns true if this writer writes JSON that's safe for inclusion in HTML
+   * and XML documents.
+   */
+  public final boolean isHtmlSafe() {
+    return htmlSafe;
+  }
+
+  /**
+   * Sets whether object members are serialized when their value is null.
+   * This has no impact on array elements. The default is true.
+   */
+//  public final void setSerializeNulls(final boolean serializeNulls) {
+//    this.serializeNulls = serializeNulls;
+//  }
+
+  /**
+   * Returns true if object members are serialized when their value is null.
+   * This has no impact on array elements. The default is true.
+   */
+  public final boolean getSerializeNulls() {
+    return serializeNulls;
+  }
+
+  /**
+   * Begins encoding a new array. Each call to this method must be paired with
+   * a call to {@link #endArray}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 beginArray(){
+    writeDeferredName();
+    return open(EMPTY_ARRAY, "[");
+  }
+
+  /**
+   * Ends encoding the current array.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 endArray(){
+    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+  }
+
+  /**
+   * Begins encoding a new object. Each call to this method must be paired
+   * with a call to {@link #endObject}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 beginObject(){
+    writeDeferredName();
+    return open(EMPTY_OBJECT, "{");
+  }
+
+  /**
+   * Ends encoding the current object.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 endObject(){
+    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+  /**
+   * Enters a new scope by appending any necessary whitespace and the given
+   * bracket.
+   */
+  private JsonWriter3 open(final int empty, final String openBracket){
+    beforeValue();
+    push(empty);
+    write(openBracket);
+    return this;
+  }
+
+  private void write(final String str) {
+    run(()->out.write(str));
+  }
+
+  /**
+   * Closes the current scope by appending any necessary whitespace and the
+   * given bracket.
+   */
+  private JsonWriter3 close(final int empty, final int nonempty, final String closeBracket)
+     {
+    final int context = peek();
+    if (context != nonempty && context != empty) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException("Dangling name: " + deferredName);
+    }
+
+    stackSize--;
+    if (context == nonempty) {
+      newline();
+    }
+    write(closeBracket);
+    return this;
+  }
+
+  private void push(final int newTop) {
+    if (stackSize == stack.length) {
+      final int[] newStack = new int[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      stack = newStack;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns the value on the top of the stack.
+   */
+  private int peek() {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    return stack[stackSize - 1];
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(final int topOfStack) {
+    stack[stackSize - 1] = topOfStack;
+  }
+
+  /**
+   * Encodes the property name.
+   *
+   * @param name the name of the forthcoming value. May not be null.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 name(final String name){
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException();
+    }
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    deferredName = name;
+    return this;
+  }
+
+  private void writeDeferredName(){
+    if (deferredName != null) {
+      beforeName();
+      stringEncoder.encode(deferredName, out);
+      deferredName = null;
+    }
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final String value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    stringEncoder.encode(value, out);
+    return this;
+  }
+
+  /**
+   * Writes {@code value} directly to the writer without quoting or
+   * escaping.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonWriter3 jsonValue(final String value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    append(value);
+    return this;
+  }
+
+  private void append(final String str) {
+    run(()->out.append(str));
+  }
+
+  /**
+   * Encodes {@code null}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 nullValue(){
+    if (deferredName != null) {
+      if (serializeNulls) {
+        writeDeferredName();
+      } else {
+        deferredName = null;
+        return this; // skip the name and the value
+      }
+    }
+    beforeValue();
+    write("null");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final boolean value){
+    writeDeferredName();
+    beforeValue();
+    write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final Boolean value){
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final double value){
+    if (Double.isNaN(value) || Double.isInfinite(value)) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    writeDeferredName();
+    beforeValue();
+    append(Double.toString(value));
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final long value){
+    writeDeferredName();
+    beforeValue();
+    longEncoder.encode(value, out);
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
+   *     {@link Double#isInfinite() infinities}.
+   * @return this writer.
+   */
+  @Override
+  public JsonWriter3 value(final Number value){
+    if (value == null) {
+      return nullValue();
+    }
+
+    writeDeferredName();
+    final String string = value.toString();
+    if (!lenient
+        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    beforeValue();
+    append(string);
+    return this;
+  }
+
+  /**
+   * Ensures all buffered data is written to the underlying {@link Writer}
+   * and flushes that writer.
+   */
+  @Override
+  public void flush(){
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    run(out::flush);
+  }
+
+  /**
+   * Flushes and closes this writer and the underlying {@link Writer}.
+   *
+   * @throws IOException if the JSON document is incomplete.
+   */
+  @Override
+  public void close(){
+    run(out::close);
+
+    final int size = stackSize;
+    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IllegalStateException("Incomplete document");
+    }
+    stackSize = 0;
+  }
+
+
+  private void newline(){
+    if (indent == null) {
+      return;
+    }
+
+    write("\n");
+    for (int i = 1, size = stackSize; i < size; i++) {
+      write(indent);
+    }
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  private void beforeName(){
+    final int context = peek();
+    if (context == NONEMPTY_OBJECT) { // first in object
+      run(()->out.write(','));
+    } else if (context != EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem.");
+    }
+    newline();
+    replaceTop(DANGLING_NAME);
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a literal value,
+   * inline array, or inline object. Also adjusts the stack to expect either a
+   * closing bracket or another element.
+   */
+  @SuppressWarnings("fallthrough")
+  private void beforeValue(){
+    switch (peek()) {
+    case NONEMPTY_DOCUMENT:
+      if (!lenient) {
+        throw new IllegalStateException(
+            "JSON must have only one top-level value.");
+      }
+      // fall-through
+    case EMPTY_DOCUMENT: // first in document
+      replaceTop(NONEMPTY_DOCUMENT);
+      break;
+
+    case EMPTY_ARRAY: // first in array
+      replaceTop(NONEMPTY_ARRAY);
+      newline();
+      break;
+
+    case NONEMPTY_ARRAY: // another in array
+      run(()->out.append(','));
+      newline();
+      break;
+
+    case DANGLING_NAME: // value for name
+      append(separator);
+      replaceTop(NONEMPTY_OBJECT);
+      break;
+
+    default:
+      throw new IllegalStateException("Nesting problem.");
+    }
+  }
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/ToStringEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/ToStringEncoder.java
deleted file mode 100644
index 068c21f5d..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/ToStringEncoder.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.github.gv2011.jsoncore.imp;
-
-public class ToStringEncoder<T> extends AbstractJsonEncoder<T>{
-
-  @Override
-  public void encode(final T value, final Appendable out) {
-    write(out, value.toString());
-  }
-
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/AbstractJsonEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/AbstractJsonEncoder.java
similarity index 81%
rename from imp/src/main/java/com/github/gv2011/jsoncore/imp/AbstractJsonEncoder.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/AbstractJsonEncoder.java
index b11098b5f..f779b8fbe 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/AbstractJsonEncoder.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/AbstractJsonEncoder.java
@@ -1,10 +1,11 @@
-package com.github.gv2011.jsoncore.imp;
+package com.github.gv2011.jsoncore.imp.enc;
 
 import static com.github.gv2011.util.ex.Exceptions.run;
 
 import java.io.StringWriter;
 
 import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.util.ann.Nullable;
 
 abstract class AbstractJsonEncoder<T> implements JsonEncoder<T>{
 
@@ -12,7 +13,7 @@
   protected AbstractJsonEncoder() {}
 
   @Override
-  public final String encode(final T value) {
+  public String encode(final @Nullable T value) {
     final StringWriter w = new StringWriter();
     encode(value, w);
     return w.toString();
@@ -26,4 +27,5 @@ protected final void write(final Appendable out, final String cbuf, final int of
     run(()->out.append(cbuf, off, off+len));
   }
 
+
 }
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/BytesEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/BytesEncoder.java
new file mode 100644
index 000000000..5dae69aaa
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/BytesEncoder.java
@@ -0,0 +1,18 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.notYetImplementedException;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.util.bytes.Bytes;
+
+public class BytesEncoder extends AbstractJsonEncoder<Bytes>{
+
+  public BytesEncoder(final JsonEncoder<String> stringEncoder) {
+  }
+
+  @Override
+  public void encode(final Bytes value, final Appendable out) {
+    throw notYetImplementedException();
+  }
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/DoubleEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/DoubleEncoder.java
new file mode 100644
index 000000000..12e5027a5
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/DoubleEncoder.java
@@ -0,0 +1,19 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+import com.github.gv2011.util.ann.Nullable;
+
+public class DoubleEncoder extends NumberEncoder<Double>{
+
+  public DoubleEncoder(final boolean lenient) {
+    super(lenient);
+  }
+
+  @Override
+  protected String toString(final @Nullable Double value) {
+    if(value!=null)checkFinite(value);
+    final String result = super.toString(value);
+    return result;
+  }
+
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/EncoderSelector.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/EncoderSelector.java
new file mode 100644
index 000000000..2d799577d
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/EncoderSelector.java
@@ -0,0 +1,112 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.format;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.util.bytes.Bytes;
+import com.github.gv2011.util.ser.TypeSupport;
+
+public class EncoderSelector implements TypeSupport<String,Object>{
+
+  private final Map<Class<?>,JsonEncoder<?>> encoders;
+
+  public EncoderSelector(final boolean lenient) {
+    encoders = buildEncoderMap(lenient);
+  }
+
+
+  @SuppressWarnings("unchecked")
+  public <T> JsonEncoder<T> selectEncoder(final T obj){
+    final Class<? extends Object> clazz = obj.getClass();
+    return (JsonEncoder<T>) tryGetEncoder(clazz)
+      .orElseThrow(()->new IllegalArgumentException(format("{} is not supported.", clazz)))
+    ;
+  }
+
+  @SuppressWarnings("unchecked")
+  public <T> Optional<JsonEncoder<T>> tryGetEncoder(final Class<T> type){
+    return Optional.ofNullable((JsonEncoder<T>) encoders.get(type));
+  }
+
+  private static Map<Class<?>, JsonEncoder<?>> buildEncoderMap(final boolean lenient) {
+    final Map<Class<?>,JsonEncoder<?>> encoders = new HashMap<>();
+    put(encoders, Void.class, new ToStringEncoder<>());
+    put(encoders, Boolean.class, new ToStringEncoder<>());
+    final JsonEncoder<String> stringEncoder = new StringEncoder();
+    put(encoders, String.class, stringEncoder);
+    put(encoders, Bytes.class, new BytesEncoder(stringEncoder));
+    put(encoders, Byte.class, new ToStringEncoder<>());
+    put(encoders, Short.class, new ToStringEncoder<>());
+    put(encoders, Integer.class, new ToStringEncoder<>());
+    put(encoders, Long.class, new ToStringEncoder<>());
+    put(encoders, BigInteger.class, new ToStringEncoder<>());
+    put(encoders, Float.class, new FloatEncoder(lenient));
+    put(encoders, Double.class, new DoubleEncoder(lenient));
+    put(encoders, BigDecimal.class, new ToStringEncoder<>());
+    put(encoders, BigInteger.class, new ToStringEncoder<>());
+    return Collections.unmodifiableMap(encoders);
+  }
+
+
+  private static <T> void put(
+    final Map<Class<?>, JsonEncoder<?>> encoders, final Class<T> clazz, final JsonEncoder<T> encoder
+  ) {
+    encoders.put(clazz, encoder);
+  }
+
+
+
+  @Override
+  public boolean isMap(final Object obj) {
+    return obj instanceof Map;
+  }
+
+  @Override
+  public Map<?,?> asMap(final Object obj) {
+    return (Map<?, ?>) obj;
+  }
+
+  @Override
+  public boolean isList(final Object obj) {
+    return obj instanceof Iterable;
+  }
+
+  @Override
+  public Iterable<?> asList(final Object obj) {
+    return (Iterable<?>) obj;
+  }
+
+
+  @Override
+  public boolean isBean(final Object obj) {
+    if(!(obj instanceof Map)) return false;
+    else return ((Map<?,?>)obj).keySet().parallelStream().allMatch(k->k.getClass()==String.class);
+  }
+
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public Map<String,?> asBean(final Object obj) {
+    return (Map<String,?>) obj;
+  }
+
+
+  @Override
+  public Object asElementary(final Object obj) {
+    return obj;
+  }
+
+
+  @Override
+  public boolean isElementary(final Object obj) {
+    return tryGetEncoder(obj.getClass()).isPresent();
+  }
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/FloatEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/FloatEncoder.java
new file mode 100644
index 000000000..e98278169
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/FloatEncoder.java
@@ -0,0 +1,18 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+import com.github.gv2011.util.ann.Nullable;
+
+public class FloatEncoder extends NumberEncoder<Float>{
+
+  public FloatEncoder(final boolean lenient) {
+    super(lenient);
+  }
+
+  @Override
+  protected String toString(final @Nullable Float value) {
+    if(value!=null)checkFinite(value);
+    final String result = super.toString(value);
+    return result;
+  }
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NonStreamingEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NonStreamingEncoder.java
new file mode 100644
index 000000000..78f188028
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NonStreamingEncoder.java
@@ -0,0 +1,37 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+import static com.github.gv2011.util.ex.Exceptions.run;
+
+import com.github.gv2011.jsoncore.JsonEncoder;
+import com.github.gv2011.util.ann.Nullable;
+
+abstract class NonStreamingEncoder<T> implements JsonEncoder<T>{
+
+
+  protected NonStreamingEncoder() {}
+
+  @Override
+  public final String encode(final @Nullable T value) {
+    return toString(value);
+  }
+
+  protected String toString(final @Nullable T value) {
+    return String.valueOf(value);
+  }
+
+  @Override
+  public final void encode(final @Nullable T value, final Appendable out) {
+    write(out, toString(value));
+  }
+
+
+  protected final void write(final Appendable out, final String str) {
+    run(()->out.append(str));
+  }
+
+  protected final void write(final Appendable out, final String cbuf, final int off, final int len) {
+    run(()->out.append(cbuf, off, off+len));
+  }
+
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NumberEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NumberEncoder.java
new file mode 100644
index 000000000..24fdc103c
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/NumberEncoder.java
@@ -0,0 +1,33 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+public class NumberEncoder<T extends Number> extends NonStreamingEncoder<T>{
+
+
+
+  private final boolean lenient;
+
+  @Override
+  protected String toString(final T value) {
+    final String result = super.toString(value);
+    checkFiniteStr(result);
+    return result;
+  }
+
+  public NumberEncoder(final boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  protected void checkFiniteStr(final String value){
+    if (!lenient && (value.equals("-Infinity") || value.equals("Infinity") || value.equals("NaN"))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+  }
+
+  protected void checkFinite(final double value){
+    if (!lenient && (Double.isInfinite(value) || Double.isNaN(value))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+  }
+
+
+}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/StringEncoder.java
similarity index 92%
rename from imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java
rename to imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/StringEncoder.java
index b5d7e21a8..4d58439d2 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonStringEncoder.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/StringEncoder.java
@@ -1,6 +1,6 @@
-package com.github.gv2011.jsoncore.imp;
+package com.github.gv2011.jsoncore.imp.enc;
 
-class JsonStringEncoder extends AbstractJsonEncoder<String>{
+public class StringEncoder extends AbstractJsonEncoder<String>{
 
     /*
    * From RFC 7159, "All Unicode characters may be placed within the
@@ -37,11 +37,11 @@
 
   private final boolean htmlSafe;
 
-  JsonStringEncoder() {
+  public StringEncoder() {
     this(false);
   }
 
-  JsonStringEncoder(final boolean htmlSafe) {
+  public StringEncoder(final boolean htmlSafe) {
     this.htmlSafe = htmlSafe;
   }
 
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/ToStringEncoder.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/ToStringEncoder.java
new file mode 100644
index 000000000..986ada638
--- /dev/null
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/enc/ToStringEncoder.java
@@ -0,0 +1,5 @@
+package com.github.gv2011.jsoncore.imp.enc;
+
+public class ToStringEncoder<T> extends NonStreamingEncoder<T>{
+
+}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/exp/GsonTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/exp/GsonTest.java
new file mode 100644
index 000000000..0da492dbf
--- /dev/null
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/exp/GsonTest.java
@@ -0,0 +1,26 @@
+package com.github.gv2011.jsoncore.exp;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.Test;
+
+import com.google.gson.Gson;
+
+public class GsonTest {
+
+  @Test
+  public void test() {
+    final Map<Object,Object> map = new HashMap<>();
+    final List<Object> list = new ArrayList<>();
+    list.add("i");
+    list.add(7);
+//    map.put("a", 2);
+    map.put(4, 3);
+//    map.put(null, 4);
+    System.out.println(new Gson().toJson(map));
+  }
+
+}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java
index 3b0911bc0..17064f954 100644
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonStringEncoderTest.java
@@ -5,11 +5,13 @@
 
 import org.junit.Test;
 
+import com.github.gv2011.jsoncore.imp.enc.StringEncoder;
+
 public class JsonStringEncoderTest {
 
   @Test
   public void testEncodeString() {
-    final JsonStringEncoder encoder = new JsonStringEncoder();
+    final StringEncoder encoder = new StringEncoder();
     assertThat(encoder.encode("abc\"d"), is("\"abc\\\"d\""));
   }
 
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
index 815ac0fe8..ae1866ebe 100644
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
+++ b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonWriterTest.java
@@ -22,49 +22,55 @@
 import java.io.Writer;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.util.Arrays;
 
-import com.github.gv2011.jsoncore.JsonFactory;
 import com.github.gv2011.jsoncore.JsonOption;
+import com.github.gv2011.jsoncore.imp.enc.EncoderSelector;
 
 import junit.framework.TestCase;
 
 public final class JsonWriterTest extends TestCase {
 
-  private final JsonFactory factory = new JsonFactoryImp();
-
   private JsonWriter newJsonWriter(final Writer w, final JsonOption... jsonOptions){
-    return new JsonWriter(w, factory, jsonOptions);
+    return newJsonWriter(w, 0, jsonOptions);
+  }
+
+  private JsonWriter newJsonWriter(final Writer w, final int indent, final JsonOption... jsonOptions){
+    final EncoderSelector encoders = new EncoderSelector(
+      Arrays.asList(jsonOptions).contains(JsonOption.LENIENT)
+    );
+    return new JsonWriter(w, encoders, indent, jsonOptions);
   }
 
   public void testTopLevelValueTypes() throws IOException {
     final StringWriter string1 = new StringWriter();
     final JsonWriter writer1 = newJsonWriter(string1);
-    writer1.value(true);
-    writer1.close();
+    writer1.serializeElementary(true);
+    writer1.endDocument();
     assertEquals("true", string1.toString());
 
     final StringWriter string2 = new StringWriter();
     final JsonWriter writer2 = newJsonWriter(string2);
     writer2.nullValue();
-    writer2.close();
+    writer2.endDocument();
     assertEquals("null", string2.toString());
 
     final StringWriter string3 = new StringWriter();
     final JsonWriter writer3 = newJsonWriter(string3);
-    writer3.value(123);
-    writer3.close();
+    writer3.serializeElementary(123);
+    writer3.endDocument();
     assertEquals("123", string3.toString());
 
     final StringWriter string4 = new StringWriter();
     final JsonWriter writer4 = newJsonWriter(string4);
-    writer4.value(123.4);
-    writer4.close();
+    writer4.serializeElementary(123.4);
+    writer4.endDocument();
     assertEquals("123.4", string4.toString());
 
     final StringWriter string5 = new StringWriter();
     final JsonWriter writert = newJsonWriter(string5);
-    writert.value("a");
-    writert.close();
+    writert.serializeElementary("a");
+    writert.endDocument();
     assertEquals("\"a\"", string5.toString());
   }
 
@@ -73,7 +79,7 @@ public void testInvalidTopLevelTypes() throws IOException {
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     jsonWriter.name("hello");
     try {
-      jsonWriter.value("world");
+      jsonWriter.serializeElementary("world");
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -108,7 +114,7 @@ public void testValueWithoutName() throws IOException {
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     jsonWriter.beginObject();
     try {
-      jsonWriter.value(true);
+      jsonWriter.serializeElementary(true);
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -119,7 +125,7 @@ public void testMultipleTopLevelValues() throws IOException {
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     jsonWriter.beginArray().endArray();
     try {
-      jsonWriter.beginArray();
+      jsonWriter.startList();
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -128,7 +134,7 @@ public void testMultipleTopLevelValues() throws IOException {
   public void testBadNestingObject() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     jsonWriter.beginObject();
     try {
       jsonWriter.endArray();
@@ -140,8 +146,8 @@ public void testBadNestingObject() throws IOException {
   public void testBadNestingArray() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.beginArray();
+    jsonWriter.startList();
+    jsonWriter.startList();
     try {
       jsonWriter.endObject();
       fail();
@@ -160,16 +166,6 @@ public void testNullName() throws IOException {
     }
   }
 
-  public void testNullStringValue() throws IOException {
-    final StringWriter stringWriter = new StringWriter();
-    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginObject();
-    jsonWriter.name("a");
-    jsonWriter.value((String) null);
-    jsonWriter.endObject();
-    assertEquals("{\"a\":null}", stringWriter.toString());
-  }
-
   public void testJsonValue() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
@@ -177,7 +173,7 @@ public void testJsonValue() throws IOException {
     jsonWriter.name("a");
     jsonWriter.jsonValue("{\"b\":true}");
     jsonWriter.name("c");
-    jsonWriter.value(1);
+    jsonWriter.serializeElementary(1);
     jsonWriter.endObject();
     assertEquals("{\"a\":{\"b\":true},\"c\":1}", stringWriter.toString());
   }
@@ -185,19 +181,19 @@ public void testJsonValue() throws IOException {
   public void testNonFiniteDoubles() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     try {
-      jsonWriter.value(Double.NaN);
+      jsonWriter.serializeElementary(Double.NaN);
       fail();
     } catch (final IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(Double.NEGATIVE_INFINITY);
+      jsonWriter.serializeElementary(Double.NEGATIVE_INFINITY);
       fail();
     } catch (final IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(Double.POSITIVE_INFINITY);
+      jsonWriter.serializeElementary(Double.POSITIVE_INFINITY);
       fail();
     } catch (final IllegalArgumentException expected) {
     }
@@ -206,19 +202,19 @@ public void testNonFiniteDoubles() throws IOException {
   public void testNonFiniteBoxedDoubles() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     try {
-      jsonWriter.value(new Double(Double.NaN));
+      jsonWriter.serializeElementary(new Double(Double.NaN));
       fail();
     } catch (final IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(new Double(Double.NEGATIVE_INFINITY));
+      jsonWriter.serializeElementary(new Double(Double.NEGATIVE_INFINITY));
       fail();
     } catch (final IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(new Double(Double.POSITIVE_INFINITY));
+      jsonWriter.serializeElementary(new Double(Double.POSITIVE_INFINITY));
       fail();
     } catch (final IllegalArgumentException expected) {
     }
@@ -227,18 +223,18 @@ public void testNonFiniteBoxedDoubles() throws IOException {
   public void testDoubles() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value(-0.0);
-    jsonWriter.value(1.0);
-    jsonWriter.value(Double.MAX_VALUE);
-    jsonWriter.value(Double.MIN_VALUE);
-    jsonWriter.value(0.0);
-    jsonWriter.value(-0.5);
-    jsonWriter.value(2.2250738585072014E-308);
-    jsonWriter.value(Math.PI);
-    jsonWriter.value(Math.E);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(-0.0);
+    jsonWriter.serializeElementary(1.0);
+    jsonWriter.serializeElementary(Double.MAX_VALUE);
+    jsonWriter.serializeElementary(Double.MIN_VALUE);
+    jsonWriter.serializeElementary(0.0);
+    jsonWriter.serializeElementary(-0.5);
+    jsonWriter.serializeElementary(2.2250738585072014E-308);
+    jsonWriter.serializeElementary(Math.PI);
+    jsonWriter.serializeElementary(Math.E);
     jsonWriter.endArray();
-    jsonWriter.close();
+    jsonWriter.endDocument();
     assertEquals("[-0.0,"
         + "1.0,"
         + "1.7976931348623157E308,"
@@ -253,14 +249,14 @@ public void testDoubles() throws IOException {
   public void testLongs() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value(0);
-    jsonWriter.value(1);
-    jsonWriter.value(-1);
-    jsonWriter.value(Long.MIN_VALUE);
-    jsonWriter.value(Long.MAX_VALUE);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(0);
+    jsonWriter.serializeElementary(1);
+    jsonWriter.serializeElementary(-1);
+    jsonWriter.serializeElementary(Long.MIN_VALUE);
+    jsonWriter.serializeElementary(Long.MAX_VALUE);
     jsonWriter.endArray();
-    jsonWriter.close();
+    jsonWriter.endDocument();
     assertEquals("[0,"
         + "1,"
         + "-1,"
@@ -271,13 +267,13 @@ public void testLongs() throws IOException {
   public void testNumbers() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value(new BigInteger("0"));
-    jsonWriter.value(new BigInteger("9223372036854775808"));
-    jsonWriter.value(new BigInteger("-9223372036854775809"));
-    jsonWriter.value(new BigDecimal("3.141592653589793238462643383"));
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(new BigInteger("0"));
+    jsonWriter.serializeElementary(new BigInteger("9223372036854775808"));
+    jsonWriter.serializeElementary(new BigInteger("-9223372036854775809"));
+    jsonWriter.serializeElementary(new BigDecimal("3.141592653589793238462643383"));
     jsonWriter.endArray();
-    jsonWriter.close();
+    jsonWriter.endDocument();
     assertEquals("[0,"
         + "9223372036854775808,"
         + "-9223372036854775809,"
@@ -287,9 +283,9 @@ public void testNumbers() throws IOException {
   public void testBooleans() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value(true);
-    jsonWriter.value(false);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(true);
+    jsonWriter.serializeElementary(false);
     jsonWriter.endArray();
     assertEquals("[true,false]", stringWriter.toString());
   }
@@ -297,10 +293,10 @@ public void testBooleans() throws IOException {
   public void testBoxedBooleans() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value((Boolean) true);
-    jsonWriter.value((Boolean) false);
-    jsonWriter.value((Boolean) null);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary((Boolean) true);
+    jsonWriter.serializeElementary((Boolean) false);
+    jsonWriter.serializeElementary((Boolean) null);
     jsonWriter.endArray();
     assertEquals("[true,false,null]", stringWriter.toString());
   }
@@ -308,7 +304,7 @@ public void testBoxedBooleans() throws IOException {
   public void testNulls() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     jsonWriter.nullValue();
     jsonWriter.endArray();
     assertEquals("[null]", stringWriter.toString());
@@ -317,25 +313,25 @@ public void testNulls() throws IOException {
   public void testStrings() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value("a");
-    jsonWriter.value("a\"");
-    jsonWriter.value("\"");
-    jsonWriter.value(":");
-    jsonWriter.value(",");
-    jsonWriter.value("\b");
-    jsonWriter.value("\f");
-    jsonWriter.value("\n");
-    jsonWriter.value("\r");
-    jsonWriter.value("\t");
-    jsonWriter.value(" ");
-    jsonWriter.value("\\");
-    jsonWriter.value("{");
-    jsonWriter.value("}");
-    jsonWriter.value("[");
-    jsonWriter.value("]");
-    jsonWriter.value("\0");
-    jsonWriter.value("\u0019");
+    jsonWriter.startList();
+    jsonWriter.serializeElementary("a");
+    jsonWriter.serializeElementary("a\"");
+    jsonWriter.serializeElementary("\"");
+    jsonWriter.serializeElementary(":");
+    jsonWriter.serializeElementary(",");
+    jsonWriter.serializeElementary("\b");
+    jsonWriter.serializeElementary("\f");
+    jsonWriter.serializeElementary("\n");
+    jsonWriter.serializeElementary("\r");
+    jsonWriter.serializeElementary("\t");
+    jsonWriter.serializeElementary(" ");
+    jsonWriter.serializeElementary("\\");
+    jsonWriter.serializeElementary("{");
+    jsonWriter.serializeElementary("}");
+    jsonWriter.serializeElementary("[");
+    jsonWriter.serializeElementary("]");
+    jsonWriter.serializeElementary("\0");
+    jsonWriter.serializeElementary("\u0019");
     jsonWriter.endArray();
     assertEquals("[\"a\","
         + "\"a\\\"\","
@@ -360,8 +356,8 @@ public void testStrings() throws IOException {
   public void testUnicodeLineBreaksEscaped() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
-    jsonWriter.value("\u2028 \u2029");
+    jsonWriter.startList();
+    jsonWriter.serializeElementary("\u2028 \u2029");
     jsonWriter.endArray();
     assertEquals("[\"\\u2028 \\u2029\"]", stringWriter.toString());
   }
@@ -369,7 +365,7 @@ public void testUnicodeLineBreaksEscaped() throws IOException {
   public void testEmptyArray() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     jsonWriter.endArray();
     assertEquals("[]", stringWriter.toString());
   }
@@ -385,14 +381,14 @@ public void testEmptyObject() throws IOException {
   public void testObjectsInArrays() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.beginArray();
+    jsonWriter.startList();
     jsonWriter.beginObject();
-    jsonWriter.name("a").value(5);
-    jsonWriter.name("b").value(false);
+    jsonWriter.name("a").serializeElementary(5);
+    jsonWriter.name("b").serializeElementary(false);
     jsonWriter.endObject();
     jsonWriter.beginObject();
-    jsonWriter.name("c").value(6);
-    jsonWriter.name("d").value(true);
+    jsonWriter.name("c").serializeElementary(6);
+    jsonWriter.name("d").serializeElementary(true);
     jsonWriter.endObject();
     jsonWriter.endArray();
     assertEquals("[{\"a\":5,\"b\":false},"
@@ -404,14 +400,14 @@ public void testArraysInObjects() throws IOException {
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     jsonWriter.beginObject();
     jsonWriter.name("a");
-    jsonWriter.beginArray();
-    jsonWriter.value(5);
-    jsonWriter.value(false);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(5);
+    jsonWriter.serializeElementary(false);
     jsonWriter.endArray();
     jsonWriter.name("b");
-    jsonWriter.beginArray();
-    jsonWriter.value(6);
-    jsonWriter.value(true);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(6);
+    jsonWriter.serializeElementary(true);
     jsonWriter.endArray();
     jsonWriter.endObject();
     assertEquals("{\"a\":[5,false],"
@@ -422,7 +418,7 @@ public void testDeepNestingArrays() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     for (int i = 0; i < 20; i++) {
-      jsonWriter.beginArray();
+      jsonWriter.startList();
     }
     for (int i = 0; i < 20; i++) {
       jsonWriter.endArray();
@@ -451,8 +447,8 @@ public void testRepeatedName() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter jsonWriter = newJsonWriter(stringWriter);
     jsonWriter.beginObject();
-    jsonWriter.name("a").value(true);
-    jsonWriter.name("a").value(false);
+    jsonWriter.name("a").serializeElementary(true);
+    jsonWriter.name("a").serializeElementary(false);
     jsonWriter.endObject();
     // JsonWriter doesn't attempt to detect duplicate names
     assertEquals("{\"a\":true,\"a\":false}", stringWriter.toString());
@@ -460,21 +456,20 @@ public void testRepeatedName() throws IOException {
 
   public void testPrettyPrintObject() throws IOException {
     final StringWriter stringWriter = new StringWriter();
-    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.setIndent("   ");
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter, 3);
 
     jsonWriter.beginObject();
-    jsonWriter.name("a").value(true);
-    jsonWriter.name("b").value(false);
-    jsonWriter.name("c").value(5.0);
+    jsonWriter.name("a").serializeElementary(true);
+    jsonWriter.name("b").serializeElementary(false);
+    jsonWriter.name("c").serializeElementary(5.0);
     jsonWriter.name("e").nullValue();
-    jsonWriter.name("f").beginArray();
-    jsonWriter.value(6.0);
-    jsonWriter.value(7.0);
+    jsonWriter.name("f").startList();
+    jsonWriter.serializeElementary(6.0);
+    jsonWriter.serializeElementary(7.0);
     jsonWriter.endArray();
     jsonWriter.name("g").beginObject();
-    jsonWriter.name("h").value(8.0);
-    jsonWriter.name("i").value(9.0);
+    jsonWriter.name("h").serializeElementary(8.0);
+    jsonWriter.name("i").serializeElementary(9.0);
     jsonWriter.endObject();
     jsonWriter.endObject();
 
@@ -497,21 +492,20 @@ public void testPrettyPrintObject() throws IOException {
 
   public void testPrettyPrintArray() throws IOException {
     final StringWriter stringWriter = new StringWriter();
-    final JsonWriter jsonWriter = newJsonWriter(stringWriter);
-    jsonWriter.setIndent("   ");
+    final JsonWriter jsonWriter = newJsonWriter(stringWriter, 3);
 
-    jsonWriter.beginArray();
-    jsonWriter.value(true);
-    jsonWriter.value(false);
-    jsonWriter.value(5.0);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(true);
+    jsonWriter.serializeElementary(false);
+    jsonWriter.serializeElementary(5.0);
     jsonWriter.nullValue();
     jsonWriter.beginObject();
-    jsonWriter.name("a").value(6.0);
-    jsonWriter.name("b").value(7.0);
+    jsonWriter.name("a").serializeElementary(6.0);
+    jsonWriter.name("b").serializeElementary(7.0);
     jsonWriter.endObject();
-    jsonWriter.beginArray();
-    jsonWriter.value(8.0);
-    jsonWriter.value(9.0);
+    jsonWriter.startList();
+    jsonWriter.serializeElementary(8.0);
+    jsonWriter.serializeElementary(9.0);
     jsonWriter.endArray();
     jsonWriter.endArray();
 
@@ -535,21 +529,21 @@ public void testPrettyPrintArray() throws IOException {
   public void testLenientWriterPermitsMultipleTopLevelValues() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter, JsonOption.LENIENT);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
+    writer.endDocument();
     assertEquals("[][]", stringWriter.toString());
   }
 
   public void testStrictWriterDoesNotPermitMultipleTopLevelValues() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
     try {
-      writer.beginArray();
+      writer.startList();
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -558,11 +552,11 @@ public void testStrictWriterDoesNotPermitMultipleTopLevelValues() throws IOExcep
   public void testClosedWriterThrowsOnStructure() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
+    writer.endDocument();
     try {
-      writer.beginArray();
+      writer.startList();
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -586,9 +580,9 @@ public void testClosedWriterThrowsOnStructure() throws IOException {
   public void testClosedWriterThrowsOnName() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
+    writer.endDocument();
     try {
       writer.name("a");
       fail();
@@ -599,11 +593,11 @@ public void testClosedWriterThrowsOnName() throws IOException {
   public void testClosedWriterThrowsOnValue() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
+    writer.endDocument();
     try {
-      writer.value("a");
+      writer.serializeElementary("a");
       fail();
     } catch (final IllegalStateException expected) {
     }
@@ -612,9 +606,9 @@ public void testClosedWriterThrowsOnValue() throws IOException {
   public void testClosedWriterThrowsOnFlush() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
+    writer.endDocument();
     try {
       writer.flush();
       fail();
@@ -625,9 +619,9 @@ public void testClosedWriterThrowsOnFlush() throws IOException {
   public void testWriterCloseIsIdempotent() throws IOException {
     final StringWriter stringWriter = new StringWriter();
     final JsonWriter writer = newJsonWriter(stringWriter);
-    writer.beginArray();
+    writer.startList();
     writer.endArray();
-    writer.close();
-    writer.close();
+    writer.endDocument();
+    writer.endDocument();
   }
 }
