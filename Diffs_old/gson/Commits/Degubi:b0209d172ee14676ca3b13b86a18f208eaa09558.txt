diff --git a/UserGuide.md b/UserGuide.md
index f5d2fff00..aac9bb440 100644
--- a/UserGuide.md
+++ b/UserGuide.md
@@ -320,7 +320,7 @@ Gson allows you to register your own custom serializers and deserializers. This
 * Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
 
 ```java
-GsonBuilder gson = new GsonBuilder();
+GsonBuilder gson = Gson.newBuilder();
 gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
 gson.registerTypeAdapter(MyType.class, new MySerializer());
 gson.registerTypeAdapter(MyType.class, new MyDeserializer());
@@ -443,7 +443,7 @@ If you would like to use the Pretty Print feature, you must configure your `Gson
 
 The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the `JsonCompactFormatter`:
 ```
-Gson gson = new GsonBuilder().setPrettyPrinting().create();
+Gson gson = Gson.newBuilder().setPrettyPrinting().build();
 String jsonOutput = gson.toJson(someObject);
 ```
 ### <a name="TOC-Null-Object-Support"></a>Null Object Support
@@ -453,7 +453,7 @@ The default behaviour that is implemented in Gson is that `null` object fields a
 Here's how you would configure a `Gson` instance to output null:
 
 ```java
-Gson gson = new GsonBuilder().serializeNulls().create();
+Gson gson = Gson.newBuilder().serializeNulls().build();
 ```
 
 NOTE: when serializing `null`s with Gson, it will add a `JsonNull` element to the `JsonElement` structure. Therefore, this object can be used in custom serialization/deserialization.
@@ -475,7 +475,7 @@ public class Foo {
   }
 }
 
-Gson gson = new GsonBuilder().serializeNulls().create();
+Gson gson = Gson.newBuilder().serializeNulls().build();
 Foo foo = new Foo();
 String json = gson.toJson(foo);
 System.out.println(json);
@@ -509,7 +509,7 @@ public class VersionedClass {
 }
 
 VersionedClass versionedObject = new VersionedClass();
-Gson gson = new GsonBuilder().setVersion(1.0).create();
+Gson gson = Gson.newBuilder().setVersion(1.0).build();
 String jsonOutput = gson.toJson(versionedObject);
 System.out.println(jsonOutput);
 System.out.println();
@@ -537,22 +537,22 @@ By default, if you mark a field as `transient`, it will be excluded. As well, if
 
 ```java
 import java.lang.reflect.Modifier;
-Gson gson = new GsonBuilder()
+Gson gson = Gson.newBuilder()
     .excludeFieldsWithModifiers(Modifier.STATIC)
-    .create();
+    .build();
 ```
 
 NOTE: you can give any number of the `Modifier` constants to the `excludeFieldsWithModifiers` method. For example:
 
 ```java
-Gson gson = new GsonBuilder()
+Gson gson = Gson.newBuilder()
     .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
-    .create();
+    .build();
 ```
 
 #### <a name="TOC-Gson-s-Expose"></a>Gson's `@Expose`
 
-This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using `new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()`. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
+This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using `Gson.newBuilder().excludeFieldsWithoutExposeAnnotation().build()`. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
 
 #### <a name="TOC-User-Defined-Exclusion-Strategies"></a>User Defined Exclusion Strategies
 
@@ -597,10 +597,10 @@ public class MyExclusionStrategy implements ExclusionStrategy {
 }
 
 public static void main(String[] args) {
-  Gson gson = new GsonBuilder()
+  Gson gson = Gson.newBuilder()
       .setExclusionStrategies(new MyExclusionStrategy(String.class))
       .serializeNulls()
-      .create();
+      .build();
   SampleObjectForTest src = new SampleObjectForTest();
   String json = gson.toJson(src);
   System.out.println(json);
@@ -633,7 +633,7 @@ private class SomeObject {
 }
 
 SomeObject someObject = new SomeObject("first", "second");
-Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
+Gson gson = Gson.newBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).build();
 String jsonRepresentation = gson.toJson(someObject);
 System.out.println(jsonRepresentation);
 ```
diff --git a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
index 47e7f5152..558a4db98 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
@@ -110,9 +110,9 @@
  * }</pre>
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
- *   Gson gson = new GsonBuilder()
+ *   Gson gson = Gson.newBuilder()
  *       .registerTypeAdapterFactory(shapeAdapterFactory)
- *       .create();
+ *       .build();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
  *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
diff --git a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
index 8a1d7cdbf..4ed47de1a 100644
--- a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
+++ b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
@@ -34,11 +34,11 @@ public void testSerialization() {
     scissors.beats = paper;
     paper.beats = rock;
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Roshambo.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     assertEquals("{'0x1':{'name':'ROCK','beats':'0x2'}," +
         "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
@@ -51,11 +51,11 @@ public void testDeserialization() {
         "'0x2':{'name':'SCISSORS','beats':'0x3'}," +
         "'0x3':{'name':'PAPER','beats':'0x1'}}";
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Roshambo.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     Roshambo rock = gson.fromJson(json, Roshambo.class);
     assertEquals("ROCK", rock.name);
@@ -70,11 +70,11 @@ public void testSerializationDirectSelfReference() {
     Roshambo suicide = new Roshambo("SUICIDE");
     suicide.beats = suicide;
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Roshambo.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     assertEquals("{'0x1':{'name':'SUICIDE','beats':'0x1'}}",
         gson.toJson(suicide).replace('"', '\''));
@@ -83,11 +83,11 @@ public void testSerializationDirectSelfReference() {
   public void testDeserializationDirectSelfReference() {
     String json = "{'0x1':{'name':'SUICIDE','beats':'0x1'}}";
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Roshambo.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     Roshambo suicide = gson.fromJson(json, Roshambo.class);
     assertEquals("SUICIDE", suicide.name);
@@ -102,12 +102,12 @@ public void testSerializeListOfLists() {
     listOfLists.add(listOfLists);
     listOfLists.add(new ArrayList<Object>());
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(listOfListsType)
         .addType(listOfAnyType)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     String json = gson.toJson(listOfLists, listOfListsType);
     assertEquals("{'0x1':['0x1','0x2'],'0x2':[]}", json.replace('"', '\''));
@@ -117,12 +117,12 @@ public void testDeserializeListOfLists() {
     Type listOfAnyType = new TypeToken<List<?>>() {}.getType();
     Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(listOfListsType)
         .addType(listOfAnyType)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     List<List<?>> listOfLists = gson.fromJson("{'0x1':['0x1','0x2'],'0x2':[]}", listOfListsType);
     assertEquals(2, listOfLists.size());
@@ -135,12 +135,12 @@ public void testSerializationWithMultipleTypes() {
     new Employee("Jesse", google);
     new Employee("Joel", google);
 
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Company.class)
         .addType(Employee.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     assertEquals("{'0x1':{'name':'Google','employees':['0x2','0x3']},"
         + "'0x2':{'name':'Jesse','company':'0x1'},"
@@ -149,12 +149,12 @@ public void testSerializationWithMultipleTypes() {
   }
 
   public void testDeserializationWithMultipleTypes() {
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     new GraphAdapterBuilder()
         .addType(Company.class)
         .addType(Employee.class)
         .registerOn(gsonBuilder);
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
 
     String json = "{'0x1':{'name':'Google','employees':['0x2','0x3']},"
         + "'0x2':{'name':'Jesse','company':'0x1'},"
diff --git a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
index 0aab6598c..a8af66fd7 100644
--- a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
+++ b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
@@ -43,10 +43,10 @@
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    this.gson = new GsonBuilder()
+    this.gson = Gson.newBuilder()
         .registerTypeAdapterFactory(new InterceptorFactory())
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
   }
 
   public void testExceptionsPropagated() {
@@ -92,7 +92,7 @@ public void testField() {
   }
 
   public void testCustomTypeAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(User.class, new TypeAdapter<User>() {
           @Override public void write(JsonWriter out, User value) throws IOException {
             throw new UnsupportedOperationException();
@@ -109,7 +109,7 @@ public void testCustomTypeAdapter() {
           }
         })
         .registerTypeAdapterFactory(new InterceptorFactory())
-        .create();
+        .build();
     UserGroup userGroup = gson.fromJson("{user:{name:'bob',password:'pwd'}}", UserGroup.class);
     assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);
   }
diff --git a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
index 7bd0a520d..6af3303d7 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
@@ -28,9 +28,9 @@
 
 public class PostConstructAdapterFactoryTest extends TestCase {
     public void test() throws Exception {
-        Gson gson = new GsonBuilder()
+        Gson gson = Gson.newBuilder()
                 .registerTypeAdapterFactory(new PostConstructAdapterFactory())
-                .create();
+                .build();
         gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
         try {
             gson.fromJson("{\"bread\": \"cheesey bread\", \"cheese\": \"swiss\"}", Sandwich.class);
@@ -45,7 +45,7 @@ public void testList() {
             new Sandwich("white", "cheddar"),
             new Sandwich("whole wheat", "swiss")));
 
-        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();
+        Gson gson = Gson.newBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).build();
 
         // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
         String json = gson.toJson(sandwiches);
diff --git a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
index 8c62bef7f..d4c3353be 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
@@ -28,9 +28,9 @@ public void testRuntimeTypeAdapter() {
     RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(
         BillingInstrument.class)
         .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(rta)
-        .create();
+        .build();
 
     CreditCard original = new CreditCard("Jesse", 234);
     assertEquals("{\"type\":\"CreditCard\",\"cvv\":234,\"ownerName\":\"Jesse\"}",
@@ -45,9 +45,9 @@ public void testRuntimeTypeIsBaseType() {
     TypeAdapterFactory rta = RuntimeTypeAdapterFactory.of(
         BillingInstrument.class)
         .registerSubtype(BillingInstrument.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(rta)
-        .create();
+        .build();
 
     BillingInstrument original = new BillingInstrument("Jesse");
     assertEquals("{\"type\":\"BillingInstrument\",\"ownerName\":\"Jesse\"}",
@@ -118,9 +118,9 @@ public void testDuplicateLabel() {
   public void testDeserializeMissingTypeField() {
     TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
         .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(billingAdapter)
-        .create();
+        .build();
     try {
       gson.fromJson("{ownerName:'Jesse'}", BillingInstrument.class);
       fail();
@@ -131,9 +131,9 @@ public void testDeserializeMissingTypeField() {
   public void testDeserializeMissingSubtype() {
     TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
         .registerSubtype(BankTransfer.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(billingAdapter)
-        .create();
+        .build();
     try {
       gson.fromJson("{type:'CreditCard',ownerName:'Jesse'}", BillingInstrument.class);
       fail();
@@ -144,9 +144,9 @@ public void testDeserializeMissingSubtype() {
   public void testSerializeMissingSubtype() {
     TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
         .registerSubtype(BankTransfer.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(billingAdapter)
-        .create();
+        .build();
     try {
       gson.toJson(new CreditCard("Jesse", 456), BillingInstrument.class);
       fail();
@@ -157,9 +157,9 @@ public void testSerializeMissingSubtype() {
   public void testSerializeCollidingTypeFieldName() {
     TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class, "cvv")
         .registerSubtype(CreditCard.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(billingAdapter)
-        .create();
+        .build();
     try {
       gson.toJson(new CreditCard("Jesse", 456), BillingInstrument.class);
       fail();
@@ -171,9 +171,9 @@ public void testSerializeWrappedNullValue() {
     TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
         .registerSubtype(CreditCard.class)
         .registerSubtype(BankTransfer.class);    
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapterFactory(billingAdapter)
-        .create();    
+        .build();    
     String serialized = gson.toJson(new BillingInstrumentWrapper(null), BillingInstrumentWrapper.class);
     BillingInstrumentWrapper deserialized = gson.fromJson(serialized, BillingInstrumentWrapper.class);
     assertNull(deserialized.instrument);
diff --git a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
index 56e54290c..97b04c28e 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
@@ -29,9 +29,9 @@
 import com.google.gson.GsonBuilder;
 
 public final class UtcDateTypeAdapterTest extends TestCase {
-  private final Gson gson = new GsonBuilder()
+  private final Gson gson = Gson.newBuilder()
     .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
-    .create();
+    .build();
 
   public void testLocalTimeZone() {
     Date expected = new Date();
@@ -56,9 +56,9 @@ public void testDifferentTimeZones() {
    * We want to make sure that this date is parseable in Android.
    */
   public void testUtcDatesOnJdkBefore1_7() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
-      .create();
+      .build();
     gson.fromJson("'2014-12-05T04:00:00.000Z'", Date.class);
   }
 
diff --git a/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html b/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html
index acf395202..ba754c23e 100644
--- a/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html
+++ b/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html
@@ -148,9 +148,9 @@ <H2>
  <code>GsonBuilder</code> to configure Gson to use one of the above sample:
  <pre class="code">
  ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);
- Gson gson = new GsonBuilder()
+ Gson gson = Gson.newBuilder()
      .setExclusionStrategies(excludeStrings)
-     .create();
+     .build();
  </pre>
 
  <p>For certain model classes, you may only want to serialize a field, but exclude it for
@@ -160,9 +160,9 @@ <H2>
  For example:
  <pre class="code">
  ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);
- Gson gson = new GsonBuilder()
+ Gson gson = Gson.newBuilder()
      .addDeserializationExclusionStrategy(excludeStrings)
-     .create();
+     .build();
  </pre>
 <P>
 
diff --git a/gson/docs/javadocs/com/google/gson/Gson.html b/gson/docs/javadocs/com/google/gson/Gson.html
index 416ee2e6c..2cbe1b8b9 100644
--- a/gson/docs/javadocs/com/google/gson/Gson.html
+++ b/gson/docs/javadocs/com/google/gson/Gson.html
@@ -114,7 +114,7 @@ <H2>
  <p>Here is an example of how Gson is used for a simple Class:
 
  <pre>
- Gson gson = new Gson(); // Or use new GsonBuilder().create();
+ Gson gson = new Gson(); // Or use Gson.newBuilder().build();
  MyType target = new MyType();
  String json = gson.toJson(target); // serializes target to Json
  MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2
@@ -560,7 +560,7 @@ <H2>
   </code> </pre>
   This factory can now be used like this:
   <pre> <code>StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();
-  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();
+  Gson gson = Gson.newBuilder().registerTypeAdapterFactory(stats).build();
   // Call gson.toJson() and fromJson methods on objects
   System.out.println("Num JSON reads" + stats.numReads);
   System.out.println("Num JSON writes" + stats.numWrites);
diff --git a/gson/docs/javadocs/com/google/gson/GsonBuilder.html b/gson/docs/javadocs/com/google/gson/GsonBuilder.html
index 9f9355742..ae77446ba 100644
--- a/gson/docs/javadocs/com/google/gson/GsonBuilder.html
+++ b/gson/docs/javadocs/com/google/gson/GsonBuilder.html
@@ -111,7 +111,7 @@ <H2>
  instance:
 
  <pre>
- Gson gson = new GsonBuilder()
+ Gson gson = Gson.newBuilder()
      .registerTypeAdapter(Id.class, new IdTypeAdapter())
      .enableComplexMapKeySerialization()
      .serializeNulls()
@@ -119,7 +119,7 @@ <H2>
      .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
      .setPrettyPrinting()
      .setVersion(1.0)
-     .create();
+     .build();
  </pre></p>
 
  <p>NOTES:
@@ -509,10 +509,10 @@ <h3>Maps as JSON objects</h3>
  then be serialized as a <A HREF="../../../com/google/gson/JsonObject.html" title="class in com.google.gson"><CODE>JsonObject</CODE></A>.
 
  <p>Below is an example:
- <pre>  <code>Gson gson = new GsonBuilder()
+ <pre>  <code>Gson gson = Gson.newBuilder()
        .register(Point.class, new MyPointTypeAdapter())
        .enableComplexMapKeySerialization()
-       .create();
+       .build();
 
    Map&lt;Point, String&gt; original = new LinkedHashMap&lt;Point, String&gt;();
    original.put(new Point(5, 6), "a");
@@ -534,9 +534,9 @@ <h3>Maps as JSON arrays</h3>
  serialize as an array of arrays (can be viewed as an entry set of pairs).
 
  <p>Below is an example of serializing complex types as JSON arrays:
- <pre> <code>Gson gson = new GsonBuilder()
+ <pre> <code>Gson gson = Gson.newBuilder()
        .enableComplexMapKeySerialization()
-       .create();
+       .build();
 
    Map&lt;Point, String&gt; original = new LinkedHashMap&lt;Point, String&gt;();
    original.put(new Point(5, 6), "a");
diff --git a/gson/docs/javadocs/com/google/gson/InstanceCreator.html b/gson/docs/javadocs/com/google/gson/InstanceCreator.html
index 3fef64483..aaaf75b12 100644
--- a/gson/docs/javadocs/com/google/gson/InstanceCreator.html
+++ b/gson/docs/javadocs/com/google/gson/InstanceCreator.html
@@ -149,7 +149,7 @@ <H2>
  The developer will need to register <code>IdInstanceCreator</code> with Gson as follows:</p>
 
  <pre>
- Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();
+ Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).build();
  </pre>
 <P>
 
diff --git a/gson/docs/javadocs/com/google/gson/JsonDeserializer.html b/gson/docs/javadocs/com/google/gson/JsonDeserializer.html
index 1f1e207ad..d5fb32458 100644
--- a/gson/docs/javadocs/com/google/gson/JsonDeserializer.html
+++ b/gson/docs/javadocs/com/google/gson/JsonDeserializer.html
@@ -140,7 +140,7 @@ <H2>
  <p>You will also need to register <code>IdDeserializer</code> with Gson as follows:</p>
 
  <pre>
- Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();
+ Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).build();
  </pre>
 
  <p>New applications should prefer <A HREF="../../../com/google/gson/TypeAdapter.html" title="class in com.google.gson"><CODE>TypeAdapter</CODE></A>, whose streaming API
diff --git a/gson/docs/javadocs/com/google/gson/JsonSerializer.html b/gson/docs/javadocs/com/google/gson/JsonSerializer.html
index db6f39efc..81c880460 100644
--- a/gson/docs/javadocs/com/google/gson/JsonSerializer.html
+++ b/gson/docs/javadocs/com/google/gson/JsonSerializer.html
@@ -139,7 +139,7 @@ <H2>
 
  <p>You will also need to register <code>IdSerializer</code> with Gson as follows:</p>
  <pre>
- Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();
+ Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdSerializer()).build();
  </pre>
 
  <p>New applications should prefer <A HREF="../../../com/google/gson/TypeAdapter.html" title="class in com.google.gson"><CODE>TypeAdapter</CODE></A>, whose streaming API
diff --git a/gson/docs/javadocs/com/google/gson/TypeAdapter.html b/gson/docs/javadocs/com/google/gson/TypeAdapter.html
index c1a05f0e0..fc9e24936 100644
--- a/gson/docs/javadocs/com/google/gson/TypeAdapter.html
+++ b/gson/docs/javadocs/com/google/gson/TypeAdapter.html
@@ -153,12 +153,12 @@ <h3>Defining a type's JSON form</h3>
  your type adapter must handle null.
 
  <p>To use a custom type adapter with Gson, you must <i>register</i> it with a
- <A HREF="../../../com/google/gson/GsonBuilder.html" title="class in com.google.gson"><CODE>GsonBuilder</CODE></A>: <pre>   <code>GsonBuilder builder = new GsonBuilder();
+ <A HREF="../../../com/google/gson/GsonBuilder.html" title="class in com.google.gson"><CODE>GsonBuilder</CODE></A>: <pre>   <code>GsonBuilder builder = Gson.newBuilder();
    builder.registerTypeAdapter(Point.class, new PointAdapter());
    // if PointAdapter didn't check for nulls in its read/write methods, you should instead use
    // builder.registerTypeAdapter(Point.class, new PointAdapter().nullSafe());
    ...
-   Gson gson = builder.create();
+   Gson gson = builder.build();
  </code></pre>
 <P>
 
@@ -360,7 +360,7 @@ <h3>Defining a type's JSON form</h3>
 <DD>This wrapper method is used to make a type adapter null tolerant. In general, a
  type adapter is required to handle nulls in write and read methods. Here is how this
  is typically done:<br>
- <pre>   <code>Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,
+ <pre>   <code>Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
    new TypeAdapter&lt;Foo&gt;() {
      public Foo read(JsonReader in) throws IOException {
        if (in.peek() == JsonToken.NULL) {
@@ -376,11 +376,11 @@ <h3>Defining a type's JSON form</h3>
        }
        // write src as JSON to out
      }
-   }).create();
+   }).build();
  </code></pre>
  You can avoid this boilerplate handling of nulls by wrapping your type adapter with
  this method. Here is how we will rewrite the above example:
- <pre>   <code>Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,
+ <pre>   <code>Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
    new TypeAdapter&lt;Foo&gt;() {
      public Foo read(JsonReader in) throws IOException {
        // read a Foo from in and return it
@@ -388,7 +388,7 @@ <h3>Defining a type's JSON form</h3>
      public void write(JsonWriter out, Foo src) throws IOException {
        // write src as JSON to out
      }
-   }.nullSafe()).create();
+   }.nullSafe()).build();
  </code></pre>
  Note that we didn't need to check for nulls in our type adapter after we used nullSafe.
 <P>
diff --git a/gson/docs/javadocs/com/google/gson/TypeAdapterFactory.html b/gson/docs/javadocs/com/google/gson/TypeAdapterFactory.html
index 2fb30755f..5de1d0a5f 100644
--- a/gson/docs/javadocs/com/google/gson/TypeAdapterFactory.html
+++ b/gson/docs/javadocs/com/google/gson/TypeAdapterFactory.html
@@ -154,10 +154,10 @@ <h3>Example: Converting enums to lowercase</h3>
  like reflection in <code>create()</code> so that the type adapter's <code>read()</code> and <code>write()</code> methods can be very fast. In this example the
  mapping from lowercase name to enum value is computed eagerly.
 
- <p>As with type adapters, factories must be <i>registered</i> with a <A HREF="../../../com/google/gson/GsonBuilder.html" title="class in com.google.gson"><CODE>GsonBuilder</CODE></A> for them to take effect: <pre>   <code>GsonBuilder builder = new GsonBuilder();
+ <p>As with type adapters, factories must be <i>registered</i> with a <A HREF="../../../com/google/gson/GsonBuilder.html" title="class in com.google.gson"><CODE>GsonBuilder</CODE></A> for them to take effect: <pre>   <code>GsonBuilder builder = Gson.newBuilder();
   builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());
   ...
-  Gson gson = builder.create();
+  Gson gson = builder.build();
  </code></pre>
  If multiple factories support the same type, the factory registered earlier
  takes precedence.
@@ -206,7 +206,7 @@ <h3>Example: composing other type adapters</h3>
              return null;
            }
 
-           Multiset&lt;E&gt; result = LinkedHashMultiset.create();
+           Multiset&lt;E&gt; result = LinkedHashMultiset.build();
            in.beginArray();
            while (in.hasNext()) {
              int count = in.nextInt();
diff --git a/gson/docs/javadocs/com/google/gson/annotations/Expose.html b/gson/docs/javadocs/com/google/gson/annotations/Expose.html
index e87aa8bd7..0e25b5334 100644
--- a/gson/docs/javadocs/com/google/gson/annotations/Expose.html
+++ b/gson/docs/javadocs/com/google/gson/annotations/Expose.html
@@ -120,7 +120,7 @@ <H2>
  If you created Gson with <code>new Gson()</code>, the <code>toJson()</code> and <code>fromJson()</code>
  methods will use the <code>password</code> field along-with <code>firstName</code>, <code>lastName</code>,
  and <code>emailAddress</code> for serialization and deserialization. However, if you created Gson
- with <code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>
+ with <code>Gson gson = Gson.newBuilder().excludeFieldsWithoutExposeAnnotation().build()</code>
  then the <code>toJson()</code> and <code>fromJson()</code> methods of Gson will exclude the
  <code>password</code> field. This is because the <code>password</code> field is not marked with the
  <code>@Expose</code> annotation. Gson will also exclude <code>lastName</code> and <code>emailAddress</code>
diff --git a/gson/docs/javadocs/com/google/gson/annotations/Since.html b/gson/docs/javadocs/com/google/gson/annotations/Since.html
index 06148fb2b..696c70e56 100644
--- a/gson/docs/javadocs/com/google/gson/annotations/Since.html
+++ b/gson/docs/javadocs/com/google/gson/annotations/Since.html
@@ -121,7 +121,7 @@ <H2>
 
  <p>If you created Gson with <code>new Gson()</code>, the <code>toJson()</code> and <code>fromJson()</code>
  methods will use all the fields for serialization and deserialization. However, if you created
- Gson with <code>Gson gson = new GsonBuilder().setVersion(1.0).create()</code> then the
+ Gson with <code>Gson gson = Gson.newBuilder().setVersion(1.0).build()</code> then the
  <code>toJson()</code> and <code>fromJson()</code> methods of Gson will exclude the <code>address</code> field
  since it's version number is set to <code>1.1</code>.</p>
 <P>
diff --git a/gson/docs/javadocs/com/google/gson/annotations/Until.html b/gson/docs/javadocs/com/google/gson/annotations/Until.html
index 813740cb5..d57d3af31 100644
--- a/gson/docs/javadocs/com/google/gson/annotations/Until.html
+++ b/gson/docs/javadocs/com/google/gson/annotations/Until.html
@@ -122,7 +122,7 @@ <H2>
 
  <p>If you created Gson with <code>new Gson()</code>, the <code>toJson()</code> and <code>fromJson()</code>
  methods will use all the fields for serialization and deserialization. However, if you created
- Gson with <code>Gson gson = new GsonBuilder().setVersion(1.2).create()</code> then the
+ Gson with <code>Gson gson = Gson.newBuilder().setVersion(1.2).build()</code> then the
  <code>toJson()</code> and <code>fromJson()</code> methods of Gson will exclude the <code>emailAddress</code>
  and <code>password</code> fields from the example above, because the version number passed to the 
  GsonBuilder, <code>1.2</code>, exceeds the version number set on the <code>Until</code> annotation,
diff --git a/gson/src/main/java/com/google/gson/ExclusionStrategy.java b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
index eb6a21054..49ff43c0e 100644
--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java
+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java
@@ -69,9 +69,9 @@
  * {@code GsonBuilder} to configure Gson to use one of the above sample:
  * <pre class="code">
  * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);
- * Gson gson = new GsonBuilder()
+ * Gson gson = Gson.newBuilder()
  *     .setExclusionStrategies(excludeStrings)
- *     .create();
+ *     .build();
  * </pre>
  *
  * <p>For certain model classes, you may only want to serialize a field, but exclude it for
@@ -81,9 +81,9 @@
  * For example:
  * <pre class="code">
  * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);
- * Gson gson = new GsonBuilder()
+ * Gson gson = Gson.newBuilder()
  *     .addDeserializationExclusionStrategy(excludeStrings)
- *     .create();
+ *     .build();
  * </pre>
  *
  * @author Inderjeet Singh
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index e6f826565..0eb267274 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -72,7 +72,7 @@
  * <p>Here is an example of how Gson is used for a simple Class:
  *
  * <pre>
- * Gson gson = new Gson(); // Or use new GsonBuilder().create();
+ * Gson gson = new Gson(); // Or use Gson.newBuilder().build();
  * MyType target = new MyType();
  * String json = gson.toJson(target); // serializes target to Json
  * MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2
@@ -103,936 +103,944 @@
  * @author Jesse Wilson
  */
 public final class Gson {
-  static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
-  static final boolean DEFAULT_LENIENT = false;
-  static final boolean DEFAULT_PRETTY_PRINT = false;
-  static final boolean DEFAULT_ESCAPE_HTML = true;
-  static final boolean DEFAULT_SERIALIZE_NULLS = false;
-  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
-  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
-
-  private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
-  private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
-
-  /**
-   * This thread local guards against reentrant calls to getAdapter(). In
-   * certain object graphs, creating an adapter for a type may recursively
-   * require an adapter for the same type! Without intervention, the recursive
-   * lookup would stack overflow. We cheat by returning a proxy type adapter.
-   * The proxy is wired up once the initial adapter has been created.
-   */
-  private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls = new ThreadLocal<>();
-  private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<>();
-
-  private final ConstructorConstructor constructorConstructor;
-  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
-
-  final List<TypeAdapterFactory> factories;
-
-  final Excluder excluder;
-  final FieldNamingStrategy fieldNamingStrategy;
-  final Map<Type, InstanceCreator<?>> instanceCreators;
-  final boolean serializeNulls;
-  final boolean complexMapKeySerialization;
-  final boolean generateNonExecutableJson;
-  final boolean htmlSafe;
-  final boolean prettyPrinting;
-  final boolean lenient;
-  final boolean serializeSpecialFloatingPointValues;
-  final String datePattern;
-  final int dateStyle;
-  final int timeStyle;
-  final LongSerializationPolicy longSerializationPolicy;
-  final List<TypeAdapterFactory> builderFactories;
-  final List<TypeAdapterFactory> builderHierarchyFactories;
-
-  /**
-   * Constructs a Gson object with default configuration. The default configuration has the
-   * following settings:
-   * <ul>
-   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This
-   *   means that all the unneeded white-space is removed. You can change this behavior with
-   *   {@link GsonBuilder#setPrettyPrinting()}. </li>
-   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are
-   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its
-   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values
-   *   by setting {@link GsonBuilder#serializeNulls()}.</li>
-   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},
-   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},
-   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer
-   *   to change the default representation, you can do so by registering a type adapter through
-   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>
-   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format
-   *   ignores the millisecond portion of the date during serialization. You can change
-   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
-   *   {@link GsonBuilder#setDateFormat(String)}. </li>
-   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.
-   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation
-   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>
-   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
-   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
-   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
-   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
-   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
-   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>
-   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from
-   *   consideration for serialization and deserialization. You can change this behavior through
-   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>
-   * </ul>
-   */
-  public Gson() {
-    this(Excluder.DEFAULT, FieldNamingStrategy.IDENTITY,
-        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
-        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
-        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
-        Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
-        Collections.<TypeAdapterFactory>emptyList());
-  }
-
-  Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
-      Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
-      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
-      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
-      LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
-      int timeStyle, List<TypeAdapterFactory> builderFactories,
-      List<TypeAdapterFactory> builderHierarchyFactories,
-      List<TypeAdapterFactory> factoriesToBeAdded) {
-    this.excluder = excluder;
-    this.fieldNamingStrategy = fieldNamingStrategy;
-    this.instanceCreators = instanceCreators;
-    this.constructorConstructor = new ConstructorConstructor(instanceCreators);
-    this.serializeNulls = serializeNulls;
-    this.complexMapKeySerialization = complexMapKeySerialization;
-    this.generateNonExecutableJson = generateNonExecutableGson;
-    this.htmlSafe = htmlSafe;
-    this.prettyPrinting = prettyPrinting;
-    this.lenient = lenient;
-    this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
-    this.longSerializationPolicy = longSerializationPolicy;
-    this.datePattern = datePattern;
-    this.dateStyle = dateStyle;
-    this.timeStyle = timeStyle;
-    this.builderFactories = builderFactories;
-    this.builderHierarchyFactories = builderHierarchyFactories;
-
-    List<TypeAdapterFactory> factories = new ArrayList<>();
-
-    // built-in type adapters that cannot be overridden
-    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);
-    factories.add(ObjectTypeAdapter.FACTORY);
-
-    // the excluder must precede all adapters that handle user-defined types
-    factories.add(excluder);
-
-    // users' type adapters
-    factories.addAll(factoriesToBeAdded);
-
-    // type adapters for basic platform types
-    factories.add(TypeAdapters.STRING_FACTORY);
-    factories.add(TypeAdapters.INTEGER_FACTORY);
-    factories.add(TypeAdapters.BOOLEAN_FACTORY);
-    factories.add(TypeAdapters.BYTE_FACTORY);
-    factories.add(TypeAdapters.SHORT_FACTORY);
-    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);
-    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));
-    factories.add(TypeAdapters.newFactory(double.class, Double.class,
-            doubleAdapter(serializeSpecialFloatingPointValues)));
-    factories.add(TypeAdapters.newFactory(float.class, Float.class,
-            floatAdapter(serializeSpecialFloatingPointValues)));
-    factories.add(TypeAdapters.NUMBER_FACTORY);
-    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);
-    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);
-    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));
-    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));
-    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);
-    factories.add(TypeAdapters.CHARACTER_FACTORY);
-    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);
-    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
-    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
-    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
-    factories.add(TypeAdapters.URL_FACTORY);
-    factories.add(TypeAdapters.URI_FACTORY);
-    factories.add(TypeAdapters.UUID_FACTORY);
-    factories.add(TypeAdapters.CURRENCY_FACTORY);
-    factories.add(TypeAdapters.LOCALE_FACTORY);
-    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
-    factories.add(TypeAdapters.BIT_SET_FACTORY);
-    factories.add(DateTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.CALENDAR_FACTORY);
-    factories.add(TimeTypeAdapter.FACTORY);
-    factories.add(SqlDateTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.TIMESTAMP_FACTORY);
-    factories.add(ArrayTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.CLASS_FACTORY);
-
-    // type adapters for composite and user-defined types
-    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
-    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
-    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);
-    factories.add(jsonAdapterFactory);
-    factories.add(TypeAdapters.ENUM_FACTORY);
-    factories.add(new ReflectiveTypeAdapterFactory(
-        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
-
-    this.factories = Collections.unmodifiableList(factories);
-  }
-
-  /**
-   * Returns a new GsonBuilder containing all custom factories and configuration used by the current
-   * instance.
-   *
-   * @return a GsonBuilder instance.
-   */
-  public GsonBuilder newBuilder() {
-    return new GsonBuilder(this);
-  }
-
-  public Excluder excluder() {
-    return excluder;
-  }
-
-  public FieldNamingStrategy fieldNamingStrategy() {
-    return fieldNamingStrategy;
-  }
-
-  public boolean serializeNulls() {
-    return serializeNulls;
-  }
-
-  public boolean htmlSafe() {
-    return htmlSafe;
-  }
-
-  private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
-    if (serializeSpecialFloatingPointValues) {
-      return TypeAdapters.DOUBLE;
-    }
-    return new TypeAdapter<>() {
-      @Override public Double read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return in.nextDouble();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        double doubleValue = value.doubleValue();
-        checkValidFloatingPoint(doubleValue);
-        out.value(value);
-      }
-    };
-  }
-
-  private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {
-    if (serializeSpecialFloatingPointValues) {
-      return TypeAdapters.FLOAT;
-    }
-    return new TypeAdapter<>() {
-      @Override public Float read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return (float) in.nextDouble();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        float floatValue = value.floatValue();
-        checkValidFloatingPoint(floatValue);
-        out.value(value);
-      }
-    };
-  }
-
-  static void checkValidFloatingPoint(double value) {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
-      throw new IllegalArgumentException(value
-          + " is not a valid double value as per JSON specification. To override this"
-          + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
-    }
-  }
-
-  private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {
-    if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {
-      return TypeAdapters.LONG;
-    }
-    return new TypeAdapter<>() {
-      @Override public Number read(JsonReader in) throws IOException {
-        if (in.peek() == JsonToken.NULL) {
-          in.nextNull();
-          return null;
-        }
-        return in.nextLong();
-      }
-      @Override public void write(JsonWriter out, Number value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-          return;
-        }
-        out.value(value.toString());
-      }
-    };
-  }
-
-  private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
-    return new TypeAdapter<AtomicLong>() {
-      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {
-        longAdapter.write(out, value.get());
-      }
-      @Override public AtomicLong read(JsonReader in) throws IOException {
-        Number value = longAdapter.read(in);
-        return new AtomicLong(value.longValue());
-      }
-    }.nullSafe();
-  }
-
-  private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {
-    return new TypeAdapter<AtomicLongArray>() {
-      @Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {
-        out.beginArray();
-        for (int i = 0, length = value.length(); i < length; i++) {
-          longAdapter.write(out, value.get(i));
-        }
-        out.endArray();
-      }
-      @Override public AtomicLongArray read(JsonReader in) throws IOException {
-        List<Long> list = new ArrayList<>();
-        in.beginArray();
-        while (in.hasNext()) {
-            long value = longAdapter.read(in).longValue();
-            list.add(value);
-        }
-        in.endArray();
-        int length = list.size();
-        AtomicLongArray array = new AtomicLongArray(length);
-        for (int i = 0; i < length; ++i) {
-          array.set(i, list.get(i));
-        }
-        return array;
-      }
-    }.nullSafe();
-  }
-
-  /**
-   * Returns the type adapter for {@code} type.
-   *
-   * @throws IllegalArgumentException if this GSON cannot serialize and
-   *     deserialize {@code type}.
-   */
-  @SuppressWarnings("unchecked")
-  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
-    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
-    if (cached != null) {
-      return (TypeAdapter<T>) cached;
-    }
-
-    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();
-    boolean requiresThreadLocalCleanup = false;
-    if (threadCalls == null) {
-      threadCalls = new HashMap<>();
-      calls.set(threadCalls);
-      requiresThreadLocalCleanup = true;
-    }
-
-    // the key and value type parameters always agree
-    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);
-    if (ongoingCall != null) {
-      return ongoingCall;
-    }
-
-    try {
-      FutureTypeAdapter<T> call = new FutureTypeAdapter<>();
-      threadCalls.put(type, call);
-
-      for (TypeAdapterFactory factory : factories) {
-        TypeAdapter<T> candidate = factory.create(this, type);
-        if (candidate != null) {
-          call.setDelegate(candidate);
-          typeTokenCache.put(type, candidate);
-          return candidate;
-        }
-      }
-      throw new IllegalArgumentException("GSON (" + GsonBuildConfig.VERSION + ") cannot handle " + type);
-    } finally {
-      threadCalls.remove(type);
-
-      if (requiresThreadLocalCleanup) {
-        calls.remove();
-      }
-    }
-  }
-
-  /**
-   * This method is used to get an alternate type adapter for the specified type. This is used
-   * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you
-   * may have registered. This features is typically used when you want to register a type
-   * adapter that does a little bit of work but then delegates further processing to the Gson
-   * default type adapter. Here is an example:
-   * <p>Let's say we want to write a type adapter that counts the number of objects being read
-   *  from or written to JSON. We can achieve this by writing a type adapter factory that uses
-   *  the <code>getDelegateAdapter</code> method:
-   *  <pre> {@code
-   *  class StatsTypeAdapterFactory implements TypeAdapterFactory {
-   *    public int numReads = 0;
-   *    public int numWrites = 0;
-   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
-   *      return new TypeAdapter<T>() {
-   *        public void write(JsonWriter out, T value) throws IOException {
-   *          ++numWrites;
-   *          delegate.write(out, value);
-   *        }
-   *        public T read(JsonReader in) throws IOException {
-   *          ++numReads;
-   *          return delegate.read(in);
-   *        }
-   *      };
-   *    }
-   *  }
-   *  } </pre>
-   *  This factory can now be used like this:
-   *  <pre> {@code
-   *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();
-   *  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();
-   *  // Call gson.toJson() and fromJson methods on objects
-   *  System.out.println("Num JSON reads" + stats.numReads);
-   *  System.out.println("Num JSON writes" + stats.numWrites);
-   *  }</pre>
-   *  Note that this call will skip all factories registered before {@code skipPast}. In case of
-   *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure
-   *  that the order of registration does not prevent this method from reaching a factory they
-   *  would expect to reply from this call.
-   *  Note that since you can not override type adapter factories for String and Java primitive
-   *  types, our stats factory will not count the number of String or primitives that will be
-   *  read or written.
-   * @param skipPast The type adapter factory that needs to be skipped while searching for
-   *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter
-   *   factory from where {@link #getDelegateAdapter} method is being invoked).
-   * @param type Type for which the delegate adapter is being searched for.
-   *
-   * @since 2.2
-   */
-  public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {
-    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via
-    // our @JsonAdapter annotation.
-    if (!factories.contains(skipPast)) {
-      skipPast = jsonAdapterFactory;
-    }
-
-    boolean skipPastFound = false;
-    for (TypeAdapterFactory factory : factories) {
-      if (!skipPastFound) {
-        if (factory == skipPast) {
-          skipPastFound = true;
-        }
-        continue;
-      }
-
-      TypeAdapter<T> candidate = factory.create(this, type);
-      if (candidate != null) {
-        return candidate;
-      }
-    }
-    throw new IllegalArgumentException("GSON cannot serialize " + type);
-  }
-
-  /**
-   * Returns the type adapter for {@code} type.
-   *
-   * @throws IllegalArgumentException if this GSON cannot serialize and
-   *     deserialize {@code type}.
-   */
-  public <T> TypeAdapter<T> getAdapter(Class<T> type) {
-    return getAdapter(TypeToken.get(type));
-  }
-
-  /**
-   * This method serializes the specified object into its equivalent representation as a tree of
-   * {@link JsonElement}s. This method should be used when the specified object is not a generic
-   * type. This method uses {@link Class#getClass()} to get the type for the specified object, but
-   * the {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJsonTree(Object, Type)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @return Json representation of {@code src}.
-   * @since 1.4
-   */
-  public JsonElement toJsonTree(Object src) {
-    if (src == null) {
-      return JsonNull.INSTANCE;
-    }
-    return toJsonTree(src, src.getClass());
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
-   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
-   * instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return Json representation of {@code src}
-   * @since 1.4
-   */
-  public JsonElement toJsonTree(Object src, Type typeOfSrc) {
-    JsonTreeWriter writer = new JsonTreeWriter();
-    toJson(src, typeOfSrc, writer);
-    return writer.get();
-  }
-
-  /**
-   * This method serializes the specified object into its equivalent Json representation.
-   * This method should be used when the specified object is not a generic type. This method uses
-   * {@link Class#getClass()} to get the type for the specified object, but the
-   * {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
-   * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @return Json representation of {@code src}.
-   */
-  public String toJson(Object src) {
-    if (src == null) {
-      return toJson(JsonNull.INSTANCE);
-    }
-    return toJson(src, src.getClass());
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent Json representation. This method must be used if the specified object is a generic
-   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
-   * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return Json representation of {@code src}
-   */
-  public String toJson(Object src, Type typeOfSrc) {
-    StringWriter writer = new StringWriter();
-    toJson(src, typeOfSrc, writer);
-    return writer.toString();
-  }
-
-  /**
-   * This method serializes the specified object into its equivalent Json representation.
-   * This method should be used when the specified object is not a generic type. This method uses
-   * {@link Class#getClass()} to get the type for the specified object, but the
-   * {@code getClass()} loses the generic type information because of the Type Erasure feature
-   * of Java. Note that this method works fine if the any of the object fields are of generic type,
-   * just the object itself should not be of a generic type. If the object is of generic type, use
-   * {@link #toJson(Object, Type, Appendable)} instead.
-   *
-   * @param src the object for which Json representation is to be created setting for Gson
-   * @param writer Writer to which the Json representation needs to be written
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.2
-   */
-  public void toJson(Object src, Appendable writer) throws JsonIOException {
-    if (src != null) {
-      toJson(src, src.getClass(), writer);
-    } else {
-      toJson(JsonNull.INSTANCE, writer);
-    }
-  }
-
-  /**
-   * This method serializes the specified object, including those of generic types, into its
-   * equivalent Json representation. This method must be used if the specified object is a generic
-   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
-   *
-   * @param src the object for which JSON representation is to be created
-   * @param typeOfSrc The specific genericized type of src. You can obtain
-   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
-   * to get the type for {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @param writer Writer to which the Json representation of src needs to be written.
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.2
-   */
-  public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {
-    try {
-      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
-      toJson(src, typeOfSrc, jsonWriter);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
-
-  /**
-   * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to
-   * {@code writer}.
-   * @throws JsonIOException if there was a problem writing to the writer
-   */
-  @SuppressWarnings("unchecked")
-  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
-    TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
-    boolean oldLenient = writer.isLenient();
-    writer.setLenient(true);
-    boolean oldHtmlSafe = writer.isHtmlSafe();
-    writer.setHtmlSafe(htmlSafe);
-    boolean oldSerializeNulls = writer.getSerializeNulls();
-    writer.setSerializeNulls(serializeNulls);
-    try {
-      ((TypeAdapter<Object>) adapter).write(writer, src);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (AssertionError e) {
-      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
-      error.initCause(e);
-      throw error;
-    } finally {
-      writer.setLenient(oldLenient);
-      writer.setHtmlSafe(oldHtmlSafe);
-      writer.setSerializeNulls(oldSerializeNulls);
-    }
-  }
-
-  /**
-   * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
-   *
-   * @param jsonElement root of a tree of {@link JsonElement}s
-   * @return JSON String representation of the tree
-   * @since 1.4
-   */
-  public String toJson(JsonElement jsonElement) {
-    StringWriter writer = new StringWriter();
-    toJson(jsonElement, writer);
-    return writer.toString();
-  }
-
-  /**
-   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.
-   *
-   * @param jsonElement root of a tree of {@link JsonElement}s
-   * @param writer Writer to which the Json representation needs to be written
-   * @throws JsonIOException if there was a problem writing to the writer
-   * @since 1.4
-   */
-  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {
-    try {
-      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
-      toJson(jsonElement, jsonWriter);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
-
-  /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
-   */
-  public JsonWriter newJsonWriter(Writer writer) throws IOException {
-    if (generateNonExecutableJson) {
-      writer.write(JSON_NON_EXECUTABLE_PREFIX);
-    }
-    JsonWriter jsonWriter = new JsonWriter(writer);
-    if (prettyPrinting) {
-      jsonWriter.setIndent("  ");
-    }
-    jsonWriter.setSerializeNulls(serializeNulls);
-    return jsonWriter;
-  }
-
-  /**
-   * Returns a new JSON reader configured for the settings on this Gson instance.
-   */
-  public JsonReader newJsonReader(Reader reader) {
-    JsonReader jsonReader = new JsonReader(reader);
-    jsonReader.setLenient(lenient);
-    return jsonReader;
-  }
-
-  /**
-   * Writes the JSON for {@code jsonElement} to {@code writer}.
-   * @throws JsonIOException if there was a problem writing to the writer
-   */
-  public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {
-    boolean oldLenient = writer.isLenient();
-    writer.setLenient(true);
-    boolean oldHtmlSafe = writer.isHtmlSafe();
-    writer.setHtmlSafe(htmlSafe);
-    boolean oldSerializeNulls = writer.getSerializeNulls();
-    writer.setSerializeNulls(serializeNulls);
-    try {
-      Streams.write(jsonElement, writer);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (AssertionError e) {
-      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
-      error.initCause(e);
-      throw error;
-    } finally {
-      writer.setLenient(oldLenient);
-      writer.setHtmlSafe(oldHtmlSafe);
-      writer.setSerializeNulls(oldSerializeNulls);
-    }
-  }
-
-  /**
-   * This method deserializes the specified Json into an object of the specified class. It is not
-   * suitable to use if the specified class is a generic type since it will not have the generic
-   * type information because of the Type Erasure feature of Java. Therefore, this method should not
-   * be used if the desired type is a generic type. Note that this method works fine if the any of
-   * the fields of the specified object are generics, just the object itself should not be a
-   * generic type. For the cases when the object is of generic type, invoke
-   * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
-   * a String, use {@link #fromJson(Reader, Class)} instead.
-   *
-   * @param <T> the type of the desired object
-   * @param json the string from which the object is to be deserialized
-   * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
-   * or if {@code json} is empty.
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type
-   * classOfT
-   */
-  public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
-    Object object = fromJson(json, (Type) classOfT);
-    return Primitives.wrap(classOfT).cast(object);
-  }
-
-  /**
-   * This method deserializes the specified Json into an object of the specified type. This method
-   * is useful if the specified object is a generic type. For non-generic objects, use
-   * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
-   * a String, use {@link #fromJson(Reader, Type)} instead.
-   *
-   * @param <T> the type of the desired object
-   * @param json the string from which the object is to be deserialized
-   * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
-   * {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
-   * or if {@code json} is empty.
-   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
-    if (json == null) {
-      return null;
-    }
-    StringReader reader = new StringReader(json);
-    T target = (T) fromJson(reader, typeOfT);
-    return target;
-  }
-
-  /**
-   * This method deserializes the Json read from the specified reader into an object of the
-   * specified class. It is not suitable to use if the specified class is a generic type since it
-   * will not have the generic type information because of the Type Erasure feature of Java.
-   * Therefore, this method should not be used if the desired type is a generic type. Note that
-   * this method works fine if the any of the fields of the specified object are generics, just the
-   * object itself should not be a generic type. For the cases when the object is of generic type,
-   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
-   * {@link Reader}, use {@link #fromJson(String, Class)} instead.
-   *
-   * @param <T> the type of the desired object
-   * @param json the reader producing the Json from which the object is to be deserialized.
-   * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
-   * @throws JsonIOException if there was a problem reading from the Reader
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type
-   * @since 1.2
-   */
-  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
-    JsonReader jsonReader = newJsonReader(json);
-    Object object = fromJson(jsonReader, classOfT);
-    assertFullConsumption(object, jsonReader);
-    return Primitives.wrap(classOfT).cast(object);
-  }
-
-  /**
-   * This method deserializes the Json read from the specified reader into an object of the
-   * specified type. This method is useful if the specified object is a generic type. For
-   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
-   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
-   *
-   * @param <T> the type of the desired object
-   * @param json the reader producing Json from which the object is to be deserialized
-   * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
-   * {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
-   * @throws JsonIOException if there was a problem reading from the Reader
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type
-   * @since 1.2
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
-    JsonReader jsonReader = newJsonReader(json);
-    T object = (T) fromJson(jsonReader, typeOfT);
-    assertFullConsumption(object, jsonReader);
-    return object;
-  }
-
-  private static void assertFullConsumption(Object obj, JsonReader reader) {
-    try {
-      if (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {
-        throw new JsonIOException("JSON document was not fully consumed.");
-      }
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
-
-  /**
-   * Reads the next JSON value from {@code reader} and convert it to an object
-   * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.
-   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully
-   *
-   * @throws JsonIOException if there was a problem writing to the Reader
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {
-    boolean isEmpty = true;
-    boolean oldLenient = reader.isLenient();
-    reader.setLenient(true);
-    try {
-      reader.peek();
-      isEmpty = false;
-      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);
-      TypeAdapter<T> typeAdapter = getAdapter(typeToken);
-      T object = typeAdapter.read(reader);
-      return object;
-    } catch (EOFException e) {
-      /*
-       * For compatibility with JSON 1.5 and earlier, we return null for empty
-       * documents instead of throwing.
-       */
-      if (isEmpty) {
-        return null;
-      }
-      throw new JsonSyntaxException(e);
-    } catch (IllegalStateException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
-      throw new JsonSyntaxException(e);
-    } catch (AssertionError e) {
-      AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
-      error.initCause(e);
-      throw error;
-    } finally {
-      reader.setLenient(oldLenient);
-    }
-  }
-
-  /**
-   * This method deserializes the Json read from the specified parse tree into an object of the
-   * specified type. It is not suitable to use if the specified class is a generic type since it
-   * will not have the generic type information because of the Type Erasure feature of Java.
-   * Therefore, this method should not be used if the desired type is a generic type. Note that
-   * this method works fine if the any of the fields of the specified object are generics, just the
-   * object itself should not be a generic type. For the cases when the object is of generic type,
-   * invoke {@link #fromJson(JsonElement, Type)}.
-   * @param <T> the type of the desired object
-   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
-   * be deserialized
-   * @param classOfT The class of T
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
-   * or if {@code json} is empty.
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
-   * @since 1.3
-   */
-  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
-    Object object = fromJson(json, (Type) classOfT);
-    return Primitives.wrap(classOfT).cast(object);
-  }
-
-  /**
-   * This method deserializes the Json read from the specified parse tree into an object of the
-   * specified type. This method is useful if the specified object is a generic type. For
-   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
-   *
-   * @param <T> the type of the desired object
-   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
-   * be deserialized
-   * @param typeOfT The specific genericized type of src. You can obtain this type by using the
-   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
-   * {@code Collection<Foo>}, you should use:
-   * <pre>
-   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
-   * </pre>
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
-   * or if {@code json} is empty.
-   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
-   * @since 1.3
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
-    if (json == null) {
-      return null;
-    }
-    return (T) fromJson(new JsonTreeReader(json), typeOfT);
-  }
-
-  static class FutureTypeAdapter<T> extends TypeAdapter<T> {
-    private TypeAdapter<T> delegate;
-
-    public void setDelegate(TypeAdapter<T> typeAdapter) {
-      if (delegate != null) {
-        throw new AssertionError();
-      }
-      delegate = typeAdapter;
-    }
-
-    @Override public T read(JsonReader in) throws IOException {
-      if (delegate == null) {
-        throw new IllegalStateException();
-      }
-      return delegate.read(in);
-    }
-
-    @Override public void write(JsonWriter out, T value) throws IOException {
-      if (delegate == null) {
-        throw new IllegalStateException();
-      }
-      delegate.write(out, value);
-    }
-  }
-
-  @Override
-  public String toString() {
-    return new StringBuilder("{serializeNulls:")
-        .append(serializeNulls)
-        .append(",factories:").append(factories)
-        .append(",instanceCreators:").append(constructorConstructor)
-        .append("}")
-        .toString();
-  }
+	static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
+	static final boolean DEFAULT_LENIENT = false;
+	static final boolean DEFAULT_PRETTY_PRINT = false;
+	static final boolean DEFAULT_ESCAPE_HTML = true;
+	static final boolean DEFAULT_SERIALIZE_NULLS = false;
+	static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
+	static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
+
+	private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
+	private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
+
+	/**
+	 * This thread local guards against reentrant calls to getAdapter(). In
+	 * certain object graphs, creating an adapter for a type may recursively
+	 * require an adapter for the same type! Without intervention, the recursive
+	 * lookup would stack overflow. We cheat by returning a proxy type adapter.
+	 * The proxy is wired up once the initial adapter has been created.
+	 */
+	private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls = new ThreadLocal<>();
+	private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<>();
+
+	private final ConstructorConstructor constructorConstructor;
+	private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+
+	final List<TypeAdapterFactory> factories;
+
+	final Excluder excluder;
+	final FieldNamingStrategy fieldNamingStrategy;
+	final Map<Type, InstanceCreator<?>> instanceCreators;
+	final boolean serializeNulls;
+	final boolean complexMapKeySerialization;
+	final boolean generateNonExecutableJson;
+	final boolean htmlSafe;
+	final boolean prettyPrinting;
+	final boolean lenient;
+	final boolean serializeSpecialFloatingPointValues;
+	final String datePattern;
+	final int dateStyle;
+	final int timeStyle;
+	final LongSerializationPolicy longSerializationPolicy;
+	final List<TypeAdapterFactory> builderFactories;
+	final List<TypeAdapterFactory> builderHierarchyFactories;
+
+	/**
+	 * Constructs a Gson object with default configuration. The default configuration has the
+	 * following settings:
+	 * <ul>
+	 *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This
+	 *   means that all the unneeded white-space is removed. You can change this behavior with
+	 *   {@link GsonBuilder#setPrettyPrinting()}. </li>
+	 *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are
+	 *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its
+	 *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values
+	 *   by setting {@link GsonBuilder#serializeNulls()}.</li>
+	 *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},
+	 *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},
+	 *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer
+	 *   to change the default representation, you can do so by registering a type adapter through
+	 *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>
+	 *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format
+	 *   ignores the millisecond portion of the date during serialization. You can change
+	 *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
+	 *   {@link GsonBuilder#setDateFormat(String)}. </li>
+	 *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.
+	 *   You can enable Gson to serialize/deserialize only those fields marked with this annotation
+	 *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>
+	 *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
+	 *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
+	 *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
+	 *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
+	 *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
+	 *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>
+	 *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from
+	 *   consideration for serialization and deserialization. You can change this behavior through
+	 *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>
+	 * </ul>
+	 */
+	public Gson() {
+		this(Excluder.DEFAULT, FieldNamingStrategy.IDENTITY,
+				Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
+				DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
+				DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
+				LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
+				Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
+				Collections.<TypeAdapterFactory>emptyList());
+	}
+
+	Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
+			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
+			boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
+			LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
+			int timeStyle, List<TypeAdapterFactory> builderFactories,
+			List<TypeAdapterFactory> builderHierarchyFactories,
+			List<TypeAdapterFactory> factoriesToBeAdded) {
+		this.excluder = excluder;
+		this.fieldNamingStrategy = fieldNamingStrategy;
+		this.instanceCreators = instanceCreators;
+		this.constructorConstructor = new ConstructorConstructor(instanceCreators);
+		this.serializeNulls = serializeNulls;
+		this.complexMapKeySerialization = complexMapKeySerialization;
+		this.generateNonExecutableJson = generateNonExecutableGson;
+		this.htmlSafe = htmlSafe;
+		this.prettyPrinting = prettyPrinting;
+		this.lenient = lenient;
+		this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
+		this.longSerializationPolicy = longSerializationPolicy;
+		this.datePattern = datePattern;
+		this.dateStyle = dateStyle;
+		this.timeStyle = timeStyle;
+		this.builderFactories = builderFactories;
+		this.builderHierarchyFactories = builderHierarchyFactories;
+
+		List<TypeAdapterFactory> factories = new ArrayList<>();
+
+		// built-in type adapters that cannot be overridden
+		factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);
+		factories.add(ObjectTypeAdapter.FACTORY);
+
+		// the excluder must precede all adapters that handle user-defined types
+		factories.add(excluder);
+
+		// users' type adapters
+		factories.addAll(factoriesToBeAdded);
+
+		// type adapters for basic platform types
+		factories.add(TypeAdapters.STRING_FACTORY);
+		factories.add(TypeAdapters.INTEGER_FACTORY);
+		factories.add(TypeAdapters.BOOLEAN_FACTORY);
+		factories.add(TypeAdapters.BYTE_FACTORY);
+		factories.add(TypeAdapters.SHORT_FACTORY);
+		TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);
+		factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));
+		factories.add(TypeAdapters.newFactory(double.class, Double.class,
+				doubleAdapter(serializeSpecialFloatingPointValues)));
+		factories.add(TypeAdapters.newFactory(float.class, Float.class,
+				floatAdapter(serializeSpecialFloatingPointValues)));
+		factories.add(TypeAdapters.NUMBER_FACTORY);
+		factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);
+		factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);
+		factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));
+		factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));
+		factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);
+		factories.add(TypeAdapters.CHARACTER_FACTORY);
+		factories.add(TypeAdapters.STRING_BUILDER_FACTORY);
+		factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
+		factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
+		factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
+		factories.add(TypeAdapters.URL_FACTORY);
+		factories.add(TypeAdapters.URI_FACTORY);
+		factories.add(TypeAdapters.UUID_FACTORY);
+		factories.add(TypeAdapters.CURRENCY_FACTORY);
+		factories.add(TypeAdapters.LOCALE_FACTORY);
+		factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
+		factories.add(TypeAdapters.BIT_SET_FACTORY);
+		factories.add(DateTypeAdapter.FACTORY);
+		factories.add(TypeAdapters.CALENDAR_FACTORY);
+		factories.add(TimeTypeAdapter.FACTORY);
+		factories.add(SqlDateTypeAdapter.FACTORY);
+		factories.add(TypeAdapters.TIMESTAMP_FACTORY);
+		factories.add(ArrayTypeAdapter.FACTORY);
+		factories.add(TypeAdapters.CLASS_FACTORY);
+
+		// type adapters for composite and user-defined types
+		factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
+		factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
+		this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);
+		factories.add(jsonAdapterFactory);
+		factories.add(TypeAdapters.ENUM_FACTORY);
+		factories.add(new ReflectiveTypeAdapterFactory(
+				constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
+
+		this.factories = Collections.unmodifiableList(factories);
+	}
+
+	/**
+	 * Returns a new GsonBuilder containing all custom factories and configuration used by the current
+	 * instance.
+	 *
+	 * @return a GsonBuilder instance.
+	 */
+	public GsonBuilder rebuild() {
+		return new GsonBuilder(this);
+	}
+	
+	public static Gson newGson() {
+		return new GsonBuilder().build();
+	}
+
+	public static GsonBuilder newBuilder() {
+		return new GsonBuilder();
+	}
+
+	public Excluder excluder() {
+		return excluder;
+	}
+
+	public FieldNamingStrategy fieldNamingStrategy() {
+		return fieldNamingStrategy;
+	}
+
+	public boolean serializeNulls() {
+		return serializeNulls;
+	}
+
+	public boolean htmlSafe() {
+		return htmlSafe;
+	}
+
+	private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
+		if (serializeSpecialFloatingPointValues) {
+			return TypeAdapters.DOUBLE;
+		}
+		return new TypeAdapter<>() {
+			@Override public Double read(JsonReader in) throws IOException {
+				if (in.peek() == JsonToken.NULL) {
+					in.nextNull();
+					return null;
+				}
+				return in.nextDouble();
+			}
+			@Override public void write(JsonWriter out, Number value) throws IOException {
+				if (value == null) {
+					out.nullValue();
+					return;
+				}
+				double doubleValue = value.doubleValue();
+				checkValidFloatingPoint(doubleValue);
+				out.value(value);
+			}
+		};
+	}
+
+	private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {
+		if (serializeSpecialFloatingPointValues) {
+			return TypeAdapters.FLOAT;
+		}
+		return new TypeAdapter<>() {
+			@Override public Float read(JsonReader in) throws IOException {
+				if (in.peek() == JsonToken.NULL) {
+					in.nextNull();
+					return null;
+				}
+				return (float) in.nextDouble();
+			}
+			@Override public void write(JsonWriter out, Number value) throws IOException {
+				if (value == null) {
+					out.nullValue();
+					return;
+				}
+				float floatValue = value.floatValue();
+				checkValidFloatingPoint(floatValue);
+				out.value(value);
+			}
+		};
+	}
+
+	static void checkValidFloatingPoint(double value) {
+		if (Double.isNaN(value) || Double.isInfinite(value)) {
+			throw new IllegalArgumentException(value
+					+ " is not a valid double value as per JSON specification. To override this"
+					+ " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
+		}
+	}
+
+	private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {
+		if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {
+			return TypeAdapters.LONG;
+		}
+		return new TypeAdapter<>() {
+			@Override public Number read(JsonReader in) throws IOException {
+				if (in.peek() == JsonToken.NULL) {
+					in.nextNull();
+					return null;
+				}
+				return in.nextLong();
+			}
+			@Override public void write(JsonWriter out, Number value) throws IOException {
+				if (value == null) {
+					out.nullValue();
+					return;
+				}
+				out.value(value.toString());
+			}
+		};
+	}
+
+	private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
+		return new TypeAdapter<AtomicLong>() {
+			@Override public void write(JsonWriter out, AtomicLong value) throws IOException {
+				longAdapter.write(out, value.get());
+			}
+			@Override public AtomicLong read(JsonReader in) throws IOException {
+				Number value = longAdapter.read(in);
+				return new AtomicLong(value.longValue());
+			}
+		}.nullSafe();
+	}
+
+	private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {
+		return new TypeAdapter<AtomicLongArray>() {
+			@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {
+				out.beginArray();
+				for (int i = 0, length = value.length(); i < length; i++) {
+					longAdapter.write(out, value.get(i));
+				}
+				out.endArray();
+			}
+			@Override public AtomicLongArray read(JsonReader in) throws IOException {
+				List<Long> list = new ArrayList<>();
+				in.beginArray();
+				while (in.hasNext()) {
+					long value = longAdapter.read(in).longValue();
+					list.add(value);
+				}
+				in.endArray();
+				int length = list.size();
+				AtomicLongArray array = new AtomicLongArray(length);
+				for (int i = 0; i < length; ++i) {
+					array.set(i, list.get(i));
+				}
+				return array;
+			}
+		}.nullSafe();
+	}
+
+	/**
+	 * Returns the type adapter for {@code} type.
+	 *
+	 * @throws IllegalArgumentException if this GSON cannot serialize and
+	 *     deserialize {@code type}.
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
+		TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
+		if (cached != null) {
+			return (TypeAdapter<T>) cached;
+		}
+
+		Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();
+		boolean requiresThreadLocalCleanup = false;
+		if (threadCalls == null) {
+			threadCalls = new HashMap<>();
+			calls.set(threadCalls);
+			requiresThreadLocalCleanup = true;
+		}
+
+		// the key and value type parameters always agree
+		FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);
+		if (ongoingCall != null) {
+			return ongoingCall;
+		}
+
+		try {
+			FutureTypeAdapter<T> call = new FutureTypeAdapter<>();
+			threadCalls.put(type, call);
+
+			for (TypeAdapterFactory factory : factories) {
+				TypeAdapter<T> candidate = factory.create(this, type);
+				if (candidate != null) {
+					call.setDelegate(candidate);
+					typeTokenCache.put(type, candidate);
+					return candidate;
+				}
+			}
+			throw new IllegalArgumentException("GSON (" + GsonBuildConfig.VERSION + ") cannot handle " + type);
+		} finally {
+			threadCalls.remove(type);
+
+			if (requiresThreadLocalCleanup) {
+				calls.remove();
+			}
+		}
+	}
+
+	/**
+	 * This method is used to get an alternate type adapter for the specified type. This is used
+	 * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you
+	 * may have registered. This features is typically used when you want to register a type
+	 * adapter that does a little bit of work but then delegates further processing to the Gson
+	 * default type adapter. Here is an example:
+	 * <p>Let's say we want to write a type adapter that counts the number of objects being read
+	 *  from or written to JSON. We can achieve this by writing a type adapter factory that uses
+	 *  the <code>getDelegateAdapter</code> method:
+	 *  <pre> {@code
+	 *  class StatsTypeAdapterFactory implements TypeAdapterFactory {
+	 *    public int numReads = 0;
+	 *    public int numWrites = 0;
+	 *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+	 *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+	 *      return new TypeAdapter<T>() {
+	 *        public void write(JsonWriter out, T value) throws IOException {
+	 *          ++numWrites;
+	 *          delegate.write(out, value);
+	 *        }
+	 *        public T read(JsonReader in) throws IOException {
+	 *          ++numReads;
+	 *          return delegate.read(in);
+	 *        }
+	 *      };
+	 *    }
+	 *  }
+	 *  } </pre>
+	 *  This factory can now be used like this:
+	 *  <pre> {@code
+	 *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();
+	 *  Gson gson = Gson.newBuilder().registerTypeAdapterFactory(stats).build();
+	 *  // Call gson.toJson() and fromJson methods on objects
+	 *  System.out.println("Num JSON reads" + stats.numReads);
+	 *  System.out.println("Num JSON writes" + stats.numWrites);
+	 *  }</pre>
+	 *  Note that this call will skip all factories registered before {@code skipPast}. In case of
+	 *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure
+	 *  that the order of registration does not prevent this method from reaching a factory they
+	 *  would expect to reply from this call.
+	 *  Note that since you can not override type adapter factories for String and Java primitive
+	 *  types, our stats factory will not count the number of String or primitives that will be
+	 *  read or written.
+	 * @param skipPast The type adapter factory that needs to be skipped while searching for
+	 *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter
+	 *   factory from where {@link #getDelegateAdapter} method is being invoked).
+	 * @param type Type for which the delegate adapter is being searched for.
+	 *
+	 * @since 2.2
+	 */
+	public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {
+		// Hack. If the skipPast factory isn't registered, assume the factory is being requested via
+		// our @JsonAdapter annotation.
+		if (!factories.contains(skipPast)) {
+			skipPast = jsonAdapterFactory;
+		}
+
+		boolean skipPastFound = false;
+		for (TypeAdapterFactory factory : factories) {
+			if (!skipPastFound) {
+				if (factory == skipPast) {
+					skipPastFound = true;
+				}
+				continue;
+			}
+
+			TypeAdapter<T> candidate = factory.create(this, type);
+			if (candidate != null) {
+				return candidate;
+			}
+		}
+		throw new IllegalArgumentException("GSON cannot serialize " + type);
+	}
+
+	/**
+	 * Returns the type adapter for {@code} type.
+	 *
+	 * @throws IllegalArgumentException if this GSON cannot serialize and
+	 *     deserialize {@code type}.
+	 */
+	public <T> TypeAdapter<T> getAdapter(Class<T> type) {
+		return getAdapter(TypeToken.get(type));
+	}
+
+	/**
+	 * This method serializes the specified object into its equivalent representation as a tree of
+	 * {@link JsonElement}s. This method should be used when the specified object is not a generic
+	 * type. This method uses {@link Class#getClass()} to get the type for the specified object, but
+	 * the {@code getClass()} loses the generic type information because of the Type Erasure feature
+	 * of Java. Note that this method works fine if the any of the object fields are of generic type,
+	 * just the object itself should not be of a generic type. If the object is of generic type, use
+	 * {@link #toJsonTree(Object, Type)} instead.
+	 *
+	 * @param src the object for which Json representation is to be created setting for Gson
+	 * @return Json representation of {@code src}.
+	 * @since 1.4
+	 */
+	public JsonElement toJsonTree(Object src) {
+		if (src == null) {
+			return JsonNull.INSTANCE;
+		}
+		return toJsonTree(src, src.getClass());
+	}
+
+	/**
+	 * This method serializes the specified object, including those of generic types, into its
+	 * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
+	 * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
+	 * instead.
+	 *
+	 * @param src the object for which JSON representation is to be created
+	 * @param typeOfSrc The specific genericized type of src. You can obtain
+	 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
+	 * to get the type for {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @return Json representation of {@code src}
+	 * @since 1.4
+	 */
+	public JsonElement toJsonTree(Object src, Type typeOfSrc) {
+		JsonTreeWriter writer = new JsonTreeWriter();
+		toJson(src, typeOfSrc, writer);
+		return writer.get();
+	}
+
+	/**
+	 * This method serializes the specified object into its equivalent Json representation.
+	 * This method should be used when the specified object is not a generic type. This method uses
+	 * {@link Class#getClass()} to get the type for the specified object, but the
+	 * {@code getClass()} loses the generic type information because of the Type Erasure feature
+	 * of Java. Note that this method works fine if the any of the object fields are of generic type,
+	 * just the object itself should not be of a generic type. If the object is of generic type, use
+	 * {@link #toJson(Object, Type)} instead. If you want to write out the object to a
+	 * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
+	 *
+	 * @param src the object for which Json representation is to be created setting for Gson
+	 * @return Json representation of {@code src}.
+	 */
+	public String toJson(Object src) {
+		if (src == null) {
+			return toJson(JsonNull.INSTANCE);
+		}
+		return toJson(src, src.getClass());
+	}
+
+	/**
+	 * This method serializes the specified object, including those of generic types, into its
+	 * equivalent Json representation. This method must be used if the specified object is a generic
+	 * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
+	 * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
+	 *
+	 * @param src the object for which JSON representation is to be created
+	 * @param typeOfSrc The specific genericized type of src. You can obtain
+	 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
+	 * to get the type for {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @return Json representation of {@code src}
+	 */
+	public String toJson(Object src, Type typeOfSrc) {
+		StringWriter writer = new StringWriter();
+		toJson(src, typeOfSrc, writer);
+		return writer.toString();
+	}
+
+	/**
+	 * This method serializes the specified object into its equivalent Json representation.
+	 * This method should be used when the specified object is not a generic type. This method uses
+	 * {@link Class#getClass()} to get the type for the specified object, but the
+	 * {@code getClass()} loses the generic type information because of the Type Erasure feature
+	 * of Java. Note that this method works fine if the any of the object fields are of generic type,
+	 * just the object itself should not be of a generic type. If the object is of generic type, use
+	 * {@link #toJson(Object, Type, Appendable)} instead.
+	 *
+	 * @param src the object for which Json representation is to be created setting for Gson
+	 * @param writer Writer to which the Json representation needs to be written
+	 * @throws JsonIOException if there was a problem writing to the writer
+	 * @since 1.2
+	 */
+	public void toJson(Object src, Appendable writer) throws JsonIOException {
+		if (src != null) {
+			toJson(src, src.getClass(), writer);
+		} else {
+			toJson(JsonNull.INSTANCE, writer);
+		}
+	}
+
+	/**
+	 * This method serializes the specified object, including those of generic types, into its
+	 * equivalent Json representation. This method must be used if the specified object is a generic
+	 * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
+	 *
+	 * @param src the object for which JSON representation is to be created
+	 * @param typeOfSrc The specific genericized type of src. You can obtain
+	 * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
+	 * to get the type for {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @param writer Writer to which the Json representation of src needs to be written.
+	 * @throws JsonIOException if there was a problem writing to the writer
+	 * @since 1.2
+	 */
+	public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {
+		try {
+			JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
+			toJson(src, typeOfSrc, jsonWriter);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
+
+	/**
+	 * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to
+	 * {@code writer}.
+	 * @throws JsonIOException if there was a problem writing to the writer
+	 */
+	@SuppressWarnings("unchecked")
+	public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
+		TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
+		boolean oldLenient = writer.isLenient();
+		writer.setLenient(true);
+		boolean oldHtmlSafe = writer.isHtmlSafe();
+		writer.setHtmlSafe(htmlSafe);
+		boolean oldSerializeNulls = writer.getSerializeNulls();
+		writer.setSerializeNulls(serializeNulls);
+		try {
+			((TypeAdapter<Object>) adapter).write(writer, src);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		} catch (AssertionError e) {
+			AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+			error.initCause(e);
+			throw error;
+		} finally {
+			writer.setLenient(oldLenient);
+			writer.setHtmlSafe(oldHtmlSafe);
+			writer.setSerializeNulls(oldSerializeNulls);
+		}
+	}
+
+	/**
+	 * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.
+	 *
+	 * @param jsonElement root of a tree of {@link JsonElement}s
+	 * @return JSON String representation of the tree
+	 * @since 1.4
+	 */
+	public String toJson(JsonElement jsonElement) {
+		StringWriter writer = new StringWriter();
+		toJson(jsonElement, writer);
+		return writer.toString();
+	}
+
+	/**
+	 * Writes out the equivalent JSON for a tree of {@link JsonElement}s.
+	 *
+	 * @param jsonElement root of a tree of {@link JsonElement}s
+	 * @param writer Writer to which the Json representation needs to be written
+	 * @throws JsonIOException if there was a problem writing to the writer
+	 * @since 1.4
+	 */
+	public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {
+		try {
+			JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
+			toJson(jsonElement, jsonWriter);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
+
+	/**
+	 * Returns a new JSON writer configured for the settings on this Gson instance.
+	 */
+	public JsonWriter newJsonWriter(Writer writer) throws IOException {
+		if (generateNonExecutableJson) {
+			writer.write(JSON_NON_EXECUTABLE_PREFIX);
+		}
+		JsonWriter jsonWriter = new JsonWriter(writer);
+		if (prettyPrinting) {
+			jsonWriter.setIndent("  ");
+		}
+		jsonWriter.setSerializeNulls(serializeNulls);
+		return jsonWriter;
+	}
+
+	/**
+	 * Returns a new JSON reader configured for the settings on this Gson instance.
+	 */
+	public JsonReader newJsonReader(Reader reader) {
+		JsonReader jsonReader = new JsonReader(reader);
+		jsonReader.setLenient(lenient);
+		return jsonReader;
+	}
+
+	/**
+	 * Writes the JSON for {@code jsonElement} to {@code writer}.
+	 * @throws JsonIOException if there was a problem writing to the writer
+	 */
+	public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {
+		boolean oldLenient = writer.isLenient();
+		writer.setLenient(true);
+		boolean oldHtmlSafe = writer.isHtmlSafe();
+		writer.setHtmlSafe(htmlSafe);
+		boolean oldSerializeNulls = writer.getSerializeNulls();
+		writer.setSerializeNulls(serializeNulls);
+		try {
+			Streams.write(jsonElement, writer);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		} catch (AssertionError e) {
+			AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+			error.initCause(e);
+			throw error;
+		} finally {
+			writer.setLenient(oldLenient);
+			writer.setHtmlSafe(oldHtmlSafe);
+			writer.setSerializeNulls(oldSerializeNulls);
+		}
+	}
+
+	/**
+	 * This method deserializes the specified Json into an object of the specified class. It is not
+	 * suitable to use if the specified class is a generic type since it will not have the generic
+	 * type information because of the Type Erasure feature of Java. Therefore, this method should not
+	 * be used if the desired type is a generic type. Note that this method works fine if the any of
+	 * the fields of the specified object are generics, just the object itself should not be a
+	 * generic type. For the cases when the object is of generic type, invoke
+	 * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
+	 * a String, use {@link #fromJson(Reader, Class)} instead.
+	 *
+	 * @param <T> the type of the desired object
+	 * @param json the string from which the object is to be deserialized
+	 * @param classOfT the class of T
+	 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+	 * or if {@code json} is empty.
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type
+	 * classOfT
+	 */
+	public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {
+		Object object = fromJson(json, (Type) classOfT);
+		return Primitives.wrap(classOfT).cast(object);
+	}
+
+	/**
+	 * This method deserializes the specified Json into an object of the specified type. This method
+	 * is useful if the specified object is a generic type. For non-generic objects, use
+	 * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
+	 * a String, use {@link #fromJson(Reader, Type)} instead.
+	 *
+	 * @param <T> the type of the desired object
+	 * @param json the string from which the object is to be deserialized
+	 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
+	 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+	 * {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+	 * or if {@code json} is empty.
+	 * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
+		if (json == null) {
+			return null;
+		}
+		StringReader reader = new StringReader(json);
+		T target = (T) fromJson(reader, typeOfT);
+		return target;
+	}
+
+	/**
+	 * This method deserializes the Json read from the specified reader into an object of the
+	 * specified class. It is not suitable to use if the specified class is a generic type since it
+	 * will not have the generic type information because of the Type Erasure feature of Java.
+	 * Therefore, this method should not be used if the desired type is a generic type. Note that
+	 * this method works fine if the any of the fields of the specified object are generics, just the
+	 * object itself should not be a generic type. For the cases when the object is of generic type,
+	 * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
+	 * {@link Reader}, use {@link #fromJson(String, Class)} instead.
+	 *
+	 * @param <T> the type of the desired object
+	 * @param json the reader producing the Json from which the object is to be deserialized.
+	 * @param classOfT the class of T
+	 * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
+	 * @throws JsonIOException if there was a problem reading from the Reader
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type
+	 * @since 1.2
+	 */
+	public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
+		JsonReader jsonReader = newJsonReader(json);
+		Object object = fromJson(jsonReader, classOfT);
+		assertFullConsumption(object, jsonReader);
+		return Primitives.wrap(classOfT).cast(object);
+	}
+
+	/**
+	 * This method deserializes the Json read from the specified reader into an object of the
+	 * specified type. This method is useful if the specified object is a generic type. For
+	 * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
+	 * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
+	 *
+	 * @param <T> the type of the desired object
+	 * @param json the reader producing Json from which the object is to be deserialized
+	 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
+	 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+	 * {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
+	 * @throws JsonIOException if there was a problem reading from the Reader
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type
+	 * @since 1.2
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
+		JsonReader jsonReader = newJsonReader(json);
+		T object = (T) fromJson(jsonReader, typeOfT);
+		assertFullConsumption(object, jsonReader);
+		return object;
+	}
+
+	private static void assertFullConsumption(Object obj, JsonReader reader) {
+		try {
+			if (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {
+				throw new JsonIOException("JSON document was not fully consumed.");
+			}
+		} catch (MalformedJsonException e) {
+			throw new JsonSyntaxException(e);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
+
+	/**
+	 * Reads the next JSON value from {@code reader} and convert it to an object
+	 * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.
+	 * Since Type is not parameterized by T, this method is type unsafe and should be used carefully
+	 *
+	 * @throws JsonIOException if there was a problem writing to the Reader
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {
+		boolean isEmpty = true;
+		boolean oldLenient = reader.isLenient();
+		reader.setLenient(true);
+		try {
+			reader.peek();
+			isEmpty = false;
+			TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);
+			TypeAdapter<T> typeAdapter = getAdapter(typeToken);
+			T object = typeAdapter.read(reader);
+			return object;
+		} catch (EOFException e) {
+			/*
+			 * For compatibility with JSON 1.5 and earlier, we return null for empty
+			 * documents instead of throwing.
+			 */
+			if (isEmpty) {
+				return null;
+			}
+			throw new JsonSyntaxException(e);
+		} catch (IllegalStateException e) {
+			throw new JsonSyntaxException(e);
+		} catch (IOException e) {
+			// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
+			throw new JsonSyntaxException(e);
+		} catch (AssertionError e) {
+			AssertionError error = new AssertionError("AssertionError (GSON " + GsonBuildConfig.VERSION + "): " + e.getMessage());
+			error.initCause(e);
+			throw error;
+		} finally {
+			reader.setLenient(oldLenient);
+		}
+	}
+
+	/**
+	 * This method deserializes the Json read from the specified parse tree into an object of the
+	 * specified type. It is not suitable to use if the specified class is a generic type since it
+	 * will not have the generic type information because of the Type Erasure feature of Java.
+	 * Therefore, this method should not be used if the desired type is a generic type. Note that
+	 * this method works fine if the any of the fields of the specified object are generics, just the
+	 * object itself should not be a generic type. For the cases when the object is of generic type,
+	 * invoke {@link #fromJson(JsonElement, Type)}.
+	 * @param <T> the type of the desired object
+	 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
+	 * be deserialized
+	 * @param classOfT The class of T
+	 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+	 * or if {@code json} is empty.
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
+	 * @since 1.3
+	 */
+	public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {
+		Object object = fromJson(json, (Type) classOfT);
+		return Primitives.wrap(classOfT).cast(object);
+	}
+
+	/**
+	 * This method deserializes the Json read from the specified parse tree into an object of the
+	 * specified type. This method is useful if the specified object is a generic type. For
+	 * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
+	 *
+	 * @param <T> the type of the desired object
+	 * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
+	 * be deserialized
+	 * @param typeOfT The specific genericized type of src. You can obtain this type by using the
+	 * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
+	 * {@code Collection<Foo>}, you should use:
+	 * <pre>
+	 * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
+	 * </pre>
+	 * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+	 * or if {@code json} is empty.
+	 * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
+	 * @since 1.3
+	 */
+	@SuppressWarnings("unchecked")
+	public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
+		if (json == null) {
+			return null;
+		}
+		return (T) fromJson(new JsonTreeReader(json), typeOfT);
+	}
+
+	static class FutureTypeAdapter<T> extends TypeAdapter<T> {
+		private TypeAdapter<T> delegate;
+
+		public void setDelegate(TypeAdapter<T> typeAdapter) {
+			if (delegate != null) {
+				throw new AssertionError();
+			}
+			delegate = typeAdapter;
+		}
+
+		@Override public T read(JsonReader in) throws IOException {
+			if (delegate == null) {
+				throw new IllegalStateException();
+			}
+			return delegate.read(in);
+		}
+
+		@Override public void write(JsonWriter out, T value) throws IOException {
+			if (delegate == null) {
+				throw new IllegalStateException();
+			}
+			delegate.write(out, value);
+		}
+	}
+
+	@Override
+	public String toString() {
+		return new StringBuilder("{serializeNulls:")
+				.append(serializeNulls)
+				.append(",factories:").append(factories)
+				.append(",instanceCreators:").append(constructorConstructor)
+				.append("}")
+				.toString();
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index c92ad653d..68aa1549d 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -50,7 +50,7 @@
  * instance:
  *
  * <pre>
- * Gson gson = new GsonBuilder()
+ * Gson gson = Gson.newBuilder()
  *     .registerTypeAdapter(Id.class, new IdTypeAdapter())
  *     .enableComplexMapKeySerialization()
  *     .serializeNulls()
@@ -58,7 +58,7 @@
  *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
  *     .setPrettyPrinting()
  *     .setVersion(1.0)
- *     .create();
+ *     .build();
  * </pre></p>
  *
  * <p>NOTES:
@@ -100,7 +100,7 @@
    * invoking various configuration methods to set desired options, and finally calling
    * {@link #create()}.
    */
-  public GsonBuilder() {
+  GsonBuilder() {
   }
 
   /**
@@ -208,10 +208,10 @@ public GsonBuilder serializeNulls() {
    *
    * <p>Below is an example:
    * <pre>  {@code
-   *   Gson gson = new GsonBuilder()
+   *   Gson gson = Gson.newBuilder()
    *       .register(Point.class, new MyPointTypeAdapter())
    *       .enableComplexMapKeySerialization()
-   *       .create();
+   *       .build();
    *
    *   Map<Point, String> original = new LinkedHashMap<Point, String>();
    *   original.put(new Point(5, 6), "a");
@@ -236,9 +236,9 @@ public GsonBuilder serializeNulls() {
    *
    * <p>Below is an example of serializing complex types as JSON arrays:
    * <pre> {@code
-   *   Gson gson = new GsonBuilder()
+   *   Gson gson = Gson.newBuilder()
    *       .enableComplexMapKeySerialization()
-   *       .create();
+   *       .build();
    *
    *   Map<Point, String> original = new LinkedHashMap<Point, String>();
    *   original.put(new Point(5, 6), "a");
@@ -569,7 +569,7 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
    *
    * @return an instance of Gson configured with the options currently set in this builder
    */
-  public Gson create() {
+  public Gson build() {
     List<TypeAdapterFactory> factories = new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);
     factories.addAll(this.factories);
     Collections.reverse(factories);
diff --git a/gson/src/main/java/com/google/gson/InstanceCreator.java b/gson/src/main/java/com/google/gson/InstanceCreator.java
index 8036f9a87..4805682f0 100644
--- a/gson/src/main/java/com/google/gson/InstanceCreator.java
+++ b/gson/src/main/java/com/google/gson/InstanceCreator.java
@@ -68,7 +68,7 @@
  * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>
  *
  * <pre>
- * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();
+ * Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).build();
  * </pre>
  *
  * @param <T> the type of object that will be created by this implementation.
diff --git a/gson/src/main/java/com/google/gson/JsonDeserializer.java b/gson/src/main/java/com/google/gson/JsonDeserializer.java
index 0589eb284..a5208c1dc 100644
--- a/gson/src/main/java/com/google/gson/JsonDeserializer.java
+++ b/gson/src/main/java/com/google/gson/JsonDeserializer.java
@@ -58,7 +58,7 @@
  * <p>You will also need to register {@code IdDeserializer} with Gson as follows:</p>
  *
  * <pre>
- * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();
+ * Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).build();
  * </pre>
  *
  * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
diff --git a/gson/src/main/java/com/google/gson/JsonSerializer.java b/gson/src/main/java/com/google/gson/JsonSerializer.java
index a60500336..5d28ff33a 100644
--- a/gson/src/main/java/com/google/gson/JsonSerializer.java
+++ b/gson/src/main/java/com/google/gson/JsonSerializer.java
@@ -57,7 +57,7 @@
  *
  * <p>You will also need to register {@code IdSerializer} with Gson as follows:</p>
  * <pre>
- * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();
+ * Gson gson = Gson.newBuilder().registerTypeAdapter(Id.class, new IdSerializer()).build();
  * </pre>
  *
  * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
diff --git a/gson/src/main/java/com/google/gson/TypeAdapter.java b/gson/src/main/java/com/google/gson/TypeAdapter.java
index 4646d271d..737c97779 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java
@@ -84,12 +84,12 @@
  * <p>To use a custom type adapter with Gson, you must <i>register</i> it with a
  * {@link GsonBuilder}: <pre>   {@code
  *
- *   GsonBuilder builder = new GsonBuilder();
+ *   GsonBuilder builder = Gson.newBuilder();
  *   builder.registerTypeAdapter(Point.class, new PointAdapter());
  *   // if PointAdapter didn't check for nulls in its read/write methods, you should instead use
  *   // builder.registerTypeAdapter(Point.class, new PointAdapter().nullSafe());
  *   ...
- *   Gson gson = builder.create();
+ *   Gson gson = builder.build();
  * }</pre>
  *
  * @since 2.1
@@ -148,7 +148,7 @@ public final void toJson(Writer out, T value) throws IOException {
    * is typically done:<br>
    * <pre>   {@code
    *
-   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,
+   * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
    *   new TypeAdapter<Foo>() {
    *     public Foo read(JsonReader in) throws IOException {
    *       if (in.peek() == JsonToken.NULL) {
@@ -164,13 +164,13 @@ public final void toJson(Writer out, T value) throws IOException {
    *       }
    *       // write src as JSON to out
    *     }
-   *   }).create();
+   *   }).build();
    * }</pre>
    * You can avoid this boilerplate handling of nulls by wrapping your type adapter with
    * this method. Here is how we will rewrite the above example:
    * <pre>   {@code
    *
-   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,
+   * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
    *   new TypeAdapter<Foo>() {
    *     public Foo read(JsonReader in) throws IOException {
    *       // read a Foo from in and return it
@@ -178,7 +178,7 @@ public final void toJson(Writer out, T value) throws IOException {
    *     public void write(JsonWriter out, Foo src) throws IOException {
    *       // write src as JSON to out
    *     }
-   *   }.nullSafe()).create();
+   *   }.nullSafe()).build();
    * }</pre>
    * Note that we didn't need to check for nulls in our type adapter after we used nullSafe.
    */
diff --git a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
index e12a72dcc..bd85fc8db 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
@@ -82,10 +82,10 @@
  * <p>As with type adapters, factories must be <i>registered</i> with a {@link
  * com.google.gson.GsonBuilder} for them to take effect: <pre>   {@code
  *
- *  GsonBuilder builder = new GsonBuilder();
+ *  GsonBuilder builder = Gson.newBuilder();
  *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());
  *  ...
- *  Gson gson = builder.create();
+ *  Gson gson = builder.build();
  * }</pre>
  * If multiple factories support the same type, the factory registered earlier
  * takes precedence.
@@ -138,7 +138,7 @@
  *             return null;
  *           }
  *
- *           Multiset<E> result = LinkedHashMultiset.create();
+ *           Multiset<E> result = LinkedHashMultiset.build();
  *           in.beginArray();
  *           while (in.hasNext()) {
  *             int count = in.nextInt();
diff --git a/gson/src/main/java/com/google/gson/annotations/Expose.java b/gson/src/main/java/com/google/gson/annotations/Expose.java
index b66dc4f27..0bbb84937 100644
--- a/gson/src/main/java/com/google/gson/annotations/Expose.java
+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java
@@ -43,7 +43,7 @@
  * If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
  * methods will use the {@code password} field along-with {@code firstName}, {@code lastName},
  * and {@code emailAddress} for serialization and deserialization. However, if you created Gson
- * with {@code Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()}
+ * with {@code Gson gson = Gson.newBuilder().excludeFieldsWithoutExposeAnnotation().build()}
  * then the {@code toJson()} and {@code fromJson()} methods of Gson will exclude the
  * {@code password} field. This is because the {@code password} field is not marked with the
  * {@code @Expose} annotation. Gson will also exclude {@code lastName} and {@code emailAddress}
diff --git a/gson/src/main/java/com/google/gson/annotations/Since.java b/gson/src/main/java/com/google/gson/annotations/Since.java
index c6b218252..07170357b 100644
--- a/gson/src/main/java/com/google/gson/annotations/Since.java
+++ b/gson/src/main/java/com/google/gson/annotations/Since.java
@@ -44,7 +44,7 @@
  *
  * <p>If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
  * methods will use all the fields for serialization and deserialization. However, if you created
- * Gson with {@code Gson gson = new GsonBuilder().setVersion(1.0).create()} then the
+ * Gson with {@code Gson gson = Gson.newBuilder().setVersion(1.0).build()} then the
  * {@code toJson()} and {@code fromJson()} methods of Gson will exclude the {@code address} field
  * since it's version number is set to {@code 1.1}.</p>
  *
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/gson/annotations/Until.java
index 8c38552b9..a02bd4954 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/gson/annotations/Until.java
@@ -45,7 +45,7 @@
  *
  * <p>If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
  * methods will use all the fields for serialization and deserialization. However, if you created
- * Gson with {@code Gson gson = new GsonBuilder().setVersion(1.2).create()} then the
+ * Gson with {@code Gson gson = Gson.newBuilder().setVersion(1.2).build()} then the
  * {@code toJson()} and {@code fromJson()} methods of Gson will exclude the {@code emailAddress}
  * and {@code password} fields from the example above, because the version number passed to the 
  * GsonBuilder, {@code 1.2}, exceeds the version number set on the {@code Until} annotation,
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 2468b2aa3..a396afd9e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -63,9 +63,9 @@
  *
  * <p>Register this adapter when you are creating your GSON instance.
  * <pre>   {@code
- *   Gson gson = new GsonBuilder()
+ *   Gson gson = Gson.newBuilder()
  *     .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())
- *     .create();
+ *     .build();
  * }</pre>
  * This will change the structure of the JSON emitted by the code above. Now we
  * get an array. In this case the arrays elements are map entries:
diff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java
index 73601c0e3..57f91311e 100644
--- a/gson/src/test/java/com/google/gson/GsonBuilderTest.java
+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java
@@ -40,15 +40,15 @@
   };
 
   public void testCreatingMoreThanOnce() {
-    GsonBuilder builder = new GsonBuilder();
-    builder.create();
-    builder.create();
+    GsonBuilder builder = Gson.newBuilder();
+    builder.build();
+    builder.build();
   }
 
   public void testExcludeFieldsWithModifiers() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .excludeFieldsWithModifiers(Modifier.VOLATILE, Modifier.PRIVATE)
-        .create();
+        .build();
     assertEquals("{\"d\":\"d\"}", gson.toJson(new HasModifiers()));
   }
 
@@ -62,7 +62,7 @@ public void testRegisterTypeAdapterForCoreType() {
         String.class,
     };
     for (Type type : types) {
-      new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);
+      Gson.newBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);
     }
   }
 
@@ -75,9 +75,9 @@ public void testRegisterTypeAdapterForCoreType() {
   }
 
   public void testTransientFieldExclusion() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .excludeFieldsWithModifiers()
-        .create();
+        .build();
     assertEquals("{\"a\":\"a\"}", gson.toJson(new HasTransients()));
   }
 
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index eec2ec91c..5b8e6f552 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -64,9 +64,9 @@ public void testClonedTypeAdapterFactoryListsAreIndependent() {
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
-    Gson clone = original.newBuilder()
+    Gson clone = original.rebuild()
         .registerTypeAdapter(Object.class, new TestTypeAdapter())
-        .create();
+        .build();
 
     assertEquals(original.factories.size() + 1, clone.factories.size());
   }
diff --git a/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java b/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
index decb93d83..44dbeff3a 100644
--- a/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
@@ -34,10 +34,10 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter())
         .registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter())
-        .create();
+        .build();
   }
 
   public void testDefaultTypeAdapterThrowsParseException() throws Exception {
@@ -135,14 +135,14 @@ public Abstract deserialize(JsonElement json, Type typeOfT,
         throw new AssertionError();
       }
     };
-    GsonBuilder builder = new GsonBuilder();
+    GsonBuilder builder = Gson.newBuilder();
     if (registerAbstractDeserializer) {
       builder.registerTypeAdapter(Abstract.class, deserializer);
     }
     if (registerAbstractHierarchyDeserializer) {
       builder.registerTypeHierarchyAdapter(Abstract.class, deserializer);
     }
-    Gson gson = builder.create();
+    Gson gson = builder.build();
     assertEquals(expected, gson.toJson(instance, instanceType));
   }
 }
diff --git a/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java b/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java
index d0a063208..a0de28063 100644
--- a/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/LongSerializationPolicyTest.java
@@ -37,9 +37,9 @@ public void testDefaultLongSerialization() throws Exception {
   }
   
   public void testDefaultLongSerializationIntegration() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .setLongSerializationPolicy(LongSerializationPolicy.DEFAULT)
-        .create();
+        .build();
     assertEquals("[1]", gson.toJson(new long[] { 1L }, long[].class));
     assertEquals("[1]", gson.toJson(new Long[] { 1L }, Long[].class));
   }
@@ -55,9 +55,9 @@ public void testStringLongSerialization() throws Exception {
   }
 
   public void testStringLongSerializationIntegration() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .create();
+        .build();
     assertEquals("[\"1\"]", gson.toJson(new long[] { 1L }, long[].class));
     assertEquals("[\"1\"]", gson.toJson(new Long[] { 1L }, Long[].class));
   }
diff --git a/gson/src/test/java/com/google/gson/MixedStreamTest.java b/gson/src/test/java/com/google/gson/MixedStreamTest.java
index 00eb4bc8a..51e5316df 100644
--- a/gson/src/test/java/com/google/gson/MixedStreamTest.java
+++ b/gson/src/test/java/com/google/gson/MixedStreamTest.java
@@ -190,7 +190,7 @@ public void testWriteHtmlSafe() {
         writer.toString());
 
     writer = new StringWriter();
-    new GsonBuilder().disableHtmlEscaping().create()
+    Gson.newBuilder().disableHtmlEscaping().build()
         .toJson(contents, type, new JsonWriter(writer));
     assertEquals("[\"<\",\">\",\"&\",\"=\",\"'\"]",
         writer.toString());
@@ -203,7 +203,7 @@ public void testWriteLenient() {
 
     StringWriter writer = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(writer);
-    new GsonBuilder().serializeSpecialFloatingPointValues().create()
+    Gson.newBuilder().serializeSpecialFloatingPointValues().build()
         .toJson(doubles, type, jsonWriter);
     assertEquals("[NaN,-Infinity,Infinity,-0.0,0.5,0.0]", writer.toString());
 
diff --git a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
index 2891bffca..395315077 100644
--- a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
@@ -23,7 +23,7 @@
 import junit.framework.TestCase;
 
 public final class ObjectTypeAdapterTest extends TestCase {
-  private final Gson gson = new GsonBuilder().create();
+  private final Gson gson = Gson.newBuilder().build();
   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);
 
   public void testDeserialize() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
index 79ae1698f..044390d79 100644
--- a/gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
@@ -46,9 +46,9 @@
   };
 
   public void testOverrideWrapperBooleanAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Boolean.class, booleanAsIntAdapter)
-        .create();
+        .build();
     assertEquals("true", gson.toJson(true, boolean.class));
     assertEquals("1", gson.toJson(true, Boolean.class));
     assertEquals(Boolean.TRUE, gson.fromJson("true", boolean.class));
@@ -57,9 +57,9 @@ public void testOverrideWrapperBooleanAdapter() {
   }
 
   public void testOverridePrimitiveBooleanAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(boolean.class, booleanAsIntAdapter)
-        .create();
+        .build();
     assertEquals("1", gson.toJson(true, boolean.class));
     assertEquals("true", gson.toJson(true, Boolean.class));
     assertEquals(Boolean.TRUE, gson.fromJson("1", boolean.class));
@@ -68,9 +68,9 @@ public void testOverridePrimitiveBooleanAdapter() {
   }
 
   public void testOverrideStringAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(String.class, swapCaseStringAdapter)
-        .create();
+        .build();
     assertEquals("\"HELLO\"", gson.toJson("Hello", String.class));
     assertEquals("hello", gson.fromJson("\"Hello\"", String.class));
   }
diff --git a/gson/src/test/java/com/google/gson/functional/ArrayTest.java b/gson/src/test/java/com/google/gson/functional/ArrayTest.java
index 11388e90a..e918bf2a6 100644
--- a/gson/src/test/java/com/google/gson/functional/ArrayTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java
@@ -110,7 +110,7 @@ public void testSingleNullInArrayDeserialization() {
   }
 
   public void testNullsInArrayWithSerializeNullPropertySetSerialization() {
-    gson = new GsonBuilder().serializeNulls().create();
+    gson = Gson.newBuilder().serializeNulls().build();
     String[] array = {"foo", null, "bar"};
     String expected = "[\"foo\",null,\"bar\"]";
     String json = gson.toJson(array);
diff --git a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
index d352e2418..bac04d942 100644
--- a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
@@ -78,7 +78,7 @@ public void testSelfReferenceArrayFieldSerialization() throws Exception {
   public void testSelfReferenceCustomHandlerSerialization() throws Exception {
     ClassWithSelfReference obj = new ClassWithSelfReference();
     obj.child = obj;
-    Gson gson = new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer<ClassWithSelfReference>() {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer<ClassWithSelfReference>() {
       public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,
           JsonSerializationContext context) {
         JsonObject obj = new JsonObject();
@@ -86,7 +86,7 @@ public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,
         obj.add("child", context.serialize(src.child));
         return obj;
       }
-    }).create();
+    }).build();
     try {
       gson.toJson(obj);
       fail("Circular reference to self can not be serialized!");
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index 4ec7378b2..1c0ed71ff 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -333,9 +333,9 @@ public JsonElement serialize(List<String> src, Type typeOfSrc,
         return new JsonPrimitive(src.get(0) + ";" + src.get(1));
       }
     };
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(listOfString, stringListSerializer)
-        .create();
+        .build();
     assertEquals("\"ab;cd\"", gson.toJson(Arrays.asList("ab", "cd"), listOfString));
   }
 
diff --git a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
index 8134ae2d1..8b71b2993 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
@@ -45,7 +45,7 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();
+    gson = Gson.newBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).build();
   }
 
   public void testDefaultConstructorNotCalledOnObject() throws Exception {
@@ -112,13 +112,13 @@ public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializatio
 
   public void testJsonTypeFieldBasedDeserialization() {
     String json = "{field1:'abc',field2:'def',__type__:'SUB_TYPE1'}";
-    Gson gson = new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer<MyBase>() {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer<MyBase>() {
       @Override public MyBase deserialize(JsonElement json, Type pojoType,
           JsonDeserializationContext context) throws JsonParseException {
         String type = json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();
         return context.deserialize(json, SubTypes.valueOf(type).getSubclass());
       }
-    }).create();
+    }).build();
     SubType1 target = (SubType1) gson.fromJson(json, MyBase.class);
     assertEquals("abc", target.field1);
   }
@@ -149,42 +149,42 @@ public Type getSubclass() {
   }
 
   public void testCustomDeserializerReturnsNullForTopLevelObject() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
         public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
             throws JsonParseException {
           return null;
         }
-      }).create();
+      }).build();
     String json = "{baseName:'Base',subName:'SubRevised'}";
     Base target = gson.fromJson(json, Base.class);
     assertNull(target);
   }
 
   public void testCustomDeserializerReturnsNull() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
         public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
             throws JsonParseException {
           return null;
         }
-      }).create();
+      }).build();
     String json = "{base:{baseName:'Base',subName:'SubRevised'}}";
     ClassWithBaseField target = gson.fromJson(json, ClassWithBaseField.class);
     assertNull(target.base);
   }
 
   public void testCustomDeserializerReturnsNullForArrayElements() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
         public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
             throws JsonParseException {
           return null;
         }
-      }).create();
+      }).build();
     String json = "[{baseName:'Base'},{baseName:'Base'}]";
     Base[] target = gson.fromJson(json, Base[].class);
     assertNull(target[0]);
@@ -192,14 +192,14 @@ public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationConte
   }
 
   public void testCustomDeserializerReturnsNullForArrayElementsForArrayField() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {
         @Override
         public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
             throws JsonParseException {
           return null;
         }
-      }).create();
+      }).build();
     String json = "{bases:[{baseName:'Base'},{baseName:'Base'}]}";
     ClassWithBaseArray target = gson.fromJson(json, ClassWithBaseArray.class);
     assertNull(target.bases[0]);
diff --git a/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
index c8095463a..6a15e635c 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
@@ -43,10 +43,10 @@
 public class CustomSerializerTest extends TestCase {
 
    public void testBaseClassSerializerInvokedForBaseClassFields() {
-     Gson gson = new GsonBuilder()
+     Gson gson = Gson.newBuilder()
          .registerTypeAdapter(Base.class, new BaseSerializer())
          .registerTypeAdapter(Sub.class, new SubSerializer())
-         .create();
+         .build();
      ClassWithBaseField target = new ClassWithBaseField(new Base());
      JsonObject json = (JsonObject) gson.toJsonTree(target);
      JsonObject base = json.get("base").getAsJsonObject();
@@ -54,10 +54,10 @@ public void testBaseClassSerializerInvokedForBaseClassFields() {
    }
 
    public void testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {
-     Gson gson = new GsonBuilder()
+     Gson gson = Gson.newBuilder()
          .registerTypeAdapter(Base.class, new BaseSerializer())
          .registerTypeAdapter(Sub.class, new SubSerializer())
-         .create();
+         .build();
      ClassWithBaseField target = new ClassWithBaseField(new Sub());
      JsonObject json = (JsonObject) gson.toJsonTree(target);
      JsonObject base = json.get("base").getAsJsonObject();
@@ -65,10 +65,10 @@ public void testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstan
    }
 
    public void testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClassInstances() {
-     Gson gson = new GsonBuilder()
+     Gson gson = Gson.newBuilder()
          .registerTypeAdapter(Base.class, new BaseSerializer())
          .registerTypeAdapter(Sub.class, new SubSerializer())
-         .create();
+         .build();
      ClassWithBaseArrayField target = new ClassWithBaseArrayField(new Base[] {new Sub(), new Sub()});
      JsonObject json = (JsonObject) gson.toJsonTree(target);
      JsonArray array = json.get("base").getAsJsonArray();
@@ -79,9 +79,9 @@ public void testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClas
    }
 
    public void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {
-     Gson gson = new GsonBuilder()
+     Gson gson = Gson.newBuilder()
          .registerTypeAdapter(Base.class, new BaseSerializer())
-         .create();
+         .build();
      ClassWithBaseField target = new ClassWithBaseField(new Sub());
      JsonObject json = (JsonObject) gson.toJsonTree(target);
      JsonObject base = json.get("base").getAsJsonObject();
@@ -89,13 +89,13 @@ public void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInsta
    }
 
    public void testSerializerReturnsNull() {
-     Gson gson = new GsonBuilder()
+     Gson gson = Gson.newBuilder()
        .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {
          public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
            return null;
          }
        })
-       .create();
+       .build();
        JsonElement json = gson.toJsonTree(new Base());
        assertTrue(json.isJsonNull());
    }
diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index b452849dd..fa6ddaae4 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -51,7 +51,7 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    builder = new GsonBuilder();
+    builder = Gson.newBuilder();
   }
 
   public void testCustomSerializers() {
@@ -64,13 +64,13 @@ public void testCustomSerializers() {
         json.addProperty("value", 25);
         return json;
       }
-    }).create();
+    }).build();
     ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();
     assertEquals("{\"bag\":5,\"value\":25}", gson.toJson(target));
   }
 
   public void testCustomDeserializers() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         ClassWithCustomTypeConverter.class, new JsonDeserializer<ClassWithCustomTypeConverter>() {
           @Override public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,
               JsonDeserializationContext context) {
@@ -79,7 +79,7 @@ public void testCustomDeserializers() {
         return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,
             value, false, ""), value);
       }
-    }).create();
+    }).build();
     String json = "{\"bag\":5,\"value\":25}";
     ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);
     assertEquals(5, target.getBag().getIntValue());
@@ -107,40 +107,40 @@ public void disable_testCustomDeserializersOfSelf() {
   }
 
   public void testCustomNestedSerializers() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {
           @Override public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,
           JsonSerializationContext context) {
         return new JsonPrimitive(6);
       }
-    }).create();
+    }).build();
     ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();
     assertEquals("{\"bag\":6,\"value\":10}", gson.toJson(target));
   }
 
   public void testCustomNestedDeserializers() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {
           @Override public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,
           JsonDeserializationContext context) throws JsonParseException {
         int value = json.getAsInt();
         return new BagOfPrimitives(value, value, false, "");
       }
-    }).create();
+    }).build();
     String json = "{\"bag\":7,\"value\":25}";
     ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);
     assertEquals(7, target.getBag().getIntValue());
   }
 
   public void testCustomTypeAdapterDoesNotAppliesToSubClasses() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
       @Override
       public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
         JsonObject json = new JsonObject();
         json.addProperty("value", src.baseValue);
         return json;
       }
-    }).create();
+    }).build();
     Base b = new Base();
     String json = gson.toJson(b);
     assertTrue(json.contains("value"));
@@ -150,14 +150,14 @@ public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext
   }
 
   public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {
       @Override
       public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
         JsonObject json = new JsonObject();
         json.addProperty("value", src.baseValue);
         return json;
       }
-    }).create();
+    }).build();
     Base b = new Base();
     String json = gson.toJson(b);
     assertTrue(json.contains("value"));
@@ -178,7 +178,7 @@ public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext
 
 
   private Gson createGsonObjectWithFooTypeAdapter() {
-    return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();
+    return Gson.newBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).build();
   }
 
   public static class Foo {
@@ -209,33 +209,33 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
   }
 
   public void testCustomSerializerInvokedForPrimitives() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(boolean.class, new JsonSerializer<Boolean>() {
           @Override public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {
             return new JsonPrimitive(s ? 1 : 0);
           }
         })
-        .create();
+        .build();
     assertEquals("1", gson.toJson(true, boolean.class));
     assertEquals("true", gson.toJson(true, Boolean.class));
   }
 
   @SuppressWarnings("rawtypes")
   public void testCustomDeserializerInvokedForPrimitives() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(boolean.class, new JsonDeserializer() {
           @Override
           public Object deserialize(JsonElement json, Type t, JsonDeserializationContext context) {
             return json.getAsInt() != 0;
           }
         })
-        .create();
+        .build();
     assertEquals(Boolean.TRUE, gson.fromJson("1", boolean.class));
     assertEquals(Boolean.TRUE, gson.fromJson("true", Boolean.class));
   }
 
   public void testCustomByteArraySerializer() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {
       @Override
       public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {
         StringBuilder sb = new StringBuilder(src.length);
@@ -244,14 +244,14 @@ public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContex
         }
         return new JsonPrimitive(sb.toString());
       }
-    }).create();
+    }).build();
     byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
     String json = gson.toJson(data);
     assertEquals("\"0123456789\"", json);
   }
 
   public void testCustomByteArrayDeserializerAndInstanceCreator() {
-    GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class,
+    GsonBuilder gsonBuilder = Gson.newBuilder().registerTypeAdapter(byte[].class,
         new JsonDeserializer<byte[]>() {
           @Override public byte[] deserialize(JsonElement json,
               Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
@@ -263,7 +263,7 @@ public void testCustomByteArrayDeserializerAndInstanceCreator() {
         return data;
       }
     });
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     String json = "'0123456789'";
     byte[] actual = gson.fromJson(json, byte[].class);
     byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
@@ -309,9 +309,9 @@ public StringHolder(String part1, String part2) {
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForCollectionElementSerializationWithType() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     Type setType = new TypeToken<Set<StringHolder>>() {}.getType();
     StringHolder holder = new StringHolder("Jacob", "Tomaw");
     Set<StringHolder> setOfHolders = new HashSet<StringHolder>();
@@ -322,9 +322,9 @@ public void testCustomAdapterInvokedForCollectionElementSerializationWithType()
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForCollectionElementSerialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     StringHolder holder = new StringHolder("Jacob", "Tomaw");
     Set<StringHolder> setOfHolders = new HashSet<StringHolder>();
     setOfHolders.add(holder);
@@ -334,9 +334,9 @@ public void testCustomAdapterInvokedForCollectionElementSerialization() {
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForCollectionElementDeserialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     Type setType = new TypeToken<Set<StringHolder>>() {}.getType();
     Set<StringHolder> setOfHolders = gson.fromJson("['Jacob:Tomaw']", setType);
     assertEquals(1, setOfHolders.size());
@@ -347,9 +347,9 @@ public void testCustomAdapterInvokedForCollectionElementDeserialization() {
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForMapElementSerializationWithType() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     Type mapType = new TypeToken<Map<String,StringHolder>>() {}.getType();
     StringHolder holder = new StringHolder("Jacob", "Tomaw");
     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();
@@ -360,9 +360,9 @@ public void testCustomAdapterInvokedForMapElementSerializationWithType() {
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForMapElementSerialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     StringHolder holder = new StringHolder("Jacob", "Tomaw");
     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();
     mapOfHolders.put("foo", holder);
@@ -372,9 +372,9 @@ public void testCustomAdapterInvokedForMapElementSerialization() {
 
   // Test created from Issue 70
   public void testCustomAdapterInvokedForMapElementDeserialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())
-      .create();
+      .build();
     Type mapType = new TypeToken<Map<String, StringHolder>>() {}.getType();
     Map<String, StringHolder> mapOfFoo = gson.fromJson("{'foo':'Jacob:Tomaw'}", mapType);
     assertEquals(1, mapOfFoo.size());
@@ -384,18 +384,18 @@ public void testCustomAdapterInvokedForMapElementDeserialization() {
   }
 
   public void testEnsureCustomSerializerNotInvokedForNullValues() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(DataHolder.class, new DataHolderSerializer())
-        .create();
+        .build();
     DataHolderWrapper target = new DataHolderWrapper(new DataHolder("abc"));
     String json = gson.toJson(target);
     assertEquals("{\"wrappedData\":{\"myData\":\"abc\"}}", json);
   }
 
   public void testEnsureCustomDeserializerNotInvokedForNullValues() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(DataHolder.class, new DataHolderDeserializer())
-        .create();
+        .build();
     String json = "{wrappedData:null}";
     DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class);
     assertNull(actual.wrappedData);
@@ -403,9 +403,9 @@ public void testEnsureCustomDeserializerNotInvokedForNullValues() {
 
   // Test created from Issue 352
   public void testRegisterHierarchyAdapterForDate() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Date.class, new DateTypeAdapter())
-        .create();
+        .build();
     assertEquals("0", gson.toJson(new Date(0)));
     assertEquals("0", gson.toJson(new java.sql.Date(0)));
     assertEquals(new Date(0), gson.fromJson("0", Date.class));
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index b7307c6fc..0dfdba3ee 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -90,7 +90,7 @@ public void testClassSerialization() {
       gson.toJson(String.class);
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
-    gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
+    gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
     assertEquals("\"java.lang.String\"", gson.toJson(String.class));
   }
 
@@ -99,7 +99,7 @@ public void testClassDeserialization() {
       gson.fromJson("String.class", String.class.getClass());
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
-    gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
+    gson = Gson.newBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).build();
     assertEquals(String.class, gson.fromJson("java.lang.String", Class.class));
   }
 
@@ -271,17 +271,17 @@ public void testBigIntegerFieldDeserialization() {
   }
   
   public void testOverrideBigIntegerTypeAdapter() throws Exception {
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class))
-        .create();
+        .build();
     assertEquals("\"123\"", gson.toJson(new BigInteger("123"), BigInteger.class));
     assertEquals(new BigInteger("123"), gson.fromJson("\"123\"", BigInteger.class));
   }
 
   public void testOverrideBigDecimalTypeAdapter() throws Exception {
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class))
-        .create();
+        .build();
     assertEquals("\"1.1\"", gson.toJson(new BigDecimal("1.1"), BigDecimal.class));
     assertEquals(new BigDecimal("1.1"), gson.fromJson("\"1.1\"", BigDecimal.class));
   }
@@ -402,7 +402,7 @@ public void testDefaultJavaSqlTimeDeserialization() {
   }
 
   public void testDefaultDateSerializationUsingBuilder() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
     if (JavaVersion.isJava9OrLater()) {
@@ -413,7 +413,7 @@ public void testDefaultDateSerializationUsingBuilder() throws Exception {
   }
 
   public void testDefaultDateDeserializationUsingBuilder() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
     Date extracted = gson.fromJson(json, Date.class);
@@ -421,7 +421,7 @@ public void testDefaultDateDeserializationUsingBuilder() throws Exception {
   }
 
   public void testDefaultCalendarSerialization() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     String json = gson.toJson(Calendar.getInstance());
     assertTrue(json.contains("year"));
     assertTrue(json.contains("month"));
@@ -432,7 +432,7 @@ public void testDefaultCalendarSerialization() throws Exception {
   }
 
   public void testDefaultCalendarDeserialization() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}";
     Calendar cal = gson.fromJson(json, Calendar.class);
     assertEquals(2009, cal.get(Calendar.YEAR));
@@ -444,7 +444,7 @@ public void testDefaultCalendarDeserialization() throws Exception {
   }
 
   public void testDefaultGregorianCalendarSerialization() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     GregorianCalendar cal = new GregorianCalendar();
     String json = gson.toJson(cal);
     assertTrue(json.contains("year"));
@@ -456,7 +456,7 @@ public void testDefaultGregorianCalendarSerialization() throws Exception {
   }
 
   public void testDefaultGregorianCalendarDeserialization() throws Exception {
-    Gson gson = new GsonBuilder().create();
+    Gson gson = Gson.newBuilder().build();
     String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}";
     GregorianCalendar cal = gson.fromJson(json, GregorianCalendar.class);
     assertEquals(2009, cal.get(Calendar.YEAR));
@@ -469,7 +469,7 @@ public void testDefaultGregorianCalendarDeserialization() throws Exception {
 
   public void testDateSerializationWithPattern() throws Exception {
     String pattern = "yyyy-MM-dd";
-    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();
+    Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
     assertEquals("\"2011-09-11\"", json);
@@ -478,7 +478,7 @@ public void testDateSerializationWithPattern() throws Exception {
   @SuppressWarnings("deprecation")
   public void testDateDeserializationWithPattern() throws Exception {
     String pattern = "yyyy-MM-dd";
-    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();
+    Gson gson = Gson.newBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).build();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
     Date extracted = gson.fromJson(json, Date.class);
@@ -489,7 +489,7 @@ public void testDateDeserializationWithPattern() throws Exception {
 
   public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {
     String pattern = "yyyy-MM-dd";
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .setDateFormat(pattern)
         .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
           public Date deserialize(JsonElement json, Type typeOfT,
@@ -498,7 +498,7 @@ public Date deserialize(JsonElement json, Type typeOfT,
             return new Date(1315806903103L);
           }
         })
-        .create();
+        .build();
 
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
@@ -513,7 +513,7 @@ public void testDateSerializationInCollection() throws Exception {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();
+      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
       List<Date> dates = Arrays.asList(new Date(0));
       String json = gson.toJson(dates, listOfDates);
       assertEquals("[\"1970-01-01\"]", json);
@@ -532,7 +532,7 @@ public void testTimestampSerialization() throws Exception {
     Locale.setDefault(Locale.US);
     try {
       Timestamp timestamp = new Timestamp(0L);
-      Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();
+      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
       String json = gson.toJson(timestamp, Timestamp.class);
       assertEquals("\"1970-01-01\"", json);
       assertEquals(0, gson.fromJson("\"1970-01-01\"", Timestamp.class).getTime());
@@ -550,7 +550,7 @@ public void testSqlDateSerialization() throws Exception {
     Locale.setDefault(Locale.US);
     try {
       java.sql.Date sqlDate = new java.sql.Date(0L);
-      Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();
+      Gson gson = Gson.newBuilder().setDateFormat("yyyy-MM-dd").build();
       String json = gson.toJson(sqlDate, Timestamp.class);
       assertEquals("\"1970-01-01\"", json);
       assertEquals(0, gson.fromJson("\"1970-01-01\"", java.sql.Date.class).getTime());
diff --git a/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
index f89148e36..c6ca8880f 100644
--- a/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
@@ -44,9 +44,9 @@
   protected void setUp() throws Exception {
     super.setUp();
     stats = new StatsTypeAdapterFactory();
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
       .registerTypeAdapterFactory(stats)
-      .create();
+      .build();
   }
 
   public void testDelegateInvoked() {
diff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java
index 66b855ebf..54485e85d 100644
--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java
@@ -119,9 +119,9 @@ public void testEnumSubclass() {
   }
 
   public void testEnumSubclassWithRegisteredTypeAdapter() {
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Roshambo.class, new MyEnumTypeAdapter())
-        .create();
+        .build();
     assertFalse(Roshambo.class == Roshambo.ROCK.getClass());
     assertEquals("\"123ROCK\"", gson.toJson(Roshambo.ROCK));
     assertEquals("[\"123ROCK\",\"123PAPER\",\"123SCISSORS\"]", gson.toJson(EnumSet.allOf(Roshambo.class)));
diff --git a/gson/src/test/java/com/google/gson/functional/EscapingTest.java b/gson/src/test/java/com/google/gson/functional/EscapingTest.java
index 1581f4518..c85055cbc 100644
--- a/gson/src/test/java/com/google/gson/functional/EscapingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EscapingTest.java
@@ -70,8 +70,8 @@ public void testEscapingObjectFields() throws Exception {
   }
   
   public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception {
-    Gson escapeHtmlGson = new GsonBuilder().create();
-    Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create();
+    Gson escapeHtmlGson = Gson.newBuilder().build();
+    Gson noEscapeHtmlGson = Gson.newBuilder().disableHtmlEscaping().build();
     
     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>");
     String escapedJsonForm = escapeHtmlGson.toJson(target);
diff --git a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
index 148378f00..2c988940b 100644
--- a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
@@ -106,16 +106,16 @@ public void testExclusionStrategyWithMode() throws Exception {
   }
 
   public void testExcludeTopLevelClassSerialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST)
-        .create();
+        .build();
     assertEquals("null", gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class));
   }
 
   public void testExcludeTopLevelClassSerializationDoesNotImpactDeserialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST)
-        .create();
+        .build();
     String json = "{\"annotatedField\":1,\"stringField\":\"x\",\"longField\":2}";
     SampleObjectForTest value = gson.fromJson(json, SampleObjectForTest.class);
     assertEquals(1, value.annotatedField);
@@ -124,18 +124,18 @@ public void testExcludeTopLevelClassSerializationDoesNotImpactDeserialization()
   }
 
   public void testExcludeTopLevelClassDeserialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST)
-        .create();
+        .build();
     String json = "{\"annotatedField\":1,\"stringField\":\"x\",\"longField\":2}";
     SampleObjectForTest value = gson.fromJson(json, SampleObjectForTest.class);
     assertNull(value);
   }
 
   public void testExcludeTopLevelClassDeserializationDoesNotImpactSerialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST)
-        .create();
+        .build();
     String json = gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class);
     assertTrue(json.contains("\"stringField\""));
     assertTrue(json.contains("\"annotatedField\""));
@@ -143,7 +143,7 @@ public void testExcludeTopLevelClassDeserializationDoesNotImpactSerialization()
   }
 
   private static Gson createGson(ExclusionStrategy exclusionStrategy, boolean serialization) {
-    GsonBuilder gsonBuilder = new GsonBuilder();
+    GsonBuilder gsonBuilder = Gson.newBuilder();
     if (serialization) {
       gsonBuilder.addSerializationExclusionStrategy(exclusionStrategy);
     } else {
@@ -151,7 +151,7 @@ private static Gson createGson(ExclusionStrategy exclusionStrategy, boolean seri
     }
     return gsonBuilder
         .serializeNulls()
-        .create();
+        .build();
   }
 
   @Retention(RetentionPolicy.RUNTIME)
diff --git a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
index 0430ba49d..69cf09532 100644
--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
@@ -37,10 +37,10 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .excludeFieldsWithoutExposeAnnotation()
         .registerTypeAdapter(SomeInterface.class, new SomeInterfaceInstanceCreator())
-        .create();
+        .build();
   }
 
   public void testNullExposeFieldSerialization() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
index 080a8234f..5fdfd1624 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
@@ -45,14 +45,14 @@ public void testDefaultInnerClassExclusion() throws Exception {
     String result = gson.toJson(target);
     assertEquals(target.toJson(), result);
 
-    gson = new GsonBuilder().create();
+    gson = Gson.newBuilder().build();
     target = outer.new Inner(VALUE);
     result = gson.toJson(target);
     assertEquals(target.toJson(), result);
   }
 
   public void testInnerClassExclusion() throws Exception {
-    Gson gson = new GsonBuilder().disableInnerClassSerialization().create();
+    Gson gson = Gson.newBuilder().disableInnerClassSerialization().build();
     Outer.Inner target = outer.new Inner(VALUE);
     String result = gson.toJson(target);
     assertEquals("null", result);
@@ -64,7 +64,7 @@ public void testDefaultNestedStaticClassIncluded() throws Exception {
     String result = gson.toJson(target);
     assertEquals(target.toJson(), result);
 
-    gson = new GsonBuilder().create();
+    gson = Gson.newBuilder().build();
     target = outer.new Inner(VALUE);
     result = gson.toJson(target);
     assertEquals(target.toJson(), result);
diff --git a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
index bd2089588..4a700a26d 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
@@ -70,9 +70,9 @@ public void testLowerCaseWithDashes() {
   }
 
   private Gson getGsonWithNamingPolicy(FieldNamingStrategy fieldNamingPolicy){
-    return new GsonBuilder()
+    return Gson.newBuilder()
       .setFieldNamingStrategy(fieldNamingPolicy)
-        .create();
+        .build();
   }
 
   @SuppressWarnings("unused") // fields are used reflectively
diff --git a/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java b/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
index 36eff8e1e..76a111514 100644
--- a/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
@@ -41,14 +41,14 @@
 
   @Before
   public void setUp() {
-    gson = new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter<TestType>() {
+    gson = Gson.newBuilder().registerTypeAdapter(TestType.class, new TypeAdapter<TestType>() {
       @Override public void write(JsonWriter out, TestType value) {
         throw new AssertionError("Expected during serialization");
       }
       @Override public TestType read(JsonReader in) throws IOException {
         throw new AssertionError("Expected during deserialization");
       }
-    }).create();
+    }).build();
   }
 
   @Test
diff --git a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
index 5437c876e..12cc9cc83 100644
--- a/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
@@ -41,26 +41,26 @@
 public class InstanceCreatorTest extends TestCase {
 
   public void testInstanceCreatorReturnsBaseType() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
         @Override public Base createInstance(Type type) {
          return new Base();
        }
       })
-      .create();
+      .build();
     String json = "{baseName:'BaseRevised',subName:'Sub'}";
     Base base = gson.fromJson(json, Base.class);
     assertEquals("BaseRevised", base.baseName);
   }
 
   public void testInstanceCreatorReturnsSubTypeForTopLevelObject() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
     .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
       @Override public Base createInstance(Type type) {
         return new Sub();
       }
     })
-    .create();
+    .build();
 
     String json = "{baseName:'Base',subName:'SubRevised'}";
     Base base = gson.fromJson(json, Base.class);
@@ -72,13 +72,13 @@ public void testInstanceCreatorReturnsSubTypeForTopLevelObject() {
   }
 
   public void testInstanceCreatorReturnsSubTypeForField() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
     .registerTypeAdapter(Base.class, new InstanceCreator<Base>() {
       @Override public Base createInstance(Type type) {
         return new Sub();
       }
     })
-    .create();
+    .build();
     String json = "{base:{baseName:'Base',subName:'SubRevised'}}";
     ClassWithBaseField target = gson.fromJson(json, ClassWithBaseField.class);
     assertTrue(target.base instanceof Sub);
@@ -95,9 +95,9 @@ public void testInstanceCreatorForCollectionType() {
       }
     };
     Type listOfStringType = new TypeToken<List<String>>() {}.getType();
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(listOfStringType, listCreator)
-        .create();
+        .build();
     List<String> list = gson.fromJson("[\"a\"]", listOfStringType);
     assertEquals(SubArrayList.class, list.getClass());
   }
@@ -111,9 +111,9 @@ public void testInstanceCreatorForParametrizedType() throws Exception {
         return new SubTreeSet();
       }
     };
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(SortedSet.class, sortedSetCreator)
-        .create();
+        .build();
 
     Type sortedSetType = new TypeToken<SortedSet<String>>() {}.getType();
     SortedSet<String> set = gson.fromJson("[\"a\"]", sortedSetType);
diff --git a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
index 464892a3a..f4ea3bb34 100644
--- a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
@@ -62,9 +62,9 @@ public void testAtomicLong() throws Exception {
   }
 
   public void testAtomicLongWithStringSerializationPolicy() throws Exception {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .create();
+        .build();
     AtomicLongHolder target = gson.fromJson("{'value':'10'}", AtomicLongHolder.class);
     assertEquals(10, target.value.get());
     String json = gson.toJson(target);
@@ -92,9 +92,9 @@ public void testAtomicLongArray() throws Exception {
   }
 
   public void testAtomicLongArrayWithStringSerializationPolicy() throws Exception {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .setLongSerializationPolicy(LongSerializationPolicy.STRING)
-        .create();
+        .build();
     AtomicLongArray target = gson.fromJson("['10', '13', '14']", AtomicLongArray.class);
     assertEquals(3, target.length());
     assertEquals(10, target.get(0));
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index 4288bfe3b..0cd99a9c0 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -76,9 +76,9 @@ public void testRegisteredAdapterOverridesJsonAdapter() {
         return new A(in.nextString());
       }
     };
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(A.class, typeAdapter)
-      .create();
+      .build();
     String json = gson.toJson(new A("abcd"));
     assertEquals("\"registeredAdapter\"", json);
   }
@@ -93,9 +93,9 @@ public JsonElement serialize(A src, Type typeOfSrc,
         return new JsonPrimitive("registeredSerializer");
       }
     };
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(A.class, serializer)
-      .create();
+      .build();
     String json = gson.toJson(new A("abcd"));
     assertEquals("\"registeredSerializer\"", json);
     A target = gson.fromJson("abcd", A.class);
@@ -112,9 +112,9 @@ public A deserialize(JsonElement json, Type typeOfT,
         return new A("registeredDeserializer");
       }
     };
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(A.class, deserializer)
-      .create();
+      .build();
     String json = gson.toJson(new A("abcd"));
     assertEquals("\"jsonAdapter\"", json);
     A target = gson.fromJson("abcd", A.class);
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
index 706fe60f8..8be669e0f 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
@@ -52,9 +52,9 @@ public void testClassAnnotationAdapterFactoryTakesPrecedenceOverDefault() {
   }
 
   public void testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(User.class, new RegisteredUserAdapter())
-        .create();
+        .build();
     String json = gson.toJson(new Computer(new User("Inderjeet Singh")));
     assertEquals("{\"user\":\"RegisteredUserAdapter\"}", json);
     Computer computer = gson.fromJson("{'user':'Inderjeet Singh'}", Computer.class);
@@ -62,7 +62,7 @@ public void testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter()
   }
 
   public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
       .registerTypeAdapter(Part.class, new TypeAdapter<Part>() {
         @Override public void write(JsonWriter out, Part part) throws IOException {
           throw new AssertionError();
@@ -70,7 +70,7 @@ public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {
         @Override public Part read(JsonReader in) throws IOException {
           throw new AssertionError();
         }
-      }).create();
+      }).build();
     String json = gson.toJson(new Gadget(new Part("screen")));
     assertEquals("{\"part\":\"PartJsonFieldAnnotationAdapter\"}", json);
     Gadget gadget = gson.fromJson("{'part':'screen'}", Gadget.class);
diff --git a/gson/src/test/java/com/google/gson/functional/LeniencyTest.java b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java
index 6b5375e4b..9d0e1ff7d 100644
--- a/gson/src/test/java/com/google/gson/functional/LeniencyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java
@@ -33,7 +33,7 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder().setLenient().create();
+    gson = Gson.newBuilder().setLenient().build();
   }
 
   public void testLenientFromJson() {
diff --git a/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java b/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
index c7cfcdf9f..1e72d7cde 100644
--- a/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
@@ -30,9 +30,9 @@
 
   public void testSerializeComplexMapWithTypeAdapter() {
     Type type = new TypeToken<Map<Point, String>>() {}.getType();
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
 
     Map<Point, String> original = new LinkedHashMap<Point, String>();
     original.put(new Point(5, 5), "a");
@@ -54,9 +54,9 @@ public void testSerializeComplexMapWithTypeAdapter() {
   }
 
   public void disabled_testTwoTypesCollapseToOneSerialize() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
 
     Map<Number, String> original = new LinkedHashMap<Number, String>();
     original.put(new Double(1.0), "a");
@@ -69,9 +69,9 @@ public void disabled_testTwoTypesCollapseToOneSerialize() {
   }
 
   public void testTwoTypesCollapseToOneDeserialize() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
 
     String s = "[[\"1.00\",\"a\"],[\"1.0\",\"b\"]]";
     try {
@@ -83,10 +83,10 @@ public void testTwoTypesCollapseToOneDeserialize() {
 
   public void testMultipleEnableComplexKeyRegistrationHasNoEffect() throws Exception {
     Type type = new TypeToken<Map<Point, String>>() {}.getType();
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
 
     Map<Point, String> original = new LinkedHashMap<Point, String>();
     original.put(new Point(6, 5), "abc");
@@ -97,7 +97,7 @@ public void testMultipleEnableComplexKeyRegistrationHasNoEffect() throws Excepti
   }
 
   public void testMapWithTypeVariableSerialization() {
-    Gson gson = new GsonBuilder().enableComplexMapKeySerialization().create();
+    Gson gson = Gson.newBuilder().enableComplexMapKeySerialization().build();
     PointWithProperty<Point> map = new PointWithProperty<Point>();
     map.map.put(new Point(2, 3), new Point(4, 5));
     Type type = new TypeToken<PointWithProperty<Point>>(){}.getType();
@@ -106,7 +106,7 @@ public void testMapWithTypeVariableSerialization() {
   }
 
   public void testMapWithTypeVariableDeserialization() {
-    Gson gson = new GsonBuilder().enableComplexMapKeySerialization().create();
+    Gson gson = Gson.newBuilder().enableComplexMapKeySerialization().build();
     String json = "{map:[[{x:2,y:3},{x:4,y:5}]]}";
     Type type = new TypeToken<PointWithProperty<Point>>(){}.getType();
     PointWithProperty<Point> map = gson.fromJson(json, type);
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index d3def325b..e1809ae5d 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -119,7 +119,7 @@ public void testMapDeserializationWithNullValue() {
   }
 
   public void testMapSerializationWithNullValueButSerializeNulls() {
-    gson = new GsonBuilder().serializeNulls().create();
+    gson = Gson.newBuilder().serializeNulls().build();
     Map<String, Integer> map = new LinkedHashMap<String, Integer>();
     map.put("abc", null);
     Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();
@@ -283,11 +283,11 @@ public void testMapStandardSubclassDeserialization() {
   }
 
   public void testMapSubclassDeserialization() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {
+    Gson gson = Gson.newBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {
       public MyMap createInstance(Type type) {
         return new MyMap();
       }
-    }).create();
+    }).build();
     String json = "{\"a\":1,\"b\":2}";
     MyMap map = gson.fromJson(json, MyMap.class);
     assertEquals("1", map.get("a"));
@@ -297,7 +297,7 @@ public MyMap createInstance(Type type) {
   public void testCustomSerializerForSpecificMapType() {
     Type type = $Gson$Types.newParameterizedTypeWithOwner(
         null, Map.class, String.class, Long.class);
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(type, new JsonSerializer<Map<String, Long>>() {
           public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
               JsonSerializationContext context) {
@@ -307,7 +307,7 @@ public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
             }
             return array;
           }
-        }).create();
+        }).build();
 
     Map<String, Long> src = new LinkedHashMap<String, Long>();
     src.put("one", 1L);
@@ -340,7 +340,7 @@ public void testMapSerializationWithNullValues() {
    * Created in response to http://code.google.com/p/google-gson/issues/detail?id=99
    */
   public void testMapSerializationWithNullValuesSerialized() {
-    Gson gson = new GsonBuilder().serializeNulls().create();
+    Gson gson = Gson.newBuilder().serializeNulls().build();
     ClassWithAMap target = new ClassWithAMap();
     target.map.put("name1", null);
     target.map.put("name2", "value2");
@@ -441,17 +441,17 @@ public void testSerializeMaps() {
     map.put("c", innerMap);
 
     assertEquals("{\"a\":12,\"b\":null,\"c\":{\"test\":1,\"TestStringArray\":[\"one\",\"two\"]}}",
-        new GsonBuilder().serializeNulls().create().toJson(map));
+        Gson.newBuilder().serializeNulls().build().toJson(map));
     assertEquals("{\n  \"a\": 12,\n  \"b\": null,\n  \"c\": "
   		+ "{\n    \"test\": 1,\n    \"TestStringArray\": "
   		+ "[\n      \"one\",\n      \"two\"\n    ]\n  }\n}",
-        new GsonBuilder().setPrettyPrinting().serializeNulls().create().toJson(map));
+        Gson.newBuilder().setPrettyPrinting().serializeNulls().build().toJson(map));
     assertEquals("{\"a\":12,\"c\":{\"test\":1,\"TestStringArray\":[\"one\",\"two\"]}}",
-        new GsonBuilder().create().toJson(map));
+        Gson.newBuilder().build().toJson(map));
     assertEquals("{\n  \"a\": 12,\n  \"c\": "
         + "{\n    \"test\": 1,\n    \"TestStringArray\": "
         + "[\n      \"one\",\n      \"two\"\n    ]\n  }\n}",
-        new GsonBuilder().setPrettyPrinting().create().toJson(map));
+        Gson.newBuilder().setPrettyPrinting().build().toJson(map));
 
     innerMap.put("d", "e");
     assertEquals("{\"a\":12,\"c\":{\"test\":1,\"TestStringArray\":[\"one\",\"two\"],\"d\":\"e\"}}",
@@ -468,9 +468,9 @@ public final void testInterfaceTypeMap() {
     String expected = "{\"bases\":{\"Test\":" + subTypeJson + "},"
       + "\"subs\":{\"Test\":" + subTypeJson + "}}";
 
-    Gson gsonWithComplexKeys = new GsonBuilder()
+    Gson gsonWithComplexKeys = Gson.newBuilder()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
     String json = gsonWithComplexKeys.toJson(element);
     assertEquals(expected, json);
 
@@ -499,16 +499,16 @@ public JsonElement serialize(TestTypes.Base src, Type typeOfSrc,
       }
     };
 
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
         .registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter)
-        .create();
+        .build();
     String json = gson.toJson(element);
     assertEquals(expected, json);
 
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter)
-        .create();
+        .build();
     json = gson.toJson(element);
     assertEquals(expected, json);
   }
@@ -523,9 +523,9 @@ public void testGeneralMapField() throws Exception {
         + "[\"one\",\"two\"],\"objectArray\":[1,2,\"three\"]}}";
     assertEquals(expected, gson.toJson(map));
 
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .enableComplexMapKeySerialization()
-        .create();
+        .build();
     assertEquals(expected, gson.toJson(map));
   }
 
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index 6585b5b58..b8725282a 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -38,46 +38,46 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    builder = new GsonBuilder();
+    builder = Gson.newBuilder();
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"SomeConstantStringInstanceField\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).build();
     String target = "{\"SomeConstantStringInstanceField\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some-constant-string-instance-field\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some.constant.string.instance.field\":\""
           + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).build();
     String target = "{\"some.constant.string.instance.field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).create();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).build();
     String target = "{\"some-constant-string-instance-field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
@@ -85,7 +85,7 @@ public void testGsonWithLowerCaseDashPolicyDeserialiation() {
 
   public void testGsonWithLowerCaseUnderscorePolicySerialization() {
     Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
-        .create();
+        .build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some_constant_string_instance_field\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
@@ -93,21 +93,21 @@ public void testGsonWithLowerCaseUnderscorePolicySerialization() {
 
   public void testGsonWithLowerCaseUnderscorePolicyDeserialiation() {
     Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
-        .create();
+        .build();
     String target = "{\"some_constant_string_instance_field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithSerializedNameFieldNamingPolicySerialization() {
-    Gson gson = builder.create();
+    Gson gson = builder.build();
     ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5, 6);
     String actual = gson.toJson(expected);
     assertEquals(expected.getExpectedJson(), actual);
   }
 
   public void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {
-    Gson gson = builder.create();
+    Gson gson = builder.build();
     ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5, 7);
     ClassWithSerializedNameFields actual =
         gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);
@@ -115,7 +115,7 @@ public void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {
   }
 
   public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() {
-    Gson gson = builder.create();
+    Gson gson = builder.build();
     try {
       ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);
       gson.toJson(target);
@@ -126,7 +126,7 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
 
   public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
     Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
-        .create();
+        .build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"Some Constant String Instance Field\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
@@ -134,14 +134,14 @@ public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
 
   public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
-        .create();
+        .build();
     String target = "{\"Some Constant String Instance Field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testDeprecatedNamingStrategy() throws Exception {
-    Gson gson = builder.setFieldNamingStrategy(new UpperCaseNamingStrategy()).create();
+    Gson gson = builder.setFieldNamingStrategy(new UpperCaseNamingStrategy()).build();
     ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);
     String actual = gson.toJson(target);
     assertEquals("{\"A\":10}", actual);
diff --git a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
index a9b77f1d8..5f500491f 100644
--- a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
@@ -45,11 +45,11 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gsonBuilder = new GsonBuilder().serializeNulls();
+    gsonBuilder = Gson.newBuilder().serializeNulls();
   }
 
   public void testTopLevelNullObjectSerialization() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     String actual = gson.toJson(null);
     assertEquals("null", actual);
 
@@ -58,13 +58,13 @@ public void testTopLevelNullObjectSerialization() {
   }
 
   public void testTopLevelNullObjectDeserialization() throws Exception {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     String actual = gson.fromJson("null", String.class);
     assertNull(actual);
   }
 
   public void testExplicitSerializationOfNulls() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithObjects target = new ClassWithObjects(null);
     String actual = gson.toJson(target);
     String expected = "{\"bag\":null}";
@@ -72,13 +72,13 @@ public void testExplicitSerializationOfNulls() {
   }
 
   public void testExplicitDeserializationOfNulls() throws Exception {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithObjects target = gson.fromJson("{\"bag\":null}", ClassWithObjects.class);
     assertNull(target.bag);
   }
   
   public void testExplicitSerializationOfNullArrayMembers() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithMembers target = new ClassWithMembers();
     String json = gson.toJson(target);
     assertTrue(json.contains("\"array\":null"));
@@ -88,7 +88,7 @@ public void testExplicitSerializationOfNullArrayMembers() {
    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68
    */
   public void testNullWrappedPrimitiveMemberSerialization() {
-    Gson gson = gsonBuilder.serializeNulls().create();
+    Gson gson = gsonBuilder.serializeNulls().build();
     ClassWithNullWrappedPrimitive target = new ClassWithNullWrappedPrimitive();
     String json = gson.toJson(target);
     assertTrue(json.contains("\"value\":null"));
@@ -98,21 +98,21 @@ public void testNullWrappedPrimitiveMemberSerialization() {
    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68
    */
   public void testNullWrappedPrimitiveMemberDeserialization() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     String json = "{'value':null}";
     ClassWithNullWrappedPrimitive target = gson.fromJson(json, ClassWithNullWrappedPrimitive.class);
     assertNull(target.value);
   }
   
   public void testExplicitSerializationOfNullCollectionMembers() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithMembers target = new ClassWithMembers();
     String json = gson.toJson(target);
     assertTrue(json.contains("\"col\":null"));
   }
   
   public void testExplicitSerializationOfNullStringMembers() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithMembers target = new ClassWithMembers();
     String json = gson.toJson(target);
     assertTrue(json.contains("\"str\":null"));
@@ -120,7 +120,7 @@ public void testExplicitSerializationOfNullStringMembers() {
 
   public void testCustomSerializationOfNulls() {
     gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     ClassWithObjects target = new ClassWithObjects(new BagOfPrimitives());
     String actual = gson.toJson(target);
     String expected = "{\"bag\":null}";
@@ -128,23 +128,23 @@ public void testCustomSerializationOfNulls() {
   }
   
   public void testPrintPrintingObjectWithNulls() throws Exception {
-    gsonBuilder = new GsonBuilder();
-    Gson gson = gsonBuilder.create();
+    gsonBuilder = Gson.newBuilder();
+    Gson gson = gsonBuilder.build();
     String result = gson.toJson(new ClassWithMembers());
     assertEquals("{}", result);
 
-    gson = gsonBuilder.serializeNulls().create();
+    gson = gsonBuilder.serializeNulls().build();
     result = gson.toJson(new ClassWithMembers());
     assertTrue(result.contains("\"str\":null"));
   }
   
   public void testPrintPrintingArraysWithNulls() throws Exception {
-    gsonBuilder = new GsonBuilder();
-    Gson gson = gsonBuilder.create();
+    gsonBuilder = Gson.newBuilder();
+    Gson gson = gsonBuilder.build();
     String result = gson.toJson(new String[] { "1", null, "3" });
     assertEquals("[\"1\",null,\"3\"]", result);
 
-    gson = gsonBuilder.serializeNulls().create();
+    gson = gsonBuilder.serializeNulls().build();
     result = gson.toJson(new String[] { "1", null, "3" });
     assertEquals("[\"1\",null,\"3\"]", result);
   }
@@ -208,13 +208,13 @@ public void testExplicitNullSetsFieldToNullDuringDeserialization() {
   }
 
   public void testCustomTypeAdapterPassesNullSerialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(ObjectWithField.class, new JsonSerializer<ObjectWithField>() {
           @Override public JsonElement serialize(ObjectWithField src, Type typeOfSrc,
               JsonSerializationContext context) {
             return context.serialize(null);
           }
-        }).create();
+        }).build();
     ObjectWithField target = new ObjectWithField();
     target.value = "value1";
     String json = gson.toJson(target);
@@ -222,13 +222,13 @@ public void testCustomTypeAdapterPassesNullSerialization() {
   }
 
   public void testCustomTypeAdapterPassesNullDesrialization() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(ObjectWithField.class, new JsonDeserializer<ObjectWithField>() {
           @Override public ObjectWithField deserialize(JsonElement json, Type type,
               JsonDeserializationContext context) {
             return context.deserialize(null, type);
           }
-        }).create();
+        }).build();
     String json = "{value:'value1'}";
     ObjectWithField target = gson.fromJson(json, ObjectWithField.class);
     assertNull(target);
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index 48508f83b..6337195ad 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -290,14 +290,14 @@ public void testAnonymousLocalClassesSerialization() throws Exception {
   }
 
   public void testAnonymousLocalClassesCustomSerialization() throws Exception {
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(ClassWithNoFields.class,
             new JsonSerializer<ClassWithNoFields>() {
               public JsonElement serialize(
                   ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {
                 return new JsonObject();
               }
-            }).create();
+            }).build();
 
     assertEquals("null", gson.toJson(new ClassWithNoFields() {
       // empty anonymous class
@@ -335,12 +335,12 @@ public void testInnerClassSerialization() {
 
   public void testInnerClassDeserialization() {
     final Parent p = new Parent();
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         Parent.Child.class, new InstanceCreator<Parent.Child>() {
       public Parent.Child createInstance(Type type) {
         return p.new Child();
       }
-    }).create();
+    }).build();
     String json = "{'value2':3}";
     Parent.Child c = gson.fromJson(json, Parent.Child.class);
     assertEquals(3, c.value2);
@@ -453,7 +453,7 @@ public void testStringFieldWithEmptyValueDeserialization() {
   }
 
   public void testJsonObjectSerialization() {
-    Gson gson = new GsonBuilder().serializeNulls().create();
+    Gson gson = Gson.newBuilder().serializeNulls().build();
     JsonObject obj = new JsonObject();
     String json = gson.toJson(obj);
     assertEquals("{}", json);
diff --git a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
index 85239c096..4b67186d0 100644
--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
@@ -63,9 +63,9 @@ public void testParameterizedTypeDeserialization() throws Exception {
     MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);
     Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();
     BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))
-        .create();
+        .build();
 
     String json = expected.getExpectedJson();
     MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);
@@ -100,10 +100,10 @@ public void testTypesWithMultipleParametersDeserialization() throws Exception {
   public void testParameterizedTypeWithCustomSerializer() {
     Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();
     Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter<Integer>())
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())
-        .create();
+        .build();
     MyParameterizedType<Integer> intTarget = new MyParameterizedType<Integer>(10);
     String json = gson.toJson(intTarget, ptIntegerType);
     assertEquals(MyParameterizedTypeAdapter.<Integer>getExpectedJson(intTarget), json);
@@ -116,13 +116,13 @@ public void testParameterizedTypeWithCustomSerializer() {
   public void testParameterizedTypesWithCustomDeserializer() {
     Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();
     Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         ptIntegerType, new MyParameterizedTypeAdapter<Integer>())
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""))
         .registerTypeAdapter(ptIntegerType,
             new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))
-        .create();
+        .build();
 
     MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);
     String json = MyParameterizedTypeAdapter.<Integer>getExpectedJson(src);
@@ -148,9 +148,9 @@ public void testParameterizedTypeWithReaderDeserialization() throws Exception {
     MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);
     Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();
     BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();
-    Gson gson = new GsonBuilder().registerTypeAdapter(
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
         expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))
-        .create();
+        .build();
 
     Reader json = new StringReader(expected.getExpectedJson());
     MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);
diff --git a/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java b/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
index 0aacc9e27..bd015d39a 100644
--- a/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
@@ -45,7 +45,7 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder().setPrettyPrinting().create();
+    gson = Gson.newBuilder().setPrettyPrinting().build();
   }
 
   public void testPrettyPrintList() {
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 9da983a3b..470c463da 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -361,7 +361,7 @@ public void testDoubleNaNSerializationNotSupportedByDefault() {
   }
 
   public void testDoubleNaNSerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     double nan = Double.NaN;
     assertEquals("NaN", gson.toJson(nan));
     assertEquals("NaN", gson.toJson(Double.NaN));
@@ -387,7 +387,7 @@ public void testFloatNaNSerializationNotSupportedByDefault() {
   }
 
   public void testFloatNaNSerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     float nan = Float.NaN;
     assertEquals("NaN", gson.toJson(nan));
     assertEquals("NaN", gson.toJson(Float.NaN));
@@ -421,7 +421,7 @@ public void testDoubleInfinitySerializationNotSupportedByDefault() {
   }
 
   public void testDoubleInfinitySerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     double infinity = Double.POSITIVE_INFINITY;
     assertEquals("Infinity", gson.toJson(infinity));
     assertEquals("Infinity", gson.toJson(Double.POSITIVE_INFINITY));
@@ -447,7 +447,7 @@ public void testFloatInfinitySerializationNotSupportedByDefault() {
   }
 
   public void testFloatInfinitySerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     float infinity = Float.POSITIVE_INFINITY;
     assertEquals("Infinity", gson.toJson(infinity));
     assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY));
@@ -481,7 +481,7 @@ public void testNegativeInfinitySerializationNotSupportedByDefault() {
   }
 
   public void testNegativeInfinitySerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     double negativeInfinity = Double.NEGATIVE_INFINITY;
     assertEquals("-Infinity", gson.toJson(negativeInfinity));
     assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY));
@@ -507,7 +507,7 @@ public void testNegativeInfinityFloatSerializationNotSupportedByDefault() {
   }
 
   public void testNegativeInfinityFloatSerialization() {
-    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
+    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
     float negativeInfinity = Float.NEGATIVE_INFINITY;
     assertEquals("-Infinity", gson.toJson(negativeInfinity));
     assertEquals("-Infinity", gson.toJson(Float.NEGATIVE_INFINITY));
@@ -527,7 +527,7 @@ public void testBigDecimalNegativeInfinityDeserializationNotSupported() {
   }
 
   public void testLongAsStringSerialization() throws Exception {
-    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();
+    gson = Gson.newBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).build();
     String result = gson.toJson(15L);
     assertEquals("\"15\"", result);
 
@@ -540,7 +540,7 @@ public void testLongAsStringDeserialization() throws Exception {
     long value = gson.fromJson("\"15\"", long.class);
     assertEquals(15, value);
 
-    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();
+    gson = Gson.newBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).build();
     value = gson.fromJson("\"25\"", long.class);
     assertEquals(25, value);
   }
@@ -569,7 +569,7 @@ public void testHtmlCharacterSerialization() throws Exception {
     String result = gson.toJson(target);
     assertFalse(result.equals('"' + target + '"'));
 
-    gson = new GsonBuilder().disableHtmlEscaping().create();
+    gson = Gson.newBuilder().disableHtmlEscaping().build();
     result = gson.toJson(target);
     assertTrue(result.equals('"' + target + '"'));
   }
diff --git a/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java b/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
index 7dcbc23c3..28a005699 100644
--- a/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
@@ -67,7 +67,7 @@ public void testJsonObjectWithNullValues() {
   }
 
   public void testJsonObjectWithNullValuesSerialized() {
-    gson = new GsonBuilder().serializeNulls().create();
+    gson = Gson.newBuilder().serializeNulls().build();
     JsonObject obj = new JsonObject();
     obj.addProperty("field1", "value1");
     obj.addProperty("field2", (String) null);
diff --git a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java
index e21fb903e..946ad2bea 100644
--- a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java
@@ -75,14 +75,14 @@ public void testTopLevelNullObjectDeserializationWithReader() {
   }
 
   public void testTopLevelNullObjectSerializationWithWriterAndSerializeNulls() {
-    Gson gson = new GsonBuilder().serializeNulls().create();
+    Gson gson = Gson.newBuilder().serializeNulls().build();
     StringWriter writer = new StringWriter();
     gson.toJson(null, writer);
     assertEquals("null", writer.toString());
   }
 
   public void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {
-    Gson gson = new GsonBuilder().serializeNulls().create();
+    Gson gson = Gson.newBuilder().serializeNulls().build();
     StringReader reader = new StringReader("null");
     Integer nullIntObject = gson.fromJson(reader, Integer.class);
     assertNull(nullIntObject);
diff --git a/gson/src/test/java/com/google/gson/functional/SecurityTest.java b/gson/src/test/java/com/google/gson/functional/SecurityTest.java
index aa1c2d451..87d97f3eb 100644
--- a/gson/src/test/java/com/google/gson/functional/SecurityTest.java
+++ b/gson/src/test/java/com/google/gson/functional/SecurityTest.java
@@ -38,24 +38,24 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gsonBuilder = new GsonBuilder();
+    gsonBuilder = Gson.newBuilder();
   }
 
   public void testNonExecutableJsonSerialization() {
-    Gson gson = gsonBuilder.generateNonExecutableJson().create();
+    Gson gson = gsonBuilder.generateNonExecutableJson().build();
     String json = gson.toJson(new BagOfPrimitives());
     assertTrue(json.startsWith(JSON_NON_EXECUTABLE_PREFIX));
   }
   
   public void testNonExecutableJsonDeserialization() {
     String json = JSON_NON_EXECUTABLE_PREFIX + "{longValue:1}";
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);
     assertEquals(1, target.longValue);
   }
   
   public void testJsonWithNonExectuableTokenSerialization() {
-    Gson gson = gsonBuilder.generateNonExecutableJson().create();
+    Gson gson = gsonBuilder.generateNonExecutableJson().build();
     String json = gson.toJson(JSON_NON_EXECUTABLE_PREFIX);
     assertTrue(json.contains(")]}'\n"));
   }
@@ -65,7 +65,7 @@ public void testJsonWithNonExectuableTokenSerialization() {
    *  without {@link GsonBuilder#generateNonExecutableJson()}.
    */
   public void testJsonWithNonExectuableTokenWithRegularGsonDeserialization() {
-    Gson gson = gsonBuilder.create();
+    Gson gson = gsonBuilder.build();
     String json = JSON_NON_EXECUTABLE_PREFIX + "{stringValue:')]}\\u0027\\n'}";
     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);
     assertEquals(")]}'\n", target.stringValue);
@@ -77,7 +77,7 @@ public void testJsonWithNonExectuableTokenWithRegularGsonDeserialization() {
    */
   public void testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization() {
     // Gson should be able to deserialize a stream with non-exectuable token even if it is created 
-    Gson gson = gsonBuilder.generateNonExecutableJson().create();
+    Gson gson = gsonBuilder.generateNonExecutableJson().build();
     String json = JSON_NON_EXECUTABLE_PREFIX + "{intValue:2,stringValue:')]}\\u0027\\n'}";
     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);
     assertEquals(")]}'\n", target.stringValue);
diff --git a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 45e85342c..1edc9bdf9 100644
--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -36,7 +36,7 @@
 import junit.framework.TestCase;
 
 public final class StreamingTypeAdaptersTest extends TestCase {
-  private Gson miniGson = new GsonBuilder().create();
+  private Gson miniGson = Gson.newBuilder().build();
   private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);
   private TypeAdapter<Map<String, Double>> mapAdapter
       = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});
@@ -107,7 +107,7 @@ private void usePersonNameAdapter() {
         out.value(value.name);
       }
     };
-    miniGson = new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();
+    miniGson = Gson.newBuilder().registerTypeAdapter(Person.class, personNameAdapter).build();
     truckAdapter = miniGson.getAdapter(Truck.class);
   }
 
@@ -159,8 +159,8 @@ public void write(JsonWriter out, Person person) throws IOException {
         out.value(person.name + "," + person.age);
       }
     };
-    Gson gson = new GsonBuilder().registerTypeAdapter(
-        Person.class, typeAdapter).create();
+    Gson gson = Gson.newBuilder().registerTypeAdapter(
+        Person.class, typeAdapter).build();
     Truck truck = new Truck();
     truck.horsePower = 1.0D;
     truck.passengers = new ArrayList<Person>();
@@ -175,7 +175,7 @@ public void write(JsonWriter out, Person person) throws IOException {
       gson.fromJson(json, Truck.class);
       fail();
     } catch (JsonSyntaxException expected) {}
-    gson = new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).create();
+    gson = Gson.newBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).build();
     assertEquals("{\"horsePower\":1.0,\"passengers\":[null,\"jesse,30\"]}",
         gson.toJson(truck, Truck.class));
     truck = gson.fromJson(json, Truck.class);
diff --git a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
index ad737ec51..9f75b4c74 100644
--- a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
@@ -53,9 +53,9 @@
 
   @Override
   protected void setUp() {
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeAdapter(Id.class, new IdTreeTypeAdapter())
-        .create();
+        .build();
     course = new Course<HistoryCourse>(COURSE_ID, 4,
         new Assignment<HistoryCourse>(null, null), createList(STUDENT1, STUDENT2));
   }
diff --git a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
index 5f881530d..5a726888f 100644
--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
@@ -33,82 +33,82 @@
 
 public final class TypeAdapterPrecedenceTest extends TestCase {
   public void testNonstreamingFollowedByNonstreaming() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Foo.class, newSerializer("serializer 1"))
         .registerTypeAdapter(Foo.class, newSerializer("serializer 2"))
         .registerTypeAdapter(Foo.class, newDeserializer("deserializer 1"))
         .registerTypeAdapter(Foo.class, newDeserializer("deserializer 2"))
-        .create();
+        .build();
     assertEquals("\"foo via serializer 2\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via deserializer 2", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testStreamingFollowedByStreaming() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Foo.class, newTypeAdapter("type adapter 1"))
         .registerTypeAdapter(Foo.class, newTypeAdapter("type adapter 2"))
-        .create();
+        .build();
     assertEquals("\"foo via type adapter 2\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via type adapter 2", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testSerializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Foo.class, newSerializer("serializer"))
         .registerTypeAdapter(Foo.class, newDeserializer("deserializer"))
         .registerTypeAdapter(Foo.class, newTypeAdapter("type adapter"))
-        .create();
+        .build();
     assertEquals("\"foo via type adapter\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via type adapter", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testStreamingFollowedByNonstreaming() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Foo.class, newTypeAdapter("type adapter"))
         .registerTypeAdapter(Foo.class, newSerializer("serializer"))
         .registerTypeAdapter(Foo.class, newDeserializer("deserializer"))
-        .create();
+        .build();
     assertEquals("\"foo via serializer\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via deserializer", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testStreamingHierarchicalFollowedByNonstreaming() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Foo.class, newTypeAdapter("type adapter"))
         .registerTypeAdapter(Foo.class, newSerializer("serializer"))
         .registerTypeAdapter(Foo.class, newDeserializer("deserializer"))
-        .create();
+        .build();
     assertEquals("\"foo via serializer\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via deserializer", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testStreamingFollowedByNonstreamingHierarchical() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeAdapter(Foo.class, newTypeAdapter("type adapter"))
         .registerTypeHierarchyAdapter(Foo.class, newSerializer("serializer"))
         .registerTypeHierarchyAdapter(Foo.class, newDeserializer("deserializer"))
-        .create();
+        .build();
     assertEquals("\"foo via type adapter\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via type adapter", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testStreamingHierarchicalFollowedByNonstreamingHierarchical() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Foo.class, newSerializer("serializer"))
         .registerTypeHierarchyAdapter(Foo.class, newDeserializer("deserializer"))
         .registerTypeHierarchyAdapter(Foo.class, newTypeAdapter("type adapter"))
-        .create();
+        .build();
     assertEquals("\"foo via type adapter\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via type adapter", gson.fromJson("foo", Foo.class).name);
   }
 
   public void testNonstreamingHierarchicalFollowedByNonstreaming() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Foo.class, newSerializer("hierarchical"))
         .registerTypeHierarchyAdapter(Foo.class, newDeserializer("hierarchical"))
         .registerTypeAdapter(Foo.class, newSerializer("non hierarchical"))
         .registerTypeAdapter(Foo.class, newDeserializer("non hierarchical"))
-        .create();
+        .build();
     assertEquals("\"foo via non hierarchical\"", gson.toJson(new Foo("foo")));
     assertEquals("foo via non hierarchical", gson.fromJson("foo", Foo.class).name);
   }
diff --git a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
index 25b9c3436..cb36385a1 100644
--- a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
@@ -55,10 +55,10 @@ public void testTypeHierarchy() {
         andy,
     };
 
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())
         .setPrettyPrinting()
-        .create();
+        .build();
 
     Company company = new Company();
     company.ceo = eric;
@@ -117,10 +117,10 @@ public void testTypeHierarchy() {
   }
 
   public void testRegisterSuperTypeFirst() {
-    Gson gson = new GsonBuilder()
+    Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())
         .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())
-        .create();
+        .build();
 
     Manager manager = new Manager();
     manager.userid = "inder";
@@ -133,10 +133,10 @@ public void testRegisterSuperTypeFirst() {
 
   /** This behaviour changed in Gson 2.1; it used to throw. */
   public void testRegisterSubTypeFirstAllowed() {
-    new GsonBuilder()
+	  Gson.newBuilder()
         .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())
         .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())
-        .create();
+        .build();
   }
 
   static class ManagerAdapter implements JsonSerializer<Manager>, JsonDeserializer<Manager> {
diff --git a/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java b/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
index 0ac038035..d9875ad2f 100644
--- a/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
+++ b/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
@@ -85,7 +85,7 @@ public void testGsonInstanceReusableForSerializationAndDeserialization() {
    * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761
    */
   public void testReturningDerivedClassesDuringDeserialization() {
-    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();
+    Gson gson = Gson.newBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).build();
     String json = "{\"opType\":\"OP1\"}";
     Base base = gson.fromJson(json, Base.class);
     assertTrue(base instanceof Derived1);
diff --git a/gson/src/test/java/com/google/gson/functional/VersioningTest.java b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
index 2416fc06d..695e0412c 100644
--- a/gson/src/test/java/com/google/gson/functional/VersioningTest.java
+++ b/gson/src/test/java/com/google/gson/functional/VersioningTest.java
@@ -40,36 +40,36 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    builder = new GsonBuilder();
+    builder = Gson.newBuilder();
   }
 
   public void testVersionedUntilSerialization() {
     Version1 target = new Version1();
-    Gson gson = builder.setVersion(1.29).create();
+    Gson gson = builder.setVersion(1.29).build();
     String json = gson.toJson(target);
     assertTrue(json.contains("\"a\":" + A));
 
-    gson = builder.setVersion(1.3).create();
+    gson = builder.setVersion(1.3).build();
     json = gson.toJson(target);
     assertFalse(json.contains("\"a\":" + A));
   }
 
   public void testVersionedUntilDeserialization() {
-    Gson gson = builder.setVersion(1.3).create();
+    Gson gson = builder.setVersion(1.3).build();
     String json = "{\"a\":3,\"b\":4,\"c\":5}";
     Version1 version1 = gson.fromJson(json, Version1.class);
     assertEquals(A, version1.a);
   }
 
   public void testVersionedClassesSerialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     String json1 = gson.toJson(new Version1());
     String json2 = gson.toJson(new Version1_1());
     assertEquals(json1, json2);
   }
 
   public void testVersionedClassesDeserialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     String json = "{\"a\":3,\"b\":4,\"c\":5}";
     Version1 version1 = gson.fromJson(json, Version1.class);
     assertEquals(3, version1.a);
@@ -81,12 +81,12 @@ public void testVersionedClassesDeserialization() {
   }
 
   public void testIgnoreLaterVersionClassSerialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     assertEquals("null", gson.toJson(new Version1_2()));
   }
 
   public void testIgnoreLaterVersionClassDeserialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     String json = "{\"a\":3,\"b\":4,\"c\":5,\"d\":6}";
     Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);
     // Since the class is versioned to be after 1.0, we expect null
@@ -95,13 +95,13 @@ public void testIgnoreLaterVersionClassDeserialization() {
   }
 
   public void testVersionedGsonWithUnversionedClassesSerialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");
     assertEquals(target.getExpectedJson(), gson.toJson(target));
   }
 
   public void testVersionedGsonWithUnversionedClassesDeserialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}";
 
     BagOfPrimitives expected = new BagOfPrimitives();
@@ -113,33 +113,33 @@ public void testVersionedGsonWithUnversionedClassesDeserialization() {
   }
 
   public void testVersionedGsonMixingSinceAndUntilSerialization() {
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     SinceUntilMixing target = new SinceUntilMixing();
     String json = gson.toJson(target);
     assertFalse(json.contains("\"b\":" + B));
 
-    gson = builder.setVersion(1.2).create();
+    gson = builder.setVersion(1.2).build();
     json = gson.toJson(target);
     assertTrue(json.contains("\"b\":" + B));
 
-    gson = builder.setVersion(1.3).create();
+    gson = builder.setVersion(1.3).build();
     json = gson.toJson(target);
     assertFalse(json.contains("\"b\":" + B));
   }
 
   public void testVersionedGsonMixingSinceAndUntilDeserialization() {
     String json = "{\"a\":5,\"b\":6}";
-    Gson gson = builder.setVersion(1.0).create();
+    Gson gson = builder.setVersion(1.0).build();
     SinceUntilMixing result = gson.fromJson(json, SinceUntilMixing.class);
     assertEquals(5, result.a);
     assertEquals(B, result.b);
 
-    gson = builder.setVersion(1.2).create();
+    gson = builder.setVersion(1.2).build();
     result = gson.fromJson(json, SinceUntilMixing.class);
     assertEquals(5, result.a);
     assertEquals(6, result.b);
 
-    gson = builder.setVersion(1.3).create();
+    gson = builder.setVersion(1.3).build();
     result = gson.fromJson(json, SinceUntilMixing.class);
     assertEquals(5, result.a);
     assertEquals(B, result.b);
diff --git a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
index 68134372c..47b3acb38 100644
--- a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
+++ b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
@@ -233,9 +233,9 @@ public void parse(char[] data, Document document) throws Exception {
   }
 
   private static class GsonBindParser implements Parser {
-    private static Gson gson = new GsonBuilder()
+    private static Gson gson = Gson.newBuilder()
         .setDateFormat("EEE MMM dd HH:mm:ss Z yyyy")
-        .create();
+        .build();
 
     public void parse(char[] data, Document document) throws Exception {
       gson.fromJson(new CharArrayReader(data), document.gsonType);
diff --git a/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java b/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
index 9cdf085e8..be710eae7 100644
--- a/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
+++ b/metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
@@ -41,7 +41,7 @@ public static void main(String[] args) {
   
   @Override
   protected void setUp() throws Exception {
-    this.gson = pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();
+    this.gson = pretty ? Gson.newBuilder().setPrettyPrinting().build() : new Gson();
     this.bag = new BagOfPrimitives(10L, 1, false, "foo");
   }
 
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java
index 2bb6f183a..030dd1175 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java
@@ -51,19 +51,19 @@ protected void setUp() throws Exception {
         .setEnumSerialization(EnumSerialization.NAME)
         .addSerializedNameExtension(Annotations.serializedName)
         .addSerializedEnumValueExtension(Annotations.serializedValue);
-    gson = new GsonBuilder()
+    gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter.build())
-        .create();
-    gsonWithEnumNumbers = new GsonBuilder()
+        .build();
+    gsonWithEnumNumbers = Gson.newBuilder()
         .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
             .setEnumSerialization(EnumSerialization.NUMBER)
             .build())
-        .create();
-    gsonWithLowerHyphen = new GsonBuilder()
+        .build();
+    gsonWithLowerHyphen = Gson.newBuilder()
         .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
             .setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN)
             .build())
-        .create();
+        .build();
   }
 
   public void testProtoWithAnnotations_deserialize() {
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
index b61d3f509..2c3a74e8e 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
@@ -41,20 +41,20 @@
   protected void setUp() throws Exception {
     super.setUp();
     gson =
-        new GsonBuilder()
+        Gson.newBuilder()
             .registerTypeHierarchyAdapter(GeneratedMessage.class,
                 ProtoTypeAdapter.newBuilder()
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
-            .create();
+            .build();
     upperCamelGson =
-        new GsonBuilder()
+        Gson.newBuilder()
             .registerTypeHierarchyAdapter(
                 GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
                     .setFieldNameSerializationFormat(
                         CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
                     .build())
-            .create();
+            .build();
   }
 
   public void testSerializeRepeatedFields() {
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
index 69b877e60..2bfbcf4d0 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
@@ -31,11 +31,11 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = new GsonBuilder().registerTypeHierarchyAdapter(
+    gson = Gson.newBuilder().registerTypeHierarchyAdapter(
       GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
           .setEnumSerialization(EnumSerialization.NUMBER)
           .build())
-      .create();
+      .build();
   }
 
   public void testSerializeEmptyProto() {
