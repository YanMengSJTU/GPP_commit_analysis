diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 5174e9c8b..cf223a902 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -166,7 +166,6 @@
 		factories.add(TypeAdapters.LOCALE_FACTORY);
 		factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
 		factories.add(TypeAdapters.BIT_SET_FACTORY);
-		factories.add(TypeAdapters.TIMESTAMP_FACTORY);
 		factories.add(ArrayTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.CLASS_FACTORY);
 		factories.add(LocalTimeAdapter.factory);
@@ -585,7 +584,6 @@ public void toJson(Object src, Type typeOfSrc, Writer writer) throws JsonIOExcep
 	@SuppressWarnings("unchecked")
 	public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
 		TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
-		boolean oldLenient = writer.isLenient();
 		boolean oldHtmlSafe = writer.isHtmlSafe();
 		writer.setHtmlSafe(htmlSafe);
 		boolean oldSerializeNulls = writer.getSerializeNulls();
@@ -599,7 +597,6 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
 			error.initCause(e);
 			throw error;
 		} finally {
-			writer.setLenient(oldLenient);
 			writer.setHtmlSafe(oldHtmlSafe);
 			writer.setSerializeNulls(oldSerializeNulls);
 		}
@@ -663,8 +660,6 @@ public JsonReader newJsonReader(Reader reader) {
 	 * @throws JsonIOException if there was a problem writing to the writer
 	 */
 	public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {
-		boolean oldLenient = writer.isLenient();
-		writer.setLenient(true);
 		boolean oldHtmlSafe = writer.isHtmlSafe();
 		writer.setHtmlSafe(htmlSafe);
 		boolean oldSerializeNulls = writer.getSerializeNulls();
@@ -678,7 +673,6 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
 			error.initCause(e);
 			throw error;
 		} finally {
-			writer.setLenient(oldLenient);
 			writer.setHtmlSafe(oldHtmlSafe);
 			writer.setSerializeNulls(oldSerializeNulls);
 		}
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index 9dd16f539..60f1a3877 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -16,15 +16,11 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.*;
 import com.google.gson.internal.bind.*;
 import com.google.gson.stream.*;
 import java.io.*;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
+import java.math.*;
+import java.util.*;
 
 /**
  * A class representing an array type in Json. An array is a list of {@link JsonElement}s each of
@@ -106,10 +102,7 @@ public void add(String string) {
 	 * @param element the element that needs to be added to the array.
 	 */
 	public void add(JsonElement element) {
-		if (element == null) {
-			element = JsonNull.INSTANCE;
-		}
-		elements.add(element);
+		elements.add(element == null ? JsonNull.INSTANCE : element);
 	}
 
 	/**
@@ -182,6 +175,7 @@ public int size() {
 	 *
 	 * @return an iterator to navigate the elements of the array.
 	 */
+	@Override
 	public Iterator<JsonElement> iterator() {
 		return elements.iterator();
 	}
@@ -357,7 +351,6 @@ public String toString() {
 		try {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
-			jsonWriter.setLenient(true);
 			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 6bf6af6b3..6b5aea064 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -201,7 +201,6 @@ public String toString() {
 		try {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
-			jsonWriter.setLenient(true);
 			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index d74665b89..7ca30b613 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -243,7 +243,6 @@ public String toString() {
 		try {
 			StringWriter stringWriter = new StringWriter();
 			JsonWriter jsonWriter = new JsonWriter(stringWriter);
-			jsonWriter.setLenient(true);
 			TypeAdapters.JSON_ELEMENT.write(jsonWriter, this);
 			return stringWriter.toString();
 		} catch (IOException e) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
index 51dc1f3a3..a0f97ef15 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
@@ -31,178 +31,176 @@
  * This writer creates a JsonElement.
  */
 public final class JsonTreeWriter extends JsonWriter {
-  private static final Writer UNWRITABLE_WRITER = new Writer() {
-    @Override public void write(char[] buffer, int offset, int counter) {
-      throw new AssertionError();
-    }
-    @Override public void flush() throws IOException {
-      throw new AssertionError();
-    }
-    @Override public void close() throws IOException {
-      throw new AssertionError();
-    }
-  };
-  /** Added to the top of the stack when this writer is closed to cause following ops to fail. */
-  private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive("closed");
-
-  /** The JsonElements and JsonArrays under modification, outermost to innermost. */
-  private final List<JsonElement> stack = new ArrayList<JsonElement>();
-
-  /** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */
-  private String pendingName;
-
-  /** the JSON element constructed by this writer. */
-  private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;
-
-  public JsonTreeWriter() {
-    super(UNWRITABLE_WRITER);
-  }
-
-  /**
-   * Returns the top level object produced by this writer.
-   */
-  public JsonElement get() {
-    if (!stack.isEmpty()) {
-      throw new IllegalStateException("Expected one JSON element but was " + stack);
-    }
-    return product;
-  }
-
-  private JsonElement peek() {
-    return stack.get(stack.size() - 1);
-  }
-
-  private void put(JsonElement value) {
-    if (pendingName != null) {
-      if (!value.isJsonNull() || getSerializeNulls()) {
-        JsonObject object = (JsonObject) peek();
-        object.add(pendingName, value);
-      }
-      pendingName = null;
-    } else if (stack.isEmpty()) {
-      product = value;
-    } else {
-      JsonElement element = peek();
-      if (element instanceof JsonArray) {
-        ((JsonArray) element).add(value);
-      } else {
-        throw new IllegalStateException();
-      }
-    }
-  }
-
-  @Override public JsonWriter beginArray() throws IOException {
-    JsonArray array = new JsonArray();
-    put(array);
-    stack.add(array);
-    return this;
-  }
-
-  @Override public JsonWriter endArray() throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonArray) {
-      stack.remove(stack.size() - 1);
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter beginObject() throws IOException {
-    JsonObject object = new JsonObject();
-    put(object);
-    stack.add(object);
-    return this;
-  }
-
-  @Override public JsonWriter endObject() throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonObject) {
-      stack.remove(stack.size() - 1);
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter name(String name) throws IOException {
-    if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
-    }
-    JsonElement element = peek();
-    if (element instanceof JsonObject) {
-      pendingName = name;
-      return this;
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override public JsonWriter value(String value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter nullValue() throws IOException {
-    put(JsonNull.INSTANCE);
-    return this;
-  }
-
-  @Override public JsonWriter value(boolean value) throws IOException {
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(Boolean value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(double value) throws IOException {
-    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {
-      throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
-    }
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(long value) throws IOException {
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public JsonWriter value(Number value) throws IOException {
-    if (value == null) {
-      return nullValue();
-    }
-
-    if (!isLenient()) {
-      double d = value.doubleValue();
-      if (Double.isNaN(d) || Double.isInfinite(d)) {
-        throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
-      }
-    }
-
-    put(new JsonPrimitive(value));
-    return this;
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public void close() throws IOException {
-    if (!stack.isEmpty()) {
-      throw new IOException("Incomplete document");
-    }
-    stack.add(SENTINEL_CLOSED);
-  }
+	private static final Writer UNWRITABLE_WRITER = new Writer() {
+		@Override public void write(char[] buffer, int offset, int counter) {
+			throw new AssertionError();
+		}
+		@Override public void flush() throws IOException {
+			throw new AssertionError();
+		}
+		@Override public void close() throws IOException {
+			throw new AssertionError();
+		}
+	};
+	/** Added to the top of the stack when this writer is closed to cause following ops to fail. */
+	private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive("closed");
+
+	/** The JsonElements and JsonArrays under modification, outermost to innermost. */
+	private final List<JsonElement> stack = new ArrayList<JsonElement>();
+
+	/** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */
+	private String pendingName;
+
+	/** the JSON element constructed by this writer. */
+	private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;
+
+	public JsonTreeWriter() {
+		super(UNWRITABLE_WRITER);
+	}
+
+	/**
+	 * Returns the top level object produced by this writer.
+	 */
+	public JsonElement get() {
+		if (!stack.isEmpty()) {
+			throw new IllegalStateException("Expected one JSON element but was " + stack);
+		}
+		return product;
+	}
+
+	private JsonElement peek() {
+		return stack.get(stack.size() - 1);
+	}
+
+	private void put(JsonElement value) {
+		if (pendingName != null) {
+			if (!value.isJsonNull() || getSerializeNulls()) {
+				JsonObject object = (JsonObject) peek();
+				object.add(pendingName, value);
+			}
+			pendingName = null;
+		} else if (stack.isEmpty()) {
+			product = value;
+		} else {
+			JsonElement element = peek();
+			if (element instanceof JsonArray) {
+				((JsonArray) element).add(value);
+			} else {
+				throw new IllegalStateException();
+			}
+		}
+	}
+
+	@Override public JsonWriter beginArray() throws IOException {
+		JsonArray array = new JsonArray();
+		put(array);
+		stack.add(array);
+		return this;
+	}
+
+	@Override public JsonWriter endArray() throws IOException {
+		if (stack.isEmpty() || pendingName != null) {
+			throw new IllegalStateException();
+		}
+		JsonElement element = peek();
+		if (element instanceof JsonArray) {
+			stack.remove(stack.size() - 1);
+			return this;
+		}
+		throw new IllegalStateException();
+	}
+
+	@Override public JsonWriter beginObject() throws IOException {
+		JsonObject object = new JsonObject();
+		put(object);
+		stack.add(object);
+		return this;
+	}
+
+	@Override public JsonWriter endObject() throws IOException {
+		if (stack.isEmpty() || pendingName != null) {
+			throw new IllegalStateException();
+		}
+		JsonElement element = peek();
+		if (element instanceof JsonObject) {
+			stack.remove(stack.size() - 1);
+			return this;
+		}
+		throw new IllegalStateException();
+	}
+
+	@Override public JsonWriter name(String name) throws IOException {
+		if (stack.isEmpty() || pendingName != null) {
+			throw new IllegalStateException();
+		}
+		JsonElement element = peek();
+		if (element instanceof JsonObject) {
+			pendingName = name;
+			return this;
+		}
+		throw new IllegalStateException();
+	}
+
+	@Override public JsonWriter value(String value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public JsonWriter nullValue() throws IOException {
+		put(JsonNull.INSTANCE);
+		return this;
+	}
+
+	@Override public JsonWriter value(boolean value) throws IOException {
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public JsonWriter value(Boolean value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public JsonWriter value(double value) throws IOException {
+		if (Double.isNaN(value) || Double.isInfinite(value)) {
+			throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
+		}
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public JsonWriter value(long value) throws IOException {
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public JsonWriter value(Number value) throws IOException {
+		if (value == null) {
+			return nullValue();
+		}
+
+		double d = value.doubleValue();
+		if (Double.isNaN(d) || Double.isInfinite(d)) {
+			throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
+		}
+
+		put(new JsonPrimitive(value));
+		return this;
+	}
+
+	@Override public void flush() throws IOException {
+	}
+
+	@Override public void close() throws IOException {
+		if (!stack.isEmpty()) {
+			throw new IOException("Incomplete document");
+		}
+		stack.add(SENTINEL_CLOSED);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index d694f9a74..8fb1834a2 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -16,46 +16,17 @@
 
 package com.google.gson.internal.bind;
 
-import java.io.IOException;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Calendar;
-import java.util.Currency;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicIntegerArray;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.LazilyParsedNumber;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+import com.google.gson.*;
+import com.google.gson.annotations.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.math.*;
+import java.net.*;
+import java.sql.*;
+import java.util.*;
+import java.util.concurrent.atomic.*;
 
 /**
  * Type adapters for basic types.
@@ -130,7 +101,7 @@ public Class read(JsonReader in) throws IOException {
 
 	public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
 
-	public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
+	public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<>() {
 		@Override
 		public Boolean read(JsonReader in) throws IOException {
 			JsonToken peek = in.peek();
@@ -153,7 +124,7 @@ public void write(JsonWriter out, Boolean value) throws IOException {
 	 * Writes a boolean as a string. Useful for map keys, where booleans aren't
 	 * otherwise permitted.
 	 */
-	public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {
+	public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<>() {
 		@Override public Boolean read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
 				in.nextNull();
@@ -170,7 +141,7 @@ public void write(JsonWriter out, Boolean value) throws IOException {
 	public static final TypeAdapterFactory BOOLEAN_FACTORY
 	= newFactory(boolean.class, Boolean.class, BOOLEAN);
 
-	public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> BYTE = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -193,7 +164,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 	public static final TypeAdapterFactory BYTE_FACTORY
 	= newFactory(byte.class, Byte.class, BYTE);
 
-	public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> SHORT = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -215,7 +186,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 	public static final TypeAdapterFactory SHORT_FACTORY
 	= newFactory(short.class, Short.class, SHORT);
 
-	public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> INTEGER = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -264,7 +235,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 
 	public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {
 		@Override public AtomicIntegerArray read(JsonReader in) throws IOException {
-			List<Integer> list = new ArrayList<Integer>();
+			List<Integer> list = new ArrayList<>();
 			in.beginArray();
 			while (in.hasNext()) {
 				try {
@@ -293,7 +264,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 	public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =
 			newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);
 
-	public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> LONG = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -312,7 +283,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> FLOAT = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -341,7 +312,7 @@ static void checkValidFloatingPoint(double value) {
 		}
 	}
 
-	public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -362,7 +333,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {
+	public static final TypeAdapter<Number> NUMBER = new TypeAdapter<>() {
 		@Override
 		public Number read(JsonReader in) throws IOException {
 			JsonToken jsonToken = in.peek();
@@ -385,7 +356,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 
 	public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);
 
-	public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {
+	public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<>() {
 		@Override
 		public Character read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -407,7 +378,7 @@ public void write(JsonWriter out, Character value) throws IOException {
 	public static final TypeAdapterFactory CHARACTER_FACTORY
 	= newFactory(char.class, Character.class, CHARACTER);
 
-	public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {
+	public static final TypeAdapter<String> STRING = new TypeAdapter<>() {
 		@Override
 		public String read(JsonReader in) throws IOException {
 			JsonToken peek = in.peek();
@@ -427,7 +398,7 @@ public void write(JsonWriter out, String value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {
+	public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<>() {
 		@Override public BigDecimal read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
 				in.nextNull();
@@ -445,7 +416,7 @@ public void write(JsonWriter out, String value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {
+	public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<>() {
 		@Override public BigInteger read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
 				in.nextNull();
@@ -465,7 +436,7 @@ public void write(JsonWriter out, String value) throws IOException {
 
 	public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);
 
-	public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {
+	public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<>() {
 		@Override
 		public StringBuilder read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -483,7 +454,7 @@ public void write(JsonWriter out, StringBuilder value) throws IOException {
 	public static final TypeAdapterFactory STRING_BUILDER_FACTORY =
 			newFactory(StringBuilder.class, STRING_BUILDER);
 
-	public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {
+	public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<>() {
 		@Override
 		public StringBuffer read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -501,7 +472,7 @@ public void write(JsonWriter out, StringBuffer value) throws IOException {
 	public static final TypeAdapterFactory STRING_BUFFER_FACTORY =
 			newFactory(StringBuffer.class, STRING_BUFFER);
 
-	public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {
+	public static final TypeAdapter<URL> URL = new TypeAdapter<>() {
 		@Override
 		public URL read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -519,7 +490,7 @@ public void write(JsonWriter out, URL value) throws IOException {
 
 	public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);
 
-	public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {
+	public static final TypeAdapter<URI> URI = new TypeAdapter<>() {
 		@Override
 		public URI read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -541,7 +512,7 @@ public void write(JsonWriter out, URI value) throws IOException {
 
 	public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);
 
-	public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {
+	public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<>() {
 		@Override
 		public InetAddress read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -560,7 +531,7 @@ public void write(JsonWriter out, InetAddress value) throws IOException {
 	public static final TypeAdapterFactory INET_ADDRESS_FACTORY =
 			newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);
 
-	public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {
+	public static final TypeAdapter<UUID> UUID = new TypeAdapter<>() {
 		@Override
 		public UUID read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -589,28 +560,7 @@ public void write(JsonWriter out, Currency value) throws IOException {
 	}.nullSafe();
 	public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);
 
-	public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {
-		@SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-		@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-			if (typeToken.getRawType() != Timestamp.class) {
-				return null;
-			}
-
-			final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);
-			return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {
-				@Override public Timestamp read(JsonReader in) throws IOException {
-					Date date = dateTypeAdapter.read(in);
-					return date != null ? new Timestamp(date.getTime()) : null;
-				}
-
-				@Override public void write(JsonWriter out, Timestamp value) throws IOException {
-					dateTypeAdapter.write(out, value);
-				}
-			};
-		}
-	};
-
-	public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {
+	public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<>() {
 		@Override
 		public Locale read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
@@ -647,7 +597,7 @@ public void write(JsonWriter out, Locale value) throws IOException {
 
 	public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);
 
-	public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {
+	public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<>() {
 		@Override public JsonElement read(JsonReader in) throws IOException {
 			switch (in.peek()) {
 			case STRING:
@@ -723,8 +673,8 @@ public void write(JsonWriter out, Locale value) throws IOException {
 	= newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
 
 	private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
-		private final Map<String, T> nameToConstant = new HashMap<String, T>();
-		private final Map<T, String> constantToName = new HashMap<T, String>();
+		private final Map<String, T> nameToConstant = new HashMap<>();
+		private final Map<T, String> constantToName = new HashMap<>();
 
 		public EnumTypeAdapter(Class<T> classOfT) {
 			try {
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 1e2793865..6b99ac124 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -189,1425 +189,1423 @@
  * @since 1.6
  */
 public class JsonReader implements Closeable {
-  /** The only non-execute prefix this parser permits */
-  private static final char[] NON_EXECUTE_PREFIX = ")]}'\n".toCharArray();
-  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
-
-  private static final int PEEKED_NONE = 0;
-  private static final int PEEKED_BEGIN_OBJECT = 1;
-  private static final int PEEKED_END_OBJECT = 2;
-  private static final int PEEKED_BEGIN_ARRAY = 3;
-  private static final int PEEKED_END_ARRAY = 4;
-  private static final int PEEKED_TRUE = 5;
-  private static final int PEEKED_FALSE = 6;
-  private static final int PEEKED_NULL = 7;
-  private static final int PEEKED_SINGLE_QUOTED = 8;
-  private static final int PEEKED_DOUBLE_QUOTED = 9;
-  private static final int PEEKED_UNQUOTED = 10;
-  /** When this is returned, the string value is stored in peekedString. */
-  private static final int PEEKED_BUFFERED = 11;
-  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
-  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
-  private static final int PEEKED_UNQUOTED_NAME = 14;
-  /** When this is returned, the integer value is stored in peekedLong. */
-  private static final int PEEKED_LONG = 15;
-  private static final int PEEKED_NUMBER = 16;
-  private static final int PEEKED_EOF = 17;
-
-  /* State machine when parsing numbers */
-  private static final int NUMBER_CHAR_NONE = 0;
-  private static final int NUMBER_CHAR_SIGN = 1;
-  private static final int NUMBER_CHAR_DIGIT = 2;
-  private static final int NUMBER_CHAR_DECIMAL = 3;
-  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;
-  private static final int NUMBER_CHAR_EXP_E = 5;
-  private static final int NUMBER_CHAR_EXP_SIGN = 6;
-  private static final int NUMBER_CHAR_EXP_DIGIT = 7;
-
-  /** The input JSON. */
-  private final Reader in;
-
-  /** True to accept non-spec compliant JSON */
-  private boolean lenient = false;
-
-  /**
-   * Use a manual buffer to easily read and unread upcoming characters, and
-   * also so we can create strings without an intermediate StringBuilder.
-   * We decode literals directly out of this buffer, so it must be at least as
-   * long as the longest token that can be reported as a number.
-   */
-  private final char[] buffer = new char[1024];
-  private int pos = 0;
-  private int limit = 0;
-
-  private int lineNumber = 0;
-  private int lineStart = 0;
-
-  int peeked = PEEKED_NONE;
-
-  /**
-   * A peeked value that was composed entirely of digits with an optional
-   * leading dash. Positive values may not have a leading 0.
-   */
-  private long peekedLong;
-
-  /**
-   * The number of characters in a peeked number literal. Increment 'pos' by
-   * this after reading a number.
-   */
-  private int peekedNumberLength;
-
-  /**
-   * A peeked string that should be parsed on the next double, long or string.
-   * This is populated before a numeric value is parsed and used if that parsing
-   * fails.
-   */
-  private String peekedString;
-
-  /*
-   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
-   */
-  private int[] stack = new int[32];
-  private int stackSize = 0;
-  {
-    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
-  }
-
-  /*
-   * The path members. It corresponds directly to stack: At indices where the
-   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
-   * pathNames contains the name at this scope. Where it contains an array
-   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
-   * that array. Otherwise the value is undefined, and we take advantage of that
-   * by incrementing pathIndices when doing so isn't useful.
-   */
-  private String[] pathNames = new String[32];
-  private int[] pathIndices = new int[32];
-
-  /**
-   * Creates a new instance that reads a JSON-encoded stream from {@code in}.
-   */
-  public JsonReader(Reader in) {
-    if (in == null) {
-      throw new NullPointerException("in == null");
-    }
-    this.in = in;
-  }
-
-  /**
-   * Configure this parser to be liberal in what it accepts. By default,
-   * this parser is strict and only accepts JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
-   * parser to lenient causes it to ignore the following syntax errors:
-   *
-   * <ul>
-   *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
-   *       prefix</a>, <code>")]}'\n"</code>.
-   *   <li>Streams that include multiple top-level values. With strict parsing,
-   *       each stream must contain exactly one top-level value.
-   *   <li>Top-level values of any type. With strict parsing, the top-level
-   *       value must be an object or an array.
-   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
-   *       Double#isInfinite() infinities}.
-   *   <li>End of line comments starting with {@code //} or {@code #} and
-   *       ending with a newline character.
-   *   <li>C-style comments starting with {@code /*} and ending with
-   *       {@code *}{@code /}. Such comments may not be nested.
-   *   <li>Names that are unquoted or {@code 'single quoted'}.
-   *   <li>Strings that are unquoted or {@code 'single quoted'}.
-   *   <li>Array elements separated by {@code ;} instead of {@code ,}.
-   *   <li>Unnecessary array separators. These are interpreted as if null
-   *       was the omitted value.
-   *   <li>Names and values separated by {@code =} or {@code =>} instead of
-   *       {@code :}.
-   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
-   * </ul>
-   */
-  public final void setLenient(boolean lenient) {
-    this.lenient = lenient;
-  }
-
-  /**
-   * Returns true if this parser is liberal in what it accepts.
-   */
-  public final boolean isLenient() {
-    return lenient;
-  }
-
-  /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * beginning of a new array.
-   */
-  public void beginArray() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_BEGIN_ARRAY) {
-      push(JsonScope.EMPTY_ARRAY);
-      pathIndices[stackSize - 1] = 0;
-      peeked = PEEKED_NONE;
-    } else {
-      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
-    }
-  }
-
-  /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * end of the current array.
-   */
-  public void endArray() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_END_ARRAY) {
-      stackSize--;
-      pathIndices[stackSize - 1]++;
-      peeked = PEEKED_NONE;
-    } else {
-      throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
-    }
-  }
-
-  /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * beginning of a new object.
-   */
-  public void beginObject() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_BEGIN_OBJECT) {
-      push(JsonScope.EMPTY_OBJECT);
-      peeked = PEEKED_NONE;
-    } else {
-      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
-    }
-  }
-
-  /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * end of the current object.
-   */
-  public void endObject() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_END_OBJECT) {
-      stackSize--;
-      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
-      pathIndices[stackSize - 1]++;
-      peeked = PEEKED_NONE;
-    } else {
-      throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
-    }
-  }
-
-  /**
-   * Returns true if the current array or object has another element.
-   */
-  public boolean hasNext() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
-  }
-
-  /**
-   * Returns the type of the next token without consuming it.
-   */
-  public JsonToken peek() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-
-    switch (p) {
-    case PEEKED_BEGIN_OBJECT:
-      return JsonToken.BEGIN_OBJECT;
-    case PEEKED_END_OBJECT:
-      return JsonToken.END_OBJECT;
-    case PEEKED_BEGIN_ARRAY:
-      return JsonToken.BEGIN_ARRAY;
-    case PEEKED_END_ARRAY:
-      return JsonToken.END_ARRAY;
-    case PEEKED_SINGLE_QUOTED_NAME:
-    case PEEKED_DOUBLE_QUOTED_NAME:
-    case PEEKED_UNQUOTED_NAME:
-      return JsonToken.NAME;
-    case PEEKED_TRUE:
-    case PEEKED_FALSE:
-      return JsonToken.BOOLEAN;
-    case PEEKED_NULL:
-      return JsonToken.NULL;
-    case PEEKED_SINGLE_QUOTED:
-    case PEEKED_DOUBLE_QUOTED:
-    case PEEKED_UNQUOTED:
-    case PEEKED_BUFFERED:
-      return JsonToken.STRING;
-    case PEEKED_LONG:
-    case PEEKED_NUMBER:
-      return JsonToken.NUMBER;
-    case PEEKED_EOF:
-      return JsonToken.END_DOCUMENT;
-    default:
-      throw new AssertionError();
-    }
-  }
-
-  int doPeek() throws IOException {
-    int peekStack = stack[stackSize - 1];
-    if (peekStack == JsonScope.EMPTY_ARRAY) {
-      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
-    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
-      // Look for a comma before the next element.
-      int c = nextNonWhitespace(true);
-      switch (c) {
-      case ']':
-        return peeked = PEEKED_END_ARRAY;
-      case ';':
-        checkLenient(); // fall-through
-      case ',':
-        break;
-      default:
-        throw syntaxError("Unterminated array");
-      }
-    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
-      stack[stackSize - 1] = JsonScope.DANGLING_NAME;
-      // Look for a comma before the next element.
-      if (peekStack == JsonScope.NONEMPTY_OBJECT) {
-        int c = nextNonWhitespace(true);
-        switch (c) {
-        case '}':
-          return peeked = PEEKED_END_OBJECT;
-        case ';':
-          checkLenient(); // fall-through
-        case ',':
-          break;
-        default:
-          throw syntaxError("Unterminated object");
-        }
-      }
-      int c = nextNonWhitespace(true);
-      switch (c) {
-      case '"':
-        return peeked = PEEKED_DOUBLE_QUOTED_NAME;
-      case '\'':
-        checkLenient();
-        return peeked = PEEKED_SINGLE_QUOTED_NAME;
-      case '}':
-        if (peekStack != JsonScope.NONEMPTY_OBJECT) {
-          return peeked = PEEKED_END_OBJECT;
-        } else {
-          throw syntaxError("Expected name");
-        }
-      default:
-        checkLenient();
-        pos--; // Don't consume the first character in an unquoted string.
-        if (isLiteral((char) c)) {
-          return peeked = PEEKED_UNQUOTED_NAME;
-        } else {
-          throw syntaxError("Expected name");
-        }
-      }
-    } else if (peekStack == JsonScope.DANGLING_NAME) {
-      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
-      // Look for a colon before the value.
-      int c = nextNonWhitespace(true);
-      switch (c) {
-      case ':':
-        break;
-      case '=':
-        checkLenient();
-        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
-          pos++;
-        }
-        break;
-      default:
-        throw syntaxError("Expected ':'");
-      }
-    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
-      if (lenient) {
-        consumeNonExecutePrefix();
-      }
-      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
-    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
-      int c = nextNonWhitespace(false);
-      if (c == -1) {
-        return peeked = PEEKED_EOF;
-      } else {
-        checkLenient();
-        pos--;
-      }
-    } else if (peekStack == JsonScope.CLOSED) {
-      throw new IllegalStateException("JsonReader is closed");
-    }
-
-    int c = nextNonWhitespace(true);
-    switch (c) {
-    case ']':
-      if (peekStack == JsonScope.EMPTY_ARRAY) {
-        return peeked = PEEKED_END_ARRAY;
-      }
-      // fall-through to handle ",]"
-    case ';':
-    case ',':
-      // In lenient mode, a 0-length literal in an array means 'null'.
-      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
-        checkLenient();
-        pos--;
-        return peeked = PEEKED_NULL;
-      } else {
-        throw syntaxError("Unexpected value");
-      }
-    case '\'':
-      checkLenient();
-      return peeked = PEEKED_SINGLE_QUOTED;
-    case '"':
-      return peeked = PEEKED_DOUBLE_QUOTED;
-    case '[':
-      return peeked = PEEKED_BEGIN_ARRAY;
-    case '{':
-      return peeked = PEEKED_BEGIN_OBJECT;
-    default:
-      pos--; // Don't consume the first character in a literal value.
-    }
-
-    int result = peekKeyword();
-    if (result != PEEKED_NONE) {
-      return result;
-    }
-
-    result = peekNumber();
-    if (result != PEEKED_NONE) {
-      return result;
-    }
-
-    if (!isLiteral(buffer[pos])) {
-      throw syntaxError("Expected value");
-    }
-
-    checkLenient();
-    return peeked = PEEKED_UNQUOTED;
-  }
-
-  private int peekKeyword() throws IOException {
-    // Figure out which keyword we're matching against by its first character.
-    char c = buffer[pos];
-    String keyword;
-    String keywordUpper;
-    int peeking;
-    if (c == 't' || c == 'T') {
-      keyword = "true";
-      keywordUpper = "TRUE";
-      peeking = PEEKED_TRUE;
-    } else if (c == 'f' || c == 'F') {
-      keyword = "false";
-      keywordUpper = "FALSE";
-      peeking = PEEKED_FALSE;
-    } else if (c == 'n' || c == 'N') {
-      keyword = "null";
-      keywordUpper = "NULL";
-      peeking = PEEKED_NULL;
-    } else {
-      return PEEKED_NONE;
-    }
-
-    // Confirm that chars [1..length) match the keyword.
-    int length = keyword.length();
-    for (int i = 1; i < length; i++) {
-      if (pos + i >= limit && !fillBuffer(i + 1)) {
-        return PEEKED_NONE;
-      }
-      c = buffer[pos + i];
-      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {
-        return PEEKED_NONE;
-      }
-    }
-
-    if ((pos + length < limit || fillBuffer(length + 1))
-        && isLiteral(buffer[pos + length])) {
-      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!
-    }
-
-    // We've found the keyword followed either by EOF or by a non-literal character.
-    pos += length;
-    return peeked = peeking;
-  }
-
-  private int peekNumber() throws IOException {
-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
-    int p = pos;
-    int l = limit;
-
-    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
-    boolean negative = false;
-    boolean fitsInLong = true;
-    int last = NUMBER_CHAR_NONE;
-
-    int i = 0;
-
-    charactersOfNumber:
-    for (; true; i++) {
-      if (p + i == l) {
-        if (i == buffer.length) {
-          // Though this looks like a well-formed number, it's too long to continue reading. Give up
-          // and let the application handle this as an unquoted literal.
-          return PEEKED_NONE;
-        }
-        if (!fillBuffer(i + 1)) {
-          break;
-        }
-        p = pos;
-        l = limit;
-      }
-
-      char c = buffer[p + i];
-      switch (c) {
-      case '-':
-        if (last == NUMBER_CHAR_NONE) {
-          negative = true;
-          last = NUMBER_CHAR_SIGN;
-          continue;
-        } else if (last == NUMBER_CHAR_EXP_E) {
-          last = NUMBER_CHAR_EXP_SIGN;
-          continue;
-        }
-        return PEEKED_NONE;
-
-      case '+':
-        if (last == NUMBER_CHAR_EXP_E) {
-          last = NUMBER_CHAR_EXP_SIGN;
-          continue;
-        }
-        return PEEKED_NONE;
-
-      case 'e':
-      case 'E':
-        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
-          last = NUMBER_CHAR_EXP_E;
-          continue;
-        }
-        return PEEKED_NONE;
-
-      case '.':
-        if (last == NUMBER_CHAR_DIGIT) {
-          last = NUMBER_CHAR_DECIMAL;
-          continue;
-        }
-        return PEEKED_NONE;
-
-      default:
-        if (c < '0' || c > '9') {
-          if (!isLiteral(c)) {
-            break charactersOfNumber;
-          }
-          return PEEKED_NONE;
-        }
-        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
-          value = -(c - '0');
-          last = NUMBER_CHAR_DIGIT;
-        } else if (last == NUMBER_CHAR_DIGIT) {
-          if (value == 0) {
-            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
-          }
-          long newValue = value * 10 - (c - '0');
-          fitsInLong &= value > MIN_INCOMPLETE_INTEGER
-              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
-          value = newValue;
-        } else if (last == NUMBER_CHAR_DECIMAL) {
-          last = NUMBER_CHAR_FRACTION_DIGIT;
-        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
-          last = NUMBER_CHAR_EXP_DIGIT;
-        }
-      }
-    }
-
-    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
-      peekedLong = negative ? value : -value;
-      pos += i;
-      return peeked = PEEKED_LONG;
-    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
-        || last == NUMBER_CHAR_EXP_DIGIT) {
-      peekedNumberLength = i;
-      return peeked = PEEKED_NUMBER;
-    } else {
-      return PEEKED_NONE;
-    }
-  }
-
-  private boolean isLiteral(char c) throws IOException {
-    switch (c) {
-    case '/':
-    case '\\':
-    case ';':
-    case '#':
-    case '=':
-      checkLenient(); // fall-through
-    case '{':
-    case '}':
-    case '[':
-    case ']':
-    case ':':
-    case ',':
-    case ' ':
-    case '\t':
-    case '\f':
-    case '\r':
-    case '\n':
-      return false;
-    default:
-      return true;
-    }
-  }
-
-  /**
-   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
-   * consumes it.
-   *
-   * @throws java.io.IOException if the next token in the stream is not a property
-   *     name.
-   */
-  public String nextName() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    String result;
-    if (p == PEEKED_UNQUOTED_NAME) {
-      result = nextUnquotedValue();
-    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
-      result = nextQuotedValue('\'');
-    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
-      result = nextQuotedValue('"');
-    } else {
-      throw new IllegalStateException("Expected a name but was " + peek() + locationString());
-    }
-    peeked = PEEKED_NONE;
-    pathNames[stackSize - 1] = result;
-    return result;
-  }
-
-  /**
-   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
-   * consuming it. If the next token is a number, this method will return its
-   * string form.
-   *
-   * @throws IllegalStateException if the next token is not a string or if
-   *     this reader is closed.
-   */
-  public String nextString() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    String result;
-    if (p == PEEKED_UNQUOTED) {
-      result = nextUnquotedValue();
-    } else if (p == PEEKED_SINGLE_QUOTED) {
-      result = nextQuotedValue('\'');
-    } else if (p == PEEKED_DOUBLE_QUOTED) {
-      result = nextQuotedValue('"');
-    } else if (p == PEEKED_BUFFERED) {
-      result = peekedString;
-      peekedString = null;
-    } else if (p == PEEKED_LONG) {
-      result = Long.toString(peekedLong);
-    } else if (p == PEEKED_NUMBER) {
-      result = new String(buffer, pos, peekedNumberLength);
-      pos += peekedNumberLength;
-    } else {
-      throw new IllegalStateException("Expected a string but was " + peek() + locationString());
-    }
-    peeked = PEEKED_NONE;
-    pathIndices[stackSize - 1]++;
-    return result;
-  }
-
-  /**
-   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
-   * consuming it.
-   *
-   * @throws IllegalStateException if the next token is not a boolean or if
-   *     this reader is closed.
-   */
-  public boolean nextBoolean() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_TRUE) {
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-      return true;
-    } else if (p == PEEKED_FALSE) {
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-      return false;
-    }
-    throw new IllegalStateException("Expected a boolean but was " + peek() + locationString());
-  }
-
-  /**
-   * Consumes the next token from the JSON stream and asserts that it is a
-   * literal null.
-   *
-   * @throws IllegalStateException if the next token is not null or if this
-   *     reader is closed.
-   */
-  public void nextNull() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-    if (p == PEEKED_NULL) {
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-    } else {
-      throw new IllegalStateException("Expected null but was " + peek() + locationString());
-    }
-  }
-
-  /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as a double using {@link Double#parseDouble(String)}.
-   *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a double, or is non-finite.
-   */
-  public double nextDouble() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-
-    if (p == PEEKED_LONG) {
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-      return (double) peekedLong;
-    }
-
-    if (p == PEEKED_NUMBER) {
-      peekedString = new String(buffer, pos, peekedNumberLength);
-      pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
-    } else if (p == PEEKED_UNQUOTED) {
-      peekedString = nextUnquotedValue();
-    } else if (p != PEEKED_BUFFERED) {
-      throw new IllegalStateException("Expected a double but was " + peek() + locationString());
-    }
-
-    peeked = PEEKED_BUFFERED;
-    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
-    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new MalformedJsonException(
-          "JSON forbids NaN and infinities: " + result + locationString());
-    }
-    peekedString = null;
-    peeked = PEEKED_NONE;
-    pathIndices[stackSize - 1]++;
-    return result;
-  }
-
-  /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as a long. If the next token's numeric value cannot be exactly
-   * represented by a Java {@code long}, this method throws.
-   *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a number, or exactly represented as a long.
-   */
-  public long nextLong() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-
-    if (p == PEEKED_LONG) {
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-      return peekedLong;
-    }
-
-    if (p == PEEKED_NUMBER) {
-      peekedString = new String(buffer, pos, peekedNumberLength);
-      pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
-      if (p == PEEKED_UNQUOTED) {
-        peekedString = nextUnquotedValue();
-      } else {
-        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
-      }
-      try {
-        long result = Long.parseLong(peekedString);
-        peeked = PEEKED_NONE;
-        pathIndices[stackSize - 1]++;
-        return result;
-      } catch (NumberFormatException ignored) {
-        // Fall back to parse as a double below.
-      }
-    } else {
-      throw new IllegalStateException("Expected a long but was " + peek() + locationString());
-    }
-
-    peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
-    long result = (long) asDouble;
-    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new NumberFormatException("Expected a long but was " + peekedString + locationString());
-    }
-    peekedString = null;
-    peeked = PEEKED_NONE;
-    pathIndices[stackSize - 1]++;
-    return result;
-  }
-
-  /**
-   * Returns the string up to but not including {@code quote}, unescaping any
-   * character escape sequences encountered along the way. The opening quote
-   * should have already been read. This consumes the closing quote, but does
-   * not include it in the returned string.
-   *
-   * @param quote either ' or ".
-   * @throws NumberFormatException if any unicode escape sequences are
-   *     malformed.
-   */
-  private String nextQuotedValue(char quote) throws IOException {
-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
-    StringBuilder builder = null;
-    while (true) {
-      int p = pos;
-      int l = limit;
-      /* the index of the first character not yet appended to the builder. */
-      int start = p;
-      while (p < l) {
-        int c = buffer[p++];
-
-        if (c == quote) {
-          pos = p;
-          int len = p - start - 1;
-          if (builder == null) {
-            return new String(buffer, start, len);
-          } else {
-            builder.append(buffer, start, len);
-            return builder.toString();
-          }
-        } else if (c == '\\') {
-          pos = p;
-          int len = p - start - 1;
-          if (builder == null) {
-            int estimatedLength = (len + 1) * 2;
-            builder = new StringBuilder(Math.max(estimatedLength, 16));
-          }
-          builder.append(buffer, start, len);
-          builder.append(readEscapeCharacter());
-          p = pos;
-          l = limit;
-          start = p;
-        } else if (c == '\n') {
-          lineNumber++;
-          lineStart = p;
-        }
-      }
-
-      if (builder == null) {
-        int estimatedLength = (p - start) * 2;
-        builder = new StringBuilder(Math.max(estimatedLength, 16));
-      }
-      builder.append(buffer, start, p - start);
-      pos = p;
-      if (!fillBuffer(1)) {
-        throw syntaxError("Unterminated string");
-      }
-    }
-  }
-
-  /**
-   * Returns an unquoted value as a string.
-   */
-  @SuppressWarnings("fallthrough")
-  private String nextUnquotedValue() throws IOException {
-    StringBuilder builder = null;
-    int i = 0;
-
-    findNonLiteralCharacter:
-    while (true) {
-      for (; pos + i < limit; i++) {
-        switch (buffer[pos + i]) {
-        case '/':
-        case '\\':
-        case ';':
-        case '#':
-        case '=':
-          checkLenient(); // fall-through
-        case '{':
-        case '}':
-        case '[':
-        case ']':
-        case ':':
-        case ',':
-        case ' ':
-        case '\t':
-        case '\f':
-        case '\r':
-        case '\n':
-          break findNonLiteralCharacter;
-        }
-      }
-
-      // Attempt to load the entire literal into the buffer at once.
-      if (i < buffer.length) {
-        if (fillBuffer(i + 1)) {
-          continue;
-        } else {
-          break;
-        }
-      }
-
-      // use a StringBuilder when the value is too long. This is too long to be a number!
-      if (builder == null) {
-        builder = new StringBuilder(Math.max(i,16));
-      }
-      builder.append(buffer, pos, i);
-      pos += i;
-      i = 0;
-      if (!fillBuffer(1)) {
-        break;
-      }
-    }
-   
-    String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
-    pos += i;
-    return result;
-  }
-
-  private void skipQuotedValue(char quote) throws IOException {
-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
-    do {
-      int p = pos;
-      int l = limit;
-      /* the index of the first character not yet appended to the builder. */
-      while (p < l) {
-        int c = buffer[p++];
-        if (c == quote) {
-          pos = p;
-          return;
-        } else if (c == '\\') {
-          pos = p;
-          readEscapeCharacter();
-          p = pos;
-          l = limit;
-        } else if (c == '\n') {
-          lineNumber++;
-          lineStart = p;
-        }
-      }
-      pos = p;
-    } while (fillBuffer(1));
-    throw syntaxError("Unterminated string");
-  }
-
-  private void skipUnquotedValue() throws IOException {
-    do {
-      int i = 0;
-      for (; pos + i < limit; i++) {
-        switch (buffer[pos + i]) {
-        case '/':
-        case '\\':
-        case ';':
-        case '#':
-        case '=':
-          checkLenient(); // fall-through
-        case '{':
-        case '}':
-        case '[':
-        case ']':
-        case ':':
-        case ',':
-        case ' ':
-        case '\t':
-        case '\f':
-        case '\r':
-        case '\n':
-          pos += i;
-          return;
-        }
-      }
-      pos += i;
-    } while (fillBuffer(1));
-  }
-
-  /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as an int. If the next token's numeric value cannot be exactly
-   * represented by a Java {@code int}, this method throws.
-   *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a number, or exactly represented as an int.
-   */
-  public int nextInt() throws IOException {
-    int p = peeked;
-    if (p == PEEKED_NONE) {
-      p = doPeek();
-    }
-
-    int result;
-    if (p == PEEKED_LONG) {
-      result = (int) peekedLong;
-      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new NumberFormatException("Expected an int but was " + peekedLong + locationString());
-      }
-      peeked = PEEKED_NONE;
-      pathIndices[stackSize - 1]++;
-      return result;
-    }
-
-    if (p == PEEKED_NUMBER) {
-      peekedString = new String(buffer, pos, peekedNumberLength);
-      pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
-      if (p == PEEKED_UNQUOTED) {
-        peekedString = nextUnquotedValue();
-      } else {
-        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
-      }
-      try {
-        result = Integer.parseInt(peekedString);
-        peeked = PEEKED_NONE;
-        pathIndices[stackSize - 1]++;
-        return result;
-      } catch (NumberFormatException ignored) {
-        // Fall back to parse as a double below.
-      }
-    } else {
-      throw new IllegalStateException("Expected an int but was " + peek() + locationString());
-    }
-
-    peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
-    result = (int) asDouble;
-    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new NumberFormatException("Expected an int but was " + peekedString + locationString());
-    }
-    peekedString = null;
-    peeked = PEEKED_NONE;
-    pathIndices[stackSize - 1]++;
-    return result;
-  }
-
-  /**
-   * Closes this JSON reader and the underlying {@link java.io.Reader}.
-   */
-  public void close() throws IOException {
-    peeked = PEEKED_NONE;
-    stack[0] = JsonScope.CLOSED;
-    stackSize = 1;
-    in.close();
-  }
-
-  /**
-   * Skips the next value recursively. If it is an object or array, all nested
-   * elements are skipped. This method is intended for use when the JSON token
-   * stream contains unrecognized or unhandled values.
-   */
-  public void skipValue() throws IOException {
-    int count = 0;
-    do {
-      int p = peeked;
-      if (p == PEEKED_NONE) {
-        p = doPeek();
-      }
-
-      if (p == PEEKED_BEGIN_ARRAY) {
-        push(JsonScope.EMPTY_ARRAY);
-        count++;
-      } else if (p == PEEKED_BEGIN_OBJECT) {
-        push(JsonScope.EMPTY_OBJECT);
-        count++;
-      } else if (p == PEEKED_END_ARRAY) {
-        stackSize--;
-        count--;
-      } else if (p == PEEKED_END_OBJECT) {
-        stackSize--;
-        count--;
-      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
-        skipUnquotedValue();
-      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
-        skipQuotedValue('\'');
-      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
-        skipQuotedValue('"');
-      } else if (p == PEEKED_NUMBER) {
-        pos += peekedNumberLength;
-      }
-      peeked = PEEKED_NONE;
-    } while (count != 0);
-
-    pathIndices[stackSize - 1]++;
-    pathNames[stackSize - 1] = "null";
-  }
-
-  private void push(int newTop) {
-    if (stackSize == stack.length) {
-      int newLength = stackSize * 2;
-      stack = Arrays.copyOf(stack, newLength);
-      pathIndices = Arrays.copyOf(pathIndices, newLength);
-      pathNames = Arrays.copyOf(pathNames, newLength);
-    }
-    stack[stackSize++] = newTop;
-  }
-
-  /**
-   * Returns true once {@code limit - pos >= minimum}. If the data is
-   * exhausted before that many characters are available, this returns
-   * false.
-   */
-  private boolean fillBuffer(int minimum) throws IOException {
-    char[] buffer = this.buffer;
-    lineStart -= pos;
-    if (limit != pos) {
-      limit -= pos;
-      System.arraycopy(buffer, pos, buffer, 0, limit);
-    } else {
-      limit = 0;
-    }
-
-    pos = 0;
-    int total;
-    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
-      limit += total;
-
-      // if this is the first read, consume an optional byte order mark (BOM) if it exists
-      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\ufeff') {
-        pos++;
-        lineStart++;
-        minimum++;
-      }
-
-      if (limit >= minimum) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Returns the next character in the stream that is neither whitespace nor a
-   * part of a comment. When this returns, the returned character is always at
-   * {@code buffer[pos-1]}; this means the caller can always push back the
-   * returned character by decrementing {@code pos}.
-   */
-  private int nextNonWhitespace(boolean throwOnEof) throws IOException {
-    /*
-     * This code uses ugly local variables 'p' and 'l' representing the 'pos'
-     * and 'limit' fields respectively. Using locals rather than fields saves
-     * a few field reads for each whitespace character in a pretty-printed
-     * document, resulting in a 5% speedup. We need to flush 'p' to its field
-     * before any (potentially indirect) call to fillBuffer() and reread both
-     * 'p' and 'l' after any (potentially indirect) call to the same method.
-     */
-    char[] buffer = this.buffer;
-    int p = pos;
-    int l = limit;
-    while (true) {
-      if (p == l) {
-        pos = p;
-        if (!fillBuffer(1)) {
-          break;
-        }
-        p = pos;
-        l = limit;
-      }
-
-      int c = buffer[p++];
-      if (c == '\n') {
-        lineNumber++;
-        lineStart = p;
-        continue;
-      } else if (c == ' ' || c == '\r' || c == '\t') {
-        continue;
-      }
-
-      if (c == '/') {
-        pos = p;
-        if (p == l) {
-          pos--; // push back '/' so it's still in the buffer when this method returns
-          boolean charsLoaded = fillBuffer(2);
-          pos++; // consume the '/' again
-          if (!charsLoaded) {
-            return c;
-          }
-        }
-
-        checkLenient();
-        char peek = buffer[pos];
-        switch (peek) {
-        case '*':
-          // skip a /* c-style comment */
-          pos++;
-          if (!skipTo("*/")) {
-            throw syntaxError("Unterminated comment");
-          }
-          p = pos + 2;
-          l = limit;
-          continue;
-
-        case '/':
-          // skip a // end-of-line comment
-          pos++;
-          skipToEndOfLine();
-          p = pos;
-          l = limit;
-          continue;
-
-        default:
-          return c;
-        }
-      } else if (c == '#') {
-        pos = p;
-        /*
-         * Skip a # hash end-of-line comment. The JSON RFC doesn't
-         * specify this behaviour, but it's required to parse
-         * existing documents. See http://b/2571423.
-         */
-        checkLenient();
-        skipToEndOfLine();
-        p = pos;
-        l = limit;
-      } else {
-        pos = p;
-        return c;
-      }
-    }
-    if (throwOnEof) {
-      throw new EOFException("End of input" + locationString());
-    } else {
-      return -1;
-    }
-  }
-
-  private void checkLenient() throws IOException {
-    if (!lenient) {
-      throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
-    }
-  }
-
-  /**
-   * Advances the position until after the next newline character. If the line
-   * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
-   * caller.
-   */
-  private void skipToEndOfLine() throws IOException {
-    while (pos < limit || fillBuffer(1)) {
-      char c = buffer[pos++];
-      if (c == '\n') {
-        lineNumber++;
-        lineStart = pos;
-        break;
-      } else if (c == '\r') {
-        break;
-      }
-    }
-  }
-
-  /**
-   * @param toFind a string to search for. Must not contain a newline.
-   */
-  private boolean skipTo(String toFind) throws IOException {
-    int length = toFind.length();
-    outer:
-    for (; pos + length <= limit || fillBuffer(length); pos++) {
-      if (buffer[pos] == '\n') {
-        lineNumber++;
-        lineStart = pos + 1;
-        continue;
-      }
-      for (int c = 0; c < length; c++) {
-        if (buffer[pos + c] != toFind.charAt(c)) {
-          continue outer;
-        }
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + locationString();
-  }
-
-  String locationString() {
-    int line = lineNumber + 1;
-    int column = pos - lineStart + 1;
-    return " at line " + line + " column " + column + " path " + getPath();
-  }
-
-  /**
-   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
-   * the current location in the JSON value.
-   */
-  public String getPath() {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0, size = stackSize; i < size; i++) {
-      switch (stack[i]) {
-        case JsonScope.EMPTY_ARRAY:
-        case JsonScope.NONEMPTY_ARRAY:
-          result.append('[').append(pathIndices[i]).append(']');
-          break;
-
-        case JsonScope.EMPTY_OBJECT:
-        case JsonScope.DANGLING_NAME:
-        case JsonScope.NONEMPTY_OBJECT:
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-          break;
-
-        case JsonScope.NONEMPTY_DOCUMENT:
-        case JsonScope.EMPTY_DOCUMENT:
-        case JsonScope.CLOSED:
-          break;
-      }
-    }
-    return result.toString();
-  }
-
-  /**
-   * Unescapes the character identified by the character or characters that
-   * immediately follow a backslash. The backslash '\' should have already
-   * been read. This supports both unicode escapes "u000A" and two-character
-   * escapes "\n".
-   *
-   * @throws NumberFormatException if any unicode escape sequences are
-   *     malformed.
-   */
-  private char readEscapeCharacter() throws IOException {
-    if (pos == limit && !fillBuffer(1)) {
-      throw syntaxError("Unterminated escape sequence");
-    }
-
-    char escaped = buffer[pos++];
-    switch (escaped) {
-    case 'u':
-      if (pos + 4 > limit && !fillBuffer(4)) {
-        throw syntaxError("Unterminated escape sequence");
-      }
-      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
-      char result = 0;
-      for (int i = pos, end = i + 4; i < end; i++) {
-        char c = buffer[i];
-        result <<= 4;
-        if (c >= '0' && c <= '9') {
-          result += (c - '0');
-        } else if (c >= 'a' && c <= 'f') {
-          result += (c - 'a' + 10);
-        } else if (c >= 'A' && c <= 'F') {
-          result += (c - 'A' + 10);
-        } else {
-          throw new NumberFormatException("\\u" + new String(buffer, pos, 4));
-        }
-      }
-      pos += 4;
-      return result;
-
-    case 't':
-      return '\t';
-
-    case 'b':
-      return '\b';
-
-    case 'n':
-      return '\n';
-
-    case 'r':
-      return '\r';
-
-    case 'f':
-      return '\f';
-
-    case '\n':
-      lineNumber++;
-      lineStart = pos;
-      // fall-through
-
-    case '\'':
-    case '"':
-    case '\\':
-    case '/':	
-    	return escaped;
-    default:
-    	// throw error when none of the above cases are matched
-    	throw syntaxError("Invalid escape sequence");
-    }
-  }
-
-  /**
-   * Throws a new IO exception with the given message and a context snippet
-   * with this reader's content.
-   */
-  private IOException syntaxError(String message) throws IOException {
-    throw new MalformedJsonException(message + locationString());
-  }
-
-  /**
-   * Consumes the non-execute prefix if it exists.
-   */
-  private void consumeNonExecutePrefix() throws IOException {
-    // fast forward through the leading whitespace
-    nextNonWhitespace(true);
-    pos--;
-
-    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {
-      return;
-    }
-
-    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {
-      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {
-        return; // not a security token!
-      }
-    }
-
-    // we consumed a security token!
-    pos += NON_EXECUTE_PREFIX.length;
-  }
-
-  static {
-    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {
-      @Override public void promoteNameToValue(JsonReader reader) throws IOException {
-        if (reader instanceof JsonTreeReader) {
-          ((JsonTreeReader)reader).promoteNameToValue();
-          return;
-        }
-        int p = reader.peeked;
-        if (p == PEEKED_NONE) {
-          p = reader.doPeek();
-        }
-        if (p == PEEKED_DOUBLE_QUOTED_NAME) {
-          reader.peeked = PEEKED_DOUBLE_QUOTED;
-        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
-          reader.peeked = PEEKED_SINGLE_QUOTED;
-        } else if (p == PEEKED_UNQUOTED_NAME) {
-          reader.peeked = PEEKED_UNQUOTED;
-        } else {
-          throw new IllegalStateException(
-              "Expected a name but was " + reader.peek() + reader.locationString());
-        }
-      }
-    };
-  }
+	private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
+
+	private static final int PEEKED_NONE = 0;
+	private static final int PEEKED_BEGIN_OBJECT = 1;
+	private static final int PEEKED_END_OBJECT = 2;
+	private static final int PEEKED_BEGIN_ARRAY = 3;
+	private static final int PEEKED_END_ARRAY = 4;
+	private static final int PEEKED_TRUE = 5;
+	private static final int PEEKED_FALSE = 6;
+	private static final int PEEKED_NULL = 7;
+	private static final int PEEKED_SINGLE_QUOTED = 8;
+	private static final int PEEKED_DOUBLE_QUOTED = 9;
+	private static final int PEEKED_UNQUOTED = 10;
+	/** When this is returned, the string value is stored in peekedString. */
+	private static final int PEEKED_BUFFERED = 11;
+	private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
+	private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
+	private static final int PEEKED_UNQUOTED_NAME = 14;
+	/** When this is returned, the integer value is stored in peekedLong. */
+	private static final int PEEKED_LONG = 15;
+	private static final int PEEKED_NUMBER = 16;
+	private static final int PEEKED_EOF = 17;
+
+	/* State machine when parsing numbers */
+	private static final int NUMBER_CHAR_NONE = 0;
+	private static final int NUMBER_CHAR_SIGN = 1;
+	private static final int NUMBER_CHAR_DIGIT = 2;
+	private static final int NUMBER_CHAR_DECIMAL = 3;
+	private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;
+	private static final int NUMBER_CHAR_EXP_E = 5;
+	private static final int NUMBER_CHAR_EXP_SIGN = 6;
+	private static final int NUMBER_CHAR_EXP_DIGIT = 7;
+
+	/** The input JSON. */
+	private final Reader in;
+
+	/** True to accept non-spec compliant JSON */
+	private boolean lenient = false;
+
+	/**
+	 * Use a manual buffer to easily read and unread upcoming characters, and
+	 * also so we can create strings without an intermediate StringBuilder.
+	 * We decode literals directly out of this buffer, so it must be at least as
+	 * long as the longest token that can be reported as a number.
+	 */
+	private final char[] buffer = new char[1024];
+	private int pos = 0;
+	private int limit = 0;
+
+	private int lineNumber = 0;
+	private int lineStart = 0;
+
+	int peeked = PEEKED_NONE;
+
+	/**
+	 * A peeked value that was composed entirely of digits with an optional
+	 * leading dash. Positive values may not have a leading 0.
+	 */
+	private long peekedLong;
+
+	/**
+	 * The number of characters in a peeked number literal. Increment 'pos' by
+	 * this after reading a number.
+	 */
+	private int peekedNumberLength;
+
+	/**
+	 * A peeked string that should be parsed on the next double, long or string.
+	 * This is populated before a numeric value is parsed and used if that parsing
+	 * fails.
+	 */
+	private String peekedString;
+
+	/*
+	 * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+	 */
+	private int[] stack = new int[32];
+	private int stackSize = 0;
+	{
+		stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
+	}
+
+	/*
+	 * The path members. It corresponds directly to stack: At indices where the
+	 * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+	 * pathNames contains the name at this scope. Where it contains an array
+	 * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+	 * that array. Otherwise the value is undefined, and we take advantage of that
+	 * by incrementing pathIndices when doing so isn't useful.
+	 */
+	private String[] pathNames = new String[32];
+	private int[] pathIndices = new int[32];
+
+	/**
+	 * Creates a new instance that reads a JSON-encoded stream from {@code in}.
+	 */
+	public JsonReader(Reader in) {
+		if (in == null) {
+			throw new NullPointerException("in == null");
+		}
+		this.in = in;
+	}
+
+	/**
+	 * Configure this parser to be liberal in what it accepts. By default,
+	 * this parser is strict and only accepts JSON as specified by <a
+	 * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
+	 * parser to lenient causes it to ignore the following syntax errors:
+	 *
+	 * <ul>
+	 *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
+	 *       prefix</a>, <code>")]}'\n"</code>.
+	 *   <li>Streams that include multiple top-level values. With strict parsing,
+	 *       each stream must contain exactly one top-level value.
+	 *   <li>Top-level values of any type. With strict parsing, the top-level
+	 *       value must be an object or an array.
+	 *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+	 *       Double#isInfinite() infinities}.
+	 *   <li>End of line comments starting with {@code //} or {@code #} and
+	 *       ending with a newline character.
+	 *   <li>C-style comments starting with {@code /*} and ending with
+	 *       {@code *}{@code /}. Such comments may not be nested.
+	 *   <li>Names that are unquoted or {@code 'single quoted'}.
+	 *   <li>Strings that are unquoted or {@code 'single quoted'}.
+	 *   <li>Array elements separated by {@code ;} instead of {@code ,}.
+	 *   <li>Unnecessary array separators. These are interpreted as if null
+	 *       was the omitted value.
+	 *   <li>Names and values separated by {@code =} or {@code =>} instead of
+	 *       {@code :}.
+	 *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
+	 * </ul>
+	 */
+	public final void setLenient(boolean lenient) {
+		this.lenient = lenient;
+	}
+
+	/**
+	 * Returns true if this parser is liberal in what it accepts.
+	 */
+	public final boolean isLenient() {
+		return lenient;
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * beginning of a new array.
+	 */
+	public void beginArray() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_BEGIN_ARRAY) {
+			push(JsonScope.EMPTY_ARRAY);
+			pathIndices[stackSize - 1] = 0;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * end of the current array.
+	 */
+	public void endArray() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_END_ARRAY) {
+			stackSize--;
+			pathIndices[stackSize - 1]++;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * beginning of a new object.
+	 */
+	public void beginObject() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_BEGIN_OBJECT) {
+			push(JsonScope.EMPTY_OBJECT);
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * end of the current object.
+	 */
+	public void endObject() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_END_OBJECT) {
+			stackSize--;
+			pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+			pathIndices[stackSize - 1]++;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Returns true if the current array or object has another element.
+	 */
+	public boolean hasNext() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
+	}
+
+	/**
+	 * Returns the type of the next token without consuming it.
+	 */
+	public JsonToken peek() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		switch (p) {
+		case PEEKED_BEGIN_OBJECT:
+			return JsonToken.BEGIN_OBJECT;
+		case PEEKED_END_OBJECT:
+			return JsonToken.END_OBJECT;
+		case PEEKED_BEGIN_ARRAY:
+			return JsonToken.BEGIN_ARRAY;
+		case PEEKED_END_ARRAY:
+			return JsonToken.END_ARRAY;
+		case PEEKED_SINGLE_QUOTED_NAME:
+		case PEEKED_DOUBLE_QUOTED_NAME:
+		case PEEKED_UNQUOTED_NAME:
+			return JsonToken.NAME;
+		case PEEKED_TRUE:
+		case PEEKED_FALSE:
+			return JsonToken.BOOLEAN;
+		case PEEKED_NULL:
+			return JsonToken.NULL;
+		case PEEKED_SINGLE_QUOTED:
+		case PEEKED_DOUBLE_QUOTED:
+		case PEEKED_UNQUOTED:
+		case PEEKED_BUFFERED:
+			return JsonToken.STRING;
+		case PEEKED_LONG:
+		case PEEKED_NUMBER:
+			return JsonToken.NUMBER;
+		case PEEKED_EOF:
+			return JsonToken.END_DOCUMENT;
+		default:
+			throw new AssertionError();
+		}
+	}
+
+	int doPeek() throws IOException {
+		int peekStack = stack[stackSize - 1];
+		if (peekStack == JsonScope.EMPTY_ARRAY) {
+			stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
+		} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
+			// Look for a comma before the next element.
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case ']':
+				return peeked = PEEKED_END_ARRAY;
+			case ';':
+				checkLenient(); // fall-through
+			case ',':
+				break;
+			default:
+				throw syntaxError("Unterminated array");
+			}
+		} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
+			stack[stackSize - 1] = JsonScope.DANGLING_NAME;
+			// Look for a comma before the next element.
+			if (peekStack == JsonScope.NONEMPTY_OBJECT) {
+				int c = nextNonWhitespace(true);
+				switch (c) {
+				case '}':
+					return peeked = PEEKED_END_OBJECT;
+				case ';':
+					checkLenient(); // fall-through
+				case ',':
+					break;
+				default:
+					throw syntaxError("Unterminated object");
+				}
+			}
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case '"':
+				return peeked = PEEKED_DOUBLE_QUOTED_NAME;
+			case '\'':
+				checkLenient();
+				return peeked = PEEKED_SINGLE_QUOTED_NAME;
+			case '}':
+				if (peekStack != JsonScope.NONEMPTY_OBJECT) {
+					return peeked = PEEKED_END_OBJECT;
+				} else {
+					throw syntaxError("Expected name");
+				}
+			default:
+				checkLenient();
+				pos--; // Don't consume the first character in an unquoted string.
+				if (isLiteral((char) c)) {
+					return peeked = PEEKED_UNQUOTED_NAME;
+				} else {
+					throw syntaxError("Expected name");
+				}
+			}
+		} else if (peekStack == JsonScope.DANGLING_NAME) {
+			stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
+			// Look for a colon before the value.
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case ':':
+				break;
+			case '=':
+				checkLenient();
+				if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
+					pos++;
+				}
+				break;
+			default:
+				throw syntaxError("Expected ':'");
+			}
+		} else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
+			if (lenient) {
+				consumeNonExecutePrefix();
+			}
+			stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
+		} else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
+			int c = nextNonWhitespace(false);
+			if (c == -1) {
+				return peeked = PEEKED_EOF;
+			} else {
+				checkLenient();
+				pos--;
+			}
+		} else if (peekStack == JsonScope.CLOSED) {
+			throw new IllegalStateException("JsonReader is closed");
+		}
+
+		int c = nextNonWhitespace(true);
+		switch (c) {
+		case ']':
+			if (peekStack == JsonScope.EMPTY_ARRAY) {
+				return peeked = PEEKED_END_ARRAY;
+			}
+			// fall-through to handle ",]"
+		case ';':
+		case ',':
+			// In lenient mode, a 0-length literal in an array means 'null'.
+			if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
+				checkLenient();
+				pos--;
+				return peeked = PEEKED_NULL;
+			} else {
+				throw syntaxError("Unexpected value");
+			}
+		case '\'':
+			checkLenient();
+			return peeked = PEEKED_SINGLE_QUOTED;
+		case '"':
+			return peeked = PEEKED_DOUBLE_QUOTED;
+		case '[':
+			return peeked = PEEKED_BEGIN_ARRAY;
+		case '{':
+			return peeked = PEEKED_BEGIN_OBJECT;
+		default:
+			pos--; // Don't consume the first character in a literal value.
+		}
+
+		int result = peekKeyword();
+		if (result != PEEKED_NONE) {
+			return result;
+		}
+
+		result = peekNumber();
+		if (result != PEEKED_NONE) {
+			return result;
+		}
+
+		if (!isLiteral(buffer[pos])) {
+			throw syntaxError("Expected value");
+		}
+
+		checkLenient();
+		return peeked = PEEKED_UNQUOTED;
+	}
+
+	private int peekKeyword() throws IOException {
+		// Figure out which keyword we're matching against by its first character.
+		char c = buffer[pos];
+		String keyword;
+		String keywordUpper;
+		int peeking;
+		if (c == 't' || c == 'T') {
+			keyword = "true";
+			keywordUpper = "TRUE";
+			peeking = PEEKED_TRUE;
+		} else if (c == 'f' || c == 'F') {
+			keyword = "false";
+			keywordUpper = "FALSE";
+			peeking = PEEKED_FALSE;
+		} else if (c == 'n' || c == 'N') {
+			keyword = "null";
+			keywordUpper = "NULL";
+			peeking = PEEKED_NULL;
+		} else {
+			return PEEKED_NONE;
+		}
+
+		// Confirm that chars [1..length) match the keyword.
+		int length = keyword.length();
+		for (int i = 1; i < length; i++) {
+			if (pos + i >= limit && !fillBuffer(i + 1)) {
+				return PEEKED_NONE;
+			}
+			c = buffer[pos + i];
+			if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {
+				return PEEKED_NONE;
+			}
+		}
+
+		if ((pos + length < limit || fillBuffer(length + 1))
+				&& isLiteral(buffer[pos + length])) {
+			return PEEKED_NONE; // Don't match trues, falsey or nullsoft!
+		}
+
+		// We've found the keyword followed either by EOF or by a non-literal character.
+		pos += length;
+		return peeked = peeking;
+	}
+
+	private int peekNumber() throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		int p = pos;
+		int l = limit;
+
+		long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
+		boolean negative = false;
+		boolean fitsInLong = true;
+		int last = NUMBER_CHAR_NONE;
+
+		int i = 0;
+
+		charactersOfNumber:
+			for (; true; i++) {
+				if (p + i == l) {
+					if (i == buffer.length) {
+						// Though this looks like a well-formed number, it's too long to continue reading. Give up
+						// and let the application handle this as an unquoted literal.
+						return PEEKED_NONE;
+					}
+					if (!fillBuffer(i + 1)) {
+						break;
+					}
+					p = pos;
+					l = limit;
+				}
+
+				char c = buffer[p + i];
+				switch (c) {
+				case '-':
+					if (last == NUMBER_CHAR_NONE) {
+						negative = true;
+						last = NUMBER_CHAR_SIGN;
+						continue;
+					} else if (last == NUMBER_CHAR_EXP_E) {
+						last = NUMBER_CHAR_EXP_SIGN;
+						continue;
+					}
+					return PEEKED_NONE;
+
+				case '+':
+					if (last == NUMBER_CHAR_EXP_E) {
+						last = NUMBER_CHAR_EXP_SIGN;
+						continue;
+					}
+					return PEEKED_NONE;
+
+				case 'e':
+				case 'E':
+					if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
+						last = NUMBER_CHAR_EXP_E;
+						continue;
+					}
+					return PEEKED_NONE;
+
+				case '.':
+					if (last == NUMBER_CHAR_DIGIT) {
+						last = NUMBER_CHAR_DECIMAL;
+						continue;
+					}
+					return PEEKED_NONE;
+
+				default:
+					if (c < '0' || c > '9') {
+						if (!isLiteral(c)) {
+							break charactersOfNumber;
+						}
+						return PEEKED_NONE;
+					}
+					if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
+						value = -(c - '0');
+						last = NUMBER_CHAR_DIGIT;
+					} else if (last == NUMBER_CHAR_DIGIT) {
+						if (value == 0) {
+							return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
+						}
+						long newValue = value * 10 - (c - '0');
+						fitsInLong &= value > MIN_INCOMPLETE_INTEGER
+								|| (value == MIN_INCOMPLETE_INTEGER && newValue < value);
+						value = newValue;
+					} else if (last == NUMBER_CHAR_DECIMAL) {
+						last = NUMBER_CHAR_FRACTION_DIGIT;
+					} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
+						last = NUMBER_CHAR_EXP_DIGIT;
+					}
+				}
+			}
+
+		// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
+		if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
+			peekedLong = negative ? value : -value;
+			pos += i;
+			return peeked = PEEKED_LONG;
+		} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
+				|| last == NUMBER_CHAR_EXP_DIGIT) {
+			peekedNumberLength = i;
+			return peeked = PEEKED_NUMBER;
+		} else {
+			return PEEKED_NONE;
+		}
+	}
+
+	private boolean isLiteral(char c) throws IOException {
+		switch (c) {
+		case '/':
+		case '\\':
+		case ';':
+		case '#':
+		case '=':
+			checkLenient(); // fall-through
+		case '{':
+		case '}':
+		case '[':
+		case ']':
+		case ':':
+		case ',':
+		case ' ':
+		case '\t':
+		case '\f':
+		case '\r':
+		case '\n':
+			return false;
+		default:
+			return true;
+		}
+	}
+
+	/**
+	 * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
+	 * consumes it.
+	 *
+	 * @throws java.io.IOException if the next token in the stream is not a property
+	 *     name.
+	 */
+	public String nextName() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		String result;
+		if (p == PEEKED_UNQUOTED_NAME) {
+			result = nextUnquotedValue();
+		} else if (p == PEEKED_SINGLE_QUOTED_NAME) {
+			result = nextQuotedValue('\'');
+		} else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
+			result = nextQuotedValue('"');
+		} else {
+			throw new IllegalStateException("Expected a name but was " + peek() + locationString());
+		}
+		peeked = PEEKED_NONE;
+		pathNames[stackSize - 1] = result;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
+	 * consuming it. If the next token is a number, this method will return its
+	 * string form.
+	 *
+	 * @throws IllegalStateException if the next token is not a string or if
+	 *     this reader is closed.
+	 */
+	public String nextString() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		String result;
+		if (p == PEEKED_UNQUOTED) {
+			result = nextUnquotedValue();
+		} else if (p == PEEKED_SINGLE_QUOTED) {
+			result = nextQuotedValue('\'');
+		} else if (p == PEEKED_DOUBLE_QUOTED) {
+			result = nextQuotedValue('"');
+		} else if (p == PEEKED_BUFFERED) {
+			result = peekedString;
+			peekedString = null;
+		} else if (p == PEEKED_LONG) {
+			result = Long.toString(peekedLong);
+		} else if (p == PEEKED_NUMBER) {
+			result = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else {
+			throw new IllegalStateException("Expected a string but was " + peek() + locationString());
+		}
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
+	 * consuming it.
+	 *
+	 * @throws IllegalStateException if the next token is not a boolean or if
+	 *     this reader is closed.
+	 */
+	public boolean nextBoolean() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_TRUE) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return true;
+		} else if (p == PEEKED_FALSE) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return false;
+		}
+		throw new IllegalStateException("Expected a boolean but was " + peek() + locationString());
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is a
+	 * literal null.
+	 *
+	 * @throws IllegalStateException if the next token is not null or if this
+	 *     reader is closed.
+	 */
+	public void nextNull() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_NULL) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+		} else {
+			throw new IllegalStateException("Expected null but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as a double using {@link Double#parseDouble(String)}.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a double, or is non-finite.
+	 */
+	public double nextDouble() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		if (p == PEEKED_LONG) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return (double) peekedLong;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+			peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+		} else if (p == PEEKED_UNQUOTED) {
+			peekedString = nextUnquotedValue();
+		} else if (p != PEEKED_BUFFERED) {
+			throw new IllegalStateException("Expected a double but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+			throw new MalformedJsonException(
+					"JSON forbids NaN and infinities: " + result + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as a long. If the next token's numeric value cannot be exactly
+	 * represented by a Java {@code long}, this method throws.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a number, or exactly represented as a long.
+	 */
+	public long nextLong() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		if (p == PEEKED_LONG) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return peekedLong;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+			if (p == PEEKED_UNQUOTED) {
+				peekedString = nextUnquotedValue();
+			} else {
+				peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+			}
+			try {
+				long result = Long.parseLong(peekedString);
+				peeked = PEEKED_NONE;
+				pathIndices[stackSize - 1]++;
+				return result;
+			} catch (NumberFormatException ignored) {
+				// Fall back to parse as a double below.
+			}
+		} else {
+			throw new IllegalStateException("Expected a long but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		long result = (long) asDouble;
+		if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
+			throw new NumberFormatException("Expected a long but was " + peekedString + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the string up to but not including {@code quote}, unescaping any
+	 * character escape sequences encountered along the way. The opening quote
+	 * should have already been read. This consumes the closing quote, but does
+	 * not include it in the returned string.
+	 *
+	 * @param quote either ' or ".
+	 * @throws NumberFormatException if any unicode escape sequences are
+	 *     malformed.
+	 */
+	private String nextQuotedValue(char quote) throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		StringBuilder builder = null;
+		while (true) {
+			int p = pos;
+			int l = limit;
+			/* the index of the first character not yet appended to the builder. */
+			int start = p;
+			while (p < l) {
+				int c = buffer[p++];
+
+				if (c == quote) {
+					pos = p;
+					int len = p - start - 1;
+					if (builder == null) {
+						return new String(buffer, start, len);
+					} else {
+						builder.append(buffer, start, len);
+						return builder.toString();
+					}
+				} else if (c == '\\') {
+					pos = p;
+					int len = p - start - 1;
+					if (builder == null) {
+						int estimatedLength = (len + 1) * 2;
+						builder = new StringBuilder(Math.max(estimatedLength, 16));
+					}
+					builder.append(buffer, start, len);
+					builder.append(readEscapeCharacter());
+					p = pos;
+					l = limit;
+					start = p;
+				} else if (c == '\n') {
+					lineNumber++;
+					lineStart = p;
+				}
+			}
+
+			if (builder == null) {
+				int estimatedLength = (p - start) * 2;
+				builder = new StringBuilder(Math.max(estimatedLength, 16));
+			}
+			builder.append(buffer, start, p - start);
+			pos = p;
+			if (!fillBuffer(1)) {
+				throw syntaxError("Unterminated string");
+			}
+		}
+	}
+
+	/**
+	 * Returns an unquoted value as a string.
+	 */
+	@SuppressWarnings("fallthrough")
+	private String nextUnquotedValue() throws IOException {
+		StringBuilder builder = null;
+		int i = 0;
+
+		findNonLiteralCharacter:
+			while (true) {
+				for (; pos + i < limit; i++) {
+					switch (buffer[pos + i]) {
+					case '/':
+					case '\\':
+					case ';':
+					case '#':
+					case '=':
+						checkLenient(); // fall-through
+					case '{':
+					case '}':
+					case '[':
+					case ']':
+					case ':':
+					case ',':
+					case ' ':
+					case '\t':
+					case '\f':
+					case '\r':
+					case '\n':
+						break findNonLiteralCharacter;
+					}
+				}
+
+				// Attempt to load the entire literal into the buffer at once.
+				if (i < buffer.length) {
+					if (fillBuffer(i + 1)) {
+						continue;
+					} else {
+						break;
+					}
+				}
+
+				// use a StringBuilder when the value is too long. This is too long to be a number!
+				if (builder == null) {
+					builder = new StringBuilder(Math.max(i,16));
+				}
+				builder.append(buffer, pos, i);
+				pos += i;
+				i = 0;
+				if (!fillBuffer(1)) {
+					break;
+				}
+			}
+
+		String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
+		pos += i;
+		return result;
+	}
+
+	private void skipQuotedValue(char quote) throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		do {
+			int p = pos;
+			int l = limit;
+			/* the index of the first character not yet appended to the builder. */
+			while (p < l) {
+				int c = buffer[p++];
+				if (c == quote) {
+					pos = p;
+					return;
+				} else if (c == '\\') {
+					pos = p;
+					readEscapeCharacter();
+					p = pos;
+					l = limit;
+				} else if (c == '\n') {
+					lineNumber++;
+					lineStart = p;
+				}
+			}
+			pos = p;
+		} while (fillBuffer(1));
+		throw syntaxError("Unterminated string");
+	}
+
+	private void skipUnquotedValue() throws IOException {
+		do {
+			int i = 0;
+			for (; pos + i < limit; i++) {
+				switch (buffer[pos + i]) {
+				case '/':
+				case '\\':
+				case ';':
+				case '#':
+				case '=':
+					checkLenient(); // fall-through
+				case '{':
+				case '}':
+				case '[':
+				case ']':
+				case ':':
+				case ',':
+				case ' ':
+				case '\t':
+				case '\f':
+				case '\r':
+				case '\n':
+					pos += i;
+					return;
+				}
+			}
+			pos += i;
+		} while (fillBuffer(1));
+	}
+
+	/**
+	 * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as an int. If the next token's numeric value cannot be exactly
+	 * represented by a Java {@code int}, this method throws.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a number, or exactly represented as an int.
+	 */
+	public int nextInt() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		int result;
+		if (p == PEEKED_LONG) {
+			result = (int) peekedLong;
+			if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
+				throw new NumberFormatException("Expected an int but was " + peekedLong + locationString());
+			}
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return result;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+			if (p == PEEKED_UNQUOTED) {
+				peekedString = nextUnquotedValue();
+			} else {
+				peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+			}
+			try {
+				result = Integer.parseInt(peekedString);
+				peeked = PEEKED_NONE;
+				pathIndices[stackSize - 1]++;
+				return result;
+			} catch (NumberFormatException ignored) {
+				// Fall back to parse as a double below.
+			}
+		} else {
+			throw new IllegalStateException("Expected an int but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		result = (int) asDouble;
+		if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
+			throw new NumberFormatException("Expected an int but was " + peekedString + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Closes this JSON reader and the underlying {@link java.io.Reader}.
+	 */
+	@Override
+	public void close() throws IOException {
+		peeked = PEEKED_NONE;
+		stack[0] = JsonScope.CLOSED;
+		stackSize = 1;
+		in.close();
+	}
+
+	/**
+	 * Skips the next value recursively. If it is an object or array, all nested
+	 * elements are skipped. This method is intended for use when the JSON token
+	 * stream contains unrecognized or unhandled values.
+	 */
+	public void skipValue() throws IOException {
+		int count = 0;
+		do {
+			int p = peeked;
+			if (p == PEEKED_NONE) {
+				p = doPeek();
+			}
+
+			if (p == PEEKED_BEGIN_ARRAY) {
+				push(JsonScope.EMPTY_ARRAY);
+				count++;
+			} else if (p == PEEKED_BEGIN_OBJECT) {
+				push(JsonScope.EMPTY_OBJECT);
+				count++;
+			} else if (p == PEEKED_END_ARRAY) {
+				stackSize--;
+				count--;
+			} else if (p == PEEKED_END_OBJECT) {
+				stackSize--;
+				count--;
+			} else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
+				skipUnquotedValue();
+			} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
+				skipQuotedValue('\'');
+			} else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
+				skipQuotedValue('"');
+			} else if (p == PEEKED_NUMBER) {
+				pos += peekedNumberLength;
+			}
+			peeked = PEEKED_NONE;
+		} while (count != 0);
+
+		pathIndices[stackSize - 1]++;
+		pathNames[stackSize - 1] = "null";
+	}
+
+	private void push(int newTop) {
+		if (stackSize == stack.length) {
+			int newLength = stackSize * 2;
+			stack = Arrays.copyOf(stack, newLength);
+			pathIndices = Arrays.copyOf(pathIndices, newLength);
+			pathNames = Arrays.copyOf(pathNames, newLength);
+		}
+		stack[stackSize++] = newTop;
+	}
+
+	/**
+	 * Returns true once {@code limit - pos >= minimum}. If the data is
+	 * exhausted before that many characters are available, this returns
+	 * false.
+	 */
+	private boolean fillBuffer(int minimum) throws IOException {
+		char[] buffer = this.buffer;
+		lineStart -= pos;
+		if (limit != pos) {
+			limit -= pos;
+			System.arraycopy(buffer, pos, buffer, 0, limit);
+		} else {
+			limit = 0;
+		}
+
+		pos = 0;
+		int total;
+		while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
+			limit += total;
+
+			// if this is the first read, consume an optional byte order mark (BOM) if it exists
+			if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\ufeff') {
+				pos++;
+				lineStart++;
+				minimum++;
+			}
+
+			if (limit >= minimum) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns the next character in the stream that is neither whitespace nor a
+	 * part of a comment. When this returns, the returned character is always at
+	 * {@code buffer[pos-1]}; this means the caller can always push back the
+	 * returned character by decrementing {@code pos}.
+	 */
+	private int nextNonWhitespace(boolean throwOnEof) throws IOException {
+		/*
+		 * This code uses ugly local variables 'p' and 'l' representing the 'pos'
+		 * and 'limit' fields respectively. Using locals rather than fields saves
+		 * a few field reads for each whitespace character in a pretty-printed
+		 * document, resulting in a 5% speedup. We need to flush 'p' to its field
+		 * before any (potentially indirect) call to fillBuffer() and reread both
+		 * 'p' and 'l' after any (potentially indirect) call to the same method.
+		 */
+		char[] buffer = this.buffer;
+		int p = pos;
+		int l = limit;
+		while (true) {
+			if (p == l) {
+				pos = p;
+				if (!fillBuffer(1)) {
+					break;
+				}
+				p = pos;
+				l = limit;
+			}
+
+			int c = buffer[p++];
+			if (c == '\n') {
+				lineNumber++;
+				lineStart = p;
+				continue;
+			} else if (c == ' ' || c == '\r' || c == '\t') {
+				continue;
+			}
+
+			if (c == '/') {
+				pos = p;
+				if (p == l) {
+					pos--; // push back '/' so it's still in the buffer when this method returns
+					boolean charsLoaded = fillBuffer(2);
+					pos++; // consume the '/' again
+					if (!charsLoaded) {
+						return c;
+					}
+				}
+
+				checkLenient();
+				char peek = buffer[pos];
+				switch (peek) {
+				case '*':
+					// skip a /* c-style comment */
+					pos++;
+					if (!skipTo("*/")) {
+						throw syntaxError("Unterminated comment");
+					}
+					p = pos + 2;
+					l = limit;
+					continue;
+
+				case '/':
+					// skip a // end-of-line comment
+					pos++;
+					skipToEndOfLine();
+					p = pos;
+					l = limit;
+					continue;
+
+				default:
+					return c;
+				}
+			} else if (c == '#') {
+				pos = p;
+				/*
+				 * Skip a # hash end-of-line comment. The JSON RFC doesn't
+				 * specify this behaviour, but it's required to parse
+				 * existing documents. See http://b/2571423.
+				 */
+				checkLenient();
+				skipToEndOfLine();
+				p = pos;
+				l = limit;
+			} else {
+				pos = p;
+				return c;
+			}
+		}
+		if (throwOnEof) {
+			throw new EOFException("End of input" + locationString());
+		} else {
+			return -1;
+		}
+	}
+
+	private void checkLenient() throws IOException {
+		if (!lenient) {
+			throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
+		}
+	}
+
+	/**
+	 * Advances the position until after the next newline character. If the line
+	 * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+	 * caller.
+	 */
+	private void skipToEndOfLine() throws IOException {
+		while (pos < limit || fillBuffer(1)) {
+			char c = buffer[pos++];
+			if (c == '\n') {
+				lineNumber++;
+				lineStart = pos;
+				break;
+			} else if (c == '\r') {
+				break;
+			}
+		}
+	}
+
+	/**
+	 * @param toFind a string to search for. Must not contain a newline.
+	 */
+	private boolean skipTo(String toFind) throws IOException {
+		int length = toFind.length();
+		outer:
+			for (; pos + length <= limit || fillBuffer(length); pos++) {
+				if (buffer[pos] == '\n') {
+					lineNumber++;
+					lineStart = pos + 1;
+					continue;
+				}
+				for (int c = 0; c < length; c++) {
+					if (buffer[pos + c] != toFind.charAt(c)) {
+						continue outer;
+					}
+				}
+				return true;
+			}
+		return false;
+	}
+
+	@Override public String toString() {
+		return getClass().getSimpleName() + locationString();
+	}
+
+	String locationString() {
+		int line = lineNumber + 1;
+		int column = pos - lineStart + 1;
+		return " at line " + line + " column " + column + " path " + getPath();
+	}
+
+	/**
+	 * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
+	 * the current location in the JSON value.
+	 */
+	public String getPath() {
+		StringBuilder result = new StringBuilder().append('$');
+		for (int i = 0, size = stackSize; i < size; i++) {
+			switch (stack[i]) {
+			case JsonScope.EMPTY_ARRAY:
+			case JsonScope.NONEMPTY_ARRAY:
+				result.append('[').append(pathIndices[i]).append(']');
+				break;
+
+			case JsonScope.EMPTY_OBJECT:
+			case JsonScope.DANGLING_NAME:
+			case JsonScope.NONEMPTY_OBJECT:
+				result.append('.');
+				if (pathNames[i] != null) {
+					result.append(pathNames[i]);
+				}
+				break;
+
+			case JsonScope.NONEMPTY_DOCUMENT:
+			case JsonScope.EMPTY_DOCUMENT:
+			case JsonScope.CLOSED:
+				break;
+			}
+		}
+		return result.toString();
+	}
+
+	/**
+	 * Unescapes the character identified by the character or characters that
+	 * immediately follow a backslash. The backslash '\' should have already
+	 * been read. This supports both unicode escapes "u000A" and two-character
+	 * escapes "\n".
+	 *
+	 * @throws NumberFormatException if any unicode escape sequences are
+	 *     malformed.
+	 */
+	private char readEscapeCharacter() throws IOException {
+		if (pos == limit && !fillBuffer(1)) {
+			throw syntaxError("Unterminated escape sequence");
+		}
+
+		char escaped = buffer[pos++];
+		switch (escaped) {
+		case 'u':
+			if (pos + 4 > limit && !fillBuffer(4)) {
+				throw syntaxError("Unterminated escape sequence");
+			}
+			// Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
+			char result = 0;
+			for (int i = pos, end = i + 4; i < end; i++) {
+				char c = buffer[i];
+				result <<= 4;
+				if (c >= '0' && c <= '9') {
+					result += (c - '0');
+				} else if (c >= 'a' && c <= 'f') {
+					result += (c - 'a' + 10);
+				} else if (c >= 'A' && c <= 'F') {
+					result += (c - 'A' + 10);
+				} else {
+					throw new NumberFormatException("\\u" + new String(buffer, pos, 4));
+				}
+			}
+			pos += 4;
+			return result;
+
+		case 't':
+			return '\t';
+
+		case 'b':
+			return '\b';
+
+		case 'n':
+			return '\n';
+
+		case 'r':
+			return '\r';
+
+		case 'f':
+			return '\f';
+
+		case '\n':
+			lineNumber++;
+			lineStart = pos;
+			// fall-through
+
+		case '\'':
+		case '"':
+		case '\\':
+		case '/':	
+			return escaped;
+		default:
+			// throw error when none of the above cases are matched
+			throw syntaxError("Invalid escape sequence");
+		}
+	}
+
+	/**
+	 * Throws a new IO exception with the given message and a context snippet
+	 * with this reader's content.
+	 */
+	private IOException syntaxError(String message) throws IOException {
+		throw new MalformedJsonException(message + locationString());
+	}
+
+	/**
+	 * Consumes the non-execute prefix if it exists.
+	 */
+	private void consumeNonExecutePrefix() throws IOException {
+		// fast forward through the leading whitespace
+		nextNonWhitespace(true);
+		
+		var p = --pos;
+		if (p + 5 > limit && !fillBuffer(5)) {
+			return;
+		}
+
+		var buf = buffer;
+		if(buf[p] != ')' || buf[p + 1] != ']' || buf[p + 2] != '}' || buf[p + 3] != '\'' || buf[p + 4] != '\n') {
+			return; // not a security token!
+		}
+
+		// we consumed a security token!
+		pos += 5;
+	}
+
+	static {
+		JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {
+			@Override public void promoteNameToValue(JsonReader reader) throws IOException {
+				if (reader instanceof JsonTreeReader) {
+					((JsonTreeReader)reader).promoteNameToValue();
+					return;
+				}
+				int p = reader.peeked;
+				if (p == PEEKED_NONE) {
+					p = reader.doPeek();
+				}
+				if (p == PEEKED_DOUBLE_QUOTED_NAME) {
+					reader.peeked = PEEKED_DOUBLE_QUOTED;
+				} else if (p == PEEKED_SINGLE_QUOTED_NAME) {
+					reader.peeked = PEEKED_SINGLE_QUOTED;
+				} else if (p == PEEKED_UNQUOTED_NAME) {
+					reader.peeked = PEEKED_UNQUOTED;
+				} else {
+					throw new IllegalStateException(
+							"Expected a name but was " + reader.peek() + reader.locationString());
+				}
+			}
+		};
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index 597bd569a..f365951a8 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -182,8 +182,6 @@
    */
   private String separator = ":";
 
-  private boolean lenient;
-
   private boolean htmlSafe;
 
   private String deferredName;
@@ -220,29 +218,6 @@ public final void setIndent(String indent) {
     }
   }
 
-  /**
-   * Configure this writer to relax its syntax rules. By default, this writer
-   * only emits well-formed JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
-   * to lenient permits the following:
-   * <ul>
-   *   <li>Top-level values of any type. With strict writing, the top-level
-   *       value must be an object or an array.
-   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
-   *       Double#isInfinite() infinities}.
-   * </ul>
-   */
-  public final void setLenient(boolean lenient) {
-    this.lenient = lenient;
-  }
-
-  /**
-   * Returns true if this writer has relaxed syntax rules.
-   */
-  public boolean isLenient() {
-    return lenient;
-  }
-
   /**
    * Configure this writer to emit JSON that's safe for direct inclusion in HTML
    * and XML documents. This escapes the HTML characters {@code <}, {@code >},
@@ -491,7 +466,7 @@ public JsonWriter value(Boolean value) throws IOException {
    */
   public JsonWriter value(double value) throws IOException {
     writeDeferredName();
-    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
+    if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     beforeValue();
@@ -525,8 +500,7 @@ public JsonWriter value(Number value) throws IOException {
 
     writeDeferredName();
     String string = value.toString();
-    if (!lenient
-        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
+    if (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN")) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     beforeValue();
@@ -627,10 +601,8 @@ private void beforeName() throws IOException {
   private void beforeValue() throws IOException {
     switch (peek()) {
     case NONEMPTY_DOCUMENT:
-      if (!lenient) {
         throw new IllegalStateException(
             "JSON must have only one top-level value.");
-      }
       // fall-through
     case EMPTY_DOCUMENT: // first in document
       replaceTop(NONEMPTY_DOCUMENT);
diff --git a/gson/src/test/java/com/google/gson/MixedStreamTest.java b/gson/src/test/java/com/google/gson/MixedStreamTest.java
index 1552aeec6..96f1067b4 100644
--- a/gson/src/test/java/com/google/gson/MixedStreamTest.java
+++ b/gson/src/test/java/com/google/gson/MixedStreamTest.java
@@ -94,16 +94,12 @@ public void testWriteDoesNotMutateState() throws IOException {
     jsonWriter.beginArray();
 
     jsonWriter.setHtmlSafe(true);
-    jsonWriter.setLenient(true);
     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);
     assertTrue(jsonWriter.isHtmlSafe());
-    assertTrue(jsonWriter.isLenient());
 
     jsonWriter.setHtmlSafe(false);
-    jsonWriter.setLenient(false);
     gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);
     assertFalse(jsonWriter.isHtmlSafe());
-    assertFalse(jsonWriter.isLenient());
   }
 
   public void testReadInvalidState() throws IOException {
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
index e07014d3f..9d36eb360 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
@@ -72,7 +72,6 @@ public void testNestedObject() throws IOException {
 
   public void testWriteAfterClose() throws Exception {
     JsonTreeWriter writer = new JsonTreeWriter();
-    writer.setLenient(true);
     writer.beginArray();
     writer.value("A");
     writer.endArray();
@@ -86,7 +85,6 @@ public void testWriteAfterClose() throws Exception {
 
   public void testPrematureClose() throws Exception {
     JsonTreeWriter writer = new JsonTreeWriter();
-    writer.setLenient(true);
     writer.beginArray();
     try {
       writer.close();
@@ -120,20 +118,8 @@ public void testEmptyWriter() {
     assertEquals(JsonNull.INSTANCE, writer.get());
   }
 
-  public void testLenientNansAndInfinities() throws IOException {
-    JsonTreeWriter writer = new JsonTreeWriter();
-    writer.setLenient(true);
-    writer.beginArray();
-    writer.value(Double.NaN);
-    writer.value(Double.NEGATIVE_INFINITY);
-    writer.value(Double.POSITIVE_INFINITY);
-    writer.endArray();
-    assertEquals("[NaN,-Infinity,Infinity]", writer.get().toString());
-  }
-
   public void testStrictNansAndInfinities() throws IOException {
     JsonTreeWriter writer = new JsonTreeWriter();
-    writer.setLenient(false);
     writer.beginArray();
     try {
       writer.value(Double.NaN);
@@ -154,7 +140,6 @@ public void testStrictNansAndInfinities() throws IOException {
 
   public void testStrictBoxedNansAndInfinities() throws IOException {
     JsonTreeWriter writer = new JsonTreeWriter();
-    writer.setLenient(false);
     writer.beginArray();
     try {
       writer.value(new Double(Double.NaN));
diff --git a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
index 2bcec173c..256033c19 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
@@ -214,30 +214,6 @@ public void testNonFiniteBoxedDoubles() throws IOException {
     }
   }
 
-  public void testNonFiniteDoublesWhenLenient() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
-    jsonWriter.setLenient(true);
-    jsonWriter.beginArray();
-    jsonWriter.value(Double.NaN);
-    jsonWriter.value(Double.NEGATIVE_INFINITY);
-    jsonWriter.value(Double.POSITIVE_INFINITY);
-    jsonWriter.endArray();
-    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
-  }
-
-  public void testNonFiniteBoxedDoublesWhenLenient() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(stringWriter);
-    jsonWriter.setLenient(true);
-    jsonWriter.beginArray();
-    jsonWriter.value(Double.valueOf(Double.NaN));
-    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));
-    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));
-    jsonWriter.endArray();
-    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
-  }
-
   public void testDoubles() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
@@ -546,18 +522,6 @@ public void testPrettyPrintArray() throws IOException {
     assertEquals(expected, stringWriter.toString());
   }
 
-  public void testLenientWriterPermitsMultipleTopLevelValues() throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
-    writer.setLenient(true);
-    writer.beginArray();
-    writer.endArray();
-    writer.beginArray();
-    writer.endArray();
-    writer.close();
-    assertEquals("[][]", stringWriter.toString());
-  }
-
   public void testStrictWriterDoesNotPermitMultipleTopLevelValues() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter writer = new JsonWriter(stringWriter);
