diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/gson/FieldNamingStrategies.java
similarity index 84%
rename from gson/src/main/java/com/google/gson/FieldNamingStrategy.java
rename to gson/src/main/java/com/google/gson/FieldNamingStrategies.java
index 06b3a6a01..155a2a410 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategies.java
@@ -18,6 +18,7 @@
 
 import java.lang.reflect.Field;
 import java.util.*;
+import java.util.function.*;
 
 /**
  * A mechanism for providing custom field naming in Gson. This allows the client code to translate
@@ -28,22 +29,18 @@
  * @author Joel Leitch
  * @since 1.3
  */
-public interface FieldNamingStrategy {
-
-	/**
-	 * Translates the field name into its JSON field name representation.
-	 *
-	 * @param f the field object that we are translating
-	 * @return the translated field name.
-	 * @since 1.3
-	 */
-	String translateName(Field f);
+public final class FieldNamingStrategies {
+	private FieldNamingStrategies() {}
 
 	/**
 	 * Using this naming policy with Gson will ensure that the field name is
 	 * unchanged.
 	 */
-	public static final FieldNamingStrategy IDENTITY = Field::getName;
+	public static final Function<Field, String> IDENTITY = Field::getName;
+	
+	public static final Function<Field, String> UPPER_CASE = f -> f.getName().toUpperCase();
+	
+	public static final Function<Field, String> LOWER_CASE = f -> f.getName().toLowerCase();
 
 	/**
 	 * Using this naming policy with Gson will ensure that the first "letter" of the Java
@@ -55,7 +52,7 @@
 	 *   <li>_someFieldName ---> _SomeFieldName</li>
 	 * </ul>
 	 */
-	public static final FieldNamingStrategy UPPER_CAMEL_CASE = f -> upperCaseFirstLetter(f.getName());
+	public static final Function<Field, String> UPPER_CAMEL_CASE = f -> upperCaseFirstLetter(f.getName());
 
 	/**
 	 * Using this naming policy with Gson will ensure that the first "letter" of the Java
@@ -70,7 +67,7 @@
 	 *
 	 * @since 1.4
 	 */
-	public static final FieldNamingStrategy UPPER_CAMEL_CASE_WITH_SPACES = f -> upperCaseFirstLetter(separateCamelCase(f.getName(), " "));
+	public static final Function<Field, String> UPPER_CAMEL_CASE_WITH_SPACES = f -> upperCaseFirstLetter(separateCamelCase(f.getName(), " "));
 
 	/**
 	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
@@ -84,7 +81,7 @@
 	 *   <li>aURL ---> a_u_r_l</li>
 	 * </ul>
 	 */
-	public static final FieldNamingStrategy LOWER_CASE_WITH_UNDERSCORES = f -> separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
+	public static final Function<Field, String> LOWER_CASE_WITH_UNDERSCORES = f -> separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
 
 	/**
 	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
@@ -103,7 +100,7 @@
 	 * {@code myobject.my-field} will result in an unintended javascript expression.
 	 * @since 1.4
 	 */
-	public static final FieldNamingStrategy LOWER_CASE_WITH_DASHES = f -> separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
+	public static final Function<Field, String> LOWER_CASE_WITH_DASHES = f -> separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
 
 	/**
 	 * Using this naming policy with Gson will modify the Java Field name from its camel cased
@@ -122,7 +119,7 @@
 	 * {@code myobject.my.field} will result in an unintended javascript expression.
 	 * @since 2.8
 	 */
-	public static final FieldNamingStrategy LOWER_CASE_WITH_DOTS = f -> separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
+	public static final Function<Field, String> LOWER_CASE_WITH_DOTS = f -> separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
 
 	/**
 	 * Converts the field name that uses camel-case define word separation into
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index a4a04ad68..5208e2c32 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -26,6 +26,7 @@
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
+import java.util.function.*;
 
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
@@ -96,7 +97,7 @@
 	final List<TypeAdapterFactory> factories;
 
 	final Excluder excluder;
-	final FieldNamingStrategy fieldNamingStrategy;
+	final Function<Field, String> fieldNamingStrategy;
 	final Map<Type, InstanceCreator<?>> instanceCreators;
 	final boolean serializeNulls;
 	final boolean complexMapKeySerialization;
@@ -106,7 +107,7 @@
 	final List<TypeAdapterFactory> builderFactories;
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
-	Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
+	Gson(Excluder excluder, Function<Field, String> fieldNamingStrategy,
 			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
 			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
 			boolean prettyPrinting,
@@ -272,7 +273,7 @@ public Excluder excluder() {
 		return excluder;
 	}
 
-	public FieldNamingStrategy fieldNamingStrategy() {
+	public Function<Field, String> fieldNamingStrategy() {
 		return fieldNamingStrategy;
 	}
 
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 22c229794..e22fa05a7 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -26,6 +26,7 @@
 import java.text.*;
 import java.util.*;
 import java.util.Date;
+import java.util.function.*;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -63,7 +64,7 @@
  */
 public final class GsonBuilder {
   private Excluder excluder = Excluder.DEFAULT;
-  private FieldNamingStrategy fieldNamingPolicy = FieldNamingStrategy.IDENTITY;
+  private Function<Field, String> fieldNamingPolicy = FieldNamingStrategies.IDENTITY;
   private final Map<Type, InstanceCreator<?>> instanceCreators
       = new HashMap<>();
   private final List<TypeAdapterFactory> factories = new ArrayList<>();
@@ -267,7 +268,7 @@ public GsonBuilder disableInnerClassSerialization() {
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.3
    */
-  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {
+  public GsonBuilder setFieldNamingStrategy(Function<Field, String> fieldNamingStrategy) {
     this.fieldNamingPolicy = fieldNamingStrategy;
     return this;
   }
diff --git a/gson/src/main/java/com/google/gson/JsonDeserializer.java b/gson/src/main/java/com/google/gson/JsonDeserializer.java
index a5208c1dc..7e410f232 100644
--- a/gson/src/main/java/com/google/gson/JsonDeserializer.java
+++ b/gson/src/main/java/com/google/gson/JsonDeserializer.java
@@ -72,20 +72,19 @@
  */
 public interface JsonDeserializer<T> {
 
-  /**
-   * Gson invokes this call-back method during deserialization when it encounters a field of the
-   * specified type.
-   * <p>In the implementation of this call-back method, you should consider invoking
-   * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects
-   * for any non-trivial field of the returned object. However, you should never invoke it on the
-   * the same type passing {@code json} since that will cause an infinite loop (Gson will call your
-   * call-back method again).
-   *
-   * @param json The Json data being deserialized
-   * @param typeOfT The type of the Object to deserialize to
-   * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}
-   * @throws JsonParseException if json is not in the expected format of {@code typeofT}
-   */
-  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
-      throws JsonParseException;
+	/**
+	 * Gson invokes this call-back method during deserialization when it encounters a field of the
+	 * specified type.
+	 * <p>In the implementation of this call-back method, you should consider invoking
+	 * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects
+	 * for any non-trivial field of the returned object. However, you should never invoke it on the
+	 * the same type passing {@code json} since that will cause an infinite loop (Gson will call your
+	 * call-back method again).
+	 *
+	 * @param json The Json data being deserialized
+	 * @param typeOfT The type of the Object to deserialize to
+	 * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}
+	 * @throws JsonParseException if json is not in the expected format of {@code typeofT}
+	 */
+	public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException;
 }
diff --git a/gson/src/main/java/com/google/gson/JsonSerializer.java b/gson/src/main/java/com/google/gson/JsonSerializer.java
index 5d28ff33a..4dcc32879 100644
--- a/gson/src/main/java/com/google/gson/JsonSerializer.java
+++ b/gson/src/main/java/com/google/gson/JsonSerializer.java
@@ -71,19 +71,19 @@
  */
 public interface JsonSerializer<T> {
 
-  /**
-   * Gson invokes this call-back method during serialization when it encounters a field of the
-   * specified type.
-   *
-   * <p>In the implementation of this call-back method, you should consider invoking
-   * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any
-   * non-trivial field of the {@code src} object. However, you should never invoke it on the
-   * {@code src} object itself since that will cause an infinite loop (Gson will call your
-   * call-back method again).</p>
-   *
-   * @param src the object that needs to be converted to Json.
-   * @param typeOfSrc the actual type (fully genericized version) of the source object.
-   * @return a JsonElement corresponding to the specified object.
-   */
-  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);
-}
+	/**
+	 * Gson invokes this call-back method during serialization when it encounters a field of the
+	 * specified type.
+	 *
+	 * <p>In the implementation of this call-back method, you should consider invoking
+	 * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any
+	 * non-trivial field of the {@code src} object. However, you should never invoke it on the
+	 * {@code src} object itself since that will cause an infinite loop (Gson will call your
+	 * call-back method again).</p>
+	 *
+	 * @param src the object that needs to be converted to Json.
+	 * @param typeOfSrc the actual type (fully genericized version) of the source object.
+	 * @return a JsonElement corresponding to the specified object.
+	 */
+	public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index 245389aca..66e230572 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -38,212 +38,209 @@
  * @author Jesse Wilson
  */
 public final class Excluder implements TypeAdapterFactory, Cloneable {
-  private static final double IGNORE_VERSIONS = -1.0d;
-  public static final Excluder DEFAULT = new Excluder();
-
-  private double version = IGNORE_VERSIONS;
-  private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;
-  private boolean serializeInnerClasses = true;
-  private boolean requireExpose;
-  private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();
-  private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();
-
-  @Override protected Excluder clone() {
-    try {
-      return (Excluder) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public Excluder withVersion(double ignoreVersionsAfter) {
-    Excluder result = clone();
-    result.version = ignoreVersionsAfter;
-    return result;
-  }
-
-  public Excluder withModifiers(int... modifiers) {
-    Excluder result = clone();
-    result.modifiers = 0;
-    for (int modifier : modifiers) {
-      result.modifiers |= modifier;
-    }
-    return result;
-  }
-
-  public Excluder disableInnerClassSerialization() {
-    Excluder result = clone();
-    result.serializeInnerClasses = false;
-    return result;
-  }
-
-  public Excluder excludeFieldsWithoutExposeAnnotation() {
-    Excluder result = clone();
-    result.requireExpose = true;
-    return result;
-  }
-
-  public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
-      boolean serialization, boolean deserialization) {
-    Excluder result = clone();
-    if (serialization) {
-      result.serializationStrategies = new ArrayList<ExclusionStrategy>(serializationStrategies);
-      result.serializationStrategies.add(exclusionStrategy);
-    }
-    if (deserialization) {
-      result.deserializationStrategies
-          = new ArrayList<ExclusionStrategy>(deserializationStrategies);
-      result.deserializationStrategies.add(exclusionStrategy);
-    }
-    return result;
-  }
-
-  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
-    Class<?> rawType = type.getRawType();
-    boolean excludeClass = excludeClassChecks(rawType);
-
-    final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
-    final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
-
-    if (!skipSerialize && !skipDeserialize) {
-      return null;
-    }
-
-    return new TypeAdapter<T>() {
-      /** The delegate is lazily created because it may not be needed, and creating it may fail. */
-      private TypeAdapter<T> delegate;
-
-      @Override public T read(JsonReader in) throws IOException {
-        if (skipDeserialize) {
-          in.skipValue();
-          return null;
-        }
-        return delegate().read(in);
-      }
-
-      @Override public void write(JsonWriter out, T value) throws IOException {
-        if (skipSerialize) {
-          out.nullValue();
-          return;
-        }
-        delegate().write(out, value);
-      }
-
-      private TypeAdapter<T> delegate() {
-        TypeAdapter<T> d = delegate;
-        return d != null
-            ? d
-            : (delegate = gson.getDelegateAdapter(Excluder.this, type));
-      }
-    };
-  }
-
-  public boolean excludeField(Field field, boolean serialize) {
-    if ((modifiers & field.getModifiers()) != 0) {
-      return true;
-    }
-
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (field.isSynthetic()) {
-      return true;
-    }
-
-    if (requireExpose) {
-      Expose annotation = field.getAnnotation(Expose.class);
-      if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {
-        return true;
-      }
-    }
-
-    if (!serializeInnerClasses && isInnerClass(field.getType())) {
-      return true;
-    }
-
-    if (isAnonymousOrLocal(field.getType())) {
-      return true;
-    }
-
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    if (!list.isEmpty()) {
-      for (ExclusionStrategy exclusionStrategy : list) {
-        if (exclusionStrategy.shouldSkipField(field)) {
-          return true;
-        }
-      }
-    }
-
-    return false;
-  }
-
-  private boolean excludeClassChecks(Class<?> clazz) {
-      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
-          return true;
-      }
-
-      if (!serializeInnerClasses && isInnerClass(clazz)) {
-          return true;
-      }
-
-      if (isAnonymousOrLocal(clazz)) {
-          return true;
-      }
-
-      return false;
-  }
-
-  public boolean excludeClass(Class<?> clazz, boolean serialize) {
-      return excludeClassChecks(clazz) ||
-              excludeClassInStrategy(clazz, serialize);
-  }
-
-  private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
-      List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-      for (ExclusionStrategy exclusionStrategy : list) {
-          if (exclusionStrategy.shouldSkipClass(clazz)) {
-              return true;
-          }
-      }
-      return false;
-  }
-
-  private boolean isAnonymousOrLocal(Class<?> clazz) {
-    return !Enum.class.isAssignableFrom(clazz)
-        && (clazz.isAnonymousClass() || clazz.isLocalClass());
-  }
-
-  private boolean isInnerClass(Class<?> clazz) {
-    return clazz.isMemberClass() && !isStatic(clazz);
-  }
-
-  private boolean isStatic(Class<?> clazz) {
-    return (clazz.getModifiers() & Modifier.STATIC) != 0;
-  }
-
-  private boolean isValidVersion(Since since, Until until) {
-    return isValidSince(since) && isValidUntil(until);
-  }
-
-  private boolean isValidSince(Since annotation) {
-    if (annotation != null) {
-      double annotationVersion = annotation.value();
-      if (annotationVersion > version) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private boolean isValidUntil(Until annotation) {
-    if (annotation != null) {
-      double annotationVersion = annotation.value();
-      if (annotationVersion <= version) {
-        return false;
-      }
-    }
-    return true;
-  }
+	private static final double IGNORE_VERSIONS = -1.0d;
+	public static final Excluder DEFAULT = new Excluder();
+
+	private double version = IGNORE_VERSIONS;
+	private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;
+	private boolean serializeInnerClasses = true;
+	private boolean requireExpose;
+	private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();
+	private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();
+
+	@Override protected Excluder clone() {
+		try {
+			return (Excluder) super.clone();
+		} catch (CloneNotSupportedException e) {
+			throw new AssertionError(e);
+		}
+	}
+
+	public Excluder withVersion(double ignoreVersionsAfter) {
+		Excluder result = clone();
+		result.version = ignoreVersionsAfter;
+		return result;
+	}
+
+	public Excluder withModifiers(int... modifiers) {
+		Excluder result = clone();
+		result.modifiers = 0;
+		for (int modifier : modifiers) {
+			result.modifiers |= modifier;
+		}
+		return result;
+	}
+
+	public Excluder disableInnerClassSerialization() {
+		Excluder result = clone();
+		result.serializeInnerClasses = false;
+		return result;
+	}
+
+	public Excluder excludeFieldsWithoutExposeAnnotation() {
+		Excluder result = clone();
+		result.requireExpose = true;
+		return result;
+	}
+
+	public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
+			boolean serialization, boolean deserialization) {
+		Excluder result = clone();
+		if (serialization) {
+			result.serializationStrategies = new ArrayList<>(serializationStrategies);
+			result.serializationStrategies.add(exclusionStrategy);
+		}
+		if (deserialization) {
+			result.deserializationStrategies
+			= new ArrayList<>(deserializationStrategies);
+			result.deserializationStrategies.add(exclusionStrategy);
+		}
+		return result;
+	}
+
+	@Override
+	public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
+		Class<?> rawType = type.getRawType();
+		boolean excludeClass = excludeClassChecks(rawType);
+
+		final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
+		final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
+
+		if (!skipSerialize && !skipDeserialize) {
+			return null;
+		}
+
+		return new TypeAdapter<>() {
+			/** The delegate is lazily created because it may not be needed, and creating it may fail. */
+			private TypeAdapter<T> delegate;
+
+			@Override public T read(JsonReader in) throws IOException {
+				if (skipDeserialize) {
+					in.skipValue();
+					return null;
+				}
+				return delegate().read(in);
+			}
+
+			@Override public void write(JsonWriter out, T value) throws IOException {
+				if (skipSerialize) {
+					out.nullValue();
+					return;
+				}
+				delegate().write(out, value);
+			}
+
+			private TypeAdapter<T> delegate() {
+				TypeAdapter<T> d = delegate;
+				return d != null
+						? d
+								: (delegate = gson.getDelegateAdapter(Excluder.this, type));
+			}
+		};
+	}
+
+	public boolean excludeField(Field field, boolean serialize) {
+		if ((modifiers & field.getModifiers()) != 0) {
+			return true;
+		}
+
+		if (version != Excluder.IGNORE_VERSIONS
+				&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {
+			return true;
+		}
+
+		if (field.isSynthetic()) {
+			return true;
+		}
+
+		if (requireExpose) {
+			Expose annotation = field.getAnnotation(Expose.class);
+			if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {
+				return true;
+			}
+		}
+
+		if (!serializeInnerClasses && isInnerClass(field.getType())) {
+			return true;
+		}
+
+		if (isAnonymousOrLocal(field.getType())) {
+			return true;
+		}
+
+		List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+		if (!list.isEmpty()) {
+			for (ExclusionStrategy exclusionStrategy : list) {
+				if (exclusionStrategy.shouldSkipField(field)) {
+					return true;
+				}
+			}
+		}
+
+		return false;
+	}
+
+	private boolean excludeClassChecks(Class<?> clazz) {
+		if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
+			return true;
+		}
+
+		if (!serializeInnerClasses && isInnerClass(clazz)) {
+			return true;
+		}
+
+		if (isAnonymousOrLocal(clazz)) {
+			return true;
+		}
+
+		return false;
+	}
+
+	public boolean excludeClass(Class<?> clazz, boolean serialize) {
+		return excludeClassChecks(clazz) ||
+				excludeClassInStrategy(clazz, serialize);
+	}
+
+	private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
+		List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+		for (ExclusionStrategy exclusionStrategy : list) {
+			if (exclusionStrategy.shouldSkipClass(clazz)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	private boolean isAnonymousOrLocal(Class<?> clazz) {
+		return !Enum.class.isAssignableFrom(clazz)
+				&& (clazz.isAnonymousClass() || clazz.isLocalClass());
+	}
+
+	private boolean isInnerClass(Class<?> clazz) {
+		return clazz.isMemberClass() && !((clazz.getModifiers() & Modifier.STATIC) != 0);
+	}
+
+	private boolean isValidVersion(Since since, Until until) {
+		return isValidSince(since) && isValidUntil(until);
+	}
+
+	private boolean isValidSince(Since annotation) {
+		if (annotation != null) {
+			double annotationVersion = annotation.value();
+			if (annotationVersion > version) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	private boolean isValidUntil(Until annotation) {
+		if (annotation != null) {
+			double annotationVersion = annotation.value();
+			if (annotationVersion <= version) {
+				return false;
+			}
+		}
+		return true;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
index 15829f3f8..9181cd483 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
@@ -36,14 +36,6 @@
  * @author Jesse Wilson
  */
 public final class JsonTreeReader extends JsonReader {
-  private static final Reader UNREADABLE_READER = new Reader() {
-    @Override public int read(char[] buffer, int offset, int count) throws IOException {
-      throw new AssertionError();
-    }
-    @Override public void close() throws IOException {
-      throw new AssertionError();
-    }
-  };
   private static final Object SENTINEL_CLOSED = new Object();
 
   /*
@@ -64,7 +56,7 @@
   private int[] pathIndices = new int[32];
 
   public JsonTreeReader(JsonElement element) {
-    super(UNREADABLE_READER);
+    super(Reader.nullReader());
     push(element);
   }
 
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
index b58f79237..6dc083bc6 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
@@ -31,17 +31,6 @@
  * This writer creates a JsonElement.
  */
 public final class JsonTreeWriter extends JsonWriter {
-	private static final Writer UNWRITABLE_WRITER = new Writer() {
-		@Override public void write(char[] buffer, int offset, int counter) {
-			throw new AssertionError();
-		}
-		@Override public void flush() throws IOException {
-			throw new AssertionError();
-		}
-		@Override public void close() throws IOException {
-			throw new AssertionError();
-		}
-	};
 	/** Added to the top of the stack when this writer is closed to cause following ops to fail. */
 	private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive("closed");
 
@@ -55,7 +44,7 @@
 	private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;
 
 	public JsonTreeWriter() {
-		super(UNWRITABLE_WRITER);
+		super(Writer.nullWriter());
 	}
 
 	/**
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 4fc525e39..7f123f92c 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -31,11 +31,11 @@
  */
 public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
 	private final Map<Type, InstanceCreator<?>> instanceCreators;
-	private final FieldNamingStrategy fieldNamingPolicy;
+	private final Function<Field, String> fieldNamingPolicy;
 	private final Excluder excluder;
 
 	public ReflectiveTypeAdapterFactory(Map<Type, InstanceCreator<?>> instanceCreators,
-			FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {
+			Function<Field, String> fieldNamingPolicy, Excluder excluder) {
 		this.instanceCreators = instanceCreators;
 		this.fieldNamingPolicy = fieldNamingPolicy;
 		this.excluder = excluder;
@@ -53,7 +53,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 	private List<String> getFieldNames(Field f) {
 		SerializedName annotation = f.getAnnotation(SerializedName.class);
 		if (annotation == null) {
-			String name = fieldNamingPolicy.translateName(f);
+			String name = fieldNamingPolicy.apply(f);
 			return Collections.singletonList(name);
 		}
 
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 3c92cc338..99ac377d5 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -25,6 +25,7 @@
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.function.*;
 import junit.framework.TestCase;
 
 /**
@@ -38,11 +39,7 @@
       .excludeFieldsWithoutExposeAnnotation()
       .disableInnerClassSerialization();
 
-  private static final FieldNamingStrategy CUSTOM_FIELD_NAMING_STRATEGY = new FieldNamingStrategy() {
-    @Override public String translateName(Field f) {
-      return "foo";
-    }
-  };
+  private static final Function<Field, String> CUSTOM_FIELD_NAMING_STRATEGY = f -> "foo";
 
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
diff --git a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
index 4a700a26d..545e2891f 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
@@ -16,16 +16,12 @@
 
 package com.google.gson.functional;
 
-import static com.google.gson.FieldNamingStrategy.IDENTITY;
-import static com.google.gson.FieldNamingStrategy.LOWER_CASE_WITH_DASHES;
-import static com.google.gson.FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES;
-import static com.google.gson.FieldNamingStrategy.UPPER_CAMEL_CASE;
-import static com.google.gson.FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES;
-
-import com.google.gson.FieldNamingStrategy;
+import static com.google.gson.FieldNamingStrategies.*;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.annotations.SerializedName;
+import java.lang.reflect.*;
+import java.util.function.*;
 import junit.framework.TestCase;
 
 public final class FieldNamingTest extends TestCase {
@@ -69,7 +65,7 @@ public void testLowerCaseWithDashes() {
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
-  private Gson getGsonWithNamingPolicy(FieldNamingStrategy fieldNamingPolicy){
+  private Gson getGsonWithNamingPolicy(Function<Field, String> fieldNamingPolicy){
     return Gson.newBuilder()
       .setFieldNamingStrategy(fieldNamingPolicy)
         .build();
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index 4580dbe95..d51a5238d 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.gson.functional;
 
-import com.google.gson.FieldNamingStrategy;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
+import com.google.gson.*;
 import com.google.gson.annotations.SerializedName;
 import com.google.gson.common.TestTypes.ClassWithSerializedNameFields;
 import com.google.gson.common.TestTypes.StringWrapper;
@@ -42,49 +40,49 @@ protected void setUp() throws Exception {
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.UPPER_CAMEL_CASE).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"SomeConstantStringInstanceField\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.UPPER_CAMEL_CASE).build();
     String target = "{\"SomeConstantStringInstanceField\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_DASHES).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some-constant-string-instance-field\":\""
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_DOTS).build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some.constant.string.instance.field\":\""
           + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
   public void testGsonWithLowerCaseDotPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DOTS).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_DOTS).build();
     String target = "{\"some.constant.string.instance.field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_DASHES).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_DASHES).build();
     String target = "{\"some-constant-string-instance-field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
     assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
   }
 
   public void testGsonWithLowerCaseUnderscorePolicySerialization() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_UNDERSCORES)
         .build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"some_constant_string_instance_field\":\""
@@ -92,7 +90,7 @@ public void testGsonWithLowerCaseUnderscorePolicySerialization() {
   }
 
   public void testGsonWithLowerCaseUnderscorePolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.LOWER_CASE_WITH_UNDERSCORES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.LOWER_CASE_WITH_UNDERSCORES)
         .build();
     String target = "{\"some_constant_string_instance_field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
@@ -125,7 +123,7 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
   }
 
   public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.UPPER_CAMEL_CASE_WITH_SPACES)
         .build();
     StringWrapper target = new StringWrapper("blah");
     assertEquals("{\"Some Constant String Instance Field\":\""
@@ -133,7 +131,7 @@ public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {
   }
 
   public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {
-    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES)
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.UPPER_CAMEL_CASE_WITH_SPACES)
         .build();
     String target = "{\"Some Constant String Instance Field\":\"someValue\"}";
     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
@@ -141,7 +139,7 @@ public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {
   }
 
   public void testDeprecatedNamingStrategy() throws Exception {
-    Gson gson = builder.setFieldNamingStrategy(new UpperCaseNamingStrategy()).build();
+    Gson gson = builder.setFieldNamingStrategy(FieldNamingStrategies.UPPER_CASE).build();
     ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);
     String actual = gson.toJson(target);
     assertEquals("{\"A\":10}", actual);
@@ -166,13 +164,6 @@ public void testAtSignInSerializedName() {
     @SerializedName("@foo") String f = "bar";
   }
 
-  private static final class UpperCaseNamingStrategy implements FieldNamingStrategy {
-    @Override
-    public String translateName(Field f) {
-      return f.getName().toUpperCase();
-    }
-  }
-
   @SuppressWarnings("unused")
   private static class ClassWithDuplicateFields {
     public Integer a;
