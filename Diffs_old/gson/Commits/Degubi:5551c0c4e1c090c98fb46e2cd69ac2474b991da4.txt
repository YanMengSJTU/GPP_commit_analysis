diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index d2818ef45..6d0fd58ed 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -107,13 +107,10 @@
 	final List<TypeAdapterFactory> builderFactories;
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
-	Gson(Excluder excluder, Function<Field, String> fieldNamingStrategy,
-			Map<Type, Function<Class<?>, ?>> instanceCreators, boolean serializeNulls,
-			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
-			boolean prettyPrinting,
-			List<TypeAdapterFactory> builderFactories,
-			List<TypeAdapterFactory> builderHierarchyFactories,
-			List<TypeAdapterFactory> factoriesToBeAdded) {
+	Gson(Excluder excluder, Function<Field, String> fieldNamingStrategy, Map<Type, Function<Class<?>, ?>> instanceCreators, boolean serializeNulls,
+		 boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting,
+		 List<TypeAdapterFactory> builderFactories, List<TypeAdapterFactory> builderHierarchyFactories, List<TypeAdapterFactory> factoriesToBeAdded) {
+		
 		this.excluder = excluder;
 		this.fieldNamingStrategy = fieldNamingStrategy;
 		this.instanceCreators = instanceCreators;
@@ -157,10 +154,10 @@
 		factories.add(TypeAdapters.LOCALE_FACTORY);
 		factories.add(ArrayTypeAdapter.FACTORY);
 		factories.add(TypeAdapters.CLASS_FACTORY);
-		factories.add(LocalTimeAdapter.factory);
-		factories.add(LocalDateAdapter.factory);
-		factories.add(LocalDateTimeAdapter.factory);
-		factories.add(InstantTypeAdapter.factory);
+		factories.add(TypeAdapters.LOCALTIME_FACTORY);
+		factories.add(TypeAdapters.LOCALDATE_FACTORY);
+		factories.add(TypeAdapters.LOCALDATETIME_FACTORY);
+		factories.add(TypeAdapters.INSTANT_FACTORY);
 
 		// type adapters for composite and user-defined types
 		factories.add(new CollectionTypeAdapterFactory(instanceCreators));
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 8294b4087..2474d075a 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -414,7 +414,7 @@ public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAd
 			hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
 		}
 		if (typeAdapter instanceof TypeAdapter<?>) {
-			factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));
+			factories.add(TypeAdapterFactory.checkingTypeHierarchy(baseType, (TypeAdapter)typeAdapter));
 		}
 		return this;
 	}
diff --git a/gson/src/main/java/com/google/gson/TypeAdapter.java b/gson/src/main/java/com/google/gson/TypeAdapter.java
index 92f35c28a..a78542f22 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java
@@ -17,14 +17,10 @@
 package com.google.gson;
 
 import com.google.gson.internal.*;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.time.*;
+import java.util.function.*;
 
 /**
  * Converts Java objects to and from JSON.
@@ -117,173 +113,182 @@
 //
 public abstract class TypeAdapter<T> {
 
-  /**
-   * Writes one JSON value (an array, object, string, number, boolean or null)
-   * for {@code value}.
-   *
-   * @param value the Java object to write. May be null.
-   */
-  public abstract void write(JsonWriter out, T value) throws IOException;
+	/**
+	 * Writes one JSON value (an array, object, string, number, boolean or null)
+	 * for {@code value}.
+	 *
+	 * @param value the Java object to write. May be null.
+	 */
+	public abstract void write(JsonWriter out, T value) throws IOException;
 
-  /**
-   * Converts {@code value} to a JSON document and writes it to {@code out}.
-   * Unlike Gson's similar {@link Gson#toJson(JsonElement, Appendable) toJson}
-   * method, this write is strict. Create a {@link
-   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
-   * writing.
-   *
-   * @param value the Java object to convert. May be null.
-   * @since 2.2
-   */
-  public final void toJson(Writer out, T value) throws IOException {
-    JsonWriter writer = new JsonWriter(out);
-    write(writer, value);
-  }
+	/**
+	 * This wrapper method is used to make a type adapter null tolerant. In general, a
+	 * type adapter is required to handle nulls in write and read methods. Here is how this
+	 * is typically done:<br>
+	 * <pre>   {@code
+	 *
+	 * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
+	 *   new TypeAdapter<Foo>() {
+	 *     public Foo read(JsonReader in) throws IOException {
+	 *       if (in.peek() == JsonToken.NULL) {
+	 *         in.nextNull();
+	 *         return null;
+	 *       }
+	 *       // read a Foo from in and return it
+	 *     }
+	 *     public void write(JsonWriter out, Foo src) throws IOException {
+	 *       if (src == null) {
+	 *         out.nullValue();
+	 *         return;
+	 *       }
+	 *       // write src as JSON to out
+	 *     }
+	 *   }).build();
+	 * }</pre>
+	 * You can avoid this boilerplate handling of nulls by wrapping your type adapter with
+	 * this method. Here is how we will rewrite the above example:
+	 * <pre>   {@code
+	 *
+	 * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
+	 *   new TypeAdapter<Foo>() {
+	 *     public Foo read(JsonReader in) throws IOException {
+	 *       // read a Foo from in and return it
+	 *     }
+	 *     public void write(JsonWriter out, Foo src) throws IOException {
+	 *       // write src as JSON to out
+	 *     }
+	 *   }.nullSafe()).build();
+	 * }</pre>
+	 * Note that we didn't need to check for nulls in our type adapter after we used nullSafe.
+	 */
+	public static<T> TypeAdapter<T> nullSafe(TypeAdapter<T> adapter) {
+		return new TypeAdapter<>() {
+			@Override 
+			public void write(JsonWriter out, T value) throws IOException {
+				if (value == null) {
+					out.nullValue();
+				} else {
+					adapter.write(out, value);
+				}
+			}
+			@Override 
+			public T read(JsonReader reader) throws IOException {
+				if (reader.peek() == JsonToken.NULL) {
+					reader.nextNull();
+					return null;
+				}
+				return adapter.read(reader);
+			}
+		};
+	}
 
-  /**
-   * This wrapper method is used to make a type adapter null tolerant. In general, a
-   * type adapter is required to handle nulls in write and read methods. Here is how this
-   * is typically done:<br>
-   * <pre>   {@code
-   *
-   * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
-   *   new TypeAdapter<Foo>() {
-   *     public Foo read(JsonReader in) throws IOException {
-   *       if (in.peek() == JsonToken.NULL) {
-   *         in.nextNull();
-   *         return null;
-   *       }
-   *       // read a Foo from in and return it
-   *     }
-   *     public void write(JsonWriter out, Foo src) throws IOException {
-   *       if (src == null) {
-   *         out.nullValue();
-   *         return;
-   *       }
-   *       // write src as JSON to out
-   *     }
-   *   }).build();
-   * }</pre>
-   * You can avoid this boilerplate handling of nulls by wrapping your type adapter with
-   * this method. Here is how we will rewrite the above example:
-   * <pre>   {@code
-   *
-   * Gson gson = Gson.newBuilder().registerTypeAdapter(Foo.class,
-   *   new TypeAdapter<Foo>() {
-   *     public Foo read(JsonReader in) throws IOException {
-   *       // read a Foo from in and return it
-   *     }
-   *     public void write(JsonWriter out, Foo src) throws IOException {
-   *       // write src as JSON to out
-   *     }
-   *   }.nullSafe()).build();
-   * }</pre>
-   * Note that we didn't need to check for nulls in our type adapter after we used nullSafe.
-   */
-  public final TypeAdapter<T> nullSafe() {
-    return new TypeAdapter<T>() {
-      @Override public void write(JsonWriter out, T value) throws IOException {
-        if (value == null) {
-          out.nullValue();
-        } else {
-          TypeAdapter.this.write(out, value);
-        }
-      }
-      @Override public T read(JsonReader reader) throws IOException {
-        if (reader.peek() == JsonToken.NULL) {
-          reader.nextNull();
-          return null;
-        }
-        return TypeAdapter.this.read(reader);
-      }
-    };
-  }
+	/**
+	 * Converts {@code value} to a JSON document. Unlike Gson's similar {@link
+	 * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link
+	 * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
+	 * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
+	 * writing.
+	 *
+	 * @param value the Java object to convert. May be null.
+	 * @since 2.2
+	 */
+	public final String toJson(T value) {
+		StringWriter stringWriter = new StringWriter();
+		try {
+			JsonWriter writer = new JsonWriter(stringWriter);
+			write(writer, value);
+		} catch (IOException e) {
+			throw new AssertionError(e); // No I/O writing to a StringWriter.
+		}
+		return stringWriter.toString();
+	}
 
-  /**
-   * Converts {@code value} to a JSON document. Unlike Gson's similar {@link
-   * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link
-   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
-   * writing.
-   *
-   * @param value the Java object to convert. May be null.
-   * @since 2.2
-   */
-  public final String toJson(T value) {
-    StringWriter stringWriter = new StringWriter();
-    try {
-      toJson(stringWriter, value);
-    } catch (IOException e) {
-      throw new AssertionError(e); // No I/O writing to a StringWriter.
-    }
-    return stringWriter.toString();
-  }
+	/**
+	 * Converts {@code value} to a JSON tree.
+	 *
+	 * @param value the Java object to convert. May be null.
+	 * @return the converted JSON tree. May be {@link JsonNull}.
+	 * @since 2.2
+	 */
+	public final JsonElement toJsonTree(T value) {
+		try {
+			JsonTreeWriter jsonWriter = new JsonTreeWriter();
+			write(jsonWriter, value);
+			return jsonWriter.get();
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
 
-  /**
-   * Converts {@code value} to a JSON tree.
-   *
-   * @param value the Java object to convert. May be null.
-   * @return the converted JSON tree. May be {@link JsonNull}.
-   * @since 2.2
-   */
-  public final JsonElement toJsonTree(T value) {
-    try {
-      JsonTreeWriter jsonWriter = new JsonTreeWriter();
-      write(jsonWriter, value);
-      return jsonWriter.get();
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
+	/**
+	 * Reads one JSON value (an array, object, string, number, boolean or null)
+	 * and converts it to a Java object. Returns the converted object.
+	 *
+	 * @return the converted Java object. May be null.
+	 */
+	public abstract T read(JsonReader in) throws IOException;
 
-  /**
-   * Reads one JSON value (an array, object, string, number, boolean or null)
-   * and converts it to a Java object. Returns the converted object.
-   *
-   * @return the converted Java object. May be null.
-   */
-  public abstract T read(JsonReader in) throws IOException;
+	/**
+	 * Converts the JSON document in {@code in} to a Java object. Unlike Gson's
+	 * similar {@link Gson#fromJson(java.io.Reader, Class) fromJson} method, this
+	 * read is strict. Create a {@link JsonReader#setLenient(boolean) lenient}
+	 * {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.
+	 *
+	 * @return the converted Java object. May be null.
+	 * @since 2.2
+	 */
+	public final T fromJson(Reader in) throws IOException {
+		JsonReader reader = new JsonReader(in);
+		return read(reader);
+	}
 
-  /**
-   * Converts the JSON document in {@code in} to a Java object. Unlike Gson's
-   * similar {@link Gson#fromJson(java.io.Reader, Class) fromJson} method, this
-   * read is strict. Create a {@link JsonReader#setLenient(boolean) lenient}
-   * {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.
-   *
-   * @return the converted Java object. May be null.
-   * @since 2.2
-   */
-  public final T fromJson(Reader in) throws IOException {
-    JsonReader reader = new JsonReader(in);
-    return read(reader);
-  }
+	/**
+	 * Converts the JSON document in {@code json} to a Java object. Unlike Gson's
+	 * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is
+	 * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code
+	 * JsonReader} and call {@link #read(JsonReader)} for lenient reading.
+	 *
+	 * @return the converted Java object. May be null.
+	 * @since 2.2
+	 */
+	public final T fromJson(String json) throws IOException {
+		return fromJson(new StringReader(json));
+	}
 
-  /**
-   * Converts the JSON document in {@code json} to a Java object. Unlike Gson's
-   * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is
-   * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code
-   * JsonReader} and call {@link #read(JsonReader)} for lenient reading.
-   *
-   * @return the converted Java object. May be null.
-   * @since 2.2
-   */
-  public final T fromJson(String json) throws IOException {
-    return fromJson(new StringReader(json));
-  }
+	/**
+	 * Converts {@code jsonTree} to a Java object.
+	 *
+	 * @param jsonTree the Java object to convert. May be {@link JsonNull}.
+	 * @since 2.2
+	 */
+	public final T fromJsonTree(JsonElement jsonTree) {
+		try {
+			JsonReader jsonReader = new JsonTreeReader(jsonTree);
+			return read(jsonReader);
+		} catch (IOException e) {
+			throw new JsonIOException(e);
+		}
+	}
 
-  /**
-   * Converts {@code jsonTree} to a Java object.
-   *
-   * @param jsonTree the Java object to convert. May be {@link JsonNull}.
-   * @since 2.2
-   */
-  public final T fromJsonTree(JsonElement jsonTree) {
-    try {
-      JsonReader jsonReader = new JsonTreeReader(jsonTree);
-      return read(jsonReader);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    }
-  }
-}
+	public static<T> TypeAdapter<T> convertingString(Function<String, T> readConverter){
+		return new TypeAdapter<>(){
+			@Override
+			public void write(JsonWriter out, T value) throws IOException {
+				if(value == null) {
+					out.nullValue();
+				}else{
+					out.value(value.toString());
+				}
+			}
+
+			@Override
+			public T read(JsonReader in) throws IOException {
+				if (in.peek() == JsonToken.NULL) {
+					in.nextNull();
+					return null;
+				}
+				return readConverter.apply(in.nextString());
+			}
+		};
+	}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
index 18a815218..d0dbb7d88 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java
@@ -17,6 +17,8 @@
 package com.google.gson;
 
 import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
 import java.util.function.*;
 
 /**
@@ -189,4 +191,30 @@
 			}
 		};
 	}
+	
+	public static <T1> TypeAdapterFactory checkingTypeHierarchy(Class<T1> clazz, TypeAdapter<T1> typeAdapter) {
+		return new TypeAdapterFactory() {
+			@Override 
+			public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken, Class<? super T2> rawType) {
+				if (!clazz.isAssignableFrom(rawType)) {
+					return null;
+				}
+				return (TypeAdapter<T2>) new TypeAdapter<T1>() {
+					@Override 
+					public void write(JsonWriter out, T1 value) throws IOException {
+						typeAdapter.write(out, value);
+					}
+
+					@Override 
+					public T1 read(JsonReader in) throws IOException {
+						T1 result = typeAdapter.read(in);
+						if (result != null && !rawType.isInstance(result)) {
+							throw new JsonSyntaxException("Expected a " + rawType.getName() + " but was " + result.getClass().getName());
+						}
+						return result;
+					}
+				};
+			}
+		};
+	}
 }
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
index 60a825f93..205508de9 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
@@ -30,13 +30,13 @@
 	public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
 		@SuppressWarnings({"unchecked", "rawtypes"})
 		@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken, Class<? super T> rawType) {
-			Type type = typeToken.getType();
+			var type = typeToken.getType();
 			if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
 				return null;
 			}
 
-			Type componentType = $Gson$Types.getArrayComponentType(type);
-			TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));
+			var componentType = $Gson$Types.getArrayComponentType(type);
+			var componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));
 			return new ArrayTypeAdapter(gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));
 		}
 	};
@@ -81,7 +81,8 @@ public Object read(JsonReader in) throws IOException {
 	}
 
 	@SuppressWarnings("unchecked")
-	@Override public void write(JsonWriter out, Object array) throws IOException {
+	@Override 
+	public void write(JsonWriter out, Object array) throws IOException {
 		if (array == null) {
 			out.nullValue();
 			return;
@@ -95,4 +96,4 @@ public Object read(JsonReader in) throws IOException {
 		}
 		out.endArray();
 	}
-}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
index 73cba79e5..9c71f0ee6 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -43,13 +43,11 @@ public CollectionTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCre
 			return null;
 		}
 
-		Type elementType = $Gson$Types.getCollectionElementType(type, rawType);
-		TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
-		Supplier<T> constructor = ConstructorConstructor.get(typeToken, instanceCreators);
+		var elementType = $Gson$Types.getCollectionElementType(type, rawType);
+		var elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
+		var constructor = ConstructorConstructor.get(typeToken, instanceCreators);
 
-		@SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
-		TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);
-		return result;
+		return new Adapter(gson, elementType, elementTypeAdapter, constructor);
 	}
 
 	private static final class Adapter<E> extends TypeAdapter<Collection<E>> {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java
deleted file mode 100644
index 2bf127426..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/InstantTypeAdapter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.google.gson.internal.bind;
-
-import com.google.gson.*;
-import com.google.gson.stream.*;
-import java.io.*;
-import java.time.*;
-
-public class InstantTypeAdapter extends TypeAdapter<Instant>{
-	public static final TypeAdapterFactory factory = TypeAdapterFactory.checkingRawType(Instant.class, InstantTypeAdapter::new);
-	
-	@Override
-	public void write(JsonWriter out, Instant value) throws IOException {
-		if(value == null) {
-			out.nullValue();
-		}else{
-			out.value(value.toString());
-		}
-	}
-
-	@Override
-	public Instant read(JsonReader in) throws IOException {
-		if (in.peek() == JsonToken.NULL) {
-			in.nextNull();
-			return null;
-		}
-		return Instant.parse(in.nextString());
-	}
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index ccc642dc6..81caba7dd 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -39,7 +39,7 @@ public JsonAdapterAnnotationTypeAdapterFactory(Map<Type, Function<Class<?>, ?>>
 
 	@Override
 	public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType, Class<? super T> rawType) {
-		JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);
+		var annotation = rawType.getAnnotation(JsonAdapter.class);
 		if (annotation == null) {
 			return null;
 		}
@@ -71,7 +71,7 @@ public JsonAdapterAnnotationTypeAdapterFactory(Map<Type, Function<Class<?>, ?>>
 		}
 
 		if (typeAdapter != null && annotation.nullSafe()) {
-			typeAdapter = typeAdapter.nullSafe();
+			typeAdapter = TypeAdapter.nullSafe(typeAdapter);
 		}
 
 		return typeAdapter;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
deleted file mode 100644
index 92fe714f8..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalDateAdapter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.google.gson.internal.bind;
-
-import com.google.gson.*;
-import com.google.gson.stream.*;
-import java.io.*;
-import java.time.*;
-
-public class LocalDateAdapter extends TypeAdapter<LocalDate>{
-	public static final TypeAdapterFactory factory = TypeAdapterFactory.checkingRawType(LocalDate.class, LocalDateAdapter::new);
-	
-	@Override
-	public void write(JsonWriter out, LocalDate value) throws IOException {
-		if(value == null) {
-			out.nullValue();
-		}else{
-			out.value(value.toString());
-		}
-	}
-
-	@Override
-	public LocalDate read(JsonReader in) throws IOException {
-		if (in.peek() == JsonToken.NULL) {
-			in.nextNull();
-			return null;
-		}
-		return LocalDate.parse(in.nextString());
-	}
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
deleted file mode 100644
index 00f673a13..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalDateTimeAdapter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.google.gson.internal.bind;
-
-import com.google.gson.*;
-import com.google.gson.stream.*;
-import java.io.*;
-import java.time.*;
-
-public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime>{
-	public static final TypeAdapterFactory factory = TypeAdapterFactory.checkingRawType(LocalDateTime.class, LocalDateTimeAdapter::new);
-	
-	@Override
-	public void write(JsonWriter out, LocalDateTime value) throws IOException {
-		if(value == null) {
-			out.nullValue();
-		}else{
-			out.value(value.toString());
-		}
-	}
-
-	@Override
-	public LocalDateTime read(JsonReader in) throws IOException {
-		if (in.peek() == JsonToken.NULL) {
-			in.nextNull();
-			return null;
-		}
-		return LocalDateTime.parse(in.nextString());
-	}
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java
deleted file mode 100644
index da9c912d2..000000000
--- a/gson/src/main/java/com/google/gson/internal/bind/LocalTimeAdapter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.google.gson.internal.bind;
-
-import com.google.gson.*;
-import com.google.gson.stream.*;
-import java.io.*;
-import java.time.*;
-
-public class LocalTimeAdapter extends TypeAdapter<LocalTime>{
-	public static final TypeAdapterFactory factory = TypeAdapterFactory.checkingRawType(LocalTime.class, LocalTimeAdapter::new);
-	
-	@Override
-	public void write(JsonWriter out, LocalTime value) throws IOException {
-		if(value == null) {
-			out.nullValue();
-		}else{
-			out.value(value.toString());
-		}
-	}
-
-	@Override
-	public LocalTime read(JsonReader in) throws IOException {
-		if (in.peek() == JsonToken.NULL) {
-			in.nextNull();
-			return null;
-		}
-		return LocalTime.parse(in.nextString());
-	}
-}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index d4e1dbc82..794da4c2a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -137,10 +137,8 @@ public MapTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators,
 		public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 				Type valueType, TypeAdapter<V> valueTypeAdapter,
 				Supplier<? extends Map<K, V>> constructor) {
-			this.keyTypeAdapter =
-					new TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);
-			this.valueTypeAdapter =
-					new TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);
+			this.keyTypeAdapter = new TypeAdapterRuntimeTypeWrapper<>(context, keyTypeAdapter, keyType);
+			this.valueTypeAdapter = new TypeAdapterRuntimeTypeWrapper<>(context, valueTypeAdapter, valueType);
 			this.constructor = constructor;
 		}
 
@@ -182,7 +180,9 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 			return map;
 		}
 
-		@Override public void write(JsonWriter out, Map<K, V> map) throws IOException {
+		@SuppressWarnings("unchecked")
+		@Override 
+		public void write(JsonWriter out, Map<K, V> map) throws IOException {
 			if (map == null) {
 				out.nullValue();
 				return;
@@ -190,7 +190,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 
 			if (!complexMapKeySerialization) {
 				out.beginObject();
-				for (Map.Entry<K, V> entry : map.entrySet()) {
+				for (var entry : map.entrySet()) {
 					out.name(String.valueOf(entry.getKey()));
 					valueTypeAdapter.write(out, entry.getValue());
 				}
@@ -198,32 +198,33 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 				return;
 			}
 
-			boolean hasComplexKeys = false;
-			List<JsonElement> keys = new ArrayList<JsonElement>(map.size());
+			var hasComplexKeys = false;
+			var keys = new JsonElement[map.size()];
+			var values = (V[]) new Object[map.size()];
+			var index = 0;
 
-			List<V> values = new ArrayList<V>(map.size());
-			for (Map.Entry<K, V> entry : map.entrySet()) {
+			for (var entry : map.entrySet()) {
 				JsonElement keyElement = keyTypeAdapter.toJsonTree(entry.getKey());
-				keys.add(keyElement);
-				values.add(entry.getValue());
+				keys[index] = keyElement;
+				values[index++] = entry.getValue();
 				hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject();
 			}
 
 			if (hasComplexKeys) {
 				out.beginArray();
-				for (int i = 0, size = keys.size(); i < size; i++) {
+				for (int i = 0; i < index; i++) {
 					out.beginArray(); // entry array
-					TypeAdapters.JSON_ELEMENT.write(out, keys.get(i));
-					valueTypeAdapter.write(out, values.get(i));
+					TypeAdapters.JSON_ELEMENT.write(out, keys[i]);
+					valueTypeAdapter.write(out, values[i]);
 					out.endArray();
 				}
 				out.endArray();
 			} else {
 				out.beginObject();
-				for (int i = 0, size = keys.size(); i < size; i++) {
-					JsonElement keyElement = keys.get(i);
+				for (int i = 0; i < index; i++) {
+					JsonElement keyElement = keys[i];
 					out.name(keyToString(keyElement));
-					valueTypeAdapter.write(out, values.get(i));
+					valueTypeAdapter.write(out, values[i]);
 				}
 				out.endObject();
 			}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index 79757666b..96635170f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -43,42 +43,32 @@
 		this.gson = gson;
 	}
 
-	@Override public Object read(JsonReader in) throws IOException {
-		JsonToken token = in.peek();
-		switch (token) {
-		case BEGIN_ARRAY:
-			List<Object> list = new ArrayList<>();
-			in.beginArray();
-			while (in.hasNext()) {
-				list.add(read(in));
-			}
-			in.endArray();
-			return list;
-
-		case BEGIN_OBJECT:
-			Map<String, Object> map = new HashMap<>();
-			in.beginObject();
-			while (in.hasNext()) {
-				map.put(in.nextName(), read(in));
-			}
-			in.endObject();
-			return map;
-
-		case STRING:
-			return in.nextString();
-
-		case NUMBER:
-			return in.nextDouble();
-
-		case BOOLEAN:
-			return in.nextBoolean();
-
-		case NULL:
-			in.nextNull();
-			return null;
-
-		default:
-			throw new IllegalStateException();
+	@Override 
+	public Object read(JsonReader in) throws IOException {
+		switch (in.peek()) {
+			case BEGIN_ARRAY:
+				var list = new ArrayList<>();
+				in.beginArray();
+				while (in.hasNext()) {
+					list.add(read(in));
+				}
+				in.endArray();
+				return list;
+	
+			case BEGIN_OBJECT:
+				var map = new HashMap<String, Object>();
+				in.beginObject();
+				while (in.hasNext()) {
+					map.put(in.nextName(), read(in));
+				}
+				in.endObject();
+				return map;
+	
+			case STRING: return in.nextString();
+			case NUMBER: return in.nextDouble();
+			case BOOLEAN: return in.nextBoolean();
+			case NULL: in.nextNull(); return null;
+			default: throw new IllegalStateException();
 		}
 	}
 
@@ -89,7 +79,7 @@
 			return;
 		}
 
-		TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
+		var typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
 		if (typeAdapter instanceof ObjectTypeAdapter) {
 			out.beginObject();
 			out.endObject();
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index dbc22c49f..7321bc1d6 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -34,8 +34,7 @@
 	private final Function<Field, String> fieldNamingPolicy;
 	private final Excluder excluder;
 
-	public ReflectiveTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators,
-			Function<Field, String> fieldNamingPolicy, Excluder excluder) {
+	public ReflectiveTypeAdapterFactory(Map<Type, Function<Class<?>, ?>> instanceCreators, Function<Field, String> fieldNamingPolicy, Excluder excluder) {
 		this.instanceCreators = instanceCreators;
 		this.fieldNamingPolicy = fieldNamingPolicy;
 		this.excluder = excluder;
@@ -59,7 +58,7 @@ public boolean excludeField(Field f, boolean serialize) {
 			return Collections.singletonList(serializedName);
 		}
 
-		List<String> fieldNames = new ArrayList<String>(alternates.length + 1);
+		List<String> fieldNames = new ArrayList<>(alternates.length + 1);
 		fieldNames.add(serializedName);
 		for (String alternate : alternates) {
 			fieldNames.add(alternate);
@@ -74,7 +73,7 @@ public boolean excludeField(Field f, boolean serialize) {
 		}
 
 		Supplier<T> constructor = ConstructorConstructor.get(type, instanceCreators);
-		return new Adapter<T>(constructor, getBoundFields(gson, type, rawType));
+		return new Adapter<>(constructor, getBoundFields(gson, type, rawType));
 	}
 
 	private ReflectiveTypeAdapterFactory.BoundField createBoundField(Gson context, Field field, String name, TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
@@ -114,7 +113,7 @@ void read(JsonReader reader, Object value) throws IOException, IllegalAccessExce
 	}
 
 	private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
-		Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
+		Map<String, BoundField> result = new LinkedHashMap<>();
 		if (raw.isInterface()) {
 			return result;
 		}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index 06345de1c..6523575b3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -31,10 +31,10 @@
 public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
 	private final JsonSerializer<T> serializer;
 	private final JsonDeserializer<T> deserializer;
-	final Gson gson;
+	private final Gson gson;
 	private final TypeToken<T> typeToken;
 	private final TypeAdapterFactory skipPast;
-	private final GsonContextImpl context = new GsonContextImpl();
+	private final GsonContextImpl context;
 
 	/** The delegate is lazily created because it may not be needed, and creating it may fail. */
 	private TypeAdapter<T> delegate;
@@ -46,6 +46,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
 		this.gson = gson;
 		this.typeToken = typeToken;
 		this.skipPast = skipPast;
+		this.context = new GsonContextImpl(gson);
 	}
 
 	@Override 
@@ -140,15 +141,24 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
 		}
 	}
 
-	private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
-		@Override public JsonElement serialize(Object src) {
+	public static final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
+		private final Gson gson;
+		
+		public GsonContextImpl(Gson gson) {
+			this.gson = gson;
+		}
+		
+		@Override 
+		public JsonElement serialize(Object src) {
 			return gson.toJsonTree(src);
 		}
-		@Override public JsonElement serialize(Object src, Type typeOfSrc) {
+		@Override 
+		public JsonElement serialize(Object src, Type typeOfSrc) {
 			return gson.toJsonTree(src, typeOfSrc);
 		}
 		@SuppressWarnings("unchecked")
-		@Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
+		@Override 
+		public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
 			return (R) gson.fromJson(json, typeOfT);
 		}
 	};
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index ed0e66cc1..5a086f041 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.internal.bind;
 
+import static com.google.gson.TypeAdapterFactory.*;
+
 import com.google.gson.*;
 import com.google.gson.annotations.*;
 import com.google.gson.internal.*;
@@ -24,6 +26,7 @@
 import java.io.*;
 import java.math.*;
 import java.net.*;
+import java.time.*;
 import java.util.*;
 
 /**
@@ -31,7 +34,7 @@
  */
 public final class TypeAdapters {
 
-	public static final TypeAdapterFactory CLASS_FACTORY = TypeAdapterFactory.checkingRawType(Class.class, () -> new TypeAdapter<Class>() {
+	public static final TypeAdapterFactory CLASS_FACTORY = TypeAdapterFactory.checkingRawType(Class.class, () -> TypeAdapter.nullSafe(new TypeAdapter<Class>() {
 		@Override
 		public void write(JsonWriter out, Class value) throws IOException {
 			throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: " + value.getName() + ". Forgot to register a type adapter?");
@@ -40,7 +43,7 @@ public void write(JsonWriter out, Class value) throws IOException {
 		public Class read(JsonReader in) throws IOException {
 			throw new UnsupportedOperationException("Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
 		}
-	}.nullSafe());
+	}));
 
 	public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<>() {
 		@Override
@@ -63,104 +66,27 @@ public void write(JsonWriter out, Boolean value) throws IOException {
 	 * otherwise permitted.
 	 */
 	public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<>() {
-		@Override public Boolean read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			return Boolean.valueOf(in.nextString());
-		}
-
-		@Override public void write(JsonWriter out, Boolean value) throws IOException {
-			out.value(value == null ? "null" : value.toString());
-		}
-	};
-
-	public static final TypeAdapterFactory BOOLEAN_FACTORY = TypeAdapterFactory.checkingRawTypes(boolean.class, Boolean.class, () -> BOOLEAN);
-
-	public static final TypeAdapter<Number> BYTE = new TypeAdapter<>() {
-		@Override
-		public Number read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			try {
-				int intValue = in.nextInt();
-				return (byte) intValue;
-			} catch (NumberFormatException e) {
-				throw new JsonSyntaxException(e);
-			}
-		}
-		@Override
-		public void write(JsonWriter out, Number value) throws IOException {
-			out.value(value);
-		}
-	};
-
-	public static final TypeAdapterFactory BYTE_FACTORY = TypeAdapterFactory.checkingRawTypes(byte.class, Byte.class, () -> BYTE);
-
-	public static final TypeAdapter<Number> SHORT = new TypeAdapter<>() {
 		@Override
-		public Number read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			try {
-				return (short) in.nextInt();
-			} catch (NumberFormatException e) {
-				throw new JsonSyntaxException(e);
-			}
-		}
-		@Override
-		public void write(JsonWriter out, Number value) throws IOException {
-			out.value(value);
-		}
-	};
-
-	public static final TypeAdapterFactory SHORT_FACTORY = TypeAdapterFactory.checkingRawTypes(short.class, Short.class, () -> SHORT);
-
-	public static final TypeAdapter<Number> INTEGER = new TypeAdapter<>() {
-		@Override
-		public Number read(JsonReader in) throws IOException {
+		public Boolean read(JsonReader in) throws IOException {
 			if (in.peek() == JsonToken.NULL) {
 				in.nextNull();
 				return null;
 			}
-			try {
-				return in.nextInt();
-			} catch (NumberFormatException e) {
-				throw new JsonSyntaxException(e);
-			}
-		}
-		@Override
-		public void write(JsonWriter out, Number value) throws IOException {
-			out.value(value);
+			return Boolean.valueOf(in.nextString());
 		}
-	};
-	public static final TypeAdapterFactory INTEGER_FACTORY = TypeAdapterFactory.checkingRawTypes(int.class, Integer.class, () -> INTEGER);
 
-	public static final TypeAdapter<Number> LONG = new TypeAdapter<>() {
 		@Override
-		public Number read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			try {
-				return in.nextLong();
-			} catch (NumberFormatException e) {
-				throw new JsonSyntaxException(e);
-			}
-		}
-		@Override
-		public void write(JsonWriter out, Number value) throws IOException {
-			out.value(value);
+		public void write(JsonWriter out, Boolean value) throws IOException {
+			out.value(value == null ? "null" : value.toString());
 		}
 	};
 	
-	public static final TypeAdapterFactory LONG_FACTORY = TypeAdapterFactory.checkingRawTypes(long.class, Long.class, () -> LONG);
+	public static final TypeAdapterFactory BOOLEAN_FACTORY = checkingRawTypes(boolean.class, Boolean.class, () -> BOOLEAN);
+
+	public static final TypeAdapterFactory BYTE_FACTORY = checkingRawTypes(byte.class, Byte.class, () -> createPrimitiveAdapter(reader -> (byte) reader.nextInt()));
+	public static final TypeAdapterFactory SHORT_FACTORY = checkingRawTypes(short.class, Short.class, () -> createPrimitiveAdapter(reader -> (short) reader.nextInt()));
+	public static final TypeAdapterFactory INTEGER_FACTORY = checkingRawTypes(int.class, Integer.class, () -> createPrimitiveAdapter(JsonReader::nextInt));
+	public static final TypeAdapterFactory LONG_FACTORY = checkingRawTypes(long.class, Long.class, () -> createPrimitiveAdapter(JsonReader::nextLong));
 
 	public static final TypeAdapter<Number> FLOAT = new TypeAdapter<>() {
 		@Override
@@ -183,7 +109,7 @@ public void write(JsonWriter out, Number value) throws IOException {
 		}
 	};
 	
-	public static final TypeAdapterFactory FLOAT_FACTORY = TypeAdapterFactory.checkingRawTypes(float.class, Float.class, () -> FLOAT);
+	public static final TypeAdapterFactory FLOAT_FACTORY = checkingRawTypes(float.class, Float.class, () -> FLOAT);
 
 	static void checkValidFloatingPoint(double value) {
 		if (Double.isNaN(value) || Double.isInfinite(value)) {
@@ -214,7 +140,28 @@ public void write(JsonWriter out, Number value) throws IOException {
 		}
 	};
 	
-	public static final TypeAdapterFactory DOUBLE_FACTORY = TypeAdapterFactory.checkingRawTypes(double.class, Double.class, () -> DOUBLE);
+	private static TypeAdapter<Number> createPrimitiveAdapter(JsonReaderFunction<Number> reader){
+		return new TypeAdapter<>() {
+			@Override
+			public Number read(JsonReader in) throws IOException {
+				if (in.peek() == JsonToken.NULL) {
+					in.nextNull();
+					return null;
+				}
+				try {
+					return reader.apply(in);
+				} catch (NumberFormatException e) {
+					throw new JsonSyntaxException(e);
+				}
+			}
+			@Override
+			public void write(JsonWriter out, Number value) throws IOException {
+				out.value(value);
+			}
+		};
+	}
+	
+	public static final TypeAdapterFactory DOUBLE_FACTORY = checkingRawTypes(double.class, Double.class, () -> DOUBLE);
 
 	public static final TypeAdapter<Number> NUMBER = new TypeAdapter<>() {
 		@Override
@@ -258,7 +205,7 @@ public void write(JsonWriter out, Character value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapterFactory CHARACTER_FACTORY = TypeAdapterFactory.checkingRawTypes(char.class, Character.class, () -> CHARACTER);
+	public static final TypeAdapterFactory CHARACTER_FACTORY = checkingRawTypes(char.class, Character.class, () -> CHARACTER);
 
 	public static final TypeAdapter<String> STRING = new TypeAdapter<>() {
 		@Override
@@ -316,6 +263,12 @@ public void write(JsonWriter out, String value) throws IOException {
 		}
 	};
 
+	public static final TypeAdapterFactory INSTANT_FACTORY = TypeAdapterFactory.checkingRawType(Instant.class, () -> TypeAdapter.convertingString(Instant::parse));
+	public static final TypeAdapterFactory LOCALDATE_FACTORY = TypeAdapterFactory.checkingRawType(LocalDate.class, () -> TypeAdapter.convertingString(LocalDate::parse));
+	public static final TypeAdapterFactory LOCALDATETIME_FACTORY = TypeAdapterFactory.checkingRawType(LocalDateTime.class, () -> TypeAdapter.convertingString(LocalDateTime::parse));
+	public static final TypeAdapterFactory LOCALTIME_FACTORY = TypeAdapterFactory.checkingRawType(LocalTime.class, () -> TypeAdapter.convertingString(LocalTime::parse));
+
+	
 	public static final TypeAdapterFactory STRING_FACTORY = TypeAdapterFactory.checkingRawType(String.class, () -> STRING);
 
 	public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<>() {
@@ -356,35 +309,8 @@ public void write(JsonWriter out, URI value) throws IOException {
 	};
 
 	public static final TypeAdapterFactory URI_FACTORY = TypeAdapterFactory.checkingRawType(URI.class, () -> URI);
-
-	public static final TypeAdapter<UUID> UUID = new TypeAdapter<>() {
-		@Override
-		public UUID read(JsonReader in) throws IOException {
-			if (in.peek() == JsonToken.NULL) {
-				in.nextNull();
-				return null;
-			}
-			return java.util.UUID.fromString(in.nextString());
-		}
-		@Override
-		public void write(JsonWriter out, UUID value) throws IOException {
-			out.value(value == null ? null : value.toString());
-		}
-	};
-
-	public static final TypeAdapterFactory UUID_FACTORY = TypeAdapterFactory.checkingRawType(UUID.class, () -> UUID);
-
-	public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {
-		@Override
-		public Currency read(JsonReader in) throws IOException {
-			return Currency.getInstance(in.nextString());
-		}
-		@Override
-		public void write(JsonWriter out, Currency value) throws IOException {
-			out.value(value.getCurrencyCode());
-		}
-	}.nullSafe();
-	public static final TypeAdapterFactory CURRENCY_FACTORY = TypeAdapterFactory.checkingRawType(Currency.class, () -> CURRENCY);
+	public static final TypeAdapterFactory UUID_FACTORY = TypeAdapterFactory.checkingRawType(UUID.class, () -> TypeAdapter.convertingString(UUID::fromString));
+	public static final TypeAdapterFactory CURRENCY_FACTORY = TypeAdapterFactory.checkingRawType(Currency.class, () -> TypeAdapter.convertingString(Currency::getInstance));
 
 	public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<>() {
 		@Override
@@ -483,7 +409,7 @@ public void write(JsonWriter out, Locale value) throws IOException {
 
 			} else if (value.isJsonObject()) {
 				out.beginObject();
-				for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
+				for (var e : value.getAsJsonObject().entrySet()) {
 					out.name(e.getKey());
 					write(out, e.getValue());
 				}
@@ -495,8 +421,7 @@ public void write(JsonWriter out, Locale value) throws IOException {
 		}
 	};
 
-	public static final TypeAdapterFactory JSON_ELEMENT_FACTORY
-	= newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
+	public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = TypeAdapterFactory.checkingTypeHierarchy(JsonElement.class, JSON_ELEMENT);
 
 	private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
 		private final Map<String, T> nameToConstant = new HashMap<>();
@@ -555,35 +480,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
 		};
 	}
 
-	/**
-	 * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
-	 * that the deserialized type matches the type requested.
-	 */
-	public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1> clazz, TypeAdapter<T1> typeAdapter) {
-		return new TypeAdapterFactory() {
-			@SuppressWarnings("unchecked")
-			@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken, Class<? super T2> rawType) {
-				if (!clazz.isAssignableFrom(rawType)) {
-					return null;
-				}
-				return (TypeAdapter<T2>) new TypeAdapter<T1>() {
-					@Override public void write(JsonWriter out, T1 value) throws IOException {
-						typeAdapter.write(out, value);
-					}
-
-					@Override public T1 read(JsonReader in) throws IOException {
-						T1 result = typeAdapter.read(in);
-						if (result != null && !rawType.isInstance(result)) {
-							throw new JsonSyntaxException("Expected a " + rawType.getName()
-							+ " but was " + result.getClass().getName());
-						}
-						return result;
-					}
-				};
-			}
-			@Override public String toString() {
-				return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]";
-			}
-		};
+	static interface JsonReaderFunction<T>{
+		T apply(JsonReader reader) throws IOException;
 	}
 }
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
index 80f708733..96a87aee7 100644
--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java
+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
@@ -40,101 +40,103 @@
  * @author Jesse Wilson
  */
 public class TypeToken<T> {
-  final Class<? super T> rawType;
-  final Type type;
-  final int hashCode;
+	final Class<? super T> rawType;
+	final Type type;
+	final int hashCode;
 
-  /**
-   * Constructs a new type literal. Derives represented class from type
-   * parameter.
-   *
-   * <p>Clients create an empty anonymous subclass. Doing so embeds the type
-   * parameter in the anonymous class's type hierarchy so we can reconstitute it
-   * at runtime despite erasure.
-   */
-  @SuppressWarnings("unchecked")
-  protected TypeToken() {
-    this.type = getSuperclassTypeParameter(getClass());
-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);
-    this.hashCode = type.hashCode();
-  }
+	/**
+	 * Constructs a new type literal. Derives represented class from type
+	 * parameter.
+	 *
+	 * <p>Clients create an empty anonymous subclass. Doing so embeds the type
+	 * parameter in the anonymous class's type hierarchy so we can reconstitute it
+	 * at runtime despite erasure.
+	 */
+	@SuppressWarnings("unchecked")
+	protected TypeToken() {
+		this.type = getSuperclassTypeParameter(getClass());
+		this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);
+		this.hashCode = type.hashCode();
+	}
 
-  /**
-   * Unsafe. Constructs a type literal manually.
-   */
-  @SuppressWarnings("unchecked")
-  TypeToken(Type type) {
-    this.type = $Gson$Types.canonicalize(Objects.requireNonNull(type));
-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);
-    this.hashCode = this.type.hashCode();
-  }
+	/**
+	 * Unsafe. Constructs a type literal manually.
+	 */
+	@SuppressWarnings("unchecked")
+	TypeToken(Type type) {
+		this.type = $Gson$Types.canonicalize(Objects.requireNonNull(type));
+		this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);
+		this.hashCode = this.type.hashCode();
+	}
 
-  /**
-   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize
-   * canonical form}.
-   */
-  static Type getSuperclassTypeParameter(Class<?> subclass) {
-    Type superclass = subclass.getGenericSuperclass();
-    if (superclass instanceof Class) {
-      throw new RuntimeException("Missing type parameter.");
-    }
-    ParameterizedType parameterized = (ParameterizedType) superclass;
-    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);
-  }
+	/**
+	 * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize
+	 * canonical form}.
+	 */
+	static Type getSuperclassTypeParameter(Class<?> subclass) {
+		Type superclass = subclass.getGenericSuperclass();
+		if (superclass instanceof Class) {
+			throw new RuntimeException("Missing type parameter.");
+		}
+		ParameterizedType parameterized = (ParameterizedType) superclass;
+		return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);
+	}
 
-  /**
-   * Returns the raw (non-generic) type for this type.
-   */
-  public final Class<? super T> getRawType() {
-    return rawType;
-  }
+	/**
+	 * Returns the raw (non-generic) type for this type.
+	 */
+	public final Class<? super T> getRawType() {
+		return rawType;
+	}
 
-  /**
-   * Gets underlying {@code Type} instance.
-   */
-  public final Type getType() {
-    return type;
-  }
+	/**
+	 * Gets underlying {@code Type} instance.
+	 */
+	public final Type getType() {
+		return type;
+	}
 
-  @Override public final int hashCode() {
-    return this.hashCode;
-  }
+	@Override public final int hashCode() {
+		return this.hashCode;
+	}
 
-  @Override public final boolean equals(Object o) {
-    return o instanceof TypeToken<?>
-        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);
-  }
+	@Override 
+	public final boolean equals(Object o) {
+		return o instanceof TypeToken<?>
+		&& $Gson$Types.equals(type, ((TypeToken<?>) o).type);
+	}
 
-  @Override public final String toString() {
-    return $Gson$Types.typeToString(type);
-  }
+	@Override 
+	public final String toString() {
+		return $Gson$Types.typeToString(type);
+	}
 
-  /**
-   * Gets type literal for the given {@code Type} instance.
-   */
-  public static TypeToken<?> get(Type type) {
-    return new TypeToken<>(type);
-  }
+	/**
+	 * Gets type literal for the given {@code Type} instance.
+	 */
+	public static TypeToken<?> get(Type type) {
+		return new TypeToken<>(type);
+	}
 
-  /**
-   * Gets type literal for the given {@code Class} instance.
-   */
-  public static <T> TypeToken<T> get(Class<T> type) {
-    return new TypeToken<>(type);
-  }
+	/**
+	 * Gets type literal for the given {@code Class} instance.
+	 */
+	public static <T> TypeToken<T> get(Class<T> type) {
+		return new TypeToken<>(type);
+	}
 
-  /**
-   * Gets type literal for the parameterized type represented by applying {@code typeArguments} to
-   * {@code rawType}.
-   */
-  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {
-    return new TypeToken<>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
-  }
+	/**
+	 * Gets type literal for the parameterized type represented by applying {@code typeArguments} to
+	 * {@code rawType}.
+	 */
+	public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {
+		return new TypeToken<>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
+	}
 
-  /**
-   * Gets type literal for the array type whose elements are all instances of {@code componentType}.
-   */
-  public static TypeToken<?> getArray(Type componentType) {
-    return new TypeToken<>($Gson$Types.arrayOf(componentType));
-  }
+	/**
+	 * Gets type literal for the array type whose elements are all instances of {@code componentType}.
+	 */
+	public static TypeToken<?> getArray(Type componentType) {
+		return new TypeToken<>($Gson$Types.arrayOf(componentType));
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index f97a7b23a..39168728d 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -266,9 +266,6 @@
 	 */
 	private int[] stack = new int[32];
 	private int stackSize = 0;
-	{
-		stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
-	}
 
 	/*
 	 * The path members. It corresponds directly to stack: At indices where the
@@ -285,6 +282,8 @@
 	 * Creates a new instance that reads a JSON-encoded stream from {@code in}.
 	 */
 	public JsonReader(Reader in) {
+		stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
+		
 		if (in == null) {
 			throw new NullPointerException("in == null");
 		}
@@ -634,16 +633,15 @@ private int peekKeyword() throws IOException {
 
 	private int peekNumber() throws IOException {
 		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-		char[] buffer = this.buffer;
-		int p = pos;
-		int l = limit;
-
-		long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
-		boolean negative = false;
-		boolean fitsInLong = true;
-		int last = NUMBER_CHAR_NONE;
+		var buffer = this.buffer;
+		var p = pos;
+		var l = limit;
 
-		int i = 0;
+		var value = 0L; // Negative to accommodate Long.MIN_VALUE more easily.
+		var negative = false;
+		var fitsInLong = true;
+		var last = NUMBER_CHAR_NONE;
+		var i = 0;
 
 		charactersOfNumber:
 			for (; true; i++) {
@@ -882,10 +880,11 @@ public double nextDouble() throws IOException {
 			p = doPeek();
 		}
 
+		var pathIndices = this.pathIndices;
 		if (p == PEEKED_LONG) {
 			peeked = PEEKED_NONE;
 			pathIndices[stackSize - 1]++;
-			return (double) peekedLong;
+			return peekedLong;
 		}
 
 		if (p == PEEKED_NUMBER) {
@@ -927,6 +926,7 @@ public long nextLong() throws IOException {
 			p = doPeek();
 		}
 
+		var pathIndices = this.pathIndices;
 		if (p == PEEKED_LONG) {
 			peeked = PEEKED_NONE;
 			pathIndices[stackSize - 1]++;
@@ -977,9 +977,9 @@ public long nextLong() throws IOException {
 	 *     malformed.
 	 */
 	private String nextQuotedValue(char quote) throws IOException {
-		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-		char[] buffer = this.buffer;
+		var buffer = this.buffer;
 		StringBuilder builder = null;
+		
 		while (true) {
 			int p = pos;
 			int l = limit;
@@ -993,10 +993,10 @@ private String nextQuotedValue(char quote) throws IOException {
 					int len = p - start - 1;
 					if (builder == null) {
 						return new String(buffer, start, len);
-					} else {
-						builder.append(buffer, start, len);
-						return builder.toString();
 					}
+					
+					builder.append(buffer, start, len);
+					return builder.toString();
 				} else if (c == '\\') {
 					pos = p;
 					int len = p - start - 1;
@@ -1033,7 +1033,9 @@ private String nextQuotedValue(char quote) throws IOException {
 	@SuppressWarnings("fallthrough")
 	private String nextUnquotedValue() throws IOException {
 		StringBuilder builder = null;
-		int i = 0;
+		var i = 0;
+		var buffer = this.buffer;
+		var limit = this.limit;
 
 		findNonLiteralCharacter:
 			while (true) {
@@ -1064,9 +1066,8 @@ private String nextUnquotedValue() throws IOException {
 				if (i < buffer.length) {
 					if (fillBuffer(i + 1)) {
 						continue;
-					} else {
-						break;
 					}
+					break;
 				}
 
 				// use a StringBuilder when the value is too long. This is too long to be a number!
@@ -1081,14 +1082,14 @@ private String nextUnquotedValue() throws IOException {
 				}
 			}
 
-		String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
+		String result = (builder == null) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
 		pos += i;
 		return result;
 	}
 
 	private void skipQuotedValue(char quote) throws IOException {
-		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-		char[] buffer = this.buffer;
+		var buffer = this.buffer;
+		
 		do {
 			int p = pos;
 			int l = limit;
@@ -1115,7 +1116,10 @@ private void skipQuotedValue(char quote) throws IOException {
 
 	private void skipUnquotedValue() throws IOException {
 		do {
-			int i = 0;
+			var i = 0;
+			var limit = this.limit;
+			var buffer = this.buffer;
+			
 			for (; pos + i < limit; i++) {
 				switch (buffer[pos + i]) {
 				case '/':
@@ -1220,7 +1224,8 @@ public void close() throws IOException {
 	 * stream contains unrecognized or unhandled values.
 	 */
 	public void skipValue() throws IOException {
-		int count = 0;
+		var count = 0;
+		
 		do {
 			int p = peeked;
 			if (p == PEEKED_NONE) {
@@ -1271,7 +1276,8 @@ private void push(int newTop) {
 	 * false.
 	 */
 	private boolean fillBuffer(int minimum) throws IOException {
-		char[] buffer = this.buffer;
+		var buffer = this.buffer;
+		
 		lineStart -= pos;
 		if (limit != pos) {
 			limit -= pos;
@@ -1281,8 +1287,10 @@ private boolean fillBuffer(int minimum) throws IOException {
 		}
 
 		pos = 0;
-		int total;
-		while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
+		var lineNumber = this.lineNumber;
+		var in = this.in;
+		
+		for(int total; (total = in.read(buffer, limit, buffer.length - limit)) != -1;) {
 			limit += total;
 
 			// if this is the first read, consume an optional byte order mark (BOM) if it exists
@@ -1314,9 +1322,10 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
 		 * before any (potentially indirect) call to fillBuffer() and reread both
 		 * 'p' and 'l' after any (potentially indirect) call to the same method.
 		 */
-		char[] buffer = this.buffer;
-		int p = pos;
-		int l = limit;
+		var buffer = this.buffer;
+		var p = pos;
+		var l = limit;
+		
 		while (true) {
 			if (p == l) {
 				pos = p;
@@ -1389,9 +1398,8 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
 		}
 		if (throwOnEof) {
 			throw new EOFException("End of input" + locationString());
-		} else {
-			return -1;
 		}
+		return -1;
 	}
 
 	private void checkLenient() throws IOException {
@@ -1406,6 +1414,9 @@ private void checkLenient() throws IOException {
 	 * caller.
 	 */
 	private void skipToEndOfLine() throws IOException {
+		var limit = this.limit;
+		var buffer = this.buffer;
+		
 		while (pos < limit || fillBuffer(1)) {
 			char c = buffer[pos++];
 			if (c == '\n') {
@@ -1422,9 +1433,13 @@ private void skipToEndOfLine() throws IOException {
 	 * @param toFind a string to search for. Must not contain a newline.
 	 */
 	private boolean skipTo(String toFind) throws IOException {
-		int length = toFind.length();
+		var length = toFind.length();
+		var buffer = this.buffer;
+		
 		outer:
 			for (; pos + length <= limit || fillBuffer(length); pos++) {
+				var pos = this.pos;
+				
 				if (buffer[pos] == '\n') {
 					lineNumber++;
 					lineStart = pos + 1;
@@ -1440,11 +1455,12 @@ private boolean skipTo(String toFind) throws IOException {
 		return false;
 	}
 
-	@Override public String toString() {
+	@Override 
+	public String toString() {
 		return getClass().getSimpleName() + locationString();
 	}
 
-	String locationString() {
+	private String locationString() {
 		int line = lineNumber + 1;
 		int column = pos - lineStart + 1;
 		return " at line " + line + " column " + column + " path " + getPath();
@@ -1455,7 +1471,11 @@ String locationString() {
 	 * the current location in the JSON value.
 	 */
 	public String getPath() {
-		StringBuilder result = new StringBuilder().append('$');
+		var result = new StringBuilder("$");
+		var stack = this.stack;
+		var pathNames = this.pathNames;
+		var pathIndices = this.pathIndices;
+		
 		for (int i = 0, size = stackSize; i < size; i++) {
 			switch (stack[i]) {
 			case JsonScope.EMPTY_ARRAY:
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index 2cc6212e9..105d604eb 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -168,9 +168,6 @@
 
 	private int[] stack = new int[32];
 	private int stackSize = 0;
-	{
-		push(EMPTY_DOCUMENT);
-	}
 
 	/**
 	 * A string containing a full set of spaces for a single level of
@@ -182,11 +179,8 @@
 	 * The name/value separator; either ":" or ": ".
 	 */
 	private String separator = ":";
-
-	private boolean htmlSafe;
-
+	private String[] replacements = REPLACEMENT_CHARS;
 	private String deferredName;
-
 	private boolean serializeNulls = true;
 
 	/**
@@ -195,6 +189,8 @@
 	 * {@link java.io.BufferedWriter BufferedWriter} if necessary.
 	 */
 	public JsonWriter(Writer out) {
+		stack[stackSize++] = EMPTY_DOCUMENT;
+		
 		if (out == null) {
 			throw new NullPointerException("out == null");
 		}
@@ -227,7 +223,7 @@ public final void setIndent(String indent) {
 	 * corresponding escape sequences.
 	 */
 	public final void setHtmlSafe(boolean htmlSafe) {
-		this.htmlSafe = htmlSafe;
+		this.replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
 	}
 
 	/**
@@ -235,7 +231,7 @@ public final void setHtmlSafe(boolean htmlSafe) {
 	 * and XML documents.
 	 */
 	public final boolean isHtmlSafe() {
-		return htmlSafe;
+		return this.replacements == HTML_SAFE_REPLACEMENT_CHARS;
 	}
 
 	/**
@@ -262,7 +258,8 @@ public final boolean getSerializeNulls() {
 	 */
 	public JsonWriter beginArray() throws IOException {
 		writeDeferredName();
-		return open(EMPTY_ARRAY, "[");
+		open(EMPTY_ARRAY, '[');
+		return this;
 	}
 
 	/**
@@ -271,7 +268,7 @@ public JsonWriter beginArray() throws IOException {
 	 * @return this writer.
 	 */
 	public JsonWriter endArray() throws IOException {
-		return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+		return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ']');
 	}
 
 	/**
@@ -282,7 +279,8 @@ public JsonWriter endArray() throws IOException {
 	 */
 	public JsonWriter beginObject() throws IOException {
 		writeDeferredName();
-		return open(EMPTY_OBJECT, "{");
+		open(EMPTY_OBJECT, '{');
+		return this;
 	}
 
 	/**
@@ -291,26 +289,27 @@ public JsonWriter beginObject() throws IOException {
 	 * @return this writer.
 	 */
 	public JsonWriter endObject() throws IOException {
-		return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+		return close(EMPTY_OBJECT, NONEMPTY_OBJECT, '}');
 	}
 
 	/**
 	 * Enters a new scope by appending any necessary whitespace and the given
 	 * bracket.
 	 */
-	private JsonWriter open(int empty, String openBracket) throws IOException {
+	private void open(int empty, char openBracket) throws IOException {
 		beforeValue();
-		push(empty);
+		if (stackSize == stack.length) {
+			stack = Arrays.copyOf(stack, stackSize * 2);
+		}
+		stack[stackSize++] = empty;
 		out.write(openBracket);
-		return this;
 	}
 
 	/**
 	 * Closes the current scope by appending any necessary whitespace and the
 	 * given bracket.
 	 */
-	private JsonWriter close(int empty, int nonempty, String closeBracket)
-			throws IOException {
+	private JsonWriter close(int empty, int nonempty, char closeBracket) throws IOException {
 		int context = peek();
 		if (context != nonempty && context != empty) {
 			throw new IllegalStateException("Nesting problem.");
@@ -327,13 +326,6 @@ private JsonWriter close(int empty, int nonempty, String closeBracket)
 		return this;
 	}
 
-	private void push(int newTop) {
-		if (stackSize == stack.length) {
-			stack = Arrays.copyOf(stack, stackSize * 2);
-		}
-		stack[stackSize++] = newTop;
-	}
-
 	/**
 	 * Returns the value on the top of the stack.
 	 */
@@ -344,13 +336,6 @@ private int peek() {
 		return stack[stackSize - 1];
 	}
 
-	/**
-	 * Replace the value on the top of the stack with the given value.
-	 */
-	private void replaceTop(int topOfStack) {
-		stack[stackSize - 1] = topOfStack;
-	}
-
 	/**
 	 * Encodes the property name.
 	 *
@@ -408,7 +393,7 @@ public JsonWriter jsonValue(String value) throws IOException {
 		}
 		writeDeferredName();
 		beforeValue();
-		out.append(value);
+		out.write(value);
 		return this;
 	}
 
@@ -471,7 +456,7 @@ public JsonWriter value(double value) throws IOException {
 			throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
 		}
 		beforeValue();
-		out.append(Double.toString(value));
+		out.write(Double.toString(value));
 		return this;
 	}
 
@@ -505,7 +490,7 @@ public JsonWriter value(Number value) throws IOException {
 			throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
 		}
 		beforeValue();
-		out.append(string);
+		out.write(string);
 		return this;
 	}
 
@@ -538,10 +523,13 @@ public void close() throws IOException {
 	}
 
 	private void string(String value) throws IOException {
-		String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
-		out.write("\"");
+		var replacements = this.replacements;
+		var out = this.out;
 		int last = 0;
 		int length = value.length();
+		
+		out.write('"');
+		
 		for (int i = 0; i < length; i++) {
 			char c = value.charAt(i);
 			String replacement;
@@ -566,17 +554,13 @@ private void string(String value) throws IOException {
 		if (last < length) {
 			out.write(value, last, length - last);
 		}
-		out.write("\"");
+		out.write('"');
 	}
 
 	private void newline() throws IOException {
-		if (indent == null) {
-			return;
-		}
-
-		out.write("\n");
-		for (int i = 1, size = stackSize; i < size; i++) {
-			out.write(indent);
+		if (indent != null) {
+			out.write('\n');
+			out.write(indent.repeat(stackSize - 1));
 		}
 	}
 
@@ -592,7 +576,7 @@ private void beforeName() throws IOException {
 			throw new IllegalStateException("Nesting problem.");
 		}
 		newline();
-		replaceTop(DANGLING_NAME);
+		stack[stackSize - 1] = DANGLING_NAME;
 	}
 
 	/**
@@ -602,30 +586,29 @@ private void beforeName() throws IOException {
 	 */
 	private void beforeValue() throws IOException {
 		switch (peek()) {
-		case NONEMPTY_DOCUMENT:
-			throw new IllegalStateException("JSON must have only one top-level value.");
-			// fall-through
-		case EMPTY_DOCUMENT: // first in document
-			replaceTop(NONEMPTY_DOCUMENT);
-			break;
-
-		case EMPTY_ARRAY: // first in array
-			replaceTop(NONEMPTY_ARRAY);
-			newline();
-			break;
-
-		case NONEMPTY_ARRAY: // another in array
-			out.append(',');
-			newline();
-			break;
-
-		case DANGLING_NAME: // value for name
-			out.append(separator);
-			replaceTop(NONEMPTY_OBJECT);
-			break;
-
-		default:
-			throw new IllegalStateException("Nesting problem.");
+			case NONEMPTY_DOCUMENT:
+				throw new IllegalStateException("JSON must have only one top-level value.");
+				// fall-through
+			case EMPTY_DOCUMENT: // first in document
+			stack[stackSize - 1] = NONEMPTY_DOCUMENT;
+				break;
+	
+			case EMPTY_ARRAY: // first in array
+			stack[stackSize - 1] = NONEMPTY_ARRAY;
+				newline();
+				break;
+	
+			case NONEMPTY_ARRAY: // another in array
+				out.write(',');
+				newline();
+				break;
+	
+			case DANGLING_NAME: // value for name
+				out.write(separator);
+			stack[stackSize - 1] = NONEMPTY_OBJECT;
+				break;
+	
+			default: throw new IllegalStateException("Nesting problem.");
 		}
 	}
-}
+}
\ No newline at end of file
diff --git a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 80ca4b2f2..a0bff4603 100644
--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -175,7 +175,7 @@ public void write(JsonWriter out, Person person) throws IOException {
       gson.fromJson(json, Truck.class);
       fail();
     } catch (JsonSyntaxException expected) {}
-    gson = Gson.newBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).build();
+    gson = Gson.newBuilder().registerTypeAdapter(Person.class, TypeAdapter.nullSafe(typeAdapter)).build();
     assertEquals("{\"horsePower\":1.0,\"passengers\":[null,\"jesse,30\"]}",
         gson.toJson(truck, Truck.class));
     truck = gson.fromJson(json, Truck.class);
