diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 7631bc983..eb0b7238c 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -30,6 +30,7 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -84,6 +85,7 @@
   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();
+  private final LinkedHashMap<Class, Object> defaultValues = new LinkedHashMap<Class, Object>();
   private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
   private String datePattern;
   private int dateStyle = DateFormat.DEFAULT;
@@ -94,7 +96,12 @@
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
   private boolean lenient = DEFAULT_LENIENT;
-  private MissingFieldHandlingStrategy missingFieldHandlingStrategy;
+  private MissingFieldHandlingStrategy missingFieldHandlingStrategy = new MissingFieldHandlingStrategy() {
+    @Override
+    public Object handle(TypeToken typeToken, String fieldName) {
+      return  defaultValues.get(typeToken.getRawType());
+    }
+  };
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -361,11 +368,27 @@ public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strateg
    * @param strategy a strategy to determine missing field's default values during deserialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    */
-  public GsonBuilder addMissingFieldHandlingStrategy(MissingFieldHandlingStrategy strategy) {
+  public GsonBuilder useMissingFieldHandlingStrategy(MissingFieldHandlingStrategy strategy) {
     this.missingFieldHandlingStrategy = strategy;
     return this;
   }
 
+  /**
+   * Configure Gson to register a default value for a type given which will be used when Gson didn't found any field's
+   * value in JSON.
+   *
+   * To maintain the backward compatibility, Gson still sets the missing fields as null if
+   * no default value is registered.
+   *
+   * @param clazz a class type to register a default value.
+   * @param value default value to be used for the type provided.
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   */
+  public GsonBuilder registerDefaultValue(Class clazz, Object value) {
+    defaultValues.put(clazz, value);
+    return this;
+  }
+
   /**
    * Configures Gson to output Json that fits in a page for pretty printing. This option only
    * affects Json serialization.
diff --git a/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java b/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java
index 3154ec1b6..3decd1c33 100644
--- a/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java
+++ b/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java
@@ -21,7 +21,8 @@
 /**
  * A strategy that is used to determine the value to assign to the field whose node was
  * missing in Json.
- * This strategy is implemented by the user and should be passed to {@link GsonBuilder#addMissingFieldHandlingStrategy(MissingFieldHandlingStrategy)} method
+ * This strategy is implemented by the user and should be passed to
+ * {@link GsonBuilder#useMissingFieldHandlingStrategy(MissingFieldHandlingStrategy)} method
  * so that Gson can use it.
  * The {@link #handle(TypeToken, String)} is used by the Gson to determine the default value
  * for a field based on the {@link TypeToken} and fieldName passed.
@@ -29,5 +30,5 @@
  * @author Prateek Jain
  */
 public interface MissingFieldHandlingStrategy {
-    Object handle(TypeToken type, String fieldName);
+  Object handle(TypeToken type, String fieldName);
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index aa93e2a6e..43984bfbc 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -248,7 +248,9 @@ private void initializeMissingFields(T instance) {
       for (BoundField field : uninitializedFields) {
         try {
           Object defaultValue = missingFieldHandlingStrategy.handle(field.typeToken, field.name);
-          field.set(instance, defaultValue);
+          if (defaultValue != null) {
+            field.set(instance, defaultValue);
+          }
         } catch (IllegalAccessException e) {
           throw new AssertionError(e);
         }
diff --git a/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java b/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java
index 6b62c047a..54054b537 100644
--- a/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java
@@ -25,8 +25,9 @@
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
 
 /**
  * Unit tests for {@link MissingFieldHandlingStrategy}
@@ -36,71 +37,120 @@
 public class MissingFieldHandlingStrategyTest {
 
   @Test
-  public void shouldAssignFieldToDefaultValues() throws Exception {
-    MissingFieldHandlingStrategy missingFieldHandlingStrategy = getMissingFieldHandlingStrategy();
-    Gson gson = new GsonBuilder().
-        addMissingFieldHandlingStrategy(missingFieldHandlingStrategy).create();
+  public void shouldAssignFieldToDefaultValuesUsingDefaultStrategy() throws Exception {
+    Gson gson = new GsonBuilder()
+        .registerDefaultValue(Optional.class, Optional.absent())
+        .create();
     JsonObject jsonObject = new JsonObject();
 
-    Protocol protocol = gson.fromJson(jsonObject, Protocol.class);
+    ObjectWithOptionalFields objectWithOptionalFields =
+        gson.fromJson(jsonObject, ObjectWithOptionalFields.class);
 
-    assertThat(protocol.name, is("HTTP"));
-    assertThat(protocol.version, is("1.1"));
+    assertFalse(objectWithOptionalFields.name.isPresent());
+    assertFalse(objectWithOptionalFields.version.isPresent());
   }
 
   @Test
   public void shouldNotTreatNullFieldAsMissingField() throws Exception {
-    MissingFieldHandlingStrategy missingFieldHandlingStrategy = getMissingFieldHandlingStrategy();
-    Gson gson = new GsonBuilder().
-        addMissingFieldHandlingStrategy(missingFieldHandlingStrategy).create();
+    Gson gson = new GsonBuilder()
+        .registerDefaultValue(Optional.class, Optional.absent())
+        .create();
 
     JsonObject jsonObject = new JsonObject();
     jsonObject.add("name", null);
     jsonObject.add("version", null);
 
-    Protocol protocol = gson.fromJson(jsonObject, Protocol.class);
+    ObjectWithOptionalFields objectWithOptionalFields =
+        gson.fromJson(jsonObject, ObjectWithOptionalFields.class);
 
-    assertNull(protocol.name);
-    assertNull(protocol.version);
+    assertNull(objectWithOptionalFields.name);
+    assertNull(objectWithOptionalFields.version);
   }
 
   @Test
-  public void shouldRespectSerializedNameAnnotation() throws Exception {
+  public void shouldUseCustomMissingFieldHandlingStrategy() throws Exception {
     MissingFieldHandlingStrategy strategy = new MissingFieldHandlingStrategy() {
       @Override
-      public Object handle(TypeToken type, String fieldName) {
+      public Object handle(TypeToken typeToken, String fieldName) {
         if ("f1".equals(fieldName))
           return "1.1";
         return "";
       }
     };
     Gson gson = new GsonBuilder().
-        addMissingFieldHandlingStrategy(strategy).create();
+        useMissingFieldHandlingStrategy(strategy).create();
     JsonObject jsonObject = new JsonObject();
 
-    assertThat(gson.fromJson(jsonObject, ObjectWithSerializedAnnotatin.class).v, is("1.1"));
+    assertThat(gson.fromJson(jsonObject, ObjectWithSerializedAnnotation.class).v, is("1.1"));
   }
 
-  private MissingFieldHandlingStrategy getMissingFieldHandlingStrategy() {
-    return new MissingFieldHandlingStrategy() {
-      @Override
-      public Object handle(TypeToken type, String fieldName) {
-        if ("name".equals(fieldName))
-          return "HTTP";
-        if ("version".equals(fieldName))
-          return "1.1";
-        return "";
-      }
-    };
+  @Test
+  public void shouldNotOverrideNoArgsConstructorValuesIfDefaultValueIsNotRegistered() throws Exception {
+    Gson gson = new GsonBuilder().create();
+    JsonObject jsonObject = new JsonObject();
+
+    assertThat(gson.fromJson(jsonObject, OnjectWithNoArgConstructor.class).stringValues, is("DEFAULT"));
   }
 
-  private static class Protocol {
-    private String name;
-    private String version;
+  private static class ObjectWithOptionalFields {
+    private Optional<String> name;
+    private Optional<String> version;
   }
 
-  private static class ObjectWithSerializedAnnotatin {
+  private static class ObjectWithSerializedAnnotation {
     @SerializedName(value = "f1")
     private String v;
   }
+
+  private static class OnjectWithNoArgConstructor {
+    private String stringValues;
+
+    public OnjectWithNoArgConstructor() {
+      this.stringValues = "DEFAULT";
+    }
+  }
+
+  static abstract class Optional<T> {
+    abstract boolean isPresent();
+
+    abstract T get();
+
+    static Optional absent() {
+      return new Absent();
+    }
+
+    static <T> Optional<T> of(T object) {
+      return new Present(object);
+    }
+  }
+
+  static class Absent<T> extends Optional<T> {
+    @Override
+    boolean isPresent() {
+      return false;
+    }
+
+    @Override
+    T get() {
+      throw new IllegalStateException("Optional.get() cannot be called on an absent value");
+    }
+  }
+
+  static class Present<T> extends Optional<T> {
+    T obj;
+
+    Present(T obj) {
+      this.obj = obj;
+    }
+
+    @Override
+    boolean isPresent() {
+      return true;
+    }
+
+    @Override
+    T get() {
+      return obj;
+    }
+  }
 }
