diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapterFactory.java
new file mode 100644
index 000000000..12a7f60a1
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapterFactory.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import com.google.gson.annotations.CustomDateFormat;
+import com.google.gson.reflect.TypeToken;
+
+import java.lang.annotation.Annotation;
+import java.sql.Timestamp;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * This type adapter factory supports three subclasses of date: {@link Date}, {@link Timestamp}, and
+ * {@link java.sql.Date}. {@link CustomDateFormat} annotation is supported.
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+final class DefaultDateTypeAdapterFactory implements ParametrizedTypeAdapterFactory {
+
+  private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
+
+  private static List<Class> supported  = Arrays.asList(new Class[] {Date.class, Timestamp.class, java.sql.Date.class});
+
+  private final DateFormat enUsFormat;
+  private final DateFormat localFormat;
+
+  DefaultDateTypeAdapterFactory() {
+    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
+      DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+  }
+
+  DefaultDateTypeAdapterFactory(String datePattern) {
+    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+  }
+
+  DefaultDateTypeAdapterFactory(int style) {
+    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+  }
+
+  public DefaultDateTypeAdapterFactory(int dateStyle, int timeStyle) {
+    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
+      DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+  }
+
+  DefaultDateTypeAdapterFactory(DateFormat enUsFormat, DateFormat localFormat) {
+    this.enUsFormat = enUsFormat;
+    this.localFormat = localFormat;
+  }
+
+  @Override
+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+    return create(gson, type, new Annotation[]{});
+  }
+
+  @Override
+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type, Annotation[] annotations) {
+
+    if (!supported.contains(type.getRawType())) {
+      return null;
+    }
+
+    SimpleDateFormat customFormat = null;
+    for (Annotation annotation : annotations) {
+      if (annotation instanceof CustomDateFormat) {
+        customFormat = processDateFormatAnnotation((CustomDateFormat) annotation);
+        break;
+      }
+    }
+
+    if (customFormat == null && type.getRawType().isAnnotationPresent(CustomDateFormat.class)) {
+      customFormat = processDateFormatAnnotation(type.getRawType().getAnnotation(CustomDateFormat.class));
+    }
+
+    return new GeneralDateTypeAdapter<T>(type, enUsFormat, localFormat, customFormat);
+  }
+
+  private static SimpleDateFormat processDateFormatAnnotation(CustomDateFormat dateFormatAnnotation) {
+    String pattern = dateFormatAnnotation.value();
+    Locale locale;
+    if (!dateFormatAnnotation.locale().isEmpty()) {
+      locale = localeFromString(dateFormatAnnotation.locale());
+    } else {
+      locale = Locale.getDefault();
+    }
+    return new  SimpleDateFormat(pattern, locale);
+  }
+
+  private static Locale localeFromString(String localeString) {
+    String parts[] = localeString.split("_");
+    if (parts.length == 0 || parts.length > 3)
+      throw new IllegalArgumentException("Invalid locale string: \"" + localeString + "\"");
+    if (parts.length == 1) return new Locale(parts[0]);
+    else if (parts.length == 2
+      || (parts.length == 3 && parts[2].startsWith("#")))
+      return new Locale(parts[0], parts[1]);
+    else return new Locale(parts[0], parts[1], parts[2]);
+  }
+
+  @Override
+  public String toString() {
+    return SIMPLE_NAME +
+      '(' + localFormat.getClass().getSimpleName() + ')';
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/GeneralDateTypeAdapter.java b/gson/src/main/java/com/google/gson/GeneralDateTypeAdapter.java
new file mode 100644
index 000000000..29845f4fe
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/GeneralDateTypeAdapter.java
@@ -0,0 +1,93 @@
+package com.google.gson;
+
+import com.google.gson.internal.bind.util.ISO8601Utils;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+
+import java.io.IOException;
+import java.sql.Timestamp;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.util.Date;
+
+/**
+ * This type adapter supports three subclasses of date: Date, Timestamp, and
+ * java.sql.Date.
+ *
+ * @author Inderjeet Singh
+ * @author Joel Leitch
+ */
+@SuppressWarnings({"unchecked", "WeakerAccess"})
+class GeneralDateTypeAdapter<T> extends TypeAdapter<T> {
+
+  TypeToken<T> type;
+  private DateFormat enUsFormat;
+  private DateFormat localFormat;
+  private DateFormat customFormat;
+
+  @SuppressWarnings("unused") // hide empty constructor
+  private GeneralDateTypeAdapter() {}
+
+  public GeneralDateTypeAdapter(TypeToken<T> type, DateFormat enUsFormat, DateFormat localFormat, DateFormat customFormat) {
+    this.type = type;
+    this.enUsFormat = enUsFormat;
+    this.localFormat = localFormat;
+    this.customFormat = customFormat;
+  }
+
+  @Override
+  public synchronized void write(JsonWriter out, T value) throws IOException {
+    if (value == null) {
+      out.nullValue();
+      return;
+    }
+    String dateFormatAsString;
+    if (customFormat != null) {
+      dateFormatAsString = customFormat.format(value);
+    } else {
+      dateFormatAsString = enUsFormat.format(value);
+    }
+    out.value(dateFormatAsString);
+  }
+
+  @Override
+  public T read(JsonReader in) throws IOException {
+    if (in.peek() == JsonToken.NULL) {
+      in.nextNull();
+      return null;
+    }
+
+    Date date = deserializeToDate(in.nextString());
+
+    Class typeOfT = type.getRawType();
+    if (typeOfT == Date.class) {
+      return (T) date;
+    } else if (typeOfT == Timestamp.class) {
+      return (T) new Timestamp(date.getTime());
+    } else if (typeOfT == java.sql.Date.class) {
+      return (T) new java.sql.Date(date.getTime());
+    } else {
+      throw new IllegalArgumentException(getClass() + " cannot deserialize to " + typeOfT);
+    }
+  }
+
+  private synchronized Date deserializeToDate(String json) {
+    try {
+      if (customFormat != null) return customFormat.parse(json);
+    } catch (ParseException ignored) {}
+    try {
+      return localFormat.parse(json);
+    } catch (ParseException ignored) {}
+    try {
+      return enUsFormat.parse(json);
+    } catch (ParseException ignored) {}
+    try {
+      return ISO8601Utils.parse(json, new ParsePosition(0));
+    } catch (ParseException e) {
+      throw new JsonSyntaxException(json, e);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 28285738e..127c82ecc 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -34,6 +34,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongArray;
 
+import com.google.gson.annotations.Parametrized;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -56,6 +57,8 @@
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
 
+import java.lang.annotation.Annotation;
+
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
  * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}
@@ -395,10 +398,18 @@ static void checkValidFloatingPoint(double value) {
    *     deserialize {@code type}.
    */
   @SuppressWarnings("unchecked")
-  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
-    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
-    if (cached != null) {
-      return (TypeAdapter<T>) cached;
+  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type, Annotation[] annotations) {
+
+    boolean parametrized = false;
+
+    for (Annotation annotation : annotations) {
+      if (annotation instanceof Parametrized) {
+        parametrized = true;
+      }
+    }
+    if (!parametrized) {
+      TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
+      if (cached != null) return (TypeAdapter<T>) cached;
     }
 
     Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();
@@ -420,10 +431,15 @@ static void checkValidFloatingPoint(double value) {
       threadCalls.put(type, call);
 
       for (TypeAdapterFactory factory : factories) {
-        TypeAdapter<T> candidate = factory.create(this, type);
+        TypeAdapter<T> candidate;
+        if (parametrized && factory instanceof ParametrizedTypeAdapterFactory) {
+          candidate = ((ParametrizedTypeAdapterFactory) factory).create(this, type, annotations);
+        } else {
+          candidate = factory.create(this, type);
+        }
         if (candidate != null) {
           call.setDelegate(candidate);
-          typeTokenCache.put(type, candidate);
+          if (!parametrized) typeTokenCache.put(type, candidate); // we don't want to cache parametrized type adapters
           return candidate;
         }
       }
@@ -437,6 +453,15 @@ static void checkValidFloatingPoint(double value) {
     }
   }
 
+  /**
+   * Returns the type adapter for {@code} type.
+   *
+   * @throws IllegalArgumentException if this GSON cannot serialize and
+   *     deserialize {@code type}.
+   */
+  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
+    return getAdapter(type, new Annotation[]{});
+  }
   /**
    * This method is used to get an alternate type adapter for the specified type. This is used
    * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index e6893860b..27f08af3a 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -17,7 +17,6 @@
 package com.google.gson;
 
 import java.lang.reflect.Type;
-import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -572,26 +571,16 @@ public Gson create() {
         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
   }
 
-  @SuppressWarnings("unchecked")
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
       List<TypeAdapterFactory> factories) {
-    DefaultDateTypeAdapter dateTypeAdapter;
-    TypeAdapter<Timestamp> timestampTypeAdapter;
-    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;
+    DefaultDateTypeAdapterFactory dateTypeAdapterFactory;
     if (datePattern != null && !"".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);
-      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);
-      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);
+      dateTypeAdapterFactory = new DefaultDateTypeAdapterFactory(datePattern);
     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);
-      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);
-      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);
+      dateTypeAdapterFactory = new DefaultDateTypeAdapterFactory(dateStyle, timeStyle);
     } else {
       return;
     }
-
-    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));
-    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
-    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
+    factories.add(dateTypeAdapterFactory);
   }
 }
diff --git a/gson/src/main/java/com/google/gson/ParametrizedTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/ParametrizedTypeAdapterFactory.java
new file mode 100644
index 000000000..8d61d5698
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/ParametrizedTypeAdapterFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import com.google.gson.reflect.TypeToken;
+
+import java.lang.annotation.Annotation;
+
+/**
+ * Behaves like an ordinary {@link TypeAdapterFactory} unless field is annotated with {@link com.google.gson.annotations.Parametrized}.
+ * In that case {@link Gson} calls {@link ParametrizedTypeAdapterFactory#create(Gson, TypeToken, Annotation[])} which allows
+ * to produce a {@link TypeAdapter} based on field annotations.
+ */
+public interface ParametrizedTypeAdapterFactory extends TypeAdapterFactory {
+
+  /**
+   * Returns a type adapter for {@code type}, or null if this factory doesn't
+   * support {@code type}.
+   */
+  <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type, Annotation[] annotations);
+}
diff --git a/gson/src/main/java/com/google/gson/annotations/CustomDateFormat.java b/gson/src/main/java/com/google/gson/annotations/CustomDateFormat.java
new file mode 100644
index 000000000..8c65bd5c6
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/CustomDateFormat.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.annotations;
+
+import java.lang.annotation.*;
+import java.sql.Timestamp;
+import java.util.Date;
+
+/**
+ * Used to specify custom serialization/deserialization pattern for {@link Date}, {@link Timestamp}, and {@link java.sql.Date}
+ * @author Andrey Makeev
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface CustomDateFormat {
+    /**
+     * @return the desired date pattern when serialized or deserialized
+     */
+    String value();
+    /**
+     * @return the desired locale of date string when serialized or deserialized
+     */
+    String locale() default "";
+}
diff --git a/gson/src/main/java/com/google/gson/annotations/Parametrized.java b/gson/src/main/java/com/google/gson/annotations/Parametrized.java
new file mode 100644
index 000000000..72f268914
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/annotations/Parametrized.java
@@ -0,0 +1,15 @@
+package com.google.gson.annotations;
+
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+
+import java.lang.annotation.*;
+
+/**
+ * Makes {@link com.google.gson.Gson} use {@link com.google.gson.ParametrizedTypeAdapterFactory#create(Gson, TypeToken, Annotation[])}
+ * @author Andrey Makeev
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Parametrized {
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 13a7bb7eb..3ad7dbbac 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -16,15 +16,14 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonSerializer;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
+import com.google.gson.*;
 import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.annotations.Parametrized;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.reflect.TypeToken;
 
+import java.lang.annotation.Annotation;
+
 /**
  * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the
  * specified class as the default type adapter.
@@ -46,17 +45,24 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
     if (annotation == null) {
       return null;
     }
-    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);
+    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, rawType.getAnnotations());
   }
 
   @SuppressWarnings({ "unchecked", "rawtypes" }) // Casts guarded by conditionals.
   TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
-      TypeToken<?> type, JsonAdapter annotation) {
+                                TypeToken<?> type, JsonAdapter annotation, Annotation[] annotations) {
+    boolean parametrized = false;
+    for (Annotation anno : annotations) {
+      if (anno instanceof Parametrized) parametrized = true;
+    }
+
     Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();
 
     TypeAdapter<?> typeAdapter;
     if (instance instanceof TypeAdapter) {
       typeAdapter = (TypeAdapter<?>) instance;
+    } else if (instance instanceof ParametrizedTypeAdapterFactory && parametrized) {
+      typeAdapter = ((ParametrizedTypeAdapterFactory) instance).create(gson, type, annotations);
     } else if (instance instanceof TypeAdapterFactory) {
       typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);
     } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 42798d059..7c1503480 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -109,10 +109,10 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     TypeAdapter<?> mapped = null;
     if (annotation != null) {
       mapped = jsonAdapterFactory.getTypeAdapter(
-          constructorConstructor, context, fieldType, annotation);
+          constructorConstructor, context, fieldType, annotation, field.getAnnotations());
     }
     final boolean jsonAdapterPresent = mapped != null;
-    if (mapped == null) mapped = context.getAdapter(fieldType);
+    if (mapped == null) mapped = context.getAdapter(fieldType, field.getAnnotations());
 
     final TypeAdapter<?> typeAdapter = mapped;
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterFactoryTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterFactoryTest.java
new file mode 100644
index 000000000..9ebb10d31
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterFactoryTest.java
@@ -0,0 +1,139 @@
+package com.google.gson;
+
+import com.google.gson.annotations.CustomDateFormat;
+import com.google.gson.annotations.Parametrized;
+import junit.framework.TestCase;
+
+import java.util.Date;
+import java.util.TimeZone;
+
+/**
+ * A basic unit test for the {@link DefaultDateTypeAdapterFactory} class.
+ * Created by amak on 6/17/17.
+ */
+public class DefaultDateTypeAdapterFactoryTest extends TestCase {
+  private static class DateTestClass {
+
+    public DateTestClass(Date date) {
+      this.fullDate = date;
+      this.longDate = date;
+      this.mediumDate = date;
+      this.shortDate = date;
+      this.fullDateTime = date;
+      this.longDateTime = date;
+      this.mediumDateTime = date;
+      this.shortDateTime = date;
+      this.isoDateTimeNoTz = date;
+      this.nonCustom = date;
+      this.nonParametrized = date;
+    }
+
+    @Parametrized
+    @CustomDateFormat("EEEE, MMMM d, yyyy")
+    Date fullDate;
+
+    @Parametrized
+    @CustomDateFormat("MMMM d, yyyy")
+    Date longDate;
+
+    @Parametrized
+    @CustomDateFormat("MMM d, yyyy")
+    Date mediumDate;
+
+    @Parametrized
+    @CustomDateFormat("M/d/yy")
+    Date shortDate;
+
+    @Parametrized
+    @CustomDateFormat(value = "EEEE, MMMM d, yyyy h:mm:ss a z", locale = "FR_fr")
+    Date fullDateTime;
+
+    @Parametrized
+    @CustomDateFormat("MMMM d, yyyy h:mm:ss a z")
+    Date longDateTime;
+
+    @Parametrized
+    @CustomDateFormat("MMM d, yyyy h:mm:ss a")
+    Date mediumDateTime;
+
+    @Parametrized
+    @CustomDateFormat("M/d/yy h:mm a")
+    Date shortDateTime;
+
+    @Parametrized
+    @CustomDateFormat("yyyy-MM-dd'T'HH:mm:ss")
+    Date isoDateTimeNoTz;
+
+    @CustomDateFormat("yyyy-MM-dd'T'HH:mm:ssZ")
+    Date nonParametrized;
+
+    Date nonCustom;
+  }
+
+  public void testObjectSerialization() {
+
+    TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+
+    Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").create();
+
+    String dateTestClassJson = gson.toJson(new DateTestClass(new Date(0)));
+
+    assertEquals("{" +
+        "\"fullDate\":\"Thursday, January 1, 1970\"," +
+        "\"longDate\":\"January 1, 1970\"," +
+        "\"mediumDate\":\"Jan 1, 1970\"," +
+        "\"shortDate\":\"1/1/70\"," +
+        "\"fullDateTime\":\"jeudi, janvier 1, 1970 12:00:00 AM UTC\"," +
+        "\"longDateTime\":\"January 1, 1970 12:00:00 AM UTC\"," +
+        "\"mediumDateTime\":\"Jan 1, 1970 12:00:00 AM\"," +
+        "\"shortDateTime\":\"1/1/70 12:00 AM\"," +
+        "\"isoDateTimeNoTz\":\"1970-01-01T00:00:00\"," +
+        "\"nonParametrized\":\"1970-01-01T00:00:00+0000\"," +
+        "\"nonCustom\":\"1970-01-01T00:00:00+0000\"" +
+        "}",
+
+      dateTestClassJson
+    );
+
+    TimeZone.setDefault(defaultTimeZone);
+  }
+
+  public void testObjectDeserialization() {
+
+    TimeZone defaultTimeZone = TimeZone.getDefault();
+    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
+
+    String jsonString = "{" +
+      "\"fullDate\":\"Thursday, January 1, 1970\"," +
+      "\"longDate\":\"January 1, 1970\"," +
+      "\"mediumDate\":\"Jan 1, 1970\"," +
+      "\"shortDate\":\"1/1/70\"," +
+      "\"fullDateTime\":\"jeudi, janvier 1, 1970 12:00:00 AM UTC\"," +
+      "\"longDateTime\":\"January 1, 1970 12:00:00 AM UTC\"," +
+      "\"mediumDateTime\":\"Jan 1, 1970 12:00:00 AM\"," +
+      "\"shortDateTime\":\"1/1/70 12:00 AM\"," +
+      "\"isoDateTimeNoTz\":\"1970-01-01T00:00:00\"," +
+      "\"nonParametrized\":\"1970-01-01T00:00:00+0000\"," +
+      "\"nonCustom\":\"1970-01-01T00:00:00+0000\"" +
+      "}";
+
+    Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").create();
+
+    DateTestClass dateTestClass = gson.fromJson(jsonString, DateTestClass.class);
+
+    assertEquals(dateTestClass.fullDate.getTime(), 0);
+    assertEquals(dateTestClass.longDate.getTime(), 0);
+    assertEquals(dateTestClass.mediumDate.getTime(), 0);
+    assertEquals(dateTestClass.shortDate.getTime(), 0);
+    assertEquals(dateTestClass.fullDateTime.getTime(), 0);
+    assertEquals(dateTestClass.longDateTime.getTime(), 0);
+    assertEquals(dateTestClass.mediumDateTime.getTime(), 0);
+    assertEquals(dateTestClass.shortDateTime.getTime(), 0);
+    assertEquals(dateTestClass.isoDateTimeNoTz.getTime(), 0);
+    assertEquals(dateTestClass.nonParametrized.getTime(), 0);
+    assertEquals(dateTestClass.nonCustom.getTime(), 0);
+
+    TimeZone.setDefault(defaultTimeZone);
+  }
+}
\ No newline at end of file
