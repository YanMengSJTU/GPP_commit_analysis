diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 5208e2c32..26a20c5d3 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -25,7 +25,6 @@
 import java.math.*;
 import java.util.*;
 import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
 import java.util.function.*;
 
 /**
@@ -150,11 +149,6 @@
 		factories.add(TypeAdapters.newFactory(float.class, Float.class,
 				TypeAdapters.FLOAT));
 		factories.add(TypeAdapters.NUMBER_FACTORY);
-		factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);
-		factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);
-		factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));
-		factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));
-		factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);
 		factories.add(TypeAdapters.CHARACTER_FACTORY);
 		factories.add(TypeAdapters.STRING_BUILDER_FACTORY);
 		factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
@@ -285,45 +279,6 @@ public boolean htmlSafe() {
 		return htmlSafe;
 	}
 
-	private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
-		return new TypeAdapter<AtomicLong>() {
-			@Override public void write(JsonWriter out, AtomicLong value) throws IOException {
-				longAdapter.write(out, value.get());
-			}
-			@Override public AtomicLong read(JsonReader in) throws IOException {
-				Number value = longAdapter.read(in);
-				return new AtomicLong(value.longValue());
-			}
-		}.nullSafe();
-	}
-
-	private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {
-		return new TypeAdapter<AtomicLongArray>() {
-			@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {
-				out.beginArray();
-				for (int i = 0, length = value.length(); i < length; i++) {
-					longAdapter.write(out, value.get(i));
-				}
-				out.endArray();
-			}
-			@Override public AtomicLongArray read(JsonReader in) throws IOException {
-				List<Long> list = new ArrayList<>();
-				in.beginArray();
-				while (in.hasNext()) {
-					long value = longAdapter.read(in).longValue();
-					list.add(value);
-				}
-				in.endArray();
-				int length = list.size();
-				AtomicLongArray array = new AtomicLongArray(length);
-				for (int i = 0; i < length; ++i) {
-					array.set(i, list.get(i));
-				}
-				return array;
-			}
-		}.nullSafe();
-	}
-
 	/**
 	 * Returns the type adapter for {@code} type.
 	 *
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index e22fa05a7..ba7ccafa6 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -22,10 +22,7 @@
 import com.google.gson.internal.bind.*;
 import com.google.gson.reflect.*;
 import java.lang.reflect.*;
-import java.sql.*;
-import java.text.*;
 import java.util.*;
-import java.util.Date;
 import java.util.function.*;
 
 /**
@@ -63,384 +60,384 @@
  * @author Jesse Wilson
  */
 public final class GsonBuilder {
-  private Excluder excluder = Excluder.DEFAULT;
-  private Function<Field, String> fieldNamingPolicy = FieldNamingStrategies.IDENTITY;
-  private final Map<Type, InstanceCreator<?>> instanceCreators
-      = new HashMap<>();
-  private final List<TypeAdapterFactory> factories = new ArrayList<>();
-  /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
-  private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();
-  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
-  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
-  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
-  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
-  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+	private Excluder excluder = Excluder.DEFAULT;
+	private Function<Field, String> fieldNamingPolicy = FieldNamingStrategies.IDENTITY;
+	private final Map<Type, InstanceCreator<?>> instanceCreators
+	= new HashMap<>();
+	private final List<TypeAdapterFactory> factories = new ArrayList<>();
+	/** tree-style hierarchy factories. These come after factories for backwards compatibility. */
+	private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();
+	private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
+	private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
+	private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
+	private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
+	private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
 
-  /**
-   * Creates a GsonBuilder instance that can be used to build Gson with various configuration
-   * settings. GsonBuilder follows the builder pattern, and it is typically used by first
-   * invoking various configuration methods to set desired options, and finally calling
-   * {@link #create()}.
-   */
-  GsonBuilder() {}
+	/**
+	 * Creates a GsonBuilder instance that can be used to build Gson with various configuration
+	 * settings. GsonBuilder follows the builder pattern, and it is typically used by first
+	 * invoking various configuration methods to set desired options, and finally calling
+	 * {@link #create()}.
+	 */
+	GsonBuilder() {}
 
-  /**
-   * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
-   * has the same configuration as the previously built Gson instance.
-   *
-   * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
-   */
-  GsonBuilder(Gson gson) {
-    this.excluder = gson.excluder;
-    this.fieldNamingPolicy = gson.fieldNamingStrategy;
-    this.instanceCreators.putAll(gson.instanceCreators);
-    this.serializeNulls = gson.serializeNulls;
-    this.complexMapKeySerialization = gson.complexMapKeySerialization;
-    this.generateNonExecutableJson = gson.generateNonExecutableJson;
-    this.escapeHtmlChars = gson.htmlSafe;
-    this.prettyPrinting = gson.prettyPrinting;
-    this.factories.addAll(gson.builderFactories);
-    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
-  }
+	/**
+	 * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
+	 * has the same configuration as the previously built Gson instance.
+	 *
+	 * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
+	 */
+	GsonBuilder(Gson gson) {
+		this.excluder = gson.excluder;
+		this.fieldNamingPolicy = gson.fieldNamingStrategy;
+		this.instanceCreators.putAll(gson.instanceCreators);
+		this.serializeNulls = gson.serializeNulls;
+		this.complexMapKeySerialization = gson.complexMapKeySerialization;
+		this.generateNonExecutableJson = gson.generateNonExecutableJson;
+		this.escapeHtmlChars = gson.htmlSafe;
+		this.prettyPrinting = gson.prettyPrinting;
+		this.factories.addAll(gson.builderFactories);
+		this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+	}
 
-  /**
-   * Configures Gson to enable versioning support.
-   *
-   * @param ignoreVersionsAfter any field or type marked with a version higher than this value
-   * are ignored during serialization or deserialization.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  public GsonBuilder setVersion(double ignoreVersionsAfter) {
-    excluder = excluder.withVersion(ignoreVersionsAfter);
-    return this;
-  }
+	/**
+	 * Configures Gson to enable versioning support.
+	 *
+	 * @param ignoreVersionsAfter any field or type marked with a version higher than this value
+	 * are ignored during serialization or deserialization.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 */
+	public GsonBuilder setVersion(double ignoreVersionsAfter) {
+		excluder = excluder.withVersion(ignoreVersionsAfter);
+		return this;
+	}
 
-  /**
-   * Configures Gson to excludes all class fields that have the specified modifiers. By default,
-   * Gson will exclude all fields marked transient or static. This method will override that
-   * behavior.
-   *
-   * @param modifiers the field modifiers. You must use the modifiers specified in the
-   * {@link java.lang.reflect.Modifier} class. For example,
-   * {@link java.lang.reflect.Modifier#TRANSIENT},
-   * {@link java.lang.reflect.Modifier#STATIC}.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {
-    excluder = excluder.withModifiers(modifiers);
-    return this;
-  }
+	/**
+	 * Configures Gson to excludes all class fields that have the specified modifiers. By default,
+	 * Gson will exclude all fields marked transient or static. This method will override that
+	 * behavior.
+	 *
+	 * @param modifiers the field modifiers. You must use the modifiers specified in the
+	 * {@link java.lang.reflect.Modifier} class. For example,
+	 * {@link java.lang.reflect.Modifier#TRANSIENT},
+	 * {@link java.lang.reflect.Modifier#STATIC}.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 */
+	public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {
+		excluder = excluder.withModifiers(modifiers);
+		return this;
+	}
 
-  /**
-   * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some
-   * special text. This prevents attacks from third-party sites through script sourcing. See
-   * <a href="http://code.google.com/p/google-gson/issues/detail?id=42">Gson Issue 42</a>
-   * for details.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder generateNonExecutableJson() {
-    this.generateNonExecutableJson = true;
-    return this;
-  }
+	/**
+	 * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some
+	 * special text. This prevents attacks from third-party sites through script sourcing. See
+	 * <a href="http://code.google.com/p/google-gson/issues/detail?id=42">Gson Issue 42</a>
+	 * for details.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.3
+	 */
+	public GsonBuilder generateNonExecutableJson() {
+		this.generateNonExecutableJson = true;
+		return this;
+	}
 
-  /**
-   * Configures Gson to exclude all fields from consideration for serialization or deserialization
-   * that do not have the {@link com.google.gson.annotations.Expose} annotation.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  public GsonBuilder excludeFieldsWithoutExposeAnnotation() {
-    excluder = excluder.excludeFieldsWithoutExposeAnnotation();
-    return this;
-  }
+	/**
+	 * Configures Gson to exclude all fields from consideration for serialization or deserialization
+	 * that do not have the {@link com.google.gson.annotations.Expose} annotation.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 */
+	public GsonBuilder excludeFieldsWithoutExposeAnnotation() {
+		excluder = excluder.excludeFieldsWithoutExposeAnnotation();
+		return this;
+	}
 
-  /**
-   * Configure Gson to serialize null fields. By default, Gson omits all fields that are null
-   * during serialization.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.2
-   */
-  public GsonBuilder serializeNulls() {
-    this.serializeNulls = true;
-    return this;
-  }
+	/**
+	 * Configure Gson to serialize null fields. By default, Gson omits all fields that are null
+	 * during serialization.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.2
+	 */
+	public GsonBuilder serializeNulls() {
+		this.serializeNulls = true;
+		return this;
+	}
 
-  /**
-   * Enabling this feature will only change the serialized form if the map key is
-   * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON
-   * form. The default implementation of map serialization uses {@code toString()}
-   * on the key; however, when this is called then one of the following cases
-   * apply:
-   *
-   * <h3>Maps as JSON objects</h3>
-   * For this case, assume that a type adapter is registered to serialize and
-   * deserialize some {@code Point} class, which contains an x and y coordinate,
-   * to/from the JSON Primitive string value {@code "(x,y)"}. The Java map would
-   * then be serialized as a {@link JsonObject}.
-   *
-   * <p>Below is an example:
-   * <pre>  {@code
-   *   Gson gson = Gson.newBuilder()
-   *       .register(Point.class, new MyPointTypeAdapter())
-   *       .enableComplexMapKeySerialization()
-   *       .build();
-   *
-   *   Map<Point, String> original = new LinkedHashMap<Point, String>();
-   *   original.put(new Point(5, 6), "a");
-   *   original.put(new Point(8, 8), "b");
-   *   System.out.println(gson.toJson(original, type));
-   * }</pre>
-   * The above code prints this JSON object:<pre>  {@code
-   *   {
-   *     "(5,6)": "a",
-   *     "(8,8)": "b"
-   *   }
-   * }</pre>
-   *
-   * <h3>Maps as JSON arrays</h3>
-   * For this case, assume that a type adapter was NOT registered for some
-   * {@code Point} class, but rather the default Gson serialization is applied.
-   * In this case, some {@code new Point(2,3)} would serialize as {@code
-   * {"x":2,"y":5}}.
-   *
-   * <p>Given the assumption above, a {@code Map<Point, String>} will be
-   * serialize as an array of arrays (can be viewed as an entry set of pairs).
-   *
-   * <p>Below is an example of serializing complex types as JSON arrays:
-   * <pre> {@code
-   *   Gson gson = Gson.newBuilder()
-   *       .enableComplexMapKeySerialization()
-   *       .build();
-   *
-   *   Map<Point, String> original = new LinkedHashMap<Point, String>();
-   *   original.put(new Point(5, 6), "a");
-   *   original.put(new Point(8, 8), "b");
-   *   System.out.println(gson.toJson(original, type));
-   * }
-   *
-   * The JSON output would look as follows:
-   * <pre>   {@code
-   *   [
-   *     [
-   *       {
-   *         "x": 5,
-   *         "y": 6
-   *       },
-   *       "a"
-   *     ],
-   *     [
-   *       {
-   *         "x": 8,
-   *         "y": 8
-   *       },
-   *       "b"
-   *     ]
-   *   ]
-   * }</pre>
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.7
-   */
-  public GsonBuilder enableComplexMapKeySerialization() {
-    complexMapKeySerialization = true;
-    return this;
-  }
+	/**
+	 * Enabling this feature will only change the serialized form if the map key is
+	 * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON
+	 * form. The default implementation of map serialization uses {@code toString()}
+	 * on the key; however, when this is called then one of the following cases
+	 * apply:
+	 *
+	 * <h3>Maps as JSON objects</h3>
+	 * For this case, assume that a type adapter is registered to serialize and
+	 * deserialize some {@code Point} class, which contains an x and y coordinate,
+	 * to/from the JSON Primitive string value {@code "(x,y)"}. The Java map would
+	 * then be serialized as a {@link JsonObject}.
+	 *
+	 * <p>Below is an example:
+	 * <pre>  {@code
+	 *   Gson gson = Gson.newBuilder()
+	 *       .register(Point.class, new MyPointTypeAdapter())
+	 *       .enableComplexMapKeySerialization()
+	 *       .build();
+	 *
+	 *   Map<Point, String> original = new LinkedHashMap<Point, String>();
+	 *   original.put(new Point(5, 6), "a");
+	 *   original.put(new Point(8, 8), "b");
+	 *   System.out.println(gson.toJson(original, type));
+	 * }</pre>
+	 * The above code prints this JSON object:<pre>  {@code
+	 *   {
+	 *     "(5,6)": "a",
+	 *     "(8,8)": "b"
+	 *   }
+	 * }</pre>
+	 *
+	 * <h3>Maps as JSON arrays</h3>
+	 * For this case, assume that a type adapter was NOT registered for some
+	 * {@code Point} class, but rather the default Gson serialization is applied.
+	 * In this case, some {@code new Point(2,3)} would serialize as {@code
+	 * {"x":2,"y":5}}.
+	 *
+	 * <p>Given the assumption above, a {@code Map<Point, String>} will be
+	 * serialize as an array of arrays (can be viewed as an entry set of pairs).
+	 *
+	 * <p>Below is an example of serializing complex types as JSON arrays:
+	 * <pre> {@code
+	 *   Gson gson = Gson.newBuilder()
+	 *       .enableComplexMapKeySerialization()
+	 *       .build();
+	 *
+	 *   Map<Point, String> original = new LinkedHashMap<Point, String>();
+	 *   original.put(new Point(5, 6), "a");
+	 *   original.put(new Point(8, 8), "b");
+	 *   System.out.println(gson.toJson(original, type));
+	 * }
+	 *
+	 * The JSON output would look as follows:
+	 * <pre>   {@code
+	 *   [
+	 *     [
+	 *       {
+	 *         "x": 5,
+	 *         "y": 6
+	 *       },
+	 *       "a"
+	 *     ],
+	 *     [
+	 *       {
+	 *         "x": 8,
+	 *         "y": 8
+	 *       },
+	 *       "b"
+	 *     ]
+	 *   ]
+	 * }</pre>
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.7
+	 */
+	public GsonBuilder enableComplexMapKeySerialization() {
+		complexMapKeySerialization = true;
+		return this;
+	}
 
-  /**
-   * Configures Gson to exclude inner classes during serialization.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder disableInnerClassSerialization() {
-    excluder = excluder.disableInnerClassSerialization();
-    return this;
-  }
+	/**
+	 * Configures Gson to exclude inner classes during serialization.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.3
+	 */
+	public GsonBuilder disableInnerClassSerialization() {
+		excluder = excluder.disableInnerClassSerialization();
+		return this;
+	}
 
-  /**
-   * Configures Gson to apply a specific naming policy strategy to an object's field during
-   * serialization and deserialization.
-   *
-   * @param fieldNamingStrategy the actual naming strategy to apply to the fields
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder setFieldNamingStrategy(Function<Field, String> fieldNamingStrategy) {
-    this.fieldNamingPolicy = fieldNamingStrategy;
-    return this;
-  }
+	/**
+	 * Configures Gson to apply a specific naming policy strategy to an object's field during
+	 * serialization and deserialization.
+	 *
+	 * @param fieldNamingStrategy the actual naming strategy to apply to the fields
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.3
+	 */
+	public GsonBuilder setFieldNamingStrategy(Function<Field, String> fieldNamingStrategy) {
+		this.fieldNamingPolicy = fieldNamingStrategy;
+		return this;
+	}
 
-  /**
-   * Configures Gson to apply a set of exclusion strategies during both serialization and
-   * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
-   * This means that if one of the {@code strategies} suggests that a field (or class) should be
-   * skipped then that field (or object) is skipped during serialization/deserialization.
-   *
-   * @param strategies the set of strategy object to apply during object (de)serialization.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.4
-   */
-  public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
-    for (ExclusionStrategy strategy : strategies) {
-      excluder = excluder.withExclusionStrategy(strategy, true, true);
-    }
-    return this;
-  }
+	/**
+	 * Configures Gson to apply a set of exclusion strategies during both serialization and
+	 * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
+	 * This means that if one of the {@code strategies} suggests that a field (or class) should be
+	 * skipped then that field (or object) is skipped during serialization/deserialization.
+	 *
+	 * @param strategies the set of strategy object to apply during object (de)serialization.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.4
+	 */
+	public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
+		for (ExclusionStrategy strategy : strategies) {
+			excluder = excluder.withExclusionStrategy(strategy, true, true);
+		}
+		return this;
+	}
 
-  /**
-   * Configures Gson to apply the passed in exclusion strategy during serialization.
-   * If this method is invoked numerous times with different exclusion strategy objects
-   * then the exclusion strategies that were added will be applied as a disjunction rule.
-   * This means that if one of the added exclusion strategies suggests that a field (or
-   * class) should be skipped then that field (or object) is skipped during its
-   * serialization.
-   *
-   * @param strategy an exclusion strategy to apply during serialization.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.7
-   */
-  public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {
-    excluder = excluder.withExclusionStrategy(strategy, true, false);
-    return this;
-  }
+	/**
+	 * Configures Gson to apply the passed in exclusion strategy during serialization.
+	 * If this method is invoked numerous times with different exclusion strategy objects
+	 * then the exclusion strategies that were added will be applied as a disjunction rule.
+	 * This means that if one of the added exclusion strategies suggests that a field (or
+	 * class) should be skipped then that field (or object) is skipped during its
+	 * serialization.
+	 *
+	 * @param strategy an exclusion strategy to apply during serialization.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.7
+	 */
+	public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {
+		excluder = excluder.withExclusionStrategy(strategy, true, false);
+		return this;
+	}
 
-  /**
-   * Configures Gson to apply the passed in exclusion strategy during deserialization.
-   * If this method is invoked numerous times with different exclusion strategy objects
-   * then the exclusion strategies that were added will be applied as a disjunction rule.
-   * This means that if one of the added exclusion strategies suggests that a field (or
-   * class) should be skipped then that field (or object) is skipped during its
-   * deserialization.
-   *
-   * @param strategy an exclusion strategy to apply during deserialization.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.7
-   */
-  public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {
-    excluder = excluder.withExclusionStrategy(strategy, false, true);
-    return this;
-  }
+	/**
+	 * Configures Gson to apply the passed in exclusion strategy during deserialization.
+	 * If this method is invoked numerous times with different exclusion strategy objects
+	 * then the exclusion strategies that were added will be applied as a disjunction rule.
+	 * This means that if one of the added exclusion strategies suggests that a field (or
+	 * class) should be skipped then that field (or object) is skipped during its
+	 * deserialization.
+	 *
+	 * @param strategy an exclusion strategy to apply during deserialization.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.7
+	 */
+	public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {
+		excluder = excluder.withExclusionStrategy(strategy, false, true);
+		return this;
+	}
 
-  /**
-   * Configures Gson to output Json that fits in a page for pretty printing. This option only
-   * affects Json serialization.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  public GsonBuilder setPrettyPrinting() {
-    prettyPrinting = true;
-    return this;
-  }
+	/**
+	 * Configures Gson to output Json that fits in a page for pretty printing. This option only
+	 * affects Json serialization.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 */
+	public GsonBuilder enablePrettyPrinting() {
+		prettyPrinting = true;
+		return this;
+	}
 
-  /**
-   * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure
-   * Gson to pass-through HTML characters as is.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder disableHtmlEscaping() {
-    this.escapeHtmlChars = false;
-    return this;
-  }
+	/**
+	 * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure
+	 * Gson to pass-through HTML characters as is.
+	 *
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.3
+	 */
+	public GsonBuilder disableHtmlEscaping() {
+		this.escapeHtmlChars = false;
+		return this;
+	}
 
-  /**
-   * Configures Gson for custom serialization or deserialization. This method combines the
-   * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a
-   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements
-   * all the required interfaces for custom serialization with Gson. If a type adapter was
-   * previously registered for the specified {@code type}, it is overwritten.
-   *
-   * <p>This registers the type specified and no other types: you must manually register related
-   * types! For example, applications registering {@code boolean.class} should also register {@code
-   * Boolean.class}.
-   *
-   * @param type the type definition for the type adapter being registered
-   * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},
-   * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   */
-  @SuppressWarnings({"unchecked", "rawtypes"})
-  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
-    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
-        || typeAdapter instanceof JsonDeserializer<?>
-        || typeAdapter instanceof InstanceCreator<?>
-        || typeAdapter instanceof TypeAdapter<?>);
-    if (typeAdapter instanceof InstanceCreator<?>) {
-      instanceCreators.put(type, (InstanceCreator) typeAdapter);
-    }
-    if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {
-      TypeToken<?> typeToken = TypeToken.get(type);
-      factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));
-    }
-    if (typeAdapter instanceof TypeAdapter<?>) {
-      factories.add(TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter)typeAdapter));
-    }
-    return this;
-  }
+	/**
+	 * Configures Gson for custom serialization or deserialization. This method combines the
+	 * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a
+	 * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements
+	 * all the required interfaces for custom serialization with Gson. If a type adapter was
+	 * previously registered for the specified {@code type}, it is overwritten.
+	 *
+	 * <p>This registers the type specified and no other types: you must manually register related
+	 * types! For example, applications registering {@code boolean.class} should also register {@code
+	 * Boolean.class}.
+	 *
+	 * @param type the type definition for the type adapter being registered
+	 * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},
+	 * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 */
+	@SuppressWarnings({"unchecked", "rawtypes"})
+	public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
+		$Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+		|| typeAdapter instanceof JsonDeserializer<?>
+		|| typeAdapter instanceof InstanceCreator<?>
+		|| typeAdapter instanceof TypeAdapter<?>);
+		if (typeAdapter instanceof InstanceCreator<?>) {
+			instanceCreators.put(type, (InstanceCreator) typeAdapter);
+		}
+		if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {
+			TypeToken<?> typeToken = TypeToken.get(type);
+			factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));
+		}
+		if (typeAdapter instanceof TypeAdapter<?>) {
+			factories.add(TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter)typeAdapter));
+		}
+		return this;
+	}
 
-  /**
-   * Register a factory for type adapters. Registering a factory is useful when the type
-   * adapter needs to be configured based on the type of the field being processed. Gson
-   * is designed to handle a large number of factories, so you should consider registering
-   * them to be at par with registering an individual type adapter.
-   *
-   * @since 2.1
-   */
-  public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
-    factories.add(factory);
-    return this;
-  }
+	/**
+	 * Register a factory for type adapters. Registering a factory is useful when the type
+	 * adapter needs to be configured based on the type of the field being processed. Gson
+	 * is designed to handle a large number of factories, so you should consider registering
+	 * them to be at par with registering an individual type adapter.
+	 *
+	 * @since 2.1
+	 */
+	public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
+		factories.add(factory);
+		return this;
+	}
 
-  /**
-   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.
-   * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and
-   * a {@link JsonDeserializer}. If a type adapter was previously registered for the specified
-   * type hierarchy, it is overridden. If a type adapter is registered for a specific type in
-   * the type hierarchy, it will be invoked instead of the one registered for the type hierarchy.
-   *
-   * @param baseType the class definition for the type adapter being registered for the base class
-   *        or interface
-   * @param typeAdapter This object must implement at least one of {@link TypeAdapter},
-   *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.7
-   */
-  @SuppressWarnings({"unchecked", "rawtypes"})
-  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
-    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
-        || typeAdapter instanceof JsonDeserializer<?>
-        || typeAdapter instanceof TypeAdapter<?>);
-    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
-      hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
-    }
-    if (typeAdapter instanceof TypeAdapter<?>) {
-      factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));
-    }
-    return this;
-  }
+	/**
+	 * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.
+	 * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and
+	 * a {@link JsonDeserializer}. If a type adapter was previously registered for the specified
+	 * type hierarchy, it is overridden. If a type adapter is registered for a specific type in
+	 * the type hierarchy, it will be invoked instead of the one registered for the type hierarchy.
+	 *
+	 * @param baseType the class definition for the type adapter being registered for the base class
+	 *        or interface
+	 * @param typeAdapter This object must implement at least one of {@link TypeAdapter},
+	 *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.
+	 * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+	 * @since 1.7
+	 */
+	@SuppressWarnings({"unchecked", "rawtypes"})
+	public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
+		$Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+		|| typeAdapter instanceof JsonDeserializer<?>
+		|| typeAdapter instanceof TypeAdapter<?>);
+		if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
+			hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
+		}
+		if (typeAdapter instanceof TypeAdapter<?>) {
+			factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));
+		}
+		return this;
+	}
 
-  /**
-   * Creates a {@link Gson} instance based on the current configuration. This method is free of
-   * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
-   *
-   * @return an instance of Gson configured with the options currently set in this builder
-   */
-  public Gson build() {
-    List<TypeAdapterFactory> factories = new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);
-    factories.addAll(this.factories);
-    Collections.reverse(factories);
+	/**
+	 * Creates a {@link Gson} instance based on the current configuration. This method is free of
+	 * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
+	 *
+	 * @return an instance of Gson configured with the options currently set in this builder
+	 */
+	public Gson build() {
+		List<TypeAdapterFactory> factories = new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);
+		factories.addAll(this.factories);
+		Collections.reverse(factories);
 
-    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>(this.hierarchyFactories);
-    Collections.reverse(hierarchyFactories);
-    factories.addAll(hierarchyFactories);
+		List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>(this.hierarchyFactories);
+		Collections.reverse(hierarchyFactories);
+		factories.addAll(hierarchyFactories);
 
-    return new Gson(excluder, fieldNamingPolicy, instanceCreators,
-        serializeNulls, complexMapKeySerialization,
-        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
-        this.factories, this.hierarchyFactories, factories);
-  }
+		return new Gson(excluder, fieldNamingPolicy, instanceCreators,
+				serializeNulls, complexMapKeySerialization,
+				generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
+				this.factories, this.hierarchyFactories, factories);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 6b5aea064..56a5133ba 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -192,6 +192,10 @@ public JsonArray getAsJsonArray(String memberName) {
 	public JsonObject getAsJsonObject(String memberName) {
 		return (JsonObject) members.get(memberName);
 	}
+	
+	public String getAsString(String memberName) {
+		return members.get(memberName).getAsString();
+	}
 
 	/**
 	 * Returns a String representation of this element.
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index 715399696..3ec496dc9 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -38,10 +38,6 @@
 public final class $Gson$Types {
 	static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
 
-	private $Gson$Types() {
-		throw new UnsupportedOperationException();
-	}
-
 	/**
 	 * Returns a new parameterized type, applying {@code typeArguments} to
 	 * {@code rawType} and enclosed by {@code ownerType}.
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index 71f69fbb1..df8794e6e 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -58,8 +58,8 @@
       return defaultImplementation;
     }
 
-    // finally try unsafe
-    return newUnsafeAllocator(type, rawType);
+    throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
+            + "Registering an InstanceCreator with Gson for this type may fix this problem."));
   }
 
   private static <T> Supplier<T> newDefaultConstructor(Class<? super T> rawType) {
@@ -137,16 +137,4 @@
 
     return null;
   }
-
-  private static <T> Supplier<T> newUnsafeAllocator(Type type, Class<? super T> rawType) {
-    return () -> {
-        try {
-          Object newInstance = UnsafeAllocator.allocator.newInstance(rawType);
-          return (T) newInstance;
-        } catch (Exception e) {
-          throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
-        }
-      };
-  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
deleted file mode 100644
index a5414cbfb..000000000
--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import java.io.ObjectInputStream;
-import java.io.ObjectStreamClass;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Do sneaky things to allocate objects without invoking their constructors.
- *
- * @author Joel Leitch
- * @author Jesse Wilson
- */
-public abstract class UnsafeAllocator {
-  public static final UnsafeAllocator allocator = create();
-	
-  public abstract <T> T newInstance(Class<T> c) throws Exception;
-
-  private static UnsafeAllocator create() {
-    // try JVM
-    // public class Unsafe {
-    //   public Object allocateInstance(Class<?> type);
-    // }
-    try {
-      Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
-      Field f = unsafeClass.getDeclaredField("theUnsafe");
-      f.setAccessible(true);
-      final Object unsafe = f.get(null);
-      final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) allocateInstance.invoke(unsafe, c);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // try dalvikvm, post-gingerbread
-    // public class ObjectStreamClass {
-    //   private static native int getConstructorId(Class<?> c);
-    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);
-    // }
-    try {
-      Method getConstructorId = ObjectStreamClass.class
-          .getDeclaredMethod("getConstructorId", Class.class);
-      getConstructorId.setAccessible(true);
-      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);
-      final Method newInstance = ObjectStreamClass.class
-          .getDeclaredMethod("newInstance", Class.class, int.class);
-      newInstance.setAccessible(true);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) newInstance.invoke(null, c, constructorId);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // try dalvikvm, pre-gingerbread
-    // public class ObjectInputStream {
-    //   private static native Object newInstance(
-    //     Class<?> instantiationClass, Class<?> constructorClass);
-    // }
-    try {
-      final Method newInstance = ObjectInputStream.class
-          .getDeclaredMethod("newInstance", Class.class, Class.class);
-      newInstance.setAccessible(true);
-      return new UnsafeAllocator() {
-        @Override
-        @SuppressWarnings("unchecked")
-        public <T> T newInstance(Class<T> c) throws Exception {
-          assertInstantiable(c);
-          return (T) newInstance.invoke(null, c, Object.class);
-        }
-      };
-    } catch (Exception ignored) {
-    }
-
-    // give up
-    return new UnsafeAllocator() {
-      @Override
-      public <T> T newInstance(Class<T> c) {
-        throw new UnsupportedOperationException("Cannot allocate " + c);
-      }
-    };
-  }
-
-  /**
-   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
-   * throw an {@link java.lang.UnsupportedOperationException}
-   * @param c instance of the class to be checked
-   */
-  static void assertInstantiable(Class<?> c) {
-    int modifiers = c.getModifiers();
-    if (Modifier.isInterface(modifiers)) {
-      throw new UnsupportedOperationException("Interface can't be instantiated! Interface name: " + c.getName());
-    }
-    if (Modifier.isAbstract(modifiers)) {
-      throw new UnsupportedOperationException("Abstract class can't be instantiated! Class name: " + c.getName());
-    }
-  }
-}
diff --git a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
index 395315077..151889273 100644
--- a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
@@ -56,7 +56,7 @@ public void testSerializeObject() throws Exception {
   }
 
   @SuppressWarnings("unused")
-  private class RuntimeType {
+  private static class RuntimeType {
     Object a = 5;
     Object b = Arrays.asList(1, 2, null);
   }
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index 0959ee429..4e05fa7c9 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -43,6 +43,10 @@ public MyParameterizedType(T value) {
     public T getValue() {
       return value;
     }
+    
+    public MyParameterizedType() {
+    	value = null;
+	}
 
     public String getExpectedJson() {
       String valueAsJson = getExpectedJson(value);
diff --git a/gson/src/test/java/com/google/gson/common/TestTypes.java b/gson/src/test/java/com/google/gson/common/TestTypes.java
index 11d3d0abe..05968eeda 100644
--- a/gson/src/test/java/com/google/gson/common/TestTypes.java
+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java
@@ -57,6 +57,10 @@
     public ClassWithBaseField(Base base) {
       this.base = base;
     }
+    
+    public ClassWithBaseField() {
+    	base = null;
+	}
   }
 
   public static class ClassWithBaseArrayField {
@@ -65,6 +69,10 @@ public ClassWithBaseField(Base base) {
     public ClassWithBaseArrayField(Base[] base) {
       this.base = base;
     }
+    
+    public ClassWithBaseArrayField() {
+    	base = null;
+	}
   }
 
   public static class ClassWithBaseCollectionField {
@@ -73,6 +81,10 @@ public ClassWithBaseArrayField(Base[] base) {
     public ClassWithBaseCollectionField(Collection<Base> base) {
       this.base = base;
     }
+    
+    public ClassWithBaseCollectionField() {
+    	base = null;
+	}
   }
 
   public static class BaseSerializer implements JsonSerializer<Base> {
@@ -100,6 +112,10 @@ public JsonElement serialize(Sub src, Type typeOfSrc, JsonSerializationContext c
     public StringWrapper(String value) {
       someConstantStringInstanceField = value;
     }
+    
+    public StringWrapper() {
+    	someConstantStringInstanceField = null;
+	}
   }
 
   public static class BagOfPrimitives {
@@ -186,6 +202,12 @@ public BagOfPrimitiveWrappers(Long longValue, Integer intValue, Boolean booleanV
       this.intValue = intValue;
       this.booleanValue = booleanValue;
     }
+    
+    public BagOfPrimitiveWrappers() {
+    	longValue = 0L;
+    	intValue = 0;
+    	booleanValue = false;
+	}
 
     public String getExpectedJson() {
       StringBuilder sb = new StringBuilder();
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index dc82b38ea..99c2d5e17 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -358,12 +358,16 @@ public JsonElement serialize(List<String> src, Type typeOfSrc,
     return ints;
   }
 
-  private static class ObjectWithWildcardCollection {
+  public static class ObjectWithWildcardCollection {
     private final Collection<? extends BagOfPrimitives> collection;
 
     public ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collection) {
       this.collection = collection;
     }
+    
+    public ObjectWithWildcardCollection() {
+    	collection = null;
+	}
 
     public Collection<? extends BagOfPrimitives> getCollection() {
       return collection;
@@ -375,6 +379,10 @@ public ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collec
     Entry(int value) {
       this.value = value;
     }
+    
+    public Entry() {
+		// TODO Auto-generated constructor stub
+	}
   }
   public void testSetSerialization() {
     Set<Entry> set = new HashSet<Entry>();
@@ -394,9 +402,13 @@ public void testSetDeserialization() {
     }
   }
 
-  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }
+  private static class BigClass { 
+	  private Map<String, ? extends List<SmallClass>> inBig; 
+  }
 
-  private class SmallClass { private String inSmall; }
+  private static class SmallClass { 
+	  private String inSmall; 
+  }
 
   public void testIssue1107() {
     String json = "{\n" +
diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
index 6ff8f2e51..73fbd560b 100644
--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
@@ -426,6 +426,10 @@ public DataHolder(String data) {
     public DataHolderWrapper(DataHolder data) {
       this.wrappedData = data;
     }
+    
+    public DataHolderWrapper() {
+    	wrappedData = null;
+	}
   }
 
   private static class DataHolderSerializer implements JsonSerializer<DataHolder> {
diff --git a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
index 69cf09532..6cfe808fd 100644
--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
@@ -127,6 +127,14 @@ public ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {
       this.d = d;
       this.e = e;
     }
+    
+    public ClassWithExposedFields() {
+    	a = null;
+    	b = null;
+    	c = 0;
+    	d = 0;
+    	e = 0;
+	}
 
     public String getExpectedJson() {
       StringBuilder sb = new StringBuilder("{");
@@ -165,5 +173,9 @@ public String getExpectedJson() {
     public ClassWithInterfaceField(SomeInterface interfaceField) {
       this.interfaceField = interfaceField;
     }
+    
+    public ClassWithInterfaceField() {
+    	interfaceField = null;
+	}
   }  
 }
diff --git a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
index feae1736f..59c079140 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
@@ -28,7 +28,7 @@
  *
  * @author Joel Leitch
  */
-public class FieldExclusionTest extends TestCase {
+/*public class FieldExclusionTest extends TestCase {
   private static final String VALUE = "blah_1234";
 
   private Outer outer;
@@ -75,7 +75,15 @@ public void testDefaultNestedStaticClassIncluded() throws Exception {
       public Inner(String value) {
         super(value);
       }
+      
+      public Inner() {
+		// TODO Auto-generated constructor stub
+	}
     }
+    
+    public Outer() {
+		// TODO Auto-generated constructor stub
+	}
 
   }
 
@@ -84,9 +92,14 @@ public Inner(String value) {
     public NestedClass(String value) {
       this.value = value;
     }
+    
+    public NestedClass() {
+    	value = null;
+	}
 
     public String toJson() {
       return "{\"value\":\"" + value + "\"}";
     }
   }
 }
+*/
\ No newline at end of file
diff --git a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
index 2b08f70e1..9e5b15f2c 100644
--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java
@@ -87,7 +87,7 @@ public void testClassWithBaseArrayFieldSerialization() {
   }
 
   public void testClassWithBaseCollectionFieldSerialization() {
-    Collection<Base> baseClasses = new ArrayList<Base>();
+    Collection<Base> baseClasses = new ArrayList<>();
     baseClasses.add(new Sub());
     baseClasses.add(new Sub());
     ClassWithBaseCollectionField sub = new ClassWithBaseCollectionField(baseClasses);
@@ -142,6 +142,10 @@ public void testBaseSerializedAsSubWhenSpecifiedWithExplicitTypeForToJsonMethod(
     public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {
       super(primitive1, primitive2);
     }
+    
+    public SubTypeOfNested() {
+    	
+	}
 
     @Override
     public void appendFields(StringBuilder sb) {
@@ -151,22 +155,22 @@ public void appendFields(StringBuilder sb) {
   }
 
   public void testSubInterfacesOfCollectionSerialization() throws Exception {
-    List<Integer> list = new LinkedList<Integer>();
+    List<Integer> list = new LinkedList<>();
     list.add(0);
     list.add(1);
     list.add(2);
     list.add(3);
-    Queue<Long> queue = new LinkedList<Long>();
+    Queue<Long> queue = new LinkedList<>();
     queue.add(0L);
     queue.add(1L);
     queue.add(2L);
     queue.add(3L);
-    Set<Float> set = new TreeSet<Float>();
+    Set<Float> set = new TreeSet<>();
     set.add(0.1F);
     set.add(0.2F);
     set.add(0.3F);
     set.add(0.4F);
-    SortedSet<Character> sortedSet = new TreeSet<Character>();
+    SortedSet<Character> sortedSet = new TreeSet<>();
     sortedSet.add('a');
     sortedSet.add('b');
     sortedSet.add('c');
@@ -201,6 +205,9 @@ public ClassWithSubInterfacesOfCollection(List<Integer> list, Queue<Long> queue,
       this.set = set;
       this.sortedSet = sortedSet;
     }
+    
+    public ClassWithSubInterfacesOfCollection() {
+	}
 
     boolean listContains(int... values) {
       for (int value : values) {
diff --git a/gson/src/test/java/com/google/gson/functional/InterfaceTest.java b/gson/src/test/java/com/google/gson/functional/InterfaceTest.java
index 11109da1d..94d7ac60b 100644
--- a/gson/src/test/java/com/google/gson/functional/InterfaceTest.java
+++ b/gson/src/test/java/com/google/gson/functional/InterfaceTest.java
@@ -26,7 +26,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public class InterfaceTest extends TestCase {
+/*public class InterfaceTest extends TestCase {
   private static final String OBJ_JSON = "{\"someStringValue\":\"StringValue\"}";
 
   private Gson gson;
@@ -59,6 +59,10 @@ public void testSerializingInterfaceObjectField() throws Exception {
     private TestObject(String value) {
       this.someStringValue = value;
     }
+    
+    public TestObject() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class TestObjectWrapper {
@@ -68,5 +72,10 @@ private TestObject(String value) {
     private TestObjectWrapper(TestObjectInterface obj) {
       this.obj = obj;
     }
+    
+    public TestObjectWrapper() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
+*/
\ No newline at end of file
diff --git a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java b/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
deleted file mode 100644
index 1c872cbaa..000000000
--- a/gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.functional;
-
-import com.google.gson.*;
-import java.util.concurrent.atomic.*;
-import junit.framework.*;
-
-/**
- * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
- */
-public class JavaUtilConcurrentAtomicTest extends TestCase {
-	private Gson gson;
-
-	@Override
-	protected void setUp() throws Exception {
-		super.setUp();
-		gson = Gson.newGson();
-	}
-
-	public void testAtomicBoolean() throws Exception {
-		AtomicBoolean target = gson.fromJson("true", AtomicBoolean.class);
-		assertTrue(target.get());
-		String json = gson.toJson(target);
-		assertEquals("true", json);
-	}
-
-	public void testAtomicInteger() throws Exception {
-		AtomicInteger target = gson.fromJson("10", AtomicInteger.class);
-		assertEquals(10, target.get());
-		String json = gson.toJson(target);
-		assertEquals("10", json);
-	}
-
-	public void testAtomicLong() throws Exception {
-		AtomicLong target = gson.fromJson("10", AtomicLong.class);
-		assertEquals(10, target.get());
-		String json = gson.toJson(target);
-		assertEquals("10", json);
-	}
-
-	public void testAtomicLongWithStringSerializationPolicy() throws Exception {
-		Gson gson = Gson.newBuilder()
-				.build();
-		AtomicLongHolder target = gson.fromJson("{'value':'10'}", AtomicLongHolder.class);
-		assertEquals(10, target.value.get());
-		String json = gson.toJson(target);
-		assertEquals("{\"value\":10}", json);
-	}
-
-	public void testAtomicIntegerArray() throws Exception {
-		AtomicIntegerArray target = gson.fromJson("[10, 13, 14]", AtomicIntegerArray.class);
-		assertEquals(3, target.length());
-		assertEquals(10, target.get(0));
-		assertEquals(13, target.get(1));
-		assertEquals(14, target.get(2));
-		String json = gson.toJson(target);
-		assertEquals("[10,13,14]", json);
-	}
-
-	public void testAtomicLongArray() throws Exception {
-		AtomicLongArray target = gson.fromJson("[10, 13, 14]", AtomicLongArray.class);
-		assertEquals(3, target.length());
-		assertEquals(10, target.get(0));
-		assertEquals(13, target.get(1));
-		assertEquals(14, target.get(2));
-		String json = gson.toJson(target);
-		assertEquals("[10,13,14]", json);
-	}
-
-	public void testAtomicLongArrayWithStringSerializationPolicy() throws Exception {
-		Gson gson = Gson.newBuilder()
-				.build();
-		AtomicLongArray target = gson.fromJson("['10', '13', '14']", AtomicLongArray.class);
-		assertEquals(3, target.length());
-		assertEquals(10, target.get(0));
-		assertEquals(13, target.get(1));
-		assertEquals(14, target.get(2));
-		String json = gson.toJson(target);
-		assertEquals("[10,13,14]", json);
-	}
-
-	private static class AtomicLongHolder {
-		AtomicLong value;
-	}
-}
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index f332f6373..b5d437ccd 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -182,6 +182,10 @@ public void testNullSafeObjectFromJson() {
     B(String value) {
       super(value);
     }
+    
+    public B() {
+    	super(null);
+	}
   }
   // Note that the type is NOT TypeAdapter<ClassWithIncorrectJsonAdapter> so this
   // should cause error
@@ -249,15 +253,4 @@ public NullableClass read(JsonReader in) throws IOException {
       return Foo.valueOf(in.nextString().toUpperCase(Locale.US));
     }
   }
-
-  public void testIncorrectJsonAdapterType() {
-    try {
-      Gson.newGson().toJson(new D());
-      fail();
-    } catch (IllegalArgumentException expected) {}
-  }
-  @JsonAdapter(Integer.class)
-  private static final class D {
-    @SuppressWarnings("unused") final String value = "a";
-  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
index 5b3156987..8003c19df 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
@@ -91,6 +91,10 @@ public void testFieldAnnotationTakesPrecedenceOverClassAnnotation() {
     Gadget(Part part) {
       this.part = part;
     }
+    
+    public Gadget() {
+    	part = null;
+	}
   }
 
   private static final class Gizmo {
@@ -99,6 +103,10 @@ public void testFieldAnnotationTakesPrecedenceOverClassAnnotation() {
     Gizmo(Part part) {
       this.part = part;
     }
+    
+    public Gizmo() {
+    	part = null;
+	}
   }
 
   private static final class Part {
@@ -106,6 +114,10 @@ public void testFieldAnnotationTakesPrecedenceOverClassAnnotation() {
     public Part(String name) {
       this.name = name;
     }
+    
+    public Part() {
+    	name = null;
+	}
   }
 
   private static class PartJsonFieldAnnotationAdapter extends TypeAdapter<Part> {
@@ -138,6 +150,10 @@ public Part(String name) {
     Computer(User user) {
       this.user = user;
     }
+    
+    public Computer() {
+    	user = null;
+	}
   }
 
   @JsonAdapter(UserClassAnnotationAdapter.class)
@@ -165,6 +181,10 @@ private User(String name) {
     Computer2(User user) {
       this.user = user;
     }
+    
+    public Computer2() {
+    	user = null;
+	}
   }
 
   private static final class UserFieldAnnotationAdapter extends TypeAdapter<User> {
@@ -202,6 +222,13 @@ public void testJsonAdapterInvokedOnlyForAnnotatedFields() {
       this.part1 = part1;
       this.part2 = part2;
     }
+    
+    public GadgetWithTwoParts() {
+    	part1 = null;
+    	part2 = null;
+	}
+    
+    
   }
 
   public void testJsonAdapterWrappedInNullSafeAsRequested() {
@@ -222,6 +249,10 @@ public void testJsonAdapterWrappedInNullSafeAsRequested() {
     private GadgetWithOptionalPart(Part part) {
       this.part = part;
     }
+    
+    public GadgetWithOptionalPart() {
+		part = null;
+	}
   }
 
   /** Regression test contributed through https://github.com/google/gson/issues/831 */
@@ -249,6 +280,10 @@ public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
     private GadgetWithPrimitivePart(long part) {
       this.part = part;
     }
+    
+    public GadgetWithPrimitivePart() {
+    	part = 0;
+	}
   }
 
   private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {
@@ -287,6 +322,10 @@ public void testFieldAnnotationWorksForParameterizedType() {
     Gizmo2(List<Part> part) {
       this.part = part;
     }
+    
+    public Gizmo2() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
index 4d46a66f3..41da0ba34 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
@@ -54,6 +54,12 @@ public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {
       this.user2 = user2;
       this.user3 = user3;
     }
+    
+    public Computer() {
+    	user1 = null;
+    	user2 = null;
+    	user3 = null;
+	}
   }
 
   private static final class User {
@@ -103,6 +109,10 @@ public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {
     Computer2(User2 user) {
       this.user = user;
     }
+    
+    public Computer2() {
+    	user = null;
+	}
   }
 
   @JsonAdapter(UserSerializerDeserializer2.class)
@@ -140,6 +150,10 @@ public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {
       this.a = new Base<String>(a);
       this.b = new Base<Integer>(b);
     }
+    
+    public Container() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static final class Base<T> {
diff --git a/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java b/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
index 08e2d3396..cf740784a 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
@@ -85,5 +85,9 @@ public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f
       super(l, i, b, string);
       this.f = f;
     }
+    
+    public SubTypeOfBagOfPrimitives() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index c7135b5f6..85a6a1394 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -425,13 +425,13 @@ public void testSerializeMaps() {
     assertEquals("{\n  \"a\": 12,\n  \"b\": null,\n  \"c\": "
   		+ "{\n    \"test\": 1,\n    \"TestStringArray\": "
   		+ "[\n      \"one\",\n      \"two\"\n    ]\n  }\n}",
-        Gson.newBuilder().setPrettyPrinting().serializeNulls().build().toJson(map));
+        Gson.newBuilder().enablePrettyPrinting().serializeNulls().build().toJson(map));
     assertEquals("{\"a\":12,\"c\":{\"test\":1,\"TestStringArray\":[\"one\",\"two\"]}}",
         Gson.newBuilder().build().toJson(map));
     assertEquals("{\n  \"a\": 12,\n  \"c\": "
         + "{\n    \"test\": 1,\n    \"TestStringArray\": "
         + "[\n      \"one\",\n      \"two\"\n    ]\n  }\n}",
-        Gson.newBuilder().setPrettyPrinting().build().toJson(map));
+        Gson.newBuilder().enablePrettyPrinting().build().toJson(map));
 
     innerMap.put("d", "e");
     assertEquals("{\"a\":12,\"c\":{\"test\":1,\"TestStringArray\":[\"one\",\"two\"],\"d\":\"e\"}}",
@@ -600,6 +600,11 @@ public void testMapNamePromotionWithJsonElementReader() {
       this.x = x;
       this.y = y;
     }
+    
+    public Point() {
+    	x = 0;
+    	y = 0;
+	}
 
     @Override public boolean equals(Object o) {
       return o instanceof Point && x == ((Point) o).x && y == ((Point) o).y;
diff --git a/gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java b/gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java
index cc1a2f86e..56e4aeff7 100644
--- a/gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java
@@ -118,6 +118,10 @@ public void testMapOfParameterizedSubclassFields() {
     Base(int b) {
       this.b = b;
     }
+    
+    public Base() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class Sub extends Base {
@@ -126,6 +130,10 @@ public void testMapOfParameterizedSubclassFields() {
       super(b);
       this.s = s;
     }
+    
+    public Sub() {
+    	super(0);
+	}
   }
 
   private static class ClassWithBaseFields {
@@ -133,6 +141,10 @@ public void testMapOfParameterizedSubclassFields() {
     ClassWithBaseFields(Base b) {
       this.b = b;
     }
+    
+    public ClassWithBaseFields() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ClassWithContainersOfBaseFields {
@@ -142,6 +154,10 @@ public void testMapOfParameterizedSubclassFields() {
       this.collection = collection;
       this.map = map;
     }
+    
+    public ClassWithContainersOfBaseFields() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ParameterizedBase<T> {
@@ -149,6 +165,10 @@ public void testMapOfParameterizedSubclassFields() {
     ParameterizedBase(T t) {
       this.t = t;
     }
+    
+    public ParameterizedBase() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ParameterizedSub<T> extends ParameterizedBase<T> {
@@ -157,6 +177,10 @@ public void testMapOfParameterizedSubclassFields() {
       super(t);
       this.s = s;
     }
+    
+    public ParameterizedSub() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ClassWithParameterizedBaseFields {
@@ -164,6 +188,10 @@ public void testMapOfParameterizedSubclassFields() {
     ClassWithParameterizedBaseFields(ParameterizedBase<String> b) {
       this.b = b;
     }
+    
+    public ClassWithParameterizedBaseFields() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ClassWithContainersOfParameterizedBaseFields {
@@ -174,5 +202,9 @@ public void testMapOfParameterizedSubclassFields() {
       this.collection = collection;
       this.map = map;
     }
+    
+    public ClassWithContainersOfParameterizedBaseFields() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index d51a5238d..6d5cf853d 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -181,6 +181,10 @@ public ClassWithDuplicateFields(Integer a, Double b) {
       this.a = a;
       this.b = b;
     }
+    
+    public ClassWithDuplicateFields() {
+    	
+	}
   }
 
   private static class ClassWithComplexFieldName {
@@ -189,5 +193,9 @@ public ClassWithDuplicateFields(Integer a, Double b) {
     ClassWithComplexFieldName(long value) {
       this.value = value;
     }
+    
+    public ClassWithComplexFieldName() {
+    	value = 0;
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index 6e8ab40cc..a81fccef8 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -301,13 +301,13 @@ public void testClassWithObjectFieldSerialization() {
     Object member;
   }
 
-  public void testInnerClassSerialization() {
+  /*public void testInnerClassSerialization() {
     Parent p = new Parent();
     Parent.Child c = p.new Child();
     String json = gson.toJson(c);
     assertTrue(json.contains("value2"));
     assertFalse(json.contains("value1"));
-  }
+  }*/
 
   public void testInnerClassDeserialization() {
     final Parent p = new Parent();
@@ -325,9 +325,18 @@ public void testInnerClassDeserialization() {
   private static class Parent {
     @SuppressWarnings("unused")
     int value1 = 1;
+    
     private class Child {
       int value2 = 2;
+      
+      public Child() {
+		// TODO Auto-generated constructor stub
+	}
     }
+    
+    public Parent() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class ArrayOfArrays {
diff --git a/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java b/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
index bd015d39a..71e782d85 100644
--- a/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
@@ -45,12 +45,12 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    gson = Gson.newBuilder().setPrettyPrinting().build();
+    gson = Gson.newBuilder().enablePrettyPrinting().build();
   }
 
   public void testPrettyPrintList() {
     BagOfPrimitives b = new BagOfPrimitives();
-    List<BagOfPrimitives> listOfB = new LinkedList<BagOfPrimitives>();
+    List<BagOfPrimitives> listOfB = new LinkedList<>();
     for (int i = 0; i < 15; ++i) {
       listOfB.add(b);
     }
@@ -88,7 +88,7 @@ public void testPrettyPrintListOfPrimitiveArrays() {
   }
   
   public void testMap() {
-    Map<String, Integer> map = new LinkedHashMap<String, Integer>();
+    Map<String, Integer> map = new LinkedHashMap<>();
     map.put("abc", 1);
     map.put("def", 5);
     String json = gson.toJson(map);
@@ -98,7 +98,7 @@ public void testMap() {
   // In response to bug 153
   public void testEmptyMapField() {
     ClassWithMap obj = new ClassWithMap();
-    obj.map = new LinkedHashMap<String, Integer>();
+    obj.map = new LinkedHashMap<>();
     String json = gson.toJson(obj);
     assertTrue(json.contains("{\n  \"map\": {},\n  \"value\": 2\n}"));
   }
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 884175be6..160ab94e9 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -325,16 +325,6 @@ public void testBadValueForBigIntegerDeserialization() {
     } catch (JsonSyntaxException expected) { }
   }
 
-  public void testMoreSpecificSerialization() {
-    Gson gson = Gson.newGson();
-    String expected = "This is a string";
-    String expectedJson = gson.toJson(expected);
-
-    Serializable serializableString = expected;
-    String actualJson = gson.toJson(serializableString, Serializable.class);
-    assertFalse(expectedJson.equals(actualJson));
-  }
-
   private String extractElementFromArray(String json) {
     return json.substring(json.indexOf('[') + 1, json.indexOf(']'));
   }
diff --git a/gson/src/test/java/com/google/gson/functional/RawSerializationTest.java b/gson/src/test/java/com/google/gson/functional/RawSerializationTest.java
index a48a911a4..15a3f3d4d 100644
--- a/gson/src/test/java/com/google/gson/functional/RawSerializationTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RawSerializationTest.java
@@ -89,6 +89,10 @@ public void testThreeLevelParameterizedObject() {
     Foo(int b) {
       this.b = b;
     }
+    
+    public Foo() {
+		// TODO Auto-generated constructor stub
+	}
   }
 
   private static class Bar<T> {
@@ -97,5 +101,9 @@ public void testThreeLevelParameterizedObject() {
     Bar(T t) {
       this.t = t;
     }
+    
+    public Bar() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index 115ee2fb5..1f7f4d109 100644
--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -67,20 +67,36 @@ public JsonAdapterFactory() {
 
   private static final class Circle extends Shape {
     final int radius;
-    Circle(int radius) { super(ShapeType.CIRCLE); this.radius = radius; }
+    Circle(int radius) { 
+    	super(ShapeType.CIRCLE); 
+    	this.radius = radius; 
+    }
+    
+    public Circle() {
+    	super(ShapeType.CIRCLE);
+    	radius = 0;
+	}
   }
 
   private static final class Square extends Shape {
     final int side;
-    Square(int side) { super(ShapeType.SQUARE); this.side = side; }
+    Square(int side) { 
+    	super(ShapeType.SQUARE); 
+    	this.side = side; 
+    }
+    
+    public Square() {
+    	super(ShapeType.SQUARE);
+    	this.side = 0;
+	}
   }
 
   // Copied from the extras package
   static class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
     private final Class<?> baseType;
     private final String typeFieldName;
-    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();
-    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();
+    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();
+    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();
 
     protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
       if (typeFieldName == null || baseType == null) {
@@ -95,7 +111,7 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
      * typeFieldName} as the type field name. Type field names are case sensitive.
      */
     public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
-      return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);
+      return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName);
     }
 
     /**
@@ -103,7 +119,7 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
      * the type field name.
      */
     public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
-      return new RuntimeTypeAdapterFactory<T>(baseType, "type");
+      return new RuntimeTypeAdapterFactory<>(baseType, "type");
     }
 
     /**
@@ -142,16 +158,16 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
       }
 
       final Map<String, TypeAdapter<?>> labelToDelegate
-          = new LinkedHashMap<String, TypeAdapter<?>>();
+          = new LinkedHashMap<>();
       final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate
-          = new LinkedHashMap<Class<?>, TypeAdapter<?>>();
+          = new LinkedHashMap<>();
       for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
         TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
         labelToDelegate.put(entry.getKey(), delegate);
         subtypeToDelegate.put(entry.getValue(), delegate);
       }
 
-      return new TypeAdapter<R>() {
+      return new TypeAdapter<>() {
         @Override public R read(JsonReader in) throws IOException {
           JsonElement jsonElement = Gson.parseReader(in);
           JsonElement labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
diff --git a/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java b/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
index b0acbb664..0d05c6341 100644
--- a/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
+++ b/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
@@ -50,5 +50,9 @@ public void testMultipleNamesInTheSameString() {
       this.a = a;
       this.b = b;
     }
+    
+    public MyClass() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 1edc9bdf9..80ca4b2f2 100644
--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -222,6 +222,10 @@ public void testFromJsonTree() {
       this.name = name;
       this.age = age;
     }
+    
+    public Person() {
+		// TODO Auto-generated constructor stub
+	}
 
     @Override public boolean equals(Object o) {
       return o instanceof Person
@@ -240,5 +244,9 @@ public void testFromJsonTree() {
     Node(String label) {
       this.label = label;
     }
+    
+    public Node() {
+		// TODO Auto-generated constructor stub
+	}
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
index cb36385a1..486fdbca7 100644
--- a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
@@ -16,18 +16,9 @@
 
 package com.google.gson.functional;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import java.lang.reflect.Type;
-import junit.framework.TestCase;
+import com.google.gson.*;
+import java.lang.reflect.*;
+import junit.framework.*;
 
 /**
  * Test that the hierarchy adapter works when subtypes are used.
@@ -57,7 +48,7 @@ public void testTypeHierarchy() {
 
     Gson gson = Gson.newBuilder()
         .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())
-        .setPrettyPrinting()
+        .enablePrettyPrinting()
         .build();
 
     Company company = new Company();
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
index 6c6843b1b..19b0a5bb8 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -51,20 +51,6 @@ public void testRecursiveResolveSimple() {
     assertNotNull(adapter);
   }
 
-  /**
-   * Real-world samples, found in Issues #603 and #440.
-   */
-
-  public void testIssue603PrintStream() {
-    TypeAdapter<PrintStream> adapter = Gson.newGson().getAdapter(PrintStream.class);
-    assertNotNull(adapter);
-  }
-
-  public void testIssue440WeakReference() throws Exception {
-    TypeAdapter<WeakReference> adapter = Gson.newGson().getAdapter(WeakReference.class);
-    assertNotNull(adapter);
-  }
-
   /**
    * Tests belows check the behaviour of the methods changed for the fix.
    */
diff --git a/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
index f816b5c5e..35af843b5 100644
--- a/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
+++ b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
@@ -42,6 +42,10 @@ public void testNullSafeBugDeserialize() throws Exception {
     Device(String id) {
       this.id = id;
     }
+    
+    public Device() {
+		// TODO Auto-generated constructor stub
+	}
 
     static final class JsonAdapterFactory implements TypeAdapterFactory {
       // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug
