diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java
deleted file mode 100644
index 6d7881473..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonArray.java
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * A class representing an array type in Json. An array is a list of {@link JsonElement}s each of
- * which can be of a different type. This is an ordered list, meaning that the order in which
- * elements are added is preserved.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class JsonArray extends JsonElement implements Iterable<JsonElement> {
-  private final List<JsonElement> elements;
-
-  /**
-   * Creates an empty JsonArray.
-   */
-  public JsonArray() {
-    elements = new ArrayList<JsonElement>();
-  }
-
-  @Override
-  JsonArray deepCopy() {
-    final JsonArray result = new JsonArray();
-    for (final JsonElement element : elements) {
-      result.add(element.deepCopy());
-    }
-    return result;
-  }
-
-  /**
-   * Adds the specified boolean to self.
-   *
-   * @param bool the boolean that needs to be added to the array.
-   */
-  public void add(final Boolean bool) {
-    elements.add(bool == null ? JsonNull.INSTANCE : new JsonPrimitive(bool));
-  }
-
-  /**
-   * Adds the specified character to self.
-   *
-   * @param character the character that needs to be added to the array.
-   */
-  public void add(final Character character) {
-    elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));
-  }
-
-  /**
-   * Adds the specified number to self.
-   *
-   * @param number the number that needs to be added to the array.
-   */
-  public void add(final Number number) {
-    elements.add(number == null ? JsonNull.INSTANCE : new JsonPrimitive(number));
-  }
-
-  /**
-   * Adds the specified string to self.
-   *
-   * @param string the string that needs to be added to the array.
-   */
-  public void add(final String string) {
-    elements.add(string == null ? JsonNull.INSTANCE : new JsonPrimitive(string));
-  }
-
-  /**
-   * Adds the specified element to self.
-   *
-   * @param element the element that needs to be added to the array.
-   */
-  public void add(JsonElement element) {
-    if (element == null) {
-      element = JsonNull.INSTANCE;
-    }
-    elements.add(element);
-  }
-
-  /**
-   * Adds all the elements of the specified array to self.
-   *
-   * @param array the array whose elements need to be added to the array.
-   */
-  public void addAll(final JsonArray array) {
-    elements.addAll(array.elements);
-  }
-
-  /**
-   * Replaces the element at the specified position in this array with the specified element.
-   *   Element can be null.
-   * @param index index of the element to replace
-   * @param element element to be stored at the specified position
-   * @return the element previously at the specified position
-   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds
-   */
-  public JsonElement set(final int index, final JsonElement element) {
-    return elements.set(index, element);
-  }
-
-  /**
-   * Removes the first occurrence of the specified element from this array, if it is present.
-   * If the array does not contain the element, it is unchanged.
-   * @param element element to be removed from this array, if present
-   * @return true if this array contained the specified element, false otherwise
-   * @since 2.3
-   */
-  public boolean remove(final JsonElement element) {
-    return elements.remove(element);
-  }
-
-  /**
-   * Removes the element at the specified position in this array. Shifts any subsequent elements
-   * to the left (subtracts one from their indices). Returns the element that was removed from
-   * the array.
-   * @param index index the index of the element to be removed
-   * @return the element previously at the specified position
-   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds
-   * @since 2.3
-   */
-  public JsonElement remove(final int index) {
-    return elements.remove(index);
-  }
-
-  /**
-   * Returns true if this array contains the specified element.
-   * @return true if this array contains the specified element.
-   * @param element whose presence in this array is to be tested
-   * @since 2.3
-   */
-  public boolean contains(final JsonElement element) {
-    return elements.contains(element);
-  }
-
-  /**
-   * Returns the number of elements in the array.
-   *
-   * @return the number of elements in the array.
-   */
-  public int size() {
-    return elements.size();
-  }
-
-  /**
-   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,
-   * the iterator navigates the elements in the order they were inserted.
-   *
-   * @return an iterator to navigate the elements of the array.
-   */
-  @Override
-  public Iterator<JsonElement> iterator() {
-    return elements.iterator();
-  }
-
-  /**
-   * Returns the ith element of the array.
-   *
-   * @param i the index of the element that is being sought.
-   * @return the element present at the ith index.
-   * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the
-   * {@link #size()} of the array.
-   */
-  public JsonElement get(final int i) {
-    return elements.get(i);
-  }
-
-  /**
-   * convenience method to get this array as a {@link Number} if it contains a single element.
-   *
-   * @return get this element as a number if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid Number.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public Number getAsNumber() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsNumber();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a {@link String} if it contains a single element.
-   *
-   * @return get this element as a String if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid String.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public String getAsString() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsString();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a double if it contains a single element.
-   *
-   * @return get this element as a double if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid double.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public double getAsDouble() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsDouble();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a {@link BigDecimal} if it contains a single element.
-   *
-   * @return get this element as a {@link BigDecimal} if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
-   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
-   * @throws IllegalStateException if the array has more than one element.
-   * @since 1.2
-   */
-  @Override
-  public BigDecimal getAsBigDecimal() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsBigDecimal();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a {@link BigInteger} if it contains a single element.
-   *
-   * @return get this element as a {@link BigInteger} if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
-   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
-   * @throws IllegalStateException if the array has more than one element.
-   * @since 1.2
-   */
-  @Override
-  public BigInteger getAsBigInteger() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsBigInteger();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a float if it contains a single element.
-   *
-   * @return get this element as a float if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid float.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public float getAsFloat() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsFloat();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a long if it contains a single element.
-   *
-   * @return get this element as a long if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid long.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public long getAsLong() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsLong();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as an integer if it contains a single element.
-   *
-   * @return get this element as an integer if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid integer.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public int getAsInt() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsInt();
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override
-  public byte getAsByte() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsByte();
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override
-  public char getAsCharacter() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsCharacter();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a primitive short if it contains a single element.
-   *
-   * @return get this element as a primitive short if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid short.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public short getAsShort() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsShort();
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * convenience method to get this array as a boolean if it contains a single element.
-   *
-   * @return get this element as a boolean if it is single element array.
-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
-   * is not a valid boolean.
-   * @throws IllegalStateException if the array has more than one element.
-   */
-  @Override
-  public boolean getAsBoolean() {
-    if (elements.size() == 1) {
-      return elements.get(0).getAsBoolean();
-    }
-    throw new IllegalStateException();
-  }
-
-  @Override
-  public boolean equals(final Object o) {
-    return (o == this) || (o instanceof JsonArray && ((JsonArray) o).elements.equals(elements));
-  }
-
-  @Override
-  public int hashCode() {
-    return elements.hashCode();
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
deleted file mode 100644
index c2b0aa1d7..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonElement.java
+++ /dev/null
@@ -1,365 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Map;
-
-import com.github.gv2011.jsoncore.JsonOption;
-
-/**
- * A class representing an element of Json. It could either be a {@link JsonObject}, a
- * {@link JsonArray}, a {@link JsonPrimitive} or a {@link JsonNull}.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public abstract class JsonElement {
-  /**
-   * Returns a deep copy of this element. Immutable elements like primitives
-   * and nulls are not copied.
-   */
-  abstract JsonElement deepCopy();
-
-  /**
-   * provides check for verifying if this element is an array or not.
-   *
-   * @return true if this element is of type {@link JsonArray}, false otherwise.
-   */
-  public boolean isJsonArray() {
-    return this instanceof JsonArray;
-  }
-
-  /**
-   * provides check for verifying if this element is a Json object or not.
-   *
-   * @return true if this element is of type {@link JsonObject}, false otherwise.
-   */
-  public boolean isJsonObject() {
-    return this instanceof JsonObject;
-  }
-
-  /**
-   * provides check for verifying if this element is a primitive or not.
-   *
-   * @return true if this element is of type {@link JsonPrimitive}, false otherwise.
-   */
-  public boolean isJsonPrimitive() {
-    return this instanceof JsonPrimitive;
-  }
-
-  /**
-   * provides check for verifying if this element represents a null value or not.
-   *
-   * @return true if this element is of type {@link JsonNull}, false otherwise.
-   * @since 1.2
-   */
-  public boolean isJsonNull() {
-    return this instanceof JsonNull;
-  }
-
-  /**
-   * convenience method to get this element as a {@link JsonObject}. If the element is of some
-   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method
-   * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
-   * first.
-   *
-   * @return get this element as a {@link JsonObject}.
-   * @throws IllegalStateException if the element is of another type.
-   */
-  public JsonObject getAsJsonObject() {
-    if (isJsonObject()) {
-      return (JsonObject) this;
-    }
-    throw new IllegalStateException("Not a JSON Object: " + this);
-  }
-
-  /**
-   * convenience method to get this element as a {@link JsonArray}. If the element is of some
-   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method
-   * after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
-   * first.
-   *
-   * @return get this element as a {@link JsonArray}.
-   * @throws IllegalStateException if the element is of another type.
-   */
-  public JsonArray getAsJsonArray() {
-    if (isJsonArray()) {
-      return (JsonArray) this;
-    }
-    throw new IllegalStateException("This is not a JSON Array.");
-  }
-
-  /**
-   * convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
-   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method
-   * after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
-   * first.
-   *
-   * @return get this element as a {@link JsonPrimitive}.
-   * @throws IllegalStateException if the element is of another type.
-   */
-  public JsonPrimitive getAsJsonPrimitive() {
-    if (isJsonPrimitive()) {
-      return (JsonPrimitive) this;
-    }
-    throw new IllegalStateException("This is not a JSON Primitive.");
-  }
-
-  /**
-   * convenience method to get this element as a {@link JsonNull}. If the element is of some
-   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method
-   * after ensuring that this element is of the desired type by calling {@link #isJsonNull()}
-   * first.
-   *
-   * @return get this element as a {@link JsonNull}.
-   * @throws IllegalStateException if the element is of another type.
-   * @since 1.2
-   */
-  public JsonNull getAsJsonNull() {
-    if (isJsonNull()) {
-      return (JsonNull) this;
-    }
-    throw new IllegalStateException("This is not a JSON Null.");
-  }
-
-  /**
-   * convenience method to get this element as a boolean value.
-   *
-   * @return get this element as a primitive boolean value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * boolean value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public boolean getAsBoolean() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a {@link Boolean} value.
-   *
-   * @return get this element as a {@link Boolean} value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * boolean value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  Boolean getAsBooleanWrapper() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a {@link Number}.
-   *
-   * @return get this element as a {@link Number}.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * number.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public Number getAsNumber() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a string value.
-   *
-   * @return get this element as a string value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * string value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public String getAsString() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive double value.
-   *
-   * @return get this element as a primitive double value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * double value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public double getAsDouble() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive float value.
-   *
-   * @return get this element as a primitive float value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * float value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public float getAsFloat() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive long value.
-   *
-   * @return get this element as a primitive long value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * long value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public long getAsLong() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive integer value.
-   *
-   * @return get this element as a primitive integer value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * integer value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public int getAsInt() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive byte value.
-   *
-   * @return get this element as a primitive byte value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * byte value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.3
-   */
-  public byte getAsByte() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive character value.
-   *
-   * @return get this element as a primitive char value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * char value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.3
-   */
-  public char getAsCharacter() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a {@link BigDecimal}.
-   *
-   * @return get this element as a {@link BigDecimal}.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
-   * * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.2
-   */
-  public BigDecimal getAsBigDecimal() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a {@link BigInteger}.
-   *
-   * @return get this element as a {@link BigInteger}.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
-   * @throws NumberFormatException if the element is not a valid {@link BigInteger}.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   * @since 1.2
-   */
-  public BigInteger getAsBigInteger() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * convenience method to get this element as a primitive short value.
-   *
-   * @return get this element as a primitive short value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * short value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  public short getAsShort() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
-  /**
-   * Returns a String representation of this element.
-   */
-  @Override
-  public String toString() {
-    try {
-      final StringWriter stringWriter = new StringWriter();
-      final JsonWriter jsonWriter = new JsonWriter(stringWriter, JsonOption.LENIENT);
-      write(jsonWriter, this);
-      return stringWriter.toString();
-    } catch (final IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private void write(final JsonWriter out, final JsonElement value) throws IOException {
-    if (value == null || value.isJsonNull()) {
-      out.nullValue();
-    } else if (value.isJsonPrimitive()) {
-      final JsonPrimitive primitive = value.getAsJsonPrimitive();
-      if (primitive.isNumber()) {
-        out.value(primitive.getAsNumber());
-      } else if (primitive.isBoolean()) {
-        out.value(primitive.getAsBoolean());
-      } else {
-        out.value(primitive.getAsString());
-      }
-
-    } else if (value.isJsonArray()) {
-      out.beginArray();
-      for (final JsonElement e : value.getAsJsonArray()) {
-        write(out, e);
-      }
-      out.endArray();
-
-    } else if (value.isJsonObject()) {
-      out.beginObject();
-      for (final Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {
-        out.name(e.getKey());
-        write(out, e.getValue());
-      }
-      out.endObject();
-
-    } else {
-      throw new IllegalArgumentException("Couldn't write " + value.getClass());
-    }
-  }
-
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java
deleted file mode 100644
index 34a9a5be7..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonIOException.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.jsoncore.imp;
-
-/**
- * This exception is raised when Gson was unable to read an input stream
- * or write to one.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class JsonIOException extends JsonParseException {
-  private static final long serialVersionUID = 1L;
-
-  public JsonIOException(final String msg) {
-    super(msg);
-  }
-
-  public JsonIOException(final String msg, final Throwable cause) {
-    super(msg, cause);
-  }
-
-  /**
-   * Creates exception with the specified cause. Consider using
-   * {@link #JsonIOException(String, Throwable)} instead if you can describe what happened.
-   *
-   * @param cause root exception that caused this exception to be thrown.
-   */
-  public JsonIOException(final Throwable cause) {
-    super(cause);
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java
deleted file mode 100755
index d4ea3ef02..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonNull.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-/**
- * A class representing a Json {@code null} value.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.2
- */
-public final class JsonNull extends JsonElement {
-  /**
-   * singleton for JsonNull
-   *
-   * @since 1.8
-   */
-  public static final JsonNull INSTANCE = new JsonNull();
-
-  /**
-   * Creates a new JsonNull object.
-   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead
-   */
-  @Deprecated
-  public JsonNull() {
-    // Do nothing
-  }
-
-  @Override
-  JsonNull deepCopy() {
-    return INSTANCE;
-  }
-
-  /**
-   * All instances of JsonNull have the same hash code since they are indistinguishable
-   */
-  @Override
-  public int hashCode() {
-    return JsonNull.class.hashCode();
-  }
-
-  /**
-   * All instances of JsonNull are the same
-   */
-  @Override
-  public boolean equals(final Object other) {
-    return this == other || other instanceof JsonNull;
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java
deleted file mode 100644
index 6fc385e26..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonObject.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.util.Map;
-import java.util.Set;
-
-/**
- * A class representing an object type in Json. An object consists of name-value pairs where names
- * are strings, and values are any other type of {@link JsonElement}. This allows for a creating a
- * tree of JsonElements. The member elements of this object are maintained in order they were added.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class JsonObject extends JsonElement {
-  private final LinkedTreeMap<String, JsonElement> members =
-      new LinkedTreeMap<String, JsonElement>();
-
-  @Override
-  JsonObject deepCopy() {
-    final JsonObject result = new JsonObject();
-    for (final Map.Entry<String, JsonElement> entry : members.entrySet()) {
-      result.add(entry.getKey(), entry.getValue().deepCopy());
-    }
-    return result;
-  }
-
-  /**
-   * Adds a member, which is a name-value pair, to self. The name must be a String, but the value
-   * can be an arbitrary JsonElement, thereby allowing you to build a full tree of JsonElements
-   * rooted at this node.
-   *
-   * @param property name of the member.
-   * @param value the member object.
-   */
-  public void add(final String property, JsonElement value) {
-    if (value == null) {
-      value = JsonNull.INSTANCE;
-    }
-    members.put(property, value);
-  }
-
-  /**
-   * Removes the {@code property} from this {@link JsonObject}.
-   *
-   * @param property name of the member that should be removed.
-   * @return the {@link JsonElement} object that is being removed.
-   * @since 1.3
-   */
-  public JsonElement remove(final String property) {
-    return members.remove(property);
-  }
-
-  /**
-   * Convenience method to add a primitive member. The specified value is converted to a
-   * JsonPrimitive of String.
-   *
-   * @param property name of the member.
-   * @param value the string value associated with the member.
-   */
-  public void addProperty(final String property, final String value) {
-    add(property, createJsonElement(value));
-  }
-
-  /**
-   * Convenience method to add a primitive member. The specified value is converted to a
-   * JsonPrimitive of Number.
-   *
-   * @param property name of the member.
-   * @param value the number value associated with the member.
-   */
-  public void addProperty(final String property, final Number value) {
-    add(property, createJsonElement(value));
-  }
-
-  /**
-   * Convenience method to add a boolean member. The specified value is converted to a
-   * JsonPrimitive of Boolean.
-   *
-   * @param property name of the member.
-   * @param value the number value associated with the member.
-   */
-  public void addProperty(final String property, final Boolean value) {
-    add(property, createJsonElement(value));
-  }
-
-  /**
-   * Convenience method to add a char member. The specified value is converted to a
-   * JsonPrimitive of Character.
-   *
-   * @param property name of the member.
-   * @param value the number value associated with the member.
-   */
-  public void addProperty(final String property, final Character value) {
-    add(property, createJsonElement(value));
-  }
-
-  /**
-   * Creates the proper {@link JsonElement} object from the given {@code value} object.
-   *
-   * @param value the object to generate the {@link JsonElement} for
-   * @return a {@link JsonPrimitive} if the {@code value} is not null, otherwise a {@link JsonNull}
-   */
-  private JsonElement createJsonElement(final Object value) {
-    return value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);
-  }
-
-  /**
-   * Returns a set of members of this object. The set is ordered, and the order is in which the
-   * elements were added.
-   *
-   * @return a set of members of this object.
-   */
-  public Set<Map.Entry<String, JsonElement>> entrySet() {
-    return members.entrySet();
-  }
-
-  /**
-   * Convenience method to check if a member with the specified name is present in this object.
-   *
-   * @param memberName name of the member that is being checked for presence.
-   * @return true if there is a member with the specified name, false otherwise.
-   */
-  public boolean has(final String memberName) {
-    return members.containsKey(memberName);
-  }
-
-  /**
-   * Returns the member with the specified name.
-   *
-   * @param memberName name of the member that is being requested.
-   * @return the member matching the name. Null if no such member exists.
-   */
-  public JsonElement get(final String memberName) {
-    return members.get(memberName);
-  }
-
-  /**
-   * Convenience method to get the specified member as a JsonPrimitive element.
-   *
-   * @param memberName name of the member being requested.
-   * @return the JsonPrimitive corresponding to the specified member.
-   */
-  public JsonPrimitive getAsJsonPrimitive(final String memberName) {
-    return (JsonPrimitive) members.get(memberName);
-  }
-
-  /**
-   * Convenience method to get the specified member as a JsonArray.
-   *
-   * @param memberName name of the member being requested.
-   * @return the JsonArray corresponding to the specified member.
-   */
-  public JsonArray getAsJsonArray(final String memberName) {
-    return (JsonArray) members.get(memberName);
-  }
-
-  /**
-   * Convenience method to get the specified member as a JsonObject.
-   *
-   * @param memberName name of the member being requested.
-   * @return the JsonObject corresponding to the specified member.
-   */
-  public JsonObject getAsJsonObject(final String memberName) {
-    return (JsonObject) members.get(memberName);
-  }
-
-  @Override
-  public boolean equals(final Object o) {
-    return (o == this) || (o instanceof JsonObject
-        && ((JsonObject) o).members.equals(members));
-  }
-
-  @Override
-  public int hashCode() {
-    return members.hashCode();
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java
deleted file mode 100644
index 77b0dee7e..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonPrimitive.java
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.math.BigDecimal;
-import java.math.BigInteger;
-
-/**
- * A class representing a Json primitive value. A primitive value
- * is either a String, a Java primitive, or a Java primitive
- * wrapper type.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class JsonPrimitive extends JsonElement {
-
-  private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,
-      float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,
-      Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };
-
-  private Object value;
-
-  /**
-   * Create a primitive containing a boolean value.
-   *
-   * @param bool the value to create the primitive with.
-   */
-  public JsonPrimitive(final Boolean bool) {
-    setValue(bool);
-  }
-
-  /**
-   * Create a primitive containing a {@link Number}.
-   *
-   * @param number the value to create the primitive with.
-   */
-  public JsonPrimitive(final Number number) {
-    setValue(number);
-  }
-
-  /**
-   * Create a primitive containing a String value.
-   *
-   * @param string the value to create the primitive with.
-   */
-  public JsonPrimitive(final String string) {
-    setValue(string);
-  }
-
-  /**
-   * Create a primitive containing a character. The character is turned into a one character String
-   * since Json only supports String.
-   *
-   * @param c the value to create the primitive with.
-   */
-  public JsonPrimitive(final Character c) {
-    setValue(c);
-  }
-
-  /**
-   * Create a primitive using the specified Object. It must be an instance of {@link Number}, a
-   * Java primitive type, or a String.
-   *
-   * @param primitive the value to create the primitive with.
-   */
-  JsonPrimitive(final Object primitive) {
-    setValue(primitive);
-  }
-
-  @Override
-  JsonPrimitive deepCopy() {
-    return this;
-  }
-
-  void setValue(final Object primitive) {
-    if (primitive instanceof Character) {
-      // convert characters to strings since in JSON, characters are represented as a single
-      // character string
-      final char c = ((Character) primitive).charValue();
-      value = String.valueOf(c);
-    } else {
-      Preconditions.checkArgument(primitive instanceof Number
-              || isPrimitiveOrString(primitive));
-      value = primitive;
-    }
-  }
-
-  /**
-   * Check whether this primitive contains a boolean value.
-   *
-   * @return true if this primitive contains a boolean value, false otherwise.
-   */
-  public boolean isBoolean() {
-    return value instanceof Boolean;
-  }
-
-  /**
-   * convenience method to get this element as a {@link Boolean}.
-   *
-   * @return get this element as a {@link Boolean}.
-   */
-  @Override
-  Boolean getAsBooleanWrapper() {
-    return (Boolean) value;
-  }
-
-  /**
-   * convenience method to get this element as a boolean value.
-   *
-   * @return get this element as a primitive boolean value.
-   */
-  @Override
-  public boolean getAsBoolean() {
-    if (isBoolean()) {
-      return getAsBooleanWrapper().booleanValue();
-    } else {
-      // Check to see if the value as a String is "true" in any case.
-      return Boolean.parseBoolean(getAsString());
-    }
-  }
-
-  /**
-   * Check whether this primitive contains a Number.
-   *
-   * @return true if this primitive contains a Number, false otherwise.
-   */
-  public boolean isNumber() {
-    return value instanceof Number;
-  }
-
-  /**
-   * convenience method to get this element as a Number.
-   *
-   * @return get this element as a Number.
-   * @throws NumberFormatException if the value contained is not a valid Number.
-   */
-  @Override
-  public Number getAsNumber() {
-    return value instanceof String ? new LazilyParsedNumber((String) value) : (Number) value;
-  }
-
-  /**
-   * Check whether this primitive contains a String value.
-   *
-   * @return true if this primitive contains a String value, false otherwise.
-   */
-  public boolean isString() {
-    return value instanceof String;
-  }
-
-  /**
-   * convenience method to get this element as a String.
-   *
-   * @return get this element as a String.
-   */
-  @Override
-  public String getAsString() {
-    if (isNumber()) {
-      return getAsNumber().toString();
-    } else if (isBoolean()) {
-      return getAsBooleanWrapper().toString();
-    } else {
-      return (String) value;
-    }
-  }
-
-  /**
-   * convenience method to get this element as a primitive double.
-   *
-   * @return get this element as a primitive double.
-   * @throws NumberFormatException if the value contained is not a valid double.
-   */
-  @Override
-  public double getAsDouble() {
-    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());
-  }
-
-  /**
-   * convenience method to get this element as a {@link BigDecimal}.
-   *
-   * @return get this element as a {@link BigDecimal}.
-   * @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.
-   */
-  @Override
-  public BigDecimal getAsBigDecimal() {
-    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString());
-  }
-
-  /**
-   * convenience method to get this element as a {@link BigInteger}.
-   *
-   * @return get this element as a {@link BigInteger}.
-   * @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.
-   */
-  @Override
-  public BigInteger getAsBigInteger() {
-    return value instanceof BigInteger ?
-        (BigInteger) value : new BigInteger(value.toString());
-  }
-
-  /**
-   * convenience method to get this element as a float.
-   *
-   * @return get this element as a float.
-   * @throws NumberFormatException if the value contained is not a valid float.
-   */
-  @Override
-  public float getAsFloat() {
-    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());
-  }
-
-  /**
-   * convenience method to get this element as a primitive long.
-   *
-   * @return get this element as a primitive long.
-   * @throws NumberFormatException if the value contained is not a valid long.
-   */
-  @Override
-  public long getAsLong() {
-    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());
-  }
-
-  /**
-   * convenience method to get this element as a primitive short.
-   *
-   * @return get this element as a primitive short.
-   * @throws NumberFormatException if the value contained is not a valid short value.
-   */
-  @Override
-  public short getAsShort() {
-    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());
-  }
-
- /**
-  * convenience method to get this element as a primitive integer.
-  *
-  * @return get this element as a primitive integer.
-  * @throws NumberFormatException if the value contained is not a valid integer.
-  */
-  @Override
-  public int getAsInt() {
-    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());
-  }
-
-  @Override
-  public byte getAsByte() {
-    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());
-  }
-
-  @Override
-  public char getAsCharacter() {
-    return getAsString().charAt(0);
-  }
-
-  private static boolean isPrimitiveOrString(final Object target) {
-    if (target instanceof String) {
-      return true;
-    }
-
-    final Class<?> classOfPrimitive = target.getClass();
-    for (final Class<?> standardPrimitive : PRIMITIVE_TYPES) {
-      if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override
-  public int hashCode() {
-    if (value == null) {
-      return 31;
-    }
-    // Using recommended hashing algorithm from Effective Java for longs and doubles
-    if (isIntegral(this)) {
-      final long value = getAsNumber().longValue();
-      return (int) (value ^ (value >>> 32));
-    }
-    if (value instanceof Number) {
-      final long value = Double.doubleToLongBits(getAsNumber().doubleValue());
-      return (int) (value ^ (value >>> 32));
-    }
-    return value.hashCode();
-  }
-
-  @Override
-  public boolean equals(final Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
-    }
-    final JsonPrimitive other = (JsonPrimitive)obj;
-    if (value == null) {
-      return other.value == null;
-    }
-    if (isIntegral(this) && isIntegral(other)) {
-      return getAsNumber().longValue() == other.getAsNumber().longValue();
-    }
-    if (value instanceof Number && other.value instanceof Number) {
-      final double a = getAsNumber().doubleValue();
-      // Java standard types other than double return true for two NaN. So, need
-      // special handling for double.
-      final double b = other.getAsNumber().doubleValue();
-      return a == b || (Double.isNaN(a) && Double.isNaN(b));
-    }
-    return value.equals(other.value);
-  }
-
-  /**
-   * Returns true if the specified number is an integral type
-   * (Long, Integer, Short, Byte, BigInteger)
-   */
-  private static boolean isIntegral(final JsonPrimitive primitive) {
-    if (primitive.value instanceof Number) {
-      final Number number = (Number) primitive.value;
-      return number instanceof BigInteger || number instanceof Long || number instanceof Integer
-          || number instanceof Short || number instanceof Byte;
-    }
-    return false;
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
index 3d5ad9c2e..628f10da0 100644
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
+++ b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReader.java
@@ -1577,29 +1577,4 @@ private void consumeNonExecutePrefix() {
     pos += NON_EXECUTE_PREFIX.length;
   }
 
-  static {
-    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {
-      @Override public void promoteNameToValue(final JsonReader reader) {
-        if (reader instanceof JsonTreeReader) {
-          ((JsonTreeReader)reader).promoteNameToValue();
-          return;
-        }
-        int p = reader.peeked;
-        if (p == PEEKED_NONE) {
-          p = reader.doPeek();
-        }
-        if (p == PEEKED_DOUBLE_QUOTED_NAME) {
-          reader.peeked = PEEKED_DOUBLE_QUOTED;
-        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
-          reader.peeked = PEEKED_SINGLE_QUOTED;
-        } else if (p == PEEKED_UNQUOTED_NAME) {
-          reader.peeked = PEEKED_UNQUOTED;
-        } else {
-          throw new IllegalStateException("Expected a name but was " + reader.peek() + " "
-              + " at line " + reader.getLineNumber() + " column " + reader.getColumnNumber()
-              + " path " + reader.getPath());
-        }
-      }
-    };
-  }
 }
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
deleted file mode 100644
index eee348a90..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonReaderInternalAccess.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.io.IOException;
-
-/**
- * Internal-only APIs of JsonReader available only to other classes in Gson.
- */
-public abstract class JsonReaderInternalAccess {
-  public static JsonReaderInternalAccess INSTANCE;
-
-  /**
-   * Changes the type of the current property name token to a string value.
-   */
-  public abstract void promoteNameToValue(JsonReader reader) throws IOException;
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java
deleted file mode 100644
index 6ade8c539..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonSyntaxException.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.jsoncore.imp;
-
-/**
- * This exception is raised when Gson attempts to read (or write) a malformed
- * JSON element.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-public final class JsonSyntaxException extends JsonParseException {
-
-  private static final long serialVersionUID = 1L;
-
-  public JsonSyntaxException(final String msg) {
-    super(msg);
-  }
-
-  public JsonSyntaxException(final String msg, final Throwable cause) {
-    super(msg, cause);
-  }
-
-  /**
-   * Creates exception with the specified cause. Consider using
-   * {@link #JsonSyntaxException(String, Throwable)} instead if you can
-   * describe what actually happened.
-   *
-   * @param cause root exception that caused this exception to be thrown.
-   */
-  public JsonSyntaxException(final Throwable cause) {
-    super(cause);
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
deleted file mode 100644
index a803f5046..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/JsonTreeReader.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.io.Reader;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import com.github.gv2011.jsoncore.JsonToken;
-
-/**
- * This reader walks the elements of a JsonElement as if it was coming from a
- * character stream.
- *
- * @author Jesse Wilson
- */
-public final class JsonTreeReader extends JsonReader {
-  private static final Reader UNREADABLE_READER = new Reader() {
-    @Override public int read(final char[] buffer, final int offset, final int count){
-      throw new AssertionError();
-    }
-    @Override public void close(){
-      throw new AssertionError();
-    }
-  };
-  private static final Object SENTINEL_CLOSED = new Object();
-
-  private final List<Object> stack = new ArrayList<Object>();
-
-  public JsonTreeReader(final JsonElement element) {
-    super(UNREADABLE_READER);
-    stack.add(element);
-  }
-
-  @Override public void beginArray(){
-    expect(JsonToken.BEGIN_ARRAY);
-    final JsonArray array = (JsonArray) peekStack();
-    stack.add(array.iterator());
-  }
-
-  @Override public void endArray(){
-    expect(JsonToken.END_ARRAY);
-    popStack(); // empty iterator
-    popStack(); // array
-  }
-
-  @Override public void beginObject(){
-    expect(JsonToken.BEGIN_OBJECT);
-    final JsonObject object = (JsonObject) peekStack();
-    stack.add(object.entrySet().iterator());
-  }
-
-  @Override public void endObject(){
-    expect(JsonToken.END_OBJECT);
-    popStack(); // empty iterator
-    popStack(); // object
-  }
-
-  @Override public boolean hasNext(){
-    final JsonToken token = peek();
-    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
-  }
-
-  @Override public JsonToken peek(){
-    if (stack.isEmpty()) {
-      return JsonToken.END_DOCUMENT;
-    }
-
-    final Object o = peekStack();
-    if (o instanceof Iterator) {
-      final boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
-      final Iterator<?> iterator = (Iterator<?>) o;
-      if (iterator.hasNext()) {
-        if (isObject) {
-          return JsonToken.NAME;
-        } else {
-          stack.add(iterator.next());
-          return peek();
-        }
-      } else {
-        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
-      }
-    } else if (o instanceof JsonObject) {
-      return JsonToken.BEGIN_OBJECT;
-    } else if (o instanceof JsonArray) {
-      return JsonToken.BEGIN_ARRAY;
-    } else if (o instanceof JsonPrimitive) {
-      final JsonPrimitive primitive = (JsonPrimitive) o;
-      if (primitive.isString()) {
-        return JsonToken.STRING;
-      } else if (primitive.isBoolean()) {
-        return JsonToken.BOOLEAN;
-      } else if (primitive.isNumber()) {
-        return JsonToken.NUMBER;
-      } else {
-        throw new AssertionError();
-      }
-    } else if (o instanceof JsonNull) {
-      return JsonToken.NULL;
-    } else if (o == SENTINEL_CLOSED) {
-      throw new IllegalStateException("JsonReader is closed");
-    } else {
-      throw new AssertionError();
-    }
-  }
-
-  private Object peekStack() {
-    return stack.get(stack.size() - 1);
-  }
-
-  private Object popStack() {
-    return stack.remove(stack.size() - 1);
-  }
-
-  private void expect(final JsonToken expected){
-    if (peek() != expected) {
-      throw new IllegalStateException("Expected " + expected + " but was " + peek());
-    }
-  }
-
-  @Override public String nextName(){
-    expect(JsonToken.NAME);
-    final Iterator<?> i = (Iterator<?>) peekStack();
-    final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    return (String) entry.getKey();
-  }
-
-  @Override public String nextString(){
-    final JsonToken token = peek();
-    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
-      throw new IllegalStateException("Expected " + JsonToken.STRING + " but was " + token);
-    }
-    return ((JsonPrimitive) popStack()).getAsString();
-  }
-
-  @Override public boolean nextBoolean(){
-    expect(JsonToken.BOOLEAN);
-    return ((JsonPrimitive) popStack()).getAsBoolean();
-  }
-
-  @Override public void nextNull(){
-    expect(JsonToken.NULL);
-    popStack();
-  }
-
-  @Override public double nextDouble(){
-    final JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
-    }
-    final double result = ((JsonPrimitive) peekStack()).getAsDouble();
-    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
-    }
-    popStack();
-    return result;
-  }
-
-  @Override public long nextLong(){
-    final JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
-    }
-    final long result = ((JsonPrimitive) peekStack()).getAsLong();
-    popStack();
-    return result;
-  }
-
-  @Override public int nextInt(){
-    final JsonToken token = peek();
-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
-    }
-    final int result = ((JsonPrimitive) peekStack()).getAsInt();
-    popStack();
-    return result;
-  }
-
-  @Override public void close(){
-    stack.clear();
-    stack.add(SENTINEL_CLOSED);
-  }
-
-  @Override public void skipValue(){
-    if (peek() == JsonToken.NAME) {
-      nextName();
-    } else {
-      popStack();
-    }
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
-
-  public void promoteNameToValue(){
-    expect(JsonToken.NAME);
-    final Iterator<?> i = (Iterator<?>) peekStack();
-    final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    stack.add(new JsonPrimitive((String)entry.getKey()));
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
deleted file mode 100644
index affb5c467..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumber.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.jsoncore.imp;
-
-import java.io.ObjectStreamException;
-import java.math.BigDecimal;
-
-/**
- * This class holds a number value that is lazily converted to a specific number type
- *
- * @author Inderjeet Singh
- */
-public final class LazilyParsedNumber extends Number {
-  private final String value;
-
-  /** @param value must not be null */
-  public LazilyParsedNumber(final String value) {
-    this.value = value;
-  }
-
-  @Override
-  public int intValue() {
-    try {
-      return Integer.parseInt(value);
-    } catch (final NumberFormatException e) {
-      try {
-        return (int) Long.parseLong(value);
-      } catch (final NumberFormatException nfe) {
-        return new BigDecimal(value).intValue();
-      }
-    }
-  }
-
-  @Override
-  public long longValue() {
-    try {
-      return Long.parseLong(value);
-    } catch (final NumberFormatException e) {
-      return new BigDecimal(value).longValue();
-    }
-  }
-
-  @Override
-  public float floatValue() {
-    return Float.parseFloat(value);
-  }
-
-  @Override
-  public double doubleValue() {
-    return Double.parseDouble(value);
-  }
-
-  @Override
-  public String toString() {
-    return value;
-  }
-
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a BigDecimal so that they won't need Gson on the other side to
-   * deserialize it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new BigDecimal(value);
-  }
-
-  @Override
-  public int hashCode() {
-    return value.hashCode();
-  }
-
-  @Override
-  public boolean equals(final Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj instanceof LazilyParsedNumber) {
-      final LazilyParsedNumber other = (LazilyParsedNumber) obj;
-      return value == other.value || value.equals(other.value);
-    }
-    return false;
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
deleted file mode 100644
index f75a75b92..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/LinkedTreeMap.java
+++ /dev/null
@@ -1,640 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.util.AbstractMap;
-import java.util.AbstractSet;
-import java.util.Comparator;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-/**
- * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses
- * insertion order for iteration order. Comparison order is only used as an
- * optimization for efficient insertion and removal.
- *
- * <p>This implementation was derived from Android 4.1's TreeMap class.
- */
-public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
-  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
-    @Override
-    public int compare(final Comparable a, final Comparable b) {
-      return a.compareTo(b);
-    }
-  };
-
-  Comparator<? super K> comparator;
-  Node<K, V> root;
-  int size = 0;
-  int modCount = 0;
-
-  // Used to preserve iteration order
-  final Node<K, V> header = new Node<K, V>();
-
-  /**
-   * Create a natural order, empty tree map whose keys must be mutually
-   * comparable and non-null.
-   */
-  @SuppressWarnings("unchecked") // unsafe! this assumes K is comparable
-  public LinkedTreeMap() {
-    this((Comparator<? super K>) NATURAL_ORDER);
-  }
-
-  /**
-   * Create a tree map ordered by {@code comparator}. This map's keys may only
-   * be null if {@code comparator} permits.
-   *
-   * @param comparator the comparator to order elements with, or {@code null} to
-   *     use the natural ordering.
-   */
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // unsafe! if comparator is null, this assumes K is comparable
-  public LinkedTreeMap(final Comparator<? super K> comparator) {
-    this.comparator = comparator != null
-        ? comparator
-        : (Comparator) NATURAL_ORDER;
-  }
-
-  @Override public int size() {
-    return size;
-  }
-
-  @Override public V get(final Object key) {
-    final Node<K, V> node = findByObject(key);
-    return node != null ? node.value : null;
-  }
-
-  @Override public boolean containsKey(final Object key) {
-    return findByObject(key) != null;
-  }
-
-  @Override public V put(final K key, final V value) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-    final Node<K, V> created = find(key, true);
-    final V result = created.value;
-    created.value = value;
-    return result;
-  }
-
-  @Override public void clear() {
-    root = null;
-    size = 0;
-    modCount++;
-
-    // Clear iteration order
-    final Node<K, V> header = this.header;
-    header.next = header.prev = header;
-  }
-
-  @Override public V remove(final Object key) {
-    final Node<K, V> node = removeInternalByKey(key);
-    return node != null ? node.value : null;
-  }
-
-  /**
-   * Returns the node at or adjacent to the given key, creating it if requested.
-   *
-   * @throws ClassCastException if {@code key} and the tree's keys aren't
-   *     mutually comparable.
-   */
-  Node<K, V> find(final K key, final boolean create) {
-    final Comparator<? super K> comparator = this.comparator;
-    Node<K, V> nearest = root;
-    int comparison = 0;
-
-    if (nearest != null) {
-      // Micro-optimization: avoid polymorphic calls to Comparator.compare().
-      @SuppressWarnings("unchecked") // Throws a ClassCastException below if there's trouble.
-      final
-          Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)
-          ? (Comparable<Object>) key
-          : null;
-
-      while (true) {
-        comparison = (comparableKey != null)
-            ? comparableKey.compareTo(nearest.key)
-            : comparator.compare(key, nearest.key);
-
-        // We found the requested key.
-        if (comparison == 0) {
-          return nearest;
-        }
-
-        // If it exists, the key is in a subtree. Go deeper.
-        final Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
-        if (child == null) {
-          break;
-        }
-
-        nearest = child;
-      }
-    }
-
-    // The key doesn't exist in this tree.
-    if (!create) {
-      return null;
-    }
-
-    // Create the node and add it to the tree or the table.
-    final Node<K, V> header = this.header;
-    Node<K, V> created;
-    if (nearest == null) {
-      // Check that the value is comparable if we didn't do any comparisons.
-      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {
-        throw new ClassCastException(key.getClass().getName() + " is not Comparable");
-      }
-      created = new Node<K, V>(nearest, key, header, header.prev);
-      root = created;
-    } else {
-      created = new Node<K, V>(nearest, key, header, header.prev);
-      if (comparison < 0) { // nearest.key is higher
-        nearest.left = created;
-      } else { // comparison > 0, nearest.key is lower
-        nearest.right = created;
-      }
-      rebalance(nearest, true);
-    }
-    size++;
-    modCount++;
-
-    return created;
-  }
-
-  @SuppressWarnings("unchecked")
-  Node<K, V> findByObject(final Object key) {
-    try {
-      return key != null ? find((K) key, false) : null;
-    } catch (final ClassCastException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns this map's entry that has the same key and value as {@code
-   * entry}, or null if this map has no such entry.
-   *
-   * <p>This method uses the comparator for key equality rather than {@code
-   * equals}. If this map's comparator isn't consistent with equals (such as
-   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
-   * contains()} will violate the collections API.
-   */
-  Node<K, V> findByEntry(final Entry<?, ?> entry) {
-    final Node<K, V> mine = findByObject(entry.getKey());
-    final boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
-    return valuesEqual ? mine : null;
-  }
-
-  private boolean equal(final Object a, final Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Removes {@code node} from this tree, rearranging the tree's structure as
-   * necessary.
-   *
-   * @param unlink true to also unlink this node from the iteration linked list.
-   */
-  void removeInternal(final Node<K, V> node, final boolean unlink) {
-    if (unlink) {
-      node.prev.next = node.next;
-      node.next.prev = node.prev;
-    }
-
-    Node<K, V> left = node.left;
-    Node<K, V> right = node.right;
-    final Node<K, V> originalParent = node.parent;
-    if (left != null && right != null) {
-
-      /*
-       * To remove a node with both left and right subtrees, move an
-       * adjacent node from one of those subtrees into this node's place.
-       *
-       * Removing the adjacent node may change this node's subtrees. This
-       * node may no longer have two subtrees once the adjacent node is
-       * gone!
-       */
-
-      final Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
-      removeInternal(adjacent, false); // takes care of rebalance and size--
-
-      int leftHeight = 0;
-      left = node.left;
-      if (left != null) {
-        leftHeight = left.height;
-        adjacent.left = left;
-        left.parent = adjacent;
-        node.left = null;
-      }
-
-      int rightHeight = 0;
-      right = node.right;
-      if (right != null) {
-        rightHeight = right.height;
-        adjacent.right = right;
-        right.parent = adjacent;
-        node.right = null;
-      }
-
-      adjacent.height = Math.max(leftHeight, rightHeight) + 1;
-      replaceInParent(node, adjacent);
-      return;
-    } else if (left != null) {
-      replaceInParent(node, left);
-      node.left = null;
-    } else if (right != null) {
-      replaceInParent(node, right);
-      node.right = null;
-    } else {
-      replaceInParent(node, null);
-    }
-
-    rebalance(originalParent, false);
-    size--;
-    modCount++;
-  }
-
-  Node<K, V> removeInternalByKey(final Object key) {
-    final Node<K, V> node = findByObject(key);
-    if (node != null) {
-      removeInternal(node, true);
-    }
-    return node;
-  }
-
-  private void replaceInParent(final Node<K, V> node, final Node<K, V> replacement) {
-    final Node<K, V> parent = node.parent;
-    node.parent = null;
-    if (replacement != null) {
-      replacement.parent = parent;
-    }
-
-    if (parent != null) {
-      if (parent.left == node) {
-        parent.left = replacement;
-      } else {
-        assert (parent.right == node);
-        parent.right = replacement;
-      }
-    } else {
-      root = replacement;
-    }
-  }
-
-  /**
-   * Rebalances the tree by making any AVL rotations necessary between the
-   * newly-unbalanced node and the tree's root.
-   *
-   * @param insert true if the node was unbalanced by an insert; false if it
-   *     was by a removal.
-   */
-  private void rebalance(final Node<K, V> unbalanced, final boolean insert) {
-    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
-      final Node<K, V> left = node.left;
-      final Node<K, V> right = node.right;
-      final int leftHeight = left != null ? left.height : 0;
-      final int rightHeight = right != null ? right.height : 0;
-
-      final int delta = leftHeight - rightHeight;
-      if (delta == -2) {
-        final Node<K, V> rightLeft = right.left;
-        final Node<K, V> rightRight = right.right;
-        final int rightRightHeight = rightRight != null ? rightRight.height : 0;
-        final int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
-
-        final int rightDelta = rightLeftHeight - rightRightHeight;
-        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
-          rotateLeft(node); // AVL right right
-        } else {
-          assert (rightDelta == 1);
-          rotateRight(right); // AVL right left
-          rotateLeft(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 2) {
-        final Node<K, V> leftLeft = left.left;
-        final Node<K, V> leftRight = left.right;
-        final int leftRightHeight = leftRight != null ? leftRight.height : 0;
-        final int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
-
-        final int leftDelta = leftLeftHeight - leftRightHeight;
-        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
-          rotateRight(node); // AVL left left
-        } else {
-          assert (leftDelta == -1);
-          rotateLeft(left); // AVL left right
-          rotateRight(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 0) {
-        node.height = leftHeight + 1; // leftHeight == rightHeight
-        if (insert) {
-          break; // the insert caused balance, so rebalancing is done!
-        }
-
-      } else {
-        assert (delta == -1 || delta == 1);
-        node.height = Math.max(leftHeight, rightHeight) + 1;
-        if (!insert) {
-          break; // the height hasn't changed, so rebalancing is done!
-        }
-      }
-    }
-  }
-
-  /**
-   * Rotates the subtree so that its root's right child is the new root.
-   */
-  private void rotateLeft(final Node<K, V> root) {
-    final Node<K, V> left = root.left;
-    final Node<K, V> pivot = root.right;
-    final Node<K, V> pivotLeft = pivot.left;
-    final Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's left child to the root's right
-    root.right = pivotLeft;
-    if (pivotLeft != null) {
-      pivotLeft.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's left
-    pivot.left = root;
-    root.parent = pivot;
-
-    // fix heights
-    root.height = Math.max(left != null ? left.height : 0,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-  }
-
-  /**
-   * Rotates the subtree so that its root's left child is the new root.
-   */
-  private void rotateRight(final Node<K, V> root) {
-    final Node<K, V> pivot = root.left;
-    final Node<K, V> right = root.right;
-    final Node<K, V> pivotLeft = pivot.left;
-    final Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's right child to the root's left
-    root.left = pivotRight;
-    if (pivotRight != null) {
-      pivotRight.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's right
-    pivot.right = root;
-    root.parent = pivot;
-
-    // fixup heights
-    root.height = Math.max(right != null ? right.height : 0,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-  }
-
-  private EntrySet entrySet;
-  private KeySet keySet;
-
-  @Override public Set<Entry<K, V>> entrySet() {
-    final EntrySet result = entrySet;
-    return result != null ? result : (entrySet = new EntrySet());
-  }
-
-  @Override public Set<K> keySet() {
-    final KeySet result = keySet;
-    return result != null ? result : (keySet = new KeySet());
-  }
-
-  static final class Node<K, V> implements Entry<K, V> {
-    Node<K, V> parent;
-    Node<K, V> left;
-    Node<K, V> right;
-    Node<K, V> next;
-    Node<K, V> prev;
-    final K key;
-    V value;
-    int height;
-
-    /** Create the header entry */
-    Node() {
-      key = null;
-      next = prev = this;
-    }
-
-    /** Create a regular entry */
-    Node(final Node<K, V> parent, final K key, final Node<K, V> next, final Node<K, V> prev) {
-      this.parent = parent;
-      this.key = key;
-      this.height = 1;
-      this.next = next;
-      this.prev = prev;
-      prev.next = this;
-      next.prev = this;
-    }
-
-    @Override
-    public K getKey() {
-      return key;
-    }
-
-    @Override
-    public V getValue() {
-      return value;
-    }
-
-    @Override
-    public V setValue(final V value) {
-      final V oldValue = this.value;
-      this.value = value;
-      return oldValue;
-    }
-
-    @SuppressWarnings("rawtypes")
-    @Override public boolean equals(final Object o) {
-      if (o instanceof Entry) {
-        final Entry other = (Entry) o;
-        return (key == null ? other.getKey() == null : key.equals(other.getKey()))
-            && (value == null ? other.getValue() == null : value.equals(other.getValue()));
-      }
-      return false;
-    }
-
-    @Override public int hashCode() {
-      return (key == null ? 0 : key.hashCode())
-          ^ (value == null ? 0 : value.hashCode());
-    }
-
-    @Override public String toString() {
-      return key + "=" + value;
-    }
-
-    /**
-     * Returns the first node in this subtree.
-     */
-    public Node<K, V> first() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.left;
-      while (child != null) {
-        node = child;
-        child = node.left;
-      }
-      return node;
-    }
-
-    /**
-     * Returns the last node in this subtree.
-     */
-    public Node<K, V> last() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.right;
-      while (child != null) {
-        node = child;
-        child = node.right;
-      }
-      return node;
-    }
-  }
-
-  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {
-    Node<K, V> next = header.next;
-    Node<K, V> lastReturned = null;
-    int expectedModCount = modCount;
-
-    LinkedTreeMapIterator() {
-    }
-
-    @Override
-    public final boolean hasNext() {
-      return next != header;
-    }
-
-    final Node<K, V> nextNode() {
-      final Node<K, V> e = next;
-      if (e == header) {
-        throw new NoSuchElementException();
-      }
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
-      }
-      next = e.next;
-      return lastReturned = e;
-    }
-
-    @Override
-    public final void remove() {
-      if (lastReturned == null) {
-        throw new IllegalStateException();
-      }
-      removeInternal(lastReturned, true);
-      lastReturned = null;
-      expectedModCount = modCount;
-    }
-  }
-
-  class EntrySet extends AbstractSet<Entry<K, V>> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<Entry<K, V>> iterator() {
-      return new LinkedTreeMapIterator<Entry<K, V>>() {
-        @Override
-        public Entry<K, V> next() {
-          return nextNode();
-        }
-      };
-    }
-
-    @Override public boolean contains(final Object o) {
-      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
-    }
-
-    @Override public boolean remove(final Object o) {
-      if (!(o instanceof Entry)) {
-        return false;
-      }
-
-      final Node<K, V> node = findByEntry((Entry<?, ?>) o);
-      if (node == null) {
-        return false;
-      }
-      removeInternal(node, true);
-      return true;
-    }
-
-    @Override public void clear() {
-      LinkedTreeMap.this.clear();
-    }
-  }
-
-  final class KeySet extends AbstractSet<K> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<K> iterator() {
-      return new LinkedTreeMapIterator<K>() {
-        @Override
-        public K next() {
-          return nextNode().key;
-        }
-      };
-    }
-
-    @Override public boolean contains(final Object o) {
-      return containsKey(o);
-    }
-
-    @Override public boolean remove(final Object key) {
-      return removeInternalByKey(key) != null;
-    }
-
-    @Override public void clear() {
-      LinkedTreeMap.this.clear();
-    }
-  }
-
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a LinkedHashMap so that they won't need Gson on the other side to
-   * deserialize it. Using serialization defeats our DoS defence, so most apps
-   * shouldn't use it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new LinkedHashMap<K, V>(this);
-  }
-}
diff --git a/imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java b/imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
deleted file mode 100644
index 3c05467a8..000000000
--- a/imp/src/main/java/com/github/gv2011/jsoncore/imp/Preconditions.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-/**
- * A simple utility class used to check method Preconditions.
- *
- * <pre>
- * public long divideBy(long value) {
- *   Preconditions.checkArgument(value != 0);
- *   return this.value / value;
- * }
- * </pre>
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-@Deprecated
-public final class Preconditions {
-  private Preconditions() {
-    throw new UnsupportedOperationException();
-  }
-
-  public static <T> T checkNotNull(final T obj) {
-    if (obj == null) {
-      throw new NullPointerException();
-    }
-    return obj;
-  }
-
-  public static void checkArgument(final boolean condition) {
-    if (!condition) {
-      throw new IllegalArgumentException();
-    }
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java
deleted file mode 100644
index 43a3a0d12..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonArrayTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import com.github.gv2011.jsoncore.imp.JsonArray;
-import com.github.gv2011.jsoncore.imp.JsonNull;
-import com.github.gv2011.jsoncore.imp.JsonObject;
-import com.github.gv2011.jsoncore.imp.JsonPrimitive;
-
-import junit.framework.TestCase;
-
-/**
- * @author Jesse Wilson
- */
-public final class JsonArrayTest extends TestCase {
-
-  public void testEqualsOnEmptyArray() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonArray(), new JsonArray());
-  }
-
-  public void testEqualsNonEmptyArray() {
-    final JsonArray a = new JsonArray();
-    final JsonArray b = new JsonArray();
-
-    assertEquals(a, a);
-
-    a.add(new JsonObject());
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-
-    b.add(new JsonObject());
-    MoreAsserts.assertEqualsAndHashCode(a, b);
-
-    a.add(new JsonObject());
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-
-    b.add(JsonNull.INSTANCE);
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-  }
-
-  public void testRemove() {
-    final JsonArray array = new JsonArray();
-    try {
-      array.remove(0);
-      fail();
-    } catch (final IndexOutOfBoundsException expected) {}
-    final JsonPrimitive a = new JsonPrimitive("a");
-    array.add(a);
-    assertTrue(array.remove(a));
-    assertFalse(array.contains(a));
-    array.add(a);
-    array.add(new JsonPrimitive("b"));
-    assertEquals("b", array.remove(1).getAsString());
-    assertEquals(1, array.size());
-    assertTrue(array.contains(a));
-  }
-
-  public void testSet() {
-    final JsonArray array = new JsonArray();
-    try {
-      array.set(0, new JsonPrimitive(1));
-      fail();
-    } catch (final IndexOutOfBoundsException expected) {}
-    final JsonPrimitive a = new JsonPrimitive("a");
-    array.add(a);
-    array.set(0, new JsonPrimitive("b"));
-    assertEquals("b", array.get(0).getAsString());
-    array.set(0, null);
-    assertNull(array.get(0));
-    array.set(0, new JsonPrimitive("c"));
-    assertEquals("c", array.get(0).getAsString());
-    assertEquals(1, array.size());
-  }
-
-  public void testDeepCopy() {
-    final JsonArray original = new JsonArray();
-    final JsonArray firstEntry = new JsonArray();
-    original.add(firstEntry);
-
-    final JsonArray copy = original.deepCopy();
-    original.add(new JsonPrimitive("y"));
-
-    assertEquals(1, copy.size());
-    firstEntry.add(new JsonPrimitive("z"));
-
-    assertEquals(1, original.get(0).getAsJsonArray().size());
-    assertEquals(0, copy.get(0).getAsJsonArray().size());
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java
deleted file mode 100644
index b40b5398a..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonNullTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import com.github.gv2011.jsoncore.imp.JsonNull;
-
-import junit.framework.TestCase;
-
-/**
- * @author Jesse Wilson
- */
-public final class JsonNullTest extends TestCase {
-
-  @SuppressWarnings("deprecation")
-  public void testEqualsAndHashcode() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), new JsonNull());
-    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), JsonNull.INSTANCE);
-    MoreAsserts.assertEqualsAndHashCode(JsonNull.INSTANCE, JsonNull.INSTANCE);
-  }
-
-  public void testDeepCopy() {
-    @SuppressWarnings("deprecation")
-    final
-    JsonNull a = new JsonNull();
-    assertSame(JsonNull.INSTANCE, a.deepCopy());
-    assertSame(JsonNull.INSTANCE, JsonNull.INSTANCE.deepCopy());
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java
deleted file mode 100644
index 34b50ca42..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonObjectTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import com.github.gv2011.jsoncore.imp.JsonArray;
-import com.github.gv2011.jsoncore.imp.JsonElement;
-import com.github.gv2011.jsoncore.imp.JsonNull;
-import com.github.gv2011.jsoncore.imp.JsonObject;
-import com.github.gv2011.jsoncore.imp.JsonPrimitive;
-
-import junit.framework.TestCase;
-
-/**
- * Unit test for the {@link JsonObject} class.
- *
- * @author Joel Leitch
- */
-public class JsonObjectTest extends TestCase {
-
-  public void testAddingAndRemovingObjectProperties() throws Exception {
-    final JsonObject jsonObj = new JsonObject();
-    final String propertyName = "property";
-    assertFalse(jsonObj.has(propertyName));
-    assertNull(jsonObj.get(propertyName));
-
-    final JsonPrimitive value = new JsonPrimitive("blah");
-    jsonObj.add(propertyName, value);
-    assertEquals(value, jsonObj.get(propertyName));
-
-    final JsonElement removedElement = jsonObj.remove(propertyName);
-    assertEquals(value, removedElement);
-    assertFalse(jsonObj.has(propertyName));
-    assertNull(jsonObj.get(propertyName));
-  }
-
-  public void testAddingNullPropertyValue() throws Exception {
-    final String propertyName = "property";
-    final JsonObject jsonObj = new JsonObject();
-    jsonObj.add(propertyName, null);
-
-    assertTrue(jsonObj.has(propertyName));
-
-    final JsonElement jsonElement = jsonObj.get(propertyName);
-    assertNotNull(jsonElement);
-    assertTrue(jsonElement.isJsonNull());
-  }
-
-  public void testAddingNullOrEmptyPropertyName() throws Exception {
-    final JsonObject jsonObj = new JsonObject();
-    try {
-      jsonObj.add(null, JsonNull.INSTANCE);
-      fail("Should not allow null property names.");
-    } catch (final NullPointerException expected) { }
-
-    jsonObj.add("", JsonNull.INSTANCE);
-    jsonObj.add("   \t", JsonNull.INSTANCE);
-  }
-
-  public void testAddingBooleanProperties() throws Exception {
-    final String propertyName = "property";
-    final JsonObject jsonObj = new JsonObject();
-    jsonObj.addProperty(propertyName, true);
-
-    assertTrue(jsonObj.has(propertyName));
-
-    final JsonElement jsonElement = jsonObj.get(propertyName);
-    assertNotNull(jsonElement);
-    assertTrue(jsonElement.getAsBoolean());
-  }
-
-  public void testAddingStringProperties() throws Exception {
-    final String propertyName = "property";
-    final String value = "blah";
-
-    final JsonObject jsonObj = new JsonObject();
-    jsonObj.addProperty(propertyName, value);
-
-    assertTrue(jsonObj.has(propertyName));
-
-    final JsonElement jsonElement = jsonObj.get(propertyName);
-    assertNotNull(jsonElement);
-    assertEquals(value, jsonElement.getAsString());
-  }
-
-  public void testAddingCharacterProperties() throws Exception {
-    final String propertyName = "property";
-    final char value = 'a';
-
-    final JsonObject jsonObj = new JsonObject();
-    jsonObj.addProperty(propertyName, value);
-
-    assertTrue(jsonObj.has(propertyName));
-
-    final JsonElement jsonElement = jsonObj.get(propertyName);
-    assertNotNull(jsonElement);
-    assertEquals(String.valueOf(value), jsonElement.getAsString());
-    assertEquals(value, jsonElement.getAsCharacter());
-  }
-
-
-  public void testEqualsOnEmptyObject() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonObject(), new JsonObject());
-  }
-
-  public void testEqualsNonEmptyObject() {
-    final JsonObject a = new JsonObject();
-    final JsonObject b = new JsonObject();
-
-    assertEquals(a, a);
-
-    a.add("foo", new JsonObject());
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-
-    b.add("foo", new JsonObject());
-    MoreAsserts.assertEqualsAndHashCode(a, b);
-
-    a.add("bar", new JsonObject());
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-
-    b.add("bar", JsonNull.INSTANCE);
-    assertFalse(a.equals(b));
-    assertFalse(b.equals(a));
-  }
-
-  public void testDeepCopy() {
-    final JsonObject original = new JsonObject();
-    final JsonArray firstEntry = new JsonArray();
-    original.add("key", firstEntry);
-
-    final JsonObject copy = original.deepCopy();
-    firstEntry.add(new JsonPrimitive("z"));
-
-    assertEquals(1, original.get("key").getAsJsonArray().size());
-    assertEquals(0, copy.get("key").getAsJsonArray().size());
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java
deleted file mode 100644
index 6b4ffc3be..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/JsonPrimitiveTest.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.math.BigDecimal;
-import java.math.BigInteger;
-
-import com.github.gv2011.jsoncore.imp.JsonPrimitive;
-
-import junit.framework.TestCase;
-
-/**
- * Unit test for the {@link JsonPrimitive} class.
- *
- * @author Joel Leitch
- */
-public class JsonPrimitiveTest extends TestCase {
-
-  public void testBoolean() throws Exception {
-    JsonPrimitive json = new JsonPrimitive(Boolean.TRUE);
-
-    assertTrue(json.isBoolean());
-    assertTrue(json.getAsBoolean());
-
-    // Extra support for booleans
-    json = new JsonPrimitive(1);
-    assertFalse(json.getAsBoolean());
-
-    json = new JsonPrimitive("1");
-    assertFalse(json.getAsBoolean());
-
-    json = new JsonPrimitive("true");
-    assertTrue(json.getAsBoolean());
-
-    json = new JsonPrimitive("TrUe");
-    assertTrue(json.getAsBoolean());
-
-    json = new JsonPrimitive("1.3");
-    assertFalse(json.getAsBoolean());
-  }
-
-  public void testParsingStringAsBoolean() throws Exception {
-    final JsonPrimitive json = new JsonPrimitive("true");
-
-    assertFalse(json.isBoolean());
-    assertTrue(json.getAsBoolean());
-  }
-
-  public void testParsingStringAsNumber() throws Exception {
-    final JsonPrimitive json = new JsonPrimitive("1");
-
-    assertFalse(json.isNumber());
-    assertEquals(1D, json.getAsDouble(), 0.00001);
-    assertEquals(1F, json.getAsFloat(), 0.00001);
-    assertEquals(1, json.getAsInt());
-    assertEquals(1L, json.getAsLong());
-    assertEquals((short) 1, json.getAsShort());
-    assertEquals((byte) 1, json.getAsByte());
-    assertEquals(new BigInteger("1"), json.getAsBigInteger());
-    assertEquals(new BigDecimal("1"), json.getAsBigDecimal());
-  }
-
-  public void testStringsAndChar() throws Exception {
-    JsonPrimitive json = new JsonPrimitive("abc");
-    assertTrue(json.isString());
-    assertEquals('a', json.getAsCharacter());
-    assertEquals("abc", json.getAsString());
-
-    json = new JsonPrimitive('z');
-    assertTrue(json.isString());
-    assertEquals('z', json.getAsCharacter());
-    assertEquals("z", json.getAsString());
-  }
-
-  public void testExponential() throws Exception {
-    final JsonPrimitive json = new JsonPrimitive("1E+7");
-
-    assertEquals(new BigDecimal("1E+7"), json.getAsBigDecimal());
-    assertEquals(new Double("1E+7"), json.getAsDouble(), 0.00001);
-    assertEquals(new Float("1E+7"), json.getAsDouble(), 0.00001);
-
-    try {
-      json.getAsInt();
-      fail("Integers can not handle exponents like this.");
-    } catch (final NumberFormatException expected) { }
-  }
-
-  public void testByteEqualsShort() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Short((short)10));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testByteEqualsInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testByteEqualsLong() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testByteEqualsBigInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testShortEqualsInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testShortEqualsLong() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Long(10));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testShortEqualsBigInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testIntegerEqualsLong() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
-    final JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testIntegerEqualsBigInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testLongEqualsBigInteger() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Long(10L));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigInteger("10"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testFloatEqualsDouble() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
-    final JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testFloatEqualsBigDecimal() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testDoubleEqualsBigDecimal() {
-    final JsonPrimitive p1 = new JsonPrimitive(new Double(10.25D));
-    final JsonPrimitive p2 = new JsonPrimitive(new BigDecimal("10.25"));
-    assertEquals(p1, p2);
-    assertEquals(p1.hashCode(), p2.hashCode());
-  }
-
-  public void testValidJsonOnToString() throws Exception {
-    JsonPrimitive json = new JsonPrimitive("Some\nEscaped\nValue");
-    assertEquals("\"Some\\nEscaped\\nValue\"", json.toString());
-
-    json = new JsonPrimitive(new BigDecimal("1.333"));
-    assertEquals("1.333", json.toString());
-  }
-
-  public void testEquals() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive("A"), new JsonPrimitive("A"));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(true), new JsonPrimitive(true));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(5L), new JsonPrimitive(5L));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive('a'), new JsonPrimitive('a'));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Float.NaN));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NEGATIVE_INFINITY),
-        new JsonPrimitive(Float.NEGATIVE_INFINITY));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.POSITIVE_INFINITY),
-        new JsonPrimitive(Float.POSITIVE_INFINITY));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NaN), new JsonPrimitive(Double.NaN));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NEGATIVE_INFINITY),
-        new JsonPrimitive(Double.NEGATIVE_INFINITY));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.POSITIVE_INFINITY),
-        new JsonPrimitive(Double.POSITIVE_INFINITY));
-    assertFalse(new JsonPrimitive("a").equals(new JsonPrimitive("b")));
-    assertFalse(new JsonPrimitive(true).equals(new JsonPrimitive(false)));
-    assertFalse(new JsonPrimitive(0).equals(new JsonPrimitive(1)));
-  }
-
-  public void testEqualsAcrossTypes() {
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive("a"), new JsonPrimitive('a'));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger("0")), new JsonPrimitive(0));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(0), new JsonPrimitive(0L));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger("0")), new JsonPrimitive(0));
-    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Double.NaN));
-  }
-
-  public void testEqualsIntegerAndBigInteger() {
-    final JsonPrimitive a = new JsonPrimitive(5L);
-    final JsonPrimitive b = new JsonPrimitive(new BigInteger("18446744073709551621")); // 2^64 + 5
-    // Ideally, the following assertion should have failed but the price is too much to pay
-    // assertFalse(a + " equals " + b, a.equals(b));
-    assertTrue(a + " equals " + b, a.equals(b));
-  }
-
-  public void testEqualsDoesNotEquateStringAndNonStringTypes() {
-    assertFalse(new JsonPrimitive("true").equals(new JsonPrimitive(true)));
-    assertFalse(new JsonPrimitive("0").equals(new JsonPrimitive(0)));
-    assertFalse(new JsonPrimitive("NaN").equals(new JsonPrimitive(Float.NaN)));
-  }
-
-  public void testDeepCopy() {
-    final JsonPrimitive a = new JsonPrimitive("a");
-    assertSame(a, a.deepCopy()); // Primitives are immutable!
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
deleted file mode 100644
index 1e5a8affd..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/LazilyParsedNumberTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.gv2011.jsoncore.imp;
-
-import junit.framework.TestCase;
-
-public class LazilyParsedNumberTest extends TestCase {
-  public void testHashCode() {
-    final LazilyParsedNumber n1 = new LazilyParsedNumber("1");
-    final LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
-    assertEquals(n1.hashCode(), n1Another.hashCode());
-  }
-
-  public void testEquals() {
-    final LazilyParsedNumber n1 = new LazilyParsedNumber("1");
-    final LazilyParsedNumber n1Another = new LazilyParsedNumber("1");
-    assertTrue(n1.equals(n1Another));
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
deleted file mode 100644
index 835f83558..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/LinkedTreeMapTest.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Random;
-
-import junit.framework.TestCase;
-
-public final class LinkedTreeMapTest extends TestCase {
-
-  public void testIterationOrder() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    assertIterationOrder(map.keySet(), "a", "c", "b");
-    assertIterationOrder(map.values(), "android", "cola", "bbq");
-  }
-
-  public void testRemoveRootDoesNotDoubleUnlink() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    final Iterator<Map.Entry<String,String>> it = map.entrySet().iterator();
-    it.next();
-    it.next();
-    it.next();
-    it.remove();
-    assertIterationOrder(map.keySet(), "a", "c");
-  }
-
-  public void testPutNullKeyFails() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    try {
-      map.put(null, "android");
-      fail();
-    } catch (final NullPointerException expected) {
-    }
-  }
-
-  public void testPutNonComparableKeyFails() {
-    final LinkedTreeMap<Object, String> map = new LinkedTreeMap<Object, String>();
-    try {
-      map.put(new Object(), "android");
-      fail();
-    } catch (final ClassCastException expected) {}
-  }
-
-  public void testContainsNonComparableKeyReturnsFalse() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "android");
-    assertFalse(map.containsKey(new Object()));
-  }
-
-  public void testContainsNullKeyIsAlwaysFalse() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "android");
-    assertFalse(map.containsKey(null));
-  }
-
-  public void testPutOverrides() throws Exception {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    assertNull(map.put("d", "donut"));
-    assertNull(map.put("e", "eclair"));
-    assertNull(map.put("f", "froyo"));
-    assertEquals(3, map.size());
-
-    assertEquals("donut", map.get("d"));
-    assertEquals("donut", map.put("d", "done"));
-    assertEquals(3, map.size());
-  }
-
-  public void testEmptyStringValues() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "");
-    assertTrue(map.containsKey("a"));
-    assertEquals("", map.get("a"));
-  }
-
-  public void testLargeSetOfRandomKeys() throws Exception {
-    final Random random = new Random(1367593214724L);
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    final String[] keys = new String[1000];
-    for (int i = 0; i < keys.length; i++) {
-      keys[i] = Integer.toString(Math.abs(random.nextInt()), 36) + "-" + i;
-      map.put(keys[i], "" + i);
-    }
-
-    for (int i = 0; i < keys.length; i++) {
-      final String key = keys[i];
-      assertTrue(map.containsKey(key));
-      assertEquals("" + i, map.get(key));
-    }
-  }
-
-  public void testClear() {
-    final LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
-    map.put("a", "android");
-    map.put("c", "cola");
-    map.put("b", "bbq");
-    map.clear();
-    assertIterationOrder(map.keySet());
-    assertEquals(0, map.size());
-  }
-
-  public void testEqualsAndHashCode() throws Exception {
-    final LinkedTreeMap<String, Integer> map1 = new LinkedTreeMap<String, Integer>();
-    map1.put("A", 1);
-    map1.put("B", 2);
-    map1.put("C", 3);
-    map1.put("D", 4);
-
-    final LinkedTreeMap<String, Integer> map2 = new LinkedTreeMap<String, Integer>();
-    map2.put("C", 3);
-    map2.put("B", 2);
-    map2.put("D", 4);
-    map2.put("A", 1);
-
-    MoreAsserts.assertEqualsAndHashCode(map1, map2);
-  }
-
-  private <T> void assertIterationOrder(
-    final Iterable<T> actual, @SuppressWarnings("unchecked") final T... expected
-  ) {
-    final ArrayList<T> actualList = new ArrayList<T>();
-    for (final T t : actual) {
-      actualList.add(t);
-    }
-    assertEquals(Arrays.asList(expected), actualList);
-  }
-}
diff --git a/imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java b/imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java
deleted file mode 100644
index 705fb6087..000000000
--- a/imp/src/test/java/com/github/gv2011/jsoncore/imp/MoreAsserts.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2016 Vinz (https://github.com/gv2011)
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.github.gv2011.jsoncore.imp;
-
-import java.util.Collection;
-
-import junit.framework.Assert;
-
-/**
- * Handy asserts that we wish were present in {@link Assert}
- * so that we didn't have to write them.
- *
- * @author Inderjeet Singh
- */
-@SuppressWarnings("deprecation")
-public class MoreAsserts {
-
-  public static void assertEquals(final int[] expected, final int[] target) {
-    if (expected == null) {
-      Assert.assertNull(target);
-    }
-    Assert.assertEquals(expected.length, target.length);
-    for (int i = 0; i < expected.length; ++i) {
-      Assert.assertEquals(expected[i], target[i]);
-    }
-  }
-
-  public static void assertEquals(final Integer[] expected, final Integer[] target) {
-    if (expected == null) {
-      Assert.assertNull(target);
-    }
-    Assert.assertEquals(expected.length, target.length);
-    for (int i = 0; i < expected.length; ++i) {
-      Assert.assertEquals(expected[i], target[i]);
-    }
-  }
-
-  /**
-   * Asserts that the specified {@code value} is not present in {@code collection}
-   * @param collection the collection to look into
-   * @param value the value that needs to be checked for presence
-   */
-  public static <T> void assertContains(final Collection<T> collection, final T value) {
-    for (final T entry : collection) {
-      if (entry.equals(value)) {
-        return;
-      }
-    }
-    Assert.fail(value + " not present in " + collection);
-  }
-
-  public static void assertEqualsAndHashCode(final Object a, final Object b) {
-    Assert.assertTrue(a.equals(b));
-    Assert.assertTrue(b.equals(a));
-    Assert.assertEquals(a.hashCode(), b.hashCode());
-    Assert.assertFalse(a.equals(null));
-    Assert.assertFalse(a.equals(new Object()));
-  }
-
-}
