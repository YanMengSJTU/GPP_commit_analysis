diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index a4ca4f309..b66220201 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -16,24 +16,6 @@
 
 package com.google.gson;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.lang.reflect.Type;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicLongArray;
-
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -56,6 +38,24 @@
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
 
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.lang.reflect.Type;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
  * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}
@@ -134,6 +134,7 @@
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
   private final boolean lenient;
+  private MissingFieldHandlingStrategy missingFieldHandlingStrategy;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   /**
@@ -175,7 +176,7 @@ public Gson() {
         Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
         DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
         DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList(), null);
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
@@ -183,7 +184,7 @@ public Gson() {
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
+      List<TypeAdapterFactory> typeAdapterFactories, MissingFieldHandlingStrategy missingFieldHandlingStrategy) {
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
@@ -192,6 +193,7 @@ public Gson() {
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
     this.lenient = lenient;
+    this.missingFieldHandlingStrategy = missingFieldHandlingStrategy;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -250,7 +252,8 @@ public Gson() {
     factories.add(jsonAdapterFactory);
     factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(new ReflectiveTypeAdapterFactory(
-        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory,
+            this.missingFieldHandlingStrategy));
 
     this.factories = Collections.unmodifiableList(factories);
   }
@@ -271,6 +274,10 @@ public boolean htmlSafe() {
     return htmlSafe;
   }
 
+  public MissingFieldHandlingStrategy missingFieldHandler() {
+    return missingFieldHandlingStrategy;
+  }
+
   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
     if (serializeSpecialFloatingPointValues) {
       return TypeAdapters.DOUBLE;
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 0c917d46f..54a45968c 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,7 +16,13 @@
 
 package com.google.gson;
 
+import com.google.gson.internal.$Gson$Preconditions;
+import com.google.gson.internal.Excluder;
+import com.google.gson.internal.bind.TreeTypeAdapter;
+import com.google.gson.internal.bind.TypeAdapters;
+import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
+
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -27,12 +33,6 @@
 import java.util.List;
 import java.util.Map;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.bind.TreeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.reflect.TypeToken;
-
 import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
 import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
 import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
@@ -94,6 +94,7 @@
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
   private boolean lenient = DEFAULT_LENIENT;
+  private MissingFieldHandlingStrategy missingFieldHandlingStrategy;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -351,6 +352,14 @@ public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strateg
     return this;
   }
 
+  /**
+   * adding MissingFieldHandlingStrategy
+   */
+  public GsonBuilder addMissingFieldHandlingStrategy(MissingFieldHandlingStrategy strategy) {
+    this.missingFieldHandlingStrategy = strategy;
+    return this;
+  }
+
   /**
    * Configures Gson to output Json that fits in a page for pretty printing. This option only
    * affects Json serialization.
@@ -569,7 +578,8 @@ public Gson create() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        serializeSpecialFloatingPointValues, longSerializationPolicy, factories,
+            missingFieldHandlingStrategy);
   }
 
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
diff --git a/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java b/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java
new file mode 100644
index 000000000..12825c03f
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/MissingFieldHandlingStrategy.java
@@ -0,0 +1,10 @@
+package com.google.gson;
+
+import com.google.gson.reflect.TypeToken;
+
+/**
+ * @author Prateek Jain
+ */
+public interface MissingFieldHandlingStrategy {
+    Object handle(TypeToken type, String fieldName);
+}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 34e97664e..aa93e2a6e 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -19,6 +19,7 @@
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.MissingFieldHandlingStrategy;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
@@ -27,11 +28,11 @@
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
-import com.google.gson.internal.Primitives;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
@@ -40,6 +41,9 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+
+import static com.google.gson.internal.Primitives.isPrimitive;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -49,14 +53,17 @@
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private MissingFieldHandlingStrategy missingFieldHandlingStrategy;
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
-      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
+                                      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
+                                      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory,
+                                      MissingFieldHandlingStrategy missingFieldHandlingStrategy) {
     this.constructorConstructor = constructorConstructor;
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.excluder = excluder;
     this.jsonAdapterFactory = jsonAdapterFactory;
+    this.missingFieldHandlingStrategy = missingFieldHandlingStrategy;
   }
 
   public boolean excludeField(Field f, boolean serialize) {
@@ -97,13 +104,13 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     }
 
     ObjectConstructor<T> constructor = constructorConstructor.get(type);
-    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
+    return new Adapter<T>(constructor, getBoundFields(gson, type, raw), missingFieldHandlingStrategy);
   }
 
   private ReflectiveTypeAdapterFactory.BoundField createBoundField(
       final Gson context, final Field field, final String name,
       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
-    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
+    final boolean isPrimitive = isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
     TypeAdapter<?> mapped = null;
@@ -115,7 +122,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     if (mapped == null) mapped = context.getAdapter(fieldType);
 
     final TypeAdapter<?> typeAdapter = mapped;
-    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
+    return new ReflectiveTypeAdapterFactory.BoundField(name, field, fieldType, serialize, deserialize) {
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
@@ -128,7 +135,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
         if (fieldValue != null || !isPrimitive) {
-          field.set(value, fieldValue);
+          this.set(value, fieldValue);
         }
       }
       @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
@@ -178,27 +185,74 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
   }
 
   static abstract class BoundField {
+    boolean initialized;
+
     final String name;
+    final Field field;
+    final TypeToken typeToken;
     final boolean serialized;
     final boolean deserialized;
 
-    protected BoundField(String name, boolean serialized, boolean deserialized) {
+    protected BoundField(String name, Field field, TypeToken typeToken, boolean serialized, boolean deserialized) {
       this.name = name;
+      this.field = field;
+      this.typeToken = typeToken;
       this.serialized = serialized;
       this.deserialized = deserialized;
     }
     abstract boolean writeField(Object value) throws IOException, IllegalAccessException;
     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;
     abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;
+
+    boolean isInitialized() {
+      return this.initialized;
+    }
+
+    boolean isDeserializable() {
+      return this.deserialized &&
+          !isPrimitive(typeToken.getRawType());
+    }
+
+    void set(Object instance, Object value) throws IllegalAccessException {
+      this.field.setAccessible(true);
+      this.field.set(instance, value);
+      this.initialized = true;
+    }
   }
 
   public static final class Adapter<T> extends TypeAdapter<T> {
     private final ObjectConstructor<T> constructor;
     private final Map<String, BoundField> boundFields;
+    private MissingFieldHandlingStrategy missingFieldHandlingStrategy;
 
-    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields, MissingFieldHandlingStrategy missingFieldHandlingStrategy) {
       this.constructor = constructor;
       this.boundFields = boundFields;
+      this.missingFieldHandlingStrategy = missingFieldHandlingStrategy;
+    }
+
+    private ArrayList<BoundField> getUninitializedFields() {
+      ArrayList<BoundField> uninitializedFields = new ArrayList<BoundField>();
+      Set<String> fieldNames = boundFields.keySet();
+      for (String fieldName : fieldNames) {
+        BoundField boundField = boundFields.get(fieldName);
+        if (boundField.isDeserializable() && !boundField.isInitialized()) {
+          uninitializedFields.add(boundField);
+        }
+      }
+      return uninitializedFields;
+    }
+
+    private void initializeMissingFields(T instance) {
+      ArrayList<BoundField> uninitializedFields = getUninitializedFields();
+      for (BoundField field : uninitializedFields) {
+        try {
+          Object defaultValue = missingFieldHandlingStrategy.handle(field.typeToken, field.name);
+          field.set(instance, defaultValue);
+        } catch (IllegalAccessException e) {
+          throw new AssertionError(e);
+        }
+      }
     }
 
     @Override public T read(JsonReader in) throws IOException {
@@ -226,6 +280,9 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
         throw new AssertionError(e);
       }
       in.endObject();
+      if (missingFieldHandlingStrategy != null) {
+        initializeMissingFields(instance);
+      }
       return instance;
     }
 
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index fb0c00321..f45964c47 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -17,11 +17,12 @@
 package com.google.gson;
 
 import com.google.gson.internal.Excluder;
+import junit.framework.TestCase;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.HashMap;
-import junit.framework.TestCase;
 
 /**
  * Unit tests for {@link Gson}.
@@ -44,7 +45,7 @@ public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
         true, true, false, LongSerializationPolicy.DEFAULT,
-        new ArrayList<TypeAdapterFactory>());
+        new ArrayList<TypeAdapterFactory>(), null);
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder());
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
diff --git a/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java b/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java
new file mode 100644
index 000000000..bb57a9002
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/MissingFieldHandlingStrategyTest.java
@@ -0,0 +1,88 @@
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
+import com.google.gson.MissingFieldHandlingStrategy;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.reflect.TypeToken;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+
+/**
+ * @author Prateek Jain
+ */
+public class MissingFieldHandlingStrategyTest {
+
+  @Test
+  public void shouldAssignFieldToDefaultValues() throws Exception {
+    MissingFieldHandlingStrategy missingFieldHandlingStrategy = getMissingFieldHandlingStrategy();
+    Gson gson = new GsonBuilder().
+        addMissingFieldHandlingStrategy(missingFieldHandlingStrategy).create();
+    JsonObject jsonObject = new JsonObject();
+
+    Protocol protocol = gson.fromJson(jsonObject, Protocol.class);
+
+    assertThat(protocol.name, is("HTTP"));
+    assertThat(protocol.version, is("1.1"));
+  }
+
+  @Test
+  public void shouldNotTreatNullFieldAsMissingField() throws Exception {
+    MissingFieldHandlingStrategy missingFieldHandlingStrategy = getMissingFieldHandlingStrategy();
+    Gson gson = new GsonBuilder().
+        addMissingFieldHandlingStrategy(missingFieldHandlingStrategy).create();
+
+    JsonObject jsonObject = new JsonObject();
+    jsonObject.add("name", null);
+    jsonObject.add("version", null);
+
+    Protocol protocol = gson.fromJson(jsonObject, Protocol.class);
+
+    assertNull(protocol.name);
+    assertNull(protocol.version);
+  }
+
+  @Test
+  public void shouldRespectSerializedNameAnnotation() throws Exception {
+    MissingFieldHandlingStrategy strategy = new MissingFieldHandlingStrategy() {
+      @Override
+      public Object handle(TypeToken type, String fieldName) {
+        if ("f1".equals(fieldName))
+          return "1.1";
+        return "";
+      }
+    };
+    Gson gson = new GsonBuilder().
+        addMissingFieldHandlingStrategy(strategy).create();
+    JsonObject jsonObject = new JsonObject();
+
+    assertThat(gson.fromJson(jsonObject, ObjectWithSerializedAnnotatin.class).v, is("1.1"));
+  }
+
+  private MissingFieldHandlingStrategy getMissingFieldHandlingStrategy() {
+    return new MissingFieldHandlingStrategy() {
+      @Override
+      public Object handle(TypeToken type, String fieldName) {
+        if ("name".equals(fieldName))
+          return "HTTP";
+        if ("version".equals(fieldName))
+          return "1.1";
+        return "";
+      }
+    };
+  }
+
+  private static class Protocol {
+    private String name;
+    private String version;
+  }
+
+  private static class ObjectWithSerializedAnnotatin {
+    @SerializedName(value = "f1")
+    private String v;
+  }
+}
