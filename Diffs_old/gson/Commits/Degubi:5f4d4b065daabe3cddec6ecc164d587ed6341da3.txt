diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index cf223a902..a4a04ad68 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -172,7 +172,7 @@
 		factories.add(LocalDateAdapter.factory);
 		factories.add(LocalDateTimeAdapter.factory);
 		factories.add(InstantTypeAdapter.factory);
-		
+
 		// type adapters for composite and user-defined types
 		factories.add(new CollectionTypeAdapterFactory(instanceCreators));
 		factories.add(new MapTypeAdapterFactory(instanceCreators, complexMapKeySerialization));
@@ -194,7 +194,7 @@
 	public GsonBuilder rebuild() {
 		return new GsonBuilder(this);
 	}
-	
+
 	public static Gson newGson() {
 		return new GsonBuilder().build();
 	}
@@ -202,7 +202,7 @@ public static Gson newGson() {
 	public static GsonBuilder newBuilder() {
 		return new GsonBuilder();
 	}
-	
+
 	/**
 	 * Parses the specified JSON string into a parse tree
 	 *
@@ -248,7 +248,17 @@ public static JsonElement parseReader(JsonReader reader) throws JsonIOException,
 		boolean lenient = reader.isLenient();
 		reader.setLenient(true);
 		try {
-			return Streams.parse(reader);
+			try {
+				return TypeAdapters.JSON_ELEMENT.read(reader);
+			} catch (EOFException e) {
+				throw new JsonSyntaxException(e);
+			} catch (MalformedJsonException e) {
+				throw new JsonSyntaxException(e);
+			} catch (IOException e) {
+				throw new JsonIOException(e);
+			} catch (NumberFormatException e) {
+				throw new JsonSyntaxException(e);
+			}
 		} catch (StackOverflowError e) {
 			throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
 		} catch (OutOfMemoryError e) {
diff --git a/gson/src/main/java/com/google/gson/JsonStreamParser.java b/gson/src/main/java/com/google/gson/JsonStreamParser.java
index 496a6a3f5..801487b76 100644
--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java
@@ -15,16 +15,10 @@
  */
 package com.google.gson;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
+import com.google.gson.stream.*;
+import java.io.*;
 import java.util.*;
 import java.util.stream.*;
-import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.MalformedJsonException;
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
@@ -88,7 +82,7 @@ public JsonElement next() throws JsonParseException {
 		}
 
 		try {
-			return Streams.parse(parser);
+			return Gson.parseReader(parser);
 		} catch (StackOverflowError e) {
 			throw new JsonParseException("Failed parsing JSON source to Json", e);
 		} catch (OutOfMemoryError e) {
diff --git a/gson/src/main/java/com/google/gson/TypeAdapter.java b/gson/src/main/java/com/google/gson/TypeAdapter.java
index 737c97779..92f35c28a 100644
--- a/gson/src/main/java/com/google/gson/TypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java
@@ -16,8 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.bind.JsonTreeWriter;
-import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.gson.internal.*;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
index a223754ae..15829f3f8 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeReader.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.gson.internal;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
diff --git a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
index a0f97ef15..b58f79237 100644
--- a/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
+++ b/gson/src/main/java/com/google/gson/internal/JsonTreeWriter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.google.gson.internal;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
diff --git a/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java b/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
index 3669af7b5..d149f41a8 100644
--- a/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
+++ b/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
@@ -15,8 +15,7 @@
  */
 package com.google.gson.internal;
 
-import java.io.ObjectStreamException;
-import java.math.BigDecimal;
+import java.math.*;
 
 /**
  * This class holds a number value that is lazily converted to a specific number type
@@ -24,73 +23,73 @@
  * @author Inderjeet Singh
  */
 public final class LazilyParsedNumber extends Number {
-  private final String value;
+	private final String value;
 
-  /** @param value must not be null */
-  public LazilyParsedNumber(String value) {
-    this.value = value;
-  }
+	/** @param value must not be null */
+	public LazilyParsedNumber(String value) {
+		this.value = value;
+	}
 
-  @Override
-  public int intValue() {
-    try {
-      return Integer.parseInt(value);
-    } catch (NumberFormatException e) {
-      try {
-        return (int) Long.parseLong(value);
-      } catch (NumberFormatException nfe) {
-        return new BigDecimal(value).intValue();
-      }
-    }
-  }
+	@Override
+	public int intValue() {
+		try {
+			return Integer.parseInt(value);
+		} catch (NumberFormatException e) {
+			try {
+				return (int) Long.parseLong(value);
+			} catch (NumberFormatException nfe) {
+				return new BigDecimal(value).intValue();
+			}
+		}
+	}
 
-  @Override
-  public long longValue() {
-    try {
-      return Long.parseLong(value);
-    } catch (NumberFormatException e) {
-      return new BigDecimal(value).longValue();
-    }
-  }
+	@Override
+	public long longValue() {
+		try {
+			return Long.parseLong(value);
+		} catch (NumberFormatException e) {
+			return new BigDecimal(value).longValue();
+		}
+	}
 
-  @Override
-  public float floatValue() {
-    return Float.parseFloat(value);
-  }
+	@Override
+	public float floatValue() {
+		return Float.parseFloat(value);
+	}
 
-  @Override
-  public double doubleValue() {
-    return Double.parseDouble(value);
-  }
+	@Override
+	public double doubleValue() {
+		return Double.parseDouble(value);
+	}
 
-  @Override
-  public String toString() {
-    return value;
-  }
+	@Override
+	public String toString() {
+		return value;
+	}
 
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a BigDecimal so that they won't need Gson on the other side to
-   * deserialize it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new BigDecimal(value);
-  }
+	/**
+	 * If somebody is unlucky enough to have to serialize one of these, serialize
+	 * it as a BigDecimal so that they won't need Gson on the other side to
+	 * deserialize it.
+	 */
+	private Object writeReplace() {
+		return new BigDecimal(value);
+	}
 
-  @Override
-  public int hashCode() {
-    return value.hashCode();
-  }
+	@Override
+	public int hashCode() {
+		return value.hashCode();
+	}
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj instanceof LazilyParsedNumber) {
-      LazilyParsedNumber other = (LazilyParsedNumber) obj;
-      return value == other.value || value.equals(other.value);
-    }
-    return false;
-  }
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj instanceof LazilyParsedNumber) {
+			LazilyParsedNumber other = (LazilyParsedNumber) obj;
+			return value == other.value || value.equals(other.value);
+		}
+		return false;
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
index 80462742e..05998aaaa 100644
--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
@@ -17,16 +17,8 @@
 
 package com.google.gson.internal;
 
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.util.AbstractMap;
-import java.util.AbstractSet;
-import java.util.Comparator;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.Set;
+import java.io.*;
+import java.util.*;
 
 /**
  * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses
@@ -35,596 +27,557 @@
  *
  * <p>This implementation was derived from Android 4.1's TreeMap class.
  */
-public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
-  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
-    public int compare(Comparable a, Comparable b) {
-      return a.compareTo(b);
-    }
-  };
-
-  Comparator<? super K> comparator;
-  Node<K, V> root;
-  int size = 0;
-  int modCount = 0;
-
-  // Used to preserve iteration order
-  final Node<K, V> header = new Node<K, V>();
-
-  /**
-   * Create a natural order, empty tree map whose keys must be mutually
-   * comparable and non-null.
-   */
-  @SuppressWarnings("unchecked") // unsafe! this assumes K is comparable
-  public LinkedTreeMap() {
-    this((Comparator<? super K>) NATURAL_ORDER);
-  }
-
-  /**
-   * Create a tree map ordered by {@code comparator}. This map's keys may only
-   * be null if {@code comparator} permits.
-   *
-   * @param comparator the comparator to order elements with, or {@code null} to
-   *     use the natural ordering.
-   */
-  @SuppressWarnings({ "unchecked", "rawtypes" }) // unsafe! if comparator is null, this assumes K is comparable
-  public LinkedTreeMap(Comparator<? super K> comparator) {
-    this.comparator = comparator != null
-        ? comparator
-        : (Comparator) NATURAL_ORDER;
-  }
-
-  @Override public int size() {
-    return size;
-  }
-
-  @Override public V get(Object key) {
-    Node<K, V> node = findByObject(key);
-    return node != null ? node.value : null;
-  }
-
-  @Override public boolean containsKey(Object key) {
-    return findByObject(key) != null;
-  }
-
-  @Override public V put(K key, V value) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-    Node<K, V> created = find(key, true);
-    V result = created.value;
-    created.value = value;
-    return result;
-  }
-
-  @Override public void clear() {
-    root = null;
-    size = 0;
-    modCount++;
-
-    // Clear iteration order
-    Node<K, V> header = this.header;
-    header.next = header.prev = header;
-  }
-
-  @Override public V remove(Object key) {
-    Node<K, V> node = removeInternalByKey(key);
-    return node != null ? node.value : null;
-  }
-
-  /**
-   * Returns the node at or adjacent to the given key, creating it if requested.
-   *
-   * @throws ClassCastException if {@code key} and the tree's keys aren't
-   *     mutually comparable.
-   */
-  Node<K, V> find(K key, boolean create) {
-    Comparator<? super K> comparator = this.comparator;
-    Node<K, V> nearest = root;
-    int comparison = 0;
-
-    if (nearest != null) {
-      // Micro-optimization: avoid polymorphic calls to Comparator.compare().
-      @SuppressWarnings("unchecked") // Throws a ClassCastException below if there's trouble.
-          Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)
-          ? (Comparable<Object>) key
-          : null;
-
-      while (true) {
-        comparison = (comparableKey != null)
-            ? comparableKey.compareTo(nearest.key)
-            : comparator.compare(key, nearest.key);
-
-        // We found the requested key.
-        if (comparison == 0) {
-          return nearest;
-        }
-
-        // If it exists, the key is in a subtree. Go deeper.
-        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
-        if (child == null) {
-          break;
-        }
-
-        nearest = child;
-      }
-    }
-
-    // The key doesn't exist in this tree.
-    if (!create) {
-      return null;
-    }
-
-    // Create the node and add it to the tree or the table.
-    Node<K, V> header = this.header;
-    Node<K, V> created;
-    if (nearest == null) {
-      // Check that the value is comparable if we didn't do any comparisons.
-      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {
-        throw new ClassCastException(key.getClass().getName() + " is not Comparable");
-      }
-      created = new Node<K, V>(nearest, key, header, header.prev);
-      root = created;
-    } else {
-      created = new Node<K, V>(nearest, key, header, header.prev);
-      if (comparison < 0) { // nearest.key is higher
-        nearest.left = created;
-      } else { // comparison > 0, nearest.key is lower
-        nearest.right = created;
-      }
-      rebalance(nearest, true);
-    }
-    size++;
-    modCount++;
-
-    return created;
-  }
-
-  @SuppressWarnings("unchecked")
-  Node<K, V> findByObject(Object key) {
-    try {
-      return key != null ? find((K) key, false) : null;
-    } catch (ClassCastException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns this map's entry that has the same key and value as {@code
-   * entry}, or null if this map has no such entry.
-   *
-   * <p>This method uses the comparator for key equality rather than {@code
-   * equals}. If this map's comparator isn't consistent with equals (such as
-   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
-   * contains()} will violate the collections API.
-   */
-  Node<K, V> findByEntry(Entry<?, ?> entry) {
-    Node<K, V> mine = findByObject(entry.getKey());
-    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
-    return valuesEqual ? mine : null;
-  }
-
-  private boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Removes {@code node} from this tree, rearranging the tree's structure as
-   * necessary.
-   *
-   * @param unlink true to also unlink this node from the iteration linked list.
-   */
-  void removeInternal(Node<K, V> node, boolean unlink) {
-    if (unlink) {
-      node.prev.next = node.next;
-      node.next.prev = node.prev;
-    }
-
-    Node<K, V> left = node.left;
-    Node<K, V> right = node.right;
-    Node<K, V> originalParent = node.parent;
-    if (left != null && right != null) {
-
-      /*
-       * To remove a node with both left and right subtrees, move an
-       * adjacent node from one of those subtrees into this node's place.
-       *
-       * Removing the adjacent node may change this node's subtrees. This
-       * node may no longer have two subtrees once the adjacent node is
-       * gone!
-       */
-
-      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
-      removeInternal(adjacent, false); // takes care of rebalance and size--
-
-      int leftHeight = 0;
-      left = node.left;
-      if (left != null) {
-        leftHeight = left.height;
-        adjacent.left = left;
-        left.parent = adjacent;
-        node.left = null;
-      }
-
-      int rightHeight = 0;
-      right = node.right;
-      if (right != null) {
-        rightHeight = right.height;
-        adjacent.right = right;
-        right.parent = adjacent;
-        node.right = null;
-      }
-
-      adjacent.height = Math.max(leftHeight, rightHeight) + 1;
-      replaceInParent(node, adjacent);
-      return;
-    } else if (left != null) {
-      replaceInParent(node, left);
-      node.left = null;
-    } else if (right != null) {
-      replaceInParent(node, right);
-      node.right = null;
-    } else {
-      replaceInParent(node, null);
-    }
-
-    rebalance(originalParent, false);
-    size--;
-    modCount++;
-  }
-
-  Node<K, V> removeInternalByKey(Object key) {
-    Node<K, V> node = findByObject(key);
-    if (node != null) {
-      removeInternal(node, true);
-    }
-    return node;
-  }
-
-  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
-    Node<K, V> parent = node.parent;
-    node.parent = null;
-    if (replacement != null) {
-      replacement.parent = parent;
-    }
-
-    if (parent != null) {
-      if (parent.left == node) {
-        parent.left = replacement;
-      } else {
-        assert (parent.right == node);
-        parent.right = replacement;
-      }
-    } else {
-      root = replacement;
-    }
-  }
-
-  /**
-   * Rebalances the tree by making any AVL rotations necessary between the
-   * newly-unbalanced node and the tree's root.
-   *
-   * @param insert true if the node was unbalanced by an insert; false if it
-   *     was by a removal.
-   */
-  private void rebalance(Node<K, V> unbalanced, boolean insert) {
-    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
-      Node<K, V> left = node.left;
-      Node<K, V> right = node.right;
-      int leftHeight = left != null ? left.height : 0;
-      int rightHeight = right != null ? right.height : 0;
-
-      int delta = leftHeight - rightHeight;
-      if (delta == -2) {
-        Node<K, V> rightLeft = right.left;
-        Node<K, V> rightRight = right.right;
-        int rightRightHeight = rightRight != null ? rightRight.height : 0;
-        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
-
-        int rightDelta = rightLeftHeight - rightRightHeight;
-        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
-          rotateLeft(node); // AVL right right
-        } else {
-          assert (rightDelta == 1);
-          rotateRight(right); // AVL right left
-          rotateLeft(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 2) {
-        Node<K, V> leftLeft = left.left;
-        Node<K, V> leftRight = left.right;
-        int leftRightHeight = leftRight != null ? leftRight.height : 0;
-        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
-
-        int leftDelta = leftLeftHeight - leftRightHeight;
-        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
-          rotateRight(node); // AVL left left
-        } else {
-          assert (leftDelta == -1);
-          rotateLeft(left); // AVL left right
-          rotateRight(node);
-        }
-        if (insert) {
-          break; // no further rotations will be necessary
-        }
-
-      } else if (delta == 0) {
-        node.height = leftHeight + 1; // leftHeight == rightHeight
-        if (insert) {
-          break; // the insert caused balance, so rebalancing is done!
-        }
-
-      } else {
-        assert (delta == -1 || delta == 1);
-        node.height = Math.max(leftHeight, rightHeight) + 1;
-        if (!insert) {
-          break; // the height hasn't changed, so rebalancing is done!
-        }
-      }
-    }
-  }
-
-  /**
-   * Rotates the subtree so that its root's right child is the new root.
-   */
-  private void rotateLeft(Node<K, V> root) {
-    Node<K, V> left = root.left;
-    Node<K, V> pivot = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's left child to the root's right
-    root.right = pivotLeft;
-    if (pivotLeft != null) {
-      pivotLeft.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's left
-    pivot.left = root;
-    root.parent = pivot;
-
-    // fix heights
-    root.height = Math.max(left != null ? left.height : 0,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-  }
-
-  /**
-   * Rotates the subtree so that its root's left child is the new root.
-   */
-  private void rotateRight(Node<K, V> root) {
-    Node<K, V> pivot = root.left;
-    Node<K, V> right = root.right;
-    Node<K, V> pivotLeft = pivot.left;
-    Node<K, V> pivotRight = pivot.right;
-
-    // move the pivot's right child to the root's left
-    root.left = pivotRight;
-    if (pivotRight != null) {
-      pivotRight.parent = root;
-    }
-
-    replaceInParent(root, pivot);
-
-    // move the root to the pivot's right
-    pivot.right = root;
-    root.parent = pivot;
-
-    // fixup heights
-    root.height = Math.max(right != null ? right.height : 0,
-        pivotRight != null ? pivotRight.height : 0) + 1;
-    pivot.height = Math.max(root.height,
-        pivotLeft != null ? pivotLeft.height : 0) + 1;
-  }
-
-  private EntrySet entrySet;
-  private KeySet keySet;
-
-  @Override public Set<Entry<K, V>> entrySet() {
-    EntrySet result = entrySet;
-    return result != null ? result : (entrySet = new EntrySet());
-  }
-
-  @Override public Set<K> keySet() {
-    KeySet result = keySet;
-    return result != null ? result : (keySet = new KeySet());
-  }
-
-  static final class Node<K, V> implements Entry<K, V> {
-    Node<K, V> parent;
-    Node<K, V> left;
-    Node<K, V> right;
-    Node<K, V> next;
-    Node<K, V> prev;
-    final K key;
-    V value;
-    int height;
-
-    /** Create the header entry */
-    Node() {
-      key = null;
-      next = prev = this;
-    }
-
-    /** Create a regular entry */
-    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {
-      this.parent = parent;
-      this.key = key;
-      this.height = 1;
-      this.next = next;
-      this.prev = prev;
-      prev.next = this;
-      next.prev = this;
-    }
-
-    public K getKey() {
-      return key;
-    }
-
-    public V getValue() {
-      return value;
-    }
-
-    public V setValue(V value) {
-      V oldValue = this.value;
-      this.value = value;
-      return oldValue;
-    }
-
-    @SuppressWarnings("rawtypes")
-    @Override public boolean equals(Object o) {
-      if (o instanceof Entry) {
-        Entry other = (Entry) o;
-        return (key == null ? other.getKey() == null : key.equals(other.getKey()))
-            && (value == null ? other.getValue() == null : value.equals(other.getValue()));
-      }
-      return false;
-    }
-
-    @Override public int hashCode() {
-      return (key == null ? 0 : key.hashCode())
-          ^ (value == null ? 0 : value.hashCode());
-    }
-
-    @Override public String toString() {
-      return key + "=" + value;
-    }
-
-    /**
-     * Returns the first node in this subtree.
-     */
-    public Node<K, V> first() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.left;
-      while (child != null) {
-        node = child;
-        child = node.left;
-      }
-      return node;
-    }
-
-    /**
-     * Returns the last node in this subtree.
-     */
-    public Node<K, V> last() {
-      Node<K, V> node = this;
-      Node<K, V> child = node.right;
-      while (child != null) {
-        node = child;
-        child = node.right;
-      }
-      return node;
-    }
-  }
-
-  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {
-    Node<K, V> next = header.next;
-    Node<K, V> lastReturned = null;
-    int expectedModCount = modCount;
-
-    LinkedTreeMapIterator() {
-    }
-
-    public final boolean hasNext() {
-      return next != header;
-    }
-
-    final Node<K, V> nextNode() {
-      Node<K, V> e = next;
-      if (e == header) {
-        throw new NoSuchElementException();
-      }
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
-      }
-      next = e.next;
-      return lastReturned = e;
-    }
-
-    public final void remove() {
-      if (lastReturned == null) {
-        throw new IllegalStateException();
-      }
-      removeInternal(lastReturned, true);
-      lastReturned = null;
-      expectedModCount = modCount;
-    }
-  }
-
-  class EntrySet extends AbstractSet<Entry<K, V>> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<Entry<K, V>> iterator() {
-      return new LinkedTreeMapIterator<Entry<K, V>>() {
-        public Entry<K, V> next() {
-          return nextNode();
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
-    }
-
-    @Override public boolean remove(Object o) {
-      if (!(o instanceof Entry)) {
-        return false;
-      }
-
-      Node<K, V> node = findByEntry((Entry<?, ?>) o);
-      if (node == null) {
-        return false;
-      }
-      removeInternal(node, true);
-      return true;
-    }
-
-    @Override public void clear() {
-      LinkedTreeMap.this.clear();
-    }
-  }
-
-  final class KeySet extends AbstractSet<K> {
-    @Override public int size() {
-      return size;
-    }
-
-    @Override public Iterator<K> iterator() {
-      return new LinkedTreeMapIterator<K>() {
-        public K next() {
-          return nextNode().key;
-        }
-      };
-    }
-
-    @Override public boolean contains(Object o) {
-      return containsKey(o);
-    }
-
-    @Override public boolean remove(Object key) {
-      return removeInternalByKey(key) != null;
-    }
-
-    @Override public void clear() {
-      LinkedTreeMap.this.clear();
-    }
-  }
-
-  /**
-   * If somebody is unlucky enough to have to serialize one of these, serialize
-   * it as a LinkedHashMap so that they won't need Gson on the other side to
-   * deserialize it. Using serialization defeats our DoS defence, so most apps
-   * shouldn't use it.
-   */
-  private Object writeReplace() throws ObjectStreamException {
-    return new LinkedHashMap<K, V>(this);
-  }
+public final class LinkedTreeMap<K extends Comparable<K>, V> extends AbstractMap<K, V> implements Serializable {
+	Node<K, V> root;
+	int size = 0;
+	int modCount = 0;
+
+	// Used to preserve iteration order
+	final Node<K, V> header = new Node<>();
+
+	@Override public int size() {
+		return size;
+	}
+
+	@Override public V get(Object key) {
+		Node<K, V> node = findByObject(key);
+		return node != null ? node.value : null;
+	}
+
+	@Override public boolean containsKey(Object key) {
+		return findByObject(key) != null;
+	}
+
+	@Override public V put(K key, V value) {
+		if (key == null) {
+			throw new NullPointerException("key == null");
+		}
+		Node<K, V> created = find(key, true);
+		V result = created.value;
+		created.value = value;
+		return result;
+	}
+
+	@Override public void clear() {
+		root = null;
+		size = 0;
+		modCount++;
+
+		// Clear iteration order
+		Node<K, V> header = this.header;
+		header.next = header.prev = header;
+	}
+
+	@Override public V remove(Object key) {
+		Node<K, V> node = removeInternalByKey(key);
+		return node != null ? node.value : null;
+	}
+
+	/**
+	 * Returns the node at or adjacent to the given key, creating it if requested.
+	 *
+	 * @throws ClassCastException if {@code key} and the tree's keys aren't
+	 *     mutually comparable.
+	 */
+	Node<K, V> find(K key, boolean create) {
+		Node<K, V> nearest = root;
+		int comparison = 0;
+
+		if (nearest != null) {
+			while (true) {
+				comparison = key.compareTo(nearest.key);
+
+				// We found the requested key.
+				if (comparison == 0) {
+					return nearest;
+				}
+
+				// If it exists, the key is in a subtree. Go deeper.
+				Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;
+				if (child == null) {
+					break;
+				}
+
+				nearest = child;
+			}
+		}
+
+		// The key doesn't exist in this tree.
+		if (!create) {
+			return null;
+		}
+
+		// Create the node and add it to the tree or the table.
+		Node<K, V> header = this.header;
+		Node<K, V> created;
+		if (nearest == null) {
+			created = new Node<>(nearest, key, header, header.prev);
+			root = created;
+		} else {
+			created = new Node<>(nearest, key, header, header.prev);
+			if (comparison < 0) { // nearest.key is higher
+				nearest.left = created;
+			} else { // comparison > 0, nearest.key is lower
+				nearest.right = created;
+			}
+			rebalance(nearest, true);
+		}
+		size++;
+		modCount++;
+
+		return created;
+	}
+
+	@SuppressWarnings("unchecked")
+	Node<K, V> findByObject(Object key) {
+		try {
+			return key != null ? find((K) key, false) : null;
+		} catch (ClassCastException e) {
+			return null;
+		}
+	}
+
+	/**
+	 * Returns this map's entry that has the same key and value as {@code
+	 * entry}, or null if this map has no such entry.
+	 *
+	 * <p>This method uses the comparator for key equality rather than {@code
+	 * equals}. If this map's comparator isn't consistent with equals (such as
+	 * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code
+	 * contains()} will violate the collections API.
+	 */
+	Node<K, V> findByEntry(Entry<?, ?> entry) {
+		Node<K, V> mine = findByObject(entry.getKey());
+		boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());
+		return valuesEqual ? mine : null;
+	}
+
+	private boolean equal(Object a, Object b) {
+		return a == b || (a != null && a.equals(b));
+	}
+
+	/**
+	 * Removes {@code node} from this tree, rearranging the tree's structure as
+	 * necessary.
+	 *
+	 * @param unlink true to also unlink this node from the iteration linked list.
+	 */
+	void removeInternal(Node<K, V> node, boolean unlink) {
+		if (unlink) {
+			node.prev.next = node.next;
+			node.next.prev = node.prev;
+		}
+
+		Node<K, V> left = node.left;
+		Node<K, V> right = node.right;
+		Node<K, V> originalParent = node.parent;
+		if (left != null && right != null) {
+
+			/*
+			 * To remove a node with both left and right subtrees, move an
+			 * adjacent node from one of those subtrees into this node's place.
+			 *
+			 * Removing the adjacent node may change this node's subtrees. This
+			 * node may no longer have two subtrees once the adjacent node is
+			 * gone!
+			 */
+
+			Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();
+			removeInternal(adjacent, false); // takes care of rebalance and size--
+
+			int leftHeight = 0;
+			left = node.left;
+			if (left != null) {
+				leftHeight = left.height;
+				adjacent.left = left;
+				left.parent = adjacent;
+				node.left = null;
+			}
+
+			int rightHeight = 0;
+			right = node.right;
+			if (right != null) {
+				rightHeight = right.height;
+				adjacent.right = right;
+				right.parent = adjacent;
+				node.right = null;
+			}
+
+			adjacent.height = Math.max(leftHeight, rightHeight) + 1;
+			replaceInParent(node, adjacent);
+			return;
+		} else if (left != null) {
+			replaceInParent(node, left);
+			node.left = null;
+		} else if (right != null) {
+			replaceInParent(node, right);
+			node.right = null;
+		} else {
+			replaceInParent(node, null);
+		}
+
+		rebalance(originalParent, false);
+		size--;
+		modCount++;
+	}
+
+	Node<K, V> removeInternalByKey(Object key) {
+		Node<K, V> node = findByObject(key);
+		if (node != null) {
+			removeInternal(node, true);
+		}
+		return node;
+	}
+
+	private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {
+		Node<K, V> parent = node.parent;
+		node.parent = null;
+		if (replacement != null) {
+			replacement.parent = parent;
+		}
+
+		if (parent != null) {
+			if (parent.left == node) {
+				parent.left = replacement;
+			} else {
+				assert (parent.right == node);
+				parent.right = replacement;
+			}
+		} else {
+			root = replacement;
+		}
+	}
+
+	/**
+	 * Rebalances the tree by making any AVL rotations necessary between the
+	 * newly-unbalanced node and the tree's root.
+	 *
+	 * @param insert true if the node was unbalanced by an insert; false if it
+	 *     was by a removal.
+	 */
+	private void rebalance(Node<K, V> unbalanced, boolean insert) {
+		for (Node<K, V> node = unbalanced; node != null; node = node.parent) {
+			Node<K, V> left = node.left;
+			Node<K, V> right = node.right;
+			int leftHeight = left != null ? left.height : 0;
+			int rightHeight = right != null ? right.height : 0;
+
+			int delta = leftHeight - rightHeight;
+			if (delta == -2) {
+				Node<K, V> rightLeft = right.left;
+				Node<K, V> rightRight = right.right;
+				int rightRightHeight = rightRight != null ? rightRight.height : 0;
+				int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;
+
+				int rightDelta = rightLeftHeight - rightRightHeight;
+				if (rightDelta == -1 || (rightDelta == 0 && !insert)) {
+					rotateLeft(node); // AVL right right
+				} else {
+					assert (rightDelta == 1);
+					rotateRight(right); // AVL right left
+					rotateLeft(node);
+				}
+				if (insert) {
+					break; // no further rotations will be necessary
+				}
+
+			} else if (delta == 2) {
+				Node<K, V> leftLeft = left.left;
+				Node<K, V> leftRight = left.right;
+				int leftRightHeight = leftRight != null ? leftRight.height : 0;
+				int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;
+
+				int leftDelta = leftLeftHeight - leftRightHeight;
+				if (leftDelta == 1 || (leftDelta == 0 && !insert)) {
+					rotateRight(node); // AVL left left
+				} else {
+					assert (leftDelta == -1);
+					rotateLeft(left); // AVL left right
+					rotateRight(node);
+				}
+				if (insert) {
+					break; // no further rotations will be necessary
+				}
+
+			} else if (delta == 0) {
+				node.height = leftHeight + 1; // leftHeight == rightHeight
+				if (insert) {
+					break; // the insert caused balance, so rebalancing is done!
+				}
+
+			} else {
+				assert (delta == -1 || delta == 1);
+				node.height = Math.max(leftHeight, rightHeight) + 1;
+				if (!insert) {
+					break; // the height hasn't changed, so rebalancing is done!
+				}
+			}
+		}
+	}
+
+	/**
+	 * Rotates the subtree so that its root's right child is the new root.
+	 */
+	private void rotateLeft(Node<K, V> root) {
+		Node<K, V> left = root.left;
+		Node<K, V> pivot = root.right;
+		Node<K, V> pivotLeft = pivot.left;
+		Node<K, V> pivotRight = pivot.right;
+
+		// move the pivot's left child to the root's right
+		root.right = pivotLeft;
+		if (pivotLeft != null) {
+			pivotLeft.parent = root;
+		}
+
+		replaceInParent(root, pivot);
+
+		// move the root to the pivot's left
+		pivot.left = root;
+		root.parent = pivot;
+
+		// fix heights
+		root.height = Math.max(left != null ? left.height : 0,
+				pivotLeft != null ? pivotLeft.height : 0) + 1;
+		pivot.height = Math.max(root.height,
+				pivotRight != null ? pivotRight.height : 0) + 1;
+	}
+
+	/**
+	 * Rotates the subtree so that its root's left child is the new root.
+	 */
+	private void rotateRight(Node<K, V> root) {
+		Node<K, V> pivot = root.left;
+		Node<K, V> right = root.right;
+		Node<K, V> pivotLeft = pivot.left;
+		Node<K, V> pivotRight = pivot.right;
+
+		// move the pivot's right child to the root's left
+		root.left = pivotRight;
+		if (pivotRight != null) {
+			pivotRight.parent = root;
+		}
+
+		replaceInParent(root, pivot);
+
+		// move the root to the pivot's right
+		pivot.right = root;
+		root.parent = pivot;
+
+		// fixup heights
+		root.height = Math.max(right != null ? right.height : 0,
+				pivotRight != null ? pivotRight.height : 0) + 1;
+		pivot.height = Math.max(root.height,
+				pivotLeft != null ? pivotLeft.height : 0) + 1;
+	}
+
+	private EntrySet entrySet;
+	private KeySet keySet;
+
+	@Override public Set<Entry<K, V>> entrySet() {
+		EntrySet result = entrySet;
+		return result != null ? result : (entrySet = new EntrySet());
+	}
+
+	@Override public Set<K> keySet() {
+		KeySet result = keySet;
+		return result != null ? result : (keySet = new KeySet());
+	}
+
+	static final class Node<K, V> implements Entry<K, V> {
+		Node<K, V> parent;
+		Node<K, V> left;
+		Node<K, V> right;
+		Node<K, V> next;
+		Node<K, V> prev;
+		final K key;
+		V value;
+		int height;
+
+		/** Create the header entry */
+		Node() {
+			key = null;
+			next = prev = this;
+		}
+
+		/** Create a regular entry */
+		Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {
+			this.parent = parent;
+			this.key = key;
+			this.height = 1;
+			this.next = next;
+			this.prev = prev;
+			prev.next = this;
+			next.prev = this;
+		}
+
+		@Override
+		public K getKey() {
+			return key;
+		}
+
+		@Override
+		public V getValue() {
+			return value;
+		}
+
+		@Override
+		public V setValue(V value) {
+			V oldValue = this.value;
+			this.value = value;
+			return oldValue;
+		}
+
+		@SuppressWarnings("rawtypes")
+		@Override public boolean equals(Object o) {
+			if (o instanceof Entry) {
+				Entry other = (Entry) o;
+				return (key == null ? other.getKey() == null : key.equals(other.getKey()))
+						&& (value == null ? other.getValue() == null : value.equals(other.getValue()));
+			}
+			return false;
+		}
+
+		@Override public int hashCode() {
+			return (key == null ? 0 : key.hashCode())
+					^ (value == null ? 0 : value.hashCode());
+		}
+
+		@Override public String toString() {
+			return key + "=" + value;
+		}
+
+		/**
+		 * Returns the first node in this subtree.
+		 */
+		public Node<K, V> first() {
+			Node<K, V> node = this;
+			Node<K, V> child = node.left;
+			while (child != null) {
+				node = child;
+				child = node.left;
+			}
+			return node;
+		}
+
+		/**
+		 * Returns the last node in this subtree.
+		 */
+		public Node<K, V> last() {
+			Node<K, V> node = this;
+			Node<K, V> child = node.right;
+			while (child != null) {
+				node = child;
+				child = node.right;
+			}
+			return node;
+		}
+	}
+
+	private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {
+		Node<K, V> next = header.next;
+		Node<K, V> lastReturned = null;
+		int expectedModCount = modCount;
+
+		LinkedTreeMapIterator() {
+		}
+
+		@Override
+		public final boolean hasNext() {
+			return next != header;
+		}
+
+		final Node<K, V> nextNode() {
+			Node<K, V> e = next;
+			if (e == header) {
+				throw new NoSuchElementException();
+			}
+			if (modCount != expectedModCount) {
+				throw new ConcurrentModificationException();
+			}
+			next = e.next;
+			return lastReturned = e;
+		}
+
+		@Override
+		public final void remove() {
+			if (lastReturned == null) {
+				throw new IllegalStateException();
+			}
+			removeInternal(lastReturned, true);
+			lastReturned = null;
+			expectedModCount = modCount;
+		}
+	}
+
+	class EntrySet extends AbstractSet<Entry<K, V>> {
+		@Override public int size() {
+			return size;
+		}
+
+		@Override public Iterator<Entry<K, V>> iterator() {
+			return new LinkedTreeMapIterator<>() {
+				public Entry<K, V> next() {
+					return nextNode();
+				}
+			};
+		}
+
+		@Override public boolean contains(Object o) {
+			return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;
+		}
+
+		@Override public boolean remove(Object o) {
+			if (!(o instanceof Entry)) {
+				return false;
+			}
+
+			Node<K, V> node = findByEntry((Entry<?, ?>) o);
+			if (node == null) {
+				return false;
+			}
+			removeInternal(node, true);
+			return true;
+		}
+
+		@Override public void clear() {
+			LinkedTreeMap.this.clear();
+		}
+	}
+
+	final class KeySet extends AbstractSet<K> {
+		@Override public int size() {
+			return size;
+		}
+
+		@Override public Iterator<K> iterator() {
+			return new LinkedTreeMapIterator<>() {
+				public K next() {
+					return nextNode().key;
+				}
+			};
+		}
+
+		@Override public boolean contains(Object o) {
+			return containsKey(o);
+		}
+
+		@Override public boolean remove(Object key) {
+			return removeInternalByKey(key) != null;
+		}
+
+		@Override public void clear() {
+			LinkedTreeMap.this.clear();
+		}
+	}
+
+	/**
+	 * If somebody is unlucky enough to have to serialize one of these, serialize
+	 * it as a LinkedHashMap so that they won't need Gson on the other side to
+	 * deserialize it. Using serialization defeats our DoS defence, so most apps
+	 * shouldn't use it.
+	 */
+	private Object writeReplace() throws ObjectStreamException {
+		return new LinkedHashMap<>(this);
+	}
 }
diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java
deleted file mode 100644
index 71360c6fe..000000000
--- a/gson/src/main/java/com/google/gson/internal/Streams.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-import com.google.gson.*;
-import com.google.gson.internal.bind.*;
-import com.google.gson.stream.*;
-import java.io.*;
-
-/**
- * Reads and writes GSON parse trees over streams.
- */
-public final class Streams {
-
-  /**
-   * Takes a reader in any state and returns the next value as a JsonElement.
-   */
-  public static JsonElement parse(JsonReader reader) throws JsonParseException {
-    try {
-      return TypeAdapters.JSON_ELEMENT.read(reader);
-    } catch (EOFException e) {
-      throw new JsonSyntaxException(e);
-    } catch (MalformedJsonException e) {
-      throw new JsonSyntaxException(e);
-    } catch (IOException e) {
-      throw new JsonIOException(e);
-    } catch (NumberFormatException e) {
-      throw new JsonSyntaxException(e);
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index befe9b7b9..beb97eb73 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -16,22 +16,12 @@
 
 package com.google.gson.internal.bind;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Streams;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
+import com.google.gson.*;
+import com.google.gson.internal.*;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.lang.reflect.*;
 
 /**
  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the
@@ -62,7 +52,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
 		if (deserializer == null) {
 			return delegate().read(in);
 		}
-		JsonElement value = Streams.parse(in);
+		JsonElement value = Gson.parseReader(in);
 		if (value.isJsonNull()) {
 			return null;
 		}
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 6b99ac124..ee81665ce 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -16,8 +16,7 @@
 
 package com.google.gson.stream;
 
-import com.google.gson.internal.JsonReaderInternalAccess;
-import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.gson.internal.*;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
diff --git a/gson/src/test/java/com/google/gson/JsonParserTest.java b/gson/src/test/java/com/google/gson/JsonParserTest.java
index c7355c709..0843c3ccf 100644
--- a/gson/src/test/java/com/google/gson/JsonParserTest.java
+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java
@@ -16,15 +16,10 @@
 
 package com.google.gson;
 
-import java.io.CharArrayReader;
-import java.io.CharArrayWriter;
-import java.io.StringReader;
-
-import junit.framework.TestCase;
-
-import com.google.gson.common.TestTypes.BagOfPrimitives;
-import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
+import com.google.gson.common.TestTypes.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import junit.framework.*;
 
 /**
  * Unit test for {@link JsonParser}
@@ -104,8 +99,8 @@ public void testReadWriteTwoObjects() throws Exception {
 
     JsonReader parser = new JsonReader(reader);
     parser.setLenient(true);
-    JsonElement element1 = Streams.parse(parser);
-    JsonElement element2 = Streams.parse(parser);
+    JsonElement element1 = Gson.parseReader(parser);
+    JsonElement element2 = Gson.parseReader(parser);
     BagOfPrimitives actualOne = gson.fromJson(element1, BagOfPrimitives.class);
     assertEquals("one", actualOne.stringValue);
     BagOfPrimitives actualTwo = gson.fromJson(element2, BagOfPrimitives.class);
diff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index a4fb661da..115ee2fb5 100644
--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -15,25 +15,14 @@
  */
 package com.google.gson.functional;
 
-import java.io.IOException;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import junit.framework.TestCase;
-
-import com.google.gson.Gson;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.JsonAdapter;
-import com.google.gson.internal.Streams;
+import com.google.gson.*;
+import com.google.gson.annotations.*;
 import com.google.gson.internal.bind.*;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+import com.google.gson.reflect.*;
+import com.google.gson.stream.*;
+import java.io.*;
+import java.util.*;
+import junit.framework.*;
 
 /**
  * Functional tests for the RuntimeTypeAdapterFactory feature in extras.
@@ -164,7 +153,7 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
 
       return new TypeAdapter<R>() {
         @Override public R read(JsonReader in) throws IOException {
-          JsonElement jsonElement = Streams.parse(in);
+          JsonElement jsonElement = Gson.parseReader(in);
           JsonElement labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
           if (labelJsonElement == null) {
             throw new JsonParseException("cannot deserialize " + baseType
diff --git a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
index 580d25a57..13f15e50d 100644
--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
@@ -59,14 +59,6 @@ public void testPutNullKeyFails() {
     }
   }
 
-  public void testPutNonComparableKeyFails() {
-    LinkedTreeMap<Object, String> map = new LinkedTreeMap<Object, String>();
-    try {
-      map.put(new Object(), "android");
-      fail();
-    } catch (ClassCastException expected) {}
-  }
-
   public void testContainsNonComparableKeyReturnsFalse() {
     LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();
     map.put("a", "android");
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
index bd6bc743b..8ea143bc6 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
@@ -17,6 +17,7 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.JsonElement;
+import com.google.gson.internal.*;
 import com.google.gson.Gson;
 import com.google.gson.stream.JsonToken;
 import java.io.IOException;
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
index f6a5bf33e..09beacf9f 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
@@ -18,6 +18,7 @@
 import com.google.gson.JsonArray;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
+import com.google.gson.internal.*;
 import com.google.gson.stream.JsonToken;
 import java.io.IOException;
 import junit.framework.TestCase;
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
index 9d36eb360..76e3af8b8 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java
@@ -17,6 +17,7 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.JsonNull;
+import com.google.gson.internal.*;
 import java.io.IOException;
 import junit.framework.TestCase;
 
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
index c0b269172..bc697c174 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
@@ -16,9 +16,8 @@
 
 package com.google.gson.stream;
 
-import com.google.gson.JsonElement;
-import com.google.gson.internal.Streams;
-import com.google.gson.internal.bind.JsonTreeReader;
+import com.google.gson.*;
+import com.google.gson.internal.*;
 import java.io.IOException;
 import java.io.StringReader;
 import java.util.Arrays;
@@ -27,7 +26,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assume.assumeTrue;
 
 @RunWith(Parameterized.class)
@@ -246,7 +245,7 @@
     },
     OBJECT_READER {
       @Override public JsonReader create(String data) {
-        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));
+        JsonElement element = Gson.parseReader(new JsonReader(new StringReader(data)));
         return new JsonTreeReader(element);
       }
     };
