diff --git a/README.md b/README.md
index a67bdb458..0fdc63822 100644
--- a/README.md
+++ b/README.md
@@ -35,12 +35,12 @@ Maven:
 [![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
 
 ### Documentation
-  * [API Javadoc](http://www.javadoc.io/doc/com.google.code.gson/gson): Documentation for the current release
+  * [API Javadoc](https://www.javadoc.io/doc/com.google.code.gson/gson): Documentation for the current release
   * [User guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
   * [Change log](https://github.com/google/gson/blob/master/CHANGELOG.md): Changes in the recent versions
   * [Design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
 
-Please use the 'gson' tag on StackOverflow or the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson or to post questions.
+Please use the 'gson' tag on StackOverflow or the [google-gson Google group](https://groups.google.com/group/google-gson) to discuss Gson or to post questions.
 
 ### Related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
diff --git a/ReleaseProcess.md b/ReleaseProcess.md
index bb2719cd4..4b85f4dc4 100644
--- a/ReleaseProcess.md
+++ b/ReleaseProcess.md
@@ -17,15 +17,15 @@ The following is a step-by-step procedure for releasing a new version of Google-
 
 1. Update the version in the [Using Gson with Maven2 page](https://github.com/google/gson/blob/master/UserGuide.md#TOC-Gson-With-Maven)
 1. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
-1. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
-1. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current "stable" release.
+1. Create a post on the [Gson Discussion Forum](https://groups.google.com/group/google-gson)
+1. Update the release version in [Wikipedia](https://en.wikipedia.org/wiki/GSON) and update the current "stable" release.
 
 ## Configuring a machine for deployment to Sonatype Repository
 
-This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
+This section was borrowed heavily from [Doclava release process](https://code.google.com/archive/p/doclava/wikis/ProcessRelease.wiki).
 
-1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
-1. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+1. Install/Configure GPG following this [guide](https://blog.sonatype.com/2010/01/how-to-generate-pgp-signatures-with-maven/).
+1. [Create encrypted passwords](https://maven.apache.org/guides/mini/guide-encryption.html).
 1. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
 1. Now for deploying a snapshot repository, use `mvn deploy`.
 
diff --git a/UserGuide.md b/UserGuide.md
index 28ced738b..f5d2fff00 100644
--- a/UserGuide.md
+++ b/UserGuide.md
@@ -250,7 +250,7 @@ gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
 
 The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
 
-You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
+You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html) class.
 
 ```java
 Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
@@ -556,7 +556,7 @@ This feature provides a way where you can mark certain fields of your objects to
 
 #### <a name="TOC-User-Defined-Exclusion-Strategies"></a>User Defined Exclusion Strategies
 
-If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
 
 The following example shows how to exclude fields marked with a specific `@Foo` annotation and excludes top-level types (or declared field type) of class `String`.
 
@@ -615,7 +615,7 @@ The output is:
 
 ### <a name="TOC-JSON-Field-Naming-Support"></a>JSON Field Naming Support
 
-Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
+Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
 
 It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise "Runtime" exceptions if an invalid field name is provided as the annotation value.
 
@@ -644,11 +644,11 @@ The output is:
 {"custom_naming":"first","SomeOtherField":"second"}
 ```
 
-If you have a need for custom naming policy ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](http://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html) annotation.
+If you have a need for custom naming policy ([see this discussion](https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html) annotation.
 
 ### <a name="TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers"></a>Sharing State Across Custom Serializers and Deserializers
 
-Sometimes you need to share state across custom serializers/deserializers ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb)). You can use the following three strategies to accomplish this:
+Sometimes you need to share state across custom serializers/deserializers ([see this discussion](https://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb)). You can use the following three strategies to accomplish this:
 
 1. Store shared state in static fields
 2. Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
index 6c5709f3d..031e71f7d 100644
--- a/examples/android-proguard-example/proguard.cfg
+++ b/examples/android-proguard-example/proguard.cfg
@@ -11,7 +11,7 @@
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson
--keep class com.google.gson.examples.android.model.** { *; }
+-keep class com.google.gson.examples.android.model.** { <fields>; }
 
 # Prevent proguard from stripping interface information from TypeAdapterFactory,
 # JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
@@ -19,4 +19,9 @@
 -keep class * implements com.google.gson.JsonSerializer
 -keep class * implements com.google.gson.JsonDeserializer
 
+# Prevent R8 from leaving Data object members always null
+-keepclassmembers,allowobfuscation class * {
+  @com.google.gson.annotations.SerializedName <fields>;
+}
+
 ##---------------End: proguard configuration for Gson  ----------
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
index 1f1eb8f10..2e833cd07 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
@@ -159,31 +159,20 @@ static String separateCamelCase(String name, String separator) {
    * Ensures the JSON field names begins with an upper case letter.
    */
   static String upperCaseFirstLetter(String name) {
-    StringBuilder fieldNameBuilder = new StringBuilder();
-    int index = 0;
-    char firstCharacter = name.charAt(index);
-    int length = name.length();
+    int firstLetterIndex = 0;
+    int limit = name.length() - 1;
+    for(; !Character.isLetter(name.charAt(firstLetterIndex)) && firstLetterIndex < limit; ++firstLetterIndex);
 
-    while (index < length - 1) {
-      if (Character.isLetter(firstCharacter)) {
-        break;
-      }
-
-      fieldNameBuilder.append(firstCharacter);
-      firstCharacter = name.charAt(++index);
+    char firstLetter = name.charAt(firstLetterIndex);
+    if(Character.isUpperCase(firstLetter)) { //The letter is already uppercased, return the original
+      return name;
     }
 
-    if (!Character.isUpperCase(firstCharacter)) {
-      String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);
-      return fieldNameBuilder.append(modifiedTarget).toString();
-    } else {
-      return name;
+    char uppercased = Character.toUpperCase(firstLetter);
+    if(firstLetterIndex == 0) { //First character in the string is the first letter, saves 1 substring
+      return uppercased + name.substring(1);
     }
-  }
 
-  private static String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {
-    return (indexOfSubstring < srcString.length())
-        ? firstCharacter + srcString.substring(indexOfSubstring)
-        : String.valueOf(firstCharacter);
+    return name.substring(0, firstLetterIndex) + uppercased + name.substring(firstLetterIndex + 1);
   }
 }
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 0cb171c71..27f3ee924 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -192,8 +192,8 @@ public Gson() {
         Collections.<TypeAdapterFactory>emptyList());
   }
 
-  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
-      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+  Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
+      Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index 315ff82e9..2ab1a1609 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -153,19 +153,6 @@ public boolean getAsBoolean() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }
 
-  /**
-   * convenience method to get this element as a {@link Boolean} value.
-   *
-   * @return get this element as a {@link Boolean} value.
-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
-   * boolean value.
-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
-   * more than a single element.
-   */
-  Boolean getAsBooleanWrapper() {
-    throw new UnsupportedOperationException(getClass().getSimpleName());
-  }
-
   /**
    * convenience method to get this element as a {@link Number}.
    *
diff --git a/gson/src/main/java/com/google/gson/JsonParser.java b/gson/src/main/java/com/google/gson/JsonParser.java
index a8ae337ba..5121e4e10 100644
--- a/gson/src/main/java/com/google/gson/JsonParser.java
+++ b/gson/src/main/java/com/google/gson/JsonParser.java
@@ -32,6 +32,9 @@
  * @since 1.3
  */
 public final class JsonParser {
+  /** @deprecated No need to instantiate this class, use the static methods instead. */
+  @Deprecated
+  public JsonParser() {}
 
   /**
    * Parses the specified JSON string into a parse tree
@@ -39,24 +42,22 @@
    * @param json JSON text
    * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
    * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
    */
-  public JsonElement parse(String json) throws JsonSyntaxException {
-    return parse(new StringReader(json));
+  public static JsonElement parseString(String json) throws JsonSyntaxException {
+    return parseReader(new StringReader(json));
   }
 
   /**
    * Parses the specified JSON string into a parse tree
    *
-   * @param json JSON text
+   * @param reader JSON text
    * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON
    * @throws JsonParseException if the specified text is not valid JSON
-   * @since 1.3
    */
-  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
+  public static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {
     try {
-      JsonReader jsonReader = new JsonReader(json);
-      JsonElement element = parse(jsonReader);
+      JsonReader jsonReader = new JsonReader(reader);
+      JsonElement element = parseReader(jsonReader);
       if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {
         throw new JsonSyntaxException("Did not consume the entire document.");
       }
@@ -75,19 +76,37 @@ public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxExceptio
    *
    * @throws JsonParseException if there is an IOException or if the specified
    *     text is not valid JSON
-   * @since 1.6
    */
-  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
-    boolean lenient = json.isLenient();
-    json.setLenient(true);
+  public static JsonElement parseReader(JsonReader reader)
+      throws JsonIOException, JsonSyntaxException {
+    boolean lenient = reader.isLenient();
+    reader.setLenient(true);
     try {
-      return Streams.parse(json);
+      return Streams.parse(reader);
     } catch (StackOverflowError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+      throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
     } catch (OutOfMemoryError e) {
-      throw new JsonParseException("Failed parsing JSON source: " + json + " to Json", e);
+      throw new JsonParseException("Failed parsing JSON source: " + reader + " to Json", e);
     } finally {
-      json.setLenient(lenient);
+      reader.setLenient(lenient);
     }
   }
+
+  /** @deprecated Use {@link JsonParser#parseString} */
+  @Deprecated
+  public JsonElement parse(String json) throws JsonSyntaxException {
+    return parseString(json);
+  }
+
+  /** @deprecated Use {@link JsonParser#parseReader(Reader)} */
+  @Deprecated
+  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {
+    return parseReader(json);
+  }
+
+  /** @deprecated Use {@link JsonParser#parseReader(JsonReader)} */
+  @Deprecated
+  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {
+    return parseReader(json);
+  }
 }
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index d4640293e..5e95d5a82 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -91,16 +91,6 @@ public boolean isBoolean() {
     return value instanceof Boolean;
   }
 
-  /**
-   * convenience method to get this element as a {@link Boolean}.
-   *
-   * @return get this element as a {@link Boolean}.
-   */
-  @Override
-  Boolean getAsBooleanWrapper() {
-    return (Boolean) value;
-  }
-
   /**
    * convenience method to get this element as a boolean value.
    *
@@ -109,11 +99,10 @@ Boolean getAsBooleanWrapper() {
   @Override
   public boolean getAsBoolean() {
     if (isBoolean()) {
-      return getAsBooleanWrapper().booleanValue();
-    } else {
-      // Check to see if the value as a String is "true" in any case.
-      return Boolean.parseBoolean(getAsString());
+      return ((Boolean) value).booleanValue();
     }
+	// Check to see if the value as a String is "true" in any case.
+    return Boolean.parseBoolean(getAsString());
   }
 
   /**
@@ -155,7 +144,7 @@ public String getAsString() {
     if (isNumber()) {
       return getAsNumber().toString();
     } else if (isBoolean()) {
-      return getAsBooleanWrapper().toString();
+      return ((Boolean) value).toString();
     } else {
       return (String) value;
     }
diff --git a/gson/src/main/java/com/google/gson/internal/Primitives.java b/gson/src/main/java/com/google/gson/internal/Primitives.java
index a98f6242a..2506fd0a5 100644
--- a/gson/src/main/java/com/google/gson/internal/Primitives.java
+++ b/gson/src/main/java/com/google/gson/internal/Primitives.java
@@ -16,11 +16,7 @@
 
 package com.google.gson.internal;
 
-
 import java.lang.reflect.Type;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Contains static utility methods pertaining to primitive types and their
@@ -29,47 +25,13 @@
  * @author Kevin Bourrillion
  */
 public final class Primitives {
-  private Primitives() {
-    throw new UnsupportedOperationException();
-  }
-
-  /** A map from primitive types to their corresponding wrapper types. */
-  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;
-
-  /** A map from wrapper types to their corresponding primitive types. */
-  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;
-
-  // Sad that we can't use a BiMap. :(
-
-  static {
-    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);
-    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);
-
-    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
-    add(primToWrap, wrapToPrim, byte.class, Byte.class);
-    add(primToWrap, wrapToPrim, char.class, Character.class);
-    add(primToWrap, wrapToPrim, double.class, Double.class);
-    add(primToWrap, wrapToPrim, float.class, Float.class);
-    add(primToWrap, wrapToPrim, int.class, Integer.class);
-    add(primToWrap, wrapToPrim, long.class, Long.class);
-    add(primToWrap, wrapToPrim, short.class, Short.class);
-    add(primToWrap, wrapToPrim, void.class, Void.class);
-
-    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
-    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
-  }
-
-  private static void add(Map<Class<?>, Class<?>> forward,
-      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {
-    forward.put(key, value);
-    backward.put(value, key);
-  }
+  private Primitives() {}
 
   /**
    * Returns true if this type is a primitive.
    */
   public static boolean isPrimitive(Type type) {
-    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);
+    return type instanceof Class<?> && ((Class<?>) type).isPrimitive();
   }
 
   /**
@@ -79,8 +41,15 @@ public static boolean isPrimitive(Type type) {
    * @see Class#isPrimitive
    */
   public static boolean isWrapperType(Type type) {
-    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(
-        $Gson$Preconditions.checkNotNull(type));
+    return type == Integer.class
+        || type == Float.class
+        || type == Byte.class
+        || type == Double.class
+        || type == Long.class
+        || type == Character.class
+        || type == Boolean.class
+        || type == Short.class
+        || type == Void.class;
   }
 
   /**
@@ -92,12 +61,18 @@ public static boolean isWrapperType(Type type) {
    *     wrap(String.class) == String.class
    * </pre>
    */
+  @SuppressWarnings("unchecked")
   public static <T> Class<T> wrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(
-        $Gson$Preconditions.checkNotNull(type));
-    return (wrapped == null) ? type : wrapped;
+    if (type == int.class) return (Class<T>) Integer.class;
+    if (type == float.class) return (Class<T>) Float.class;
+    if (type == byte.class) return (Class<T>) Byte.class;
+    if (type == double.class) return (Class<T>) Double.class;
+    if (type == long.class) return (Class<T>) Long.class;
+    if (type == char.class) return (Class<T>) Character.class;
+    if (type == boolean.class) return (Class<T>) Boolean.class;
+    if (type == short.class) return (Class<T>) Short.class;
+    if (type == void.class) return (Class<T>) Void.class;
+    return type;
   }
 
   /**
@@ -109,11 +84,17 @@ public static boolean isWrapperType(Type type) {
    *     unwrap(String.class) == String.class
    * </pre>
    */
+  @SuppressWarnings("unchecked")
   public static <T> Class<T> unwrap(Class<T> type) {
-    // cast is safe: long.class and Long.class are both of type Class<Long>
-    @SuppressWarnings("unchecked")
-    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(
-        $Gson$Preconditions.checkNotNull(type));
-    return (unwrapped == null) ? type : unwrapped;
+    if (type == Integer.class) return (Class<T>) int.class;
+    if (type == Float.class) return (Class<T>) float.class;
+    if (type == Byte.class) return (Class<T>) byte.class;
+    if (type == Double.class) return (Class<T>) double.class;
+    if (type == Long.class) return (Class<T>) long.class;
+    if (type == Character.class) return (Class<T>) char.class;
+    if (type == Boolean.class) return (Class<T>) boolean.class;
+    if (type == Short.class) return (Class<T>) short.class;
+    if (type == Void.class) return (Class<T>) void.class;
+    return type;
   }
 }
diff --git a/gson/src/main/java/module-info.java b/gson/src/main/java/module-info.java
index d567d8ce5..ba6ea07b7 100644
--- a/gson/src/main/java/module-info.java
+++ b/gson/src/main/java/module-info.java
@@ -4,5 +4,5 @@
 	exports com.google.gson.reflect;
 	exports com.google.gson.stream;
 
-	requires java.sql;
+	requires transitive java.sql;
 }
diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java
index d071c3baa..652b52885 100644
--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java
+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java
@@ -128,7 +128,7 @@ public void testWritePropertyWithEmptyStringName() {
   }
 
   public void testReadPropertyWithEmptyStringName() {
-    JsonObject jsonObj = new JsonParser().parse("{\"\":true}").getAsJsonObject();
+    JsonObject jsonObj = JsonParser.parseString("{\"\":true}").getAsJsonObject();
     assertEquals(true, jsonObj.get("").getAsBoolean());
   }
 
diff --git a/gson/src/test/java/com/google/gson/JsonParserTest.java b/gson/src/test/java/com/google/gson/JsonParserTest.java
index 7efa7fd2e..cc18238be 100644
--- a/gson/src/test/java/com/google/gson/JsonParserTest.java
+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java
@@ -32,23 +32,16 @@
  * @author Inderjeet Singh
  */
 public class JsonParserTest extends TestCase {
-  private JsonParser parser;
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-    parser = new JsonParser();
-  }
 
   public void testParseInvalidJson() {
     try {
-      parser.parse("[[]");
+      JsonParser.parseString("[[]");
       fail();
     } catch (JsonSyntaxException expected) { }
   }
 
   public void testParseUnquotedStringArrayFails() {
-    JsonElement element = parser.parse("[a,b,c]");
+    JsonElement element = JsonParser.parseString("[a,b,c]");
     assertEquals("a", element.getAsJsonArray().get(0).getAsString());
     assertEquals("b", element.getAsJsonArray().get(1).getAsString());
     assertEquals("c", element.getAsJsonArray().get(2).getAsString());
@@ -57,38 +50,38 @@ public void testParseUnquotedStringArrayFails() {
 
   public void testParseString() {
     String json = "{a:10,b:'c'}";
-    JsonElement e = parser.parse(json);
+    JsonElement e = JsonParser.parseString(json);
     assertTrue(e.isJsonObject());
     assertEquals(10, e.getAsJsonObject().get("a").getAsInt());
     assertEquals("c", e.getAsJsonObject().get("b").getAsString());
   }
 
   public void testParseEmptyString() {
-    JsonElement e = parser.parse("\"   \"");
+    JsonElement e = JsonParser.parseString("\"   \"");
     assertTrue(e.isJsonPrimitive());
     assertEquals("   ", e.getAsString());
   }
 
   public void testParseEmptyWhitespaceInput() {
-    JsonElement e = parser.parse("     ");
+    JsonElement e = JsonParser.parseString("     ");
     assertTrue(e.isJsonNull());
   }
 
   public void testParseUnquotedSingleWordStringFails() {
-    assertEquals("Test", parser.parse("Test").getAsString());
+    assertEquals("Test", JsonParser.parseString("Test").getAsString());
   }
 
   public void testParseUnquotedMultiWordStringFails() {
     String unquotedSentence = "Test is a test..blah blah";
     try {
-      parser.parse(unquotedSentence);
+      JsonParser.parseString(unquotedSentence);
       fail();
     } catch (JsonSyntaxException expected) { }
   }
 
   public void testParseMixedArray() {
     String json = "[{},13,\"stringValue\"]";
-    JsonElement e = parser.parse(json);
+    JsonElement e = JsonParser.parseString(json);
     assertTrue(e.isJsonArray());
 
     JsonArray  array = e.getAsJsonArray();
@@ -99,7 +92,7 @@ public void testParseMixedArray() {
 
   public void testParseReader() {
     StringReader reader = new StringReader("{a:10,b:'c'}");
-    JsonElement e = parser.parse(reader);
+    JsonElement e = JsonParser.parseReader(reader);
     assertTrue(e.isJsonObject());
     assertEquals(10, e.getAsJsonObject().get("a").getAsInt());
     assertEquals("c", e.getAsJsonObject().get("b").getAsString());
diff --git a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
index 5d326af8c..4e383ec83 100644
--- a/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
+++ b/gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
@@ -33,7 +33,7 @@ public void testIdentity() {
     Gson gson = getGsonWithNamingPolicy(IDENTITY);
     assertEquals("{'lowerCamel':1,'UpperCamel':2,'_lowerCamelLeadingUnderscore':3," +
         "'_UpperCamelLeadingUnderscore':4,'lower_words':5,'UPPER_WORDS':6," +
-        "'annotatedName':7,'lowerId':8}",
+        "'annotatedName':7,'lowerId':8,'_9':9}",
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
@@ -41,7 +41,7 @@ public void testUpperCamelCase() {
     Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE);
     assertEquals("{'LowerCamel':1,'UpperCamel':2,'_LowerCamelLeadingUnderscore':3," +
         "'_UpperCamelLeadingUnderscore':4,'Lower_words':5,'UPPER_WORDS':6," +
-        "'annotatedName':7,'LowerId':8}",
+        "'annotatedName':7,'LowerId':8,'_9':9}",
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
@@ -49,7 +49,7 @@ public void testUpperCamelCaseWithSpaces() {
     Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);
     assertEquals("{'Lower Camel':1,'Upper Camel':2,'_Lower Camel Leading Underscore':3," +
         "'_ Upper Camel Leading Underscore':4,'Lower_words':5,'U P P E R_ W O R D S':6," +
-        "'annotatedName':7,'Lower Id':8}",
+        "'annotatedName':7,'Lower Id':8,'_9':9}",
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
@@ -57,7 +57,7 @@ public void testLowerCaseWithUnderscores() {
     Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_UNDERSCORES);
     assertEquals("{'lower_camel':1,'upper_camel':2,'_lower_camel_leading_underscore':3," +
         "'__upper_camel_leading_underscore':4,'lower_words':5,'u_p_p_e_r__w_o_r_d_s':6," +
-        "'annotatedName':7,'lower_id':8}",
+        "'annotatedName':7,'lower_id':8,'_9':9}",
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
@@ -65,7 +65,7 @@ public void testLowerCaseWithDashes() {
     Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_DASHES);
     assertEquals("{'lower-camel':1,'upper-camel':2,'_lower-camel-leading-underscore':3," +
         "'_-upper-camel-leading-underscore':4,'lower_words':5,'u-p-p-e-r_-w-o-r-d-s':6," +
-        "'annotatedName':7,'lower-id':8}",
+        "'annotatedName':7,'lower-id':8,'_9':9}",
         gson.toJson(new TestNames()).replace('\"', '\''));
   }
 
@@ -85,5 +85,6 @@ private Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){
     int UPPER_WORDS = 6;
     @SerializedName("annotatedName") int annotated = 7;
     int lowerId = 8;
+    int _9 = 9;
   }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonParserTest.java b/gson/src/test/java/com/google/gson/functional/JsonParserTest.java
index 44f4477cb..1da6a6f29 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonParserTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonParserTest.java
@@ -112,7 +112,7 @@ public void testBadFieldTypeForDeserializingCustomTree() {
   public void testChangingCustomTreeAndDeserializing() {
     StringReader json =
       new StringReader("{'stringValue':'no message','intValue':10,'longValue':20}");
-    JsonObject obj = (JsonObject) new JsonParser().parse(json);
+    JsonObject obj = (JsonObject) JsonParser.parseReader(json);
     obj.remove("stringValue");
     obj.addProperty("stringValue", "fooBar");
     BagOfPrimitives target = gson.fromJson(obj, BagOfPrimitives.class);
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index 154ecf558..d3def325b 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -608,7 +608,7 @@ public void testMapNamePromotionWithJsonElementReader() {
     String json = "{'2.3':'a'}";
     Map<Double, String> map = new LinkedHashMap<Double, String>();
     map.put(2.3, "a");
-    JsonElement tree = new JsonParser().parse(json);
+    JsonElement tree = JsonParser.parseString(json);
     assertEquals(map, gson.fromJson(tree, new TypeToken<Map<Double, String>>() {}.getType()));
   }
 
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
index 10624711c..4c4dd8df9 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
@@ -26,7 +26,7 @@
 public final class JsonElementReaderTest extends TestCase {
 
   public void testNumbers() throws IOException {
-    JsonElement element = new JsonParser().parse("[1, 2, 3]");
+    JsonElement element = JsonParser.parseString("[1, 2, 3]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals(1, reader.nextInt());
@@ -36,7 +36,7 @@ public void testNumbers() throws IOException {
   }
 
   public void testLenientNansAndInfinities() throws IOException {
-    JsonElement element = new JsonParser().parse("[NaN, -Infinity, Infinity]");
+    JsonElement element = JsonParser.parseString("[NaN, -Infinity, Infinity]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.setLenient(true);
     reader.beginArray();
@@ -47,7 +47,7 @@ public void testLenientNansAndInfinities() throws IOException {
   }
 
   public void testStrictNansAndInfinities() throws IOException {
-    JsonElement element = new JsonParser().parse("[NaN, -Infinity, Infinity]");
+    JsonElement element = JsonParser.parseString("[NaN, -Infinity, Infinity]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.setLenient(false);
     reader.beginArray();
@@ -73,7 +73,7 @@ public void testStrictNansAndInfinities() throws IOException {
   }
 
   public void testNumbersFromStrings() throws IOException {
-    JsonElement element = new JsonParser().parse("[\"1\", \"2\", \"3\"]");
+    JsonElement element = JsonParser.parseString("[\"1\", \"2\", \"3\"]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals(1, reader.nextInt());
@@ -83,7 +83,7 @@ public void testNumbersFromStrings() throws IOException {
   }
 
   public void testStringsFromNumbers() throws IOException {
-    JsonElement element = new JsonParser().parse("[1]");
+    JsonElement element = JsonParser.parseString("[1]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals("1", reader.nextString());
@@ -91,7 +91,7 @@ public void testStringsFromNumbers() throws IOException {
   }
 
   public void testBooleans() throws IOException {
-    JsonElement element = new JsonParser().parse("[true, false]");
+    JsonElement element = JsonParser.parseString("[true, false]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals(true, reader.nextBoolean());
@@ -100,7 +100,7 @@ public void testBooleans() throws IOException {
   }
 
   public void testNulls() throws IOException {
-    JsonElement element = new JsonParser().parse("[null,null]");
+    JsonElement element = JsonParser.parseString("[null,null]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     reader.nextNull();
@@ -109,7 +109,7 @@ public void testNulls() throws IOException {
   }
 
   public void testStrings() throws IOException {
-    JsonElement element = new JsonParser().parse("[\"A\",\"B\"]");
+    JsonElement element = JsonParser.parseString("[\"A\",\"B\"]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals("A", reader.nextString());
@@ -118,7 +118,7 @@ public void testStrings() throws IOException {
   }
 
   public void testArray() throws IOException {
-    JsonElement element = new JsonParser().parse("[1, 2, 3]");
+    JsonElement element = JsonParser.parseString("[1, 2, 3]");
     JsonTreeReader reader = new JsonTreeReader(element);
     assertEquals(JsonToken.BEGIN_ARRAY, reader.peek());
     reader.beginArray();
@@ -134,7 +134,7 @@ public void testArray() throws IOException {
   }
 
   public void testObject() throws IOException {
-    JsonElement element = new JsonParser().parse("{\"A\": 1, \"B\": 2}");
+    JsonElement element = JsonParser.parseString("{\"A\": 1, \"B\": 2}");
     JsonTreeReader reader = new JsonTreeReader(element);
     assertEquals(JsonToken.BEGIN_OBJECT, reader.peek());
     reader.beginObject();
@@ -152,14 +152,14 @@ public void testObject() throws IOException {
   }
 
   public void testEmptyArray() throws IOException {
-    JsonElement element = new JsonParser().parse("[]");
+    JsonElement element = JsonParser.parseString("[]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     reader.endArray();
   }
 
   public void testNestedArrays() throws IOException {
-    JsonElement element = new JsonParser().parse("[[],[[]]]");
+    JsonElement element = JsonParser.parseString("[[],[[]]]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     reader.beginArray();
@@ -172,7 +172,7 @@ public void testNestedArrays() throws IOException {
   }
 
   public void testNestedObjects() throws IOException {
-    JsonElement element = new JsonParser().parse("{\"A\":{},\"B\":{\"C\":{}}}");
+    JsonElement element = JsonParser.parseString("{\"A\":{},\"B\":{\"C\":{}}}");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginObject();
     assertEquals("A", reader.nextName());
@@ -188,14 +188,14 @@ public void testNestedObjects() throws IOException {
   }
 
   public void testEmptyObject() throws IOException {
-    JsonElement element = new JsonParser().parse("{}");
+    JsonElement element = JsonParser.parseString("{}");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginObject();
     reader.endObject();
   }
 
   public void testSkipValue() throws IOException {
-    JsonElement element = new JsonParser().parse("[\"A\",{\"B\":[[]]},\"C\",[[]],\"D\",null]");
+    JsonElement element = JsonParser.parseString("[\"A\",{\"B\":[[]]},\"C\",[[]],\"D\",null]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     assertEquals("A", reader.nextString());
@@ -208,7 +208,7 @@ public void testSkipValue() throws IOException {
   }
 
   public void testWrongType() throws IOException {
-    JsonElement element = new JsonParser().parse("[[],\"A\"]");
+    JsonElement element = JsonParser.parseString("[[],\"A\"]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     try {
@@ -299,7 +299,7 @@ public void testWrongType() throws IOException {
   }
 
   public void testEarlyClose() throws IOException {
-    JsonElement element = new JsonParser().parse("[1, 2, 3]");
+    JsonElement element = JsonParser.parseString("[1, 2, 3]");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginArray();
     reader.close();
