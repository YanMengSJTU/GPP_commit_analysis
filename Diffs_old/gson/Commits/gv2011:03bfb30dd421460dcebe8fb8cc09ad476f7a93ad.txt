diff --git a/LICENSE b/LICENSE
index 5dedc84e0..c4097ce0f 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Google Gson
+Vinz Jsoncore (based on Google Gson)
 
                                  Apache License
                            Version 2.0, January 2004
diff --git a/src/main/java/com/google/gson/stream/JsonReader.java b/src/main/java/com/github/gv2011/jsoncore/JsonReader.java
similarity index 93%
rename from src/main/java/com/google/gson/stream/JsonReader.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonReader.java
index 7a5e9cbb6..57d81be1e 100644
--- a/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonReader.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,10 +15,8 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.github.gv2011.jsoncore;
 
-import com.google.gson.internal.JsonReaderInternalAccess;
-import com.google.gson.internal.bind.JsonTreeReader;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.IOException;
@@ -286,7 +285,7 @@
   /**
    * Creates a new instance that reads a JSON-encoded stream from {@code in}.
    */
-  public JsonReader(Reader in) {
+  public JsonReader(final Reader in) {
     if (in == null) {
       throw new NullPointerException("in == null");
     }
@@ -322,7 +321,7 @@ public JsonReader(Reader in) {
    *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
    * </ul>
    */
-  public final void setLenient(boolean lenient) {
+  public final void setLenient(final boolean lenient) {
     this.lenient = lenient;
   }
 
@@ -463,12 +462,12 @@ public JsonToken peek() throws IOException {
   }
 
   int doPeek() throws IOException {
-    int peekStack = stack[stackSize - 1];
+    final int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
     } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
       // Look for a comma before the next element.
-      int c = nextNonWhitespace(true);
+      final int c = nextNonWhitespace(true);
       switch (c) {
       case ']':
         return peeked = PEEKED_END_ARRAY;
@@ -483,7 +482,7 @@ int doPeek() throws IOException {
       stack[stackSize - 1] = JsonScope.DANGLING_NAME;
       // Look for a comma before the next element.
       if (peekStack == JsonScope.NONEMPTY_OBJECT) {
-        int c = nextNonWhitespace(true);
+        final int c = nextNonWhitespace(true);
         switch (c) {
         case '}':
           return peeked = PEEKED_END_OBJECT;
@@ -495,7 +494,7 @@ int doPeek() throws IOException {
           throw syntaxError("Unterminated object");
         }
       }
-      int c = nextNonWhitespace(true);
+      final int c = nextNonWhitespace(true);
       switch (c) {
       case '"':
         return peeked = PEEKED_DOUBLE_QUOTED_NAME;
@@ -520,7 +519,7 @@ int doPeek() throws IOException {
     } else if (peekStack == JsonScope.DANGLING_NAME) {
       stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
       // Look for a colon before the value.
-      int c = nextNonWhitespace(true);
+      final int c = nextNonWhitespace(true);
       switch (c) {
       case ':':
         break;
@@ -539,7 +538,7 @@ int doPeek() throws IOException {
       }
       stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
     } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
-      int c = nextNonWhitespace(false);
+      final int c = nextNonWhitespace(false);
       if (c == -1) {
         return peeked = PEEKED_EOF;
       } else {
@@ -550,7 +549,7 @@ int doPeek() throws IOException {
       throw new IllegalStateException("JsonReader is closed");
     }
 
-    int c = nextNonWhitespace(true);
+    final int c = nextNonWhitespace(true);
     switch (c) {
     case ']':
       if (peekStack == JsonScope.EMPTY_ARRAY) {
@@ -621,7 +620,7 @@ private int peekKeyword() throws IOException {
     }
 
     // Confirm that chars [1..length) match the keyword.
-    int length = keyword.length();
+    final int length = keyword.length();
     for (int i = 1; i < length; i++) {
       if (pos + i >= limit && !fillBuffer(i + 1)) {
         return PEEKED_NONE;
@@ -644,7 +643,7 @@ private int peekKeyword() throws IOException {
 
   private int peekNumber() throws IOException {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
+    final char[] buffer = this.buffer;
     int p = pos;
     int l = limit;
 
@@ -670,7 +669,7 @@ private int peekNumber() throws IOException {
         l = limit;
       }
 
-      char c = buffer[p + i];
+      final char c = buffer[p + i];
       switch (c) {
       case '-':
         if (last == NUMBER_CHAR_NONE) {
@@ -719,7 +718,7 @@ private int peekNumber() throws IOException {
           if (value == 0) {
             return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
           }
-          long newValue = value * 10 - (c - '0');
+          final long newValue = value * 10 - (c - '0');
           fitsInLong &= value > MIN_INCOMPLETE_INTEGER
               || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
           value = newValue;
@@ -745,7 +744,7 @@ private int peekNumber() throws IOException {
     }
   }
 
-  private boolean isLiteral(char c) throws IOException {
+  private boolean isLiteral(final char c) throws IOException {
     switch (c) {
     case '/':
     case '\\':
@@ -771,7 +770,7 @@ private boolean isLiteral(char c) throws IOException {
   }
 
   /**
-   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and
+   * Returns the next token, a {@link com.github.gv2011.jsoncore.JsonToken#NAME property name}, and
    * consumes it.
    *
    * @throws java.io.IOException if the next token in the stream is not a property
@@ -799,7 +798,7 @@ public String nextName() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
+   * Returns the {@link com.github.gv2011.jsoncore.JsonToken#STRING string} value of the next token,
    * consuming it. If the next token is a number, this method will return its
    * string form.
    *
@@ -836,7 +835,7 @@ public String nextString() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
+   * Returns the {@link com.github.gv2011.jsoncore.JsonToken#BOOLEAN boolean} value of the next token,
    * consuming it.
    *
    * @throws IllegalStateException if the next token is not a boolean or if
@@ -882,7 +881,7 @@ public void nextNull() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
+   * Returns the {@link com.github.gv2011.jsoncore.JsonToken#NUMBER double} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as a double using {@link Double#parseDouble(String)}.
    *
@@ -915,7 +914,7 @@ public double nextDouble() throws IOException {
     }
 
     peeked = PEEKED_BUFFERED;
-    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    final double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
       throw new MalformedJsonException("JSON forbids NaN and infinities: " + result
           + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
@@ -927,7 +926,7 @@ public double nextDouble() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
+   * Returns the {@link com.github.gv2011.jsoncore.JsonToken#NUMBER long} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as a long. If the next token's numeric value cannot be exactly
    * represented by a Java {@code long}, this method throws.
@@ -958,11 +957,11 @@ public long nextLong() throws IOException {
         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
       }
       try {
-        long result = Long.parseLong(peekedString);
+        final long result = Long.parseLong(peekedString);
         peeked = PEEKED_NONE;
         pathIndices[stackSize - 1]++;
         return result;
-      } catch (NumberFormatException ignored) {
+      } catch (final NumberFormatException ignored) {
         // Fall back to parse as a double below.
       }
     } else {
@@ -971,8 +970,8 @@ public long nextLong() throws IOException {
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
-    long result = (long) asDouble;
+    final double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    final long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
       throw new NumberFormatException("Expected a long but was " + peekedString
           + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
@@ -993,17 +992,17 @@ public long nextLong() throws IOException {
    * @throws NumberFormatException if any unicode escape sequences are
    *     malformed.
    */
-  private String nextQuotedValue(char quote) throws IOException {
+  private String nextQuotedValue(final char quote) throws IOException {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
-    StringBuilder builder = new StringBuilder();
+    final char[] buffer = this.buffer;
+    final StringBuilder builder = new StringBuilder();
     while (true) {
       int p = pos;
       int l = limit;
       /* the index of the first character not yet appended to the builder. */
       int start = p;
       while (p < l) {
-        int c = buffer[p++];
+        final int c = buffer[p++];
 
         if (c == quote) {
           pos = p;
@@ -1095,15 +1094,15 @@ private String nextUnquotedValue() throws IOException {
     return result;
   }
 
-  private void skipQuotedValue(char quote) throws IOException {
+  private void skipQuotedValue(final char quote) throws IOException {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
-    char[] buffer = this.buffer;
+    final char[] buffer = this.buffer;
     do {
       int p = pos;
       int l = limit;
       /* the index of the first character not yet appended to the builder. */
       while (p < l) {
-        int c = buffer[p++];
+        final int c = buffer[p++];
         if (c == quote) {
           pos = p;
           return;
@@ -1153,7 +1152,7 @@ private void skipUnquotedValue() throws IOException {
   }
 
   /**
-   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
+   * Returns the {@link com.github.gv2011.jsoncore.JsonToken#NUMBER int} value of the next token,
    * consuming it. If the next token is a string, this method will attempt to
    * parse it as an int. If the next token's numeric value cannot be exactly
    * represented by a Java {@code int}, this method throws.
@@ -1194,7 +1193,7 @@ public int nextInt() throws IOException {
         peeked = PEEKED_NONE;
         pathIndices[stackSize - 1]++;
         return result;
-      } catch (NumberFormatException ignored) {
+      } catch (final NumberFormatException ignored) {
         // Fall back to parse as a double below.
       }
     } else {
@@ -1203,7 +1202,7 @@ public int nextInt() throws IOException {
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    final double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
       throw new NumberFormatException("Expected an int but was " + peekedString
@@ -1218,6 +1217,7 @@ public int nextInt() throws IOException {
   /**
    * Closes this JSON reader and the underlying {@link java.io.Reader}.
    */
+  @Override
   public void close() throws IOException {
     peeked = PEEKED_NONE;
     stack[0] = JsonScope.CLOSED;
@@ -1266,11 +1266,11 @@ public void skipValue() throws IOException {
     pathNames[stackSize - 1] = "null";
   }
 
-  private void push(int newTop) {
+  private void push(final int newTop) {
     if (stackSize == stack.length) {
-      int[] newStack = new int[stackSize * 2];
-      int[] newPathIndices = new int[stackSize * 2];
-      String[] newPathNames = new String[stackSize * 2];
+      final int[] newStack = new int[stackSize * 2];
+      final int[] newPathIndices = new int[stackSize * 2];
+      final String[] newPathNames = new String[stackSize * 2];
       System.arraycopy(stack, 0, newStack, 0, stackSize);
       System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
       System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
@@ -1287,7 +1287,7 @@ private void push(int newTop) {
    * false.
    */
   private boolean fillBuffer(int minimum) throws IOException {
-    char[] buffer = this.buffer;
+    final char[] buffer = this.buffer;
     lineStart -= pos;
     if (limit != pos) {
       limit -= pos;
@@ -1329,7 +1329,7 @@ int getColumnNumber() {
    * {@code buffer[pos-1]}; this means the caller can always push back the
    * returned character by decrementing {@code pos}.
    */
-  private int nextNonWhitespace(boolean throwOnEof) throws IOException {
+  private int nextNonWhitespace(final boolean throwOnEof) throws IOException {
     /*
      * This code uses ugly local variables 'p' and 'l' representing the 'pos'
      * and 'limit' fields respectively. Using locals rather than fields saves
@@ -1338,7 +1338,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
      * before any (potentially indirect) call to fillBuffer() and reread both
      * 'p' and 'l' after any (potentially indirect) call to the same method.
      */
-    char[] buffer = this.buffer;
+    final char[] buffer = this.buffer;
     int p = pos;
     int l = limit;
     while (true) {
@@ -1351,7 +1351,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
         l = limit;
       }
 
-      int c = buffer[p++];
+      final int c = buffer[p++];
       if (c == '\n') {
         lineNumber++;
         lineStart = p;
@@ -1364,7 +1364,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
         pos = p;
         if (p == l) {
           pos--; // push back '/' so it's still in the buffer when this method returns
-          boolean charsLoaded = fillBuffer(2);
+          final boolean charsLoaded = fillBuffer(2);
           pos++; // consume the '/' again
           if (!charsLoaded) {
             return c;
@@ -1372,7 +1372,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
         }
 
         checkLenient();
-        char peek = buffer[pos];
+        final char peek = buffer[pos];
         switch (peek) {
         case '*':
           // skip a /* c-style comment */
@@ -1432,7 +1432,7 @@ private void checkLenient() throws IOException {
    */
   private void skipToEndOfLine() throws IOException {
     while (pos < limit || fillBuffer(1)) {
-      char c = buffer[pos++];
+      final char c = buffer[pos++];
       if (c == '\n') {
         lineNumber++;
         lineStart = pos;
@@ -1446,7 +1446,7 @@ private void skipToEndOfLine() throws IOException {
   /**
    * @param toFind a string to search for. Must not contain a newline.
    */
-  private boolean skipTo(String toFind) throws IOException {
+  private boolean skipTo(final String toFind) throws IOException {
     outer:
     for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
       if (buffer[pos] == '\n') {
@@ -1474,7 +1474,7 @@ private boolean skipTo(String toFind) throws IOException {
    * the current location in the JSON value.
    */
   public String getPath() {
-    StringBuilder result = new StringBuilder().append('$');
+    final StringBuilder result = new StringBuilder().append('$');
     for (int i = 0, size = stackSize; i < size; i++) {
       switch (stack[i]) {
         case JsonScope.EMPTY_ARRAY:
@@ -1514,7 +1514,7 @@ private char readEscapeCharacter() throws IOException {
       throw syntaxError("Unterminated escape sequence");
     }
 
-    char escaped = buffer[pos++];
+    final char escaped = buffer[pos++];
     switch (escaped) {
     case 'u':
       if (pos + 4 > limit && !fillBuffer(4)) {
@@ -1523,7 +1523,7 @@ private char readEscapeCharacter() throws IOException {
       // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
       char result = 0;
       for (int i = pos, end = i + 4; i < end; i++) {
-        char c = buffer[i];
+        final char c = buffer[i];
         result <<= 4;
         if (c >= '0' && c <= '9') {
           result += (c - '0');
@@ -1570,7 +1570,7 @@ private char readEscapeCharacter() throws IOException {
    * Throws a new IO exception with the given message and a context snippet
    * with this reader's content.
    */
-  private IOException syntaxError(String message) throws IOException {
+  private IOException syntaxError(final String message) throws IOException {
     throw new MalformedJsonException(message
         + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
   }
@@ -1599,7 +1599,7 @@ private void consumeNonExecutePrefix() throws IOException {
 
   static {
     JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {
-      @Override public void promoteNameToValue(JsonReader reader) throws IOException {
+      @Override public void promoteNameToValue(final JsonReader reader) throws IOException {
         if (reader instanceof JsonTreeReader) {
           ((JsonTreeReader)reader).promoteNameToValue();
           return;
diff --git a/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java b/src/main/java/com/github/gv2011/jsoncore/JsonReaderInternalAccess.java
similarity index 92%
rename from src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonReaderInternalAccess.java
index bbd472040..9eecafc0f 100644
--- a/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonReaderInternalAccess.java
@@ -14,9 +14,8 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal;
+package com.github.gv2011.jsoncore;
 
-import com.google.gson.stream.JsonReader;
 import java.io.IOException;
 
 /**
diff --git a/src/main/java/com/google/gson/stream/JsonScope.java b/src/main/java/com/github/gv2011/jsoncore/JsonScope.java
similarity index 95%
rename from src/main/java/com/google/gson/stream/JsonScope.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonScope.java
index da6913727..9f3d17f5c 100644
--- a/src/main/java/com/google/gson/stream/JsonScope.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonScope.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.github.gv2011.jsoncore;
 
 /**
  * Lexical scoping elements within a JSON reader or writer.
diff --git a/src/main/java/com/google/gson/stream/JsonToken.java b/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
similarity index 98%
rename from src/main/java/com/google/gson/stream/JsonToken.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonToken.java
index f1025b3f4..ec1d9ec5a 100644
--- a/src/main/java/com/google/gson/stream/JsonToken.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonToken.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.github.gv2011.jsoncore;
 
 /**
  * A structure, name or value type in a JSON-encoded string.
diff --git a/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/src/main/java/com/github/gv2011/jsoncore/JsonTreeReader.java
similarity index 98%
rename from src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonTreeReader.java
index 6a8362805..eef7c9895 100644
--- a/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonTreeReader.java
@@ -14,15 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.bind;
+package com.github.gv2011.jsoncore;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
+
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
diff --git a/src/main/java/com/google/gson/stream/JsonWriter.java b/src/main/java/com/github/gv2011/jsoncore/JsonWriter.java
similarity index 88%
rename from src/main/java/com/google/gson/stream/JsonWriter.java
rename to src/main/java/com/github/gv2011/jsoncore/JsonWriter.java
index e2fc19611..8bd101715 100644
--- a/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/src/main/java/com/github/gv2011/jsoncore/JsonWriter.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2016 Vinz (https://github.com/gv2011)
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,21 +15,21 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.github.gv2011.jsoncore;
+
+import static com.github.gv2011.jsoncore.JsonScope.DANGLING_NAME;
+import static com.github.gv2011.jsoncore.JsonScope.EMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.JsonScope.EMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.JsonScope.EMPTY_OBJECT;
+import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_ARRAY;
+import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_DOCUMENT;
+import static com.github.gv2011.jsoncore.JsonScope.NONEMPTY_OBJECT;
 
 import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
 
-import static com.google.gson.stream.JsonScope.DANGLING_NAME;
-import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;
-import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;
-import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;
-import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;
-import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;
-import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;
-
 /**
  * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
  * encoded value to a stream, one token at a time. The stream includes both
@@ -194,7 +195,7 @@
    * For best performance, ensure {@link Writer} is buffered; wrapping in
    * {@link java.io.BufferedWriter BufferedWriter} if necessary.
    */
-  public JsonWriter(Writer out) {
+  public JsonWriter(final Writer out) {
     if (out == null) {
       throw new NullPointerException("out == null");
     }
@@ -209,13 +210,13 @@ public JsonWriter(Writer out) {
    *
    * @param indent a string containing only whitespace.
    */
-  public final void setIndent(String indent) {
+  public final void setIndent(final String indent) {
     if (indent.length() == 0) {
       this.indent = null;
-      this.separator = ":";
+      separator = ":";
     } else {
       this.indent = indent;
-      this.separator = ": ";
+      separator = ": ";
     }
   }
 
@@ -231,7 +232,7 @@ public final void setIndent(String indent) {
    *       Double#isInfinite() infinities}.
    * </ul>
    */
-  public final void setLenient(boolean lenient) {
+  public final void setLenient(final boolean lenient) {
     this.lenient = lenient;
   }
 
@@ -249,7 +250,7 @@ public boolean isLenient() {
    * setting, your XML/HTML encoder should replace these characters with the
    * corresponding escape sequences.
    */
-  public final void setHtmlSafe(boolean htmlSafe) {
+  public final void setHtmlSafe(final boolean htmlSafe) {
     this.htmlSafe = htmlSafe;
   }
 
@@ -265,7 +266,7 @@ public final boolean isHtmlSafe() {
    * Sets whether object members are serialized when their value is null.
    * This has no impact on array elements. The default is true.
    */
-  public final void setSerializeNulls(boolean serializeNulls) {
+  public final void setSerializeNulls(final boolean serializeNulls) {
     this.serializeNulls = serializeNulls;
   }
 
@@ -321,7 +322,7 @@ public JsonWriter endObject() throws IOException {
    * Enters a new scope by appending any necessary whitespace and the given
    * bracket.
    */
-  private JsonWriter open(int empty, String openBracket) throws IOException {
+  private JsonWriter open(final int empty, final String openBracket) throws IOException {
     beforeValue();
     push(empty);
     out.write(openBracket);
@@ -332,9 +333,9 @@ private JsonWriter open(int empty, String openBracket) throws IOException {
    * Closes the current scope by appending any necessary whitespace and the
    * given bracket.
    */
-  private JsonWriter close(int empty, int nonempty, String closeBracket)
+  private JsonWriter close(final int empty, final int nonempty, final String closeBracket)
       throws IOException {
-    int context = peek();
+    final int context = peek();
     if (context != nonempty && context != empty) {
       throw new IllegalStateException("Nesting problem.");
     }
@@ -350,9 +351,9 @@ private JsonWriter close(int empty, int nonempty, String closeBracket)
     return this;
   }
 
-  private void push(int newTop) {
+  private void push(final int newTop) {
     if (stackSize == stack.length) {
-      int[] newStack = new int[stackSize * 2];
+      final int[] newStack = new int[stackSize * 2];
       System.arraycopy(stack, 0, newStack, 0, stackSize);
       stack = newStack;
     }
@@ -372,7 +373,7 @@ private int peek() {
   /**
    * Replace the value on the top of the stack with the given value.
    */
-  private void replaceTop(int topOfStack) {
+  private void replaceTop(final int topOfStack) {
     stack[stackSize - 1] = topOfStack;
   }
 
@@ -382,7 +383,7 @@ private void replaceTop(int topOfStack) {
    * @param name the name of the forthcoming value. May not be null.
    * @return this writer.
    */
-  public JsonWriter name(String name) throws IOException {
+  public JsonWriter name(final String name) throws IOException {
     if (name == null) {
       throw new NullPointerException("name == null");
     }
@@ -410,7 +411,7 @@ private void writeDeferredName() throws IOException {
    * @param value the literal string value, or null to encode a null literal.
    * @return this writer.
    */
-  public JsonWriter value(String value) throws IOException {
+  public JsonWriter value(final String value) throws IOException {
     if (value == null) {
       return nullValue();
     }
@@ -427,7 +428,7 @@ public JsonWriter value(String value) throws IOException {
    * @param value the literal string value, or null to encode a null literal.
    * @return this writer.
    */
-  public JsonWriter jsonValue(String value) throws IOException {
+  public JsonWriter jsonValue(final String value) throws IOException {
     if (value == null) {
       return nullValue();
     }
@@ -461,7 +462,7 @@ public JsonWriter nullValue() throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(boolean value) throws IOException {
+  public JsonWriter value(final boolean value) throws IOException {
     writeDeferredName();
     beforeValue();
     out.write(value ? "true" : "false");
@@ -473,7 +474,7 @@ public JsonWriter value(boolean value) throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(Boolean value) throws IOException {
+  public JsonWriter value(final Boolean value) throws IOException {
     if (value == null) {
       return nullValue();
     }
@@ -490,7 +491,7 @@ public JsonWriter value(Boolean value) throws IOException {
    *     {@link Double#isInfinite() infinities}.
    * @return this writer.
    */
-  public JsonWriter value(double value) throws IOException {
+  public JsonWriter value(final double value) throws IOException {
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
@@ -505,7 +506,7 @@ public JsonWriter value(double value) throws IOException {
    *
    * @return this writer.
    */
-  public JsonWriter value(long value) throws IOException {
+  public JsonWriter value(final long value) throws IOException {
     writeDeferredName();
     beforeValue();
     out.write(Long.toString(value));
@@ -519,13 +520,13 @@ public JsonWriter value(long value) throws IOException {
    *     {@link Double#isInfinite() infinities}.
    * @return this writer.
    */
-  public JsonWriter value(Number value) throws IOException {
+  public JsonWriter value(final Number value) throws IOException {
     if (value == null) {
       return nullValue();
     }
 
     writeDeferredName();
-    String string = value.toString();
+    final String string = value.toString();
     if (!lenient
         && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
@@ -539,6 +540,7 @@ public JsonWriter value(Number value) throws IOException {
    * Ensures all buffered data is written to the underlying {@link Writer}
    * and flushes that writer.
    */
+  @Override
   public void flush() throws IOException {
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
@@ -551,23 +553,24 @@ public void flush() throws IOException {
    *
    * @throws IOException if the JSON document is incomplete.
    */
+  @Override
   public void close() throws IOException {
     out.close();
 
-    int size = stackSize;
+    final int size = stackSize;
     if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
       throw new IOException("Incomplete document");
     }
     stackSize = 0;
   }
 
-  private void string(String value) throws IOException {
-    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
+  private void string(final String value) throws IOException {
+    final String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
     out.write("\"");
     int last = 0;
-    int length = value.length();
+    final int length = value.length();
     for (int i = 0; i < length; i++) {
-      char c = value.charAt(i);
+      final char c = value.charAt(i);
       String replacement;
       if (c < 128) {
         replacement = replacements[c];
@@ -609,7 +612,7 @@ private void newline() throws IOException {
    * adjusts the stack to expect the name's value.
    */
   private void beforeName() throws IOException {
-    int context = peek();
+    final int context = peek();
     if (context == NONEMPTY_OBJECT) { // first in object
       out.write(',');
     } else if (context != EMPTY_OBJECT) { // not in an object!
diff --git a/src/main/java/com/google/gson/stream/MalformedJsonException.java b/src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java
similarity index 97%
rename from src/main/java/com/google/gson/stream/MalformedJsonException.java
rename to src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java
index 9da70ebcc..e05a2c74b 100644
--- a/src/main/java/com/google/gson/stream/MalformedJsonException.java
+++ b/src/main/java/com/github/gv2011/jsoncore/MalformedJsonException.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.stream;
+package com.github.gv2011.jsoncore;
 
 import java.io.IOException;
 
diff --git a/src/main/java/com/google/gson/Gson.java b/src/main/java/com/google/gson/Gson.java
index 9fbf44a5d..3c3075bc9 100644
--- a/src/main/java/com/google/gson/Gson.java
+++ b/src/main/java/com/google/gson/Gson.java
@@ -34,6 +34,11 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongArray;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonTreeReader;
+import com.github.gv2011.jsoncore.JsonWriter;
+import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -42,7 +47,6 @@
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
 import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
-import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.MapTypeAdapterFactory;
 import com.google.gson.internal.bind.ObjectTypeAdapter;
@@ -51,10 +55,6 @@
 import com.google.gson.internal.bind.TimeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import com.google.gson.stream.MalformedJsonException;
 
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
diff --git a/src/main/java/com/google/gson/GsonBuilder.java b/src/main/java/com/google/gson/GsonBuilder.java
index 0c917d46f..7d7f2d9ae 100644
--- a/src/main/java/com/google/gson/GsonBuilder.java
+++ b/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.stream.JsonReader;
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -27,6 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
+import com.github.gv2011.jsoncore.JsonReader;
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.bind.TreeTypeAdapter;
diff --git a/src/main/java/com/google/gson/JsonElement.java b/src/main/java/com/google/gson/JsonElement.java
index d9cd91846..8342318b1 100644
--- a/src/main/java/com/google/gson/JsonElement.java
+++ b/src/main/java/com/google/gson/JsonElement.java
@@ -16,8 +16,9 @@
 
 package com.google.gson;
 
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.StringWriter;
 import java.math.BigDecimal;
diff --git a/src/main/java/com/google/gson/JsonParser.java b/src/main/java/com/google/gson/JsonParser.java
index a8ae337ba..3970bebf9 100755
--- a/src/main/java/com/google/gson/JsonParser.java
+++ b/src/main/java/com/google/gson/JsonParser.java
@@ -19,10 +19,10 @@
 import java.io.Reader;
 import java.io.StringReader;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.MalformedJsonException;
 
 /**
  * A parser to parse Json into a parse tree of {@link JsonElement}s
diff --git a/src/main/java/com/google/gson/JsonStreamParser.java b/src/main/java/com/google/gson/JsonStreamParser.java
index f0438db32..4e0134019 100644
--- a/src/main/java/com/google/gson/JsonStreamParser.java
+++ b/src/main/java/com/google/gson/JsonStreamParser.java
@@ -22,10 +22,10 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.MalformedJsonException;
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
diff --git a/src/main/java/com/google/gson/TypeAdapter.java b/src/main/java/com/google/gson/TypeAdapter.java
index 4646d271d..3920facc3 100644
--- a/src/main/java/com/google/gson/TypeAdapter.java
+++ b/src/main/java/com/google/gson/TypeAdapter.java
@@ -17,10 +17,11 @@
 package com.google.gson;
 
 import com.google.gson.internal.bind.JsonTreeWriter;
-import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonTreeReader;
+import com.github.gv2011.jsoncore.JsonWriter;
+
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
@@ -131,7 +132,7 @@
    * Unlike Gson's similar {@link Gson#toJson(JsonElement, Appendable) toJson}
    * method, this write is strict. Create a {@link
    * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
+   * {@link #write(com.github.gv2011.jsoncore.JsonWriter, Object)} for lenient
    * writing.
    *
    * @param value the Java object to convert. May be null.
@@ -205,7 +206,7 @@ public final void toJson(Writer out, T value) throws IOException {
    * Converts {@code value} to a JSON document. Unlike Gson's similar {@link
    * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link
    * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call
-   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient
+   * {@link #write(com.github.gv2011.jsoncore.JsonWriter, Object)} for lenient
    * writing.
    *
    * @param value the Java object to convert. May be null.
diff --git a/src/main/java/com/google/gson/annotations/Expose.java b/src/main/java/com/google/gson/annotations/Expose.java
deleted file mode 100644
index 1b9c70df0..000000000
--- a/src/main/java/com/google/gson/annotations/Expose.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.annotations;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation that indicates this member should be exposed for JSON
- * serialization or deserialization.
- *
- * <p>This annotation has no effect unless you build {@link com.google.gson.Gson}
- * with a {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#excludeFieldsWithoutExposeAnnotation()}
- * method.</p>
- *
- * <p>Here is an example of how this annotation is meant to be used:
- * <p><pre>
- * public class User {
- *   &#64Expose private String firstName;
- *   &#64Expose(serialize = false) private String lastName;
- *   &#64Expose (serialize = false, deserialize = false) private String emailAddress;
- *   private String password;
- * }
- * </pre></p>
- * If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
- * methods will use the {@code password} field along-with {@code firstName}, {@code lastName},
- * and {@code emailAddress} for serialization and deserialization. However, if you created Gson
- * with {@code Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()}
- * then the {@code toJson()} and {@code fromJson()} methods of Gson will exclude the
- * {@code password} field. This is because the {@code password} field is not marked with the
- * {@code @Expose} annotation. Gson will also exclude {@code lastName} and {@code emailAddress}
- * from serialization since {@code serialize} is set to {@code false}. Similarly, Gson will
- * exclude {@code emailAddress} from deserialization since {@code deserialize} is set to false.
- *
- * <p>Note that another way to achieve the same effect would have been to just mark the
- * {@code password} field as {@code transient}, and Gson would have excluded it even with default
- * settings. The {@code @Expose} annotation is useful in a style of programming where you want to
- * explicitly specify all fields that should get considered for serialization or deserialization.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.FIELD)
-public @interface Expose {
-  
-  /**
-   * If {@code true}, the field marked with this annotation is written out in the JSON while
-   * serializing. If {@code false}, the field marked with this annotation is skipped from the
-   * serialized output. Defaults to {@code true}.
-   * @since 1.4
-   */
-  public boolean serialize() default true;
-
-  /**
-   * If {@code true}, the field marked with this annotation is deserialized from the JSON.
-   * If {@code false}, the field marked with this annotation is skipped during deserialization. 
-   * Defaults to {@code true}.
-   * @since 1.4
-   */
-  public boolean deserialize() default true;
-}
diff --git a/src/main/java/com/google/gson/annotations/JsonAdapter.java b/src/main/java/com/google/gson/annotations/JsonAdapter.java
deleted file mode 100644
index 2ee3e682d..000000000
--- a/src/main/java/com/google/gson/annotations/JsonAdapter.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2014 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.annotations;
-
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation that indicates the Gson {@link TypeAdapter} to use with a class
- * or field.
- *
- * <p>Here is an example of how this annotation is used:</p>
- * <pre>
- * &#64JsonAdapter(UserJsonAdapter.class)
- * public class User {
- *   public final String firstName, lastName;
- *   private User(String firstName, String lastName) {
- *     this.firstName = firstName;
- *     this.lastName = lastName;
- *   }
- * }
- * public class UserJsonAdapter extends TypeAdapter&lt;User&gt; {
- *   &#64Override public void write(JsonWriter out, User user) throws IOException {
- *     // implement write: combine firstName and lastName into name
- *     out.beginObject();
- *     out.name("name");
- *     out.value(user.firstName + " " + user.lastName);
- *     out.endObject();
- *     // implement the write method
- *   }
- *   &#64Override public User read(JsonReader in) throws IOException {
- *     // implement read: split name into firstName and lastName
- *     in.beginObject();
- *     in.nextName();
- *     String[] nameParts = in.nextString().split(" ");
- *     in.endObject();
- *     return new User(nameParts[0], nameParts[1]);
- *   }
- * }
- * </pre>
- *
- * Since User class specified UserJsonAdapter.class in &#64JsonAdapter annotation, it
- * will automatically be invoked to serialize/deserialize User instances. <br>
- *
- * <p> Here is an example of how to apply this annotation to a field.
- * <pre>
- * private static final class Gadget {
- *   &#64JsonAdapter(UserJsonAdapter2.class)
- *   final User user;
- *   Gadget(User user) {
- *     this.user = user;
- *   }
- * }
- * </pre>
- *
- * It's possible to specify different type adapters on a field, that
- * field's type, and in the {@link com.google.gson.GsonBuilder}. Field
- * annotations take precedence over {@code GsonBuilder}-registered type
- * adapters, which in turn take precedence over annotated types.
- *
- * <p>The class referenced by this annotation must be either a {@link
- * TypeAdapter} or a {@link TypeAdapterFactory}. Using the factory interface
- * makes it possible to delegate to the enclosing {@code Gson} instance.
- *
- * @since 2.3
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @author Jesse Wilson
- */
-// Note that the above example is taken from AdaptAnnotationTest.
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.TYPE, ElementType.FIELD})
-public @interface JsonAdapter {
-
-  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
-  Class<?> value();
-
-}
diff --git a/src/main/java/com/google/gson/annotations/SerializedName.java b/src/main/java/com/google/gson/annotations/SerializedName.java
deleted file mode 100644
index 363b95a35..000000000
--- a/src/main/java/com/google/gson/annotations/SerializedName.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.annotations;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation that indicates this member should be serialized to JSON with
- * the provided name value as its field name.
- *
- * <p>This annotation will override any {@link com.google.gson.FieldNamingPolicy}, including
- * the default field naming policy, that may have been set on the {@link com.google.gson.Gson}
- * instance.  A different naming policy can set using the {@code GsonBuilder} class.  See
- * {@link com.google.gson.GsonBuilder#setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)}
- * for more information.</p>
- *
- * <p>Here is an example of how this annotation is meant to be used:</p>
- * <pre>
- * public class MyClass {
- *   &#64SerializedName("name") String a;
- *   &#64SerializedName(value="name1", alternate={"name2", "name3"}) String b;
- *   String c;
- *
- *   public MyClass(String a, String b, String c) {
- *     this.a = a;
- *     this.b = b;
- *     this.c = c;
- *   }
- * }
- * </pre>
- *
- * <p>The following shows the output that is generated when serializing an instance of the
- * above example class:</p>
- * <pre>
- * MyClass target = new MyClass("v1", "v2", "v3");
- * Gson gson = new Gson();
- * String json = gson.toJson(target);
- * System.out.println(json);
- *
- * ===== OUTPUT =====
- * {"name":"v1","name1":"v2","c":"v3"}
- * </pre>
- *
- * <p>NOTE: The value you specify in this annotation must be a valid JSON field name.</p>
- * While deserializing, all values specified in the annotation will be deserialized into the field.
- * For example:
- * <pre>
- *   MyClass target = gson.fromJson("{'name1':'v1'}", MyClass.class);
- *   assertEquals("v1", target.b);
- *   target = gson.fromJson("{'name2':'v2'}", MyClass.class);
- *   assertEquals("v2", target.b);
- *   target = gson.fromJson("{'name3':'v3'}", MyClass.class);
- *   assertEquals("v3", target.b);
- * </pre>
- * Note that MyClass.b is now deserialized from either name1, name2 or name3.
- *
- * @see com.google.gson.FieldNamingPolicy
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD, ElementType.METHOD})
-public @interface SerializedName {
-
-  /**
-   * @return the desired name of the field when it is serialized or deserialized
-   */
-  String value();
-  /**
-   * @return the alternative names of the field when it is deserialized
-   */
-  String[] alternate() default {};
-}
diff --git a/src/main/java/com/google/gson/annotations/Since.java b/src/main/java/com/google/gson/annotations/Since.java
deleted file mode 100644
index 541f154b6..000000000
--- a/src/main/java/com/google/gson/annotations/Since.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.annotations;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation that indicates the version number since a member or a type has been present.
- * This annotation is useful to manage versioning of your Json classes for a web-service.
- *
- * <p>
- * This annotation has no effect unless you build {@link com.google.gson.Gson} with a
- * {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#setVersion(double)} method.
- *
- * <p>Here is an example of how this annotation is meant to be used:</p>
- * <pre>
- * public class User {
- *   private String firstName;
- *   private String lastName;
- *   &#64Since(1.0) private String emailAddress;
- *   &#64Since(1.0) private String password;
- *   &#64Since(1.1) private Address address;
- * }
- * </pre>
- *
- * <p>If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
- * methods will use all the fields for serialization and deserialization. However, if you created
- * Gson with {@code Gson gson = new GsonBuilder().setVersion(1.0).create()} then the
- * {@code toJson()} and {@code fromJson()} methods of Gson will exclude the {@code address} field
- * since it's version number is set to {@code 1.1}.</p>
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD, ElementType.TYPE})
-public @interface Since {
-  /**
-   * the value indicating a version number since this member
-   * or type has been present.
-   */
-  double value();
-}
diff --git a/src/main/java/com/google/gson/annotations/Until.java b/src/main/java/com/google/gson/annotations/Until.java
deleted file mode 100644
index 4648b8a2a..000000000
--- a/src/main/java/com/google/gson/annotations/Until.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.annotations;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation that indicates the version number until a member or a type should be present.
- * Basically, if Gson is created with a version number that exceeds the value stored in the
- * {@code Until} annotation then the field will be ignored from the JSON output.  This annotation
- * is useful to manage versioning of your JSON classes for a web-service.
- *
- * <p>
- * This annotation has no effect unless you build {@link com.google.gson.Gson} with a
- * {@link com.google.gson.GsonBuilder} and invoke
- * {@link com.google.gson.GsonBuilder#setVersion(double)} method.
- *
- * <p>Here is an example of how this annotation is meant to be used:</p>
- * <pre>
- * public class User {
- *   private String firstName;
- *   private String lastName;
- *   &#64Until(1.1) private String emailAddress;
- *   &#64Until(1.1) private String password;
- * }
- * </pre>
- *
- * <p>If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
- * methods will use all the fields for serialization and deserialization. However, if you created
- * Gson with {@code Gson gson = new GsonBuilder().setVersion(1.2).create()} then the
- * {@code toJson()} and {@code fromJson()} methods of Gson will exclude the {@code emailAddress}
- * and {@code password} fields from the example above, because the version number passed to the 
- * GsonBuilder, {@code 1.2}, exceeds the version number set on the {@code Until} annotation,
- * {@code 1.1}, for those fields.
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- * @since 1.3
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.FIELD, ElementType.TYPE})
-public @interface Until {
-
-  /**
-   * the value indicating a version number until this member
-   * or type should be ignored.
-   */
-  double value();
-}
diff --git a/src/main/java/com/google/gson/annotations/package-info.java b/src/main/java/com/google/gson/annotations/package-info.java
deleted file mode 100644
index 1c461fd68..000000000
--- a/src/main/java/com/google/gson/annotations/package-info.java
+++ /dev/null
@@ -1,6 +0,0 @@
-/**
- * This package provides annotations that can be used with {@link com.google.gson.Gson}.
- * 
- * @author Inderjeet Singh, Joel Leitch
- */
-package com.google.gson.annotations;
\ No newline at end of file
diff --git a/src/main/java/com/google/gson/internal/Excluder.java b/src/main/java/com/google/gson/internal/Excluder.java
index bef790406..1356fc064 100644
--- a/src/main/java/com/google/gson/internal/Excluder.java
+++ b/src/main/java/com/google/gson/internal/Excluder.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.internal;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.ExclusionStrategy;
 import com.google.gson.FieldAttributes;
 import com.google.gson.Gson;
@@ -25,8 +27,7 @@
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
diff --git a/src/main/java/com/google/gson/internal/Streams.java b/src/main/java/com/google/gson/internal/Streams.java
index 74956d777..a644c2bf6 100644
--- a/src/main/java/com/google/gson/internal/Streams.java
+++ b/src/main/java/com/google/gson/internal/Streams.java
@@ -16,15 +16,16 @@
 
 package com.google.gson.internal;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
+import com.github.gv2011.jsoncore.MalformedJsonException;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonIOException;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-import com.google.gson.stream.MalformedJsonException;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Writer;
diff --git a/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
index 3fb7c0568..853abd6d6 100644
--- a/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
@@ -23,14 +23,14 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 
 /**
  * Adapt an array of objects.
diff --git a/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
index 1d57844a4..1f4929d50 100644
--- a/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
+++ b/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
@@ -16,6 +16,9 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
@@ -23,9 +26,7 @@
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.Collection;
diff --git a/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
index 561af1985..06eaaf23a 100644
--- a/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
@@ -16,15 +16,16 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
diff --git a/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java b/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
index 51dc1f3a3..c7dd2fac0 100644
--- a/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
+++ b/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
@@ -16,12 +16,13 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
diff --git a/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 1682aad04..a38e1dca8 100644
--- a/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -16,6 +16,10 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonReaderInternalAccess;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonPrimitive;
@@ -24,13 +28,10 @@
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
-import com.google.gson.internal.JsonReaderInternalAccess;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
diff --git a/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index ec42e0482..d86b59e78 100644
--- a/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -16,14 +16,14 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.LinkedTreeMap;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index b47aaac41..fa62b9900 100644
--- a/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -16,6 +16,9 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
@@ -29,9 +32,7 @@
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
diff --git a/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
index 5ec244f29..70f1cf3a1 100644
--- a/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
@@ -16,14 +16,15 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
diff --git a/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
index 55d4b2f69..269d18d39 100644
--- a/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
@@ -16,14 +16,15 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.sql.Time;
 import java.text.DateFormat;
diff --git a/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index e13e3489f..109714476 100644
--- a/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
@@ -28,8 +30,7 @@
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 
diff --git a/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index 7e52c27d2..bba0400cb 100644
--- a/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -15,11 +15,12 @@
  */
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
diff --git a/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 23ab8a134..0152af26c 100644
--- a/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -40,6 +40,9 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerArray;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
@@ -53,9 +56,6 @@
 import com.google.gson.annotations.SerializedName;
 import com.google.gson.internal.LazilyParsedNumber;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
 
 /**
  * Type adapters for basic types.
diff --git a/src/test/java/com/google/gson/GsonBuilderTest.java b/src/test/java/com/google/gson/GsonBuilderTest.java
index 73601c0e3..f61451035 100755
--- a/src/test/java/com/google/gson/GsonBuilderTest.java
+++ b/src/test/java/com/google/gson/GsonBuilderTest.java
@@ -21,8 +21,8 @@
 
 import junit.framework.TestCase;
 
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 
 /**
  * Unit tests for {@link GsonBuilder}.
diff --git a/src/test/java/com/google/gson/JsonParserTest.java b/src/test/java/com/google/gson/JsonParserTest.java
index 7efa7fd2e..9ef2b8bf1 100644
--- a/src/test/java/com/google/gson/JsonParserTest.java
+++ b/src/test/java/com/google/gson/JsonParserTest.java
@@ -22,9 +22,9 @@
 
 import junit.framework.TestCase;
 
+import com.github.gv2011.jsoncore.JsonReader;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.internal.Streams;
-import com.google.gson.stream.JsonReader;
 
 /**
  * Unit test for {@link JsonParser}
diff --git a/src/test/java/com/google/gson/MixedStreamTest.java b/src/test/java/com/google/gson/MixedStreamTest.java
index 00eb4bc8a..2deb15452 100644
--- a/src/test/java/com/google/gson/MixedStreamTest.java
+++ b/src/test/java/com/google/gson/MixedStreamTest.java
@@ -16,9 +16,10 @@
 
 package com.google.gson;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
diff --git a/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java b/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
index 79ae1698f..9b278326f 100644
--- a/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
@@ -16,8 +16,9 @@
 
 package com.google.gson;
 
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
+
 import java.io.IOException;
 import java.util.Locale;
 import junit.framework.TestCase;
diff --git a/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 198667162..e0dc844c0 100644
--- a/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
@@ -28,8 +30,7 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Type;
diff --git a/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java b/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
index f89148e36..8ae78b212 100644
--- a/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
+++ b/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
@@ -21,14 +21,14 @@
 
 import junit.framework.TestCase;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
 
 /**
  * Functional tests for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)} method.
diff --git a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index b7b29a656..91f4e8350 100644
--- a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
@@ -29,8 +31,7 @@
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.Locale;
diff --git a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
index 4c745ec2a..333481683 100644
--- a/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
+++ b/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
@@ -16,14 +16,15 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import junit.framework.TestCase;
 
diff --git a/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index 7959fc860..4ace8a747 100644
--- a/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -21,6 +21,8 @@
 
 import junit.framework.TestCase;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
@@ -31,8 +33,6 @@
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
 
 /**
  * Functional tests for the RuntimeTypeAdapterFactory feature in extras.
diff --git a/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 551ceffc0..76d91432e 100644
--- a/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
@@ -24,8 +26,7 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
diff --git a/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java b/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
index 5f881530d..c10645a48 100644
--- a/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
+++ b/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.functional;
 
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonWriter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
@@ -25,8 +27,7 @@
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Type;
 import junit.framework.TestCase;
diff --git a/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java b/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
index 10624711c..d909ac6e6 100644
--- a/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
+++ b/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
@@ -16,9 +16,11 @@
 
 package com.google.gson.internal.bind;
 
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.JsonTreeReader;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
-import com.google.gson.stream.JsonToken;
+
 import java.io.IOException;
 import junit.framework.TestCase;
 
diff --git a/src/test/java/com/google/gson/stream/JsonReaderPathTest.java b/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
index 50661664c..2c887a1d4 100644
--- a/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
+++ b/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
@@ -18,6 +18,9 @@
 
 import java.io.IOException;
 import java.io.StringReader;
+
+import com.github.gv2011.jsoncore.JsonReader;
+
 import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
diff --git a/src/test/java/com/google/gson/stream/JsonReaderTest.java b/src/test/java/com/google/gson/stream/JsonReaderTest.java
index 48279dacb..1e524ca14 100644
--- a/src/test/java/com/google/gson/stream/JsonReaderTest.java
+++ b/src/test/java/com/google/gson/stream/JsonReaderTest.java
@@ -16,22 +16,27 @@
 
 package com.google.gson.stream;
 
+import static com.github.gv2011.jsoncore.JsonToken.BEGIN_ARRAY;
+import static com.github.gv2011.jsoncore.JsonToken.BEGIN_OBJECT;
+import static com.github.gv2011.jsoncore.JsonToken.BOOLEAN;
+import static com.github.gv2011.jsoncore.JsonToken.END_ARRAY;
+import static com.github.gv2011.jsoncore.JsonToken.END_OBJECT;
+import static com.github.gv2011.jsoncore.JsonToken.NAME;
+import static com.github.gv2011.jsoncore.JsonToken.NULL;
+import static com.github.gv2011.jsoncore.JsonToken.NUMBER;
+import static com.github.gv2011.jsoncore.JsonToken.STRING;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.Arrays;
-import junit.framework.TestCase;
 
-import static com.google.gson.stream.JsonToken.BEGIN_ARRAY;
-import static com.google.gson.stream.JsonToken.BEGIN_OBJECT;
-import static com.google.gson.stream.JsonToken.BOOLEAN;
-import static com.google.gson.stream.JsonToken.END_ARRAY;
-import static com.google.gson.stream.JsonToken.END_OBJECT;
-import static com.google.gson.stream.JsonToken.NAME;
-import static com.google.gson.stream.JsonToken.NULL;
-import static com.google.gson.stream.JsonToken.NUMBER;
-import static com.google.gson.stream.JsonToken.STRING;
+import com.github.gv2011.jsoncore.JsonReader;
+import com.github.gv2011.jsoncore.JsonToken;
+import com.github.gv2011.jsoncore.MalformedJsonException;
+
+import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
 public final class JsonReaderTest extends TestCase {
diff --git a/src/test/java/com/google/gson/stream/JsonWriterTest.java b/src/test/java/com/google/gson/stream/JsonWriterTest.java
index 34dc91402..10b9d2994 100644
--- a/src/test/java/com/google/gson/stream/JsonWriterTest.java
+++ b/src/test/java/com/google/gson/stream/JsonWriterTest.java
@@ -20,6 +20,9 @@
 import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+
+import com.github.gv2011.jsoncore.JsonWriter;
+
 import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
