diff --git a/.gitignore b/.gitignore
index b1bdb7f26..5bda0b93e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,4 +13,8 @@ release.properties
 *.iws
 classes
 
+.gradle
+local.properties
+build
+
 .DS_Store
diff --git a/.travis.yml b/.travis.yml
index ee50d51cb..963e19f6e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk7
+  - openjdk7
   - oraclejdk8
 
 install: mvn -f gson install -DskipTests=true
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2029e6b4..ca2032114 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,76 @@
 Change Log
 ==========
 
-## Version 2.4.0
+## Version 2.8.3
+_2018-04-27_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.2...gson-parent-2.8.3)
+ * Added a new API, `GsonBuilder.newBuilder()` that clones the current builder
+ * Preserving DateFormatter behavior on JDK 9
+ * Numerous other bugfixes
+
+## Version 2.8.2
+_2017-09-19_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.1...gson-parent-2.8.2)
+ * Introduced a new API, `JsonElement.deepCopy()`
+ * Numerous other bugfixes
+
+## Version 2.8.1
+_2017-05-30_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.0...gson-parent-2.8.1)
+ * New: `JsonObject.keySet()`
+ * `@JsonAdapter` annotation can now use `JsonSerializer` and `JsonDeserializer` as well.
+
+## Version 2.8
+_2016-10-26_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.7...gson-parent-2.8.0)
+ * New: `TypeToken.getParameterized()` and `TypeToken.getArray()` make it easier to
+   register or look up a `TypeAdapter`.
+ * New: `@JsonAdapter(nullSafe=true)` to specify that a custom type adapter handles null.
+
+## Version 2.7
+_2016-06-14_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.6.2...gson-parent-2.7)
+ * Added support for JsonSerializer/JsonDeserializer in @JsonAdapter annotation
+ * Exposing Gson properties excluder(), fieldNamingStrategy(), serializeNulls(), htmlSafe()
+ * Added JsonObject.size() method
+ * Added JsonWriter.value(Boolean value) method
+ * Using ArrayDeque, ConcurrentHashMap, and other JDK 1.6 features
+ * Better error reporting
+ * Plenty of other bug fixes
+
+## Version 2.6.2
+_2016-02-26_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.6.1...gson-parent-2.6.2)
+ * Fixed an NPE bug with @JsonAdapter annotation
+ * Added back OSGI manifest
+ * Some documentation typo fixes
+
+## Version 2.6.1
+
+_2016-02-11_ [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.6...gson-parent-2.6.1)
+
+ * Fix: The 2.6 release targeted Java 1.7, but we intend to target Java 1.6. The
+   2.6.1 release is identical to 2.6, but it targets Java 1.6.
+
+
+## Version 2.6
+
+_2016-02-11_ [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.5...gson-parent-2.6)
+
+ * Permit timezones without minutes in the default date adapter.
+ * Update reader and writer for RFC 7159. This means that strings, numbers,
+   booleans and null may be top-level values in JSON documents, even if the
+   reader is strict.
+ * New `setLenient()` method on `GsonBuilder`. This setting impacts the new
+   factory method `Gson.newJsonReader()`.
+ * Adapters discovered with `@JsonAdapter` are now null safe by default.
+
+
+## Version 2.5
+
+_2015-11-24_ [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.4...gson-parent-2.5)
+
+ * Updated minimum JDK version to 1.6
+ * Improved Date Deserialization by accepting many date formats
+ * Added support for `java.util.Currency`, `AtomicLong`, `AtomicLongArray`, `AtomicInteger`, `AtomicIntegerArray`, `AtomicBoolean`. This change is backward-incompatible because the earlier version of Gson used the default serialization which wasn't intuitive. We hope that these classes are not used enough to actually cause problems in the field.
+ * Improved debugging information when some exceptions are thrown
+
+
+## Version 2.4
 
 _2015-10-04_
 
@@ -15,6 +84,301 @@ _2015-10-04_
  * New: APIs to add primitives directly to `JsonArray` instances.
  * New: ISO 8601 date type adapter. Find this in _extras_.
  * Fix: `FieldNamingPolicy` now works properly when running on a device with a Turkish locale.
-
   [autovalue]: https://github.com/google/auto/tree/master/value
 
+
+## Version 2.3.1
+
+_2014-11-20_
+
+ * Added support to serialize objects with self-referential fields. The self-referential field is set to null in JSON. Previous version of Gson threw a StackOverflowException on encountering any self-referential fields.
+   * The most visible impact of this is that Gson can now serialize Throwable (Exception and Error)
+ * Added support for @JsonAdapter annotation on enums which are user defined types
+ * Fixed bug in getPath() with array of objects and arrays of arrays
+ * Other smaller bug fixes
+
+
+## Version 2.3
+
+_2014-08-11_
+
+ * The new @JsonAdapter annotation to specify a Json TypeAdapter for a class field
+ * JsonPath support: JsonReader.getPath() method returns the JsonPath expression
+ * New public methods in JsonArray (similar to the java.util.List): `contains(JsonElement), remove(JsonElement), remove(int index), set(int index, JsonElement element)`
+ * Many other smaller bug fixes
+
+
+## Version 2.2.4
+
+_2013-05-13_
+
+ * Fix internal map (LinkedHashTreeMap) hashing bug.
+ * Bug fix (Issue 511)
+
+
+## Version 2.2.3
+
+_2013-04-12_
+
+ * Fixes for possible DoS attack due to poor String hashing
+
+
+## Version 2.2.2
+
+_2012-07-02_
+
+ * Gson now allows a user to override default type adapters for Primitives and Strings. This behavior was allowed in earlier versions of Gson but was prohibited started Gson 2.0. We decided to allow it again: This enables a user to parse 1/0 as boolean values for compatibility with iOS JSON libraries.
+ * (Incompatible behavior change in `JsonParser`): In the past, if `JsonParser` encountered a stream that terminated prematurely, it returned `JsonNull`. This behavior wasn't correct because the stream had invalid JSON, not a null. `JsonParser` is now changed to throw `JsonSyntaxException` in this case. Note that if JsonParser (or Gson) encounter an empty stream, they still return `JsonNull`.
+
+
+## Version 2.2.1
+
+_2012-05-05_
+
+ * Very minor fixes
+
+
+## Version 2.2
+
+_2012-05-05_
+
+ * Added getDelegateAdapter in Gson class
+ * Fixed a security bug related to denial of service attack with Java HashMap String collisions.
+
+
+## Version 2.1
+
+_2011-12-30_ (Targeted Dec 31, 2011)
+
+ * Support for user-defined streaming type adapters
+ * continued performance enhancements
+ * Dropped support for type hierarchy instance creators. We don't expect this to be a problem. We'll also detect fewer errors where multiple type adapters can serialize the same type. With APIs like getNextTypeAdapter, this might actually be an improvement!
+
+
+## Version 2.0
+
+_2011-11-13_
+
+#### Faster
+
+ * Previous versions first parsed complete document into a DOM-style model (JsonObject or JsonArray) and then bound data against that. Gson 2 does data binding directly from the stream parser.
+
+#### More Predictable
+
+ * Objects are serialized and deserialized in the same way, regardless of where they occur in the object graph.
+
+#### Changes to watch out for
+
+  * Gson 1.7 would serialize top-level nulls as "". 2.0 serializes them as "null".
+    ```
+    String json = gson.toJson(null, Foo.class);
+    1.7: json == ""
+    2.0: json == "null"
+    ```
+
+  * Gson 1.7 permitted duplicate map keys. 2.0 forbids them.
+    ```
+    String json = "{'a':1,'a':2}";
+    Map<String, Integer> map = gson.fromJson(json, mapType);
+    1.7: map == {a=2}
+    2.0: JsonSyntaxException thrown
+    ```
+
+  * Gson 1.7 won’t serialize subclass fields in collection elements. 2.0 adds this extra information.
+    ```
+    List<Point2d> points = new ArrayList<Point2d>();
+    points.add(new Point3d(1, 2, 3));
+    String json = gson.toJson(points,
+        new TypeToken<List<Point2d>>() {}.getType());
+    1.7: json == "[{'x':1,'y':2}]"
+    2.0: json == "[{'x':1,'y':2,'z':3}]"
+    ```
+
+  * Gson 1.7 binds single-element arrays as their contents. 2.0 doesn’t.
+    ```
+    Integer i = gson.fromJson("[42]", Integer.class);
+    1.7: i == 42
+    2.0: JsonSyntaxException thrown
+    ```
+
+#### Other changes to be aware of
+ * Gson 2.0 doesn’t support type adapters for primitive types.
+ * Gson 1.7 uses arbitrary precision for primitive type conversion (so -122.08e-2132 != 0). Gson 2.0 uses double precision (so -122.08e-2132 == 0).
+ * Gson 1.7 sets subclass fields when an InstanceCreator returns a subclass when the value is a field of another object. Gson 2.0 sets fields of the requested type only.
+ * Gson 1.7 versioning never skips the top-level object. Gson 2.0 versioning applies to all objects.
+ * Gson 1.7 truncates oversized large integers. Gson 2.0 fails on them.
+ * Gson 2.0 permits integers to have .0 fractions like "1.0".
+ * Gson 1.7 throws IllegalStateException on circular references. Gson 2.0 lets the runtime throw a StackOverflowError.
+
+
+## Version 1.7.2
+
+_2011-09-30_ (Unplanned release)
+ * Fixed a threading issue in FieldAttributes (Issue 354)
+
+
+## Version 1.7.1
+
+_2011-04-13_ (Unplanned release)
+
+ * Fixed Gson jars in Maven Central repository
+ * Removed assembly-descriptor.xml and maven pom.xml/pom.properties files from Gson binary jar. This also ensures that jarjar can be run correctly on Gson.
+
+
+## Version 1.7
+
+_2011-04-12_ (Targeted: Jan 2011)
+
+ * No need to define no-args constructors for classes serialized with Gson
+ * Ability to register a hierarchical type adapter
+ * Support for serialization and deserialization of maps with complex keys
+ * Serialization and deserialization specific exclusion strategies
+ * Allow concrete data structure fields without type adapters
+ * Fixes "type" management (i.e. Wildcards, etc.)
+ * Major performance enhancements by reducing the need for Java reflection
+See detailed announcement at this thread in the Gson Google Group.
+
+
+## Version 1.6
+
+_2010-11-24_ (Targeted: Oct, 2010)
+
+ * New stream parser APIs
+ * New parser that improves parsing performance significantly
+
+
+## Version 1.5
+
+_2010-08-19_ (Target Date: Aug 18, 2010)
+
+ * Added `UPPER_CAMEL_CASE_WITH_SPACES` naming policy
+ * Added SQL date and time support
+ * A number of performance improvements: Using caching of field annotations for speeding up reflection, replacing recursive calls in the parser with a for loop.
+
+
+## Version 1.4 BETA
+
+_2009_10_09_
+
+ * JsonStreamParser: A streaming parser API class to deserialize multiple JSON objects on a stream (such as a pipelined HTTP response)
+ * Raised the deserialization limit for byte and object arrays and collection to over 11MB from 80KB. See issue 96.
+ * While serializing, Gson now uses the actual type of a field. This allows serialization of base-class references holding sub-classes to the JSON for the sub-class. It also allows serialization of raw collections. See Issue 155, 156.
+ * Added a `Gson.toJsonTree()` method that serializes a Java object to a tree of JsonElements. See issue 110.
+ * Added a `Gson.fromJson(JsonElement)` method that deserializes from a Json parse tree.
+ * Updated `Expose` annotation to contain parameters serialize and deserialize to control whether a field gets serialized or deserialized. See issue 146.
+ * Added a new naming policy `LOWER_CASE_WITH_DASHES`
+ * Default date type adapter is now thread-safe. See Issue 162.
+ * `JsonElement.toString()` now outputs valid JSON after escaping characters properly. See issue 154.
+ * `JsonPrimitive.equals()` now returns true for two numbers if their values are equal. All integral types (long, int, short, byte, BigDecimal, Long, Integer, Short, Byte) are treated equivalent for comparison. Similarly, floating point types (double, float, BigDecimal, Double, Float) are treated equivalent as well. See issue 147.
+ * Fixed bugs in pretty printing. See issue 153.
+ * If a field causes circular reference error, Gson lists the field name instead of the object value. See issue 118.
+ * Gson now serializes a list with null elements correctly. See issue 117.
+ * Fixed issue 121, 123, 126.
+ * Support user defined exclusion strategies (Feature Request 138).
+
+
+## Version 1.3
+
+_2009-04-01_
+
+ * Fix security token to remove the `<data>` element.
+ * Changed JsonParser.parse method to be non-static
+ * Throw JsonParseExceptions instead of ClassCastExceptions and UnsupportedOperationExceptions
+
+
+## Version 1.3 beta3
+
+_2009-03-17_
+
+ * Supported custom mapping of field names by making `FieldNamingStrategy` public and allowing `FieldNamingStrategy` to be set in GsonBuilder. See issue 104.
+ * Added a new GsonBuilder setting `generateNonExecutableJson()` that prefixes the generated JSON with some text to make the output non-executable Javascript. Gson now recognizes this text from input while deserializing and filters it out. This feature is meant to prevent script sourcing attacks. See Issue 42.
+ * Supported deserialization of sets with elements that do not implement Comparable. See Issue 100
+ * Supported deserialization of floating point numbers without a sign after E. See Issue 94
+
+
+## Version 1.3 beta2
+
+_2009-02-05_
+
+ * Added a new Parser API. See issue 65
+ * Supported deserialization of java.util.Properties. See Issue 87
+ * Fixed the pretty printing of maps. See Issue 93
+ * Supported automatic conversion of strings into numeric and boolean types if possible. See Issue 89
+ * Supported deserialization of longs into strings. See Issue 82
+
+
+## Version 1.3 beta1
+
+_2009_01_ (Target Date Friday, Dec 15, 2008)
+
+ * Made JSON parser lenient by allowing unquoted member names while parsing. See Issue 41
+ * Better precision handling for floating points. See Issue 71, 72
+ * Support for deserialization of special double values: NaN, infinity and negative infinity. See Issue 81
+ * Backward compatibility issue found with serialization of `Collection<Object>` type.  See Issue 73 and 83.
+ * Able to serialize null keys and/or values within a Map.  See Issue 77
+ * Deserializing non-String value keys for Maps.  See Issue 85.
+
+ * Support for clashing field name.  See Issue 76.
+ * Removed the need to invoke instance creator if a deserializer is registered. See issues 37 and 69.
+ * Added default support for java.util.UUID. See Issue 79
+ * Changed `Gson.toJson()` methods to use `Appendable` instead of `Writer`. Issue 52. This requires that clients recompile their source code that uses Gson.
+
+
+## Version 1.2.3
+
+_2008-11-15_ (Target Date Friday, Oct 31, 2008)
+
+ * Added support to serialize raw maps. See issue 45
+ * Made Gson thread-safe by fixing Issue 63
+ * Fixed Issue 68 to allow default type adapters for primitive types to be replaced by custom type adapters.
+ * Relaxed the JSON parser to accept escaped slash (\/) as a valid character in the string. See Issue 66
+
+
+## Version 1.2.2
+
+_2008-10-14_ (Target Date: None, Unplanned)
+
+ * This version was released to fix Issue 58 which caused a regression bug in version 1.2.1. It includes the contents from the release 1.2.1
+
+
+## Version 1.2.1
+
+_2008-10-13_ (Target Date Friday, Oct 7, 2008)
+
+**Note:** This release was abandoned since it caused a regression (Issue 58) bug.
+
+ * Includes updated parser for JSON that supports much larger strings. For example, Gson 1.2 failed at parsing a 100k string, Gson 1.2.1 has successfully parsed strings of size 15-20MB. The parser also is faster and consumes less memory since it uses a token match instead of a recursion-based Grammar production match. See Issue 47.
+ * Gson now supports field names with single quotes ' in addition to double quotes ". See Issue 55.
+ * Includes bug fixes for issue 46, 49, 51, 53, 54, and 56.
+
+
+## Version 1.2
+
+_2008-08-29_ (Target Date Tuesday Aug 26, 2008)
+
+ * Includes support for feature requests 21, 24, 29
+ * Includes bug fixes for Issue 22, Issue 23, Issue 25, Issue 26, Issue 32 , Issue 34, Issue 35, Issue 36, Issue 37, Issue 38, Issue 39
+ * Performance enhancements (see r137)
+ * Documentation updates
+
+
+## Version 1.1.1
+
+_2008-07-18_ (Target Date Friday, Aug 1, 2008)
+
+ * Includes fixes for Issue 19, Partial fix for Issue 20
+
+
+## Version 1.1
+
+_2008-07-01_ (Target Date Thursday, July 3, 2008)
+
+ * Includes fixes for Issue 9, Issue 16, Issue 18
+
+
+## Version 1.0.1
+
+_2008-06-17_ (Target Date Friday,  Jun 13, 2008)
+
+ * Includes fixes for Issue 15, Issue 14, Issue 3, Issue 8
+ * Javadoc improvements
diff --git a/GsonDesignDocument.md b/GsonDesignDocument.md
new file mode 100644
index 000000000..2c3702ee1
--- /dev/null
+++ b/GsonDesignDocument.md
@@ -0,0 +1,57 @@
+# Gson Design Document
+
+This document presents issues that we faced while designing Gson. It is meant for advanced users or developers working on Gson. If you are interested in learning how to use Gson, see its user guide. 
+
+**Navigating the Json tree or the target Type Tree while deserializing**
+
+When you are deserializing a Json string into an object of desired type, you can either navigate the tree of the input, or the type tree of the desired type. Gson uses the latter approach of navigating the type of the target object. This keeps you in tight control of instantiating only the type of objects that you are expecting (essentially validating the input against the expected "schema"). By doing this, you also ignore any extra fields that the Json input has but were not expected. 
+
+As part of Gson, we wrote a general purpose ObjectNavigator that can take any object and navigate through its fields calling a visitor of your choice. 
+
+**Supporting richer serialization semantics than deserialization semantics**
+
+Gson supports serialization of arbitrary collections, but can only deserialize genericized collections. this means that Gson can, in some cases, fail to deserialize Json that it wrote. This is primarily a limitation of the Java type system since when you encounter a Json array of arbitrary types there is no way to detect the types of individual elements. We could have chosen to restrict the serialization to support only generic collections, but chose not to.This is because often the user of the library are concerned with either serialization or deserialization, but not both. In such cases, there is no need to artificially restrict the serialization capabilities. 
+
+**Supporting serialization and deserialization of classes that are not under your control and hence can not be modified**
+
+Some Json libraries use annotations on fields or methods to indicate which fields should be used for Json serialization. That approach essentially precludes the use of classes from JDK or third-party libraries. We solved this problem by defining the notion of Custom serializers and deserializers. This approach is not new, and was used by the JAX-RPC technology to solve essentially the same problem. 
+
+**Using Checked vs Unchecked exceptions to indicate a parsing error**
+
+We chose to use unchecked exceptions to indicate a parsing failure. This is primarily done because usually the client can not recover from bad input, and hence forcing them to catch a checked exception results in sloppy code in the catch() block. 
+
+**Creating class instances for deserialization**
+
+Gson needs to create a dummy class instance before it can deserialize Json data into its fields. We could have used Guice to get such an instance, but that would have resulted in a dependency on Guice. Moreover, it probably would have done the wrong thing since Guice is expected to return a valid instance, whereas we need to create a dummy one. Worse, Gson would overwrite the fields of that instance with the incoming data there by modifying the instance for all subsequent Guice injections. This is clearly not a desired behavior. Hence, we create class instances by invoking the parameterless constructor. We also handle the primitive types, enums, collections, sets, maps and trees as a special case. 
+
+To solve the problem of supporting unmodifiable types, we use custom instance creators. So, if you want to use a library types that does not define a default constructor (for example, Money class), then you can register an instance creator that returns a dummy instance when asked.
+
+**Using fields vs getters to indicate Json elements**
+
+Some Json libraries use the getters of a type to deduce the Json elements. We chose to use all fields (up the inheritance hierarchy) that are not transient, static, or synthetic. We did this because not all classes are written with suitably named getters. Moreover, getXXX or isXXX might be semantic rather than indicating properties. 
+
+However, there are good arguments to support properties as well. We intend to enhance Gson in a latter version to support properties as an alternate mapping for indicating Json fields. For now, Gson is fields-based. 
+
+**Why are most classes in Gson marked as final?**
+
+While Gson provides a fairly extensible architecture by providing pluggable serializers and deserializers, Gson classes were not specifically designed to be extensible. Providing non-final classes would have allowed a user to legitimately extend Gson classes, and then expect that behavior to work in all subsequent revisions. We chose to limit such use-cases by marking classes as final, and waiting until a good use-case emerges to allow extensibility. Marking a class final also has a minor benefit of providing additional optimization opportunities to Java compiler and virtual machine. 
+
+**Why are inner interfaces and classes used heavily in Gson?**
+
+Gson uses inner classes substantially. Many of the public interfaces are inner interfaces too (see JsonSerializer.Context or JsonDeserializer.Context as an example). These are primarily done as a matter of style. For example, we could have moved JsonSerializer.Context to be a top-level class JsonSerializerContext, but chose not to do so. However, if you can give us good reasons to rename it alternately, we are open to changing this philosophy. 
+
+**Why do you provide two ways of constructing Gson?**
+
+Gson can be constructed in two ways: by invoking new Gson() or by using a GsonBuilder. We chose to provide a simple no-args constructor to handle simple use-cases for Gson where you want to use default options, and quickly want to get going with writing code. For all other situations, where you need to configure Gson with options such as formatters, version controls etc, we use a builder pattern. The builder pattern allows a user to specify multiple optional settings for what essentially become constructor parameters for Gson. 
+
+**Comparing Gson with Alternate Approaches**
+
+Note that these comparisons were done while developing Gson so these date back to mid to late 2007.
+
+__Comparing Gson with org.json library__
+
+org.json is a much lower-level library that can be used to write a toJson() method in a class. If you can not use Gson directly (may be because of platform restrictions regarding reflection), you could use org.json to hand-code a toJson method in each object. 
+
+__Comparing Gson with org.json.simple library__
+
+org.json.simple library is very similar to org.json library and hence fairly low level. The key issue with this library is that it does not handle exceptions very well. In some cases it appeared to just eat the exception while in other cases it throws an "Error" rather than an exception.
diff --git a/LICENSE b/LICENSE
index d8a8268f2..d64569567 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,13 +1,202 @@
-Copyright 2008 Google Inc. 
 
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
 
-    http://www.apache.org/licenses/LICENSE-2.0
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/README.md b/README.md
index 2c0388c3e..233a979f2 100644
--- a/README.md
+++ b/README.md
@@ -1,26 +1,68 @@
 # google-gson
+
+[![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson)
+[![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
+
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
-Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. 
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
 
-There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
+There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.
 
-*Gson Goals*
-  * Provide simple toJson() and fromJson() methods to convert Java objects to JSON and vice-versa
+### Gson Goals
+  * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-*Gson Downloads*
-  * [Gson 2.4 Download](http://search.maven.org/#artifactdetails%7Ccom.google.code.gson%7Cgson%7C2.4%7Cjar) downloads at Maven Central
+### Gson Download and Maven
+  * To use Gson in Android
+```gradle
+dependencies {
+    compile 'com.google.code.gson:gson:2.8.3'
+}
+```
+
+  * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
+  * To use Gson with Maven
+  ```xml
+<dependency>
+    <groupId>com.google.code.gson</groupId>
+    <artifactId>gson</artifactId>
+    <version>2.8.3</version>
+</dependency>
+```
 
-*Gson Documentation*
-  * Gson [API](http://google.github.io/gson/apidocs/): Javadocs for the current Gson release
-  * Gson [user guide](http://sites.google.com/site/gson/gson-user-guide): This guide contains examples on how to use Gson in your code.
-  * Gson [Roadmap](https://sites.google.com/site/gson/gson-roadmap): Details on upcoming releases 
-  * Gson [design document](https://sites.google.com/site/gson/gson-design-document): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+### Gson Documentation
+  * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
+  * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
+  * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
+  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
 
-Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
+Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions.
 
-*Gson-related Content Created by Third Parties*
+### Gson-related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
+  * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
+  * [Gson API Report](https://abi-laboratory.pro/java/tracker/timeline/gson/)
+
+### License
+
+Gson is released under the [Apache 2.0 license](LICENSE).
+
+```
+Copyright 2008 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
diff --git a/ReleaseProcess.md b/ReleaseProcess.md
new file mode 100644
index 000000000..2aef00af6
--- /dev/null
+++ b/ReleaseProcess.md
@@ -0,0 +1,92 @@
+# Gson Release Process
+
+The following is a step-by-step procedure for releasing a new version of Google-Gson.
+
+1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
+1. (obsolete step) Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
+1. Ensure all changelists are code-reviewed and have +1
+1. (obsolete step) Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
+1. `cd gson` to the parent directory; ensure there are no open files and all changes are committed.
+1. Run `mvn release:clean`
+1. Do a dry run: `mvn release:prepare -DdryRun=true`
+1. Start the release: `mvn release:prepare`
+   * Answer questions: usually the defaults are fine.
+   * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
+1. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
+
+   ```bash
+   mvn -s /home/<username>/.m2/settings.xml release:perform
+   ```
+
+1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
+
+   ```bash
+   cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
+   cd /tmp/1.7.2
+
+   mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2-javadoc.jar \
+      -Dclassifier=javadoc
+
+   mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2-sources.jar \
+      -Dclassifier=sources
+
+   mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2.jar
+   ```
+
+1. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+1. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
+
+1. Update the version in the [Using Gson with Maven2 page](https://github.com/google/gson/blob/master/UserGuide.md#TOC-Gson-With-Maven)
+1. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
+1. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
+1. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current "stable" release.
+
+## Configuring a machine for deployment to Sonatype Repository
+
+This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
+
+1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
+1. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+1. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
+1. Now for deploying a snapshot repository, use `mvn deploy`.
+
+## Getting Maven Publishing Privileges
+
+Based on [Gson group thread](https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion):
+
+1. [Sign up for a Sonatype account](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide) following instructions under (2) on that page
+1. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
+
+## Running Benchmarks or Tests on Android
+
+* Download vogar
+* Put `adb` on your `$PATH` and run:
+
+  ```bash
+  vogar --benchmark --classpath gson.jar path/to/Benchmark.java
+  ```
+
+For example, here is how to run the [CollectionsDeserializationBenchmark](gson/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java):
+
+```bash
+export ANDROID_HOME=~/apps/android-sdk-mac_x86
+export PATH=$PATH:$ANDROID_HOME/platform-tools/:$ANDROID_HOME/android-sdk-mac_x86/tools/
+$VOGAR_HOME/bin/vogar \
+    --benchmark \
+    --sourcepath ../gson/src/main/java/ \
+    src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java \
+    -- \
+    --vm "app_process -Xgc:noconcurrent,app_process"
+```
diff --git a/UserGuide.md b/UserGuide.md
new file mode 100644
index 000000000..e024f1692
--- /dev/null
+++ b/UserGuide.md
@@ -0,0 +1,669 @@
+# Gson User Guide
+
+1. [Overview](#TOC-Overview)
+2. [Goals for Gson](#TOC-Goals-for-Gson)
+3. [Gson Performance and Scalability](#TOC-Gson-Performance-and-Scalability)
+4. [Gson Users](#TOC-Gson-Users)
+5. [Using Gson](#TOC-Using-Gson)
+   * [Using Gson with Gradle/Android](#TOC-Gson-With-Gradle)
+   * [Using Gson with Maven](#TOC-Gson-With-Maven)
+   * [Primitives Examples](#TOC-Primitives-Examples)
+   * [Object Examples](#TOC-Object-Examples)
+   * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
+   * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
+   * [Array Examples](#TOC-Array-Examples)
+   * [Collections Examples](#TOC-Collections-Examples)
+     * [Collections Limitations](#TOC-Collections-Limitations)
+   * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
+   * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
+   * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
+   * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
+     * [Writing a Serializer](#TOC-Writing-a-Serializer)
+     * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
+   * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
+     * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
+   * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
+   * [Null Object Support](#TOC-Null-Object-Support)
+   * [Versioning Support](#TOC-Versioning-Support)
+   * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
+     * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
+     * [Gson's `@Expose`](#TOC-Gson-s-Expose)
+     * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
+   * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
+   * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
+   * [Streaming](#TOC-Streaming)
+6. [Issues in Designing Gson](#TOC-Issues-in-Designing-Gson)
+7. [Future Enhancements to Gson](#TOC-Future-Enhancements-to-Gson)
+
+## <a name="TOC-Overview"></a>Overview
+
+Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
+
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.
+
+## <a name="TOC-Goals-for-Gson"></a>Goals for Gson
+
+* Provide easy to use mechanisms like `toString()` and constructor (factory method) to convert Java to JSON and vice-versa
+* Allow pre-existing unmodifiable objects to be converted to and from JSON
+* Allow custom representations for objects
+* Support arbitrarily complex objects
+* Generate compact and readable JSON output
+
+## <a name="TOC-Gson-Performance-and-Scalability"></a>Gson Performance and Scalability
+
+Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class [`PerformanceTest`](gson/src/test/java/com/google/gson/metrics/PerformanceTest.java).
+
+* Strings: Deserialized strings of over 25MB without any problems (see `disabled_testStringDeserializationPerformance` method in `PerformanceTest`)
+* Large collections:
+  * Serialized a collection of 1.4 million objects (see `disabled_testLargeCollectionSerialization` method in `PerformanceTest`)
+  * Deserialized a collection of 87,000 objects (see `disabled_testLargeCollectionDeserialization` in `PerformanceTest`)
+* Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.
+
+Note: Delete the `disabled_` prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.
+
+## <a name="TOC-Gson-Users"></a>Gson Users
+
+Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.
+
+## <a name="TOC-Using-Gson"></a>Using Gson
+
+The primary class to use is [`Gson`](gson/src/main/java/com/google/gson/Gson.java) which you can just create by calling `new Gson()`. There is also a class [`GsonBuilder`](gson/src/main/java/com/google/gson/GsonBuilder.java) available that can be used to create a Gson instance with various settings like version control and so on.
+
+The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.
+
+## <a name="TOC-Gson-With-Gradle"></a>Using Gson with Gradle/Android
+```
+dependencies {
+    compile 'com.google.code.gson:gson:2.8.3'
+}
+```
+## <a name="TOC-Gson-With-Maven"></a>Using Gson with Maven
+To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:
+
+```xml
+<dependencies>
+    <!--  Gson: Java to Json conversion -->
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.3</version>
+      <scope>compile</scope>
+    </dependency>
+</dependencies>
+```
+
+That is it, now your maven project is Gson enabled. 
+
+### <a name="TOC-Primitives-Examples"></a>Primitives Examples
+
+```java
+// Serialization
+Gson gson = new Gson();
+gson.toJson(1);            // ==> 1
+gson.toJson("abcd");       // ==> "abcd"
+gson.toJson(new Long(10)); // ==> 10
+int[] values = { 1 };
+gson.toJson(values);       // ==> [1]
+
+// Deserialization
+int one = gson.fromJson("1", int.class);
+Integer one = gson.fromJson("1", Integer.class);
+Long one = gson.fromJson("1", Long.class);
+Boolean false = gson.fromJson("false", Boolean.class);
+String str = gson.fromJson("\"abc\"", String.class);
+String[] anotherStr = gson.fromJson("[\"abc\"]", String[].class);
+```
+
+### <a name="TOC-Object-Examples"></a>Object Examples
+
+```java
+class BagOfPrimitives {
+  private int value1 = 1;
+  private String value2 = "abc";
+  private transient int value3 = 3;
+  BagOfPrimitives() {
+    // no-args constructor
+  }
+}
+
+// Serialization
+BagOfPrimitives obj = new BagOfPrimitives();
+Gson gson = new Gson();
+String json = gson.toJson(obj);  
+
+// ==> json is {"value1":1,"value2":"abc"}
+```
+
+Note that you can not serialize objects with circular references since that will result in infinite recursion.
+
+```java
+// Deserialization
+BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
+// ==> obj2 is just like obj
+```
+
+#### <a name="TOC-Finer-Points-with-Objects"></a>**Finer Points with Objects**
+
+* It is perfectly fine (and recommended) to use private fields.
+* There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
+* If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
+* This implementation handles nulls correctly.
+* While serializing, a null field is omitted from the output.
+* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
+* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization.
+* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.
+
+### <a name="TOC-Nested-Classes-including-Inner-Classes-"></a>Nested Classes (including Inner Classes)
+
+Gson can serialize static nested classes quite easily.
+
+Gson can also deserialize static nested classes. However, Gson can **not** automatically deserialize the **pure inner classes since their no-args constructor also need a reference to the containing Object** which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:
+
+```java
+public class A { 
+  public String a; 
+
+  class B { 
+
+    public String b; 
+
+    public B() {
+      // No args constructor for B
+    }
+  } 
+}
+```
+
+**NOTE**: The above class B can not (by default) be serialized with Gson.
+
+Gson can not deserialize `{"b":"abc"}` into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B. 
+
+```java
+public class InstanceCreatorForB implements InstanceCreator<A.B> {
+  private final A a;
+  public InstanceCreatorForB(A a)  {
+    this.a = a;
+  }
+  public A.B createInstance(Type type) {
+    return a.new B();
+  }
+}
+```
+
+The above is possible, but not recommended.
+
+### <a name="TOC-Array-Examples"></a>Array Examples
+
+```java
+Gson gson = new Gson();
+int[] ints = {1, 2, 3, 4, 5};
+String[] strings = {"abc", "def", "ghi"};
+
+// Serialization
+gson.toJson(ints);     // ==> [1,2,3,4,5]
+gson.toJson(strings);  // ==> ["abc", "def", "ghi"]
+
+// Deserialization
+int[] ints2 = gson.fromJson("[1,2,3,4,5]", int[].class); 
+// ==> ints2 will be same as ints
+```
+
+We also support multi-dimensional arrays, with arbitrarily complex element types.
+
+### <a name="TOC-Collections-Examples"></a>Collections Examples
+
+```java
+Gson gson = new Gson();
+Collection<Integer> ints = Lists.immutableList(1,2,3,4,5);
+
+// Serialization
+String json = gson.toJson(ints);  // ==> json is [1,2,3,4,5]
+
+// Deserialization
+Type collectionType = new TypeToken<Collection<Integer>>(){}.getType();
+Collection<Integer> ints2 = gson.fromJson(json, collectionType);
+// ==> ints2 is same as ints
+```
+
+Fairly hideous: note how we define the type of collection.
+Unfortunately, there is no way to get around this in Java.
+
+#### <a name="TOC-Collections-Limitations"></a>Collections Limitations
+
+Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type.
+This makes sense, and is rarely a problem when following good Java coding practices.
+
+### <a name="TOC-Serializing-and-Deserializing-Generic-Types"></a>Serializing and Deserializing Generic Types
+
+When you call `toJson(obj)`, Gson calls `obj.getClass()` to get information on the fields to serialize. Similarly, you can typically pass `MyClass.class` object in the `fromJson(json, MyClass.class)` method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:
+
+```java
+class Foo<T> {
+  T value;
+}
+Gson gson = new Gson();
+Foo<Bar> foo = new Foo<Bar>();
+gson.toJson(foo); // May not serialize foo.value correctly
+
+gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
+```
+
+The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
+
+You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
+
+```java
+Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
+gson.toJson(foo, fooType);
+
+gson.fromJson(json, fooType);
+```
+The idiom used to get `fooType` actually defines an anonymous local inner class containing a method `getType()` that returns the fully parameterized type.
+
+### <a name="TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types"></a>Serializing and Deserializing Collection with Objects of Arbitrary Types
+
+Sometimes you are dealing with JSON array that contains mixed types. For example:
+`['hello',5,{name:'GREETINGS',source:'guest'}]`
+
+The equivalent `Collection` containing this is:
+
+```java
+Collection collection = new ArrayList();
+collection.add("hello");
+collection.add(5);
+collection.add(new Event("GREETINGS", "guest"));
+```
+
+where the `Event` class is defined as:
+
+```java
+class Event {
+  private String name;
+  private String source;
+  private Event(String name, String source) {
+    this.name = name;
+    this.source = source;
+  }
+}
+```
+
+You can serialize the collection with Gson without doing anything specific: `toJson(collection)` would write out the desired output.
+
+However, deserialization with `fromJson(json, Collection.class)` will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in `fromJson()`. So, you have three options:
+
+1. Use Gson's parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use `Gson.fromJson()` on each of the array elements.This is the preferred approach. [Here is an example](extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java) that demonstrates how to do this.
+
+2. Register a type adapter for `Collection.class` that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.
+
+3. Register a type adapter for `MyCollectionMemberType` and use `fromJson()` with `Collection<MyCollectionMemberType>`.
+
+This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type `Collection<MyCollectionMemberType>`.
+
+### <a name="TOC-Built-in-Serializers-and-Deserializers"></a>Built-in Serializers and Deserializers
+
+Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
+Here is a list of such classes:
+
+1. `java.net.URL` to match it with strings like `"https://github.com/google/gson/"`
+2. `java.net.URI` to match it with strings like `"/google/gson/"`
+
+You can also find source code for some commonly used classes such as JodaTime at [this page](https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1).
+
+### <a name="TOC-Custom-Serialization-and-Deserialization"></a>Custom Serialization and Deserialization
+
+Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
+Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:
+
+* Json Serializers: Need to define custom serialization for an object
+* Json Deserializers: Needed to define custom deserialization for a type
+
+* Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
+
+```java
+GsonBuilder gson = new GsonBuilder();
+gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
+gson.registerTypeAdapter(MyType.class, new MySerializer());
+gson.registerTypeAdapter(MyType.class, new MyDeserializer());
+gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());
+```
+
+`registerTypeAdapter` call checks if the type adapter implements more than one of these interfaces and register it for all of them.
+
+#### <a name="TOC-Writing-a-Serializer"></a>Writing a Serializer
+
+Here is an example of how to write a custom serializer for JodaTime `DateTime` class.
+
+```java
+private class DateTimeSerializer implements JsonSerializer<DateTime> {
+  public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
+    return new JsonPrimitive(src.toString());
+  }
+}
+```
+
+Gson calls `serialize()` when it runs into a `DateTime` object during serialization.
+
+#### <a name="TOC-Writing-a-Deserializer"></a>Writing a Deserializer
+
+Here is an example of how to write a custom deserializer for JodaTime DateTime class.
+
+```java
+private class DateTimeDeserializer implements JsonDeserializer<DateTime> {
+  public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+      throws JsonParseException {
+    return new DateTime(json.getAsJsonPrimitive().getAsString());
+  }
+}
+```
+
+Gson calls `deserialize` when it needs to deserialize a JSON string fragment into a DateTime object
+
+**Finer points with Serializers and Deserializers**
+
+Often you want to register a single handler for all generic types corresponding to a raw type
+
+* For example, suppose you have an `Id` class for id representation/translation (i.e. an internal vs. external representation).
+* `Id<T>` type that has same serialization for all generic types
+  * Essentially write out the id value
+* Deserialization is very similar but not exactly the same
+  * Need to call `new Id(Class<T>, String)` which returns an instance of `Id<T>`
+
+Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say `Id<RequiresSpecialHandling>` needed special handling).
+The `Type` parameter for the `toJson()` and `fromJson()` contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.
+
+### <a name="TOC-Writing-an-Instance-Creator"></a>Writing an Instance Creator
+
+While deserializing an Object, Gson needs to create a default instance of the class.
+Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.
+
+* Doesn't matter whether public or private
+
+Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor
+
+**Instance Creator Example**
+
+```java
+private class MoneyInstanceCreator implements InstanceCreator<Money> {
+  public Money createInstance(Type type) {
+    return new Money("1000000", CurrencyCode.USD);
+  }
+}
+```
+
+Type could be of a corresponding generic type
+
+* Very useful to invoke constructors which need specific generic type information
+* For example, if the `Id` class stores the class for which the Id is being created
+
+#### <a name="TOC-InstanceCreator-for-a-Parameterized-Type"></a>InstanceCreator for a Parameterized Type
+
+Sometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:
+
+```java
+class MyList<T> extends ArrayList<T> {
+}
+
+class MyListInstanceCreator implements InstanceCreator<MyList<?>> {
+    @SuppressWarnings("unchecked")
+  public MyList<?> createInstance(Type type) {
+    // No need to use a parameterized list since the actual instance will have the raw type anyway.
+    return new MyList();
+  }
+}
+```
+
+However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the `createInstance` method. Here is an example:
+
+```java
+public class Id<T> {
+  private final Class<T> classOfId;
+  private final long value;
+  public Id(Class<T> classOfId, long value) {
+    this.classOfId = classOfId;
+    this.value = value;
+  }
+}
+
+class IdInstanceCreator implements InstanceCreator<Id<?>> {
+  public Id<?> createInstance(Type type) {
+    Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments();
+    Type idType = typeParameters[0]; // Id has only one parameterized type T
+    return Id.get((Class)idType, 0L);
+  }
+}
+```
+
+In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, `type`. The `type` object in this case is the Java parameterized type representation of `Id<Foo>` where the actual instance should be bound to `Id<Foo>`. Since `Id` class has just one parameterized type parameter, `T`, we use the zeroth element of the type array returned by `getActualTypeArgument()` which will hold `Foo.class` in this case.
+
+### <a name="TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format"></a>Compact Vs. Pretty Printing for JSON Output Format
+
+The default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, "null" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the [Null Object Support](#TOC-Null-Object-Support) section for information on configure Gson to output all null values.
+
+If you would like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default `JsonPrintFormatter` that has default line length of 80 character, 2 character indentation, and 4 character right margin.
+
+The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the `JsonCompactFormatter`:
+```
+Gson gson = new GsonBuilder().setPrettyPrinting().create();
+String jsonOutput = gson.toJson(someObject);
+```
+### <a name="TOC-Null-Object-Support"></a>Null Object Support
+
+The default behaviour that is implemented in Gson is that `null` object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.
+
+Here's how you would configure a `Gson` instance to output null:
+
+```java
+Gson gson = new GsonBuilder().serializeNulls().create();
+```
+
+NOTE: when serializing `null`s with Gson, it will add a `JsonNull` element to the `JsonElement` structure. Therefore, this object can be used in custom serialization/deserialization.
+
+Here's an example:
+
+```java
+public class Foo {
+  private final String s;
+  private final int i;
+
+  public Foo() {
+    this(null, 5);
+  }
+
+  public Foo(String s, int i) {
+    this.s = s;
+    this.i = i;
+  }
+}
+
+Gson gson = new GsonBuilder().serializeNulls().create();
+Foo foo = new Foo();
+String json = gson.toJson(foo);
+System.out.println(json);
+
+json = gson.toJson(null);
+System.out.println(json);
+```
+
+The output is:
+
+```
+{"s":null,"i":5}
+null
+```
+
+### <a name="TOC-Versioning-Support"></a>Versioning Support
+
+Multiple versions of the same object can be maintained by using [@Since](gson/src/main/java/com/google/gson/annotations/Since.java) annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your `Gson` instance to ignore any field/object that is greater than some version number. If no version is set on the `Gson` instance then it will serialize and deserialize all fields and classes regardless of the version.
+
+```java
+public class VersionedClass {
+  @Since(1.1) private final String newerField;
+  @Since(1.0) private final String newField;
+  private final String field;
+
+  public VersionedClass() {
+    this.newerField = "newer";
+    this.newField = "new";
+    this.field = "old";
+  }
+}
+
+VersionedClass versionedObject = new VersionedClass();
+Gson gson = new GsonBuilder().setVersion(1.0).create();
+String jsonOutput = gson.toJson(someObject);
+System.out.println(jsonOutput);
+System.out.println();
+
+gson = new Gson();
+jsonOutput = gson.toJson(someObject);
+System.out.println(jsonOutput);
+```
+
+The output is:
+
+```
+{"newField":"new","field":"old"}
+
+{"newerField":"newer","newField":"new","field":"old"}
+```
+
+### <a name="TOC-Excluding-Fields-From-Serialization-and-Deserialization"></a>Excluding Fields From Serialization and Deserialization
+
+Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use [custom serializers and deserializers](#TOC-Custom-Serialization-and-Deserialization).
+
+#### <a name="TOC-Java-Modifier-Exclusion"></a>Java Modifier Exclusion
+
+By default, if you mark a field as `transient`, it will be excluded. As well, if a field is marked as `static` then by default it will be excluded. If you want to include some transient fields then you can do the following:
+
+```java
+import java.lang.reflect.Modifier;
+Gson gson = new GsonBuilder()
+    .excludeFieldsWithModifiers(Modifier.STATIC)
+    .create();
+```
+
+NOTE: you can give any number of the `Modifier` constants to the `excludeFieldsWithModifiers` method. For example:
+
+```java
+Gson gson = new GsonBuilder()
+    .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
+    .create();
+```
+
+#### <a name="TOC-Gson-s-Expose"></a>Gson's `@Expose`
+
+This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using `new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()`. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
+
+#### <a name="TOC-User-Defined-Exclusion-Strategies"></a>User Defined Exclusion Strategies
+
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+
+The following example shows how to exclude fields marked with a specific `@Foo` annotation and excludes top-level types (or declared field type) of class `String`.
+
+```java
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD})
+public @interface Foo {
+  // Field tag only annotation
+}
+
+public class SampleObjectForTest {
+  @Foo private final int annotatedField;
+  private final String stringField;
+  private final long longField;
+  private final Class<?> clazzField;
+
+  public SampleObjectForTest() {
+    annotatedField = 5;
+    stringField = "someDefaultValue";
+    longField = 1234;
+  }
+}
+
+public class MyExclusionStrategy implements ExclusionStrategy {
+  private final Class<?> typeToSkip;
+
+  private MyExclusionStrategy(Class<?> typeToSkip) {
+    this.typeToSkip = typeToSkip;
+  }
+
+  public boolean shouldSkipClass(Class<?> clazz) {
+    return (clazz == typeToSkip);
+  }
+
+  public boolean shouldSkipField(FieldAttributes f) {
+    return f.getAnnotation(Foo.class) != null;
+  }
+}
+
+public static void main(String[] args) {
+  Gson gson = new GsonBuilder()
+      .setExclusionStrategies(new MyExclusionStrategy(String.class))
+      .serializeNulls()
+      .create();
+  SampleObjectForTest src = new SampleObjectForTest();
+  String json = gson.toJson(src);
+  System.out.println(json);
+}
+```
+
+The output is:
+
+```
+{"longField":1234}
+```
+
+### <a name="TOC-JSON-Field-Naming-Support"></a>JSON Field Naming Support
+
+Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
+
+It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise "Runtime" exceptions if an invalid field name is provided as the annotation value.
+
+The following is an example of how to use both Gson naming policy features:
+
+```java
+private class SomeObject {
+  @SerializedName("custom_naming") private final String someField;
+  private final String someOtherField;
+
+  public SomeObject(String a, String b) {
+    this.someField = a;
+    this.someOtherField = b;
+  }
+}
+
+SomeObject someObject = new SomeObject("first", "second");
+Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
+String jsonRepresentation = gson.toJson(someObject);
+System.out.println(jsonRepresentation);
+```
+
+The output is:
+
+```
+{"custom_naming":"first","SomeOtherField":"second"}
+```
+
+If you have a need for custom naming policy ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](http://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html) annotation.
+
+### <a name="TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers"></a>Sharing State Across Custom Serializers and Deserializers
+
+Sometimes you need to share state across custom serializers/deserializers ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb)). You can use the following three strategies to accomplish this:
+
+1. Store shared state in static fields
+2. Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state
+3. Use Java `ThreadLocal`
+
+1 and 2 are not thread-safe options, but 3 is.
+
+### <a name="TOC-Streaming"></a>Streaming
+
+In addition Gson's object model and data binding, you can use Gson to read from and write to a [stream](https://sites.google.com/site/gson/streaming). You can also combine streaming and object model access to get the best of both approaches.
+
+## <a name="TOC-Issues-in-Designing-Gson"></a>Issues in Designing Gson
+
+See the [Gson design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md "Gson design document") for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.
+
+## <a name="TOC-Future-Enhancements-to-Gson"></a>Future Enhancements to Gson
+
+For the latest list of proposed enhancements or if you'd like to suggest new ones, see the [Issues section](https://github.com/google/gson/issues) under the project website.
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 000000000..28586b5ec
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,12 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
+    }
+}
+
diff --git a/examples/android-proguard-example/AndroidManifest.xml b/examples/android-proguard-example/AndroidManifest.xml
old mode 100755
new mode 100644
diff --git a/examples/android-proguard-example/proguard.cfg b/examples/android-proguard-example/proguard.cfg
index a1d8fe1ae..6c5709f3d 100644
--- a/examples/android-proguard-example/proguard.cfg
+++ b/examples/android-proguard-example/proguard.cfg
@@ -7,10 +7,16 @@
 -keepattributes *Annotation*
 
 # Gson specific classes
--keep class sun.misc.Unsafe { *; }
+-dontwarn sun.misc.**
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson
 -keep class com.google.gson.examples.android.model.** { *; }
 
+# Prevent proguard from stripping interface information from TypeAdapterFactory,
+# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
+-keep class * implements com.google.gson.TypeAdapterFactory
+-keep class * implements com.google.gson.JsonSerializer
+-keep class * implements com.google.gson.JsonDeserializer
+
 ##---------------End: proguard configuration for Gson  ----------
diff --git a/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java b/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
index 5245f448d..1273ec971 100644
--- a/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
+++ b/examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
@@ -52,6 +52,6 @@ public String getCurrencyCode() {
   @Override
   public String toString() {
     return String.format("(item: %s, qty: %s, price: %.2f %s)",
-        name, quantity, priceInMicros/(double)1000000, currencyCode);
+        name, quantity, priceInMicros / 1000000d, currencyCode);
   }
 }
diff --git a/extras/pom.xml b/extras/pom.xml
index 41e6c9c9b..1c5e76c39 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -40,9 +40,14 @@
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.3.1</version>
+      <version>2.7</version>
       <scope>compile</scope>
     </dependency>
+    <dependency>
+      <groupId>javax.annotation</groupId>
+      <artifactId>jsr250-api</artifactId>
+      <version>1.0</version>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -86,16 +91,16 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.2</version>
+        <version>3.5.1</version>
         <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
+          <source>1.6</source>
+          <target>1.6</target>
         </configuration>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>2.5</version>
+        <version>3.0.2</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -113,7 +118,7 @@
       <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
+         <version>3.0.1</version>
          <executions>
            <execution>
              <id>attach-sources</id>
@@ -127,7 +132,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.1</version>
+         <version>2.10.4</version>
          <executions>
            <execution>
              <id>attach-javadocs</id>
@@ -147,7 +152,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.9</version>
+         <version>2.10</version>
          <configuration>
            <downloadSources>true</downloadSources>
            <downloadJavadocs>true</downloadJavadocs>
diff --git a/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
new file mode 100644
index 000000000..36e06da20
--- /dev/null
+++ b/extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+public class PostConstructAdapterFactory implements TypeAdapterFactory {
+    // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+        for (Class<?> t = type.getRawType(); (t != Object.class) && (t.getSuperclass() != null); t = t.getSuperclass()) {
+            for (Method m : t.getDeclaredMethods()) {
+                if (m.isAnnotationPresent(PostConstruct.class)) {
+                    m.setAccessible(true);
+                    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+                    return new PostConstructAdapter<T>(delegate, m);
+                }
+            }
+        }
+        return null;
+    }
+
+    final static class PostConstructAdapter<T> extends TypeAdapter<T> {
+        private final TypeAdapter<T> delegate;
+        private final Method method;
+
+        public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
+            this.delegate = delegate;
+            this.method = method;
+        }
+
+        @Override public T read(JsonReader in) throws IOException {
+            T result = delegate.read(in);
+            if (result != null) {
+                try {
+                    method.invoke(result);
+                } catch (IllegalAccessException e) {
+                    throw new AssertionError();
+                } catch (InvocationTargetException e) {
+                    if (e.getCause() instanceof RuntimeException) throw (RuntimeException) e.getCause();
+                    throw new RuntimeException(e.getCause());
+                }
+            }
+            return result;
+        }
+
+        @Override public void write(JsonWriter out, T value) throws IOException {
+            delegate.write(out, value);
+        }
+    }
+}
diff --git a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
index 5bdf6e51f..bc0569cbd 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
@@ -94,11 +94,11 @@
  * "Rectangle"}) are configurable.
  *
  * <h3>Registering Types</h3>
- * Create a {@code RuntimeTypeAdapter} by passing the base type and type field
+ * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
  * name to the {@link #of} factory method. If you don't supply an explicit type
  * field name, {@code "type"} will be used. <pre>   {@code
- *   RuntimeTypeAdapter<Shape> shapeAdapter
- *       = RuntimeTypeAdapter.of(Shape.class, "type");
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
+ *       = RuntimeTypeAdapterFactory.of(Shape.class, "type");
  * }</pre>
  * Next register all of your subtypes. Every subtype must be explicitly
  * registered. This protects your application from injection attacks. If you
@@ -108,14 +108,14 @@
  *   shapeAdapter.registerSubtype(Circle.class, "Circle");
  *   shapeAdapter.registerSubtype(Diamond.class, "Diamond");
  * }</pre>
- * Finally, register the type adapter in your application's GSON builder:
+ * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapter(Shape.class, shapeAdapter)
+ *       .registerTypeAdapterFactory(shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
- *   RuntimeTypeAdapter<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
  *       .registerSubtype(Rectangle.class)
  *       .registerSubtype(Circle.class)
  *       .registerSubtype(Diamond.class);
diff --git a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
index 5e8c0ccee..1e889d373 100644
--- a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
+++ b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
@@ -229,7 +229,7 @@ private static Date parse(String date, ParsePosition pos) throws ParseException
     } catch (IllegalArgumentException e) {
       fail = e;
     }
-    String input = (date == null) ? null : ('"' + date + "'");
+    String input = (date == null) ? null : ("'" + date + "'");
     throw new ParseException("Failed to parse date [" + input + "]: " + fail.getMessage(), pos.getIndex());
   }
 
diff --git a/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
new file mode 100644
index 000000000..7bd0a520d
--- /dev/null
+++ b/extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import junit.framework.TestCase;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class PostConstructAdapterFactoryTest extends TestCase {
+    public void test() throws Exception {
+        Gson gson = new GsonBuilder()
+                .registerTypeAdapterFactory(new PostConstructAdapterFactory())
+                .create();
+        gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
+        try {
+            gson.fromJson("{\"bread\": \"cheesey bread\", \"cheese\": \"swiss\"}", Sandwich.class);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("too cheesey", expected.getMessage());
+        }
+    }
+
+    public void testList() {
+        MultipleSandwiches sandwiches = new MultipleSandwiches(Arrays.asList(
+            new Sandwich("white", "cheddar"),
+            new Sandwich("whole wheat", "swiss")));
+
+        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();
+
+        // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
+        String json = gson.toJson(sandwiches);
+        assertEquals("{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}", json);
+
+        MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
+        assertEquals(sandwiches, sandwichesFromJson);
+    }
+
+    static class Sandwich {
+        public String bread;
+        public String cheese;
+
+        public Sandwich(String bread, String cheese) {
+            this.bread = bread;
+            this.cheese = cheese;
+        }
+
+        @PostConstruct private void validate() {
+            if (bread.equals("cheesey bread") && cheese != null) {
+                throw new IllegalArgumentException("too cheesey");
+            }
+        }
+
+        public boolean equals(Object o) {
+            if (o == this) {
+                return true;
+            }
+            if (!(o instanceof Sandwich)) {
+                return false;
+            }
+            final Sandwich other = (Sandwich) o;
+            if (this.bread == null ? other.bread != null : !this.bread.equals(other.bread)) {
+                return false;
+            }
+            if (this.cheese == null ? other.cheese != null : !this.cheese.equals(other.cheese)) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    static class MultipleSandwiches {
+        public List<Sandwich> sandwiches;
+
+        public MultipleSandwiches(List<Sandwich> sandwiches) {
+            this.sandwiches = sandwiches;
+        }
+
+        public boolean equals(Object o) {
+            if (o == this) {
+                return true;
+            }
+            if (!(o instanceof MultipleSandwiches)) {
+                return false;
+            }
+            final MultipleSandwiches other = (MultipleSandwiches) o;
+            if (this.sandwiches == null ? other.sandwiches != null : !this.sandwiches.equals(other.sandwiches)) {
+                return false;
+            }
+            return true;
+        }
+    }
+}
diff --git a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
index 902dc4774..56e54290c 100644
--- a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
+++ b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
@@ -22,6 +22,7 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
+import com.google.gson.JsonParseException;
 import junit.framework.TestCase;
 
 import com.google.gson.Gson;
@@ -76,4 +77,13 @@ public void testNullDateSerialization() {
     String json = gson.toJson(null, Date.class);
     assertEquals("null", json);
   }
+
+  public void testWellFormedParseException() {
+    try {
+      gson.fromJson("2017-06-20T14:32:30", Date.class);
+      fail("No exception");
+    } catch (JsonParseException exe) {
+      assertEquals(exe.getMessage(), "java.text.ParseException: Failed to parse date ['2017-06-20T14']: 2017-06-20T14");
+    }
+  }
 }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 000000000..7a3265ee9
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 000000000..4c5f88200
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Apr 27 17:41:01 PDT 2018
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 000000000..cccdd3d51
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100755
index 000000000..f9553162f
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,84 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/gson/bnd.bnd b/gson/bnd.bnd
new file mode 100644
index 000000000..c98fcfd3c
--- /dev/null
+++ b/gson/bnd.bnd
@@ -0,0 +1,14 @@
+Bundle-SymbolicName: com.google.gson
+Bundle-Name: ${project.name}
+Bundle-Description: ${project.description}
+Bundle-Vendor: Google Gson Project
+Bundle-ContactAddress: ${project.parent.url}
+Bundle-RequiredExecutionEnvironment: J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8
+
+-removeheaders: Private-Package
+
+-exportcontents:\
+    com.google.gson,\
+    com.google.gson.annotations,\
+    com.google.gson.reflect,\
+    com.google.gson.stream
diff --git a/gson/build.gradle b/gson/build.gradle
new file mode 100644
index 000000000..04706bb95
--- /dev/null
+++ b/gson/build.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+
+group = 'com.google.code.gson'
+version = '2.8.4-SNAPSHOT'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+sourceSets.main.java.exclude("**/module-info.java")
+dependencies {
+    testCompile "junit:junit:4.12"
+}
diff --git a/gson/pom.xml b/gson/pom.xml
index 74f886e85..e1bcf0afc 100644
--- a/gson/pom.xml
+++ b/gson/pom.xml
@@ -1,246 +1,61 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson</artifactId>
-  <packaging>jar</packaging>
-  <version>2.5-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson</name>
+
   <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-    <relativePath />
+    <groupId>com.google.code.gson</groupId>
+    <artifactId>gson-parent</artifactId>
+    <version>2.8.4-SNAPSHOT</version>
   </parent>
-  <url>https://github.com/google/gson</url>
-  <description>Google Gson library</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:git:https://github.com/google/gson.git</connection>
-    <developerConnection>scm:git:https://github.com/google/gson.git</developerConnection>
-    <url>https://github.com/google/gson</url>
-    <tag>gson-${project.version}</tag>
-  </scm>
-  <issueManagement>
-    <system>Github Issue Tracking</system>
-    <url>https://github.com/google/gson/issues</url>
-  </issueManagement>
-  <distributionManagement>
-    <snapshotRepository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>Sonatype Nexus Snapshots</name>
-      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-    <repository>
-      <id>sonatype-nexus-staging</id>
-      <name>Nexus Release Repository</name>
-      <url>http://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-    </repository>
-  </distributionManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
+
+  <artifactId>gson</artifactId>
+  <name>Gson</name>
+
   <dependencies>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
-  <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.5</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>doclint-java8-disable</id>
-      <activation>
-        <jdk>[1.8,)</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-            <configuration>
-              <additionalparam>-Xdoclint:none</additionalparam>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
+
   <build>
-    <defaultGoal>package</defaultGoal>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.3</version>
+        <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
+          <includePackageNames>com.google.gson</includePackageNames>
+          <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
+          <links>
+            <link>http://docs.oracle.com/javase/6/docs/api/</link>
+          </links>
         </configuration>
       </plugin>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.6</version>
+        <groupId>biz.aQute.bnd</groupId>
+        <artifactId>bnd-maven-plugin</artifactId>
+        <version>3.1.0</version>
         <executions>
           <execution>
-            <phase>package</phase>
             <goals>
-              <goal>jar</goal>
+              <goal>bnd-process</goal>
             </goals>
           </execution>
         </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-            <manifestEntries>
-              <Bundle-RequiredExecutionEnvironment>J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8</Bundle-RequiredExecutionEnvironment>
-              <Export-Package><![CDATA[com.google.gson;version=${project.version}, com.google.gson.annotations;version=${project.version}, com.google.gson.reflect;version=${project.version}, com.google.gson.stream;version=${project.version}, com.google.gson.internal;version=${project.version}, com.google.gson.internal.bind;version=${project.version}]]></Export-Package>
-              <Bundle-Version>${project.version}</Bundle-Version>
-              <Bundle-ContactAddress>https://github.com/google/gson</Bundle-ContactAddress>
-              <Bundle-Vendor>Google Gson Project</Bundle-Vendor>
-              <Bundle-Name>${project.name}</Bundle-Name>
-              <Bundle-Description>${project.description}</Bundle-Description>
-              <Bundle-ClassPath>.</Bundle-ClassPath>
-              <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-              <Bundle-SymbolicName>com.google.gson</Bundle-SymbolicName>
-            </manifestEntries>
-          </archive>
-        </configuration>
       </plugin>
-      <plugin>
-       <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <archive>
-             <manifestEntries>
-               <Eclipse-SourceBundle>com.google.gson;version="${project.version}"</Eclipse-SourceBundle>
-               <Bundle-SymbolicName>com.google.gson.source</Bundle-SymbolicName>
-               <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-               <Bundle-Version>${project.version}</Bundle-Version>
-             </manifestEntries>
-           </archive>
-         </configuration>
-       </plugin>
-       <plugin>
-         <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.3</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <includePackageNames>com.google.gson</includePackageNames>
-           <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
-            <links>
-             <link>http://docs.oracle.com/javase/6/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>protected</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.10</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <!-- version>2.5</version -->
+        <artifactId>maven-jar-plugin</artifactId>
         <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
+          <archive>
+            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+          </archive>
         </configuration>
       </plugin>
       <plugin>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.5.5</version>
-        <configuration>
-          <descriptor>assembly-descriptor.xml</descriptor>
-          <finalName>google-gson-${project.version}</finalName>
-          <outputDirectory>target/dist</outputDirectory>
-          <workDirectory>target/assembly/work</workDirectory>
-        </configuration>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
       </plugin>
     </plugins>
   </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
 </project>
diff --git a/gson/src/main/java/com.google.gson/module-info.java b/gson/src/main/java/com.google.gson/module-info.java
new file mode 100644
index 000000000..d567d8ce5
--- /dev/null
+++ b/gson/src/main/java/com.google.gson/module-info.java
@@ -0,0 +1,8 @@
+module com.google.gson {
+	exports com.google.gson;
+	exports com.google.gson.annotations;
+	exports com.google.gson.reflect;
+	exports com.google.gson.stream;
+
+	requires java.sql;
+}
diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
index 7ea945f8d..0cbf77cea 100644
--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
@@ -16,14 +16,23 @@
 
 package com.google.gson;
 
-import java.lang.reflect.Type;
+import java.io.IOException;
 import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.text.ParseException;
+import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
-import java.util.TimeZone;
+
+import com.google.gson.internal.PreJava9DateFormatProvider;
+import com.google.gson.internal.bind.util.ISO8601Utils;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.google.gson.util.VersionUtils;
 
 /**
  * This type adapter supports three subclasses of date: Date, Timestamp, and
@@ -32,90 +41,125 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
+final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
+
+  private static final String SIMPLE_NAME = "DefaultDateTypeAdapter";
 
-  // TODO: migrate to streaming adapter
+  private final Class<? extends Date> dateType;
 
-  private final DateFormat enUsFormat;
-  private final DateFormat localFormat;
-  private final DateFormat iso8601Format;
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
 
-  DefaultDateTypeAdapter() {
-    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
-        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
   }
 
-  DefaultDateTypeAdapter(String datePattern) {
-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(new SimpleDateFormat(datePattern, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(new SimpleDateFormat(datePattern));
+    }
   }
 
-  DefaultDateTypeAdapter(int style) {
-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateInstance(style, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateInstance(style));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
+    }
   }
 
   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
-        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    this(Date.class, dateStyle, timeStyle);
+  }
+
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {
+    this.dateType = verifyDateType(dateType);
+    dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
+    }
   }
 
-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {
-    this.enUsFormat = enUsFormat;
-    this.localFormat = localFormat;
-    this.iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
-    this.iso8601Format.setTimeZone(TimeZone.getTimeZone("UTC"));
+  private static Class<? extends Date> verifyDateType(Class<? extends Date> dateType) {
+    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {
+      throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType);
+    }
+    return dateType;
   }
 
   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
   // See issue 162
   @Override
-  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
-    synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(src);
-      return new JsonPrimitive(dateFormatAsString);
+  public void write(JsonWriter out, Date value) throws IOException {
+    if (value == null) {
+      out.nullValue();
+      return;
+    }
+    synchronized(dateFormats) {
+      String dateFormatAsString = dateFormats.get(0).format(value);
+      out.value(dateFormatAsString);
     }
   }
 
   @Override
-  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
-      throws JsonParseException {
-    if (!(json instanceof JsonPrimitive)) {
-      throw new JsonParseException("The date should be a string value");
+  public Date read(JsonReader in) throws IOException {
+    if (in.peek() == JsonToken.NULL) {
+      in.nextNull();
+      return null;
     }
-    Date date = deserializeToDate(json);
-    if (typeOfT == Date.class) {
+    Date date = deserializeToDate(in.nextString());
+    if (dateType == Date.class) {
       return date;
-    } else if (typeOfT == Timestamp.class) {
+    } else if (dateType == Timestamp.class) {
       return new Timestamp(date.getTime());
-    } else if (typeOfT == java.sql.Date.class) {
+    } else if (dateType == java.sql.Date.class) {
       return new java.sql.Date(date.getTime());
     } else {
-      throw new IllegalArgumentException(getClass() + " cannot deserialize to " + typeOfT);
+      // This must never happen: dateType is guarded in the primary constructor
+      throw new AssertionError();
     }
   }
 
-  private Date deserializeToDate(JsonElement json) {
-    synchronized (localFormat) {
-      try {
-        return localFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {
+  private Date deserializeToDate(String s) {
+    synchronized (dateFormats) {
+      for (DateFormat dateFormat : dateFormats) {
+        try {
+          return dateFormat.parse(s);
+        } catch (ParseException ignored) {}
       }
       try {
-        return enUsFormat.parse(json.getAsString());
-      } catch (ParseException ignored) {
-      }
-      try {
-        return iso8601Format.parse(json.getAsString());
+        return ISO8601Utils.parse(s, new ParsePosition(0));
       } catch (ParseException e) {
-        throw new JsonSyntaxException(json.getAsString(), e);
+        throw new JsonSyntaxException(s, e);
       }
     }
   }
 
   @Override
   public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(DefaultDateTypeAdapter.class.getSimpleName());
-    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');
-    return sb.toString();
+    DateFormat defaultFormat = dateFormats.get(0);
+    if (defaultFormat instanceof SimpleDateFormat) {
+      return SIMPLE_NAME + '(' + ((SimpleDateFormat) defaultFormat).toPattern() + ')';
+    } else {
+      return SIMPLE_NAME + '(' + defaultFormat.getClass().getSimpleName() + ')';
+    }
   }
 }
diff --git a/gson/src/main/java/com/google/gson/FieldAttributes.java b/gson/src/main/java/com/google/gson/FieldAttributes.java
index cb89ff110..4ee906a60 100644
--- a/gson/src/main/java/com/google/gson/FieldAttributes.java
+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java
@@ -68,7 +68,7 @@ public String getName() {
    *   private List&lt;String&gt; red;
    * }
    *
-   * Type listParmeterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
+   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
    * </pre>
    *
    * <p>This method would return {@code String.class} for the {@code bar} field and
@@ -136,9 +136,13 @@ public boolean hasModifier(int modifier) {
   }
 
   /**
-   * This is exposed internally only for the removing synthetic fields from the JSON output.
+   * Returns the value of the field represented by this {@code Field}, on
+   * the specified object. The value is automatically wrapped in an
+   * object if it has a primitive type.
    *
-   * @return true if the field is synthetic; otherwise false
+   * @return the value of the represented field in object
+   * {@code obj}; primitive values are wrapped in an appropriate
+   * object before being returned
    * @throws IllegalAccessException
    * @throws IllegalArgumentException
    */
diff --git a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
index eecb2dbbf..1f1eb8f10 100644
--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java
@@ -114,15 +114,38 @@
     @Override public String translateName(Field f) {
       return separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
     }
+  },
+
+  /**
+   * Using this naming policy with Gson will modify the Java Field name from its camel cased
+   * form to a lower case field name where each word is separated by a dot (.).
+   *
+   * <p>Here's a few examples of the form "Java Field Name" ---> "JSON Field Name":</p>
+   * <ul>
+   *   <li>someFieldName ---> some.field.name</li>
+   *   <li>_someFieldName ---> _some.field.name</li>
+   *   <li>aStringField ---> a.string.field</li>
+   *   <li>aURL ---> a.u.r.l</li>
+   * </ul>
+   * Using dots in JavaScript is not recommended since dot is also used for a member sign in
+   * expressions. This requires that a field named with dots is always accessed as a quoted
+   * property like {@code myobject['my.field']}. Accessing it as an object field
+   * {@code myobject.my.field} will result in an unintended javascript expression.
+   * @since 2.8
+   */
+  LOWER_CASE_WITH_DOTS() {
+    @Override public String translateName(Field f) {
+      return separateCamelCase(f.getName(), ".").toLowerCase(Locale.ENGLISH);
+    }
   };
 
   /**
    * Converts the field name that uses camel-case define word separation into
    * separate words that are separated by the provided {@code separatorString}.
    */
-  private static String separateCamelCase(String name, String separator) {
+  static String separateCamelCase(String name, String separator) {
     StringBuilder translation = new StringBuilder();
-    for (int i = 0; i < name.length(); i++) {
+    for (int i = 0, length = name.length(); i < length; i++) {
       char character = name.charAt(i);
       if (Character.isUpperCase(character) && translation.length() != 0) {
         translation.append(separator);
@@ -135,12 +158,13 @@ private static String separateCamelCase(String name, String separator) {
   /**
    * Ensures the JSON field names begins with an upper case letter.
    */
-  private static String upperCaseFirstLetter(String name) {
+  static String upperCaseFirstLetter(String name) {
     StringBuilder fieldNameBuilder = new StringBuilder();
     int index = 0;
     char firstCharacter = name.charAt(index);
+    int length = name.length();
 
-    while (index < name.length() - 1) {
+    while (index < length - 1) {
       if (Character.isLetter(firstCharacter)) {
         break;
       }
@@ -149,10 +173,6 @@ private static String upperCaseFirstLetter(String name) {
       firstCharacter = name.charAt(++index);
     }
 
-    if (index == name.length()) {
-      return fieldNameBuilder.toString();
-    }
-
     if (!Character.isUpperCase(firstCharacter)) {
       String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);
       return fieldNameBuilder.append(modifiedTarget).toString();
diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index c29eada40..5b1c6c833 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -25,11 +25,13 @@
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongArray;
 
@@ -78,7 +80,7 @@
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
  * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
- * example for serializing and deserialing a {@code ParameterizedType}:
+ * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
  * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
@@ -101,7 +103,14 @@
  */
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
+  static final boolean DEFAULT_LENIENT = false;
+  static final boolean DEFAULT_PRETTY_PRINT = false;
+  static final boolean DEFAULT_ESCAPE_HTML = true;
+  static final boolean DEFAULT_SERIALIZE_NULLS = false;
+  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
+  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
+  private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
 
   /**
@@ -114,32 +123,29 @@
   private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls
       = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();
 
-  private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache
-      = Collections.synchronizedMap(new HashMap<TypeToken<?>, TypeAdapter<?>>());
+  private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
 
-  private final List<TypeAdapterFactory> factories;
   private final ConstructorConstructor constructorConstructor;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
-  private final boolean serializeNulls;
-  private final boolean htmlSafe;
-  private final boolean generateNonExecutableJson;
-  private final boolean prettyPrinting;
+  final List<TypeAdapterFactory> factories;
 
-  final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {
-    @SuppressWarnings("unchecked")
-    @Override public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-      return (T) fromJson(json, typeOfT);
-    }
-  };
-
-  final JsonSerializationContext serializationContext = new JsonSerializationContext() {
-    @Override public JsonElement serialize(Object src) {
-      return toJsonTree(src);
-    }
-    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
-      return toJsonTree(src, typeOfSrc);
-    }
-  };
+  final Excluder excluder;
+  final FieldNamingStrategy fieldNamingStrategy;
+  final Map<Type, InstanceCreator<?>> instanceCreators;
+  final boolean serializeNulls;
+  final boolean complexMapKeySerialization;
+  final boolean generateNonExecutableJson;
+  final boolean htmlSafe;
+  final boolean prettyPrinting;
+  final boolean lenient;
+  final boolean serializeSpecialFloatingPointValues;
+  final String datePattern;
+  final int dateStyle;
+  final int timeStyle;
+  final LongSerializationPolicy longSerializationPolicy;
+  final List<TypeAdapterFactory> builderFactories;
+  final List<TypeAdapterFactory> builderHierarchyFactories;
 
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
@@ -177,22 +183,39 @@
    */
   public Gson() {
     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,
-        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,
-        true, false, false, LongSerializationPolicy.DEFAULT,
+        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
+        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
+        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
+        LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
+        Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
         Collections.<TypeAdapterFactory>emptyList());
   }
 
-  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,
+  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
-      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
-      LongSerializationPolicy longSerializationPolicy,
-      List<TypeAdapterFactory> typeAdapterFactories) {
+      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
+      LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
+      int timeStyle, List<TypeAdapterFactory> builderFactories,
+      List<TypeAdapterFactory> builderHierarchyFactories,
+      List<TypeAdapterFactory> factoriesToBeAdded) {
+    this.excluder = excluder;
+    this.fieldNamingStrategy = fieldNamingStrategy;
+    this.instanceCreators = instanceCreators;
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.serializeNulls = serializeNulls;
+    this.complexMapKeySerialization = complexMapKeySerialization;
     this.generateNonExecutableJson = generateNonExecutableGson;
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
+    this.lenient = lenient;
+    this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = longSerializationPolicy;
+    this.datePattern = datePattern;
+    this.dateStyle = dateStyle;
+    this.timeStyle = timeStyle;
+    this.builderFactories = builderFactories;
+    this.builderHierarchyFactories = builderHierarchyFactories;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -203,8 +226,8 @@ public Gson() {
     // the excluder must precede all adapters that handle user-defined types
     factories.add(excluder);
 
-    // user's type adapters
-    factories.addAll(typeAdapterFactories);
+    // users' type adapters
+    factories.addAll(factoriesToBeAdded);
 
     // type adapters for basic platform types
     factories.add(TypeAdapters.STRING_FACTORY);
@@ -247,14 +270,41 @@ public Gson() {
     // type adapters for composite and user-defined types
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
-    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
+    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);
+    factories.add(jsonAdapterFactory);
     factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(new ReflectiveTypeAdapterFactory(
-        constructorConstructor, fieldNamingPolicy, excluder));
+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
 
     this.factories = Collections.unmodifiableList(factories);
   }
 
+  /**
+   * Returns a new GsonBuilder containing all custom factories and configuration used by the current
+   * instance.
+   *
+   * @return a GsonBuilder instance.
+   */
+  public GsonBuilder newBuilder() {
+    return new GsonBuilder(this);
+  }
+
+  public Excluder excluder() {
+    return excluder;
+  }
+
+  public FieldNamingStrategy fieldNamingStrategy() {
+    return fieldNamingStrategy;
+  }
+
+  public boolean serializeNulls() {
+    return serializeNulls;
+  }
+
+  public boolean htmlSafe() {
+    return htmlSafe;
+  }
+
   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
     if (serializeSpecialFloatingPointValues) {
       return TypeAdapters.DOUBLE;
@@ -303,7 +353,7 @@ public Gson() {
     };
   }
 
-  private void checkValidFloatingPoint(double value) {
+  static void checkValidFloatingPoint(double value) {
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(value
           + " is not a valid double value as per JSON specification. To override this"
@@ -380,7 +430,7 @@ private void checkValidFloatingPoint(double value) {
    */
   @SuppressWarnings("unchecked")
   public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
-    TypeAdapter<?> cached = typeTokenCache.get(type);
+    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
     if (cached != null) {
       return (TypeAdapter<T>) cached;
     }
@@ -434,9 +484,9 @@ private void checkValidFloatingPoint(double value) {
    *  class StatsTypeAdapterFactory implements TypeAdapterFactory {
    *    public int numReads = 0;
    *    public int numWrites = 0;
-   *    public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {
-   *      final TypeAdapter&lt;T&gt; delegate = gson.getDelegateAdapter(this, type);
-   *      return new TypeAdapter&lt;T&gt;() {
+   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+   *      return new TypeAdapter<T>() {
    *        public void write(JsonWriter out, T value) throws IOException {
    *          ++numWrites;
    *          delegate.write(out, value);
@@ -459,7 +509,7 @@ private void checkValidFloatingPoint(double value) {
    *  }</pre>
    *  Note that this call will skip all factories registered before {@code skipPast}. In case of
    *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure
-   *  that the order of registration does not prevent this method from reaching a factory they 
+   *  that the order of registration does not prevent this method from reaching a factory they
    *  would expect to reply from this call.
    *  Note that since you can not override type adapter factories for String and Java primitive
    *  types, our stats factory will not count the number of String or primitives that will be
@@ -472,12 +522,13 @@ private void checkValidFloatingPoint(double value) {
    * @since 2.2
    */
   public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {
-    boolean skipPastFound = false;
-    // Skip past if and only if the specified factory is present in the factories.
-    // This is useful because the factories created through JsonAdapter annotations are not
-    // registered in this list.
-    if (!factories.contains(skipPast)) skipPastFound = true;
+    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via
+    // our @JsonAdapter annotation.
+    if (!factories.contains(skipPast)) {
+      skipPast = jsonAdapterFactory;
+    }
 
+    boolean skipPastFound = false;
     for (TypeAdapterFactory factory : factories) {
       if (!skipPastFound) {
         if (factory == skipPast) {
@@ -685,7 +736,7 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
       JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
       toJson(jsonElement, jsonWriter);
     } catch (IOException e) {
-      throw new RuntimeException(e);
+      throw new JsonIOException(e);
     }
   }
 
@@ -704,6 +755,15 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
     return jsonWriter;
   }
 
+  /**
+   * Returns a new JSON reader configured for the settings on this Gson instance.
+   */
+  public JsonReader newJsonReader(Reader reader) {
+    JsonReader jsonReader = new JsonReader(reader);
+    jsonReader.setLenient(lenient);
+    return jsonReader;
+  }
+
   /**
    * Writes the JSON for {@code jsonElement} to {@code writer}.
    * @throws JsonIOException if there was a problem writing to the writer
@@ -739,7 +799,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the string from which the object is to be deserialized
    * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    * classOfT
    */
@@ -795,7 +856,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @since 1.2
    */
   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
-    JsonReader jsonReader = new JsonReader(json);
+    JsonReader jsonReader = newJsonReader(json);
     Object object = fromJson(jsonReader, classOfT);
     assertFullConsumption(object, jsonReader);
     return Primitives.wrap(classOfT).cast(object);
@@ -822,7 +883,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    */
   @SuppressWarnings("unchecked")
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
-    JsonReader jsonReader = new JsonReader(json);
+    JsonReader jsonReader = newJsonReader(json);
     T object = (T) fromJson(jsonReader, typeOfT);
     assertFullConsumption(object, jsonReader);
     return object;
@@ -955,7 +1016,7 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {
   public String toString() {
     return new StringBuilder("{serializeNulls:")
         .append(serializeNulls)
-        .append("factories:").append(factories)
+        .append(",factories:").append(factories)
         .append(",instanceCreators:").append(constructorConstructor)
         .append("}")
         .toString();
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index e6c0b8c0c..b97be452b 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -28,8 +28,18 @@
 
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
+import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+
+import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
+import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
+import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
+import static com.google.gson.Gson.DEFAULT_LENIENT;
+import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
+import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
+import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -74,15 +84,16 @@
   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();
-  private boolean serializeNulls;
+  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
   private String datePattern;
   private int dateStyle = DateFormat.DEFAULT;
   private int timeStyle = DateFormat.DEFAULT;
-  private boolean complexMapKeySerialization;
-  private boolean serializeSpecialFloatingPointValues;
-  private boolean escapeHtmlChars = true;
-  private boolean prettyPrinting;
-  private boolean generateNonExecutableJson;
+  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
+  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;
+  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
+  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
+  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+  private boolean lenient = DEFAULT_LENIENT;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -93,6 +104,31 @@
   public GsonBuilder() {
   }
 
+  /**
+   * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder
+   * has the same configuration as the previously built Gson instance.
+   *
+   * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
+   */
+  GsonBuilder(Gson gson) {
+    this.excluder = gson.excluder;
+    this.fieldNamingPolicy = gson.fieldNamingStrategy;
+    this.instanceCreators.putAll(gson.instanceCreators);
+    this.serializeNulls = gson.serializeNulls;
+    this.complexMapKeySerialization = gson.complexMapKeySerialization;
+    this.generateNonExecutableJson = gson.generateNonExecutableJson;
+    this.escapeHtmlChars = gson.htmlSafe;
+    this.prettyPrinting = gson.prettyPrinting;
+    this.lenient = gson.lenient;
+    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;
+    this.longSerializationPolicy = gson.longSerializationPolicy;
+    this.datePattern = gson.datePattern;
+    this.dateStyle = gson.dateStyle;
+    this.timeStyle = gson.timeStyle;
+    this.factories.addAll(gson.builderFactories);
+    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+  }
+
   /**
    * Configures Gson to enable versioning support.
    *
@@ -293,7 +329,7 @@ public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrateg
    * Configures Gson to apply a set of exclusion strategies during both serialization and
    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
    * This means that if one of the {@code strategies} suggests that a field (or class) should be
-   * skipped then that field (or object) is skipped during serializaiton/deserialization.
+   * skipped then that field (or object) is skipped during serialization/deserialization.
    *
    * @param strategies the set of strategy object to apply during object (de)serialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
@@ -351,6 +387,19 @@ public GsonBuilder setPrettyPrinting() {
     return this;
   }
 
+  /**
+   * By default, Gson is strict and only accepts JSON as specified by
+   * <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. This option makes the parser
+   * liberal in what it accepts.
+   *
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   * @see JsonReader#setLenient(boolean)
+   */
+  public GsonBuilder setLenient() {
+    lenient = true;
+    return this;
+  }
+
   /**
    * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure
    * Gson to pass-through HTML characters as is.
@@ -495,8 +544,7 @@ public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAd
         || typeAdapter instanceof JsonDeserializer<?>
         || typeAdapter instanceof TypeAdapter<?>);
     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
-      hierarchyFactories.add(0,
-          TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
+      hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
     }
     if (typeAdapter instanceof TypeAdapter<?>) {
       factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));
@@ -536,31 +584,44 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
    * @return an instance of Gson configured with the options currently set in this builder
    */
   public Gson create() {
-    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
+    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>(this.factories.size() + this.hierarchyFactories.size() + 3);
     factories.addAll(this.factories);
     Collections.reverse(factories);
-    factories.addAll(this.hierarchyFactories);
+
+    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>(this.hierarchyFactories);
+    Collections.reverse(hierarchyFactories);
+    factories.addAll(hierarchyFactories);
+
     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
-        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
-        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
+        generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
+        serializeSpecialFloatingPointValues, longSerializationPolicy,
+        datePattern, dateStyle, timeStyle,
+        this.factories, this.hierarchyFactories, factories);
   }
 
+  @SuppressWarnings("unchecked")
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
       List<TypeAdapterFactory> factories) {
     DefaultDateTypeAdapter dateTypeAdapter;
+    TypeAdapter<Timestamp> timestampTypeAdapter;
+    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;
     if (datePattern != null && !"".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);
     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);
     } else {
       return;
     }
 
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
+    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
   }
 }
diff --git a/gson/src/main/java/com/google/gson/JsonArray.java b/gson/src/main/java/com/google/gson/JsonArray.java
index c664a5e18..f2b3b31f5 100644
--- a/gson/src/main/java/com/google/gson/JsonArray.java
+++ b/gson/src/main/java/com/google/gson/JsonArray.java
@@ -39,14 +39,25 @@
   public JsonArray() {
     elements = new ArrayList<JsonElement>();
   }
+  
+  public JsonArray(int capacity) {
+    elements = new ArrayList<JsonElement>(capacity);
+  }
 
+  /**
+   * Creates a deep copy of this element and all its children
+   * @since 2.8.2
+   */
   @Override
-  JsonArray deepCopy() {
-    JsonArray result = new JsonArray();
-    for (JsonElement element : elements) {
-      result.add(element.deepCopy());
+  public JsonArray deepCopy() {
+    if (!elements.isEmpty()) {
+      JsonArray result = new JsonArray(elements.size());
+      for (JsonElement element : elements) {
+        result.add(element.deepCopy());
+      }
+      return result;
     }
-    return result;
+    return new JsonArray();
   }
 
   /**
@@ -162,7 +173,7 @@ public int size() {
   }
 
   /**
-   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,
+   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,
    * the iterator navigates the elements in the order they were inserted.
    *
    * @return an iterator to navigate the elements of the array.
diff --git a/gson/src/main/java/com/google/gson/JsonElement.java b/gson/src/main/java/com/google/gson/JsonElement.java
index d9cd91846..62bb920cd 100644
--- a/gson/src/main/java/com/google/gson/JsonElement.java
+++ b/gson/src/main/java/com/google/gson/JsonElement.java
@@ -34,8 +34,9 @@
   /**
    * Returns a deep copy of this element. Immutable elements like primitives
    * and nulls are not copied.
+   * @since 2.8.2
    */
-  abstract JsonElement deepCopy();
+  public abstract JsonElement deepCopy();
 
   /**
    * provides check for verifying if this element is an array or not.
@@ -103,7 +104,7 @@ public JsonArray getAsJsonArray() {
     if (isJsonArray()) {
       return (JsonArray) this;
     }
-    throw new IllegalStateException("This is not a JSON Array.");
+    throw new IllegalStateException("Not a JSON Array: " + this);
   }
 
   /**
@@ -119,7 +120,7 @@ public JsonPrimitive getAsJsonPrimitive() {
     if (isJsonPrimitive()) {
       return (JsonPrimitive) this;
     }
-    throw new IllegalStateException("This is not a JSON Primitive.");
+    throw new IllegalStateException("Not a JSON Primitive: " + this);
   }
 
   /**
@@ -136,7 +137,7 @@ public JsonNull getAsJsonNull() {
     if (isJsonNull()) {
       return (JsonNull) this;
     }
-    throw new IllegalStateException("This is not a JSON Null.");
+    throw new IllegalStateException("Not a JSON Null: " + this);
   }
 
   /**
diff --git a/gson/src/main/java/com/google/gson/JsonNull.java b/gson/src/main/java/com/google/gson/JsonNull.java
old mode 100755
new mode 100644
index 56883369e..67cb9325b
--- a/gson/src/main/java/com/google/gson/JsonNull.java
+++ b/gson/src/main/java/com/google/gson/JsonNull.java
@@ -40,8 +40,12 @@ public JsonNull() {
     // Do nothing
   }
 
+  /**
+   * Returns the same instance since it is an immutable value
+   * @since 2.8.2
+   */
   @Override
-  JsonNull deepCopy() {
+  public JsonNull deepCopy() {
     return INSTANCE;
   }
 
diff --git a/gson/src/main/java/com/google/gson/JsonObject.java b/gson/src/main/java/com/google/gson/JsonObject.java
index 78c7a177a..4b63db56c 100644
--- a/gson/src/main/java/com/google/gson/JsonObject.java
+++ b/gson/src/main/java/com/google/gson/JsonObject.java
@@ -33,8 +33,12 @@
   private final LinkedTreeMap<String, JsonElement> members =
       new LinkedTreeMap<String, JsonElement>();
 
+  /**
+   * Creates a deep copy of this element and all its children
+   * @since 2.8.2
+   */
   @Override
-  JsonObject deepCopy() {
+  public JsonObject deepCopy() {
     JsonObject result = new JsonObject();
     for (Map.Entry<String, JsonElement> entry : members.entrySet()) {
       result.add(entry.getKey(), entry.getValue().deepCopy());
@@ -132,6 +136,25 @@ private JsonElement createJsonElement(Object value) {
     return members.entrySet();
   }
 
+  /**
+   * Returns a set of members key values.
+   *
+   * @return a set of member keys as Strings
+   * @since 2.8.1
+   */
+  public Set<String> keySet() {
+    return members.keySet();
+  }
+
+  /**
+   * Returns the number of key/value pairs in the object.
+   *
+   * @return the number of key/value pairs in the object.
+   */
+  public int size() {
+    return members.size();
+  }
+
   /**
    * Convenience method to check if a member with the specified name is present in this object.
    *
diff --git a/gson/src/main/java/com/google/gson/JsonParser.java b/gson/src/main/java/com/google/gson/JsonParser.java
old mode 100755
new mode 100644
diff --git a/gson/src/main/java/com/google/gson/JsonPrimitive.java b/gson/src/main/java/com/google/gson/JsonPrimitive.java
index e2443d435..adb18fad0 100644
--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java
+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java
@@ -85,8 +85,12 @@ public JsonPrimitive(Character c) {
     setValue(primitive);
   }
 
+  /**
+   * Returns the same value as primitives are immutable.
+   * @since 2.8.2
+   */
   @Override
-  JsonPrimitive deepCopy() {
+  public JsonPrimitive deepCopy() {
     return this;
   }
 
diff --git a/gson/src/main/java/com/google/gson/annotations/Expose.java b/gson/src/main/java/com/google/gson/annotations/Expose.java
index 1b9c70df0..b66dc4f27 100644
--- a/gson/src/main/java/com/google/gson/annotations/Expose.java
+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -57,6 +58,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Expose {
diff --git a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
index 2ee3e682d..93163f858 100644
--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
+++ b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java
@@ -16,6 +16,8 @@
 
 package com.google.gson.annotations;
 
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import java.lang.annotation.ElementType;
@@ -77,8 +79,10 @@
  * adapters, which in turn take precedence over annotated types.
  *
  * <p>The class referenced by this annotation must be either a {@link
- * TypeAdapter} or a {@link TypeAdapterFactory}. Using the factory interface
- * makes it possible to delegate to the enclosing {@code Gson} instance.
+ * TypeAdapter} or a {@link TypeAdapterFactory}, or must implement one
+ * or both of {@link JsonDeserializer} or {@link JsonSerializer}. 
+ * Using {@link TypeAdapterFactory} makes it possible to delegate 
+ * to the enclosing {@code Gson} instance.
  *
  * @since 2.3
  *
@@ -91,7 +95,10 @@
 @Target({ElementType.TYPE, ElementType.FIELD})
 public @interface JsonAdapter {
 
-  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
+  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}, or one or both of {@link JsonDeserializer} or {@link JsonSerializer}. */
   Class<?> value();
 
+  /** false, to be able to handle {@code null} values within the adapter, default value is true. */
+  boolean nullSafe() default true;
+
 }
diff --git a/gson/src/main/java/com/google/gson/annotations/SerializedName.java b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
index 363b95a35..9e8e4b8d4 100644
--- a/gson/src/main/java/com/google/gson/annotations/SerializedName.java
+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -76,6 +77,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.METHOD})
 public @interface SerializedName {
diff --git a/gson/src/main/java/com/google/gson/annotations/Since.java b/gson/src/main/java/com/google/gson/annotations/Since.java
index 541f154b6..c6b218252 100644
--- a/gson/src/main/java/com/google/gson/annotations/Since.java
+++ b/gson/src/main/java/com/google/gson/annotations/Since.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -50,6 +51,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Since {
diff --git a/gson/src/main/java/com/google/gson/annotations/Until.java b/gson/src/main/java/com/google/gson/annotations/Until.java
index 4648b8a2a..676a4b959 100644
--- a/gson/src/main/java/com/google/gson/annotations/Until.java
+++ b/gson/src/main/java/com/google/gson/annotations/Until.java
@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -54,6 +55,7 @@
  * @author Joel Leitch
  * @since 1.3
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Until {
diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
index 745d07193..adea605f5 100644
--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
@@ -16,9 +16,6 @@
 
 package com.google.gson.internal;
 
-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
-
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
@@ -28,11 +25,10 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Properties;
+import java.util.*;
+
+import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
+import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
 
 /**
  * Static methods for working with types.
@@ -75,7 +71,13 @@ public static GenericArrayType arrayOf(Type componentType) {
    * this returns {@code ?}, which is shorthand for {@code ? extends Object}.
    */
   public static WildcardType subtypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);
+    Type[] upperBounds;
+    if (bound instanceof WildcardType) {
+      upperBounds = ((WildcardType) bound).getUpperBounds();
+    } else {
+      upperBounds = new Type[] { bound };
+    }
+    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
   }
 
   /**
@@ -84,7 +86,13 @@ public static WildcardType subtypeOf(Type bound) {
    * super String}.
    */
   public static WildcardType supertypeOf(Type bound) {
-    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });
+    Type[] lowerBounds;
+    if (bound instanceof WildcardType) {
+      lowerBounds = ((WildcardType) bound).getLowerBounds();
+    } else {
+      lowerBounds = new Type[] { bound };
+    }
+    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
   }
 
   /**
@@ -212,7 +220,7 @@ public static boolean equals(Type a, Type b) {
     }
   }
 
-  private static int hashCodeOrZero(Object o) {
+  static int hashCodeOrZero(Object o) {
     return o != null ? o.hashCode() : 0;
   }
 
@@ -267,6 +275,10 @@ static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResol
    * @param supertype a superclass of, or interface implemented by, this.
    */
   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+    if (context instanceof WildcardType) {
+      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead
+      context = ((WildcardType)context).getUpperBounds()[0];
+    }
     checkArgument(supertype.isAssignableFrom(contextRawType));
     return resolve(context, contextRawType,
         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
@@ -322,10 +334,21 @@ public static Type getCollectionElementType(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
+  }
+
+  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
+                              Collection<TypeVariable> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+        if (visitedTypeVariables.contains(typeVariable)) {
+          // cannot reduce due to infinite recursion
+          return toResolve;
+        } else {
+          visitedTypeVariables.add(typeVariable);
+        }
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
           return toResolve;
@@ -334,7 +357,7 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
+        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
         return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
@@ -342,7 +365,7 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof GenericArrayType) {
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
+        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
         return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
@@ -350,12 +373,12 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
       } else if (toResolve instanceof ParameterizedType) {
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
+        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
         boolean changed = newOwnerType != ownerType;
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
           if (resolvedTypeArgument != args[t]) {
             if (!changed) {
               args = args.clone();
@@ -375,12 +398,12 @@ public static Type resolve(Type context, Class<?> contextRawType, Type toResolve
         Type[] originalUpperBound = original.getUpperBounds();
 
         if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
           if (lowerBound != originalLowerBound[0]) {
             return supertypeOf(lowerBound);
           }
         } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
           if (upperBound != originalUpperBound[0]) {
             return subtypeOf(upperBound);
           }
@@ -411,7 +434,7 @@ static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVaria
   }
 
   private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
+    for (int i = 0, length = array.length; i < length; i++) {
       if (toFind.equals(array[i])) {
         return i;
       }
@@ -430,7 +453,7 @@ private static int indexOf(Object[] array, Object toFind) {
         : null;
   }
 
-  private static void checkNotPrimitive(Type type) {
+  static void checkNotPrimitive(Type type) {
     checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
   }
 
@@ -451,7 +474,7 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
       this.ownerType = ownerType == null ? null : canonicalize(ownerType);
       this.rawType = canonicalize(rawType);
       this.typeArguments = typeArguments.clone();
-      for (int t = 0; t < this.typeArguments.length; t++) {
+      for (int t = 0, length = this.typeArguments.length; t < length; t++) {
         checkNotNull(this.typeArguments[t]);
         checkNotPrimitive(this.typeArguments[t]);
         this.typeArguments[t] = canonicalize(this.typeArguments[t]);
@@ -482,15 +505,14 @@ public Type getOwnerType() {
     }
 
     @Override public String toString() {
-      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));
-      stringBuilder.append(typeToString(rawType));
-
-      if (typeArguments.length == 0) {
-        return stringBuilder.toString();
+      int length = typeArguments.length;
+      if (length == 0) {
+        return typeToString(rawType);
       }
 
-      stringBuilder.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
+      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));
+      stringBuilder.append(typeToString(rawType)).append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < length; i++) {
         stringBuilder.append(", ").append(typeToString(typeArguments[i]));
       }
       return stringBuilder.append(">").toString();
diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
index 6fc9f2d3e..5fab46010 100644
--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
@@ -20,12 +20,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -40,6 +40,7 @@
 
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonIOException;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 
 /**
@@ -47,6 +48,7 @@
  */
 public final class ConstructorConstructor {
   private final Map<Type, InstanceCreator<?>> instanceCreators;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     this.instanceCreators = instanceCreators;
@@ -98,7 +100,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     try {
       final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
       if (!constructor.isAccessible()) {
-        constructor.setAccessible(true);
+        accessor.makeAccessible(constructor);
       }
       return new ObjectConstructor<T>() {
         @SuppressWarnings("unchecked") // T is the same raw type as is requested
@@ -163,7 +165,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
       } else if (Queue.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
           @Override public T construct() {
-            return (T) new LinkedList<Object>();
+            return (T) new ArrayDeque<Object>();
           }
         };
       } else {
@@ -224,7 +226,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
+              + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
         }
       }
     };
diff --git a/gson/src/main/java/com/google/gson/internal/Excluder.java b/gson/src/main/java/com/google/gson/internal/Excluder.java
index bef790406..6b83757ed 100644
--- a/gson/src/main/java/com/google/gson/internal/Excluder.java
+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java
@@ -110,8 +110,10 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
 
   public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
-    final boolean skipSerialize = excludeClass(rawType, true);
-    final boolean skipDeserialize = excludeClass(rawType, false);
+    boolean excludeClass = excludeClassChecks(rawType);
+
+    final boolean skipSerialize = excludeClass || excludeClassInStrategy(rawType, true);
+    final boolean skipDeserialize = excludeClass ||  excludeClassInStrategy(rawType, false);
 
     if (!skipSerialize && !skipDeserialize) {
       return null;
@@ -188,28 +190,35 @@ public boolean excludeField(Field field, boolean serialize) {
     return false;
   }
 
-  public boolean excludeClass(Class<?> clazz, boolean serialize) {
-    if (version != Excluder.IGNORE_VERSIONS
-        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
-      return true;
-    }
-
-    if (!serializeInnerClasses && isInnerClass(clazz)) {
-      return true;
-    }
+  private boolean excludeClassChecks(Class<?> clazz) {
+      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {
+          return true;
+      }
 
-    if (isAnonymousOrLocal(clazz)) {
-      return true;
-    }
+      if (!serializeInnerClasses && isInnerClass(clazz)) {
+          return true;
+      }
 
-    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
-    for (ExclusionStrategy exclusionStrategy : list) {
-      if (exclusionStrategy.shouldSkipClass(clazz)) {
-        return true;
+      if (isAnonymousOrLocal(clazz)) {
+          return true;
       }
-    }
 
-    return false;
+      return false;
+  }
+
+  public boolean excludeClass(Class<?> clazz, boolean serialize) {
+      return excludeClassChecks(clazz) ||
+              excludeClassInStrategy(clazz, serialize);
+  }
+
+  private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
+      List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;
+      for (ExclusionStrategy exclusionStrategy : list) {
+          if (exclusionStrategy.shouldSkipClass(clazz)) {
+              return true;
+          }
+      }
+      return false;
   }
 
   private boolean isAnonymousOrLocal(Class<?> clazz) {
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java b/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
index e251ec2f7..b2707c50d 100644
--- a/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
+++ b/gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
@@ -762,6 +762,9 @@ void add(Node<K, V> node) {
     Node<K, V> lastReturned = null;
     int expectedModCount = modCount;
 
+    LinkedTreeMapIterator() {
+    }
+
     public final boolean hasNext() {
       return next != header;
     }
diff --git a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
index c2c84802a..80462742e 100644
--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
@@ -528,6 +528,9 @@ public V setValue(V value) {
     Node<K, V> lastReturned = null;
     int expectedModCount = modCount;
 
+    LinkedTreeMapIterator() {
+    }
+
     public final boolean hasNext() {
       return next != header;
     }
@@ -624,4 +627,4 @@ public K next() {
   private Object writeReplace() throws ObjectStreamException {
     return new LinkedHashMap<K, V>(this);
   }
-}
\ No newline at end of file
+}
diff --git a/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
new file mode 100644
index 000000000..beb527c9e
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Locale;
+
+/**
+ * Provides DateFormats for US locale with patterns which were the default ones before Java 9.
+ */
+public class PreJava9DateFormatProvider {
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below.
+   */
+  public static DateFormat getUSDateFormat(int style) {
+    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);
+  }
+
+  /**
+   * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}
+   * in Java 8 or below.
+   */
+  public static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {
+    String pattern = getDatePartOfDateTimePattern(dateStyle) + " " + getTimePartOfDateTimePattern(timeStyle);
+    return new SimpleDateFormat(pattern, Locale.US);
+  }
+
+  private static String getDateFormatPattern(int style) {
+    switch (style) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, y";
+    case DateFormat.LONG:
+      return "MMMM d, y";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, y";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + style);
+    }
+  }
+
+  private static String getDatePartOfDateTimePattern(int dateStyle) {
+    switch (dateStyle) {
+    case DateFormat.SHORT:
+      return "M/d/yy";
+    case DateFormat.MEDIUM:
+      return "MMM d, yyyy";
+    case DateFormat.LONG:
+      return "MMMM d, yyyy";
+    case DateFormat.FULL:
+      return "EEEE, MMMM d, yyyy";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + dateStyle);
+    }
+  }
+
+  private static String getTimePartOfDateTimePattern(int timeStyle) {
+    switch (timeStyle) {
+    case DateFormat.SHORT:
+      return "h:mm a";
+    case DateFormat.MEDIUM:
+      return "h:mm:ss a";
+    case DateFormat.FULL:
+    case DateFormat.LONG:
+      return "h:mm:ss a z";
+    default:
+      throw new IllegalArgumentException("Unknown DateFormat style: " + timeStyle);
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java
index 7f00f11d9..ac99910a9 100644
--- a/gson/src/main/java/com/google/gson/internal/Streams.java
+++ b/gson/src/main/java/com/google/gson/internal/Streams.java
@@ -72,7 +72,6 @@ public static void write(JsonElement element, JsonWriter writer) throws IOExcept
     TypeAdapters.JSON_ELEMENT.write(writer, element);
   }
 
-  @SuppressWarnings("resource")
   public static Writer writerForAppendable(Appendable appendable) {
     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
   }
@@ -85,7 +84,7 @@ public static Writer writerForAppendable(Appendable appendable) {
     private final Appendable appendable;
     private final CurrentWrite currentWrite = new CurrentWrite();
 
-    private AppendableWriter(Appendable appendable) {
+    AppendableWriter(Appendable appendable) {
       this.appendable = appendable;
     }
 
diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
index fce0be379..999a2b57e 100644
--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
@@ -20,6 +20,7 @@
 import java.io.ObjectStreamClass;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 
 /**
  * Do sneaky things to allocate objects without invoking their constructors.
@@ -45,6 +46,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings("unchecked")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) allocateInstance.invoke(unsafe, c);
         }
       };
@@ -68,6 +70,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings("unchecked")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) newInstance.invoke(null, c, constructorId);
         }
       };
@@ -87,6 +90,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings("unchecked")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) newInstance.invoke(null, c, Object.class);
         }
       };
@@ -101,4 +105,19 @@ public static UnsafeAllocator create() {
       }
     };
   }
+
+  /**
+   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
+   * throw an {@link java.lang.UnsupportedOperationException}
+   * @param c instance of the class to be checked
+   */
+  static void assertInstantiable(Class<?> c) {
+    int modifiers = c.getModifiers();
+    if (Modifier.isInterface(modifiers)) {
+      throw new UnsupportedOperationException("Interface can't be instantiated! Interface name: " + c.getName());
+    }
+    if (Modifier.isAbstract(modifiers)) {
+      throw new UnsupportedOperationException("Abstract class can't be instantiated! Class name: " + c.getName());
+    }
+  }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
index 3fb7c0568..56101706b 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
@@ -73,8 +73,10 @@ public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class
       list.add(instance);
     }
     in.endArray();
-    Object array = Array.newInstance(componentType, list.size());
-    for (int i = 0; i < list.size(); i++) {
+
+    int size = list.size();
+    Object array = Array.newInstance(componentType, size);
+    for (int i = 0; i < size; i++) {
       Array.set(array, i, list.get(i));
     }
     return array;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
index 2e1d282bb..c3a3de1b5 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
@@ -20,17 +20,22 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.PreJava9DateFormatProvider;
+import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+import com.google.gson.util.VersionUtils;
+
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
-import java.text.SimpleDateFormat;
+import java.text.ParsePosition;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
-import java.util.TimeZone;
 
 /**
  * Adapter for Date. Although this class appears stateless, it is not.
@@ -46,16 +51,20 @@
     }
   };
 
-  private final DateFormat enUsFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);
-  private final DateFormat localFormat
-      = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);
-  private final DateFormat iso8601Format = buildIso8601Format();
+  /**
+   * List of 1 or more different date formats used for de-serialization attempts.
+   * The first of them (default US format) is used for serialization as well.
+   */
+  private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
 
-  private static DateFormat buildIso8601Format() {
-    DateFormat iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
-    iso8601Format.setTimeZone(TimeZone.getTimeZone("UTC"));
-    return iso8601Format;
+  public DateTypeAdapter() {
+    dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
+    if (!Locale.getDefault().equals(Locale.US)) {
+      dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
+    if (VersionUtils.isJava9OrLater()) {
+      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
+    }
   }
 
   @Override public Date read(JsonReader in) throws IOException {
@@ -67,16 +76,13 @@ private static DateFormat buildIso8601Format() {
   }
 
   private synchronized Date deserializeToDate(String json) {
-    try {
-      return localFormat.parse(json);
-    } catch (ParseException ignored) {
-    }
-    try {
-      return enUsFormat.parse(json);
-    } catch (ParseException ignored) {
+    for (DateFormat dateFormat : dateFormats) {
+      try {
+        return dateFormat.parse(json);
+      } catch (ParseException ignored) {}
     }
     try {
-      return iso8601Format.parse(json);
+    	return ISO8601Utils.parse(json, new ParsePosition(0));
     } catch (ParseException e) {
       throw new JsonSyntaxException(json, e);
     }
@@ -87,7 +93,9 @@ private synchronized Date deserializeToDate(String json) {
       out.nullValue();
       return;
     }
-    String dateFormatAsString = enUsFormat.format(value);
+    String dateFormatAsString = dateFormats.get(0).format(value);
     out.value(dateFormatAsString);
   }
+  
+  
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
index 77554e221..13a7bb7eb 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
@@ -17,6 +17,8 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.Gson;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
@@ -30,7 +32,6 @@
  * @since 2.3
  */
 public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {
-
   private final ConstructorConstructor constructorConstructor;
 
   public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {
@@ -40,29 +41,43 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
   @SuppressWarnings("unchecked")
   @Override
   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {
-    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);
+    Class<? super T> rawType = targetType.getRawType();
+    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);
     if (annotation == null) {
       return null;
     }
     return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);
   }
 
-  @SuppressWarnings("unchecked") // Casts guarded by conditionals.
-  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
-      TypeToken<?> fieldType, JsonAdapter annotation) {
-    Class<?> value = annotation.value();
-    if (TypeAdapter.class.isAssignableFrom(value)) {
-          Class<TypeAdapter<?>> typeAdapter = (Class<TypeAdapter<?>>) value;
-      return constructorConstructor.get(TypeToken.get(typeAdapter)).construct();
+  @SuppressWarnings({ "unchecked", "rawtypes" }) // Casts guarded by conditionals.
+  TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
+      TypeToken<?> type, JsonAdapter annotation) {
+    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();
+
+    TypeAdapter<?> typeAdapter;
+    if (instance instanceof TypeAdapter) {
+      typeAdapter = (TypeAdapter<?>) instance;
+    } else if (instance instanceof TypeAdapterFactory) {
+      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);
+    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {
+      JsonSerializer<?> serializer = instance instanceof JsonSerializer
+          ? (JsonSerializer) instance
+          : null;
+      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer
+          ? (JsonDeserializer) instance
+          : null;
+      typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);
+    } else {
+      throw new IllegalArgumentException("Invalid attempt to bind an instance of "
+          + instance.getClass().getName() + " as a @JsonAdapter for " + type.toString()
+          + ". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,"
+          + " JsonSerializer or JsonDeserializer.");
     }
-    if (TypeAdapterFactory.class.isAssignableFrom(value)) {
-          Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;
-      return constructorConstructor.get(TypeToken.get(typeAdapterFactory))
-          .construct()
-          .create(gson, fieldType);
+
+    if (typeAdapter != null && annotation.nullSafe()) {
+      typeAdapter = typeAdapter.nullSafe();
     }
 
-    throw new IllegalArgumentException(
-        "@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.");
+    return typeAdapter;
   }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
index 6a8362805..387b29e9b 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
@@ -25,9 +25,7 @@
 import com.google.gson.stream.JsonToken;
 import java.io.IOException;
 import java.io.Reader;
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -47,35 +45,57 @@
   };
   private static final Object SENTINEL_CLOSED = new Object();
 
-  private final List<Object> stack = new ArrayList<Object>();
+  /*
+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+   */
+  private Object[] stack = new Object[32];
+  private int stackSize = 0;
+
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
 
   public JsonTreeReader(JsonElement element) {
     super(UNREADABLE_READER);
-    stack.add(element);
+    push(element);
   }
 
   @Override public void beginArray() throws IOException {
     expect(JsonToken.BEGIN_ARRAY);
     JsonArray array = (JsonArray) peekStack();
-    stack.add(array.iterator());
+    push(array.iterator());
+    pathIndices[stackSize - 1] = 0;
   }
 
   @Override public void endArray() throws IOException {
     expect(JsonToken.END_ARRAY);
     popStack(); // empty iterator
     popStack(); // array
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public void beginObject() throws IOException {
     expect(JsonToken.BEGIN_OBJECT);
     JsonObject object = (JsonObject) peekStack();
-    stack.add(object.entrySet().iterator());
+    push(object.entrySet().iterator());
   }
 
   @Override public void endObject() throws IOException {
     expect(JsonToken.END_OBJECT);
     popStack(); // empty iterator
     popStack(); // object
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public boolean hasNext() throws IOException {
@@ -84,19 +104,19 @@ public JsonTreeReader(JsonElement element) {
   }
 
   @Override public JsonToken peek() throws IOException {
-    if (stack.isEmpty()) {
+    if (stackSize == 0) {
       return JsonToken.END_DOCUMENT;
     }
 
     Object o = peekStack();
     if (o instanceof Iterator) {
-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;
       Iterator<?> iterator = (Iterator<?>) o;
       if (iterator.hasNext()) {
         if (isObject) {
           return JsonToken.NAME;
         } else {
-          stack.add(iterator.next());
+          push(iterator.next());
           return peek();
         }
       } else {
@@ -127,16 +147,19 @@ public JsonTreeReader(JsonElement element) {
   }
 
   private Object peekStack() {
-    return stack.get(stack.size() - 1);
+    return stack[stackSize - 1];
   }
 
   private Object popStack() {
-    return stack.remove(stack.size() - 1);
+    Object result = stack[--stackSize];
+    stack[stackSize] = null;
+    return result;
   }
 
   private void expect(JsonToken expected) throws IOException {
     if (peek() != expected) {
-      throw new IllegalStateException("Expected " + expected + " but was " + peek());
+      throw new IllegalStateException(
+          "Expected " + expected + " but was " + peek() + locationString());
     }
   }
 
@@ -144,71 +167,104 @@ private void expect(JsonToken expected) throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    return (String) entry.getKey();
+    String result = (String) entry.getKey();
+    pathNames[stackSize - 1] = result;
+    push(entry.getValue());
+    return result;
   }
 
   @Override public String nextString() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
-      throw new IllegalStateException("Expected " + JsonToken.STRING + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.STRING + " but was " + token + locationString());
+    }
+    String result = ((JsonPrimitive) popStack()).getAsString();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
-    return ((JsonPrimitive) popStack()).getAsString();
+    return result;
   }
 
   @Override public boolean nextBoolean() throws IOException {
     expect(JsonToken.BOOLEAN);
-    return ((JsonPrimitive) popStack()).getAsBoolean();
+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
+    return result;
   }
 
   @Override public void nextNull() throws IOException {
     expect(JsonToken.NULL);
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public double nextDouble() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     double result = ((JsonPrimitive) peekStack()).getAsDouble();
     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
       throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
     }
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public long nextLong() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     long result = ((JsonPrimitive) peekStack()).getAsLong();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public int nextInt() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
+      throw new IllegalStateException(
+          "Expected " + JsonToken.NUMBER + " but was " + token + locationString());
     }
     int result = ((JsonPrimitive) peekStack()).getAsInt();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public void close() throws IOException {
-    stack.clear();
-    stack.add(SENTINEL_CLOSED);
+    stack = new Object[] { SENTINEL_CLOSED };
+    stackSize = 1;
   }
 
   @Override public void skipValue() throws IOException {
     if (peek() == JsonToken.NAME) {
       nextName();
+      pathNames[stackSize - 2] = "null";
     } else {
       popStack();
+      if (stackSize > 0) {
+        pathNames[stackSize - 1] = "null";
+      }
+    }
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
   }
 
@@ -220,7 +276,45 @@ public void promoteNameToValue() throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    stack.add(new JsonPrimitive((String)entry.getKey()));
+    push(entry.getValue());
+    push(new JsonPrimitive((String) entry.getKey()));
+  }
+
+  private void push(Object newTop) {
+    if (stackSize == stack.length) {
+      Object[] newStack = new Object[stackSize * 2];
+      int[] newPathIndices = new int[stackSize * 2];
+      String[] newPathNames = new String[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
+      stack = newStack;
+      pathIndices = newPathIndices;
+      pathNames = newPathNames;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  @Override public String getPath() {
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0; i < stackSize; i++) {
+      if (stack[i] instanceof JsonArray) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('[').append(pathIndices[i]).append(']');
+        }
+      } else if (stack[i] instanceof JsonObject) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+        }
+      }
+    }
+    return result.toString();
+  }
+
+  private String locationString() {
+    return " at path " + getPath();
   }
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
index 5f9f0395d..51dc1f3a3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
@@ -159,6 +159,14 @@ private void put(JsonElement value) {
     return this;
   }
 
+  @Override public JsonWriter value(Boolean value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    put(new JsonPrimitive(value));
+    return this;
+  }
+
   @Override public JsonWriter value(double value) throws IOException {
     if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value);
diff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
index 9c82a3965..5a34a5d5f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
@@ -104,7 +104,7 @@
  */
 public final class MapTypeAdapterFactory implements TypeAdapterFactory {
   private final ConstructorConstructor constructorConstructor;
-  private final boolean complexMapKeySerialization;
+  final boolean complexMapKeySerialization;
 
   public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       boolean complexMapKeySerialization) {
@@ -224,7 +224,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 
       if (hasComplexKeys) {
         out.beginArray();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           out.beginArray(); // entry array
           Streams.write(keys.get(i), out);
           valueTypeAdapter.write(out, values.get(i));
@@ -233,7 +233,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
         out.endArray();
       } else {
         out.beginObject();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           JsonElement keyElement = keys.get(i);
           out.name(keyToString(keyElement));
           valueTypeAdapter.write(out, values.get(i));
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
index 12889933d..ec42e0482 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
@@ -47,7 +47,7 @@
 
   private final Gson gson;
 
-  private ObjectTypeAdapter(Gson gson) {
+  ObjectTypeAdapter(Gson gson) {
     this.gson = gson;
   }
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
index 960153aa0..777e7dee3 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
@@ -16,16 +16,6 @@
 
 package com.google.gson.internal.bind;
 
-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
@@ -38,10 +28,19 @@
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -50,12 +49,16 @@
   private final ConstructorConstructor constructorConstructor;
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {
+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {
     this.constructorConstructor = constructorConstructor;
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.excluder = excluder;
+    this.jsonAdapterFactory = jsonAdapterFactory;
   }
 
   public boolean excludeField(Field f, boolean serialize) {
@@ -68,20 +71,22 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 
   /** first element holds the default name */
   private List<String> getFieldNames(Field f) {
-    return getFieldName(fieldNamingPolicy, f);
-  }
+    SerializedName annotation = f.getAnnotation(SerializedName.class);
+    if (annotation == null) {
+      String name = fieldNamingPolicy.translateName(f);
+      return Collections.singletonList(name);
+    }
 
-  /** first element holds the default name */
-  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {
-    SerializedName serializedName = f.getAnnotation(SerializedName.class);
-    List<String> fieldNames = new LinkedList<String>();
-    if (serializedName == null) {
-      fieldNames.add(fieldNamingPolicy.translateName(f));
-    } else {
-      fieldNames.add(serializedName.value());
-      for (String alternate : serializedName.alternate()) {
-        fieldNames.add(alternate);
-      }
+    String serializedName = annotation.value();
+    String[] alternates = annotation.alternate();
+    if (alternates.length == 0) {
+      return Collections.singletonList(serializedName);
+    }
+
+    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);
+    fieldNames.add(serializedName);
+    for (String alternate : alternates) {
+      fieldNames.add(alternate);
     }
     return fieldNames;
   }
@@ -102,14 +107,23 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+    TypeAdapter<?> mapped = null;
+    if (annotation != null) {
+      mapped = jsonAdapterFactory.getTypeAdapter(
+          constructorConstructor, context, fieldType, annotation);
+    }
+    final boolean jsonAdapterPresent = mapped != null;
+    if (mapped == null) mapped = context.getAdapter(fieldType);
+
+    final TypeAdapter<?> typeAdapter = mapped;
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);
       @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
-        TypeAdapter t =
-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());
+        TypeAdapter t = jsonAdapterPresent ? typeAdapter
+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
@@ -127,15 +141,6 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     };
   }
 
-  private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {
-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
-    if (annotation != null) {
-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);
-      if (adapter != null) return adapter;
-    }
-    return gson.getAdapter(fieldType);
-  }
-
   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
     if (raw.isInterface()) {
@@ -151,11 +156,11 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
         if (!serialize && !deserialize) {
           continue;
         }
-        field.setAccessible(true);
+        accessor.makeAccessible(field);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;
-        for (int i = 0; i < fieldNames.size(); ++i) {
+        for (int i = 0, size = fieldNames.size(); i < size; ++i) {
           String name = fieldNames.get(i);
           if (i != 0) serialize = false; // only serialize the default name
           BoundField boundField = createBoundField(context, field, name,
@@ -193,7 +198,7 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
     private final ObjectConstructor<T> constructor;
     private final Map<String, BoundField> boundFields;
 
-    private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
       this.constructor = constructor;
       this.boundFields = boundFields;
     }
diff --git a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
similarity index 77%
rename from gson/src/main/java/com/google/gson/TreeTypeAdapter.java
rename to gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index ef0909095..a5c6c5dcd 100644
--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -14,31 +14,42 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
+import java.lang.reflect.Type;
 
 /**
  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the
  * tree adapter may be serialization-only or deserialization-only, this class
  * has a facility to lookup a delegate type adapter on demand.
  */
-final class TreeTypeAdapter<T> extends TypeAdapter<T> {
+public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final JsonSerializer<T> serializer;
   private final JsonDeserializer<T> deserializer;
-  private final Gson gson;
+  final Gson gson;
   private final TypeToken<T> typeToken;
   private final TypeAdapterFactory skipPast;
+  private final GsonContextImpl context = new GsonContextImpl();
 
   /** The delegate is lazily created because it may not be needed, and creating it may fail. */
   private TypeAdapter<T> delegate;
 
-  private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
+  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
     this.serializer = serializer;
     this.deserializer = deserializer;
@@ -55,7 +66,7 @@ private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseri
     if (value.isJsonNull()) {
       return null;
     }
-    return deserializer.deserialize(value, typeToken.getType(), gson.deserializationContext);
+    return deserializer.deserialize(value, typeToken.getType(), context);
   }
 
   @Override public void write(JsonWriter out, T value) throws IOException {
@@ -67,7 +78,7 @@ private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseri
       out.nullValue();
       return;
     }
-    JsonElement tree = serializer.serialize(value, typeToken.getType(), gson.serializationContext);
+    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);
     Streams.write(tree, out);
   }
 
@@ -105,14 +116,14 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
     return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);
   }
 
-  private static class SingleTypeFactory implements TypeAdapterFactory {
+  private static final class SingleTypeFactory implements TypeAdapterFactory {
     private final TypeToken<?> exactType;
     private final boolean matchRawType;
     private final Class<?> hierarchyType;
     private final JsonSerializer<?> serializer;
     private final JsonDeserializer<?> deserializer;
 
-    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
+    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
         Class<?> hierarchyType) {
       serializer = typeAdapter instanceof JsonSerializer
           ? (JsonSerializer<?>) typeAdapter
@@ -138,4 +149,17 @@ private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean ma
           : null;
     }
   }
+
+  private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
+    @Override public JsonElement serialize(Object src) {
+      return gson.toJsonTree(src);
+    }
+    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
+      return gson.toJsonTree(src, typeOfSrc);
+    }
+    @SuppressWarnings("unchecked")
+    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
+      return (R) gson.fromJson(json, typeOfT);
+    }
+  };
 }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
index 7e52c27d2..2bf37ad0a 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
@@ -15,14 +15,15 @@
  */
 package com.google.gson.internal.bind;
 
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
 
 final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
   private final Gson context;
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 0d6d013c1..354ce5a1f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -69,33 +69,20 @@ private TypeAdapters() {
   public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {
     @Override
     public void write(JsonWriter out, Class value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-      } else {
-        throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
-            + value.getName() + ". Forgot to register a type adapter?");
-      }
+      throw new UnsupportedOperationException("Attempted to serialize java.lang.Class: "
+              + value.getName() + ". Forgot to register a type adapter?");
     }
     @Override
     public Class read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      } else {
-        throw new UnsupportedOperationException(
-            "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
-      }
+      throw new UnsupportedOperationException(
+              "Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?");
     }
-  };
+  }.nullSafe();
+
   public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);
 
   public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {
     @Override public BitSet read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
-        in.nextNull();
-        return null;
-      }
-
       BitSet bitset = new BitSet();
       in.beginArray();
       int i = 0;
@@ -132,29 +119,25 @@ public Class read(JsonReader in) throws IOException {
     }
 
     @Override public void write(JsonWriter out, BitSet src) throws IOException {
-      if (src == null) {
-        out.nullValue();
-        return;
-      }
-
       out.beginArray();
-      for (int i = 0; i < src.length(); i++) {
+      for (int i = 0, length = src.length(); i < length; i++) {
         int value = (src.get(i)) ? 1 : 0;
         out.value(value);
       }
       out.endArray();
     }
-  };
+  }.nullSafe();
 
   public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);
 
   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
     @Override
     public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
+      JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
         in.nextNull();
         return null;
-      } else if (in.peek() == JsonToken.STRING) {
+      } else if (peek == JsonToken.STRING) {
         // support strings for compatibility with GSON 1.7
         return Boolean.parseBoolean(in.nextString());
       }
@@ -162,10 +145,6 @@ public Boolean read(JsonReader in) throws IOException {
     }
     @Override
     public void write(JsonWriter out, Boolean value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
       out.value(value);
     }
   };
@@ -372,6 +351,7 @@ public Number read(JsonReader in) throws IOException {
         in.nextNull();
         return null;
       case NUMBER:
+      case STRING:
         return new LazilyParsedNumber(in.nextString());
       default:
         throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
@@ -809,7 +789,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
           constantToName.put(constant, name);
         }
       } catch (NoSuchFieldException e) {
-        throw new AssertionError("Missing field in " + classOfT.getName(), e);
+        throw new AssertionError(e);
       }
     }
     @Override public T read(JsonReader in) throws IOException {
@@ -925,4 +905,4 @@ public EnumTypeAdapter(Class<T> classOfT) {
       }
     };
   }
-}
+}
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
new file mode 100644
index 000000000..99ec679a7
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
@@ -0,0 +1,352 @@
+package com.google.gson.internal.bind.util;
+
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.util.*;
+
+/**
+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
+ * highly suitable if you (un)serialize lots of date objects.
+ * 
+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
+ * 
+ * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
+ */
+//Date parsing code from Jackson databind ISO8601Utils.java
+// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+public class ISO8601Utils
+{
+    /**
+     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
+     * 
+     * @since 2.7
+     */
+    private static final String UTC_ID = "UTC";
+    /**
+     * The UTC timezone, prefetched to avoid more lookups.
+     * 
+     * @since 2.7
+     */
+    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
+
+    /*
+    /**********************************************************
+    /* Formatting
+    /**********************************************************
+     */
+
+    /**
+     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
+     * 
+     * @param date the date to format
+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'
+     */
+    public static String format(Date date) {
+        return format(date, false, TIMEZONE_UTC);
+    }
+
+    /**
+     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)
+     * 
+     * @param date the date to format
+     * @param millis true to include millis precision otherwise false
+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'
+     */
+    public static String format(Date date, boolean millis) {
+        return format(date, millis, TIMEZONE_UTC);
+    }
+
+    /**
+     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
+     * 
+     * @param date the date to format
+     * @param millis true to include millis precision otherwise false
+     * @param tz timezone to use for the formatting (UTC will produce 'Z')
+     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]
+     */
+    public static String format(Date date, boolean millis, TimeZone tz) {
+        Calendar calendar = new GregorianCalendar(tz, Locale.US);
+        calendar.setTime(date);
+
+        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
+        int capacity = "yyyy-MM-ddThh:mm:ss".length();
+        capacity += millis ? ".sss".length() : 0;
+        capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length();
+        StringBuilder formatted = new StringBuilder(capacity);
+
+        padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
+        formatted.append('-');
+        padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
+        formatted.append('-');
+        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
+        formatted.append('T');
+        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
+        formatted.append(':');
+        padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
+        formatted.append(':');
+        padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
+        if (millis) {
+            formatted.append('.');
+            padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
+        }
+
+        int offset = tz.getOffset(calendar.getTimeInMillis());
+        if (offset != 0) {
+            int hours = Math.abs((offset / (60 * 1000)) / 60);
+            int minutes = Math.abs((offset / (60 * 1000)) % 60);
+            formatted.append(offset < 0 ? '-' : '+');
+            padInt(formatted, hours, "hh".length());
+            formatted.append(':');
+            padInt(formatted, minutes, "mm".length());
+        } else {
+            formatted.append('Z');
+        }
+
+        return formatted.toString();
+    }
+
+    /*
+    /**********************************************************
+    /* Parsing
+    /**********************************************************
+     */
+
+    /**
+     * Parse a date from ISO-8601 formatted string. It expects a format
+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
+     * 
+     * @param date ISO string to parse in the appropriate format.
+     * @param pos The position to start parsing from, updated to where parsing stopped.
+     * @return the parsed date
+     * @throws ParseException if the date is not in the appropriate format
+     */
+    public static Date parse(String date, ParsePosition pos) throws ParseException {
+        Exception fail = null;
+        try {
+            int offset = pos.getIndex();
+
+            // extract year
+            int year = parseInt(date, offset, offset += 4);
+            if (checkOffset(date, offset, '-')) {
+                offset += 1;
+            }
+
+            // extract month
+            int month = parseInt(date, offset, offset += 2);
+            if (checkOffset(date, offset, '-')) {
+                offset += 1;
+            }
+
+            // extract day
+            int day = parseInt(date, offset, offset += 2);
+            // default time value
+            int hour = 0;
+            int minutes = 0;
+            int seconds = 0;
+            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
+
+            // if the value has no time component (and no time zone), we are done
+            boolean hasT = checkOffset(date, offset, 'T');
+            
+            if (!hasT && (date.length() <= offset)) {
+                Calendar calendar = new GregorianCalendar(year, month - 1, day);
+
+                pos.setIndex(offset);
+                return calendar.getTime();
+            }
+
+            if (hasT) {
+
+                // extract hours, minutes, seconds and milliseconds
+                hour = parseInt(date, offset += 1, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+
+                minutes = parseInt(date, offset, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+                // second and milliseconds can be optional
+                if (date.length() > offset) {
+                    char c = date.charAt(offset);
+                    if (c != 'Z' && c != '+' && c != '-') {
+                        seconds = parseInt(date, offset, offset += 2);
+                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
+                        // milliseconds can be optional in the format
+                        if (checkOffset(date, offset, '.')) {
+                            offset += 1;
+                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
+                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
+                            int fraction = parseInt(date, offset, parseEndOffset);
+                            // compensate for "missing" digits
+                            switch (parseEndOffset - offset) { // number of digits parsed
+                            case 2:
+                                milliseconds = fraction * 10;
+                                break;
+                            case 1:
+                                milliseconds = fraction * 100;
+                                break;
+                            default:
+                                milliseconds = fraction;
+                            }
+                            offset = endOffset;
+                        }
+                    }
+                }
+            }
+
+            // extract timezone
+            if (date.length() <= offset) {
+                throw new IllegalArgumentException("No time zone indicator");
+            }
+
+            TimeZone timezone = null;
+            char timezoneIndicator = date.charAt(offset);
+
+            if (timezoneIndicator == 'Z') {
+                timezone = TIMEZONE_UTC;
+                offset += 1;
+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
+                String timezoneOffset = date.substring(offset);
+
+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
+                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00";
+
+                offset += timezoneOffset.length();
+                // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
+                if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
+                    timezone = TIMEZONE_UTC;
+                } else {
+                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
+                    //    not sure why, but that's the way it looks. Further, Javadocs for
+                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
+                    //    custom timezones... odd.
+                    String timezoneId = "GMT" + timezoneOffset;
+//                    String timezoneId = "UTC" + timezoneOffset;
+
+                    timezone = TimeZone.getTimeZone(timezoneId);
+
+                    String act = timezone.getID();
+                    if (!act.equals(timezoneId)) {
+                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
+                         *    one without. If so, don't sweat.
+                         *   Yes, very inefficient. Hopefully not hit often.
+                         *   If it becomes a perf problem, add 'loose' comparison instead.
+                         */
+                        String cleaned = act.replace(":", "");
+                        if (!cleaned.equals(timezoneId)) {
+                            throw new IndexOutOfBoundsException("Mismatching time zone indicator: "+timezoneId+" given, resolves to "
+                                    +timezone.getID());
+                        }
+                    }
+                }
+            } else {
+                throw new IndexOutOfBoundsException("Invalid time zone indicator '" + timezoneIndicator+"'");
+            }
+
+            Calendar calendar = new GregorianCalendar(timezone);
+            calendar.setLenient(false);
+            calendar.set(Calendar.YEAR, year);
+            calendar.set(Calendar.MONTH, month - 1);
+            calendar.set(Calendar.DAY_OF_MONTH, day);
+            calendar.set(Calendar.HOUR_OF_DAY, hour);
+            calendar.set(Calendar.MINUTE, minutes);
+            calendar.set(Calendar.SECOND, seconds);
+            calendar.set(Calendar.MILLISECOND, milliseconds);
+
+            pos.setIndex(offset);
+            return calendar.getTime();
+            // If we get a ParseException it'll already have the right message/offset.
+            // Other exception types can convert here.
+        } catch (IndexOutOfBoundsException e) {
+            fail = e;
+        } catch (NumberFormatException e) {
+            fail = e;
+        } catch (IllegalArgumentException e) {
+            fail = e;
+        }
+        String input = (date == null) ? null : ('"' + date + '"');
+        String msg = fail.getMessage();
+        if (msg == null || msg.isEmpty()) {
+            msg = "("+fail.getClass().getName()+")";
+        }
+        ParseException ex = new ParseException("Failed to parse date [" + input + "]: " + msg, pos.getIndex());
+        ex.initCause(fail);
+        throw ex;
+    }
+
+    /**
+     * Check if the expected character exist at the given offset in the value.
+     * 
+     * @param value the string to check at the specified offset
+     * @param offset the offset to look for the expected character
+     * @param expected the expected character
+     * @return true if the expected character exist at the given offset
+     */
+    private static boolean checkOffset(String value, int offset, char expected) {
+        return (offset < value.length()) && (value.charAt(offset) == expected);
+    }
+
+    /**
+     * Parse an integer located between 2 given offsets in a string
+     * 
+     * @param value the string to parse
+     * @param beginIndex the start index for the integer in the string
+     * @param endIndex the end index for the integer in the string
+     * @return the int
+     * @throws NumberFormatException if the value is not a number
+     */
+    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
+        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
+            throw new NumberFormatException(value);
+        }
+        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
+        int i = beginIndex;
+        int result = 0;
+        int digit;
+        if (i < endIndex) {
+            digit = Character.digit(value.charAt(i++), 10);
+            if (digit < 0) {
+                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+            }
+            result = -digit;
+        }
+        while (i < endIndex) {
+            digit = Character.digit(value.charAt(i++), 10);
+            if (digit < 0) {
+                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+            }
+            result *= 10;
+            result -= digit;
+        }
+        return -result;
+    }
+
+    /**
+     * Zero pad a number to a specified length
+     * 
+     * @param buffer buffer to use for padding
+     * @param value the integer value to pad if necessary.
+     * @param length the length of the string we should zero pad
+     */
+    private static void padInt(StringBuilder buffer, int value, int length) {
+        String strValue = Integer.toString(value);
+        for (int i = length - strValue.length(); i > 0; i--) {
+            buffer.append('0');
+        }
+        buffer.append(strValue);
+    }
+
+    /**
+     * Returns the index of the first character in the string that is not a digit, starting at offset.
+     */
+    private static int indexOfNonDigit(String string, int offset) {
+        for (int i = offset; i < string.length(); i++) {
+            char c = string.charAt(i);
+            if (c < '0' || c > '9') return i;
+        }
+        return string.length();
+    }
+
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
new file mode 100644
index 000000000..325274e22
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * A basic implementation of {@link ReflectionAccessor} which is suitable for Java 8 and below.
+ * <p>
+ * This implementation just calls {@link AccessibleObject#setAccessible(boolean) setAccessible(true)}, which worked
+ * fine before Java 9.
+ */
+final class PreJava9ReflectionAccessor extends ReflectionAccessor {
+
+  /** {@inheritDoc} */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    ao.setAccessible(true);
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
new file mode 100644
index 000000000..42230d254
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import com.google.gson.util.VersionUtils;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
+ * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
+ * thrown or warnings like
+ * <pre>
+ *   WARNING: An illegal reflective access operation has occurred
+ *   WARNING: Illegal reflective access by ...
+ * </pre>
+ * <p/>
+ * Works both for Java 9 and earlier Java versions.
+ */
+public abstract class ReflectionAccessor {
+
+  // the singleton instance, use getInstance() to obtain
+  private static final ReflectionAccessor instance = VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
+
+  /**
+   * Does the same as {@code ao.setAccessible(true)}, but never throws
+   * {@link java.lang.reflect.InaccessibleObjectException}
+   */
+  public abstract void makeAccessible(AccessibleObject ao);
+
+  /**
+   * Obtains a {@link ReflectionAccessor} instance suitable for the current Java version.
+   * <p>
+   * You may need one a reflective operation in your code throws {@link java.lang.reflect.InaccessibleObjectException}.
+   * In such a case, use {@link ReflectionAccessor#makeAccessible(AccessibleObject)} on a field, method or constructor
+   * (instead of basic {@link AccessibleObject#setAccessible(boolean)}).
+   */
+  public static ReflectionAccessor getInstance() {
+    return instance;
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
new file mode 100644
index 000000000..749335b77
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import com.google.gson.JsonIOException;
+
+/**
+ * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
+ * <p>
+ * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
+ * use {@link PreJava9ReflectionAccessor} for them.
+ */
+@SuppressWarnings({"unchecked", "rawtypes"})
+final class UnsafeReflectionAccessor extends ReflectionAccessor {
+
+  private static Class unsafeClass;
+  private final Object theUnsafe = getUnsafeInstance();
+  private final Field overrideField = getOverrideField();
+
+  /** {@inheritDoc} */
+  @Override
+  public void makeAccessible(AccessibleObject ao) {
+    boolean success = makeAccessibleWithUnsafe(ao);
+    if (!success) {
+      try {
+        // unsafe couldn't be found, so try using accessible anyway
+        ao.setAccessible(true);
+      } catch (SecurityException e) {
+        throw new JsonIOException("Gson couldn't modify fields for " + ao
+          + "\nand sun.misc.Unsafe not found.\nEither write a custom type adapter,"
+          + " or make fields accessible, or include sun.misc.Unsafe.", e);
+      }
+    }
+  }
+
+  // Visible for testing only
+  boolean makeAccessibleWithUnsafe(AccessibleObject ao) {
+    if (theUnsafe != null && overrideField != null) {
+      try {
+        Method method = unsafeClass.getMethod("objectFieldOffset", Field.class);
+        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
+        Method putBooleanMethod = unsafeClass.getMethod("putBoolean",  Object.class, long.class, boolean.class);
+        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);
+        return true;
+      } catch (Exception ignored) { // do nothing
+      }
+    }
+    return false;
+  }
+
+  private static Object getUnsafeInstance() {
+    try {
+      unsafeClass = Class.forName("sun.misc.Unsafe");
+      Field unsafeField = unsafeClass.getDeclaredField("theUnsafe");
+      unsafeField.setAccessible(true);
+      return unsafeField.get(null);
+    } catch (Exception e) {
+      return null;
+    }
+  }
+
+  private static Field getOverrideField() {
+    try {
+      return AccessibleObject.class.getDeclaredField("override");
+    } catch (NoSuchFieldException e) {
+      return null;
+    }
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
index e16e8e6dc..3fb8af2bc 100644
--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java
+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java
@@ -302,4 +302,19 @@ private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
   public static <T> TypeToken<T> get(Class<T> type) {
     return new TypeToken<T>(type);
   }
+
+  /**
+   * Gets type literal for the parameterized type represented by applying {@code typeArguments} to
+   * {@code rawType}.
+   */
+  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {
+    return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
+  }
+
+  /**
+   * Gets type literal for the array type whose elements are all instances of {@code componentType}.
+   */
+  public static TypeToken<?> getArray(Type componentType) {
+    return new TypeToken<Object>($Gson$Types.arrayOf(componentType));
+  }
 }
diff --git a/gson/src/main/java/com/google/gson/reflect/package-info.java b/gson/src/main/java/com/google/gson/reflect/package-info.java
index e666c4311..5e43ee9fc 100644
--- a/gson/src/main/java/com/google/gson/reflect/package-info.java
+++ b/gson/src/main/java/com/google/gson/reflect/package-info.java
@@ -1,6 +1,6 @@
 /**
  * This package provides utility classes for finding type information for generic types.
- *  
+ *
  * @author Inderjeet Singh, Joel Leitch
  */
 package com.google.gson.reflect;
\ No newline at end of file
diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java
index 388f30b06..e0799d736 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java
@@ -24,7 +24,7 @@
 import java.io.Reader;
 
 /**
- * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
+ * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
  * encoded value as a stream of tokens. This stream includes both literal
  * values (strings, numbers, booleans, and nulls) as well as the begin and
  * end delimiters of objects and arrays. The tokens are traversed in
@@ -242,7 +242,7 @@
   private int lineNumber = 0;
   private int lineStart = 0;
 
-  private int peeked = PEEKED_NONE;
+  int peeked = PEEKED_NONE;
 
   /**
    * A peeked value that was composed entirely of digits with an optional
@@ -294,7 +294,7 @@ public JsonReader(Reader in) {
   }
 
   /**
-   * Configure this parser to be  be liberal in what it accepts. By default,
+   * Configure this parser to be liberal in what it accepts. By default,
    * this parser is strict and only accepts JSON as specified by <a
    * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
    * parser to lenient causes it to ignore the following syntax errors:
@@ -347,8 +347,7 @@ public void beginArray() throws IOException {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
     }
   }
 
@@ -366,8 +365,7 @@ public void endArray() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_ARRAY but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
     }
   }
 
@@ -384,8 +382,7 @@ public void beginObject() throws IOException {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
     }
   }
 
@@ -404,8 +401,7 @@ public void endObject() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_OBJECT but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
     }
   }
 
@@ -462,7 +458,7 @@ public JsonToken peek() throws IOException {
     }
   }
 
-  private int doPeek() throws IOException {
+  int doPeek() throws IOException {
     int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
@@ -571,9 +567,6 @@ private int doPeek() throws IOException {
       checkLenient();
       return peeked = PEEKED_SINGLE_QUOTED;
     case '"':
-      if (stackSize == 1) {
-        checkLenient();
-      }
       return peeked = PEEKED_DOUBLE_QUOTED;
     case '[':
       return peeked = PEEKED_BEGIN_ARRAY;
@@ -583,10 +576,6 @@ private int doPeek() throws IOException {
       pos--; // Don't consume the first character in a literal value.
     }
 
-    if (stackSize == 1) {
-      checkLenient(); // Top-level value isn't an array or an object.
-    }
-
     int result = peekKeyword();
     if (result != PEEKED_NONE) {
       return result;
@@ -739,7 +728,7 @@ private int peekNumber() throws IOException {
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;
@@ -797,8 +786,7 @@ public String nextName() throws IOException {
     } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
       result = nextQuotedValue('"');
     } else {
-      throw new IllegalStateException("Expected a name but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a name but was " + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathNames[stackSize - 1] = result;
@@ -834,8 +822,7 @@ public String nextString() throws IOException {
       result = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else {
-      throw new IllegalStateException("Expected a string but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a string but was " + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathIndices[stackSize - 1]++;
@@ -863,8 +850,7 @@ public boolean nextBoolean() throws IOException {
       pathIndices[stackSize - 1]++;
       return false;
     }
-    throw new IllegalStateException("Expected a boolean but was " + peek()
-        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    throw new IllegalStateException("Expected a boolean but was " + peek() + locationString());
   }
 
   /**
@@ -883,8 +869,7 @@ public void nextNull() throws IOException {
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
     } else {
-      throw new IllegalStateException("Expected null but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected null but was " + peek() + locationString());
     }
   }
 
@@ -917,15 +902,14 @@ public double nextDouble() throws IOException {
     } else if (p == PEEKED_UNQUOTED) {
       peekedString = nextUnquotedValue();
     } else if (p != PEEKED_BUFFERED) {
-      throw new IllegalStateException("Expected a double but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a double but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new MalformedJsonException("JSON forbids NaN and infinities: " + result
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new MalformedJsonException(
+          "JSON forbids NaN and infinities: " + result + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -958,8 +942,12 @@ public long nextLong() throws IOException {
     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+      }
       try {
         long result = Long.parseLong(peekedString);
         peeked = PEEKED_NONE;
@@ -969,16 +957,14 @@ public long nextLong() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected a long but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected a long but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new NumberFormatException("Expected a long but was " + peekedString
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new NumberFormatException("Expected a long but was " + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -999,7 +985,7 @@ public long nextLong() throws IOException {
   private String nextQuotedValue(char quote) throws IOException {
     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
     char[] buffer = this.buffer;
-    StringBuilder builder = new StringBuilder();
+    StringBuilder builder = null;
     while (true) {
       int p = pos;
       int l = limit;
@@ -1010,11 +996,21 @@ private String nextQuotedValue(char quote) throws IOException {
 
         if (c == quote) {
           pos = p;
-          builder.append(buffer, start, p - start - 1);
-          return builder.toString();
+          int len = p - start - 1;
+          if (builder == null) {
+            return new String(buffer, start, len);
+          } else {
+            builder.append(buffer, start, len);
+            return builder.toString();
+          }
         } else if (c == '\\') {
           pos = p;
-          builder.append(buffer, start, p - start - 1);
+          int len = p - start - 1;
+          if (builder == null) {
+            int estimatedLength = (len + 1) * 2;
+            builder = new StringBuilder(Math.max(estimatedLength, 16));
+          }
+          builder.append(buffer, start, len);
           builder.append(readEscapeCharacter());
           p = pos;
           l = limit;
@@ -1025,6 +1021,10 @@ private String nextQuotedValue(char quote) throws IOException {
         }
       }
 
+      if (builder == null) {
+        int estimatedLength = (p - start) * 2;
+        builder = new StringBuilder(Math.max(estimatedLength, 16));
+      }
       builder.append(buffer, start, p - start);
       pos = p;
       if (!fillBuffer(1)) {
@@ -1077,7 +1077,7 @@ private String nextUnquotedValue() throws IOException {
 
       // use a StringBuilder when the value is too long. This is too long to be a number!
       if (builder == null) {
-        builder = new StringBuilder();
+        builder = new StringBuilder(Math.max(i,16));
       }
       builder.append(buffer, pos, i);
       pos += i;
@@ -1086,14 +1086,8 @@ private String nextUnquotedValue() throws IOException {
         break;
       }
     }
-
-    String result;
-    if (builder == null) {
-      result = new String(buffer, pos, i);
-    } else {
-      builder.append(buffer, pos, i);
-      result = builder.toString();
-    }
+   
+    String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
     pos += i;
     return result;
   }
@@ -1175,8 +1169,7 @@ public int nextInt() throws IOException {
     if (p == PEEKED_LONG) {
       result = (int) peekedLong;
       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new NumberFormatException("Expected an int but was " + peekedLong
-            + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+        throw new NumberFormatException("Expected an int but was " + peekedLong + locationString());
       }
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
@@ -1186,8 +1179,12 @@ public int nextInt() throws IOException {
     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+      }
       try {
         result = Integer.parseInt(peekedString);
         peeked = PEEKED_NONE;
@@ -1197,16 +1194,14 @@ public int nextInt() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected an int but was " + peek()
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new IllegalStateException("Expected an int but was " + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new NumberFormatException("Expected an int but was " + peekedString
-          + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+      throw new NumberFormatException("Expected an int but was " + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -1314,14 +1309,6 @@ private boolean fillBuffer(int minimum) throws IOException {
     return false;
   }
 
-  private int getLineNumber() {
-    return lineNumber + 1;
-  }
-
-  private int getColumnNumber() {
-    return pos - lineStart + 1;
-  }
-
   /**
    * Returns the next character in the stream that is neither whitespace nor a
    * part of a comment. When this returns, the returned character is always at
@@ -1411,8 +1398,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
       }
     }
     if (throwOnEof) {
-      throw new EOFException("End of input"
-          + " at line " + getLineNumber() + " column " + getColumnNumber());
+      throw new EOFException("End of input" + locationString());
     } else {
       return -1;
     }
@@ -1446,14 +1432,15 @@ private void skipToEndOfLine() throws IOException {
    * @param toFind a string to search for. Must not contain a newline.
    */
   private boolean skipTo(String toFind) throws IOException {
+    int length = toFind.length();
     outer:
-    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
+    for (; pos + length <= limit || fillBuffer(length); pos++) {
       if (buffer[pos] == '\n') {
         lineNumber++;
         lineStart = pos + 1;
         continue;
       }
-      for (int c = 0; c < toFind.length(); c++) {
+      for (int c = 0; c < length; c++) {
         if (buffer[pos + c] != toFind.charAt(c)) {
           continue outer;
         }
@@ -1464,8 +1451,13 @@ private boolean skipTo(String toFind) throws IOException {
   }
 
   @Override public String toString() {
-    return getClass().getSimpleName()
-        + " at line " + getLineNumber() + " column " + getColumnNumber();
+    return getClass().getSimpleName() + locationString();
+  }
+
+  String locationString() {
+    int line = lineNumber + 1;
+    int column = pos - lineStart + 1;
+    return " at line " + line + " column " + column + " path " + getPath();
   }
 
   /**
@@ -1560,8 +1552,11 @@ private char readEscapeCharacter() throws IOException {
     case '\'':
     case '"':
     case '\\':
+    case '/':	
+    	return escaped;
     default:
-      return escaped;
+    	// throw error when none of the above cases are matched
+    	throw syntaxError("Invalid escape sequence");
     }
   }
 
@@ -1570,8 +1565,7 @@ private char readEscapeCharacter() throws IOException {
    * with this reader's content.
    */
   private IOException syntaxError(String message) throws IOException {
-    throw new MalformedJsonException(message
-        + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath());
+    throw new MalformedJsonException(message + locationString());
   }
 
   /**
@@ -1614,9 +1608,8 @@ private void consumeNonExecutePrefix() throws IOException {
         } else if (p == PEEKED_UNQUOTED_NAME) {
           reader.peeked = PEEKED_UNQUOTED;
         } else {
-          throw new IllegalStateException("Expected a name but was " + reader.peek() + " "
-              + " at line " + reader.getLineNumber() + " column " + reader.getColumnNumber()
-              + " path " + reader.getPath());
+          throw new IllegalStateException(
+              "Expected a name but was " + reader.peek() + reader.locationString());
         }
       }
     };
diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
index 8d3bdb347..8148816c2 100644
--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java
+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java
@@ -30,7 +30,7 @@
 import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;
 
 /**
- * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
+ * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
  * encoded value to a stream, one token at a time. The stream includes both
  * literal values (strings, numbers, booleans and nulls) as well as the begin
  * and end delimiters of objects and arrays.
@@ -130,7 +130,7 @@
 public class JsonWriter implements Closeable, Flushable {
 
   /*
-   * From RFC 4627, "All Unicode characters may be placed within the
+   * From RFC 7159, "All Unicode characters may be placed within the
    * quotation marks except for the characters that must be escaped:
    * quotation mark, reverse solidus, and the control characters
    * (U+0000 through U+001F)."
@@ -222,7 +222,7 @@ public final void setIndent(String indent) {
   /**
    * Configure this writer to relax its syntax rules. By default, this writer
    * only emits well-formed JSON as specified by <a
-   * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the writer
+   * href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>. Setting the writer
    * to lenient permits the following:
    * <ul>
    *   <li>Top-level values of any type. With strict writing, the top-level
@@ -322,7 +322,7 @@ public JsonWriter endObject() throws IOException {
    * bracket.
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
-    beforeValue(true);
+    beforeValue();
     push(empty);
     out.write(openBracket);
     return this;
@@ -415,7 +415,7 @@ public JsonWriter value(String value) throws IOException {
       return nullValue();
     }
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     string(value);
     return this;
   }
@@ -432,7 +432,7 @@ public JsonWriter jsonValue(String value) throws IOException {
       return nullValue();
     }
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.append(value);
     return this;
   }
@@ -451,7 +451,7 @@ public JsonWriter nullValue() throws IOException {
         return this; // skip the name and the value
       }
     }
-    beforeValue(false);
+    beforeValue();
     out.write("null");
     return this;
   }
@@ -463,7 +463,22 @@ public JsonWriter nullValue() throws IOException {
    */
   public JsonWriter value(boolean value) throws IOException {
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
+    out.write(value ? "true" : "false");
+    return this;
+  }
+
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter value(Boolean value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
     out.write(value ? "true" : "false");
     return this;
   }
@@ -476,11 +491,11 @@ public JsonWriter value(boolean value) throws IOException {
    * @return this writer.
    */
   public JsonWriter value(double value) throws IOException {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
+    writeDeferredName();
+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.append(Double.toString(value));
     return this;
   }
@@ -492,7 +507,7 @@ public JsonWriter value(double value) throws IOException {
    */
   public JsonWriter value(long value) throws IOException {
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.write(Long.toString(value));
     return this;
   }
@@ -515,7 +530,7 @@ public JsonWriter value(Number value) throws IOException {
         && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    beforeValue(false);
+    beforeValue();
     out.append(string);
     return this;
   }
@@ -608,12 +623,9 @@ private void beforeName() throws IOException {
    * Inserts any necessary separators and whitespace before a literal value,
    * inline array, or inline object. Also adjusts the stack to expect either a
    * closing bracket or another element.
-   *
-   * @param root true if the value is a new array or object, the two values
-   *     permitted as top-level elements.
    */
   @SuppressWarnings("fallthrough")
-  private void beforeValue(boolean root) throws IOException {
+  private void beforeValue() throws IOException {
     switch (peek()) {
     case NONEMPTY_DOCUMENT:
       if (!lenient) {
@@ -622,10 +634,6 @@ private void beforeValue(boolean root) throws IOException {
       }
       // fall-through
     case EMPTY_DOCUMENT: // first in document
-      if (!lenient && !root) {
-        throw new IllegalStateException(
-            "JSON must start with an array or an object.");
-      }
       replaceTop(NONEMPTY_DOCUMENT);
       break;
 
diff --git a/gson/src/main/java/com/google/gson/util/VersionUtils.java b/gson/src/main/java/com/google/gson/util/VersionUtils.java
new file mode 100644
index 000000000..d81e43c09
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/util/VersionUtils.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.util;
+
+/**
+ * Utility to check the major Java version of the current JVM.
+ */
+public class VersionUtils {
+
+  private static final int majorJavaVersion = determineMajorJavaVersion();
+
+  private static int determineMajorJavaVersion() {
+    String[] parts = System.getProperty("java.version").split("[._]");
+    int firstVer = Integer.parseInt(parts[0]);
+    if (firstVer == 1 && parts.length > 1) {
+      return Integer.parseInt(parts[1]);
+    } else {
+      return firstVer;
+    }
+  }
+
+  /**
+   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
+   */
+  public static int getMajorJavaVersion() {
+    return majorJavaVersion;
+  }
+
+  /**
+   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
+   */
+  public static boolean isJava9OrLater() {
+    return majorJavaVersion >= 9;
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
index 966a8c185..a074bea0c 100644
--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
@@ -16,11 +16,14 @@
 
 package com.google.gson;
 
+import java.io.IOException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -44,17 +47,21 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(locale);
     try {
-      assertFormatted("Jan 1, 1970 12:00:00 AM", new DefaultDateTypeAdapter());
-      assertFormatted("1/1/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
-      assertFormatted("1/1/70 12:00 AM",
+      String afterYearSep = VersionUtils.isJava9OrLater() ? ", " : " ";
+      String afterYearLongSep = VersionUtils.isJava9OrLater() ? " at " : " ";
+      String utcFull = VersionUtils.isJava9OrLater() ? "Coordinated Universal Time" : "UTC";
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertFormatted("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertFormatted("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertFormatted("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
+      assertFormatted(String.format("1/1/70%s12:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertFormatted("Jan 1, 1970 12:00:00 AM",
+      assertFormatted(String.format("Jan 1, 1970%s12:00:00 AM", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertFormatted("January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("January 1, 1970%s12:00:00 AM UTC", afterYearLongSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertFormatted("Thursday, January 1, 1970 12:00:00 AM UTC",
+      assertFormatted(String.format("Thursday, January 1, 1970%s12:00:00 AM %s", afterYearLongSep, utcFull),
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -62,23 +69,27 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     }
   }
 
-  public void testParsingDatesFormattedWithSystemLocale() {
+  public void testParsingDatesFormattedWithSystemLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.FRANCE);
     try {
-      assertParsed("1 janv. 1970 00:00:00", new DefaultDateTypeAdapter());
-      assertParsed("01/01/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
+      String afterYearSep = VersionUtils.isJava9OrLater() ? " à " : " ";
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertParsed("01/01/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed("1 janv. 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed("1 janvier 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed("01/01/70 00:00",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
-      assertParsed("1 janv. 1970 00:00:00",
+      assertParsed(String.format("1 janv. 1970%s00:00:00", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
-      assertParsed("1 janvier 1970 00:00:00 UTC",
+      assertParsed(String.format("1 janvier 1970%s00:00:00 UTC", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed("jeudi 1 janvier 1970 00 h 00 UTC",
+      assertParsed(VersionUtils.isJava9OrLater() ?
+                      "jeudi 1 janvier 1970 à 00:00:00 Coordinated Universal Time" :
+                      "jeudi 1 janvier 1970 00 h 00 UTC",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
@@ -86,16 +97,16 @@ public void testParsingDatesFormattedWithSystemLocale() {
     }
   }
 
-  public void testParsingDatesFormattedWithUsLocale() {
+  public void testParsingDatesFormattedWithUsLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertParsed("Jan 1, 1970 0:00:00 AM", new DefaultDateTypeAdapter());
-      assertParsed("1/1/70", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed("Jan 1, 1970", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed("January 1, 1970", new DefaultDateTypeAdapter(DateFormat.LONG));
+      assertParsed("Jan 1, 1970 0:00:00 AM", new DefaultDateTypeAdapter(Date.class));
+      assertParsed("1/1/70", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed("Jan 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed("January 1, 1970", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed("1/1/70 0:00 AM",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
       assertParsed("Jan 1, 1970 0:00:00 AM",
@@ -110,54 +121,82 @@ public void testParsingDatesFormattedWithUsLocale() {
     }
   }
 
-  public void testFormatUsesDefaultTimezone() {
+  public void testFormatUsesDefaultTimezone() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertFormatted("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter());
-      assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter());
+      String afterYearSep = VersionUtils.isJava9OrLater() ? ", " : " ";
+      assertFormatted(String.format("Dec 31, 1969%s4:00:00 PM", afterYearSep),
+              new DefaultDateTypeAdapter(Date.class));
+      assertParsed("Dec 31, 1969 4:00:00 PM", new DefaultDateTypeAdapter(Date.class));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
       Locale.setDefault(defaultLocale);
     }
   }
 
+  public void testDateDeserializationISO8601() throws Exception {
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+    assertParsed("1970-01-01T00:00:00.000Z", adapter);
+    assertParsed("1970-01-01T00:00Z", adapter);
+    assertParsed("1970-01-01T00:00:00+00:00", adapter);
+    assertParsed("1970-01-01T01:00:00+01:00", adapter);
+    assertParsed("1970-01-01T01:00:00+01", adapter);
+  }
+  
   public void testDateSerialization() throws Exception {
     int dateStyle = DateFormat.LONG;
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle);
     DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testDatePattern() throws Exception {
     String pattern = "yyyy-MM-dd";
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, pattern);
     DateFormat formatter = new SimpleDateFormat(pattern);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testInvalidDatePattern() throws Exception {
     try {
-      new DefaultDateTypeAdapter("I am a bad Date pattern....");
+      new DefaultDateTypeAdapter(Date.class, "I am a bad Date pattern....");
       fail("Invalid date pattern should fail.");
     } catch (IllegalArgumentException expected) { }
   }
 
+  public void testNullValue() throws Exception {
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+    assertNull(adapter.fromJson("null"));
+    assertEquals("null", adapter.toJson(null));
+  }
+
+  public void testUnexpectedToken() throws Exception {
+    try {
+      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
+      adapter.fromJson("{}");
+      fail("Unexpected token should fail.");
+    } catch (IllegalStateException expected) { }
+  }
+
   private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {
-    assertEquals(formatted, adapter.serialize(new Date(0), Date.class, null).getAsString());
+    assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));
+  }
+
+  private void assertParsed(String date, DefaultDateTypeAdapter adapter) throws IOException {
+    assertEquals(date, new Date(0), adapter.fromJson(toLiteral(date)));
+    assertEquals("ISO 8601", new Date(0), adapter.fromJson(toLiteral("1970-01-01T00:00:00Z")));
   }
 
-  private void assertParsed(String date, DefaultDateTypeAdapter  adapter) {
-    assertEquals(date, new Date(0), adapter.deserialize(new JsonPrimitive(date), Date.class, null));
-    assertEquals("ISO 8601", new Date(0), adapter.deserialize(
-        new JsonPrimitive("1970-01-01T00:00:00Z"), Date.class, null));
+  private static String toLiteral(String s) {
+    return '"' + s + '"';
   }
 }
diff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
new file mode 100644
index 000000000..eec2ec91c
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson;
+
+import com.google.gson.internal.Excluder;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.text.DateFormat;
+import java.util.ArrayList;
+import java.util.HashMap;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link Gson}.
+ *
+ * @author Ryan Harter
+ */
+public final class GsonTest extends TestCase {
+
+  private static final Excluder CUSTOM_EXCLUDER = Excluder.DEFAULT
+      .excludeFieldsWithoutExposeAnnotation()
+      .disableInnerClassSerialization();
+
+  private static final FieldNamingStrategy CUSTOM_FIELD_NAMING_STRATEGY = new FieldNamingStrategy() {
+    @Override public String translateName(Field f) {
+      return "foo";
+    }
+  };
+
+  public void testOverridesDefaultExcluder() {
+    Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
+        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+
+    assertEquals(CUSTOM_EXCLUDER, gson.excluder());
+    assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
+    assertEquals(true, gson.serializeNulls());
+    assertEquals(false, gson.htmlSafe());
+  }
+
+  public void testClonedTypeAdapterFactoryListsAreIndependent() {
+    Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
+        new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
+        true, true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
+        new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
+
+    Gson clone = original.newBuilder()
+        .registerTypeAdapter(Object.class, new TestTypeAdapter())
+        .create();
+
+    assertEquals(original.factories.size() + 1, clone.factories.size());
+  }
+
+  private static final class TestTypeAdapter extends TypeAdapter<Object> {
+    @Override public void write(JsonWriter out, Object value) throws IOException {
+      // Test stub.
+    }
+    @Override public Object read(JsonReader in) throws IOException { return null; }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java
index 9423a24d2..d071c3baa 100644
--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java
+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java
@@ -158,6 +158,20 @@ public void testEqualsNonEmptyObject() {
     assertFalse(b.equals(a));
   }
 
+  public void testSize() {
+    JsonObject o = new JsonObject();
+    assertEquals(0, o.size());
+
+    o.add("Hello", new JsonPrimitive(1));
+    assertEquals(1, o.size());
+
+    o.add("Hi", new JsonPrimitive(1));
+    assertEquals(2, o.size());
+
+    o.remove("Hello");
+    assertEquals(1, o.size());
+  }
+
   public void testDeepCopy() {
     JsonObject original = new JsonObject();
     JsonArray firstEntry = new JsonArray();
@@ -169,4 +183,19 @@ public void testDeepCopy() {
     assertEquals(1, original.get("key").getAsJsonArray().size());
     assertEquals(0, copy.get("key").getAsJsonArray().size());
   }
+
+  /**
+   * From issue 941
+   */
+  public void testKeySet() {
+    JsonObject a = new JsonObject();
+
+    a.add("foo", new JsonArray());
+    a.add("bar", new JsonObject());
+
+    assertEquals(2, a.size());
+    assertEquals(2, a.keySet().size());
+    assertTrue(a.keySet().contains("foo"));
+    assertTrue(a.keySet().contains("bar"));
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
index 8b56579ea..24d78e89d 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.
+ * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
diff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
index 9a8f707b4..4ec7378b2 100644
--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java
+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java
@@ -393,4 +393,23 @@ public void testSetDeserialization() {
       assertTrue(entry.value == 1 || entry.value == 2);
     }
   }
+
+  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }
+
+  private class SmallClass { private String inSmall; }
+
+  public void testIssue1107() {
+    String json = "{\n" +
+            "  \"inBig\": {\n" +
+            "    \"key\": [\n" +
+            "      { \"inSmall\": \"hello\" }\n" +
+            "    ]\n" +
+            "  }\n" +
+            "}";
+    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
+    SmallClass small = bigClass.inBig.get("key").get(0);
+    assertNotNull(small);
+    assertEquals("hello", small.inSmall);
+  }
+
 }
diff --git a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
index 198667162..635c20887 100644
--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
@@ -55,6 +55,8 @@
 import java.util.TimeZone;
 import java.util.TreeSet;
 import java.util.UUID;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -328,7 +330,11 @@ public void testBitSetDeserialization() throws Exception {
   public void testDefaultDateSerialization() {
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserialization() {
@@ -369,7 +375,11 @@ public void testDefaultJavaSqlDateDeserialization() {
   public void testDefaultJavaSqlTimestampSerialization() {
     Timestamp now = new java.sql.Timestamp(1259875082000L);
     String json = gson.toJson(now);
-    assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Dec 3, 2009, 1:18:02 PM\"", json);
+    } else {
+      assertEquals("\"Dec 3, 2009 1:18:02 PM\"", json);
+    }
   }
 
   public void testDefaultJavaSqlTimestampDeserialization() {
@@ -395,7 +405,11 @@ public void testDefaultDateSerializationUsingBuilder() throws Exception {
     Gson gson = new GsonBuilder().create();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("\"Sep 11, 2011, 10:55:03 PM\"", json);
+    } else {
+      assertEquals("\"Sep 11, 2011 10:55:03 PM\"", json);
+    }
   }
 
   public void testDefaultDateDeserializationUsingBuilder() throws Exception {
diff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java
index 4a9f05b59..66b855ebf 100644
--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java
+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java
@@ -16,6 +16,12 @@
 
 package com.google.gson.functional;
 
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Set;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonDeserializationContext;
@@ -29,13 +35,6 @@
 import com.google.gson.common.MoreAsserts;
 import com.google.gson.reflect.TypeToken;
 
-
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.Set;
-
 import junit.framework.TestCase;
 /**
  * Functional tests for Java 5.0 enums.
@@ -199,4 +198,19 @@ public void testEnumSet() {
     @SerializedName("girl")
     FEMALE
   }
+
+  public void testEnumClassWithFields() {
+	  assertEquals("\"RED\"", gson.toJson(Color.RED));
+	  assertEquals("red", gson.fromJson("RED", Color.class).value);
+  }
+
+  public enum Color {
+	  RED("red", 1), BLUE("blue", 2), GREEN("green", 3);
+	  String value;
+	  int index;
+	  private Color(String value, int index) {
+		  this.value = value;
+		  this.index = index;
+	  }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
index d07984128..4288bfe3b 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
@@ -133,6 +133,12 @@ public void testSuperclassTypeAdapterNotInvoked() {
     assertFalse(json.contains("jsonAdapter"));
   }
 
+  public void testNullSafeObjectFromJson() {
+    Gson gson = new Gson();
+    NullableClass fromJson = gson.fromJson("null", NullableClass.class);
+    assertNull(fromJson);
+  }
+
   @JsonAdapter(A.JsonAdapter.class)
   private static class A {
     final String value;
@@ -215,6 +221,23 @@ public void testSuperclassTypeAdapterNotInvoked() {
     }
   }
 
+  @JsonAdapter(value = NullableClassJsonAdapter.class)
+  private static class NullableClass {
+  }
+
+  private static class NullableClassJsonAdapter extends TypeAdapter<NullableClass> {
+    @Override
+    public void write(JsonWriter out, NullableClass value) throws IOException {
+      out.value("nullable");
+    }
+
+    @Override
+    public NullableClass read(JsonReader in) throws IOException {
+      in.nextString();
+      return new NullableClass();
+    }
+  }
+
   @JsonAdapter(FooJsonAdapter.class)
   private static enum Foo { BAR, BAZ }
   private static class FooJsonAdapter extends TypeAdapter<Foo> {
@@ -226,4 +249,15 @@ public void testSuperclassTypeAdapterNotInvoked() {
       return Foo.valueOf(in.nextString().toUpperCase(Locale.US));
     }
   }
+
+  public void testIncorrectJsonAdapterType() {
+    try {
+      new Gson().toJson(new D());
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+  @JsonAdapter(Integer.class)
+  private static final class D {
+    @SuppressWarnings("unused") final String value = "a";
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
index fb5121dcf..706fe60f8 100644
--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
@@ -16,6 +16,10 @@
 
 package com.google.gson.functional;
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.TypeAdapter;
@@ -24,7 +28,7 @@
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
+
 import junit.framework.TestCase;
 
 /**
@@ -63,7 +67,6 @@ public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {
         @Override public void write(JsonWriter out, Part part) throws IOException {
           throw new AssertionError();
         }
-
         @Override public Part read(JsonReader in) throws IOException {
           throw new AssertionError();
         }
@@ -200,4 +203,104 @@ public void testJsonAdapterInvokedOnlyForAnnotatedFields() {
       this.part2 = part2;
     }
   }
+
+  public void testJsonAdapterWrappedInNullSafeAsRequested() {
+    Gson gson = new Gson();
+    String fromJson = "{'part':null}";
+
+    GadgetWithOptionalPart gadget = gson.fromJson(fromJson, GadgetWithOptionalPart.class);
+    assertNull(gadget.part);
+
+    String toJson = gson.toJson(gadget);
+    assertFalse(toJson.contains("PartJsonFieldAnnotationAdapter"));
+  }
+
+  private static final class GadgetWithOptionalPart {
+    @JsonAdapter(value = PartJsonFieldAnnotationAdapter.class)
+    final Part part;
+
+    private GadgetWithOptionalPart(Part part) {
+      this.part = part;
+    }
+  }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithOptionalPart(new Part("foo")));
+    assertEquals("{\"part\":\"PartJsonFieldAnnotationAdapter\"}", json);
+    GadgetWithOptionalPart gadget = gson.fromJson("{'part':'foo'}", GadgetWithOptionalPart.class);
+    assertEquals("PartJsonFieldAnnotationAdapter", gadget.part.name);
+  }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithPrimitivePart(42));
+    assertEquals("{\"part\":\"42\"}", json);
+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);
+    assertEquals(42, gadget.part);
+  }
+
+  private static final class GadgetWithPrimitivePart {
+    @JsonAdapter(LongToStringTypeAdapterFactory.class)
+    final long part;
+
+    private GadgetWithPrimitivePart(long part) {
+      this.part = part;
+    }
+  }
+
+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {
+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {
+      @Override public void write(JsonWriter out, Long value) throws IOException {
+        out.value(value.toString());
+      }
+      @Override public Long read(JsonReader in) throws IOException {
+        return in.nextLong();
+      }
+    };
+    @SuppressWarnings("unchecked")
+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      Class<?> cls = type.getRawType();
+      if (Long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      } else if (long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      }
+      throw new IllegalStateException("Non-long field of type " + type
+          + " annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)");
+    }
+  }
+
+  public void testFieldAnnotationWorksForParameterizedType() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Gizmo2(Arrays.asList(new Part("Part"))));
+    assertEquals("{\"part\":\"GizmoPartTypeAdapterFactory\"}", json);
+    Gizmo2 computer = gson.fromJson("{'part':'Part'}", Gizmo2.class);
+    assertEquals("GizmoPartTypeAdapterFactory", computer.part.get(0).name);
+  }
+
+  private static final class Gizmo2 {
+    @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)
+    List<Part> part;
+    Gizmo2(List<Part> part) {
+      this.part = part;
+    }
+  }
+
+  private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      return new TypeAdapter<T>() {
+        @Override public void write(JsonWriter out, T value) throws IOException {
+          out.value("GizmoPartTypeAdapterFactory");
+        }
+        @SuppressWarnings("unchecked")
+        @Override public T read(JsonReader in) throws IOException {
+          in.nextString();
+          return (T) Arrays.asList(new Part("GizmoPartTypeAdapterFactory"));
+        }
+      };
+    }
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
new file mode 100644
index 000000000..8ab4e128a
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.functional;
+
+import java.lang.reflect.Type;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.annotations.JsonAdapter;
+
+import junit.framework.TestCase;
+
+/**
+ * Functional tests for the {@link JsonAdapter} annotation on fields where the value is of
+ * type {@link JsonSerializer} or {@link JsonDeserializer}.
+ */
+public final class JsonAdapterSerializerDeserializerTest extends TestCase {
+
+  public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Computer(new User("Inderjeet Singh"), null, new User("Jesse Wilson")));
+    assertEquals("{\"user1\":\"UserSerializer\",\"user3\":\"UserSerializerDeserializer\"}", json);
+    Computer computer = gson.fromJson("{'user2':'Jesse Wilson','user3':'Jake Wharton'}", Computer.class);
+    assertEquals("UserSerializer", computer.user2.name);
+    assertEquals("UserSerializerDeserializer", computer.user3.name);
+  }
+
+  private static final class Computer {
+    @JsonAdapter(UserSerializer.class) final User user1;
+    @JsonAdapter(UserDeserializer.class) final User user2;
+    @JsonAdapter(UserSerializerDeserializer.class) final User user3;
+    Computer(User user1, User user2, User user3) {
+      this.user1 = user1;
+      this.user2 = user2;
+      this.user3 = user3;
+    }
+  }
+
+  private static final class User {
+    public final String name;
+    private User(String name) {
+      this.name = name;
+    }
+  }
+
+  private static final class UserSerializer implements JsonSerializer<User> {
+    @Override
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializer");
+    }
+  }
+
+  private static final class UserDeserializer implements JsonDeserializer<User> {
+    @Override
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User("UserSerializer");
+    }
+  }
+
+  private static final class UserSerializerDeserializer implements JsonSerializer<User>, JsonDeserializer<User> {
+    @Override
+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializerDeserializer");
+    }
+    @Override
+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User("UserSerializerDeserializer");
+    }
+  }
+
+  public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new Computer2(new User2("Inderjeet Singh")));
+    assertEquals("{\"user\":\"UserSerializerDeserializer2\"}", json);
+    Computer2 computer = gson.fromJson("{'user':'Inderjeet Singh'}", Computer2.class);
+    assertEquals("UserSerializerDeserializer2", computer.user.name);
+  }
+
+  private static final class Computer2 {
+    final User2 user;
+    Computer2(User2 user) {
+      this.user = user;
+    }
+  }
+
+  @JsonAdapter(UserSerializerDeserializer2.class)
+  private static final class User2 {
+    public final String name;
+    private User2(String name) {
+      this.name = name;
+    }
+  }
+
+  private static final class UserSerializerDeserializer2 implements JsonSerializer<User2>, JsonDeserializer<User2> {
+    @Override
+    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("UserSerializerDeserializer2");
+    }
+    @Override
+    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+        throws JsonParseException {
+      return new User2("UserSerializerDeserializer2");
+    }
+  }
+
+  public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {
+    Container c = new Container("Foo", 10);
+    Gson gson = new Gson();
+    String json = gson.toJson(c);
+    assertTrue(json.contains("\"a\":\"BaseStringAdapter\""));
+    assertTrue(json.contains("\"b\":\"BaseIntegerAdapter\""));
+  }
+
+  private static final class Container {
+    @JsonAdapter(BaseStringAdapter.class) Base<String> a;
+    @JsonAdapter(BaseIntegerAdapter.class) Base<Integer> b;
+    Container(String a, int b) {
+      this.a = new Base<String>(a);
+      this.b = new Base<Integer>(b);
+    }
+  }
+
+  private static final class Base<T> {
+    @SuppressWarnings("unused")
+    T value;
+    Base(T value) {
+      this.value = value;
+    }
+  }
+
+  private static final class BaseStringAdapter implements JsonSerializer<Base<String>> {
+    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("BaseStringAdapter");
+    }
+  }
+
+  private static final class BaseIntegerAdapter implements JsonSerializer<Base<Integer>> {
+    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context) {
+      return new JsonPrimitive("BaseIntegerAdapter");
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/functional/LeniencyTest.java b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java
new file mode 100644
index 000000000..6b5375e4b
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import java.util.List;
+import junit.framework.TestCase;
+
+import static java.util.Collections.singletonList;
+
+/**
+ * Functional tests for leniency option.
+ */
+public class LeniencyTest extends TestCase {
+
+  private Gson gson;
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    gson = new GsonBuilder().setLenient().create();
+  }
+
+  public void testLenientFromJson() {
+    List<String> json = gson.fromJson(""
+        + "[ # One!\n"
+        + "  'Hi' #Element!\n"
+        + "] # Array!", new TypeToken<List<String>>() {}.getType());
+    assertEquals(singletonList("Hi"), json);
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
old mode 100755
new mode 100644
index 590760cb5..154ecf558
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -167,6 +167,34 @@ public void testMapDeserializationWithIntegerKeys() {
     assertEquals("456", map.get(123));
   }
 
+  public void testMapDeserializationWithUnquotedIntegerKeys() {
+    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();
+    Map<Integer, String> map = gson.fromJson("{123:\"456\"}", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals("456", map.get(123));
+  }
+
+  public void testMapDeserializationWithLongKeys() {
+    long longValue = 9876543210L;
+    String json = String.format("{\"%d\":\"456\"}", longValue);
+    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
+    Map<Long, String> map = gson.fromJson(json, typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(longValue));
+    assertEquals("456", map.get(longValue));
+  }
+
+  public void testMapDeserializationWithUnquotedLongKeys() {
+    long longKey = 9876543210L;
+    String json = String.format("{%d:\"456\"}", longKey);
+    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
+    Map<Long, String> map = gson.fromJson(json, typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(longKey));
+    assertEquals("456", map.get(longKey));
+  }
+
   public void testHashMapDeserialization() throws Exception {
     Type typeOfMap = new TypeToken<HashMap<Integer, String>>() {}.getType();
     HashMap<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);
diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
index c3c0be1de..5b1bba5be 100644
--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
@@ -63,6 +63,20 @@ public void testGsonWithLowerCaseDashPolicySerialization() {
         + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
   }
 
+  public void testGsonWithLowerCaseDotPolicySerialization() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    StringWrapper target = new StringWrapper("blah");
+    assertEquals("{\"some.constant.string.instance.field\":\""
+          + target.someConstantStringInstanceField + "\"}", gson.toJson(target));
+  }
+
+  public void testGsonWithLowerCaseDotPolicyDeserialiation() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    String target = "{\"some.constant.string.instance.field\":\"someValue\"}";
+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
+    assertEquals("someValue", deserializedObject.someConstantStringInstanceField);
+  }
+
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
     String target = "{\"some-constant-string-instance-field\":\"someValue\"}";
diff --git a/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
old mode 100755
new mode 100644
diff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
index de1219a6a..cf82457a3 100644
--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java
+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java
@@ -43,6 +43,8 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
+
+import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -482,7 +484,11 @@ public void testSingletonLists() {
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
     a.map.put("date", new Date(0));
-    assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    if (VersionUtils.isJava9OrLater()) {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969, 4:00:00 PM\"}}", gson.toJson(a));
+    } else {
+      assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));
+    }
   }
 
   public class HasObjectMap {
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index bb28ed1ec..9da983a3b 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -158,6 +158,11 @@ public void testNumberDeserialization() {
     assertEquals(1L, actual.longValue());
   }
 
+  public void testNumberAsStringDeserialization() {
+    Number value = gson.fromJson("\"18\"", Number.class);
+    assertEquals(18, value.intValue());
+  }
+
   public void testPrimitiveDoubleAutoboxedSerialization() {
     assertEquals("-122.08234335", gson.toJson(-122.08234335));
     assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));
diff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
index 7959fc860..1284e2c9b 100644
--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
@@ -45,7 +45,7 @@
    * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}
    * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.
    */
-  public void testSubclassesAutomaticallySerialzed() throws Exception {
+  public void testSubclassesAutomaticallySerialized() throws Exception {
     Shape shape = new Circle(25);
     String json = gson.toJson(shape);
     shape = gson.fromJson(json, Shape.class);
diff --git a/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java b/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
index 38ad8242f..0314ae0af 100644
--- a/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
+++ b/gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
@@ -25,7 +25,7 @@
 
   public void testFirstNameIsChosenForSerialization() {
     MyClass target = new MyClass("v1", "v2");
-    // Ensure name1 occurs exactly once, and name2 and name3 dont appear
+    // Ensure name1 occurs exactly once, and name2 and name3 don't appear
     assertEquals("{\"name\":\"v1\",\"name1\":\"v2\"}", gson.toJson(target));
   }
 
diff --git a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
index 551ceffc0..45e85342c 100644
--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
@@ -27,8 +27,6 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -43,59 +41,59 @@
   private TypeAdapter<Map<String, Double>> mapAdapter
       = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});
 
-  public void testSerialize() throws IOException {
+  public void testSerialize() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29));
     truck.horsePower = 300;
 
     assertEquals("{'horsePower':300.0,"
         + "'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserialize() throws IOException {
     String json = "{'horsePower':300.0,"
         + "'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}";
-    Truck truck = fromJson(truckAdapter, json);
+    Truck truck = truckAdapter.fromJson(json.replace('\'', '\"'));
     assertEquals(300.0, truck.horsePower);
     assertEquals(Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29)), truck.passengers);
   }
 
-  public void testSerializeNullField() throws IOException {
+  public void testSerializeNullField() {
     Truck truck = new Truck();
     truck.passengers = null;
     assertEquals("{'horsePower':0.0,'passengers':null}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeNullField() throws IOException {
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':null}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':null}".replace('\'', '\"'));
     assertNull(truck.passengers);
   }
 
-  public void testSerializeNullObject() throws IOException {
+  public void testSerializeNullObject() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList((Person) null);
     assertEquals("{'horsePower':0.0,'passengers':[null]}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeNullObject() throws IOException {
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':[null]}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':[null]}".replace('\'', '\"'));
     assertEquals(Arrays.asList((Person) null), truck.passengers);
   }
 
-  public void testSerializeWithCustomTypeAdapter() throws IOException {
+  public void testSerializeWithCustomTypeAdapter() {
     usePersonNameAdapter();
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person("Jesse", 29), new Person("Jodie", 29));
     assertEquals("{'horsePower':0.0,'passengers':['Jesse','Jodie']}",
-        toJson(truckAdapter, truck).replace('\"', '\''));
+        truckAdapter.toJson(truck).replace('\"', '\''));
   }
 
   public void testDeserializeWithCustomTypeAdapter() throws IOException {
     usePersonNameAdapter();
-    Truck truck = fromJson(truckAdapter, "{'horsePower':0.0,'passengers':['Jesse','Jodie']}");
+    Truck truck = truckAdapter.fromJson("{'horsePower':0.0,'passengers':['Jesse','Jodie']}".replace('\'', '\"'));
     assertEquals(Arrays.asList(new Person("Jesse", -1), new Person("Jodie", -1)), truck.passengers);
   }
 
@@ -113,40 +111,40 @@ private void usePersonNameAdapter() {
     truckAdapter = miniGson.getAdapter(Truck.class);
   }
 
-  public void testSerializeMap() throws IOException {
+  public void testSerializeMap() {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put("a", 5.0);
     map.put("b", 10.0);
-    assertEquals("{'a':5.0,'b':10.0}", toJson(mapAdapter, map).replace('"', '\''));
+    assertEquals("{'a':5.0,'b':10.0}", mapAdapter.toJson(map).replace('"', '\''));
   }
 
   public void testDeserializeMap() throws IOException {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put("a", 5.0);
     map.put("b", 10.0);
-    assertEquals(map, fromJson(mapAdapter, "{'a':5.0,'b':10.0}"));
+    assertEquals(map, mapAdapter.fromJson("{'a':5.0,'b':10.0}".replace('\'', '\"')));
   }
 
-  public void testSerialize1dArray() throws IOException {
+  public void testSerialize1dArray() {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    assertEquals("[1.0,2.0,3.0]", toJson(arrayAdapter, new double[]{1.0, 2.0, 3.0}));
+    assertEquals("[1.0,2.0,3.0]", arrayAdapter.toJson(new double[]{ 1.0, 2.0, 3.0 }));
   }
 
   public void testDeserialize1dArray() throws IOException {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    double[] array = fromJson(arrayAdapter, "[1.0,2.0,3.0]");
+    double[] array = arrayAdapter.fromJson("[1.0,2.0,3.0]");
     assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));
   }
 
-  public void testSerialize2dArray() throws IOException {
+  public void testSerialize2dArray() {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
     double[][] array = { {1.0, 2.0 }, { 3.0 } };
-    assertEquals("[[1.0,2.0],[3.0]]", toJson(arrayAdapter, array));
+    assertEquals("[[1.0,2.0],[3.0]]", arrayAdapter.toJson(array));
   }
 
   public void testDeserialize2dArray() throws IOException {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
-    double[][] array = fromJson(arrayAdapter, "[[1.0,2.0],[3.0]]");
+    double[][] array = arrayAdapter.fromJson("[[1.0,2.0],[3.0]]");
     double[][] expected = { {1.0, 2.0 }, { 3.0 } };
     assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));
   }
@@ -186,7 +184,7 @@ public void write(JsonWriter out, Person person) throws IOException {
     assertEquals("jesse", truck.passengers.get(1).name);
   }
 
-  public void testSerializeRecursive() throws IOException {
+  public void testSerializeRecursive() {
     TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);
     Node root = new Node("root");
     root.left = new Node("left");
@@ -194,7 +192,7 @@ public void testSerializeRecursive() throws IOException {
     assertEquals("{'label':'root',"
         + "'left':{'label':'left','left':null,'right':null},"
         + "'right':{'label':'right','left':null,'right':null}}",
-        toJson(nodeAdapter, root).replace('"', '\''));
+        nodeAdapter.toJson(root).replace('"', '\''));
   }
   
   public void testFromJsonTree() {
@@ -243,19 +241,4 @@ public void testFromJsonTree() {
       this.label = label;
     }
   }
-
-  // TODO: remove this when TypeAdapter.toJson() is public
-  private static <T> String toJson(TypeAdapter<T> typeAdapter, T value) throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
-    typeAdapter.write(writer, value);
-    return stringWriter.toString();
-  }
-
-  // TODO: remove this when TypeAdapter.fromJson() is public
-  private <T> T fromJson(TypeAdapter<T> typeAdapter, String json) throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(json));
-    reader.setLenient(true); // TODO: non-lenient?
-    return typeAdapter.read(reader);
-  }
 }
diff --git a/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
new file mode 100644
index 000000000..431fc83dd
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import junit.framework.TestCase;
+
+/**
+ * Test unsafe allocator instantiation
+ * @author Ugljesa Jovanovic
+ */
+public final class UnsafeAllocatorInstantiationTest extends TestCase {
+
+  public interface Interface {
+  }
+
+  public static abstract class AbstractClass {
+  }
+
+  public static class ConcreteClass {
+  }
+
+  /**
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * to instantiate an interface
+   */
+  public void testInterfaceInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(Interface.class);
+      fail();
+    } catch (Exception e) {
+      assertEquals(e.getClass(), UnsupportedOperationException.class);
+    }
+  }
+
+  /**
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * to instantiate an abstract class
+   */
+  public void testAbstractClassInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(AbstractClass.class);
+      fail();
+    } catch (Exception e) {
+      assertEquals(e.getClass(), UnsupportedOperationException.class);
+    }
+  }
+
+  /**
+   * Ensure that no exception is thrown when trying to instantiate a concrete class
+   */
+  public void testConcreteClassInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(ConcreteClass.class);
+    } catch (Exception e) {
+      fail();
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
new file mode 100644
index 000000000..f6a5bf33e
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.bind;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.stream.JsonToken;
+import java.io.IOException;
+import junit.framework.TestCase;
+
+@SuppressWarnings("resource")
+public class JsonTreeReaderTest extends TestCase {
+  public void testSkipValue_emptyJsonObject() throws IOException {
+    JsonTreeReader in = new JsonTreeReader(new JsonObject());
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+
+  public void testSkipValue_filledJsonObject() throws IOException {
+    JsonObject jsonObject = new JsonObject();
+    JsonArray jsonArray = new JsonArray();
+    jsonArray.add('c');
+    jsonArray.add("text");
+    jsonObject.add("a", jsonArray);
+    jsonObject.addProperty("b", true);
+    jsonObject.addProperty("i", 1);
+    jsonObject.add("n", JsonNull.INSTANCE);
+    JsonObject jsonObject2 = new JsonObject();
+    jsonObject2.addProperty("n", 2L);
+    jsonObject.add("o", jsonObject2);
+    jsonObject.addProperty("s", "text");
+    JsonTreeReader in = new JsonTreeReader(jsonObject);
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
new file mode 100644
index 000000000..aaa577b53
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2017 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal.bind;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.internal.$Gson$Types;
+import junit.framework.TestCase;
+
+import java.io.PrintStream;
+import java.lang.ref.WeakReference;
+
+/**
+ * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,
+ * java.lang.reflect.Type)}, described at <a href="https://github.com/google/gson/issues/440">Issue #440</a>
+ * and similar issues.
+ * <p>
+ * These tests originally caused {@link StackOverflowError} because of infinite recursion on attempts to
+ * resolve generics on types, with an intermediate types like 'Foo2&lt;? extends ? super ? extends ... ? extends A&gt;'
+ */
+public class RecursiveTypesResolveTest extends TestCase {
+
+  private static class Foo1<A> {
+    public Foo2<? extends A> foo2;
+  }
+
+  private static class Foo2<B> {
+    public Foo1<? super B> foo1;
+  }
+
+  /**
+   * Test simplest case of recursion.
+   */
+  public void testRecursiveResolveSimple() {
+    TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);
+    assertNotNull(adapter);
+  }
+
+  //
+  // Real-world samples, found in Issues #603 and #440.
+  //
+  public void testIssue603PrintStream() {
+    TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);
+    assertNotNull(adapter);
+  }
+
+  public void testIssue440WeakReference() throws Exception {
+    TypeAdapter<WeakReference> adapter = new Gson().getAdapter(WeakReference.class);
+    assertNotNull(adapter);
+  }
+
+  //
+  // Tests belows check the behaviour of the methods changed for the fix
+  //
+
+  public void testDoubleSupertype() {
+    assertEquals($Gson$Types.supertypeOf(Number.class),
+            $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)));
+  }
+
+  public void testDoubleSubtype() {
+    assertEquals($Gson$Types.subtypeOf(Number.class),
+            $Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)));
+  }
+
+  public void testSuperSubtype() {
+    assertEquals($Gson$Types.subtypeOf(Object.class),
+            $Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)));
+  }
+
+  public void testSubSupertype() {
+    assertEquals($Gson$Types.subtypeOf(Object.class),
+            $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));
+  }
+
+  //
+  // tests for recursion while resolving type variables
+  //
+
+  private static class TestType<X> {
+    TestType<? super X> superType;
+  }
+
+  private static class TestType2<X, Y> {
+    TestType2<? super Y, ? super X> superReversedType;
+  }
+
+  public void testRecursiveTypeVariablesResolve1() throws Exception {
+    TypeAdapter<TestType> adapter = new Gson().getAdapter(TestType.class);
+    assertNotNull(adapter);
+  }
+
+  public void testRecursiveTypeVariablesResolve12() throws Exception {
+    TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);
+    assertNotNull(adapter);
+  }
+}
+
+
+
diff --git a/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java b/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
new file mode 100644
index 000000000..d5caaf537
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Field;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link UnsafeReflectionAccessor}
+ *
+ * @author Inderjeet Singh
+ */
+public class UnsafeReflectionAccessorTest {
+
+  @Test
+  public void testMakeAccessibleWithUnsafe() throws Exception {
+    UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+    Field field = ClassWithPrivateFinalFields.class.getDeclaredField("a");
+    try {
+      boolean success = accessor.makeAccessibleWithUnsafe(field);
+      assertTrue(success);
+    } catch (Exception e) {
+      fail("Unsafe didn't work on the JDK");
+    }
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ClassWithPrivateFinalFields {
+    private final String a;
+    public ClassWithPrivateFinalFields(String a) {
+      this.a = a;
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
index 7dda9d47d..40572716b 100644
--- a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.RandomAccess;
 import java.util.Set;
 import junit.framework.TestCase;
@@ -79,4 +80,26 @@ public void testIsAssignableFromWithNestedWildcards() throws Exception {
     // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false
     assertFalse(TypeToken.get(b).isAssignableFrom(a));
   }
+
+  public void testArrayFactory() {
+    TypeToken<?> expectedStringArray = new TypeToken<String[]>() {};
+    assertEquals(expectedStringArray, TypeToken.getArray(String.class));
+
+    TypeToken<?> expectedListOfStringArray = new TypeToken<List<String>[]>() {};
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertEquals(expectedListOfStringArray, TypeToken.getArray(listOfString));
+  }
+
+  public void testParameterizedFactory() {
+    TypeToken<?> expectedListOfString = new TypeToken<List<String>>() {};
+    assertEquals(expectedListOfString, TypeToken.getParameterized(List.class, String.class));
+
+    TypeToken<?> expectedMapOfStringToString = new TypeToken<Map<String, String>>() {};
+    assertEquals(expectedMapOfStringToString, TypeToken.getParameterized(Map.class, String.class, String.class));
+
+    TypeToken<?> expectedListOfListOfListOfString = new TypeToken<List<List<List<String>>>>() {};
+    Type listOfString = TypeToken.getParameterized(List.class, String.class).getType();
+    Type listOfListOfString = TypeToken.getParameterized(List.class, listOfString).getType();
+    assertEquals(expectedListOfListOfListOfString, TypeToken.getParameterized(List.class, listOfListOfString));
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
new file mode 100644
index 000000000..30a6775c8
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.regression;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.annotations.JsonAdapter;
+import com.google.gson.reflect.TypeToken;
+
+import junit.framework.TestCase;
+
+public class JsonAdapterNullSafeTest extends TestCase {
+  private final Gson gson = new Gson();
+
+  public void testNullSafeBugSerialize() throws Exception {
+    Device device = new Device("ec57803e");
+    gson.toJson(device);
+  }
+
+  public void testNullSafeBugDeserialize() throws Exception {
+    Device device = gson.fromJson("{'id':'ec57803e2'}", Device.class);
+    assertEquals("ec57803e2", device.id);
+  }
+
+  @JsonAdapter(Device.JsonAdapterFactory.class)
+  private static final class Device {
+    String id;
+    Device(String id) {
+      this.id = id;
+    }
+
+    static final class JsonAdapterFactory implements TypeAdapterFactory {
+      // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug
+      // because we use it to return a null type adapter on a recursive call.
+      private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();
+
+      @SuppressWarnings({"unchecked", "rawtypes"})
+      @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {
+        if (type.getRawType() != Device.class || recursiveCall.get() != null) {
+          recursiveCall.set(null); // clear for subsequent use
+          return null;
+        }
+        recursiveCall.set(Boolean.TRUE);
+        return (TypeAdapter) gson.getDelegateAdapter(this, type);
+      }
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
index 50661664c..c0b269172 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
@@ -16,15 +16,35 @@
 
 package com.google.gson.stream;
 
+import com.google.gson.JsonElement;
+import com.google.gson.internal.Streams;
+import com.google.gson.internal.bind.JsonTreeReader;
 import java.io.IOException;
 import java.io.StringReader;
-import junit.framework.TestCase;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-@SuppressWarnings("resource")
-public class JsonReaderPathTest extends TestCase {
-  public void testPath() throws IOException {
-    JsonReader reader = new JsonReader(
-        new StringReader("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}"));
+import static junit.framework.Assert.assertEquals;
+import static org.junit.Assume.assumeTrue;
+
+@RunWith(Parameterized.class)
+public class JsonReaderPathTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { Factory.STRING_READER },
+        new Object[] { Factory.OBJECT_READER }
+    );
+  }
+
+  @Parameterized.Parameter
+  public Factory factory;
+
+  @Test public void path() throws IOException {
+    JsonReader reader = factory.create("{\"a\":[2,true,false,null,\"b\",{\"c\":\"d\"},[3]]}");
     assertEquals("$", reader.getPath());
     reader.beginObject();
     assertEquals("$.", reader.getPath());
@@ -62,8 +82,8 @@ public void testPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testObjectPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+  @Test public void objectPath() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1,\"b\":2}");
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -102,8 +122,8 @@ public void testObjectPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testArrayPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2]"));
+  @Test public void arrayPath() throws IOException {
+    JsonReader reader = factory.create("[1,2]");
     assertEquals("$", reader.getPath());
 
     reader.peek();
@@ -132,8 +152,10 @@ public void testArrayPath() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[][]"));
+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {
+    assumeTrue(factory == Factory.STRING_READER);
+
+    JsonReader reader = factory.create("[][]");
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -143,24 +165,25 @@ public void testMultipleTopLevelValuesInOneDocument() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testSkipArrayElements() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[1,2,3]"));
+  @Test public void skipArrayElements() throws IOException {
+    JsonReader reader = factory.create("[1,2,3]");
     reader.beginArray();
     reader.skipValue();
     reader.skipValue();
     assertEquals("$[2]", reader.getPath());
   }
 
-  public void testSkipObjectNames() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1}"));
+  @Test public void skipObjectNames() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1}");
     reader.beginObject();
     reader.skipValue();
     assertEquals("$.null", reader.getPath());
   }
 
-  public void testSkipObjectValues() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("{\"a\":1,\"b\":2}"));
+  @Test public void skipObjectValues() throws IOException {
+    JsonReader reader = factory.create("{\"a\":1,\"b\":2}");
     reader.beginObject();
+    assertEquals("$.", reader.getPath());
     reader.nextName();
     reader.skipValue();
     assertEquals("$.null", reader.getPath());
@@ -168,15 +191,15 @@ public void testSkipObjectValues() throws IOException {
     assertEquals("$.b", reader.getPath());
   }
 
-  public void testSkipNestedStructures() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[1,2,3],4]"));
+  @Test public void skipNestedStructures() throws IOException {
+    JsonReader reader = factory.create("[[1,2,3],4]");
     reader.beginArray();
     reader.skipValue();
     assertEquals("$[1]", reader.getPath());
   }
 
-  public void testArrayOfObjects() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[{},{},{}]"));
+  @Test public void arrayOfObjects() throws IOException {
+    JsonReader reader = factory.create("[{},{},{}]");
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginObject();
@@ -195,8 +218,8 @@ public void testArrayOfObjects() throws IOException {
     assertEquals("$", reader.getPath());
   }
 
-  public void testArrayOfArrays() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader("[[],[],[]]"));
+  @Test public void arrayOfArrays() throws IOException {
+    JsonReader reader = factory.create("[[],[],[]]");
     reader.beginArray();
     assertEquals("$[0]", reader.getPath());
     reader.beginArray();
@@ -214,4 +237,20 @@ public void testArrayOfArrays() throws IOException {
     reader.endArray();
     assertEquals("$", reader.getPath());
   }
+
+  enum Factory {
+    STRING_READER {
+      @Override public JsonReader create(String data) {
+        return new JsonReader(new StringReader(data));
+      }
+    },
+    OBJECT_READER {
+      @Override public JsonReader create(String data) {
+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));
+        return new JsonTreeReader(element);
+      }
+    };
+
+    abstract JsonReader create(String data);
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
index 72c9aa4cb..19ca2d234 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
@@ -174,6 +174,21 @@ public void testHelloWorld() throws IOException {
     assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
+  public void testInvalidJsonInput() throws IOException {
+    String json = "{\n"
+        + "   \"h\\ello\": true,\n"
+        + "   \"foo\": [\"world\"]\n"
+        + "}";
+
+    JsonReader reader = new JsonReader(reader(json));
+    reader.beginObject();
+    try {
+      reader.nextName();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+  
   public void testNulls() {
     try {
       new JsonReader(null);
@@ -195,14 +210,6 @@ public void testEmptyString() {
     }
   }
 
-  public void testNoTopLevelObject() {
-    try {
-      new JsonReader(reader("true")).nextBoolean();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
   public void testCharacterUnescaping() throws IOException {
     String json = "[\"a\","
         + "\"a\\\"\","
@@ -509,7 +516,7 @@ public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException
     try {
       reader.nextInt();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (NumberFormatException expected) {
     }
     assertEquals("12.34e5x", reader.nextString());
   }
@@ -553,6 +560,18 @@ public void testLongLargerThanMinLongThatWrapsAround() throws IOException {
     } catch (NumberFormatException expected) {
     }
   }
+  
+  /**
+   * Issue 1053, negative zero.
+   * @throws Exception
+   */
+  public void testNegativeZero() throws Exception {
+	  	JsonReader reader = new JsonReader(reader("[-0]"));
+	    reader.setLenient(false);
+	    reader.beginArray();
+	    assertEquals(NUMBER, reader.peek());
+	    assertEquals("-0", reader.nextString());
+  }
 
   /**
    * This test fails because there's no double for 9223372036854775808, and our
@@ -1227,44 +1246,37 @@ public void testStrictMultipleTopLevelValuesWithSkipValue() throws IOException {
     }
   }
 
-  public void testStrictTopLevelString() {
-    JsonReader reader = new JsonReader(reader("\"a\""));
-    try {
-      reader.nextString();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
+  public void testTopLevelValueTypes() throws IOException {
+    JsonReader reader1 = new JsonReader(reader("true"));
+    assertTrue(reader1.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());
 
-  public void testLenientTopLevelString() throws IOException {
-    JsonReader reader = new JsonReader(reader("\"a\""));
-    reader.setLenient(true);
-    assertEquals("a", reader.nextString());
-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
-  }
+    JsonReader reader2 = new JsonReader(reader("false"));
+    assertFalse(reader2.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());
 
-  public void testStrictTopLevelValueType() {
-    JsonReader reader = new JsonReader(reader("true"));
-    try {
-      reader.nextBoolean();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
+    JsonReader reader3 = new JsonReader(reader("null"));
+    assertEquals(JsonToken.NULL, reader3.peek());
+    reader3.nextNull();
+    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());
 
-  public void testLenientTopLevelValueType() throws IOException {
-    JsonReader reader = new JsonReader(reader("true"));
-    reader.setLenient(true);
-    assertEquals(true, reader.nextBoolean());
+    JsonReader reader4 = new JsonReader(reader("123"));
+    assertEquals(123, reader4.nextInt());
+    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());
+
+    JsonReader reader5 = new JsonReader(reader("123.4"));
+    assertEquals(123.4, reader5.nextDouble());
+    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());
+
+    JsonReader reader6 = new JsonReader(reader("\"a\""));
+    assertEquals("a", reader6.nextString());
+    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());
   }
 
-  public void testStrictTopLevelValueTypeWithSkipValue() {
+  public void testTopLevelValueTypeWithSkipValue() throws IOException {
     JsonReader reader = new JsonReader(reader("true"));
-    try {
-      reader.skipValue();
-      fail();
-    } catch (IOException expected) {
-    }
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testStrictNonExecutePrefix() {
@@ -1524,7 +1536,7 @@ public void testUnterminatedObject() throws IOException {
     } catch (MalformedJsonException expected) {
     }
   }
-  
+
   public void testVeryLongQuotedString() throws IOException {
     char[] stringChars = new char[1024 * 16];
     Arrays.fill(stringChars, 'x');
diff --git a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
index 4cfd55a72..2bcec173c 100644
--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
@@ -16,20 +16,54 @@
 
 package com.google.gson.stream;
 
+import junit.framework.TestCase;
+
 import java.io.IOException;
 import java.io.StringWriter;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import junit.framework.TestCase;
 
 @SuppressWarnings("resource")
 public final class JsonWriterTest extends TestCase {
 
-  public void testWrongTopLevelType() throws IOException {
+  public void testTopLevelValueTypes() throws IOException {
+    StringWriter string1 = new StringWriter();
+    JsonWriter writer1 = new JsonWriter(string1);
+    writer1.value(true);
+    writer1.close();
+    assertEquals("true", string1.toString());
+
+    StringWriter string2 = new StringWriter();
+    JsonWriter writer2 = new JsonWriter(string2);
+    writer2.nullValue();
+    writer2.close();
+    assertEquals("null", string2.toString());
+
+    StringWriter string3 = new StringWriter();
+    JsonWriter writer3 = new JsonWriter(string3);
+    writer3.value(123);
+    writer3.close();
+    assertEquals("123", string3.toString());
+
+    StringWriter string4 = new StringWriter();
+    JsonWriter writer4 = new JsonWriter(string4);
+    writer4.value(123.4);
+    writer4.close();
+    assertEquals("123.4", string4.toString());
+
+    StringWriter string5 = new StringWriter();
+    JsonWriter writert = new JsonWriter(string5);
+    writert.value("a");
+    writert.close();
+    assertEquals("\"a\"", string5.toString());
+  }
+
+  public void testInvalidTopLevelTypes() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.name("hello");
     try {
-      jsonWriter.value("a");
+      jsonWriter.value("world");
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -180,6 +214,30 @@ public void testNonFiniteBoxedDoubles() throws IOException {
     }
   }
 
+  public void testNonFiniteDoublesWhenLenient() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setLenient(true);
+    jsonWriter.beginArray();
+    jsonWriter.value(Double.NaN);
+    jsonWriter.value(Double.NEGATIVE_INFINITY);
+    jsonWriter.value(Double.POSITIVE_INFINITY);
+    jsonWriter.endArray();
+    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
+  }
+
+  public void testNonFiniteBoxedDoublesWhenLenient() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.setLenient(true);
+    jsonWriter.beginArray();
+    jsonWriter.value(Double.valueOf(Double.NaN));
+    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));
+    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));
+    jsonWriter.endArray();
+    assertEquals("[NaN,-Infinity,Infinity]", stringWriter.toString());
+  }
+
   public void testDoubles() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
@@ -250,6 +308,17 @@ public void testBooleans() throws IOException {
     assertEquals("[true,false]", stringWriter.toString());
   }
 
+  public void testBoxedBooleans() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value((Boolean) true);
+    jsonWriter.value((Boolean) false);
+    jsonWriter.value((Boolean) null);
+    jsonWriter.endArray();
+    assertEquals("[true,false,null]", stringWriter.toString());
+  }
+
   public void testNulls() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
diff --git a/pom.xml b/pom.xml
index e8edde909..187434336 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,95 +1,113 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-parent</artifactId>
-  <packaging>pom</packaging>
-  <version>2.5-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson Parent</name>
+
   <parent>
     <groupId>org.sonatype.oss</groupId>
     <artifactId>oss-parent</artifactId>
-    <version>9</version>
-    <relativePath />
+    <version>7</version>
   </parent>
+
+  <groupId>com.google.code.gson</groupId>
+  <artifactId>gson-parent</artifactId>
+  <version>2.8.4-SNAPSHOT</version>
+  <packaging>pom</packaging>
+
+  <name>Gson Parent</name>
+  <description>Gson JSON library</description>
   <url>https://github.com/google/gson</url>
-  <description>Google Gson library</description>
+
+  <modules>
+    <module>gson</module>
+  </modules>
+
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <java.version>1.6</java.version>
   </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
+
   <scm>
+    <url>https://github.com/google/gson/</url>
     <connection>scm:git:https://github.com/google/gson.git</connection>
-    <developerConnection>scm:git:https://github.com/google/gson.git</developerConnection>
-    <url>https://github.com/google/gson</url>
-    <tag>gson-${project.version}</tag>
+    <developerConnection>scm:git:git@github.com:google/gson.git</developerConnection>
+    <tag>HEAD</tag>
   </scm>
+
   <issueManagement>
-    <system>Github Issue Tracking</system>
+    <system>GitHub Issues</system>
     <url>https://github.com/google/gson/issues</url>
   </issueManagement>
-  <distributionManagement>
-    <snapshotRepository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>Sonatype Nexus Snapshots</name>
-      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-    <repository>
-      <id>sonatype-nexus-staging</id>
-      <name>Nexus Release Repository</name>
-      <url>http://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-    </repository>
-  </distributionManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.2</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <modules>
-    <module>gson</module>
-  </modules>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>junit</groupId>
+        <artifactId>junit</artifactId>
+        <version>4.12</version>
+        <scope>test</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <version>3.7.0</version>
+          <configuration>
+            <excludes>
+              <exclude>**/module-info.java</exclude>
+            </excludes>
+            <source>${java.version}</source>
+            <target>${java.version}</target>
+          </configuration>
+        </plugin>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-javadoc-plugin</artifactId>
+          <version>2.10.4</version>
+        </plugin>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-jar-plugin</artifactId>
+        </plugin>
+        <plugin>
+          <groupId>org.apache.felix</groupId>
+          <artifactId>maven-bundle-plugin</artifactId>
+          <version>3.3.0</version>
+          <inherited>true</inherited>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.5.3</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9.5</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
   <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.5</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
     <profile>
       <id>doclint-java8-disable</id>
       <activation>
@@ -108,142 +126,4 @@
       </build>
     </profile>
   </profiles>
-  <build>
-    <defaultGoal>package</defaultGoal>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.3</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.6</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-            <manifestEntries>
-              <Bundle-RequiredExecutionEnvironment>J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8</Bundle-RequiredExecutionEnvironment>
-              <Export-Package><![CDATA[com.google.gson;version=${project.version}, com.google.gson.annotations;version=${project.version}, com.google.gson.reflect;version=${project.version}, com.google.gson.stream;version=${project.version}, com.google.gson.internal;version=${project.version}, com.google.gson.internal.bind;version=${project.version}]]></Export-Package>
-              <Bundle-Version>${project.version}</Bundle-Version>
-              <Bundle-ContactAddress>https://github.com/google/gson</Bundle-ContactAddress>
-              <Bundle-Vendor>Google Gson Project</Bundle-Vendor>
-              <Bundle-Name>${project.name}</Bundle-Name>
-              <Bundle-Description>${project.description}</Bundle-Description>
-              <Bundle-ClassPath>.</Bundle-ClassPath>
-              <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-              <Bundle-SymbolicName>com.google.gson</Bundle-SymbolicName>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-      <plugin>
-       <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <archive>
-             <manifestEntries>
-               <Eclipse-SourceBundle>com.google.gson;version="${project.version}"</Eclipse-SourceBundle>
-               <Bundle-SymbolicName>com.google.gson.source</Bundle-SymbolicName>
-               <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-               <Bundle-Version>${project.version}</Bundle-Version>
-             </manifestEntries>
-           </archive>
-         </configuration>
-       </plugin>
-       <plugin>
-         <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.3</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <includePackageNames>com.google.gson</includePackageNames>
-           <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
-            <links>
-             <link>http://docs.oracle.com/javase/1.5.0/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>protected</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.10</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <!-- version>2.5</version -->
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.5.5</version>
-        <configuration>
-          <descriptor>assembly-descriptor.xml</descriptor>
-          <finalName>google-gson-${project.version}</finalName>
-          <outputDirectory>target/dist</outputDirectory>
-          <workDirectory>target/assembly/work</workDirectory>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
 </project>
diff --git a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
index ff44779f1..c378685c8 100644
--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Converter;
 import com.google.common.collect.MapMaker;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonDeserializationContext;
@@ -35,8 +34,8 @@
 import com.google.protobuf.Descriptors.EnumDescriptor;
 import com.google.protobuf.Descriptors.EnumValueDescriptor;
 import com.google.protobuf.Descriptors.FieldDescriptor;
+import com.google.protobuf.DynamicMessage;
 import com.google.protobuf.Extension;
-import com.google.protobuf.GeneratedMessage;
 import com.google.protobuf.Message;
 
 import java.lang.reflect.Field;
@@ -73,7 +72,7 @@
  * @author Stanley Wang
  */
 public class ProtoTypeAdapter
-    implements JsonSerializer<GeneratedMessage>, JsonDeserializer<GeneratedMessage> {
+    implements JsonSerializer<Message>, JsonDeserializer<Message> {
   /**
    * Determines how enum <u>values</u> should be serialized.
    */
@@ -94,7 +93,8 @@
     private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
     private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
     private EnumSerialization enumSerialization;
-    private Converter<String, String> fieldNameSerializationFormat;
+    private CaseFormat protoFormat;
+    private CaseFormat jsonFormat;
 
     private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
@@ -126,7 +126,8 @@ public Builder setEnumSerialization(EnumSerialization enumSerialization) {
      */
     public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
-      fieldNameSerializationFormat = fromFieldNameFormat.converterTo(toFieldNameFormat);
+      this.protoFormat = fromFieldNameFormat;
+      this.jsonFormat = toFieldNameFormat;
       return this;
     }
 
@@ -174,7 +175,7 @@ public Builder addSerializedEnumValueExtension(
     }
 
     public ProtoTypeAdapter build() {
-      return new ProtoTypeAdapter(enumSerialization, fieldNameSerializationFormat,
+      return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat,
           serializedNameExtensions, serializedEnumValueExtensions);
     }
   }
@@ -195,22 +196,25 @@ public static Builder newBuilder() {
       new MapMaker().makeMap();
 
   private final EnumSerialization enumSerialization;
-  private final Converter<String, String> fieldNameSerializationFormat;
+  private final CaseFormat protoFormat;
+  private final CaseFormat jsonFormat;
   private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
   private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
 
   private ProtoTypeAdapter(EnumSerialization enumSerialization,
-      Converter<String, String> fieldNameSerializationFormat,
+      CaseFormat protoFormat,
+      CaseFormat jsonFormat,
       Set<Extension<FieldOptions, String>> serializedNameExtensions,
       Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {
     this.enumSerialization = enumSerialization;
-    this.fieldNameSerializationFormat = fieldNameSerializationFormat;
+    this.protoFormat = protoFormat;
+    this.jsonFormat = jsonFormat;
     this.serializedNameExtensions = serializedNameExtensions;
     this.serializedEnumValueExtensions = serializedEnumValueExtensions;
   }
 
   @Override
-  public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
+  public JsonElement serialize(Message src, Type typeOfSrc,
       JsonSerializationContext context) {
     JsonObject ret = new JsonObject();
     final Map<FieldDescriptor, Object> fields = src.getAllFields();
@@ -243,17 +247,24 @@ public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
   }
 
   @Override
-  public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
+  public Message deserialize(JsonElement json, Type typeOfT,
       JsonDeserializationContext context) throws JsonParseException {
     try {
       JsonObject jsonObject = json.getAsJsonObject();
       @SuppressWarnings("unchecked")
-      Class<? extends GeneratedMessage> protoClass = (Class<? extends GeneratedMessage>) typeOfT;
+      Class<? extends Message> protoClass = (Class<? extends Message>) typeOfT;
+
+      if (DynamicMessage.class.isAssignableFrom(protoClass)) {
+        throw new IllegalStateException("only generated messages are supported");
+      }
 
       try {
         // Invoke the ProtoClass.newBuilder() method
-        GeneratedMessage.Builder<?> protoBuilder =
-            (GeneratedMessage.Builder<?>) getCachedMethod(protoClass, "newBuilder").invoke(null);
+        Message.Builder protoBuilder =
+            (Message.Builder) getCachedMethod(protoClass, "newBuilder").invoke(null);
+
+        Message defaultInstance =
+            (Message) getCachedMethod(protoClass, "getDefaultInstance").invoke(null);
 
         Descriptor protoDescriptor =
             (Descriptor) getCachedMethod(protoClass, "getDescriptor").invoke(null);
@@ -262,15 +273,15 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
           String jsonFieldName =
               getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());
 
-          if (jsonObject.has(jsonFieldName)) {
-            JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          if (jsonElement != null && !jsonElement.isJsonNull()) {
             // Do not reuse jsonFieldName here, it might have a custom value
             Object fieldValue;
             if (fieldDescriptor.getType() == ENUM_TYPE) {
               if (jsonElement.isJsonArray()) {
                 // Handling array
                 Collection<EnumValueDescriptor> enumCollection =
-                    new ArrayList<EnumValueDescriptor>();
+                    new ArrayList<EnumValueDescriptor>(jsonElement.getAsJsonArray().size());
                 for (JsonElement element : jsonElement.getAsJsonArray()) {
                   enumCollection.add(
                       findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));
@@ -284,21 +295,21 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else if (fieldDescriptor.isRepeated()) {
               // If the type is an array, then we have to grab the type from the class.
+              // protobuf java field names are always lower camel case
               String protoArrayFieldName =
-                  fieldNameSerializationFormat.convert(fieldDescriptor.getName()) + "_";
+                  protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + "_";
               Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);
               Type protoArrayFieldType = protoArrayField.getGenericType();
               fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else {
-              Message prototype = protoBuilder.build();
-              Object field = prototype.getField(fieldDescriptor);
+              Object field = defaultInstance.getField(fieldDescriptor);
               fieldValue = context.deserialize(jsonElement, field.getClass());
               protoBuilder.setField(fieldDescriptor, fieldValue);
             }
           }
         }
-        return (GeneratedMessage) protoBuilder.build();
+        return (Message) protoBuilder.build();
       } catch (SecurityException e) {
         throw new JsonParseException(e);
       } catch (NoSuchMethodException e) {
@@ -325,7 +336,7 @@ private String getCustSerializedName(FieldOptions options, String defaultName) {
         return options.getExtension(extension);
       }
     }
-    return fieldNameSerializationFormat.convert(defaultName);
+    return protoFormat.to(jsonFormat, defaultName);
   }
 
   /**
diff --git a/proto/src/main/protobuf/bag.proto b/proto/src/main/protobuf/bag.proto
index 26189a24f..48cc96397 100644
--- a/proto/src/main/protobuf/bag.proto
+++ b/proto/src/main/protobuf/bag.proto
@@ -24,6 +24,11 @@ message SimpleProto {
   optional int32 count = 2;
 }
 
+message ProtoWithDifferentCaseFormat {
+  repeated string name_that_tests_case_format = 1;
+  optional string another_field = 2;
+}
+
 message ProtoWithRepeatedFields {
   repeated int64 numbers = 1;
   repeated SimpleProto simples = 2;
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
index 964549d6b..b61d3f509 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
@@ -15,10 +15,13 @@
  */
 package com.google.gson.protobuf.functional;
 
+import com.google.common.base.CaseFormat;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
 import com.google.gson.protobuf.ProtoTypeAdapter;
 import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
+import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
 import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
 import com.google.protobuf.GeneratedMessage;
@@ -32,6 +35,7 @@
  */
 public class ProtosWithComplexAndRepeatedFieldsTest extends TestCase {
   private Gson gson;
+  private Gson upperCamelGson;
 
   @Override
   protected void setUp() throws Exception {
@@ -43,6 +47,14 @@ protected void setUp() throws Exception {
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
             .create();
+    upperCamelGson =
+        new GsonBuilder()
+            .registerTypeHierarchyAdapter(
+                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+                    .setFieldNameSerializationFormat(
+                        CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
+                    .build())
+            .create();
   }
 
   public void testSerializeRepeatedFields() {
@@ -67,4 +79,23 @@ public void testDeserializeRepeatedFieldsProto() {
     assertEquals("bar", proto.getSimples(0).getMsg());
     assertEquals(7, proto.getSimples(1).getCount());
   }
+
+  public void testSerializeDifferentCaseFormat() {
+    final ProtoWithDifferentCaseFormat proto =
+      ProtoWithDifferentCaseFormat.newBuilder()
+        .setAnotherField("foo")
+        .addNameThatTestsCaseFormat("bar")
+        .build();
+    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
+    assertEquals("foo", json.get("AnotherField").getAsString());
+    assertEquals("bar", json.get("NameThatTestsCaseFormat").getAsJsonArray().get(0).getAsString());
+  }
+
+  public void testDeserializeDifferentCaseFormat() {
+    final String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
+    ProtoWithDifferentCaseFormat proto =
+      upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
+    assertEquals("foo", proto.getAnotherField());
+    assertEquals("bar", proto.getNameThatTestsCaseFormat(0));
+  }
 }
diff --git a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
index f90899e1c..69b877e60 100644
--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
@@ -66,4 +66,11 @@ public void testDeserializeProto() {
     assertEquals("foo", proto.getMsg());
     assertEquals(3, proto.getCount());
   }
+
+  public void testDeserializeWithExplicitNullValue() {
+    SimpleProto proto = gson.fromJson("{msg:'foo',count:null}", SimpleProto.class);
+    assertEquals("foo", proto.getMsg());
+    assertEquals(0, proto.getCount());
+  }
+
 }
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 000000000..975ec9b39
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':gson'
