diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 984dc4a5c..41af6290e 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -78,7 +78,6 @@
 	static final boolean DEFAULT_ESCAPE_HTML = true;
 	static final boolean DEFAULT_SERIALIZE_NULLS = false;
 	static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
-	static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
 	private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
 	private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
@@ -105,7 +104,6 @@
 	final boolean generateNonExecutableJson;
 	final boolean htmlSafe;
 	final boolean prettyPrinting;
-	final boolean serializeSpecialFloatingPointValues;
 	final String datePattern;
 	final int dateStyle;
 	final int timeStyle;
@@ -113,54 +111,10 @@
 	final List<TypeAdapterFactory> builderFactories;
 	final List<TypeAdapterFactory> builderHierarchyFactories;
 
-	/**
-	 * Constructs a Gson object with default configuration. The default configuration has the
-	 * following settings:
-	 * <ul>
-	 *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This
-	 *   means that all the unneeded white-space is removed. You can change this behavior with
-	 *   {@link GsonBuilder#setPrettyPrinting()}. </li>
-	 *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are
-	 *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its
-	 *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values
-	 *   by setting {@link GsonBuilder#serializeNulls()}.</li>
-	 *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},
-	 *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},
-	 *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer
-	 *   to change the default representation, you can do so by registering a type adapter through
-	 *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>
-	 *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format
-	 *   ignores the millisecond portion of the date during serialization. You can change
-	 *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
-	 *   {@link GsonBuilder#setDateFormat(String)}. </li>
-	 *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.
-	 *   You can enable Gson to serialize/deserialize only those fields marked with this annotation
-	 *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>
-	 *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
-	 *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
-	 *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
-	 *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
-	 *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
-	 *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>
-	 *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from
-	 *   consideration for serialization and deserialization. You can change this behavior through
-	 *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>
-	 * </ul>
-	 */
-	private Gson() {
-		this(Excluder.DEFAULT, FieldNamingStrategy.IDENTITY,
-				Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
-				DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
-				DEFAULT_PRETTY_PRINT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
-				LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,
-				Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
-				Collections.<TypeAdapterFactory>emptyList());
-	}
-
 	Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
 			Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
 			boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
-			boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
+			boolean prettyPrinting,
 			LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,
 			int timeStyle, List<TypeAdapterFactory> builderFactories,
 			List<TypeAdapterFactory> builderHierarchyFactories,
@@ -173,7 +127,6 @@ private Gson() {
 		this.generateNonExecutableJson = generateNonExecutableGson;
 		this.htmlSafe = htmlSafe;
 		this.prettyPrinting = prettyPrinting;
-		this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;
 		this.longSerializationPolicy = longSerializationPolicy;
 		this.datePattern = datePattern;
 		this.dateStyle = dateStyle;
@@ -202,9 +155,9 @@ private Gson() {
 		TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);
 		factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));
 		factories.add(TypeAdapters.newFactory(double.class, Double.class,
-				doubleAdapter(serializeSpecialFloatingPointValues)));
+				TypeAdapters.DOUBLE));
 		factories.add(TypeAdapters.newFactory(float.class, Float.class,
-				floatAdapter(serializeSpecialFloatingPointValues)));
+				TypeAdapters.FLOAT));
 		factories.add(TypeAdapters.NUMBER_FACTORY);
 		factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);
 		factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);
@@ -333,62 +286,6 @@ public boolean htmlSafe() {
 		return htmlSafe;
 	}
 
-	private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
-		if (serializeSpecialFloatingPointValues) {
-			return TypeAdapters.DOUBLE;
-		}
-		return new TypeAdapter<>() {
-			@Override public Double read(JsonReader in) throws IOException {
-				if (in.peek() == JsonToken.NULL) {
-					in.nextNull();
-					return null;
-				}
-				return in.nextDouble();
-			}
-			@Override public void write(JsonWriter out, Number value) throws IOException {
-				if (value == null) {
-					out.nullValue();
-					return;
-				}
-				double doubleValue = value.doubleValue();
-				checkValidFloatingPoint(doubleValue);
-				out.value(value);
-			}
-		};
-	}
-
-	private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {
-		if (serializeSpecialFloatingPointValues) {
-			return TypeAdapters.FLOAT;
-		}
-		return new TypeAdapter<>() {
-			@Override public Float read(JsonReader in) throws IOException {
-				if (in.peek() == JsonToken.NULL) {
-					in.nextNull();
-					return null;
-				}
-				return (float) in.nextDouble();
-			}
-			@Override public void write(JsonWriter out, Number value) throws IOException {
-				if (value == null) {
-					out.nullValue();
-					return;
-				}
-				float floatValue = value.floatValue();
-				checkValidFloatingPoint(floatValue);
-				out.value(value);
-			}
-		};
-	}
-
-	static void checkValidFloatingPoint(double value) {
-		if (Double.isNaN(value) || Double.isInfinite(value)) {
-			throw new IllegalArgumentException(value
-					+ " is not a valid double value as per JSON specification. To override this"
-					+ " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
-		}
-	}
-
 	private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {
 		if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {
 			return TypeAdapters.LONG;
@@ -722,7 +619,6 @@ public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOE
 	public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
 		TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
 		boolean oldLenient = writer.isLenient();
-		writer.setLenient(true);
 		boolean oldHtmlSafe = writer.isHtmlSafe();
 		writer.setHtmlSafe(htmlSafe);
 		boolean oldSerializeNulls = writer.getSerializeNulls();
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 8e88f0111..627ed5667 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -16,28 +16,16 @@
 
 package com.google.gson;
 
-import java.lang.reflect.Type;
-import java.sql.Timestamp;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import static com.google.gson.Gson.*;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Excluder;
+import com.google.gson.internal.*;
 import com.google.gson.internal.bind.*;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-
-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
-import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+import com.google.gson.reflect.*;
+import java.lang.reflect.*;
+import java.sql.*;
+import java.text.*;
+import java.util.*;
+import java.util.Date;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -87,7 +75,6 @@
   private int dateStyle = DateFormat.DEFAULT;
   private int timeStyle = DateFormat.DEFAULT;
   private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
-  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;
   private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
   private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
   private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
@@ -115,7 +102,6 @@
     this.generateNonExecutableJson = gson.generateNonExecutableJson;
     this.escapeHtmlChars = gson.htmlSafe;
     this.prettyPrinting = gson.prettyPrinting;
-    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;
     this.longSerializationPolicy = gson.longSerializationPolicy;
     this.datePattern = gson.datePattern;
     this.dateStyle = gson.dateStyle;
@@ -521,31 +507,6 @@ public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAd
     return this;
   }
 
-  /**
-   * Section 2.4 of <a href="http://www.ietf.org/rfc/rfc4627.txt">JSON specification</a> disallows
-   * special double values (NaN, Infinity, -Infinity). However,
-   * <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Javascript
-   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript
-   * values. Moreover, most JavaScript engines will accept these special values in JSON without
-   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even
-   * though JSON specification disallows them.
-   *
-   * <p>Gson always accepts these special values during deserialization. However, it outputs
-   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},
-   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value
-   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it
-   * will throw an {@link IllegalArgumentException}. This method provides a way to override the
-   * default behavior when you know that the JSON receiver will be able to handle these special
-   * values.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.3
-   */
-  public GsonBuilder serializeSpecialFloatingPointValues() {
-    this.serializeSpecialFloatingPointValues = true;
-    return this;
-  }
-
   /**
    * Creates a {@link Gson} instance based on the current configuration. This method is free of
    * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.
@@ -566,7 +527,7 @@ public Gson build() {
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
-        serializeSpecialFloatingPointValues, longSerializationPolicy,
+        longSerializationPolicy,
         datePattern, dateStyle, timeStyle,
         this.factories, this.hierarchyFactories, factories);
   }
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
index 354ce5a1f..b6b71712f 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
@@ -323,9 +323,23 @@ public Number read(JsonReader in) throws IOException {
     }
     @Override
     public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
+    	if (value == null) {
+			out.nullValue();
+			return;
+		}
+		float floatValue = value.floatValue();
+		checkValidFloatingPoint(floatValue);
+		out.value(value);
     }
   };
+  
+  static void checkValidFloatingPoint(double value) {
+		if (Double.isNaN(value) || Double.isInfinite(value)) {
+			throw new IllegalArgumentException(value
+					+ " is not a valid double value as per JSON specification. To override this"
+					+ " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
+		}
+	}
 
   public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {
     @Override
@@ -338,7 +352,13 @@ public Number read(JsonReader in) throws IOException {
     }
     @Override
     public void write(JsonWriter out, Number value) throws IOException {
-      out.value(value);
+    	if (value == null) {
+			out.nullValue();
+			return;
+		}
+		double doubleValue = value.doubleValue();
+		checkValidFloatingPoint(doubleValue);
+		out.value(value);
     }
   };
 
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 80c4c1645..fa2711a00 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -47,7 +47,7 @@
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
@@ -60,7 +60,7 @@ public void testOverridesDefaultExcluder() {
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        true, false, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
+        true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>());
 
diff --git a/gson/src/test/java/com/google/gson/MixedStreamTest.java b/gson/src/test/java/com/google/gson/MixedStreamTest.java
index 36d19d3b9..1552aeec6 100644
--- a/gson/src/test/java/com/google/gson/MixedStreamTest.java
+++ b/gson/src/test/java/com/google/gson/MixedStreamTest.java
@@ -196,24 +196,6 @@ public void testWriteHtmlSafe() {
         writer.toString());
   }
 
-  public void testWriteLenient() {
-    List<Double> doubles = Arrays.asList(Double.NaN, Double.NEGATIVE_INFINITY,
-        Double.POSITIVE_INFINITY, -0.0d, 0.5d, 0.0d);
-    Type type = new TypeToken<List<Double>>() {}.getType();
-
-    StringWriter writer = new StringWriter();
-    JsonWriter jsonWriter = new JsonWriter(writer);
-    Gson.newBuilder().serializeSpecialFloatingPointValues().build()
-        .toJson(doubles, type, jsonWriter);
-    assertEquals("[NaN,-Infinity,Infinity,-0.0,0.5,0.0]", writer.toString());
-
-    try {
-      Gson.newGson().toJson(doubles, type, new JsonWriter(new StringWriter()));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
   static final class Car {
     String name;
     int color;
diff --git a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
index 441d039d4..45020f0e9 100644
--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
@@ -360,13 +360,6 @@ public void testDoubleNaNSerializationNotSupportedByDefault() {
     }
   }
 
-  public void testDoubleNaNSerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    double nan = Double.NaN;
-    assertEquals("NaN", gson.toJson(nan));
-    assertEquals("NaN", gson.toJson(Double.NaN));
-  }
-
   public void testDoubleNaNDeserialization() {
     assertTrue(Double.isNaN(gson.fromJson("NaN", Double.class)));
     assertTrue(Double.isNaN(gson.fromJson("NaN", double.class)));
@@ -386,13 +379,6 @@ public void testFloatNaNSerializationNotSupportedByDefault() {
     }
   }
 
-  public void testFloatNaNSerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    float nan = Float.NaN;
-    assertEquals("NaN", gson.toJson(nan));
-    assertEquals("NaN", gson.toJson(Float.NaN));
-  }
-
   public void testFloatNaNDeserialization() {
     assertTrue(Float.isNaN(gson.fromJson("NaN", Float.class)));
     assertTrue(Float.isNaN(gson.fromJson("NaN", float.class)));
@@ -420,13 +406,6 @@ public void testDoubleInfinitySerializationNotSupportedByDefault() {
     }
   }
 
-  public void testDoubleInfinitySerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    double infinity = Double.POSITIVE_INFINITY;
-    assertEquals("Infinity", gson.toJson(infinity));
-    assertEquals("Infinity", gson.toJson(Double.POSITIVE_INFINITY));
-  }
-
   public void testDoubleInfinityDeserialization() {
     assertTrue(Double.isInfinite(gson.fromJson("Infinity", Double.class)));
     assertTrue(Double.isInfinite(gson.fromJson("Infinity", double.class)));
@@ -446,13 +425,6 @@ public void testFloatInfinitySerializationNotSupportedByDefault() {
     }
   }
 
-  public void testFloatInfinitySerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    float infinity = Float.POSITIVE_INFINITY;
-    assertEquals("Infinity", gson.toJson(infinity));
-    assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY));
-  }
-
   public void testFloatInfinityDeserialization() {
     assertTrue(Float.isInfinite(gson.fromJson("Infinity", Float.class)));
     assertTrue(Float.isInfinite(gson.fromJson("Infinity", float.class)));
@@ -480,13 +452,6 @@ public void testNegativeInfinitySerializationNotSupportedByDefault() {
     }
   }
 
-  public void testNegativeInfinitySerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    double negativeInfinity = Double.NEGATIVE_INFINITY;
-    assertEquals("-Infinity", gson.toJson(negativeInfinity));
-    assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY));
-  }
-
   public void testNegativeInfinityDeserialization() {
     assertTrue(Double.isInfinite(gson.fromJson("-Infinity", double.class)));
     assertTrue(Double.isInfinite(gson.fromJson("-Infinity", Double.class)));
@@ -506,13 +471,6 @@ public void testNegativeInfinityFloatSerializationNotSupportedByDefault() {
     }
   }
 
-  public void testNegativeInfinityFloatSerialization() {
-    Gson gson = Gson.newBuilder().serializeSpecialFloatingPointValues().build();
-    float negativeInfinity = Float.NEGATIVE_INFINITY;
-    assertEquals("-Infinity", gson.toJson(negativeInfinity));
-    assertEquals("-Infinity", gson.toJson(Float.NEGATIVE_INFINITY));
-  }
-
   public void testNegativeInfinityFloatDeserialization() {
     assertTrue(Float.isInfinite(gson.fromJson("-Infinity", float.class)));
     assertTrue(Float.isInfinite(gson.fromJson("-Infinity", Float.class)));
@@ -521,7 +479,7 @@ public void testNegativeInfinityFloatDeserialization() {
   public void testBigDecimalNegativeInfinityDeserializationNotSupported() {
     try {
       gson.fromJson("-Infinity", BigDecimal.class);
-      fail("Gson should not accept positive infinity for deserialization");
+      fail("Gson should not accept negative infinity for deserialization");
     } catch (JsonSyntaxException expected) {
     }
   }
