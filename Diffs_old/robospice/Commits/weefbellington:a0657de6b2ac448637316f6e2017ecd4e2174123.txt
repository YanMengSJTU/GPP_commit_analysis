diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java
new file mode 100644
index 000000000..8feecc27b
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java
@@ -0,0 +1,7 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.test.InstrumentationTestCase;
+
+public class InMemoryBitmapObjectPersisterTest extends InstrumentationTestCase
+{
+}
diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java
new file mode 100644
index 000000000..98a86aa68
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java
@@ -0,0 +1,7 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.test.InstrumentationTestCase;
+
+public class InMemoryLRUCacheObjectPersisterTest extends InstrumentationTestCase
+{
+}
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
new file mode 100644
index 000000000..3bdb97f92
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
@@ -0,0 +1,65 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.app.ActivityManager;
+import android.app.Application;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.v4.util.LruCache;
+
+public class InMemoryBitmapObjectPersister
+    extends InMemoryLRUCacheObjectPersister<Bitmap>
+{
+
+    private final int cacheSize;
+
+    public InMemoryBitmapObjectPersister (Application application)
+    {
+        this(application, -1);
+    }
+
+    public InMemoryBitmapObjectPersister( Application application,
+                                          int cacheSize )
+    {
+        super( application, Bitmap.class );
+
+        // base Android memory class is 16 MB per process
+        // the cache should take up no more than 1/4 of the available app memory
+        if (cacheSize > 0)
+        {
+            this.cacheSize = cacheSize;
+        }
+        else
+        {
+            int memClass = ( (ActivityManager) application.getSystemService(
+                Context.ACTIVITY_SERVICE ) ).getMemoryClass();
+            this.cacheSize = 1024 * 1024 * 4 * (memClass / 16);
+        }
+    }
+
+    @Override
+    protected LruCache<String, CacheItem<Bitmap>> instantiateLRUCache()
+    {
+        return new LruCache<String, CacheItem<Bitmap>>(cacheSize)
+        {
+
+            @Override
+            protected int sizeOf( String key,
+                                  CacheItem<Bitmap> value )
+            {
+                return value.data.getRowBytes() *
+                       value.data.getHeight();
+            }
+
+            @Override
+            protected void entryRemoved( boolean evicted,
+                                         String key,
+                                         CacheItem<Bitmap> oldValue,
+                                         CacheItem<Bitmap> newValue )
+            {
+                super.entryRemoved( evicted, key, oldValue, newValue );
+            }
+        };
+    }
+
+
+}
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
new file mode 100644
index 000000000..f17dd58da
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
@@ -0,0 +1,124 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.app.Application;
+import android.os.SystemClock;
+import android.support.v4.util.LruCache;
+import com.octo.android.robospice.persistence.ObjectPersister;
+import com.octo.android.robospice.persistence.exception.CacheLoadingException;
+import com.octo.android.robospice.persistence.exception.CacheSavingException;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Persister for in-memory cache of Bitmaps
+ * used by RoboSpice to automagically cache / fetch images
+ * Stores data as bitmaps
+ */
+
+public abstract class InMemoryLRUCacheObjectPersister<T> extends ObjectPersister<T>
+{
+    private static final String CACHE_MISS_EXPIRED   =
+        "%s: found in cache but the data was stale.";
+    private static final String CACHE_MISS_NOT_FOUND =
+        "%s: not found in cache";
+
+    private LruCache<String, CacheItem<T>> memoryCache;
+
+    protected InMemoryLRUCacheObjectPersister( Application application,
+                                               Class<T> clazz )
+    {
+        super( application, clazz );
+    }
+
+    private LruCache<String, CacheItem<T>> getMemoryCache()
+    {
+        if ( memoryCache == null )
+        {
+            memoryCache = instantiateLRUCache();
+        }
+        return memoryCache;
+    }
+
+    protected abstract LruCache<String, CacheItem<T>> instantiateLRUCache();
+
+    protected static class CacheItem<T>
+    {
+        public final long created;
+        public final T    data;
+
+        public CacheItem( long created, T data )
+        {
+            this.created = created;
+            this.data = data;
+        }
+    }
+
+    @Override
+    public T loadDataFromCache( Object cacheKey,
+                                     long maxTimeInCacheBeforeExpiry ) throws
+                                                                       CacheLoadingException
+    {
+        String keyString = (String) cacheKey;
+        CacheItem<T> cacheItem = getMemoryCache().get( keyString );
+        String errorMsg = String.format( CACHE_MISS_NOT_FOUND, cacheKey );
+
+        if ( cacheItem != null )
+        {
+            long timeInCache = SystemClock.elapsedRealtime() - cacheItem.created;
+            if (timeInCache > maxTimeInCacheBeforeExpiry)
+            {
+                errorMsg = String.format( CACHE_MISS_EXPIRED, cacheKey );
+            }
+            else
+            {
+                return cacheItem.data;
+            }
+        }
+
+        throw new CacheLoadingException(errorMsg);
+    }
+
+    @Override
+    public List<T> loadAllDataFromCache() throws CacheLoadingException
+    {
+        Map<String, CacheItem<T>> cacheMap = getMemoryCache().snapshot();
+        ArrayList<T> allData = new ArrayList<T>();
+        for (CacheItem<T> item : cacheMap.values()) {
+            allData.add( item.data ) ;
+        }
+
+        return allData;
+    }
+
+    @Override
+    public List<Object> getAllCacheKeys()
+    {
+        return new ArrayList<Object>( getMemoryCache().snapshot().keySet() );
+    }
+
+    @Override
+    public T saveDataToCacheAndReturnData( T bitmap, Object cacheKey ) throws
+                                                                          CacheSavingException
+    {
+        CacheItem<T> itemToCache = new CacheItem<T>(SystemClock.elapsedRealtime(),
+                                                 bitmap);
+        getMemoryCache().put( (String) cacheKey, itemToCache );
+
+        return bitmap;
+    }
+
+    @Override
+    public boolean removeDataFromCache( Object o )
+    {
+        return (getMemoryCache().remove( (String) o ) != null);
+    }
+
+    @Override
+    public void removeAllDataFromCache()
+    {
+        getMemoryCache().evictAll();
+    }
+
+}
