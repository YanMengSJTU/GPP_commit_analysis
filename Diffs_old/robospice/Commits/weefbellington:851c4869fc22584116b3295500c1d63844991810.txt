diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
index 3bdb97f92..8981b5bd4 100644
--- a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
@@ -1,65 +1,79 @@
 package com.octo.android.robospice.persistence.binary;
 
-import android.app.ActivityManager;
-import android.app.Application;
-import android.content.Context;
-import android.graphics.Bitmap;
 import android.support.v4.util.LruCache;
+import android.graphics.Bitmap;
+import android.content.Context;
+import android.app.Application;
+import android.app.ActivityManager;
+
+/**
+ * Concrete implementation of {@link InMemoryLRUCacheObjectPersister} for bitmap
+ * objects.
+ *
+ * By default, it creates an LRU cache that can fill up to 1/4 of application
+ * memory. This value can be changed by passing a different cache size in the
+ * constructor method.
+ */
 
-public class InMemoryBitmapObjectPersister
-    extends InMemoryLRUCacheObjectPersister<Bitmap>
-{
+public class InMemoryBitmapObjectPersister extends
+    InMemoryLRUCacheObjectPersister<Bitmap> {
 
     private final int cacheSize;
 
-    public InMemoryBitmapObjectPersister (Application application)
-    {
+    /**
+     * Convenience constructor with the default cache size.
+     *
+     * @param application the Android application object
+     */
+
+    public InMemoryBitmapObjectPersister(Application application) {
         this(application, -1);
     }
 
-    public InMemoryBitmapObjectPersister( Application application,
-                                          int cacheSize )
-    {
-        super( application, Bitmap.class );
+    /**
+     * Default constructor method.
+     *
+     * @param application the Android application object
+     * @param cacheSize the requested cache size, in bytes. If the size is less
+     *                  than one, the cache size is limited to 1/4 of the
+     *                  application memory.
+     */
+    public InMemoryBitmapObjectPersister(Application application, int cacheSize) {
+        super(application, Bitmap.class);
 
         // base Android memory class is 16 MB per process
         // the cache should take up no more than 1/4 of the available app memory
-        if (cacheSize > 0)
-        {
+        if (cacheSize > 0) {
             this.cacheSize = cacheSize;
-        }
-        else
-        {
-            int memClass = ( (ActivityManager) application.getSystemService(
-                Context.ACTIVITY_SERVICE ) ).getMemoryClass();
+        } else {
+            int memClass = ((ActivityManager) application
+                .getSystemService( Context.ACTIVITY_SERVICE )).getMemoryClass();
             this.cacheSize = 1024 * 1024 * 4 * (memClass / 16);
         }
     }
 
+    /**
+     * Creates the LRUCache, calculating the size of the object based on the
+     * number of bytes in the bitmap.
+     *
+     * @return the instantiated cache
+     */
+
     @Override
-    protected LruCache<String, CacheItem<Bitmap>> instantiateLRUCache()
-    {
-        return new LruCache<String, CacheItem<Bitmap>>(cacheSize)
-        {
+    protected LruCache<Object, CacheItem<Bitmap>> instantiateLRUCache() {
+        return new LruCache<Object, CacheItem<Bitmap>>(cacheSize) {
 
             @Override
-            protected int sizeOf( String key,
-                                  CacheItem<Bitmap> value )
-            {
-                return value.data.getRowBytes() *
-                       value.data.getHeight();
+            protected int sizeOf(Object key, CacheItem<Bitmap> value) {
+                return value.data.getRowBytes() * value.data.getHeight();
             }
 
             @Override
-            protected void entryRemoved( boolean evicted,
-                                         String key,
-                                         CacheItem<Bitmap> oldValue,
-                                         CacheItem<Bitmap> newValue )
-            {
-                super.entryRemoved( evicted, key, oldValue, newValue );
+            protected void entryRemoved(boolean evicted, Object key,
+                CacheItem<Bitmap> oldValue, CacheItem<Bitmap> newValue) {
+                super.entryRemoved(evicted, key, oldValue, newValue);
             }
         };
     }
 
-
 }
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
index f17dd58da..9cfa0f885 100644
--- a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
@@ -12,67 +12,88 @@
 import java.util.Map;
 
 /**
- * Persister for in-memory cache of Bitmaps
- * used by RoboSpice to automagically cache / fetch images
- * Stores data as bitmaps
+ * @author David Stemmer
+ * @author Mike Jancola
+ *
+ * Abstract in-memory object persister, based on the Android LRUCache.
+ *
  */
 
-public abstract class InMemoryLRUCacheObjectPersister<T> extends ObjectPersister<T>
-{
-    private static final String CACHE_MISS_EXPIRED   =
-        "%s: found in cache but the data was stale.";
-    private static final String CACHE_MISS_NOT_FOUND =
-        "%s: not found in cache";
+public abstract class InMemoryLRUCacheObjectPersister<T> extends
+    ObjectPersister<T> {
+    private static final String CACHE_MISS_EXPIRED = "%s: found in cache but the data was stale.";
+    private static final String CACHE_MISS_NOT_FOUND = "%s: not found in cache";
 
-    private LruCache<String, CacheItem<T>> memoryCache;
+    private LruCache<Object, CacheItem<T>> memoryCache;
 
-    protected InMemoryLRUCacheObjectPersister( Application application,
-                                               Class<T> clazz )
-    {
-        super( application, clazz );
+    protected InMemoryLRUCacheObjectPersister(Application application,
+        Class<T> clazz) {
+        super(application, clazz);
     }
 
-    private LruCache<String, CacheItem<T>> getMemoryCache()
-    {
-        if ( memoryCache == null )
-        {
+    private LruCache<Object, CacheItem<T>> getMemoryCache() {
+        if (memoryCache == null) {
             memoryCache = instantiateLRUCache();
         }
         return memoryCache;
     }
 
-    protected abstract LruCache<String, CacheItem<T>> instantiateLRUCache();
+    /**
+     * Subclasses must implement this method to instantiate the LRU cache.
+     *
+     * @return the instantiated cache object
+     */
 
-    protected static class CacheItem<T>
-    {
+    protected abstract LruCache<Object, CacheItem<T>> instantiateLRUCache();
+
+    /**
+     * The CacheItem class represents a cached object, consisting of a piece of
+     * immutable data and a timestamp marking when the data was added to the
+     * cache.
+     *
+     * @param <T> the type of object that will be stored in the cache
+     */
+
+    protected static class CacheItem<T> {
         public final long created;
-        public final T    data;
+        public final T data;
 
-        public CacheItem( long created, T data )
-        {
+        public CacheItem(long created, T data) {
             this.created = created;
             this.data = data;
         }
     }
 
+    /**
+     *
+     * @param cacheKey the cacheKey of the data to load.
+     * @param maxTimeInCacheBeforeExpiry max time, in milliseconds, that the data should remain in the cache
+     * @return the cached data
+     * @throws CacheLoadingException when the cache data is null
+     */
+
     @Override
-    public T loadDataFromCache( Object cacheKey,
-                                     long maxTimeInCacheBeforeExpiry ) throws
-                                                                       CacheLoadingException
-    {
-        String keyString = (String) cacheKey;
-        CacheItem<T> cacheItem = getMemoryCache().get( keyString );
-        String errorMsg = String.format( CACHE_MISS_NOT_FOUND, cacheKey );
-
-        if ( cacheItem != null )
-        {
-            long timeInCache = SystemClock.elapsedRealtime() - cacheItem.created;
-            if (timeInCache > maxTimeInCacheBeforeExpiry)
-            {
-                errorMsg = String.format( CACHE_MISS_EXPIRED, cacheKey );
-            }
-            else
-            {
+    public T loadDataFromCache(Object cacheKey, long maxTimeInCacheBeforeExpiry)
+        throws CacheLoadingException {
+        String keyString = cacheKey.toString();
+        CacheItem<T> cacheItem = getMemoryCache().get(keyString);
+        String errorMsg = String.format(CACHE_MISS_NOT_FOUND, cacheKey);
+
+        /*
+        Since this is an in-memory cache and will be dumped when the
+        device reboots, the timestamp is retrieved via the
+        {@link android.os.SystemClock#elapsedRealtime()} method. This method
+        counts the time since boot and is safer than
+        {@link System#currentTimeMillis()} which can be dependant on user
+        configuration.
+        */
+
+        if (cacheItem != null) {
+            long timeInCache = SystemClock.elapsedRealtime()
+                - cacheItem.created;
+            if (timeInCache > maxTimeInCacheBeforeExpiry) {
+                errorMsg = String.format(CACHE_MISS_EXPIRED, cacheKey);
+            } else {
                 return cacheItem.data;
             }
         }
@@ -81,43 +102,38 @@ public T loadDataFromCache( Object cacheKey,
     }
 
     @Override
-    public List<T> loadAllDataFromCache() throws CacheLoadingException
-    {
-        Map<String, CacheItem<T>> cacheMap = getMemoryCache().snapshot();
+    public List<T> loadAllDataFromCache() throws CacheLoadingException {
+        Map<Object, CacheItem<T>> cacheMap = getMemoryCache().snapshot();
         ArrayList<T> allData = new ArrayList<T>();
         for (CacheItem<T> item : cacheMap.values()) {
-            allData.add( item.data ) ;
+            allData.add(item.data);
         }
 
         return allData;
     }
 
     @Override
-    public List<Object> getAllCacheKeys()
-    {
-        return new ArrayList<Object>( getMemoryCache().snapshot().keySet() );
+    public List<Object> getAllCacheKeys() {
+        return new ArrayList<Object>(getMemoryCache().snapshot().keySet());
     }
 
     @Override
-    public T saveDataToCacheAndReturnData( T bitmap, Object cacheKey ) throws
-                                                                          CacheSavingException
-    {
-        CacheItem<T> itemToCache = new CacheItem<T>(SystemClock.elapsedRealtime(),
-                                                 bitmap);
-        getMemoryCache().put( (String) cacheKey, itemToCache );
+    public T saveDataToCacheAndReturnData(T bitmap, Object cacheKey)
+        throws CacheSavingException {
+        CacheItem<T> itemToCache = new CacheItem<T>(
+            SystemClock.elapsedRealtime(), bitmap);
+        getMemoryCache().put( cacheKey, itemToCache);
 
         return bitmap;
     }
 
     @Override
-    public boolean removeDataFromCache( Object o )
-    {
-        return (getMemoryCache().remove( (String) o ) != null);
+    public boolean removeDataFromCache(Object o) {
+        return (getMemoryCache().remove(o) != null);
     }
 
     @Override
-    public void removeAllDataFromCache()
-    {
+    public void removeAllDataFromCache() {
         getMemoryCache().evictAll();
     }
 
