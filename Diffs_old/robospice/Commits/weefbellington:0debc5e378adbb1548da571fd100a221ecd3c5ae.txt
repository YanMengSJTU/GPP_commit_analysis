diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersisterTest.java
new file mode 100644
index 000000000..d383b6b47
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersisterTest.java
@@ -0,0 +1,77 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.test.InstrumentationTestCase;
+import com.octo.android.robospice.persistence.DurationInMillis;
+import com.octo.android.robospice.persistence.exception.CacheLoadingException;
+
+public class InFileBitmapObjectPersisterTest extends InstrumentationTestCase {
+
+    private static final int BITMAP_HEIGHT = 10;
+    private static final int BITMAP_WIDTH = 10;
+    private static final int BYTES_PER_PIXEL = 4;
+    private static final Bitmap testBitmap = Bitmap.createBitmap(BITMAP_WIDTH,
+        BITMAP_HEIGHT, Bitmap.Config.ARGB_8888);
+
+    private static final String CACHE_KEY_1 = "cacheKey1";
+
+    private static final int BITMAP_SIZE = BITMAP_HEIGHT * BITMAP_WIDTH
+        * BYTES_PER_PIXEL;
+
+    private static final long ONE_MILLISECOND = 1;
+    private static final String EXPIRED_DATA_MSG = "Cache loaded expired data instead of throwing a CacheLoadingException.";
+
+    private Application application;
+    private InFileBitmapObjectPersister testPersister;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        application = (Application) getInstrumentation().getTargetContext()
+            .getApplicationContext();
+
+        testPersister = new InFileBitmapObjectPersister(application);
+        testPersister.removeAllDataFromCache();
+    }
+
+    private void assertBitmapSizeEquals(Bitmap bitmap, int bytes) {
+        assertEquals(bitmap.getRowBytes() * bitmap.getHeight(), bytes);
+    }
+
+    public void testSaveDataToCache() throws Exception {
+        assertNotNull(testPersister.saveDataToCacheAndReturnData(testBitmap,
+            CACHE_KEY_1));
+        assertTrue(testPersister.getCacheFile(CACHE_KEY_1).exists());
+    }
+
+    public void testLoadDataFromCacheNoExpiration() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(testBitmap, CACHE_KEY_1);
+        Bitmap data = testPersister.loadDataFromCache(CACHE_KEY_1,
+            DurationInMillis.ALWAYS);
+        assertNotNull(data);
+        assertBitmapSizeEquals(data, BITMAP_SIZE);
+
+    }
+
+    public void testLoadDataFromCacheNotExpired() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(testBitmap, CACHE_KEY_1);
+        Bitmap data = testPersister.loadDataFromCache(CACHE_KEY_1,
+            Long.MAX_VALUE);
+        assertNotNull(data);
+        assertBitmapSizeEquals(data, BITMAP_SIZE);
+    }
+
+    public void testLoadDataFromCacheExpired() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(testBitmap, CACHE_KEY_1);
+        Thread.sleep(ONE_MILLISECOND);
+        try {
+            testPersister.loadDataFromCache(CACHE_KEY_1, ONE_MILLISECOND);
+            throw new Exception(EXPIRED_DATA_MSG);
+        } catch (CacheLoadingException e) {
+            // throwing this error is the expected behavior
+        }
+    }
+
+}
diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java
index 6cdf449c0..ce69932b4 100644
--- a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java
+++ b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersisterTest.java
@@ -1,8 +1,9 @@
 package com.octo.android.robospice.persistence.binary;
 
-import android.test.InstrumentationTestCase;
-import android.graphics.Bitmap;
 import android.app.Application;
+import android.graphics.Bitmap;
+import android.support.v4.util.LruCache;
+import android.test.InstrumentationTestCase;
 
 public class InMemoryBitmapObjectPersisterTest extends InstrumentationTestCase {
 
@@ -20,7 +21,21 @@
     // The cache is large enough to hold no more than 1 bitmap
     private static final int CACHE_SIZE = BITMAP_SIZE * 3 / 2;
 
-    private InMemoryBitmapObjectPersister testPersister;
+    private TestBitmapPersister testPersister;
+
+    private class TestBitmapPersister extends InMemoryBitmapObjectPersister {
+
+        private TestBitmapPersister( Application application, int cacheSize )
+        {
+            super( application, cacheSize );
+        }
+
+        // increase visibility
+        @Override
+        public LruCache<Object, CacheItem<Bitmap>> getMemoryCache() {
+            return super.getMemoryCache();
+        }
+    }
 
     @Override
     protected void setUp() throws Exception {
@@ -29,8 +44,8 @@ protected void setUp() throws Exception {
         Application application = (Application) getInstrumentation()
             .getTargetContext().getApplicationContext();
 
-        testPersister = new InMemoryBitmapObjectPersister(application,
-            CACHE_SIZE);
+        testPersister = new TestBitmapPersister(application, CACHE_SIZE);
+
     }
 
     public void testCacheSizeCalculation() throws Exception {
@@ -38,4 +53,5 @@ public void testCacheSizeCalculation() throws Exception {
         assertEquals(testPersister.getMemoryCache().size(), BITMAP_SIZE);
     }
 
+
 }
diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java
deleted file mode 100644
index 02375dea4..000000000
--- a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersisterTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.octo.android.robospice.persistence.binary;
-
-import android.test.InstrumentationTestCase;
-import android.support.v4.util.LruCache;
-import android.app.Application;
-
-import com.octo.android.robospice.persistence.DurationInMillis;
-import com.octo.android.robospice.persistence.exception.CacheLoadingException;
-
-public class InMemoryLRUCacheObjectPersisterTest extends
-    InstrumentationTestCase {
-
-    private static final int CACHE_SIZE = 2;
-    private static final String CACHE_KEY_1 = "cacheKey1";
-    private static final String CACHE_KEY_2 = "cacheKey2";
-    private static final String CACHE_KEY_3 = "cacheKey3";
-    private static final Object GENERIC_DATA = new Object();
-    private static final long ONE_MILLISECOND = 1;
-
-    private static final String EXPIRED_DATA_MSG = "Cache loaded expired data instead of throwing a CacheLoadingException.";
-    private static final String DID_NOT_PURGE_LRU_MSG = "Cache loaded old data that should have been purged by the LRUCache.";
-
-    private InMemoryLRUCacheObjectPersister<Object> testPersister;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        Application application = (Application) getInstrumentation()
-            .getTargetContext().getApplicationContext();
-
-        testPersister = new InMemoryLRUCacheObjectPersister<Object>(
-            application, Object.class) {
-
-            @Override
-            protected LruCache<Object, CacheItem<Object>> instantiateLRUCache() {
-                return new LruCache<Object, CacheItem<Object>>(CACHE_SIZE);
-            }
-        };
-    }
-
-    public void testSaveDataToCacheAndReturnData() throws Exception {
-
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
-        assertNotNull(testPersister.getMemoryCache().get(CACHE_KEY_1));
-    }
-
-    public void testLoadDataFromCacheNoExpiration() throws Exception {
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
-        Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
-            DurationInMillis.ALWAYS);
-        assertNotNull(data);
-    }
-
-    public void testLoadDataFromCacheNotExpired() throws Exception {
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
-        Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
-            Long.MAX_VALUE);
-        assertNotNull(data);
-    }
-
-    public void testLoadDataFromCacheExpired() throws Exception {
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
-        Thread.sleep(ONE_MILLISECOND);
-        try {
-            Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
-                ONE_MILLISECOND);
-            throw new Exception(EXPIRED_DATA_MSG);
-        } catch (CacheLoadingException e) {
-            // throwing this error is the expected behavior
-        }
-    }
-
-    public void testPurgeLeastRecentlyUsed() throws Exception {
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_2);
-        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_3);
-        try {
-            testPersister.loadDataFromCache(CACHE_KEY_1,
-                DurationInMillis.ALWAYS);
-            throw new Exception(DID_NOT_PURGE_LRU_MSG);
-        } catch (CacheLoadingException e) {
-            // throwing this error is the expected behavior
-        }
-    }
-
-}
diff --git a/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersisterTest.java b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersisterTest.java
new file mode 100644
index 000000000..d8549d8ac
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache-test/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersisterTest.java
@@ -0,0 +1,124 @@
+package com.octo.android.robospice.persistence.memory;
+
+import android.app.Application;
+import android.support.v4.util.LruCache;
+import android.test.InstrumentationTestCase;
+import com.octo.android.robospice.persistence.DurationInMillis;
+import com.octo.android.robospice.persistence.ObjectPersister;
+import com.octo.android.robospice.persistence.exception.CacheLoadingException;
+import com.octo.android.robospice.persistence.string.InFileStringObjectPersister;
+
+public class InMemoryLRUCacheObjectPersisterTest extends
+    InstrumentationTestCase {
+
+    private static final int    CACHE_SIZE      = 2;
+    private static final String CACHE_KEY_1     = "cacheKey1";
+    private static final String CACHE_KEY_2     = "cacheKey2";
+    private static final String CACHE_KEY_3     = "cacheKey3";
+    private static final String GENERIC_DATA    = "hello world!";
+    private static final long   ONE_MILLISECOND = 1;
+    private static final long   TEN_MILLISECONDS = ONE_MILLISECOND * 10;
+
+    private static final String EXPIRED_DATA_MSG      = "Cache loaded expired data instead of throwing a CacheLoadingException.";
+    private static final String DID_NOT_PURGE_LRU_MSG = "Cache loaded old data that should have been purged by the LRUCache.";
+
+    private TestLRUPersister testPersister;
+    private TestLRUPersister testPersisterWithFallback;
+
+    private class TestLRUPersister extends InMemoryLRUCacheObjectPersister<String>
+    {
+
+        private TestLRUPersister( Application application )
+        {
+            super( application, String.class );
+        }
+
+        private TestLRUPersister( Application application,
+                                  ObjectPersister<String> fallback )
+        {
+            super( application, String.class, fallback );
+        }
+
+        @Override
+        protected LruCache<Object, CacheItem<String>> instantiateLRUCache()
+        {
+            return new LruCache<Object, CacheItem<String>>(CACHE_SIZE);
+        }
+
+        // increase visibility
+        @Override
+        public LruCache<Object, CacheItem<String>> getMemoryCache()
+        {
+            return super.getMemoryCache();
+        }
+
+
+    }
+
+    public void setUp() {
+        Application application = (Application) getInstrumentation()
+            .getTargetContext().getApplicationContext();
+        testPersister = new TestLRUPersister( application );
+
+        InFileStringObjectPersister fallbackPersister = new InFileStringObjectPersister( application );
+
+        testPersisterWithFallback = new TestLRUPersister( application, fallbackPersister );
+    }
+
+    public void tearDown() {
+        testPersisterWithFallback.getFallbackPersister().removeAllDataFromCache();
+    }
+
+    public void testSaveDataToCacheAndReturnData() throws Exception {
+
+
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        assertNotNull(testPersister.getMemoryCache().get(CACHE_KEY_1));
+    }
+
+    public void testLoadDataFromCacheNoExpiration() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
+            DurationInMillis.ALWAYS);
+        assertNotNull(data);
+    }
+
+    public void testLoadDataFromCacheNotExpired() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
+            Long.MAX_VALUE);
+        assertNotNull(data);
+    }
+
+    public void testLoadDataFromCacheExpired() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        Thread.sleep(TEN_MILLISECONDS);
+        try {
+            Object data = testPersister.loadDataFromCache(CACHE_KEY_1,
+                                                          ONE_MILLISECOND);
+            throw new Exception(EXPIRED_DATA_MSG);
+        } catch (CacheLoadingException e) {
+            // throwing this error is the expected behavior
+        }
+    }
+
+    public void testPurgeLeastRecentlyUsed() throws Exception {
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_2);
+        testPersister.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_3);
+        try {
+            testPersister.loadDataFromCache(CACHE_KEY_1,
+                DurationInMillis.ALWAYS);
+            throw new Exception(DID_NOT_PURGE_LRU_MSG);
+        } catch (CacheLoadingException e) {
+            // throwing this error is the expected behavior
+        }
+    }
+
+    public void testFallback() throws Exception {
+        testPersisterWithFallback.saveDataToCacheAndReturnData(GENERIC_DATA, CACHE_KEY_1);
+        testPersisterWithFallback.getMemoryCache().evictAll();
+        assertNotNull( testPersisterWithFallback.loadDataFromCache( CACHE_KEY_1, DurationInMillis.ALWAYS) );
+    }
+
+}
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersister.java
new file mode 100644
index 000000000..534efed25
--- /dev/null
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InFileBitmapObjectPersister.java
@@ -0,0 +1,94 @@
+package com.octo.android.robospice.persistence.binary;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import com.octo.android.robospice.persistence.DurationInMillis;
+import com.octo.android.robospice.persistence.exception.CacheLoadingException;
+import com.octo.android.robospice.persistence.exception.CacheSavingException;
+import com.octo.android.robospice.persistence.file.InFileObjectPersister;
+
+import java.io.*;
+
+/**
+ * @author David Stemmer
+ */
+public class InFileBitmapObjectPersister extends InFileObjectPersister<Bitmap> {
+
+    private static final String ERROR_CACHE_MISS_EXPIRED = "Found file in cache but the data was stale: %s";
+    private static final String ERROR_CACHE_MISS_NOT_FOUND = "No cached file for path: %s";
+    private static final String ERROR_COULD_NOT_COMPRESS_BITMAP = "Could not compress bitmap for path: %s";
+    private static final String ERROR_COULD_NOT_DECODE_BITMAP = "Found the file but could not decode bitmap for path: %s";
+
+    public InFileBitmapObjectPersister(Application application) {
+        super(application, Bitmap.class);
+    }
+
+    @Override
+    public Bitmap loadDataFromCache(Object cacheKey, long maxTimeInCache)
+        throws CacheLoadingException {
+
+        File cachedFile = getCacheFile(cacheKey);
+
+        boolean dataIsMissing = !cachedFile.exists();
+        if (dataIsMissing) {
+            String errorMsg = String.format(ERROR_CACHE_MISS_NOT_FOUND,
+                cachedFile.getAbsolutePath());
+            throw new CacheLoadingException(errorMsg);
+        }
+
+        boolean dataDoesExpire = maxTimeInCache != DurationInMillis.ALWAYS;
+        boolean dataIsStale = System.currentTimeMillis() - cachedFile.lastModified() > maxTimeInCache;
+        if (dataDoesExpire && dataIsStale) {
+            String errorMsg = String.format(ERROR_CACHE_MISS_EXPIRED,
+                cachedFile.getAbsolutePath());
+            throw new CacheLoadingException(errorMsg);
+        }
+
+        Bitmap data = BitmapFactory.decodeFile(cachedFile.getAbsolutePath());
+
+        boolean bitmapNotLoaded = data == null;
+        if (bitmapNotLoaded) {
+            String errorMsg = String.format(ERROR_COULD_NOT_DECODE_BITMAP,
+                cachedFile.getAbsolutePath());
+            throw new CacheLoadingException(errorMsg);
+        }
+
+        return data;
+    }
+
+    @Override
+    public Bitmap saveDataToCacheAndReturnData(Bitmap data, Object cacheKey)
+        throws CacheSavingException {
+        try {
+            String errorMsg = null;
+            File cacheFile = getCacheFile(cacheKey);
+            BufferedOutputStream out = new BufferedOutputStream(
+                new FileOutputStream(cacheFile));
+
+            boolean didCompress = data.compress(Bitmap.CompressFormat.PNG, 100,
+                out);
+            if (!didCompress) {
+                /*
+                 * we don't throw the error immediately so the stream has an
+                 * opportunity to close
+                 */
+                errorMsg = String.format(ERROR_COULD_NOT_COMPRESS_BITMAP,
+                    getCacheFile(cacheKey).getAbsolutePath());
+            }
+
+            out.flush();
+            out.close();
+
+            if (errorMsg != null) {
+                throw new CacheSavingException(errorMsg);
+            }
+
+            return data;
+        } catch (FileNotFoundException e) {
+            throw new CacheSavingException(e);
+        } catch (IOException e) {
+            throw new CacheSavingException(e);
+        }
+    }
+}
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
index af2411295..3972b5c5a 100644
--- a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryBitmapObjectPersister.java
@@ -1,18 +1,20 @@
 package com.octo.android.robospice.persistence.binary;
 
-import android.support.v4.util.LruCache;
-import android.graphics.Bitmap;
-import android.content.Context;
-import android.app.Application;
 import android.app.ActivityManager;
+import android.app.Application;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.v4.util.LruCache;
+import com.octo.android.robospice.persistence.ObjectPersister;
+import com.octo.android.robospice.persistence.memory.InMemoryLRUCacheObjectPersister;
 
 /**
  * @author David Stemmer
  * @author Mike Jancola Concrete implementation of
- *         {@link InMemoryLRUCacheObjectPersister} for bitmap objects. By
- *         default, it creates an LRU cache that can fill up to 1/4 of
- *         application memory. This value can be changed by passing a different
- *         cache size in the constructor method.
+ *         {@link com.octo.android.robospice.persistence.memory.InMemoryLRUCacheObjectPersister}
+ *         for bitmap objects. By default, it creates an LRU cache that can fill
+ *         up to 1/4 of application memory. This value can be changed by passing
+ *         a different cache size in the constructor method.
  */
 
 public class InMemoryBitmapObjectPersister extends
@@ -24,7 +26,7 @@
     private static final int BASELINE_MEMCLASS = 16;
 
     /**
-     * Convenience constructor with the default cache size.
+     * Convenience constructor with the default cache size and no fallback persister.
      * @param application
      *            the Android application object
      */
@@ -33,6 +35,16 @@ public InMemoryBitmapObjectPersister(Application application) {
         this(application, -1);
     }
 
+    /**
+     * Convenience constructor with the default cache size.
+     * @param application
+     *            the Android application object
+     */
+
+    public InMemoryBitmapObjectPersister(Application application, int cacheSize) {
+        this (application, cacheSize, null);
+    }
+
     /**
      * Default constructor method.
      * @param application
@@ -43,8 +55,11 @@ public InMemoryBitmapObjectPersister(Application application) {
      *            memory.
      */
 
-    public InMemoryBitmapObjectPersister(Application application, int cacheSize) {
-        super(application, Bitmap.class);
+    public InMemoryBitmapObjectPersister (
+        Application application,
+        int cacheSize,
+        ObjectPersister<Bitmap> fallbackPersister) {
+        super(application, Bitmap.class, fallbackPersister);
 
         // base Android memory class is 16 MB per process
         // the cache should take up no more than 1/4 of the available app memory
diff --git a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersister.java
similarity index 71%
rename from robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
rename to robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersister.java
index bd5205e77..3466118fa 100644
--- a/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/binary/InMemoryLRUCacheObjectPersister.java
+++ b/robospice-cache-parent/robospice-cache/src/main/java/com/octo/android/robospice/persistence/memory/InMemoryLRUCacheObjectPersister.java
@@ -1,4 +1,4 @@
-package com.octo.android.robospice.persistence.binary;
+package com.octo.android.robospice.persistence.memory;
 
 import android.app.Application;
 import android.os.SystemClock;
@@ -24,10 +24,18 @@
     private static final String CACHE_MISS_NOT_FOUND = "%s: not found in cache";
 
     private LruCache<Object, CacheItem<T>> memoryCache;
+    private final ObjectPersister<T> fallbackPersister;
 
     protected InMemoryLRUCacheObjectPersister(Application application,
         Class<T> clazz) {
+        this(application, clazz, null);
+    }
+
+    protected InMemoryLRUCacheObjectPersister(Application application,
+        Class<T> clazz, ObjectPersister<T> fallback) {
         super(application, clazz);
+        this.fallbackPersister = fallback;
+
     }
 
     protected LruCache<Object, CacheItem<T>> getMemoryCache() {
@@ -37,6 +45,10 @@ protected InMemoryLRUCacheObjectPersister(Application application,
         return memoryCache;
     }
 
+    public ObjectPersister<T> getFallbackPersister() {
+        return fallbackPersister;
+    }
+
     /**
      * Subclasses must implement this method to instantiate the LRU cache.
      * @return the instantiated cache object
@@ -86,7 +98,8 @@ public T loadDataFromCache(Object cacheKey, long maxTimeInCacheBeforeExpiry)
         throws CacheLoadingException {
         String keyString = cacheKey.toString();
         CacheItem<T> cacheItem = getMemoryCache().get(keyString);
-        String errorMsg = String.format(CACHE_MISS_NOT_FOUND, cacheKey);
+
+        T dataToReturn =  null;
 
         /*
          * Since this is an in-memory cache and will be dumped when the device
@@ -98,17 +111,26 @@ public T loadDataFromCache(Object cacheKey, long maxTimeInCacheBeforeExpiry)
          */
 
         if (cacheItem != null) {
-            boolean doesExpire = maxTimeInCacheBeforeExpiry != DurationInMillis.ALWAYS;
-            long timeInCache = SystemClock.elapsedRealtime()
-                - cacheItem.created;
-            if (doesExpire && timeInCache > maxTimeInCacheBeforeExpiry) {
-                errorMsg = String.format(CACHE_MISS_EXPIRED, cacheKey);
+            boolean dataDoesExpire = maxTimeInCacheBeforeExpiry != DurationInMillis.ALWAYS;
+            boolean dataIsStale = SystemClock.elapsedRealtime() - cacheItem.created > maxTimeInCacheBeforeExpiry;
+            if (dataDoesExpire && dataIsStale) {
+                String errorMsg = String.format(CACHE_MISS_EXPIRED, cacheKey);
+                throw new CacheLoadingException( errorMsg );
             } else {
-                return cacheItem.data;
+                dataToReturn = cacheItem.data;
             }
+        } else if (fallbackPersister != null ){
+            dataToReturn = fallbackPersister.loadDataFromCache( cacheKey,
+                                                        maxTimeInCacheBeforeExpiry );
+        }
+
+        boolean dataIsMissing = dataToReturn == null;
+        if (dataIsMissing)  {
+            String errorMsg = String.format( CACHE_MISS_NOT_FOUND, cacheKey );
+            throw new CacheLoadingException(errorMsg);
         }
 
-        throw new CacheLoadingException(errorMsg);
+        return dataToReturn;
     }
 
     @Override
@@ -128,18 +150,23 @@ public T loadDataFromCache(Object cacheKey, long maxTimeInCacheBeforeExpiry)
     }
 
     @Override
-    public T saveDataToCacheAndReturnData(T bitmap, Object cacheKey)
+    public T saveDataToCacheAndReturnData(T data, Object cacheKey)
         throws CacheSavingException {
         CacheItem<T> itemToCache = new CacheItem<T>(
-            SystemClock.elapsedRealtime(), bitmap);
+            SystemClock.elapsedRealtime(), data);
         getMemoryCache().put(cacheKey, itemToCache);
 
-        return bitmap;
+        if (fallbackPersister != null) {
+            fallbackPersister.saveDataToCacheAndReturnData(data, cacheKey);
+        }
+
+        return data;
     }
 
     @Override
     public boolean removeDataFromCache(Object o) {
         return (getMemoryCache().remove(o) != null);
+
     }
 
     @Override
