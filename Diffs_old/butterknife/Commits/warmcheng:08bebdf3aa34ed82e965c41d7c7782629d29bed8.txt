diff --git a/butterknife-compiler/build.gradle b/butterknife-compiler/build.gradle
index 3553ef39..e6b51fa2 100644
--- a/butterknife-compiler/build.gradle
+++ b/butterknife-compiler/build.gradle
@@ -16,6 +16,10 @@ dependencies {
     testImplementation deps.truth
 }
 
+tasks.withType(JavaCompile) {
+    options.encoding = "UTF-8"
+}
+
 checkstyle {
     configFile rootProject.file('checkstyle.xml')
     showViolations true
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index a566f3cb..7595d745 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -475,6 +475,9 @@ private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationCl
 
     private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
                                Set<TypeElement> erasedTargetNames) {
+        // 得到注解 @BindView 元素所在的类元素(getEnclosingElement: 获取包裹该元素的元素的索引)
+        // 因为我们的 @BindView 值添加在字段上，因而传进来的 element 其实是 VariableElement 类型
+        // 我们通过 element.getEnclosingElement() 可以获得其外层element： TypeElement (类、接口、枚举、注解等)
         TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
         // Start by verifying common generated code restrictions.
@@ -482,14 +485,22 @@ private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder>
                 || isBindingInWrongPackage(BindView.class, element);
 
         // Verify that the target type extends from View.
+        // 返回该元素的类型(我们可以根据该元素的 TypeMirror 来进行更近一部的判断，或者获取更加详细的信息，
+        // 比如同样是 TypeElement，它可以代表类，也可以代表接口或者枚举、注解等)
         TypeMirror elementType = element.asType();
+        // 如果类型是变量，就强转程 TypeVariable，然后将 elementType 重新赋值为它的上一级边界，
+        // 也就是它继承的类及实现的各个接口
         if (elementType.getKind() == TypeKind.TYPEVAR) {
             TypeVariable typeVariable = (TypeVariable) elementType;
             elementType = typeVariable.getUpperBound();
         }
         Name qualifiedName = enclosingElement.getQualifiedName();
         Name simpleName = element.getSimpleName();
+        // 判断 elementType 是否是 View 的子类，或者是一个接口，如果是，就继续执行，否则就报警告或者报错
+        // ( 因为 @BindView 只能注解在 View 的子类或者接口上 )
         if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
+            // 如果是 TypeKind.ERROR ，表示：A class or interface type that could not be resolved.
+            // 也就是说 该类或者接口类型不能被解析或解析出错(其中有一些字段解析出错)
             if (elementType.getKind() == TypeKind.ERROR) {
                 note(element, "@%s field with unresolved type (%s) "
                                 + "must elsewhere be generated as a View or interface. (%s.%s)",
@@ -506,11 +517,14 @@ private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder>
         }
 
         // Assemble information on the field.
+        // 获取 @BindView 注解中输入的资源的 Id
         int id = element.getAnnotation(BindView.class).value();
 
+        // 将 TypeElement 传进去
         BindingSet.Builder builder = builderMap.get(enclosingElement);
         QualifiedId qualifiedId = elementToQualifiedId(element, id);
         if (builder != null) {
+            // 查看是否存在重复绑定的 ID
             String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
             if (existingBindingName != null) {
                 error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
@@ -1254,20 +1268,35 @@ private void parseListenerAnnotation(Class<? extends Annotation> annotationClass
         erasedTargetNames.add(enclosingElement);
     }
 
+    /**
+     * @param typeMirror
+     * @return typeMirror 所代表的实际类是否是一个接口
+     */
     private boolean isInterface(TypeMirror typeMirror) {
         return typeMirror instanceof DeclaredType
                 && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
     }
 
+    /**
+     * @param typeMirror
+     * @param otherType
+     * @return typeMirror 是否是 otherType 的子类
+     */
     static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
         if (isTypeEqual(typeMirror, otherType)) {
             return true;
         }
+        // TypeKind.DECLARED : A class or interface type.
+        // 如果根本就不是一个类或者接口类型，当然也就不符合@BindView 的要求，直接返回 FALSE
         if (typeMirror.getKind() != TypeKind.DECLARED) {
             return false;
         }
+        // DeclaredType 是 TypeMirror 的间接子类
         DeclaredType declaredType = (DeclaredType) typeMirror;
+        // 返回此类型的实际类型参数，传进来的 typeMirror 参数实际就包含了继承的类或者实现的各种接口 ，
+        // 返回该类型的真实类型参数
         List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        // 如果 typeArguments.size() > 0 ，说明是存在泛型，那么就需要拼接字符串，在后面加上<?,?>这种泛型表示
         if (typeArguments.size() > 0) {
             StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
             typeString.append('<');
diff --git a/butterknife-integration-test/build.gradle b/butterknife-integration-test/build.gradle
index f06fe678..c52d466d 100644
--- a/butterknife-integration-test/build.gradle
+++ b/butterknife-integration-test/build.gradle
@@ -8,6 +8,10 @@ android {
     targetCompatibility = JavaVersion.VERSION_1_7
   }
 
+  tasks.withType(JavaCompile) {
+    options.encoding = "UTF-8"
+  }
+
   defaultConfig {
     applicationId 'com.example.butterknife'
     minSdkVersion versions.minSdk
diff --git a/gradle.properties b/gradle.properties
index a4db5d39..c72a2a81 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -15,4 +15,5 @@ POM_LICENCE_DIST=repo
 POM_DEVELOPER_ID=jakewharton
 POM_DEVELOPER_NAME=Jake Wharton
 
-org.gradle.jvmargs=-Xmx1536M
+org.gradle.daemon=true
+org.gradle.jvmargs=-Xmx1536M -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
