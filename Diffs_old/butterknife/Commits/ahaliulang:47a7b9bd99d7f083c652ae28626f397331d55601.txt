diff --git a/butterknife-annotations/src/main/java/butterknife/BindView.java b/butterknife-annotations/src/main/java/butterknife/BindView.java
index 4770bf69..d07f1ae7 100644
--- a/butterknife-annotations/src/main/java/butterknife/BindView.java
+++ b/butterknife-annotations/src/main/java/butterknife/BindView.java
@@ -1,6 +1,7 @@
 package butterknife;
 
 import android.support.annotation.IdRes;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
@@ -14,8 +15,50 @@
  * {@literal @}BindView(R.id.title) TextView title;
  * </code></pre>
  */
-@Retention(CLASS) @Target(FIELD)
+@Retention(CLASS) //注解的保留时间，可选值 SOURCE(源码时)，CLASS(编译时)，RUNTIME(运行时),默认为 CLASS
+@Target(FIELD) //表示可以用来修饰哪些程序元素，如TYPE，METHOD，CONSTRUCTOR，FIELD，PARAMETER等，未标注则表示可修饰所有
 public @interface BindView {
-  /** View ID to which the field will be bound. */
-  @IdRes int value();
+    /**
+     * View ID to which the field will be bound.
+     */
+    @IdRes int value();
 }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
index c5c7bc46..be3f87ce 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
@@ -1,8 +1,5 @@
 package butterknife.compiler;
 
-import butterknife.OnTouch;
-import butterknife.internal.ListenerClass;
-import butterknife.internal.ListenerMethod;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
@@ -13,6 +10,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.WildcardTypeName;
+
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -22,10 +20,15 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
+import butterknife.OnTouch;
+import butterknife.internal.ListenerClass;
+import butterknife.internal.ListenerMethod;
+
 import static butterknife.compiler.ButterKnifeProcessor.ACTIVITY_TYPE;
 import static butterknife.compiler.ButterKnifeProcessor.DIALOG_TYPE;
 import static butterknife.compiler.ButterKnifeProcessor.VIEW_TYPE;
@@ -36,742 +39,762 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-/** A set of all the bindings requested by a single type. */
+/**
+ * A set of all the bindings requested by a single type.
+ */
 final class BindingSet {
-  static final ClassName UTILS = ClassName.get("butterknife.internal", "Utils");
-  private static final ClassName VIEW = ClassName.get("android.view", "View");
-  private static final ClassName CONTEXT = ClassName.get("android.content", "Context");
-  private static final ClassName RESOURCES = ClassName.get("android.content.res", "Resources");
-  private static final ClassName UI_THREAD =
-      ClassName.get("android.support.annotation", "UiThread");
-  private static final ClassName CALL_SUPER =
-      ClassName.get("android.support.annotation", "CallSuper");
-  private static final ClassName SUPPRESS_LINT =
-      ClassName.get("android.annotation", "SuppressLint");
-  private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");
-  static final ClassName BITMAP_FACTORY = ClassName.get("android.graphics", "BitmapFactory");
-  static final ClassName CONTEXT_COMPAT =
-      ClassName.get("android.support.v4.content", "ContextCompat");
-  static final ClassName ANIMATION_UTILS =
-          ClassName.get("android.view.animation", "AnimationUtils");
-
-  private final TypeName targetTypeName;
-  private final ClassName bindingClassName;
-  private final boolean isFinal;
-  private final boolean isView;
-  private final boolean isActivity;
-  private final boolean isDialog;
-  private final ImmutableList<ViewBinding> viewBindings;
-  private final ImmutableList<FieldCollectionViewBinding> collectionBindings;
-  private final ImmutableList<ResourceBinding> resourceBindings;
-  private final BindingSet parentBinding;
-
-  private BindingSet(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
-      boolean isView, boolean isActivity, boolean isDialog, ImmutableList<ViewBinding> viewBindings,
-      ImmutableList<FieldCollectionViewBinding> collectionBindings,
-      ImmutableList<ResourceBinding> resourceBindings, BindingSet parentBinding) {
-    this.isFinal = isFinal;
-    this.targetTypeName = targetTypeName;
-    this.bindingClassName = bindingClassName;
-    this.isView = isView;
-    this.isActivity = isActivity;
-    this.isDialog = isDialog;
-    this.viewBindings = viewBindings;
-    this.collectionBindings = collectionBindings;
-    this.resourceBindings = resourceBindings;
-    this.parentBinding = parentBinding;
-  }
-
-  JavaFile brewJava(int sdk, boolean debuggable) {
-    return JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable))
-        .addFileComment("Generated code from Butter Knife. Do not modify!")
-        .build();
-  }
-
-  private TypeSpec createType(int sdk, boolean debuggable) {
-    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
-        .addModifiers(PUBLIC);
-    if (isFinal) {
-      result.addModifiers(FINAL);
-    }
+    static final ClassName UTILS = ClassName.get("butterknife.internal", "Utils");
+    private static final ClassName VIEW = ClassName.get("android.view", "View");
+    private static final ClassName CONTEXT = ClassName.get("android.content", "Context");
+    private static final ClassName RESOURCES = ClassName.get("android.content.res", "Resources");
+    private static final ClassName UI_THREAD =
+            ClassName.get("android.support.annotation", "UiThread");
+    private static final ClassName CALL_SUPER =
+            ClassName.get("android.support.annotation", "CallSuper");
+    private static final ClassName SUPPRESS_LINT =
+            ClassName.get("android.annotation", "SuppressLint");
+    private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");
+    static final ClassName BITMAP_FACTORY = ClassName.get("android.graphics", "BitmapFactory");
+    static final ClassName CONTEXT_COMPAT =
+            ClassName.get("android.support.v4.content", "ContextCompat");
+    static final ClassName ANIMATION_UTILS =
+            ClassName.get("android.view.animation", "AnimationUtils");
 
-    if (parentBinding != null) {
-      result.superclass(parentBinding.bindingClassName);
-    } else {
-      result.addSuperinterface(UNBINDER);
-    }
+    private final TypeName targetTypeName;
+    private final ClassName bindingClassName;
+    private final boolean isFinal;
+    private final boolean isView;
+    private final boolean isActivity;
+    private final boolean isDialog;
+    private final ImmutableList<ViewBinding> viewBindings;
+    private final ImmutableList<FieldCollectionViewBinding> collectionBindings;
+    private final ImmutableList<ResourceBinding> resourceBindings;
+    private final BindingSet parentBinding;
+
+    private BindingSet(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+                       boolean isView, boolean isActivity, boolean isDialog, ImmutableList<ViewBinding> viewBindings,
+                       ImmutableList<FieldCollectionViewBinding> collectionBindings,
+                       ImmutableList<ResourceBinding> resourceBindings, BindingSet parentBinding) {
+        this.isFinal = isFinal;
+        this.targetTypeName = targetTypeName;
+        this.bindingClassName = bindingClassName;
+        this.isView = isView;
+        this.isActivity = isActivity;
+        this.isDialog = isDialog;
+        this.viewBindings = viewBindings;
+        this.collectionBindings = collectionBindings;
+        this.resourceBindings = resourceBindings;
+        this.parentBinding = parentBinding;
+    }
+
+    JavaFile brewJava(int sdk, boolean debuggable) {
+        return JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable))
+                .addFileComment("Generated code from Butter Knife. Do not modify!")
+                .build();
+    }
+
+    private TypeSpec createType(int sdk, boolean debuggable) {
+        TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
+                .addModifiers(PUBLIC);
+        if (isFinal) {
+            result.addModifiers(FINAL);
+        }
 
-    if (hasTargetField()) {
-      result.addField(targetTypeName, "target", PRIVATE);
-    }
+        if (parentBinding != null) {
+            result.superclass(parentBinding.bindingClassName);
+        } else {
+            result.addSuperinterface(UNBINDER);
+        }
 
-    if (isView) {
-      result.addMethod(createBindingConstructorForView());
-    } else if (isActivity) {
-      result.addMethod(createBindingConstructorForActivity());
-    } else if (isDialog) {
-      result.addMethod(createBindingConstructorForDialog());
-    }
-    if (!constructorNeedsView()) {
-      // Add a delegating constructor with a target type + view signature for reflective use.
-      result.addMethod(createBindingViewDelegateConstructor());
-    }
-    result.addMethod(createBindingConstructor(sdk, debuggable));
+        if (hasTargetField()) {
+            result.addField(targetTypeName, "target", PRIVATE);
+        }
 
-    if (hasViewBindings() || parentBinding == null) {
-      result.addMethod(createBindingUnbindMethod(result));
-    }
+        if (isView) {
+            result.addMethod(createBindingConstructorForView());
+        } else if (isActivity) {
+            result.addMethod(createBindingConstructorForActivity());
+        } else if (isDialog) {
+            result.addMethod(createBindingConstructorForDialog());
+        }
+        if (!constructorNeedsView()) {
+            // Add a delegating constructor with a target type + view signature for reflective use.
+            result.addMethod(createBindingViewDelegateConstructor());
+        }
+        result.addMethod(createBindingConstructor(sdk, debuggable));
 
-    return result.build();
-  }
-
-  private MethodSpec createBindingViewDelegateConstructor() {
-    return MethodSpec.constructorBuilder()
-        .addJavadoc("@deprecated Use {@link #$T($T, $T)} for direct creation.\n    "
-                + "Only present for runtime invocation through {@code ButterKnife.bind()}.\n",
-            bindingClassName, targetTypeName, CONTEXT)
-        .addAnnotation(Deprecated.class)
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target")
-        .addParameter(VIEW, "source")
-        .addStatement(("this(target, source.getContext())"))
-        .build();
-  }
-
-  private MethodSpec createBindingConstructorForView() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target)");
-    } else {
-      builder.addStatement("this(target, target.getContext())");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructorForActivity() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target.getWindow().getDecorView())");
-    } else {
-      builder.addStatement("this(target, target)");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructorForDialog() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target.getWindow().getDecorView())");
-    } else {
-      builder.addStatement("this(target, target.getContext())");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructor(int sdk, boolean debuggable) {
-    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC);
-
-    if (hasMethodBindings()) {
-      constructor.addParameter(targetTypeName, "target", FINAL);
-    } else {
-      constructor.addParameter(targetTypeName, "target");
-    }
+        if (hasViewBindings() || parentBinding == null) {
+            result.addMethod(createBindingUnbindMethod(result));
+        }
 
-    if (constructorNeedsView()) {
-      constructor.addParameter(VIEW, "source");
-    } else {
-      constructor.addParameter(CONTEXT, "context");
+        return result.build();
+    }
+
+    private MethodSpec createBindingViewDelegateConstructor() {
+        return MethodSpec.constructorBuilder()
+                .addJavadoc("@deprecated Use {@link #$T($T, $T)} for direct creation.\n    "
+                                + "Only present for runtime invocation through {@code ButterKnife.bind()}.\n",
+                        bindingClassName, targetTypeName, CONTEXT)
+                .addAnnotation(Deprecated.class)
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target")
+                .addParameter(VIEW, "source")
+                .addStatement(("this(target, source.getContext())"))
+                .build();
+    }
+
+    private MethodSpec createBindingConstructorForView() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target)");
+        } else {
+            builder.addStatement("this(target, target.getContext())");
+        }
+        return builder.build();
     }
 
-    if (hasUnqualifiedResourceBindings()) {
-      // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
-      constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-          .addMember("value", "$S", "ResourceType")
-          .build());
+    private MethodSpec createBindingConstructorForActivity() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target.getWindow().getDecorView())");
+        } else {
+            builder.addStatement("this(target, target)");
+        }
+        return builder.build();
     }
 
-    if (hasOnTouchMethodBindings()) {
-      constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
-          .addMember("value", "$S", "ClickableViewAccessibility")
-          .build());
+    private MethodSpec createBindingConstructorForDialog() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target.getWindow().getDecorView())");
+        } else {
+            builder.addStatement("this(target, target.getContext())");
+        }
+        return builder.build();
     }
 
-    if (parentBinding != null) {
-      if (parentBinding.constructorNeedsView()) {
-        constructor.addStatement("super(target, source)");
-      } else if (constructorNeedsView()) {
-        constructor.addStatement("super(target, source.getContext())");
-      } else {
-        constructor.addStatement("super(target, context)");
-      }
-      constructor.addCode("\n");
-    }
-    if (hasTargetField()) {
-      constructor.addStatement("this.target = target");
-      constructor.addCode("\n");
-    }
+    private MethodSpec createBindingConstructor(int sdk, boolean debuggable) {
+        MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC);
 
-    if (hasViewBindings()) {
-      if (hasViewLocal()) {
-        // Local variable in which all views will be temporarily stored.
-        constructor.addStatement("$T view", VIEW);
-      }
-      for (ViewBinding binding : viewBindings) {
-        addViewBinding(constructor, binding, debuggable);
-      }
-      for (FieldCollectionViewBinding binding : collectionBindings) {
-        constructor.addStatement("$L", binding.render(debuggable));
-      }
-
-      if (!resourceBindings.isEmpty()) {
-        constructor.addCode("\n");
-      }
-    }
+        if (hasMethodBindings()) {
+            constructor.addParameter(targetTypeName, "target", FINAL);
+        } else {
+            constructor.addParameter(targetTypeName, "target");
+        }
 
-    if (!resourceBindings.isEmpty()) {
-      if (constructorNeedsView()) {
-        constructor.addStatement("$T context = source.getContext()", CONTEXT);
-      }
-      if (hasResourceBindingsNeedingResource(sdk)) {
-        constructor.addStatement("$T res = context.getResources()", RESOURCES);
-      }
-      for (ResourceBinding binding : resourceBindings) {
-        constructor.addStatement("$L", binding.render(sdk));
-      }
-    }
+        if (constructorNeedsView()) {
+            constructor.addParameter(VIEW, "source");
+        } else {
+            constructor.addParameter(CONTEXT, "context");
+        }
 
-    return constructor.build();
-  }
+        if (hasUnqualifiedResourceBindings()) {
+            // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
+            constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "ResourceType")
+                    .build());
+        }
 
-  private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass) {
-    MethodSpec.Builder result = MethodSpec.methodBuilder("unbind")
-        .addAnnotation(Override.class)
-        .addModifiers(PUBLIC);
-    if (!isFinal && parentBinding == null) {
-      result.addAnnotation(CALL_SUPER);
-    }
+        if (hasOnTouchMethodBindings()) {
+            constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
+                    .addMember("value", "$S", "ClickableViewAccessibility")
+                    .build());
+        }
 
-    if (hasTargetField()) {
-      if (hasFieldBindings()) {
-        result.addStatement("$T target = this.target", targetTypeName);
-      }
-      result.addStatement("if (target == null) throw new $T($S)", IllegalStateException.class,
-          "Bindings already cleared.");
-      result.addStatement("$N = null", hasFieldBindings() ? "this.target" : "target");
-      result.addCode("\n");
-      for (ViewBinding binding : viewBindings) {
-        if (binding.getFieldBinding() != null) {
-          result.addStatement("target.$L = null", binding.getFieldBinding().getName());
-        }
-      }
-      for (FieldCollectionViewBinding binding : collectionBindings) {
-        result.addStatement("target.$L = null", binding.name);
-      }
-    }
+        if (parentBinding != null) {
+            if (parentBinding.constructorNeedsView()) {
+                constructor.addStatement("super(target, source)");
+            } else if (constructorNeedsView()) {
+                constructor.addStatement("super(target, source.getContext())");
+            } else {
+                constructor.addStatement("super(target, context)");
+            }
+            constructor.addCode("\n");
+        }
+        if (hasTargetField()) {
+            constructor.addStatement("this.target = target");
+            constructor.addCode("\n");
+        }
 
-    if (hasMethodBindings()) {
-      result.addCode("\n");
-      for (ViewBinding binding : viewBindings) {
-        addFieldAndUnbindStatement(bindingClass, result, binding);
-      }
-    }
+        if (hasViewBindings()) {
+            if (hasViewLocal()) {
+                // Local variable in which all views will be temporarily stored.
+                constructor.addStatement("$T view", VIEW);
+            }
+            for (ViewBinding binding : viewBindings) {
+                addViewBinding(constructor, binding, debuggable);
+            }
+            for (FieldCollectionViewBinding binding : collectionBindings) {
+                constructor.addStatement("$L", binding.render(debuggable));
+            }
 
-    if (parentBinding != null) {
-      result.addCode("\n");
-      result.addStatement("super.unbind()");
-    }
-    return result.build();
-  }
-
-  private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
-      ViewBinding bindings) {
-    // Only add fields to the binding if there are method bindings.
-    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
-        bindings.getMethodBindings();
-    if (classMethodBindings.isEmpty()) {
-      return;
-    }
+            if (!resourceBindings.isEmpty()) {
+                constructor.addCode("\n");
+            }
+        }
 
-    String fieldName = bindings.isBoundToRoot() ? "viewSource" : "view" + bindings.getId().value;
-    result.addField(VIEW, fieldName, PRIVATE);
+        if (!resourceBindings.isEmpty()) {
+            if (constructorNeedsView()) {
+                constructor.addStatement("$T context = source.getContext()", CONTEXT);
+            }
+            if (hasResourceBindingsNeedingResource(sdk)) {
+                constructor.addStatement("$T res = context.getResources()", RESOURCES);
+            }
+            for (ResourceBinding binding : resourceBindings) {
+                constructor.addStatement("$L", binding.render(sdk));
+            }
+        }
 
-    // We only need to emit the null check if there are zero required bindings.
-    boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
-    if (needsNullChecked) {
-      unbindMethod.beginControlFlow("if ($N != null)", fieldName);
+        return constructor.build();
     }
 
-    for (ListenerClass listenerClass : classMethodBindings.keySet()) {
-      // We need to keep a reference to the listener
-      // in case we need to unbind it via a remove method.
-      boolean requiresRemoval = !"".equals(listenerClass.remover());
-      String listenerField = "null";
-      if (requiresRemoval) {
-        TypeName listenerClassName = bestGuess(listenerClass.type());
-        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
-        result.addField(listenerClassName, listenerField, PRIVATE);
-      }
-
-      if (!VIEW_TYPE.equals(listenerClass.targetType())) {
-        unbindMethod.addStatement("(($T) $N).$N($N)", bestGuess(listenerClass.targetType()),
-            fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
-      } else {
-        unbindMethod.addStatement("$N.$N($N)", fieldName,
-            removerOrSetter(listenerClass, requiresRemoval), listenerField);
-      }
-
-      if (requiresRemoval) {
-        unbindMethod.addStatement("$N = null", listenerField);
-      }
-    }
+    private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass) {
+        MethodSpec.Builder result = MethodSpec.methodBuilder("unbind")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC);
+        if (!isFinal && parentBinding == null) {
+            result.addAnnotation(CALL_SUPER);
+        }
+
+        if (hasTargetField()) {
+            if (hasFieldBindings()) {
+                result.addStatement("$T target = this.target", targetTypeName);
+            }
+            result.addStatement("if (target == null) throw new $T($S)", IllegalStateException.class,
+                    "Bindings already cleared.");
+            result.addStatement("$N = null", hasFieldBindings() ? "this.target" : "target");
+            result.addCode("\n");
+            for (ViewBinding binding : viewBindings) {
+                if (binding.getFieldBinding() != null) {
+                    result.addStatement("target.$L = null", binding.getFieldBinding().getName());
+                }
+            }
+            for (FieldCollectionViewBinding binding : collectionBindings) {
+                result.addStatement("target.$L = null", binding.name);
+            }
+        }
 
-    unbindMethod.addStatement("$N = null", fieldName);
+        if (hasMethodBindings()) {
+            result.addCode("\n");
+            for (ViewBinding binding : viewBindings) {
+                addFieldAndUnbindStatement(bindingClass, result, binding);
+            }
+        }
 
-    if (needsNullChecked) {
-      unbindMethod.endControlFlow();
-    }
-  }
-
-  private String removerOrSetter(ListenerClass listenerClass, boolean requiresRemoval) {
-    return requiresRemoval
-        ? listenerClass.remover()
-        : listenerClass.setter();
-  }
-
-  private void addViewBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
-    if (binding.isSingleFieldBinding()) {
-      // Optimize the common case where there's a single binding directly to a field.
-      FieldViewBinding fieldBinding = binding.getFieldBinding();
-      CodeBlock.Builder builder = CodeBlock.builder()
-          .add("target.$L = ", fieldBinding.getName());
-
-      boolean requiresCast = requiresCast(fieldBinding.getType());
-      if (!debuggable || (!requiresCast && !fieldBinding.isRequired())) {
-        if (requiresCast) {
-          builder.add("($T) ", fieldBinding.getType());
-        }
-        builder.add("source.findViewById($L)", binding.getId().code);
-      } else {
-        builder.add("$T.find", UTILS);
-        builder.add(fieldBinding.isRequired() ? "RequiredView" : "OptionalView");
-        if (requiresCast) {
-          builder.add("AsType");
-        }
-        builder.add("(source, $L", binding.getId().code);
-        if (fieldBinding.isRequired() || requiresCast) {
-          builder.add(", $S", asHumanDescription(singletonList(fieldBinding)));
-        }
-        if (requiresCast) {
-          builder.add(", $T.class", fieldBinding.getRawType());
-        }
-        builder.add(")");
-      }
-      result.addStatement("$L", builder.build());
-      return;
+        if (parentBinding != null) {
+            result.addCode("\n");
+            result.addStatement("super.unbind()");
+        }
+        return result.build();
     }
 
-    List<MemberViewBinding> requiredBindings = binding.getRequiredBindings();
-    if (!debuggable || requiredBindings.isEmpty()) {
-      result.addStatement("view = source.findViewById($L)", binding.getId().code);
-    } else if (!binding.isBoundToRoot()) {
-      result.addStatement("view = $T.findRequiredView(source, $L, $S)", UTILS,
-          binding.getId().code, asHumanDescription(requiredBindings));
-    }
+    private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
+                                            ViewBinding bindings) {
+        // Only add fields to the binding if there are method bindings.
+        Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+                bindings.getMethodBindings();
+        if (classMethodBindings.isEmpty()) {
+            return;
+        }
 
-    addFieldBinding(result, binding, debuggable);
-    addMethodBindings(result, binding, debuggable);
-  }
-
-  private void addFieldBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
-    FieldViewBinding fieldBinding = binding.getFieldBinding();
-    if (fieldBinding != null) {
-      if (requiresCast(fieldBinding.getType())) {
-        if (debuggable) {
-          result.addStatement("target.$L = $T.castView(view, $L, $S, $T.class)",
-              fieldBinding.getName(), UTILS, binding.getId().code,
-              asHumanDescription(singletonList(fieldBinding)), fieldBinding.getRawType());
-        } else {
-          result.addStatement("target.$L = ($T) view", fieldBinding.getName(),
-              fieldBinding.getType());
+        String fieldName = bindings.isBoundToRoot() ? "viewSource" : "view" + bindings.getId().value;
+        result.addField(VIEW, fieldName, PRIVATE);
+
+        // We only need to emit the null check if there are zero required bindings.
+        boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
+        if (needsNullChecked) {
+            unbindMethod.beginControlFlow("if ($N != null)", fieldName);
+        }
+
+        for (ListenerClass listenerClass : classMethodBindings.keySet()) {
+            // We need to keep a reference to the listener
+            // in case we need to unbind it via a remove method.
+            boolean requiresRemoval = !"".equals(listenerClass.remover());
+            String listenerField = "null";
+            if (requiresRemoval) {
+                TypeName listenerClassName = bestGuess(listenerClass.type());
+                listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+                result.addField(listenerClassName, listenerField, PRIVATE);
+            }
+
+            if (!VIEW_TYPE.equals(listenerClass.targetType())) {
+                unbindMethod.addStatement("(($T) $N).$N($N)", bestGuess(listenerClass.targetType()),
+                        fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
+            } else {
+                unbindMethod.addStatement("$N.$N($N)", fieldName,
+                        removerOrSetter(listenerClass, requiresRemoval), listenerField);
+            }
+
+            if (requiresRemoval) {
+                unbindMethod.addStatement("$N = null", listenerField);
+            }
+        }
+
+        unbindMethod.addStatement("$N = null", fieldName);
+
+        if (needsNullChecked) {
+            unbindMethod.endControlFlow();
         }
-      } else {
-        result.addStatement("target.$L = view", fieldBinding.getName());
-      }
-    }
-  }
-
-  private void addMethodBindings(MethodSpec.Builder result, ViewBinding binding,
-      boolean debuggable) {
-    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
-        binding.getMethodBindings();
-    if (classMethodBindings.isEmpty()) {
-      return;
     }
 
-    // We only need to emit the null check if there are zero required bindings.
-    boolean needsNullChecked = binding.getRequiredBindings().isEmpty();
-    if (needsNullChecked) {
-      result.beginControlFlow("if (view != null)");
+    private String removerOrSetter(ListenerClass listenerClass, boolean requiresRemoval) {
+        return requiresRemoval
+                ? listenerClass.remover()
+                : listenerClass.setter();
     }
 
-    // Add the view reference to the binding.
-    String fieldName = "viewSource";
-    String bindName = "source";
-    if (!binding.isBoundToRoot()) {
-      fieldName = "view" + binding.getId().value;
-      bindName = "view";
+    private void addViewBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+        if (binding.isSingleFieldBinding()) {
+            // Optimize the common case where there's a single binding directly to a field.
+            FieldViewBinding fieldBinding = binding.getFieldBinding();
+            CodeBlock.Builder builder = CodeBlock.builder()
+                    .add("target.$L = ", fieldBinding.getName());
+
+            boolean requiresCast = requiresCast(fieldBinding.getType());
+            if (!debuggable || (!requiresCast && !fieldBinding.isRequired())) {
+                if (requiresCast) {
+                    builder.add("($T) ", fieldBinding.getType());
+                }
+                builder.add("source.findViewById($L)", binding.getId().code);
+            } else {
+                builder.add("$T.find", UTILS);
+                builder.add(fieldBinding.isRequired() ? "RequiredView" : "OptionalView");
+                if (requiresCast) {
+                    builder.add("AsType");
+                }
+                builder.add("(source, $L", binding.getId().code);
+                if (fieldBinding.isRequired() || requiresCast) {
+                    builder.add(", $S", asHumanDescription(singletonList(fieldBinding)));
+                }
+                if (requiresCast) {
+                    builder.add(", $T.class", fieldBinding.getRawType());
+                }
+                builder.add(")");
+            }
+            result.addStatement("$L", builder.build());
+            return;
+        }
+
+        List<MemberViewBinding> requiredBindings = binding.getRequiredBindings();
+        if (!debuggable || requiredBindings.isEmpty()) {
+            result.addStatement("view = source.findViewById($L)", binding.getId().code);
+        } else if (!binding.isBoundToRoot()) {
+            result.addStatement("view = $T.findRequiredView(source, $L, $S)", UTILS,
+                    binding.getId().code, asHumanDescription(requiredBindings));
+        }
+
+        addFieldBinding(result, binding, debuggable);
+        addMethodBindings(result, binding, debuggable);
     }
-    result.addStatement("$L = $N", fieldName, bindName);
-
-    for (Map.Entry<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> e
-        : classMethodBindings.entrySet()) {
-      ListenerClass listener = e.getKey();
-      Map<ListenerMethod, Set<MethodViewBinding>> methodBindings = e.getValue();
-
-      TypeSpec.Builder callback = TypeSpec.anonymousClassBuilder("")
-          .superclass(ClassName.bestGuess(listener.type()));
-
-      for (ListenerMethod method : getListenerMethods(listener)) {
-        MethodSpec.Builder callbackMethod = MethodSpec.methodBuilder(method.name())
-            .addAnnotation(Override.class)
-            .addModifiers(PUBLIC)
-            .returns(bestGuess(method.returnType()));
-        String[] parameterTypes = method.parameters();
-        for (int i = 0, count = parameterTypes.length; i < count; i++) {
-          callbackMethod.addParameter(bestGuess(parameterTypes[i]), "p" + i);
-        }
-
-        boolean hasReturnType = !"void".equals(method.returnType());
-        CodeBlock.Builder builder = CodeBlock.builder();
-        if (hasReturnType) {
-          builder.add("return ");
-        }
-
-        if (methodBindings.containsKey(method)) {
-          for (MethodViewBinding methodBinding : methodBindings.get(method)) {
-            builder.add("target.$L(", methodBinding.getName());
-            List<Parameter> parameters = methodBinding.getParameters();
-            String[] listenerParameters = method.parameters();
-            for (int i = 0, count = parameters.size(); i < count; i++) {
-              if (i > 0) {
-                builder.add(", ");
-              }
-
-              Parameter parameter = parameters.get(i);
-              int listenerPosition = parameter.getListenerPosition();
-
-              if (parameter.requiresCast(listenerParameters[listenerPosition])) {
+
+    private void addFieldBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+        FieldViewBinding fieldBinding = binding.getFieldBinding();
+        if (fieldBinding != null) {
+            if (requiresCast(fieldBinding.getType())) {
                 if (debuggable) {
-                  builder.add("$T.castParam(p$L, $S, $L, $S, $L, $T.class)", UTILS,
-                      listenerPosition, method.name(), listenerPosition, methodBinding.getName(), i,
-                      parameter.getType());
+                    result.addStatement("target.$L = $T.castView(view, $L, $S, $T.class)",
+                            fieldBinding.getName(), UTILS, binding.getId().code,
+                            asHumanDescription(singletonList(fieldBinding)), fieldBinding.getRawType());
                 } else {
-                  builder.add("($T) p$L", parameter.getType(), listenerPosition);
+                    result.addStatement("target.$L = ($T) view", fieldBinding.getName(),
+                            fieldBinding.getType());
                 }
-              } else {
-                builder.add("p$L", listenerPosition);
-              }
-            }
-            builder.add(");\n");
-          }
-        } else if (hasReturnType) {
-          builder.add("$L;\n", method.defaultReturn());
-        }
-        callbackMethod.addCode(builder.build());
-        callback.addMethod(callbackMethod.build());
-      }
-
-      boolean requiresRemoval = listener.remover().length() != 0;
-      String listenerField = null;
-      if (requiresRemoval) {
-        TypeName listenerClassName = bestGuess(listener.type());
-        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
-        result.addStatement("$L = $L", listenerField, callback.build());
-      }
-
-      if (!VIEW_TYPE.equals(listener.targetType())) {
-        result.addStatement("(($T) $N).$L($L)", bestGuess(listener.targetType()), bindName,
-            listener.setter(), requiresRemoval ? listenerField : callback.build());
-      } else {
-        result.addStatement("$N.$L($L)", bindName, listener.setter(),
-            requiresRemoval ? listenerField : callback.build());
-      }
+            } else {
+                result.addStatement("target.$L = view", fieldBinding.getName());
+            }
+        }
     }
 
-    if (needsNullChecked) {
-      result.endControlFlow();
-    }
-  }
+    private void addMethodBindings(MethodSpec.Builder result, ViewBinding binding,
+                                   boolean debuggable) {
+        Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+                binding.getMethodBindings();
+        if (classMethodBindings.isEmpty()) {
+            return;
+        }
 
-  private static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
-    if (listener.method().length == 1) {
-      return Arrays.asList(listener.method());
-    }
+        // We only need to emit the null check if there are zero required bindings.
+        boolean needsNullChecked = binding.getRequiredBindings().isEmpty();
+        if (needsNullChecked) {
+            result.beginControlFlow("if (view != null)");
+        }
 
-    try {
-      List<ListenerMethod> methods = new ArrayList<>();
-      Class<? extends Enum<?>> callbacks = listener.callbacks();
-      for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
-        Field callbackField = callbacks.getField(callbackMethod.name());
-        ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
-        if (method == null) {
-          throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
-              callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
-              callbackMethod.name(), ListenerMethod.class.getSimpleName()));
-        }
-        methods.add(method);
-      }
-      return methods;
-    } catch (NoSuchFieldException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  static String asHumanDescription(Collection<? extends MemberViewBinding> bindings) {
-    Iterator<? extends MemberViewBinding> iterator = bindings.iterator();
-    switch (bindings.size()) {
-      case 1:
-        return iterator.next().getDescription();
-      case 2:
-        return iterator.next().getDescription() + " and " + iterator.next().getDescription();
-      default:
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0, count = bindings.size(); i < count; i++) {
-          if (i != 0) {
-            builder.append(", ");
-          }
-          if (i == count - 1) {
-            builder.append("and ");
-          }
-          builder.append(iterator.next().getDescription());
-        }
-        return builder.toString();
-    }
-  }
-
-  private static TypeName bestGuess(String type) {
-    switch (type) {
-      case "void": return TypeName.VOID;
-      case "boolean": return TypeName.BOOLEAN;
-      case "byte": return TypeName.BYTE;
-      case "char": return TypeName.CHAR;
-      case "double": return TypeName.DOUBLE;
-      case "float": return TypeName.FLOAT;
-      case "int": return TypeName.INT;
-      case "long": return TypeName.LONG;
-      case "short": return TypeName.SHORT;
-      default:
-        int left = type.indexOf('<');
-        if (left != -1) {
-          ClassName typeClassName = ClassName.bestGuess(type.substring(0, left));
-          List<TypeName> typeArguments = new ArrayList<>();
-          do {
-            typeArguments.add(WildcardTypeName.subtypeOf(Object.class));
-            left = type.indexOf('<', left + 1);
-          } while (left != -1);
-          return ParameterizedTypeName.get(typeClassName,
-              typeArguments.toArray(new TypeName[typeArguments.size()]));
-        }
-        return ClassName.bestGuess(type);
-    }
-  }
-
-  /** True when this type's bindings require a view hierarchy. */
-  private boolean hasViewBindings() {
-    return !viewBindings.isEmpty() || !collectionBindings.isEmpty();
-  }
-
-  /** True when this type's bindings use raw integer values instead of {@code R} references. */
-  private boolean hasUnqualifiedResourceBindings() {
-    for (ResourceBinding binding : resourceBindings) {
-      if (!binding.id().qualifed) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** True when this type's bindings use Resource directly instead of Context. */
-  private boolean hasResourceBindingsNeedingResource(int sdk) {
-    for (ResourceBinding binding : resourceBindings) {
-      if (binding.requiresResources(sdk)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasMethodBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (!bindings.getMethodBindings().isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasOnTouchMethodBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.getMethodBindings()
-          .containsKey(OnTouch.class.getAnnotation(ListenerClass.class))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasFieldBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.getFieldBinding() != null) {
-        return true;
-      }
-    }
-    return !collectionBindings.isEmpty();
-  }
-
-  private boolean hasTargetField() {
-    return hasFieldBindings() || hasMethodBindings();
-  }
-
-  private boolean hasViewLocal() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.requiresLocal()) {
-        return true;
-      }
-    }
-    return false;
-  }
+        // Add the view reference to the binding.
+        String fieldName = "viewSource";
+        String bindName = "source";
+        if (!binding.isBoundToRoot()) {
+            fieldName = "view" + binding.getId().value;
+            bindName = "view";
+        }
+        result.addStatement("$L = $N", fieldName, bindName);
+
+        for (Map.Entry<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> e
+                : classMethodBindings.entrySet()) {
+            ListenerClass listener = e.getKey();
+            Map<ListenerMethod, Set<MethodViewBinding>> methodBindings = e.getValue();
+
+            TypeSpec.Builder callback = TypeSpec.anonymousClassBuilder("")
+                    .superclass(ClassName.bestGuess(listener.type()));
+
+            for (ListenerMethod method : getListenerMethods(listener)) {
+                MethodSpec.Builder callbackMethod = MethodSpec.methodBuilder(method.name())
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bestGuess(method.returnType()));
+                String[] parameterTypes = method.parameters();
+                for (int i = 0, count = parameterTypes.length; i < count; i++) {
+                    callbackMethod.addParameter(bestGuess(parameterTypes[i]), "p" + i);
+                }
 
-  /** True if this binding requires a view. Otherwise only a context is needed. */
-  private boolean constructorNeedsView() {
-    return hasViewBindings() //
-        || parentBinding != null && parentBinding.constructorNeedsView();
-  }
+                boolean hasReturnType = !"void".equals(method.returnType());
+                CodeBlock.Builder builder = CodeBlock.builder();
+                if (hasReturnType) {
+                    builder.add("return ");
+                }
+
+                if (methodBindings.containsKey(method)) {
+                    for (MethodViewBinding methodBinding : methodBindings.get(method)) {
+                        builder.add("target.$L(", methodBinding.getName());
+                        List<Parameter> parameters = methodBinding.getParameters();
+                        String[] listenerParameters = method.parameters();
+                        for (int i = 0, count = parameters.size(); i < count; i++) {
+                            if (i > 0) {
+                                builder.add(", ");
+                            }
+
+                            Parameter parameter = parameters.get(i);
+                            int listenerPosition = parameter.getListenerPosition();
+
+                            if (parameter.requiresCast(listenerParameters[listenerPosition])) {
+                                if (debuggable) {
+                                    builder.add("$T.castParam(p$L, $S, $L, $S, $L, $T.class)", UTILS,
+                                            listenerPosition, method.name(), listenerPosition, methodBinding.getName(), i,
+                                            parameter.getType());
+                                } else {
+                                    builder.add("($T) p$L", parameter.getType(), listenerPosition);
+                                }
+                            } else {
+                                builder.add("p$L", listenerPosition);
+                            }
+                        }
+                        builder.add(");\n");
+                    }
+                } else if (hasReturnType) {
+                    builder.add("$L;\n", method.defaultReturn());
+                }
+                callbackMethod.addCode(builder.build());
+                callback.addMethod(callbackMethod.build());
+            }
 
-  static boolean requiresCast(TypeName type) {
-    return !VIEW_TYPE.equals(type.toString());
-  }
+            boolean requiresRemoval = listener.remover().length() != 0;
+            String listenerField = null;
+            if (requiresRemoval) {
+                TypeName listenerClassName = bestGuess(listener.type());
+                listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+                result.addStatement("$L = $L", listenerField, callback.build());
+            }
 
-  @Override public String toString() {
-    return bindingClassName.toString();
-  }
+            if (!VIEW_TYPE.equals(listener.targetType())) {
+                result.addStatement("(($T) $N).$L($L)", bestGuess(listener.targetType()), bindName,
+                        listener.setter(), requiresRemoval ? listenerField : callback.build());
+            } else {
+                result.addStatement("$N.$L($L)", bindName, listener.setter(),
+                        requiresRemoval ? listenerField : callback.build());
+            }
+        }
 
-  static Builder newBuilder(TypeElement enclosingElement) {
-    TypeMirror typeMirror = enclosingElement.asType();
+        if (needsNullChecked) {
+            result.endControlFlow();
+        }
+    }
 
-    boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);
-    boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);
-    boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);
+    private static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
+        if (listener.method().length == 1) {
+            return Arrays.asList(listener.method());
+        }
 
-    TypeName targetType = TypeName.get(typeMirror);
-    if (targetType instanceof ParameterizedTypeName) {
-      targetType = ((ParameterizedTypeName) targetType).rawType;
+        try {
+            List<ListenerMethod> methods = new ArrayList<>();
+            Class<? extends Enum<?>> callbacks = listener.callbacks();
+            for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
+                Field callbackField = callbacks.getField(callbackMethod.name());
+                ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
+                if (method == null) {
+                    throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
+                            callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
+                            callbackMethod.name(), ListenerMethod.class.getSimpleName()));
+                }
+                methods.add(method);
+            }
+            return methods;
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError(e);
+        }
     }
 
-    String packageName = getPackage(enclosingElement).getQualifiedName().toString();
-    String className = enclosingElement.getQualifiedName().toString().substring(
-        packageName.length() + 1).replace('.', '$');
-    ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding");
+    static String asHumanDescription(Collection<? extends MemberViewBinding> bindings) {
+        Iterator<? extends MemberViewBinding> iterator = bindings.iterator();
+        switch (bindings.size()) {
+            case 1:
+                return iterator.next().getDescription();
+            case 2:
+                return iterator.next().getDescription() + " and " + iterator.next().getDescription();
+            default:
+                StringBuilder builder = new StringBuilder();
+                for (int i = 0, count = bindings.size(); i < count; i++) {
+                    if (i != 0) {
+                        builder.append(", ");
+                    }
+                    if (i == count - 1) {
+                        builder.append("and ");
+                    }
+                    builder.append(iterator.next().getDescription());
+                }
+                return builder.toString();
+        }
+    }
 
-    boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);
-    return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);
-  }
+    private static TypeName bestGuess(String type) {
+        switch (type) {
+            case "void":
+                return TypeName.VOID;
+            case "boolean":
+                return TypeName.BOOLEAN;
+            case "byte":
+                return TypeName.BYTE;
+            case "char":
+                return TypeName.CHAR;
+            case "double":
+                return TypeName.DOUBLE;
+            case "float":
+                return TypeName.FLOAT;
+            case "int":
+                return TypeName.INT;
+            case "long":
+                return TypeName.LONG;
+            case "short":
+                return TypeName.SHORT;
+            default:
+                int left = type.indexOf('<');
+                if (left != -1) {
+                    ClassName typeClassName = ClassName.bestGuess(type.substring(0, left));
+                    List<TypeName> typeArguments = new ArrayList<>();
+                    do {
+                        typeArguments.add(WildcardTypeName.subtypeOf(Object.class));
+                        left = type.indexOf('<', left + 1);
+                    } while (left != -1);
+                    return ParameterizedTypeName.get(typeClassName,
+                            typeArguments.toArray(new TypeName[typeArguments.size()]));
+                }
+                return ClassName.bestGuess(type);
+        }
+    }
 
-  static final class Builder {
-    private final TypeName targetTypeName;
-    private final ClassName bindingClassName;
-    private final boolean isFinal;
-    private final boolean isView;
-    private final boolean isActivity;
-    private final boolean isDialog;
+    /**
+     * True when this type's bindings require a view hierarchy.
+     */
+    private boolean hasViewBindings() {
+        return !viewBindings.isEmpty() || !collectionBindings.isEmpty();
+    }
 
-    private BindingSet parentBinding;
-
-    private final Map<Id, ViewBinding.Builder> viewIdMap = new LinkedHashMap<>();
-    private final ImmutableList.Builder<FieldCollectionViewBinding> collectionBindings =
-        ImmutableList.builder();
-    private final ImmutableList.Builder<ResourceBinding> resourceBindings = ImmutableList.builder();
-
-    private Builder(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
-        boolean isView, boolean isActivity, boolean isDialog) {
-      this.targetTypeName = targetTypeName;
-      this.bindingClassName = bindingClassName;
-      this.isFinal = isFinal;
-      this.isView = isView;
-      this.isActivity = isActivity;
-      this.isDialog = isDialog;
+    /**
+     * True when this type's bindings use raw integer values instead of {@code R} references.
+     */
+    private boolean hasUnqualifiedResourceBindings() {
+        for (ResourceBinding binding : resourceBindings) {
+            if (!binding.id().qualifed) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    void addField(Id id, FieldViewBinding binding) {
-      getOrCreateViewBindings(id).setFieldBinding(binding);
+    /**
+     * True when this type's bindings use Resource directly instead of Context.
+     */
+    private boolean hasResourceBindingsNeedingResource(int sdk) {
+        for (ResourceBinding binding : resourceBindings) {
+            if (binding.requiresResources(sdk)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    void addFieldCollection(FieldCollectionViewBinding binding) {
-      collectionBindings.add(binding);
+    private boolean hasMethodBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (!bindings.getMethodBindings().isEmpty()) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    boolean addMethod(
-        Id id,
-        ListenerClass listener,
-        ListenerMethod method,
-        MethodViewBinding binding) {
-      ViewBinding.Builder viewBinding = getOrCreateViewBindings(id);
-      if (viewBinding.hasMethodBinding(listener, method) && !"void".equals(method.returnType())) {
+    private boolean hasOnTouchMethodBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.getMethodBindings()
+                    .containsKey(OnTouch.class.getAnnotation(ListenerClass.class))) {
+                return true;
+            }
+        }
         return false;
-      }
-      viewBinding.addMethodBinding(listener, method, binding);
-      return true;
     }
 
-    void addResource(ResourceBinding binding) {
-      resourceBindings.add(binding);
+    private boolean hasFieldBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.getFieldBinding() != null) {
+                return true;
+            }
+        }
+        return !collectionBindings.isEmpty();
+    }
+
+    private boolean hasTargetField() {
+        return hasFieldBindings() || hasMethodBindings();
+    }
+
+    private boolean hasViewLocal() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.requiresLocal()) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    void setParent(BindingSet parent) {
-      this.parentBinding = parent;
+    /**
+     * True if this binding requires a view. Otherwise only a context is needed.
+     */
+    private boolean constructorNeedsView() {
+        return hasViewBindings() //
+                || parentBinding != null && parentBinding.constructorNeedsView();
     }
 
-    String findExistingBindingName(Id id) {
-      ViewBinding.Builder builder = viewIdMap.get(id);
-      if (builder == null) {
-        return null;
-      }
-      FieldViewBinding fieldBinding = builder.fieldBinding;
-      if (fieldBinding == null) {
-        return null;
-      }
-      return fieldBinding.getName();
+    static boolean requiresCast(TypeName type) {
+        return !VIEW_TYPE.equals(type.toString());
     }
 
-    private ViewBinding.Builder getOrCreateViewBindings(Id id) {
-      ViewBinding.Builder viewId = viewIdMap.get(id);
-      if (viewId == null) {
-        viewId = new ViewBinding.Builder(id);
-        viewIdMap.put(id, viewId);
-      }
-      return viewId;
+    @Override
+    public String toString() {
+        return bindingClassName.toString();
     }
 
-    BindingSet build() {
-      ImmutableList.Builder<ViewBinding> viewBindings = ImmutableList.builder();
-      for (ViewBinding.Builder builder : viewIdMap.values()) {
-        viewBindings.add(builder.build());
-      }
-      return new BindingSet(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,
-          viewBindings.build(), collectionBindings.build(), resourceBindings.build(),
-          parentBinding);
+    static Builder newBuilder(TypeElement enclosingElement) {
+        TypeMirror typeMirror = enclosingElement.asType();
+
+        boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);
+        boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);
+        boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);
+
+        TypeName targetType = TypeName.get(typeMirror);
+        if (targetType instanceof ParameterizedTypeName) {
+            targetType = ((ParameterizedTypeName) targetType).rawType;
+        }
+
+        String packageName = getPackage(enclosingElement).getQualifiedName().toString();
+        String className = enclosingElement.getQualifiedName().toString().substring(
+                packageName.length() + 1).replace('.', '$');
+        ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding");
+
+        boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);
+        return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);
+    }
+
+    static final class Builder {
+        private final TypeName targetTypeName;
+        private final ClassName bindingClassName;
+        private final boolean isFinal;
+        private final boolean isView;
+        private final boolean isActivity;
+        private final boolean isDialog;
+
+        private BindingSet parentBinding;
+
+        private final Map<Id, ViewBinding.Builder> viewIdMap = new LinkedHashMap<>();
+        private final ImmutableList.Builder<FieldCollectionViewBinding> collectionBindings =
+                ImmutableList.builder();
+        private final ImmutableList.Builder<ResourceBinding> resourceBindings = ImmutableList.builder();
+
+        private Builder(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+                        boolean isView, boolean isActivity, boolean isDialog) {
+            this.targetTypeName = targetTypeName;
+            this.bindingClassName = bindingClassName;
+            this.isFinal = isFinal;
+            this.isView = isView;
+            this.isActivity = isActivity;
+            this.isDialog = isDialog;
+        }
+
+        void addField(Id id, FieldViewBinding binding) {
+            getOrCreateViewBindings(id).setFieldBinding(binding);
+        }
+
+        void addFieldCollection(FieldCollectionViewBinding binding) {
+            collectionBindings.add(binding);
+        }
+
+        boolean addMethod(
+                Id id,
+                ListenerClass listener,
+                ListenerMethod method,
+                MethodViewBinding binding) {
+            ViewBinding.Builder viewBinding = getOrCreateViewBindings(id);
+            if (viewBinding.hasMethodBinding(listener, method) && !"void".equals(method.returnType())) {
+                return false;
+            }
+            viewBinding.addMethodBinding(listener, method, binding);
+            return true;
+        }
+
+        void addResource(ResourceBinding binding) {
+            resourceBindings.add(binding);
+        }
+
+        void setParent(BindingSet parent) {
+            this.parentBinding = parent;
+        }
+
+        String findExistingBindingName(Id id) {
+            ViewBinding.Builder builder = viewIdMap.get(id);
+            if (builder == null) {
+                return null;
+            }
+            FieldViewBinding fieldBinding = builder.fieldBinding;
+            if (fieldBinding == null) {
+                return null;
+            }
+            return fieldBinding.getName();
+        }
+
+        private ViewBinding.Builder getOrCreateViewBindings(Id id) {
+            ViewBinding.Builder viewId = viewIdMap.get(id);
+            if (viewId == null) {
+                viewId = new ViewBinding.Builder(id);
+                viewIdMap.put(id, viewId);
+            }
+            return viewId;
+        }
+
+        BindingSet build() {
+            ImmutableList.Builder<ViewBinding> viewBindings = ImmutableList.builder();
+            for (ViewBinding.Builder builder : viewIdMap.values()) {
+                viewBindings.add(builder.build());
+            }
+            return new BindingSet(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,
+                    viewBindings.build(), collectionBindings.build(), resourceBindings.build(),
+                    parentBinding);
+        }
     }
-  }
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index 8faac8b1..6eb5131a 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -1,33 +1,5 @@
 package butterknife.compiler;
 
-import butterknife.BindAnim;
-import butterknife.BindArray;
-import butterknife.BindBitmap;
-import butterknife.BindBool;
-import butterknife.BindColor;
-import butterknife.BindDimen;
-import butterknife.BindDrawable;
-import butterknife.BindFloat;
-import butterknife.BindFont;
-import butterknife.BindInt;
-import butterknife.BindString;
-import butterknife.BindView;
-import butterknife.BindViews;
-import butterknife.OnCheckedChanged;
-import butterknife.OnClick;
-import butterknife.OnEditorAction;
-import butterknife.OnFocusChange;
-import butterknife.OnItemClick;
-import butterknife.OnItemLongClick;
-import butterknife.OnItemSelected;
-import butterknife.OnLongClick;
-import butterknife.OnPageChange;
-import butterknife.OnTextChanged;
-import butterknife.OnTouch;
-import butterknife.Optional;
-import butterknife.compiler.FieldTypefaceBinding.TypefaceStyles;
-import butterknife.internal.ListenerClass;
-import butterknife.internal.ListenerMethod;
 import com.google.auto.common.SuperficialValidation;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableSet;
@@ -39,6 +11,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.TreeScanner;
+
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -50,12 +23,13 @@
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Deque;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -80,6 +54,35 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
+import butterknife.BindAnim;
+import butterknife.BindArray;
+import butterknife.BindBitmap;
+import butterknife.BindBool;
+import butterknife.BindColor;
+import butterknife.BindDimen;
+import butterknife.BindDrawable;
+import butterknife.BindFloat;
+import butterknife.BindFont;
+import butterknife.BindInt;
+import butterknife.BindString;
+import butterknife.BindView;
+import butterknife.BindViews;
+import butterknife.OnCheckedChanged;
+import butterknife.OnClick;
+import butterknife.OnEditorAction;
+import butterknife.OnFocusChange;
+import butterknife.OnItemClick;
+import butterknife.OnItemLongClick;
+import butterknife.OnItemSelected;
+import butterknife.OnLongClick;
+import butterknife.OnPageChange;
+import butterknife.OnTextChanged;
+import butterknife.OnTouch;
+import butterknife.Optional;
+import butterknife.compiler.FieldTypefaceBinding.TypefaceStyles;
+import butterknife.internal.ListenerClass;
+import butterknife.internal.ListenerMethod;
+
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -88,1437 +91,1472 @@
 
 @AutoService(Processor.class)
 public final class ButterKnifeProcessor extends AbstractProcessor {
-  // TODO remove when http://b.android.com/187527 is released.
-  private static final String OPTION_SDK_INT = "butterknife.minSdk";
-  private static final String OPTION_DEBUGGABLE = "butterknife.debuggable";
-  static final Id NO_ID = new Id(-1);
-  static final String VIEW_TYPE = "android.view.View";
-  static final String ACTIVITY_TYPE = "android.app.Activity";
-  static final String DIALOG_TYPE = "android.app.Dialog";
-  private static final String COLOR_STATE_LIST_TYPE = "android.content.res.ColorStateList";
-  private static final String BITMAP_TYPE = "android.graphics.Bitmap";
-  private static final String ANIMATION_TYPE = "android.view.animation.Animation";
-  private static final String DRAWABLE_TYPE = "android.graphics.drawable.Drawable";
-  private static final String TYPED_ARRAY_TYPE = "android.content.res.TypedArray";
-  private static final String TYPEFACE_TYPE = "android.graphics.Typeface";
-  private static final String NULLABLE_ANNOTATION_NAME = "Nullable";
-  private static final String STRING_TYPE = "java.lang.String";
-  private static final String LIST_TYPE = List.class.getCanonicalName();
-  private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
-      OnCheckedChanged.class, //
-      OnClick.class, //
-      OnEditorAction.class, //
-      OnFocusChange.class, //
-      OnItemClick.class, //
-      OnItemLongClick.class, //
-      OnItemSelected.class, //
-      OnLongClick.class, //
-      OnPageChange.class, //
-      OnTextChanged.class, //
-      OnTouch.class //
-  );
-
-  private static final List<String> SUPPORTED_TYPES = Arrays.asList(
-      "array", "attr", "bool", "color", "dimen", "drawable", "id", "integer", "string"
-  );
-
-  private Elements elementUtils;
-  private Types typeUtils;
-  private Filer filer;
-  private Trees trees;
-
-  private int sdk = 1;
-  private boolean debuggable = true;
-
-  private final Map<QualifiedId, Id> symbols = new LinkedHashMap<>();
-
-  @Override public synchronized void init(ProcessingEnvironment env) {
-    super.init(env);
-
-    String sdk = env.getOptions().get(OPTION_SDK_INT);
-    if (sdk != null) {
-      try {
-        this.sdk = Integer.parseInt(sdk);
-      } catch (NumberFormatException e) {
-        env.getMessager()
-            .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '"
-                + sdk
-                + "'. Falling back to API 1 support.");
-      }
-    }
+    // TODO remove when http://b.android.com/187527 is released.
+    private static final String OPTION_SDK_INT = "butterknife.minSdk";
+    private static final String OPTION_DEBUGGABLE = "butterknife.debuggable";
+    static final Id NO_ID = new Id(-1);
+    static final String VIEW_TYPE = "android.view.View";
+    static final String ACTIVITY_TYPE = "android.app.Activity";
+    static final String DIALOG_TYPE = "android.app.Dialog";
+    private static final String COLOR_STATE_LIST_TYPE = "android.content.res.ColorStateList";
+    private static final String BITMAP_TYPE = "android.graphics.Bitmap";
+    private static final String ANIMATION_TYPE = "android.view.animation.Animation";
+    private static final String DRAWABLE_TYPE = "android.graphics.drawable.Drawable";
+    private static final String TYPED_ARRAY_TYPE = "android.content.res.TypedArray";
+    private static final String TYPEFACE_TYPE = "android.graphics.Typeface";
+    private static final String NULLABLE_ANNOTATION_NAME = "Nullable";
+    private static final String STRING_TYPE = "java.lang.String";
+    private static final String LIST_TYPE = List.class.getCanonicalName();
+    private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
+            OnCheckedChanged.class, //
+            OnClick.class, //
+            OnEditorAction.class, //
+            OnFocusChange.class, //
+            OnItemClick.class, //
+            OnItemLongClick.class, //
+            OnItemSelected.class, //
+            OnLongClick.class, //
+            OnPageChange.class, //
+            OnTextChanged.class, //
+            OnTouch.class //
+    );
+
+    private static final List<String> SUPPORTED_TYPES = Arrays.asList(
+            "array", "attr", "bool", "color", "dimen", "drawable", "id", "integer", "string"
+    );
+
+    private Elements elementUtils;
+    private Types typeUtils;
+    private Filer filer;
+    private Trees trees;
+
+    private int sdk = 1;
+    private boolean debuggable = true;
+
+    private final Map<QualifiedId, Id> symbols = new LinkedHashMap<>();
+
+    @Override
+    public synchronized void init(ProcessingEnvironment env) {
+        super.init(env);
+
+        String sdk = env.getOptions().get(OPTION_SDK_INT);
+        if (sdk != null) {
+            try {
+                this.sdk = Integer.parseInt(sdk);
+            } catch (NumberFormatException e) {
+                env.getMessager()
+                        .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '"
+                                + sdk
+                                + "'. Falling back to API 1 support.");
+            }
+        }
 
-    debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
+        debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
 
-    elementUtils = env.getElementUtils();
-    typeUtils = env.getTypeUtils();
-    filer = env.getFiler();
-    try {
-      trees = Trees.instance(processingEnv);
-    } catch (IllegalArgumentException ignored) {
+        elementUtils = env.getElementUtils();
+        typeUtils = env.getTypeUtils();
+        filer = env.getFiler();
+        try {
+            trees = Trees.instance(processingEnv);
+        } catch (IllegalArgumentException ignored) {
+        }
     }
-  }
-
-  @Override public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(OPTION_SDK_INT, OPTION_DEBUGGABLE);
-  }
 
-  @Override public Set<String> getSupportedAnnotationTypes() {
-    Set<String> types = new LinkedHashSet<>();
-    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
-      types.add(annotation.getCanonicalName());
+    @Override
+    public Set<String> getSupportedOptions() {
+        return ImmutableSet.of(OPTION_SDK_INT, OPTION_DEBUGGABLE);
     }
-    return types;
-  }
-
-  private Set<Class<? extends Annotation>> getSupportedAnnotations() {
-    Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
-
-    annotations.add(BindAnim.class);
-    annotations.add(BindArray.class);
-    annotations.add(BindBitmap.class);
-    annotations.add(BindBool.class);
-    annotations.add(BindColor.class);
-    annotations.add(BindDimen.class);
-    annotations.add(BindDrawable.class);
-    annotations.add(BindFloat.class);
-    annotations.add(BindFont.class);
-    annotations.add(BindInt.class);
-    annotations.add(BindString.class);
-    annotations.add(BindView.class);
-    annotations.add(BindViews.class);
-    annotations.addAll(LISTENERS);
-
-    return annotations;
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
-    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
-
-    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
-      TypeElement typeElement = entry.getKey();
-      BindingSet binding = entry.getValue();
-
-      JavaFile javaFile = binding.brewJava(sdk, debuggable);
-      try {
-        javaFile.writeTo(filer);
-      } catch (IOException e) {
-        error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
-      }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+        Set<String> types = new LinkedHashSet<>();
+        for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
+            types.add(annotation.getCanonicalName());
+        }
+        return types;
+    }
+
+    private Set<Class<? extends Annotation>> getSupportedAnnotations() {
+        Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
+
+        annotations.add(BindAnim.class);
+        annotations.add(BindArray.class);
+        annotations.add(BindBitmap.class);
+        annotations.add(BindBool.class);
+        annotations.add(BindColor.class);
+        annotations.add(BindDimen.class);
+        annotations.add(BindDrawable.class);
+        annotations.add(BindFloat.class);
+        annotations.add(BindFont.class);
+        annotations.add(BindInt.class);
+        annotations.add(BindString.class);
+        annotations.add(BindView.class);
+        annotations.add(BindViews.class);
+        annotations.addAll(LISTENERS);
+
+        return annotations;
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+        //使用 RoundEnvironment 可以查找被特定注解标注的元素
+        Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
+
+        for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
+            TypeElement typeElement = entry.getKey();
+            BindingSet binding = entry.getValue();
+
+            JavaFile javaFile = binding.brewJava(sdk, debuggable);
+            try {
+                javaFile.writeTo(filer);
+            } catch (IOException e) {
+                error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
+            }
+        }
+
+        return false;
     }
 
-    return false;
-  }
+    //扫描所有的 ButterKnife 注解，并且生成以 TypeElement 为键，BindingSet为值的 HashMap
+    private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
+        Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
+        Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
 
-  private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
-    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
-    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
+        scanForRClasses(env);
 
-    scanForRClasses(env);
+        // Process each @BindAnim element.
+        for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceAnimation(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindAnim.class, e);
+            }
+        }
 
-    // Process each @BindAnim element.
-    for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceAnimation(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindAnim.class, e);
-      }
-    }
+        // Process each @BindArray element.
+        for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceArray(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindArray.class, e);
+            }
+        }
 
-    // Process each @BindArray element.
-    for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceArray(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindArray.class, e);
-      }
-    }
+        // Process each @BindBitmap element.
+        for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceBitmap(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindBitmap.class, e);
+            }
+        }
 
-    // Process each @BindBitmap element.
-    for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceBitmap(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindBitmap.class, e);
-      }
-    }
+        // Process each @BindBool element.
+        for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceBool(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindBool.class, e);
+            }
+        }
 
-    // Process each @BindBool element.
-    for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceBool(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindBool.class, e);
-      }
-    }
+        // Process each @BindColor element.
+        for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceColor(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindColor.class, e);
+            }
+        }
 
-    // Process each @BindColor element.
-    for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceColor(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindColor.class, e);
-      }
-    }
+        // Process each @BindDimen element.
+        for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceDimen(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindDimen.class, e);
+            }
+        }
 
-    // Process each @BindDimen element.
-    for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceDimen(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindDimen.class, e);
-      }
-    }
+        // Process each @BindDrawable element.
+        for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceDrawable(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindDrawable.class, e);
+            }
+        }
 
-    // Process each @BindDrawable element.
-    for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceDrawable(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindDrawable.class, e);
-      }
-    }
+        // Process each @BindFloat element.
+        for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceFloat(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindFloat.class, e);
+            }
+        }
 
-    // Process each @BindFloat element.
-    for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceFloat(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindFloat.class, e);
-      }
-    }
+        // Process each @BindFont element.
+        for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceFont(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindFont.class, e);
+            }
+        }
 
-    // Process each @BindFont element.
-    for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceFont(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindFont.class, e);
-      }
-    }
+        // Process each @BindInt element.
+        for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceInt(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindInt.class, e);
+            }
+        }
 
-    // Process each @BindInt element.
-    for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceInt(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindInt.class, e);
-      }
-    }
+        // Process each @BindString element.
+        for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceString(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindString.class, e);
+            }
+        }
 
-    // Process each @BindString element.
-    for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceString(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindString.class, e);
-      }
-    }
+        // Process each @BindView element.
+        //遍历所有被 @BindView 标注的元素
+        for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
+            // we don't SuperficialValidation.validateElement(element)
+            // so that an unresolved View type can be generated by later processing rounds
+            try {
+                parseBindView(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                //输出错误信息
+                logParsingError(element, BindView.class, e);
+            }
+        }
 
-    // Process each @BindView element.
-    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
-      // we don't SuperficialValidation.validateElement(element)
-      // so that an unresolved View type can be generated by later processing rounds
-      try {
-        parseBindView(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindView.class, e);
-      }
-    }
+        // Process each @BindViews element.
+        for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
+            // we don't SuperficialValidation.validateElement(element)
+            // so that an unresolved View type can be generated by later processing rounds
+            try {
+                parseBindViews(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindViews.class, e);
+            }
+        }
 
-    // Process each @BindViews element.
-    for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
-      // we don't SuperficialValidation.validateElement(element)
-      // so that an unresolved View type can be generated by later processing rounds
-      try {
-        parseBindViews(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindViews.class, e);
-      }
-    }
+        // Process each annotation that corresponds to a listener.
+        for (Class<? extends Annotation> listener : LISTENERS) {
+            findAndParseListener(env, listener, builderMap, erasedTargetNames);
+        }
 
-    // Process each annotation that corresponds to a listener.
-    for (Class<? extends Annotation> listener : LISTENERS) {
-      findAndParseListener(env, listener, builderMap, erasedTargetNames);
-    }
+        // Associate superclass binders with their subclass binders. This is a queue-based tree walk
+        // which starts at the roots (superclasses) and walks to the leafs (subclasses).
+        Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
+                new ArrayDeque<>(builderMap.entrySet());
+        Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
+        while (!entries.isEmpty()) {
+            Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();
 
-    // Associate superclass binders with their subclass binders. This is a queue-based tree walk
-    // which starts at the roots (superclasses) and walks to the leafs (subclasses).
-    Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
-        new ArrayDeque<>(builderMap.entrySet());
-    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
-    while (!entries.isEmpty()) {
-      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();
-
-      TypeElement type = entry.getKey();
-      BindingSet.Builder builder = entry.getValue();
-
-      TypeElement parentType = findParentType(type, erasedTargetNames);
-      if (parentType == null) {
-        bindingMap.put(type, builder.build());
-      } else {
-        BindingSet parentBinding = bindingMap.get(parentType);
-        if (parentBinding != null) {
-          builder.setParent(parentBinding);
-          bindingMap.put(type, builder.build());
-        } else {
-          // Has a superclass binding but we haven't built it yet. Re-enqueue for later.
-          entries.addLast(entry);
+            TypeElement type = entry.getKey();
+            BindingSet.Builder builder = entry.getValue();
+
+            TypeElement parentType = findParentType(type, erasedTargetNames);
+            if (parentType == null) {
+                bindingMap.put(type, builder.build());
+            } else {
+                BindingSet parentBinding = bindingMap.get(parentType);
+                if (parentBinding != null) {
+                    builder.setParent(parentBinding);
+                    bindingMap.put(type, builder.build());
+                } else {
+                    // Has a superclass binding but we haven't built it yet. Re-enqueue for later.
+                    entries.addLast(entry);
+                }
+            }
         }
-      }
-    }
 
-    return bindingMap;
-  }
-
-  private void logParsingError(Element element, Class<? extends Annotation> annotation,
-      Exception e) {
-    StringWriter stackTrace = new StringWriter();
-    e.printStackTrace(new PrintWriter(stackTrace));
-    error(element, "Unable to parse @%s binding.\n\n%s", annotation.getSimpleName(), stackTrace);
-  }
-
-  private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass,
-      String targetThing, Element element) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify method modifiers.
-    Set<Modifier> modifiers = element.getModifiers();
-    if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
-      error(element, "@%s %s must not be private or static. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+        return bindingMap;
     }
 
-    // Verify containing type.
-    if (enclosingElement.getKind() != CLASS) {
-      error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+    private void logParsingError(Element element, Class<? extends Annotation> annotation,
+                                 Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+        error(element, "Unable to parse @%s binding.\n\n%s", annotation.getSimpleName(), stackTrace);
     }
 
-    // Verify containing class visibility is not private.
-    if (enclosingElement.getModifiers().contains(PRIVATE)) {
-      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass,
+                                                   String targetThing, Element element) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    return hasError;
-  }
+        // Verify method modifiers.
+        Set<Modifier> modifiers = element.getModifiers();
+        if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
+            error(element, "@%s %s must not be private or static. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
-      Element element) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-    String qualifiedName = enclosingElement.getQualifiedName().toString();
+        // Verify containing type.
+        if (enclosingElement.getKind() != CLASS) {
+            error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (qualifiedName.startsWith("android.")) {
-      error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
+        // Verify containing class visibility is not private.
+        if (enclosingElement.getModifiers().contains(PRIVATE)) {
+            error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
+
+        return hasError;
     }
-    if (qualifiedName.startsWith("java.")) {
-      error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
+
+    private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
+                                            Element element) {
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        String qualifiedName = enclosingElement.getQualifiedName().toString();
+
+        if (qualifiedName.startsWith("android.")) {
+            error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
+                    annotationClass.getSimpleName(), qualifiedName);
+            return true;
+        }
+        if (qualifiedName.startsWith("java.")) {
+            error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
+                    annotationClass.getSimpleName(), qualifiedName);
+            return true;
+        }
+
+        return false;
     }
 
-    return false;
-  }
+    private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+                               Set<TypeElement> erasedTargetNames) {
+        //得到注解 @BindView 元素所在的类元素
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-  private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
-      Set<TypeElement> erasedTargetNames) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Start by verifying common generated code restrictions.
+        // -------- 类型校验逻辑-----start
+        //类型校验逻辑
+        //判断是否被注解在属性上，如果该属性是被 private 或者 static 修饰的，则出错
+        //判断是否被注解在错误的包中，若包名以“android” 或者 “java”开头，则出错
+        boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
+                || isBindingInWrongPackage(BindView.class, element);
 
-    // Start by verifying common generated code restrictions.
-    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
-        || isBindingInWrongPackage(BindView.class, element);
+        // Verify that the target type extends from View.
+        TypeMirror elementType = element.asType();
+        if (elementType.getKind() == TypeKind.TYPEVAR) {
+            TypeVariable typeVariable = (TypeVariable) elementType;
+            elementType = typeVariable.getUpperBound();
+        }
+        Name qualifiedName = enclosingElement.getQualifiedName();
+        Name simpleName = element.getSimpleName();
+        if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
+            if (elementType.getKind() == TypeKind.ERROR) {
+                note(element, "@%s field with unresolved type (%s) "
+                                + "must elsewhere be generated as a View or interface. (%s.%s)",
+                        BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
+            } else {
+                error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
+                        BindView.class.getSimpleName(), qualifiedName, simpleName);
+                hasError = true;
+            }
+        }
 
-    // Verify that the target type extends from View.
-    TypeMirror elementType = element.asType();
-    if (elementType.getKind() == TypeKind.TYPEVAR) {
-      TypeVariable typeVariable = (TypeVariable) elementType;
-      elementType = typeVariable.getUpperBound();
-    }
-    Name qualifiedName = enclosingElement.getQualifiedName();
-    Name simpleName = element.getSimpleName();
-    if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
-      if (elementType.getKind() == TypeKind.ERROR) {
-        note(element, "@%s field with unresolved type (%s) "
-                + "must elsewhere be generated as a View or interface. (%s.%s)",
-            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
-      } else {
-        error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
-            BindView.class.getSimpleName(), qualifiedName, simpleName);
-        hasError = true;
-      }
-    }
+        //如果有错误，不执行下面代码
+        if (hasError) {
+            return;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // -------- 类型校验逻辑-----end
+
+        // Assemble information on the field.
+        //得到被注解的注解值，即R.id.xxx
+        int id = element.getAnnotation(BindView.class).value();
+
+        //根据所在的类元素去查找 builder
+        BindingSet.Builder builder = builderMap.get(enclosingElement);
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        //如果相应的 builder 已经存在
+        if (builder != null) {
+            //得到相对应的 View 绑定的属性名
+            String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
+            //若该属性名已经存在，则说明之前已经绑定过，会报错
+            if (existingBindingName != null) {
+                error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
+                        BindView.class.getSimpleName(), id, existingBindingName,
+                        enclosingElement.getQualifiedName(), element.getSimpleName());
+                return;
+            }
+        } else {
+            //如果没有对应的 builder，就通过 getOnCreateBuilder 方法生成，并且放入 builderMap
+            builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        }
 
-    // Assemble information on the field.
-    int id = element.getAnnotation(BindView.class).value();
-
-    BindingSet.Builder builder = builderMap.get(enclosingElement);
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    if (builder != null) {
-      String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
-      if (existingBindingName != null) {
-        error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
-            BindView.class.getSimpleName(), id, existingBindingName,
-            enclosingElement.getQualifiedName(), element.getSimpleName());
-        return;
-      }
-    } else {
-      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    }
+        //得到注解名
+        String name = simpleName.toString();
+        //得到注解元素的类型
+        TypeName type = TypeName.get(elementType);
+        boolean required = isFieldRequired(element);
+
+        //更具id，添加相对应的 Field 的绑定信息
+        builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));
+
+        // Add the type-erased version to the valid binding targets set.
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private QualifiedId elementToQualifiedId(Element element, int id) {
+        return new QualifiedId(elementUtils.getPackageOf(element), id);
+    }
+
+    private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+                                Set<TypeElement> erasedTargetNames) {
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Start by verifying common generated code restrictions.
+        boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
+                || isBindingInWrongPackage(BindViews.class, element);
+
+        // Verify that the type is a List or an array.
+        TypeMirror elementType = element.asType();
+        String erasedType = doubleErasure(elementType);
+        TypeMirror viewType = null;
+        FieldCollectionViewBinding.Kind kind = null;
+        if (elementType.getKind() == TypeKind.ARRAY) {
+            ArrayType arrayType = (ArrayType) elementType;
+            viewType = arrayType.getComponentType();
+            kind = FieldCollectionViewBinding.Kind.ARRAY;
+        } else if (LIST_TYPE.equals(erasedType)) {
+            DeclaredType declaredType = (DeclaredType) elementType;
+            List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+            if (typeArguments.size() != 1) {
+                error(element, "@%s List must have a generic component. (%s.%s)",
+                        BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+                hasError = true;
+            } else {
+                viewType = typeArguments.get(0);
+            }
+            kind = FieldCollectionViewBinding.Kind.LIST;
+        } else {
+            error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
+        if (viewType != null && viewType.getKind() == TypeKind.TYPEVAR) {
+            TypeVariable typeVariable = (TypeVariable) viewType;
+            viewType = typeVariable.getUpperBound();
+        }
 
-    String name = simpleName.toString();
-    TypeName type = TypeName.get(elementType);
-    boolean required = isFieldRequired(element);
-
-    builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));
-
-    // Add the type-erased version to the valid binding targets set.
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private QualifiedId elementToQualifiedId(Element element, int id) {
-    return new QualifiedId(elementUtils.getPackageOf(element), id);
-  }
-
-  private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
-      Set<TypeElement> erasedTargetNames) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Start by verifying common generated code restrictions.
-    boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
-        || isBindingInWrongPackage(BindViews.class, element);
-
-    // Verify that the type is a List or an array.
-    TypeMirror elementType = element.asType();
-    String erasedType = doubleErasure(elementType);
-    TypeMirror viewType = null;
-    FieldCollectionViewBinding.Kind kind = null;
-    if (elementType.getKind() == TypeKind.ARRAY) {
-      ArrayType arrayType = (ArrayType) elementType;
-      viewType = arrayType.getComponentType();
-      kind = FieldCollectionViewBinding.Kind.ARRAY;
-    } else if (LIST_TYPE.equals(erasedType)) {
-      DeclaredType declaredType = (DeclaredType) elementType;
-      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-      if (typeArguments.size() != 1) {
-        error(element, "@%s List must have a generic component. (%s.%s)",
-            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-        hasError = true;
-      } else {
-        viewType = typeArguments.get(0);
-      }
-      kind = FieldCollectionViewBinding.Kind.LIST;
-    } else {
-      error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-    if (viewType != null && viewType.getKind() == TypeKind.TYPEVAR) {
-      TypeVariable typeVariable = (TypeVariable) viewType;
-      viewType = typeVariable.getUpperBound();
-    }
+        // Verify that the target type extends from View.
+        if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
+            if (viewType.getKind() == TypeKind.ERROR) {
+                note(element, "@%s List or array with unresolved type (%s) "
+                                + "must elsewhere be generated as a View or interface. (%s.%s)",
+                        BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+            } else {
+                error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
+                        BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+                hasError = true;
+            }
+        }
 
-    // Verify that the target type extends from View.
-    if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
-      if (viewType.getKind() == TypeKind.ERROR) {
-        note(element, "@%s List or array with unresolved type (%s) "
-                + "must elsewhere be generated as a View or interface. (%s.%s)",
-            BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-      } else {
-        error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
-            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-        hasError = true;
-      }
-    }
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int[] ids = element.getAnnotation(BindViews.class).value();
+        if (ids.length == 0) {
+            error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int[] ids = element.getAnnotation(BindViews.class).value();
-    if (ids.length == 0) {
-      error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        Integer duplicateId = findDuplicate(ids);
+        if (duplicateId != null) {
+            error(element, "@%s annotation contains duplicate ID %d. (%s.%s)",
+                    BindViews.class.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    Integer duplicateId = findDuplicate(ids);
-    if (duplicateId != null) {
-      error(element, "@%s annotation contains duplicate ID %d. (%s.%s)",
-          BindViews.class.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    if (hasError) {
-      return;
-    }
+        assert viewType != null; // Always false as hasError would have been true.
+        TypeName type = TypeName.get(viewType);
+        boolean required = isFieldRequired(element);
 
-    assert viewType != null; // Always false as hasError would have been true.
-    TypeName type = TypeName.get(viewType);
-    boolean required = isFieldRequired(element);
+        List<Id> idVars = new ArrayList<>();
+        for (int id : ids) {
+            QualifiedId qualifiedId = elementToQualifiedId(element, id);
+            idVars.add(getId(qualifiedId));
+        }
+
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required));
 
-    List<Id> idVars = new ArrayList<>();
-    for (int id : ids) {
-      QualifiedId qualifiedId = elementToQualifiedId(element, id);
-      idVars.add(getId(qualifiedId));
+        erasedTargetNames.add(enclosingElement);
     }
 
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required));
+    private void parseResourceAnimation(Element element,
+                                        Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    erasedTargetNames.add(enclosingElement);
-  }
+        // Verify that the target type is Animation.
+        if (!ANIMATION_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Animation'. (%s.%s)",
+                    BindAnim.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private void parseResourceAnimation(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindAnim.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindAnim.class, element);
 
-    // Verify that the target type is Animation.
-    if (!ANIMATION_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Animation'. (%s.%s)",
-          BindAnim.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindAnim.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindAnim.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindAnim.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldAnimationBinding(getId(qualifiedId), name));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindAnim.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldAnimationBinding(getId(qualifiedId), name));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceBool(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is bool.
-    if (element.asType().getKind() != TypeKind.BOOLEAN) {
-      error(element, "@%s field type must be 'boolean'. (%s.%s)",
-          BindBool.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceBool(Element element,
+                                   Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindBool.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindBool.class, element);
+        // Verify that the target type is bool.
+        if (element.asType().getKind() != TypeKind.BOOLEAN) {
+            error(element, "@%s field type must be 'boolean'. (%s.%s)",
+                    BindBool.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindBool.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindBool.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindBool.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BOOL));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceColor(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is int or ColorStateList.
-    boolean isColorStateList = false;
-    TypeMirror elementType = element.asType();
-    if (COLOR_STATE_LIST_TYPE.equals(elementType.toString())) {
-      isColorStateList = true;
-    } else if (elementType.getKind() != TypeKind.INT) {
-      error(element, "@%s field type must be 'int' or 'ColorStateList'. (%s.%s)",
-          BindColor.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindColor.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindColor.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindBool.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BOOL));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceColor(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is int or ColorStateList.
+        boolean isColorStateList = false;
+        TypeMirror elementType = element.asType();
+        if (COLOR_STATE_LIST_TYPE.equals(elementType.toString())) {
+            isColorStateList = true;
+        } else if (elementType.getKind() != TypeKind.INT) {
+            error(element, "@%s field type must be 'int' or 'ColorStateList'. (%s.%s)",
+                    BindColor.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindColor.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindColor.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindColor.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
-        isColorStateList ? FieldResourceBinding.Type.COLOR_STATE_LIST
-            : FieldResourceBinding.Type.COLOR));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceDimen(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is int or ColorStateList.
-    boolean isInt = false;
-    TypeMirror elementType = element.asType();
-    if (elementType.getKind() == TypeKind.INT) {
-      isInt = true;
-    } else if (elementType.getKind() != TypeKind.FLOAT) {
-      error(element, "@%s field type must be 'int' or 'float'. (%s.%s)",
-          BindDimen.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindDimen.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindDimen.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindColor.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
+                isColorStateList ? FieldResourceBinding.Type.COLOR_STATE_LIST
+                        : FieldResourceBinding.Type.COLOR));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceDimen(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is int or ColorStateList.
+        boolean isInt = false;
+        TypeMirror elementType = element.asType();
+        if (elementType.getKind() == TypeKind.INT) {
+            isInt = true;
+        } else if (elementType.getKind() != TypeKind.FLOAT) {
+            error(element, "@%s field type must be 'int' or 'float'. (%s.%s)",
+                    BindDimen.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindDimen.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindDimen.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindDimen.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
-        isInt ? FieldResourceBinding.Type.DIMEN_AS_INT : FieldResourceBinding.Type.DIMEN_AS_FLOAT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceBitmap(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is Bitmap.
-    if (!BITMAP_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Bitmap'. (%s.%s)",
-          BindBitmap.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindBitmap.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindBitmap.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindDimen.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
+                isInt ? FieldResourceBinding.Type.DIMEN_AS_INT : FieldResourceBinding.Type.DIMEN_AS_FLOAT));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindBitmap.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BITMAP));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceDrawable(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is Drawable.
-    if (!DRAWABLE_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Drawable'. (%s.%s)",
-          BindDrawable.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceBitmap(Element element,
+                                     Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindDrawable.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindDrawable.class, element);
+        // Verify that the target type is Bitmap.
+        if (!BITMAP_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Bitmap'. (%s.%s)",
+                    BindBitmap.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindBitmap.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindBitmap.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindDrawable.class).value();
-    int tint = element.getAnnotation(BindDrawable.class).tint();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    QualifiedId qualifiedTint = elementToQualifiedId(element, tint);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldDrawableBinding(getId(qualifiedId), name, getId(qualifiedTint)));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceFloat(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is float.
-    if (element.asType().getKind() != TypeKind.FLOAT) {
-      error(element, "@%s field type must be 'float'. (%s.%s)",
-          BindFloat.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindFloat.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindFloat.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindBitmap.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BITMAP));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindFloat.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.FLOAT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceFont(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is a Typeface.
-    if (!TYPEFACE_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Typeface'. (%s.%s)",
-          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceDrawable(Element element,
+                                       Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindFont.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindFont.class, element);
+        // Verify that the target type is Drawable.
+        if (!DRAWABLE_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Drawable'. (%s.%s)",
+                    BindDrawable.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    BindFont bindFont = element.getAnnotation(BindFont.class);
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindDrawable.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindDrawable.class, element);
 
-    int styleValue = bindFont.style();
-    TypefaceStyles style = TypefaceStyles.fromValue(styleValue);
-    if (style == null) {
-      error(element, "@%s style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (%s.%s)",
-          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(), name);
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
+
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindDrawable.class).value();
+        int tint = element.getAnnotation(BindDrawable.class).tint();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        QualifiedId qualifiedTint = elementToQualifiedId(element, tint);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldDrawableBinding(getId(qualifiedId), name, getId(qualifiedTint)));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    QualifiedId qualifiedId = elementToQualifiedId(element, bindFont.value());
-    builder.addResource(new FieldTypefaceBinding(getId(qualifiedId), name, style));
+    private void parseResourceFloat(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    erasedTargetNames.add(enclosingElement);
-  }
+        // Verify that the target type is float.
+        if (element.asType().getKind() != TypeKind.FLOAT) {
+            error(element, "@%s field type must be 'float'. (%s.%s)",
+                    BindFloat.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private void parseResourceInt(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindFloat.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindFloat.class, element);
 
-    // Verify that the target type is int.
-    if (element.asType().getKind() != TypeKind.INT) {
-      error(element, "@%s field type must be 'int'. (%s.%s)", BindInt.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindInt.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindInt.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindFloat.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.FLOAT));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindInt.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.INT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceString(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is String.
-    if (!STRING_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'String'. (%s.%s)",
-          BindString.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceFont(Element element,
+                                   Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindString.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindString.class, element);
+        // Verify that the target type is a Typeface.
+        if (!TYPEFACE_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Typeface'. (%s.%s)",
+                    BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindFont.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindFont.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindString.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.STRING));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceArray(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is supported.
-    FieldResourceBinding.Type type = getArrayResourceMethodName(element);
-    if (type == null) {
-      error(element,
-          "@%s field type must be one of: String[], int[], CharSequence[], %s. (%s.%s)",
-          BindArray.class.getSimpleName(), TYPED_ARRAY_TYPE, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        BindFont bindFont = element.getAnnotation(BindFont.class);
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindArray.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindArray.class, element);
+        int styleValue = bindFont.style();
+        TypefaceStyles style = TypefaceStyles.fromValue(styleValue);
+        if (style == null) {
+            error(element, "@%s style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (%s.%s)",
+                    BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(), name);
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindArray.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name, type));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  /**
-   * Returns a method name from the {@link android.content.res.Resources} class for array resource
-   * binding, null if the element type is not supported.
-   */
-  private static FieldResourceBinding.Type getArrayResourceMethodName(Element element) {
-    TypeMirror typeMirror = element.asType();
-    if (TYPED_ARRAY_TYPE.equals(typeMirror.toString())) {
-      return FieldResourceBinding.Type.TYPED_ARRAY;
-    }
-    if (TypeKind.ARRAY.equals(typeMirror.getKind())) {
-      ArrayType arrayType = (ArrayType) typeMirror;
-      String componentType = arrayType.getComponentType().toString();
-      if (STRING_TYPE.equals(componentType)) {
-        return FieldResourceBinding.Type.STRING_ARRAY;
-      } else if ("int".equals(componentType)) {
-        return FieldResourceBinding.Type.INT_ARRAY;
-      } else if ("java.lang.CharSequence".equals(componentType)) {
-        return FieldResourceBinding.Type.TEXT_ARRAY;
-      }
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        QualifiedId qualifiedId = elementToQualifiedId(element, bindFont.value());
+        builder.addResource(new FieldTypefaceBinding(getId(qualifiedId), name, style));
+
+        erasedTargetNames.add(enclosingElement);
     }
-    return null;
-  }
 
-  /** Returns the first duplicate element inside an array, null if there are no duplicates. */
-  private static Integer findDuplicate(int[] array) {
-    Set<Integer> seenElements = new LinkedHashSet<>();
+    private void parseResourceInt(Element element,
+                                  Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    for (int element : array) {
-      if (!seenElements.add(element)) {
-        return element;
-      }
-    }
+        // Verify that the target type is int.
+        if (element.asType().getKind() != TypeKind.INT) {
+            error(element, "@%s field type must be 'int'. (%s.%s)", BindInt.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    return null;
-  }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindInt.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindInt.class, element);
 
-  /** Uses both {@link Types#erasure} and string manipulation to strip any generic types. */
-  private String doubleErasure(TypeMirror elementType) {
-    String name = typeUtils.erasure(elementType).toString();
-    int typeParamStart = name.indexOf('<');
-    if (typeParamStart != -1) {
-      name = name.substring(0, typeParamStart);
-    }
-    return name;
-  }
-
-  private void findAndParseListener(RoundEnvironment env,
-      Class<? extends Annotation> annotationClass,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        StringWriter stackTrace = new StringWriter();
-        e.printStackTrace(new PrintWriter(stackTrace));
+        if (hasError) {
+            return;
+        }
 
-        error(element, "Unable to generate view binder for @%s.\n\n%s",
-            annotationClass.getSimpleName(), stackTrace.toString());
-      }
-    }
-  }
-
-  private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames)
-      throws Exception {
-    // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
-    if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
-      throw new IllegalStateException(
-          String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindInt.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.INT));
+
+        erasedTargetNames.add(enclosingElement);
     }
 
-    ExecutableElement executableElement = (ExecutableElement) element;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+    private void parseResourceString(Element element,
+                                     Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is String.
+        if (!STRING_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'String'. (%s.%s)",
+                    BindString.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
+
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindString.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindString.class, element);
+
+        if (hasError) {
+            return;
+        }
+
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindString.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.STRING));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceArray(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is supported.
+        FieldResourceBinding.Type type = getArrayResourceMethodName(element);
+        if (type == null) {
+            error(element,
+                    "@%s field type must be one of: String[], int[], CharSequence[], %s. (%s.%s)",
+                    BindArray.class.getSimpleName(), TYPED_ARRAY_TYPE, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
+
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindArray.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindArray.class, element);
+
+        if (hasError) {
+            return;
+        }
+
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindArray.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name, type));
 
-    // Assemble information on the method.
-    Annotation annotation = element.getAnnotation(annotationClass);
-    Method annotationValue = annotationClass.getDeclaredMethod("value");
-    if (annotationValue.getReturnType() != int[].class) {
-      throw new IllegalStateException(
-          String.format("@%s annotation value() type not int[].", annotationClass));
+        erasedTargetNames.add(enclosingElement);
     }
 
-    int[] ids = (int[]) annotationValue.invoke(annotation);
-    String name = executableElement.getSimpleName().toString();
-    boolean required = isListenerRequired(executableElement);
+    /**
+     * Returns a method name from the {@link android.content.res.Resources} class for array resource
+     * binding, null if the element type is not supported.
+     */
+    private static FieldResourceBinding.Type getArrayResourceMethodName(Element element) {
+        TypeMirror typeMirror = element.asType();
+        if (TYPED_ARRAY_TYPE.equals(typeMirror.toString())) {
+            return FieldResourceBinding.Type.TYPED_ARRAY;
+        }
+        if (TypeKind.ARRAY.equals(typeMirror.getKind())) {
+            ArrayType arrayType = (ArrayType) typeMirror;
+            String componentType = arrayType.getComponentType().toString();
+            if (STRING_TYPE.equals(componentType)) {
+                return FieldResourceBinding.Type.STRING_ARRAY;
+            } else if ("int".equals(componentType)) {
+                return FieldResourceBinding.Type.INT_ARRAY;
+            } else if ("java.lang.CharSequence".equals(componentType)) {
+                return FieldResourceBinding.Type.TEXT_ARRAY;
+            }
+        }
+        return null;
+    }
 
-    // Verify that the method and its containing class are accessible via generated code.
-    boolean hasError = isInaccessibleViaGeneratedCode(annotationClass, "methods", element);
-    hasError |= isBindingInWrongPackage(annotationClass, element);
+    /**
+     * Returns the first duplicate element inside an array, null if there are no duplicates.
+     */
+    private static Integer findDuplicate(int[] array) {
+        Set<Integer> seenElements = new LinkedHashSet<>();
 
-    Integer duplicateId = findDuplicate(ids);
-    if (duplicateId != null) {
-      error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
-          annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+        for (int element : array) {
+            if (!seenElements.add(element)) {
+                return element;
+            }
+        }
+
+        return null;
     }
 
-    ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
-    if (listener == null) {
-      throw new IllegalStateException(
-          String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
-              annotationClass.getSimpleName()));
+    /**
+     * Uses both {@link Types#erasure} and string manipulation to strip any generic types.
+     */
+    private String doubleErasure(TypeMirror elementType) {
+        String name = typeUtils.erasure(elementType).toString();
+        int typeParamStart = name.indexOf('<');
+        if (typeParamStart != -1) {
+            name = name.substring(0, typeParamStart);
+        }
+        return name;
+    }
+
+    private void findAndParseListener(RoundEnvironment env,
+                                      Class<? extends Annotation> annotationClass,
+                                      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                StringWriter stackTrace = new StringWriter();
+                e.printStackTrace(new PrintWriter(stackTrace));
+
+                error(element, "Unable to generate view binder for @%s.\n\n%s",
+                        annotationClass.getSimpleName(), stackTrace.toString());
+            }
+        }
     }
 
-    for (int id : ids) {
-      if (id == NO_ID.value) {
-        if (ids.length == 1) {
-          if (!required) {
-            error(element, "ID-free binding must not be annotated with @Optional. (%s.%s)",
-                enclosingElement.getQualifiedName(), element.getSimpleName());
+    private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
+                                         Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames)
+            throws Exception {
+        // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
+        if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
+            throw new IllegalStateException(
+                    String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
+        }
+
+        ExecutableElement executableElement = (ExecutableElement) element;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Assemble information on the method.
+        Annotation annotation = element.getAnnotation(annotationClass);
+        Method annotationValue = annotationClass.getDeclaredMethod("value");
+        if (annotationValue.getReturnType() != int[].class) {
+            throw new IllegalStateException(
+                    String.format("@%s annotation value() type not int[].", annotationClass));
+        }
+
+        int[] ids = (int[]) annotationValue.invoke(annotation);
+        String name = executableElement.getSimpleName().toString();
+        boolean required = isListenerRequired(executableElement);
+
+        // Verify that the method and its containing class are accessible via generated code.
+        boolean hasError = isInaccessibleViaGeneratedCode(annotationClass, "methods", element);
+        hasError |= isBindingInWrongPackage(annotationClass, element);
+
+        Integer duplicateId = findDuplicate(ids);
+        if (duplicateId != null) {
+            error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
+                    annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
             hasError = true;
-          }
+        }
+
+        ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
+        if (listener == null) {
+            throw new IllegalStateException(
+                    String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
+                            annotationClass.getSimpleName()));
+        }
+
+        for (int id : ids) {
+            if (id == NO_ID.value) {
+                if (ids.length == 1) {
+                    if (!required) {
+                        error(element, "ID-free binding must not be annotated with @Optional. (%s.%s)",
+                                enclosingElement.getQualifiedName(), element.getSimpleName());
+                        hasError = true;
+                    }
+                } else {
+                    error(element, "@%s annotation contains invalid ID %d. (%s.%s)",
+                            annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
+                            element.getSimpleName());
+                    hasError = true;
+                }
+            }
+        }
+
+        ListenerMethod method;
+        ListenerMethod[] methods = listener.method();
+        if (methods.length > 1) {
+            throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
+                    annotationClass.getSimpleName()));
+        } else if (methods.length == 1) {
+            if (listener.callbacks() != ListenerClass.NONE.class) {
+                throw new IllegalStateException(
+                        String.format("Both method() and callback() defined on @%s.",
+                                annotationClass.getSimpleName()));
+            }
+            method = methods[0];
         } else {
-          error(element, "@%s annotation contains invalid ID %d. (%s.%s)",
-              annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
-              element.getSimpleName());
-          hasError = true;
+            Method annotationCallback = annotationClass.getDeclaredMethod("callback");
+            Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
+            Field callbackField = callback.getDeclaringClass().getField(callback.name());
+            method = callbackField.getAnnotation(ListenerMethod.class);
+            if (method == null) {
+                throw new IllegalStateException(
+                        String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
+                                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
+                                callback.name()));
+            }
         }
-      }
-    }
 
-    ListenerMethod method;
-    ListenerMethod[] methods = listener.method();
-    if (methods.length > 1) {
-      throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
-          annotationClass.getSimpleName()));
-    } else if (methods.length == 1) {
-      if (listener.callbacks() != ListenerClass.NONE.class) {
-        throw new IllegalStateException(
-            String.format("Both method() and callback() defined on @%s.",
-                annotationClass.getSimpleName()));
-      }
-      method = methods[0];
-    } else {
-      Method annotationCallback = annotationClass.getDeclaredMethod("callback");
-      Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
-      Field callbackField = callback.getDeclaringClass().getField(callback.name());
-      method = callbackField.getAnnotation(ListenerMethod.class);
-      if (method == null) {
-        throw new IllegalStateException(
-            String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
-                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
-                callback.name()));
-      }
-    }
+        // Verify that the method has equal to or less than the number of parameters as the listener.
+        List<? extends VariableElement> methodParameters = executableElement.getParameters();
+        if (methodParameters.size() > method.parameters().length) {
+            error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
+                    annotationClass.getSimpleName(), method.parameters().length,
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Verify that the method has equal to or less than the number of parameters as the listener.
-    List<? extends VariableElement> methodParameters = executableElement.getParameters();
-    if (methodParameters.size() > method.parameters().length) {
-      error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
-          annotationClass.getSimpleName(), method.parameters().length,
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        // Verify method return type matches the listener.
+        TypeMirror returnType = executableElement.getReturnType();
+        if (returnType instanceof TypeVariable) {
+            TypeVariable typeVariable = (TypeVariable) returnType;
+            returnType = typeVariable.getUpperBound();
+        }
+        if (!returnType.toString().equals(method.returnType())) {
+            error(element, "@%s methods must have a '%s' return type. (%s.%s)",
+                    annotationClass.getSimpleName(), method.returnType(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Verify method return type matches the listener.
-    TypeMirror returnType = executableElement.getReturnType();
-    if (returnType instanceof TypeVariable) {
-      TypeVariable typeVariable = (TypeVariable) returnType;
-      returnType = typeVariable.getUpperBound();
-    }
-    if (!returnType.toString().equals(method.returnType())) {
-      error(element, "@%s methods must have a '%s' return type. (%s.%s)",
-          annotationClass.getSimpleName(), method.returnType(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
+        if (hasError) {
+            return;
+        }
+
+        Parameter[] parameters = Parameter.NONE;
+        if (!methodParameters.isEmpty()) {
+            parameters = new Parameter[methodParameters.size()];
+            BitSet methodParameterUsed = new BitSet(methodParameters.size());
+            String[] parameterTypes = method.parameters();
+            for (int i = 0; i < methodParameters.size(); i++) {
+                VariableElement methodParameter = methodParameters.get(i);
+                TypeMirror methodParameterType = methodParameter.asType();
+                if (methodParameterType instanceof TypeVariable) {
+                    TypeVariable typeVariable = (TypeVariable) methodParameterType;
+                    methodParameterType = typeVariable.getUpperBound();
+                }
+
+                for (int j = 0; j < parameterTypes.length; j++) {
+                    if (methodParameterUsed.get(j)) {
+                        continue;
+                    }
+                    if ((isSubtypeOfType(methodParameterType, parameterTypes[j])
+                            && isSubtypeOfType(methodParameterType, VIEW_TYPE))
+                            || isTypeEqual(methodParameterType, parameterTypes[j])
+                            || isInterface(methodParameterType)) {
+                        parameters[i] = new Parameter(j, TypeName.get(methodParameterType));
+                        methodParameterUsed.set(j);
+                        break;
+                    }
+                }
+                if (parameters[i] == null) {
+                    StringBuilder builder = new StringBuilder();
+                    builder.append("Unable to match @")
+                            .append(annotationClass.getSimpleName())
+                            .append(" method arguments. (")
+                            .append(enclosingElement.getQualifiedName())
+                            .append('.')
+                            .append(element.getSimpleName())
+                            .append(')');
+                    for (int j = 0; j < parameters.length; j++) {
+                        Parameter parameter = parameters[j];
+                        builder.append("\n\n  Parameter #")
+                                .append(j + 1)
+                                .append(": ")
+                                .append(methodParameters.get(j).asType().toString())
+                                .append("\n    ");
+                        if (parameter == null) {
+                            builder.append("did not match any listener parameters");
+                        } else {
+                            builder.append("matched listener parameter #")
+                                    .append(parameter.getListenerPosition() + 1)
+                                    .append(": ")
+                                    .append(parameter.getType());
+                        }
+                    }
+                    builder.append("\n\nMethods may have up to ")
+                            .append(method.parameters().length)
+                            .append(" parameter(s):\n");
+                    for (String parameterType : method.parameters()) {
+                        builder.append("\n  ").append(parameterType);
+                    }
+                    builder.append(
+                            "\n\nThese may be listed in any order but will be searched for from top to bottom.");
+                    error(executableElement, builder.toString());
+                    return;
+                }
+            }
+        }
+
+        MethodViewBinding binding = new MethodViewBinding(name, Arrays.asList(parameters), required);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        for (int id : ids) {
+            QualifiedId qualifiedId = elementToQualifiedId(element, id);
+            if (!builder.addMethod(getId(qualifiedId), listener, method, binding)) {
+                error(element, "Multiple listener methods with return value specified for ID %d. (%s.%s)",
+                        id, enclosingElement.getQualifiedName(), element.getSimpleName());
+                return;
+            }
+        }
+
+        // Add the type-erased version to the valid binding targets set.
+        erasedTargetNames.add(enclosingElement);
     }
 
-    if (hasError) {
-      return;
+    private boolean isInterface(TypeMirror typeMirror) {
+        return typeMirror instanceof DeclaredType
+                && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
     }
 
-    Parameter[] parameters = Parameter.NONE;
-    if (!methodParameters.isEmpty()) {
-      parameters = new Parameter[methodParameters.size()];
-      BitSet methodParameterUsed = new BitSet(methodParameters.size());
-      String[] parameterTypes = method.parameters();
-      for (int i = 0; i < methodParameters.size(); i++) {
-        VariableElement methodParameter = methodParameters.get(i);
-        TypeMirror methodParameterType = methodParameter.asType();
-        if (methodParameterType instanceof TypeVariable) {
-          TypeVariable typeVariable = (TypeVariable) methodParameterType;
-          methodParameterType = typeVariable.getUpperBound();
-        }
-
-        for (int j = 0; j < parameterTypes.length; j++) {
-          if (methodParameterUsed.get(j)) {
-            continue;
-          }
-          if ((isSubtypeOfType(methodParameterType, parameterTypes[j])
-                  && isSubtypeOfType(methodParameterType, VIEW_TYPE))
-              || isTypeEqual(methodParameterType, parameterTypes[j])
-              || isInterface(methodParameterType)) {
-            parameters[i] = new Parameter(j, TypeName.get(methodParameterType));
-            methodParameterUsed.set(j);
-            break;
-          }
-        }
-        if (parameters[i] == null) {
-          StringBuilder builder = new StringBuilder();
-          builder.append("Unable to match @")
-              .append(annotationClass.getSimpleName())
-              .append(" method arguments. (")
-              .append(enclosingElement.getQualifiedName())
-              .append('.')
-              .append(element.getSimpleName())
-              .append(')');
-          for (int j = 0; j < parameters.length; j++) {
-            Parameter parameter = parameters[j];
-            builder.append("\n\n  Parameter #")
-                .append(j + 1)
-                .append(": ")
-                .append(methodParameters.get(j).asType().toString())
-                .append("\n    ");
-            if (parameter == null) {
-              builder.append("did not match any listener parameters");
-            } else {
-              builder.append("matched listener parameter #")
-                  .append(parameter.getListenerPosition() + 1)
-                  .append(": ")
-                  .append(parameter.getType());
+    static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
+        if (isTypeEqual(typeMirror, otherType)) {
+            return true;
+        }
+        if (typeMirror.getKind() != TypeKind.DECLARED) {
+            return false;
+        }
+        DeclaredType declaredType = (DeclaredType) typeMirror;
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (typeArguments.size() > 0) {
+            StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
+            typeString.append('<');
+            for (int i = 0; i < typeArguments.size(); i++) {
+                if (i > 0) {
+                    typeString.append(',');
+                }
+                typeString.append('?');
             }
-          }
-          builder.append("\n\nMethods may have up to ")
-              .append(method.parameters().length)
-              .append(" parameter(s):\n");
-          for (String parameterType : method.parameters()) {
-            builder.append("\n  ").append(parameterType);
-          }
-          builder.append(
-              "\n\nThese may be listed in any order but will be searched for from top to bottom.");
-          error(executableElement, builder.toString());
-          return;
-        }
-      }
+            typeString.append('>');
+            if (typeString.toString().equals(otherType)) {
+                return true;
+            }
+        }
+        Element element = declaredType.asElement();
+        if (!(element instanceof TypeElement)) {
+            return false;
+        }
+        TypeElement typeElement = (TypeElement) element;
+        TypeMirror superType = typeElement.getSuperclass();
+        if (isSubtypeOfType(superType, otherType)) {
+            return true;
+        }
+        for (TypeMirror interfaceType : typeElement.getInterfaces()) {
+            if (isSubtypeOfType(interfaceType, otherType)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    MethodViewBinding binding = new MethodViewBinding(name, Arrays.asList(parameters), required);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    for (int id : ids) {
-      QualifiedId qualifiedId = elementToQualifiedId(element, id);
-      if (!builder.addMethod(getId(qualifiedId), listener, method, binding)) {
-        error(element, "Multiple listener methods with return value specified for ID %d. (%s.%s)",
-            id, enclosingElement.getQualifiedName(), element.getSimpleName());
-        return;
-      }
+    private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
+        return otherType.equals(typeMirror.toString());
     }
 
-    // Add the type-erased version to the valid binding targets set.
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private boolean isInterface(TypeMirror typeMirror) {
-    return typeMirror instanceof DeclaredType
-        && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
-  }
+    private BindingSet.Builder getOrCreateBindingBuilder(
+            Map<TypeElement, BindingSet.Builder> builderMap, TypeElement enclosingElement) {
+        BindingSet.Builder builder = builderMap.get(enclosingElement);
+        if (builder == null) {
+            builder = BindingSet.newBuilder(enclosingElement);
+            builderMap.put(enclosingElement, builder);
+        }
+        return builder;
+    }
+
+    /**
+     * Finds the parent binder type in the supplied set, if any.
+     */
+    private TypeElement findParentType(TypeElement typeElement, Set<TypeElement> parents) {
+        TypeMirror type;
+        while (true) {
+            type = typeElement.getSuperclass();
+            if (type.getKind() == TypeKind.NONE) {
+                return null;
+            }
+            typeElement = (TypeElement) ((DeclaredType) type).asElement();
+            if (parents.contains(typeElement)) {
+                return typeElement;
+            }
+        }
+    }
 
-  static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
-    if (isTypeEqual(typeMirror, otherType)) {
-      return true;
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+        return SourceVersion.latestSupported();
     }
-    if (typeMirror.getKind() != TypeKind.DECLARED) {
-      return false;
+
+    private void error(Element element, String message, Object... args) {
+        printMessage(Kind.ERROR, element, message, args);
     }
-    DeclaredType declaredType = (DeclaredType) typeMirror;
-    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-    if (typeArguments.size() > 0) {
-      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
-      typeString.append('<');
-      for (int i = 0; i < typeArguments.size(); i++) {
-        if (i > 0) {
-          typeString.append(',');
-        }
-        typeString.append('?');
-      }
-      typeString.append('>');
-      if (typeString.toString().equals(otherType)) {
-        return true;
-      }
+
+    private void note(Element element, String message, Object... args) {
+        printMessage(Kind.NOTE, element, message, args);
     }
-    Element element = declaredType.asElement();
-    if (!(element instanceof TypeElement)) {
-      return false;
+
+    private void printMessage(Kind kind, Element element, String message, Object[] args) {
+        if (args.length > 0) {
+            message = String.format(message, args);
+        }
+
+        processingEnv.getMessager().printMessage(kind, message, element);
     }
-    TypeElement typeElement = (TypeElement) element;
-    TypeMirror superType = typeElement.getSuperclass();
-    if (isSubtypeOfType(superType, otherType)) {
-      return true;
+
+    private static boolean hasAnnotationWithName(Element element, String simpleName) {
+        for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+            String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();
+            if (simpleName.equals(annotationName)) {
+                return true;
+            }
+        }
+        return false;
     }
-    for (TypeMirror interfaceType : typeElement.getInterfaces()) {
-      if (isSubtypeOfType(interfaceType, otherType)) {
-        return true;
-      }
+
+    private static boolean isFieldRequired(Element element) {
+        return !hasAnnotationWithName(element, NULLABLE_ANNOTATION_NAME);
     }
-    return false;
-  }
-
-  private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
-    return otherType.equals(typeMirror.toString());
-  }
-
-  private BindingSet.Builder getOrCreateBindingBuilder(
-      Map<TypeElement, BindingSet.Builder> builderMap, TypeElement enclosingElement) {
-    BindingSet.Builder builder = builderMap.get(enclosingElement);
-    if (builder == null) {
-      builder = BindingSet.newBuilder(enclosingElement);
-      builderMap.put(enclosingElement, builder);
+
+    private static boolean isListenerRequired(ExecutableElement element) {
+        return element.getAnnotation(Optional.class) == null;
     }
-    return builder;
-  }
-
-  /** Finds the parent binder type in the supplied set, if any. */
-  private TypeElement findParentType(TypeElement typeElement, Set<TypeElement> parents) {
-    TypeMirror type;
-    while (true) {
-      type = typeElement.getSuperclass();
-      if (type.getKind() == TypeKind.NONE) {
+
+    private static AnnotationMirror getMirror(Element element,
+                                              Class<? extends Annotation> annotation) {
+        for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
+            if (annotationMirror.getAnnotationType().toString().equals(annotation.getCanonicalName())) {
+                return annotationMirror;
+            }
+        }
         return null;
-      }
-      typeElement = (TypeElement) ((DeclaredType) type).asElement();
-      if (parents.contains(typeElement)) {
-        return typeElement;
-      }
     }
-  }
 
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
+    private Id getId(QualifiedId qualifiedId) {
+        if (symbols.get(qualifiedId) == null) {
+            symbols.put(qualifiedId, new Id(qualifiedId.id));
+        }
+        return symbols.get(qualifiedId);
+    }
 
-  private void error(Element element, String message, Object... args) {
-    printMessage(Kind.ERROR, element, message, args);
-  }
+    private void scanForRClasses(RoundEnvironment env) {
+        if (trees == null) return;
 
-  private void note(Element element, String message, Object... args) {
-    printMessage(Kind.NOTE, element, message, args);
-  }
+        RClassScanner scanner = new RClassScanner();
 
-  private void printMessage(Kind kind, Element element, String message, Object[] args) {
-    if (args.length > 0) {
-      message = String.format(message, args);
+        for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
+            for (Element element : env.getElementsAnnotatedWith(annotation)) {
+                JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
+                if (tree != null) { // tree can be null if the references are compiled types and not source
+                    scanner.setCurrentPackage(elementUtils.getPackageOf(element));
+                    tree.accept(scanner);
+                }
+            }
+        }
+
+        for (Map.Entry<PackageElement, Set<Symbol.ClassSymbol>> packageNameToRClassSet
+                : scanner.getRClasses().entrySet()) {
+            PackageElement respectivePackageName = packageNameToRClassSet.getKey();
+            for (Symbol.ClassSymbol rClass : packageNameToRClassSet.getValue()) {
+                parseRClass(respectivePackageName, rClass, scanner.getReferenced());
+            }
+        }
     }
 
-    processingEnv.getMessager().printMessage(kind, message, element);
-  }
+    private void parseRClass(PackageElement respectivePackageName, Symbol.ClassSymbol rClass,
+                             Set<String> referenced) {
+        TypeElement element;
 
-  private static boolean hasAnnotationWithName(Element element, String simpleName) {
-    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
-      String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();
-      if (simpleName.equals(annotationName)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private static boolean isFieldRequired(Element element) {
-    return !hasAnnotationWithName(element, NULLABLE_ANNOTATION_NAME);
-  }
-
-  private static boolean isListenerRequired(ExecutableElement element) {
-    return element.getAnnotation(Optional.class) == null;
-  }
-
-  private static AnnotationMirror getMirror(Element element,
-      Class<? extends Annotation> annotation) {
-    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
-      if (annotationMirror.getAnnotationType().toString().equals(annotation.getCanonicalName())) {
-        return annotationMirror;
-      }
+        try {
+            element = rClass;
+        } catch (MirroredTypeException mte) {
+            element = (TypeElement) typeUtils.asElement(mte.getTypeMirror());
+        }
+
+        JCTree tree = (JCTree) trees.getTree(element);
+        if (tree != null) { // tree can be null if the references are compiled types and not source
+            IdScanner idScanner =
+                    new IdScanner(symbols, elementUtils.getPackageOf(element), respectivePackageName,
+                            referenced);
+            tree.accept(idScanner);
+        } else {
+            parseCompiledR(respectivePackageName, element, referenced);
+        }
     }
-    return null;
-  }
 
-  private Id getId(QualifiedId qualifiedId) {
-    if (symbols.get(qualifiedId) == null) {
-      symbols.put(qualifiedId, new Id(qualifiedId.id));
+    private void parseCompiledR(PackageElement respectivePackageName, TypeElement rClass,
+                                Set<String> referenced) {
+        for (Element element : rClass.getEnclosedElements()) {
+            String innerClassName = element.getSimpleName().toString();
+            if (SUPPORTED_TYPES.contains(innerClassName)) {
+                for (Element enclosedElement : element.getEnclosedElements()) {
+                    if (enclosedElement instanceof VariableElement) {
+                        String fqName = elementUtils.getPackageOf(enclosedElement).getQualifiedName().toString()
+                                + ".R."
+                                + innerClassName
+                                + "."
+                                + enclosedElement.toString();
+                        if (referenced.contains(fqName)) {
+                            VariableElement variableElement = (VariableElement) enclosedElement;
+                            Object value = variableElement.getConstantValue();
+
+                            if (value instanceof Integer) {
+                                int id = (Integer) value;
+                                ClassName rClassName =
+                                        ClassName.get(elementUtils.getPackageOf(variableElement).toString(), "R",
+                                                innerClassName);
+                                String resourceName = variableElement.getSimpleName().toString();
+                                QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
+                                symbols.put(qualifiedId, new Id(id, rClassName, resourceName));
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
-    return symbols.get(qualifiedId);
-  }
 
-  private void scanForRClasses(RoundEnvironment env) {
-    if (trees == null) return;
+    private static class RClassScanner extends TreeScanner {
+        // Maps the currently evaluated rPackageName to R Classes
+        private final Map<PackageElement, Set<Symbol.ClassSymbol>> rClasses = new LinkedHashMap<>();
+        private PackageElement currentPackage;
+        private Set<String> referenced = new HashSet<>();
+
+        @Override
+        public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
+            Symbol symbol = jcFieldAccess.sym;
+            if (symbol != null
+                    && symbol.getEnclosingElement() != null
+                    && symbol.getEnclosingElement().getEnclosingElement() != null
+                    && symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
+                Set<Symbol.ClassSymbol> rClassSet = rClasses.get(currentPackage);
+                if (rClassSet == null) {
+                    rClassSet = new HashSet<>();
+                    rClasses.put(currentPackage, rClassSet);
+                }
+                referenced.add(getFqName(symbol));
+                rClassSet.add(symbol.getEnclosingElement().getEnclosingElement().enclClass());
+            }
+        }
 
-    RClassScanner scanner = new RClassScanner();
+        Map<PackageElement, Set<Symbol.ClassSymbol>> getRClasses() {
+            return rClasses;
+        }
 
-    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
-      for (Element element : env.getElementsAnnotatedWith(annotation)) {
-        JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
-        if (tree != null) { // tree can be null if the references are compiled types and not source
-          scanner.setCurrentPackage(elementUtils.getPackageOf(element));
-          tree.accept(scanner);
+        Set<String> getReferenced() {
+            return referenced;
         }
-      }
-    }
 
-    for (Map.Entry<PackageElement, Set<Symbol.ClassSymbol>> packageNameToRClassSet
-          : scanner.getRClasses().entrySet()) {
-      PackageElement respectivePackageName = packageNameToRClassSet.getKey();
-      for (Symbol.ClassSymbol rClass : packageNameToRClassSet.getValue()) {
-        parseRClass(respectivePackageName, rClass, scanner.getReferenced());
-      }
+        void setCurrentPackage(PackageElement packageElement) {
+            this.currentPackage = packageElement;
+        }
     }
-  }
 
-  private void parseRClass(PackageElement respectivePackageName, Symbol.ClassSymbol rClass,
-      Set<String> referenced) {
-    TypeElement element;
+    private static class IdScanner extends TreeScanner {
+        private final Map<QualifiedId, Id> ids;
+        private final PackageElement rPackageName;
+        private final PackageElement respectivePackageName;
+        private final Set<String> referenced;
 
-    try {
-      element = rClass;
-    } catch (MirroredTypeException mte) {
-      element = (TypeElement) typeUtils.asElement(mte.getTypeMirror());
-    }
+        IdScanner(Map<QualifiedId, Id> ids, PackageElement rPackageName,
+                  PackageElement respectivePackageName, Set<String> referenced) {
+            this.ids = ids;
+            this.rPackageName = rPackageName;
+            this.respectivePackageName = respectivePackageName;
+            this.referenced = referenced;
+        }
 
-    JCTree tree = (JCTree) trees.getTree(element);
-    if (tree != null) { // tree can be null if the references are compiled types and not source
-      IdScanner idScanner =
-          new IdScanner(symbols, elementUtils.getPackageOf(element), respectivePackageName,
-              referenced);
-      tree.accept(idScanner);
-    } else {
-      parseCompiledR(respectivePackageName, element, referenced);
-    }
-  }
-
-  private void parseCompiledR(PackageElement respectivePackageName, TypeElement rClass,
-      Set<String> referenced) {
-    for (Element element : rClass.getEnclosedElements()) {
-      String innerClassName = element.getSimpleName().toString();
-      if (SUPPORTED_TYPES.contains(innerClassName)) {
-        for (Element enclosedElement : element.getEnclosedElements()) {
-          if (enclosedElement instanceof VariableElement) {
-            String fqName = elementUtils.getPackageOf(enclosedElement).getQualifiedName().toString()
-                + ".R."
-                + innerClassName
-                + "."
-                + enclosedElement.toString();
-            if (referenced.contains(fqName)) {
-              VariableElement variableElement = (VariableElement) enclosedElement;
-              Object value = variableElement.getConstantValue();
-
-              if (value instanceof Integer) {
-                int id = (Integer) value;
-                ClassName rClassName =
-                    ClassName.get(elementUtils.getPackageOf(variableElement).toString(), "R",
-                        innerClassName);
-                String resourceName = variableElement.getSimpleName().toString();
-                QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
-                symbols.put(qualifiedId, new Id(id, rClassName, resourceName));
-              }
+        @Override
+        public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
+            for (JCTree tree : jcClassDecl.defs) {
+                if (tree instanceof ClassTree) {
+                    ClassTree classTree = (ClassTree) tree;
+                    String className = classTree.getSimpleName().toString();
+                    if (SUPPORTED_TYPES.contains(className)) {
+                        ClassName rClassName = ClassName.get(rPackageName.getQualifiedName().toString(), "R",
+                                className);
+                        VarScanner scanner = new VarScanner(ids, rClassName, respectivePackageName, referenced);
+                        ((JCTree) classTree).accept(scanner);
+                    }
+                }
             }
-          }
         }
-      }
-    }
-  }
-
-  private static class RClassScanner extends TreeScanner {
-    // Maps the currently evaluated rPackageName to R Classes
-    private final Map<PackageElement, Set<Symbol.ClassSymbol>> rClasses = new LinkedHashMap<>();
-    private PackageElement currentPackage;
-    private Set<String> referenced = new HashSet<>();
-
-    @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
-      Symbol symbol = jcFieldAccess.sym;
-      if (symbol != null
-          && symbol.getEnclosingElement() != null
-          && symbol.getEnclosingElement().getEnclosingElement() != null
-          && symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
-        Set<Symbol.ClassSymbol> rClassSet = rClasses.get(currentPackage);
-        if (rClassSet == null) {
-          rClassSet = new HashSet<>();
-          rClasses.put(currentPackage, rClassSet);
-        }
-        referenced.add(getFqName(symbol));
-        rClassSet.add(symbol.getEnclosingElement().getEnclosingElement().enclClass());
-      }
     }
 
-    Map<PackageElement, Set<Symbol.ClassSymbol>> getRClasses() {
-      return rClasses;
-    }
+    private static class VarScanner extends TreeScanner {
+        private final Map<QualifiedId, Id> ids;
+        private final ClassName className;
+        private final PackageElement respectivePackageName;
+        private final Set<String> referenced;
 
-    Set<String> getReferenced() {
-      return referenced;
-    }
-
-    void setCurrentPackage(PackageElement packageElement) {
-      this.currentPackage = packageElement;
-    }
-  }
-
-  private static class IdScanner extends TreeScanner {
-    private final Map<QualifiedId, Id> ids;
-    private final PackageElement rPackageName;
-    private final PackageElement respectivePackageName;
-    private final Set<String> referenced;
-
-    IdScanner(Map<QualifiedId, Id> ids, PackageElement rPackageName,
-        PackageElement respectivePackageName, Set<String> referenced) {
-      this.ids = ids;
-      this.rPackageName = rPackageName;
-      this.respectivePackageName = respectivePackageName;
-      this.referenced = referenced;
-    }
+        private VarScanner(Map<QualifiedId, Id> ids, ClassName className,
+                           PackageElement respectivePackageName, Set<String> referenced) {
+            this.ids = ids;
+            this.className = className;
+            this.respectivePackageName = respectivePackageName;
+            this.referenced = referenced;
+        }
 
-    @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
-      for (JCTree tree : jcClassDecl.defs) {
-        if (tree instanceof ClassTree) {
-          ClassTree classTree = (ClassTree) tree;
-          String className = classTree.getSimpleName().toString();
-          if (SUPPORTED_TYPES.contains(className)) {
-            ClassName rClassName = ClassName.get(rPackageName.getQualifiedName().toString(), "R",
-                    className);
-            VarScanner scanner = new VarScanner(ids, rClassName, respectivePackageName, referenced);
-            ((JCTree) classTree).accept(scanner);
-          }
-        }
-      }
-    }
-  }
-
-  private static class VarScanner extends TreeScanner {
-    private final Map<QualifiedId, Id> ids;
-    private final ClassName className;
-    private final PackageElement respectivePackageName;
-    private final Set<String> referenced;
-
-    private VarScanner(Map<QualifiedId, Id> ids, ClassName className,
-        PackageElement respectivePackageName, Set<String> referenced) {
-      this.ids = ids;
-      this.className = className;
-      this.respectivePackageName = respectivePackageName;
-      this.referenced = referenced;
+        @Override
+        public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
+            if ("int".equals(jcVariableDecl.getType().toString())) {
+                String resourceName = jcVariableDecl.getName().toString();
+                if (referenced.contains(getFqName(jcVariableDecl.sym))) {
+                    int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
+                    QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
+                    ids.put(qualifiedId, new Id(id, className, resourceName));
+                }
+            }
+        }
     }
 
-    @Override public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
-      if ("int".equals(jcVariableDecl.getType().toString())) {
-        String resourceName = jcVariableDecl.getName().toString();
-        if (referenced.contains(getFqName(jcVariableDecl.sym))) {
-          int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
-          QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
-          ids.put(qualifiedId, new Id(id, className, resourceName));
-        }
-      }
+    private static String getFqName(Symbol rSymbol) {
+        return rSymbol.packge().getQualifiedName().toString()
+                + ".R."
+                + rSymbol.enclClass().name.toString()
+                + "."
+                + rSymbol.name.toString();
     }
-  }
-
-  private static String getFqName(Symbol rSymbol) {
-    return rSymbol.packge().getQualifiedName().toString()
-        + ".R."
-        + rSymbol.enclClass().name.toString()
-        + "."
-        + rSymbol.name.toString();
-  }
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/QualifiedId.java b/butterknife-compiler/src/main/java/butterknife/compiler/QualifiedId.java
index 1d8683e4..3b3427a5 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/QualifiedId.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/QualifiedId.java
@@ -3,29 +3,32 @@
 import javax.lang.model.element.PackageElement;
 
 final class QualifiedId {
-  final PackageElement packageName;
-  final int id;
+    final PackageElement packageName;
+    final int id;
 
-  QualifiedId(PackageElement packageName, int id) {
-    this.packageName = packageName;
-    this.id = id;
-  }
+    QualifiedId(PackageElement packageName, int id) {
+        this.packageName = packageName;
+        this.id = id;
+    }
 
-  @Override public String toString() {
-    return "QualifiedId{packageName='" + packageName + "', id=" + id + '}';
-  }
+    @Override
+    public String toString() {
+        return "QualifiedId{packageName='" + packageName + "', id=" + id + '}';
+    }
 
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof QualifiedId)) return false;
-    QualifiedId other = (QualifiedId) o;
-    return id == other.id
-        && packageName.equals(other.packageName);
-  }
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof QualifiedId)) return false;
+        QualifiedId other = (QualifiedId) o;
+        return id == other.id
+                && packageName.equals(other.packageName);
+    }
 
-  @Override public int hashCode() {
-    int result = packageName.hashCode();
-    result = 31 * result + id;
-    return result;
-  }
+    @Override
+    public int hashCode() {
+        int result = packageName.hashCode();
+        result = 31 * result + id;
+        return result;
+    }
 }
diff --git a/butterknife/src/main/java/butterknife/ButterKnife.java b/butterknife/src/main/java/butterknife/ButterKnife.java
index e4090708..eea8bf0d 100644
--- a/butterknife/src/main/java/butterknife/ButterKnife.java
+++ b/butterknife/src/main/java/butterknife/ButterKnife.java
@@ -13,6 +13,7 @@
 import android.util.Log;
 import android.util.Property;
 import android.view.View;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.LinkedHashMap;
@@ -82,276 +83,330 @@
  * </code></pre>
  */
 public final class ButterKnife {
-  private ButterKnife() {
-    throw new AssertionError("No instances.");
-  }
+    private ButterKnife() {
+        throw new AssertionError("No instances.");
+    }
+
+    /**
+     * An action that can be applied to a list of views.
+     */
+    public interface Action<T extends View> {
+        /**
+         * Apply the action on the {@code view} which is at {@code index} in the list.
+         */
+        @UiThread
+        void apply(@NonNull T view, int index);
+    }
+
+    /**
+     * A setter that can apply a value to a list of views.
+     */
+    public interface Setter<T extends View, V> {
+        /**
+         * Set the {@code value} on the {@code view} which is at {@code index} in the list.
+         */
+        @UiThread
+        void set(@NonNull T view, V value, int index);
+    }
+
+    private static final String TAG = "ButterKnife";
+    private static boolean debug = false;
 
-  /** An action that can be applied to a list of views. */
-  public interface Action<T extends View> {
-    /** Apply the action on the {@code view} which is at {@code index} in the list. */
+    @VisibleForTesting
+    static final Map<Class<?>, Constructor<? extends Unbinder>> BINDINGS = new LinkedHashMap<>();
+
+    /**
+     * Control whether debug logging is enabled.
+     */
+    public static void setDebug(boolean debug) {
+        ButterKnife.debug = debug;
+    }
+
+    /**
+     * BindView annotated fields and methods in the specified {@link Activity}. The current content
+     * view is used as the view root.
+     *
+     * @param target Target activity for view binding.
+     */
+    @NonNull
     @UiThread
-    void apply(@NonNull T view, int index);
-  }
+    public static Unbinder bind(@NonNull Activity target) {
+        View sourceView = target.getWindow().getDecorView();
+        return createBinding(target, sourceView);
+    }
 
-  /** A setter that can apply a value to a list of views. */
-  public interface Setter<T extends View, V> {
-    /** Set the {@code value} on the {@code view} which is at {@code index} in the list. */
+    /**
+     * BindView annotated fields and methods in the specified {@link View}. The view and its children
+     * are used as the view root.
+     *
+     * @param target Target view for view binding.
+     */
+    @NonNull
     @UiThread
-    void set(@NonNull T view, V value, int index);
-  }
-
-  private static final String TAG = "ButterKnife";
-  private static boolean debug = false;
-
-  @VisibleForTesting
-  static final Map<Class<?>, Constructor<? extends Unbinder>> BINDINGS = new LinkedHashMap<>();
-
-  /** Control whether debug logging is enabled. */
-  public static void setDebug(boolean debug) {
-    ButterKnife.debug = debug;
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@link Activity}. The current content
-   * view is used as the view root.
-   *
-   * @param target Target activity for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Activity target) {
-    View sourceView = target.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@link View}. The view and its children
-   * are used as the view root.
-   *
-   * @param target Target view for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull View target) {
-    return createBinding(target, target);
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@link Dialog}. The current content
-   * view is used as the view root.
-   *
-   * @param target Target dialog for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Dialog target) {
-    View sourceView = target.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link Activity} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source Activity on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
-    View sourceView = source.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link View} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source View root on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull View source) {
-    return createBinding(target, source);
-  }
-
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link Dialog} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source Dialog on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
-    View sourceView = source.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
-
-  private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
-    Class<?> targetClass = target.getClass();
-    if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName());
-    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);
-
-    if (constructor == null) {
-      return Unbinder.EMPTY;
+    public static Unbinder bind(@NonNull View target) {
+        return createBinding(target, target);
     }
 
-    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
-    try {
-      return constructor.newInstance(target, source);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException("Unable to invoke " + constructor, e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Unable to invoke " + constructor, e);
-    } catch (InvocationTargetException e) {
-      Throwable cause = e.getCause();
-      if (cause instanceof RuntimeException) {
-        throw (RuntimeException) cause;
-      }
-      if (cause instanceof Error) {
-        throw (Error) cause;
-      }
-      throw new RuntimeException("Unable to create binding instance.", cause);
+    /**
+     * BindView annotated fields and methods in the specified {@link Dialog}. The current content
+     * view is used as the view root.
+     *
+     * @param target Target dialog for view binding.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Dialog target) {
+        View sourceView = target.getWindow().getDecorView();
+        return createBinding(target, sourceView);
     }
-  }
-
-  @Nullable @CheckResult @UiThread
-  private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
-    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
-    if (bindingCtor != null) {
-      if (debug) Log.d(TAG, "HIT: Cached in binding map.");
-      return bindingCtor;
+
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link Activity} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source Activity on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
+        View sourceView = source.getWindow().getDecorView();
+        return createBinding(target, sourceView);
     }
-    String clsName = cls.getName();
-    if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
-      if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
-      return null;
+
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link View} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source View root on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull View source) {
+        return createBinding(target, source);
     }
-    try {
-      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");
-      //noinspection unchecked
-      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
-      if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
-    } catch (ClassNotFoundException e) {
-      if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
-      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
+
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link Dialog} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source Dialog on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
+        View sourceView = source.getWindow().getDecorView();
+        return createBinding(target, sourceView);
     }
-    BINDINGS.put(cls, bindingCtor);
-    return bindingCtor;
-  }
-
-  /** Apply the specified {@code actions} across the {@code list} of views. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull List<T> list,
-      @NonNull Action<? super T>... actions) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      for (Action<? super T> action : actions) {
-        action.apply(list.get(i), i);
-      }
+
+    private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
+        Class<?> targetClass = target.getClass();
+        if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName());
+
+        //找出绑定类如MainActivity_ViewBinding 的构造方法
+        Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);
+
+        //什么情况下会出现空的情况呢？只调用 ButterKnife.bind() 方法时，
+        // 比如在 MainActivity 的 onCreate 回调里
+        // findBindingConstructorForClass 就会找不到相应的 _ViewBinding 类
+        //然后出发相应的条件返回 null
+        if (constructor == null) {
+            return Unbinder.EMPTY;
+        }
+
+        //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
+        try {
+            //利用反射生成 _ViewBinging 实例，向上转型为 Unbinder
+            return constructor.newInstance(target, source);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Unable to invoke " + constructor, e);
+        } catch (InstantiationException e) {
+            throw new RuntimeException("Unable to invoke " + constructor, e);
+        } catch (InvocationTargetException e) {
+            Throwable cause = e.getCause();
+            if (cause instanceof RuntimeException) {
+                throw (RuntimeException) cause;
+            }
+            if (cause instanceof Error) {
+                throw (Error) cause;
+            }
+            throw new RuntimeException("Unable to create binding instance.", cause);
+        }
     }
-  }
-
-  /** Apply the specified {@code actions} across the {@code array} of views. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull T[] array,
-      @NonNull Action<? super T>... actions) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      for (Action<? super T> action : actions) {
-        action.apply(array[i], i);
-      }
+
+    @Nullable
+    @CheckResult
+    @UiThread
+    private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
+        Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
+        //如果缓存不为空
+        if (bindingCtor != null) {
+            if (debug) Log.d(TAG, "HIT: Cached in binding map.");
+            return bindingCtor;
+        }
+        String clsName = cls.getName();
+
+        //如果找到 java 类或者 android 的类 就返回null
+        if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
+            if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
+            return null;
+        }
+        try {
+            Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");
+            //noinspection unchecked
+            bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
+            if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
+        } catch (ClassNotFoundException e) {
+            //没有实现相应@Bind 注解 就不会产生 _ViewBind类
+            if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
+            //递归查询父类
+            bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
+        }
+        //保存到缓存中
+        BINDINGS.put(cls, bindingCtor);
+        return bindingCtor;
     }
-  }
-
-  /** Apply the specified {@code action} across the {@code list} of views. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull List<T> list,
-      @NonNull Action<? super T> action) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      action.apply(list.get(i), i);
+
+    /**
+     * Apply the specified {@code actions} across the {@code list} of views.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull List<T> list,
+                                              @NonNull Action<? super T>... actions) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            for (Action<? super T> action : actions) {
+                action.apply(list.get(i), i);
+            }
+        }
     }
-  }
 
-  /** Apply the specified {@code action} across the {@code array} of views. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull T[] array, @NonNull Action<? super T> action) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      action.apply(array[i], i);
+    /**
+     * Apply the specified {@code actions} across the {@code array} of views.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull T[] array,
+                                              @NonNull Action<? super T>... actions) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            for (Action<? super T> action : actions) {
+                action.apply(array[i], i);
+            }
+        }
+    }
+
+    /**
+     * Apply the specified {@code action} across the {@code list} of views.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull List<T> list,
+                                              @NonNull Action<? super T> action) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            action.apply(list.get(i), i);
+        }
+    }
+
+    /**
+     * Apply the specified {@code action} across the {@code array} of views.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull T[] array, @NonNull Action<? super T> action) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            action.apply(array[i], i);
+        }
+    }
+
+    /**
+     * Apply {@code actions} to {@code view}.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull T view,
+                                              @NonNull Action<? super T>... actions) {
+        for (Action<? super T> action : actions) {
+            action.apply(view, 0);
+        }
+    }
+
+    /**
+     * Apply {@code action} to {@code view}.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull T view, @NonNull Action<? super T> action) {
+        action.apply(view, 0);
     }
-  }
-
-  /** Apply {@code actions} to {@code view}. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull T view,
-      @NonNull Action<? super T>... actions) {
-    for (Action<? super T> action : actions) {
-      action.apply(view, 0);
+
+    /**
+     * Set the {@code value} using the specified {@code setter} across the {@code list} of views.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull List<T> list,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            setter.set(list.get(i), value, i);
+        }
     }
-  }
-
-  /** Apply {@code action} to {@code view}. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull T view, @NonNull Action<? super T> action) {
-    action.apply(view, 0);
-  }
-
-  /** Set the {@code value} using the specified {@code setter} across the {@code list} of views. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull List<T> list,
-      @NonNull Setter<? super T, V> setter, V value) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value, i);
+
+    /**
+     * Set the {@code value} using the specified {@code setter} across the {@code array} of views.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T[] array,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            setter.set(array[i], value, i);
+        }
     }
-  }
-
-  /** Set the {@code value} using the specified {@code setter} across the {@code array} of views. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T[] array,
-      @NonNull Setter<? super T, V> setter, V value) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      setter.set(array[i], value, i);
+
+    /**
+     * Set {@code value} on {@code view} using {@code setter}.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T view,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        setter.set(view, value, 0);
     }
-  }
-
-  /** Set {@code value} on {@code view} using {@code setter}. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T view,
-      @NonNull Setter<? super T, V> setter, V value) {
-    setter.set(view, value, 0);
-  }
-
-  /**
-   * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
-   */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull List<T> list,
-      @NonNull Property<? super T, V> setter, V value) {
-    //noinspection ForLoopReplaceableByForEach
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value);
+
+    /**
+     * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull List<T> list,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0, count = list.size(); i < count; i++) {
+            setter.set(list.get(i), value);
+        }
+    }
+
+    /**
+     * Apply the specified {@code value} across the {@code array} of views using the {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T[] array,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0, count = array.length; i < count; i++) {
+            setter.set(array[i], value);
+        }
     }
-  }
-
-  /**
-   * Apply the specified {@code value} across the {@code array} of views using the {@code property}.
-   */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T[] array,
-      @NonNull Property<? super T, V> setter, V value) {
-    //noinspection ForLoopReplaceableByForEach
-    for (int i = 0, count = array.length; i < count; i++) {
-      setter.set(array[i], value);
+
+    /**
+     * Apply {@code value} to {@code view} using {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T view,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        setter.set(view, value);
     }
-  }
-
-  /** Apply {@code value} to {@code view} using {@code property}. */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T view,
-      @NonNull Property<? super T, V> setter, V value) {
-    setter.set(view, value);
-  }
 }
diff --git a/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java b/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
index f936ff6f..cc47c36e 100644
--- a/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
+++ b/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
@@ -7,21 +7,50 @@
  * same frame. A click on one button disables all buttons for that frame.
  */
 public abstract class DebouncingOnClickListener implements View.OnClickListener {
-  static boolean enabled = true;
+    static boolean enabled = true;
+
+    private static final Runnable ENABLE_AGAIN = new Runnable() {
+        @Override
+        public void run() {
+            enabled = true;
+        }
+    };
 
-  private static final Runnable ENABLE_AGAIN = new Runnable() {
-    @Override public void run() {
-      enabled = true;
-    }
-  };
 
-  @Override public final void onClick(View v) {
-    if (enabled) {
-      enabled = false;
-      v.post(ENABLE_AGAIN);
-      doClick(v);
+    /**
+     * Runnable 并不一定是新开一个线程，比如下面的调用方法是运行在UI线程中的
+     *
+     * Handler mHanlder = new Handler();
+     * mHandler.post(new Runnable(){
+     *     @Override
+     *     public void run(){
+     *
+     *     }
+     * })
+     *我们可以通过调用 handle 的 post 方法，把 Runnable
+     * 对象（一般是Runnable 的子类）传过去；
+     * handler 会在 looper 中调用这个 Runnable 的 Run 方法执行
+     *
+     * Runnable 是一个接口，不是一个线程，一般线程会实现 Runnable。所以如果我们使用匿名
+     * 内部类是运行在 UI 线程的，如果我们使用实现这个 Runnable 接口的线程类，则是运行在对应
+     * 线程的
+     *
+     *
+     * View.post（Runnable）方法的原理。在 post（Runnable）方法里，View获取当前线程（即UI线程）的
+     * Handler，然后将 action对象 post 到 Handler里。在Handler 里，它将传递过来的 action对象包装
+     * 成一个 Message（Message 的 callback 为 action），然后将其投入 UI 线程的消息循环中。
+     * 在 Handle 再次处理该 Message 时，有一条分支（为解释的那条）就是它所设，直接调用 runnable 的
+     * run 方法。而此时，已经路由到 UI 线程里，因此，我们可以毫无顾忌的来更新 UI
+     * @param v
+     */
+    @Override
+    public final void onClick(View v) {
+        if (enabled) {
+            enabled = false;
+            v.post(ENABLE_AGAIN);
+            doClick(v);
+        }
     }
-  }
 
-  public abstract void doClick(View v);
+    public abstract void doClick(View v);
 }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 99340b4a..13372aef 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d2..76526385 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
+#Mon Dec 18 16:57:16 CST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
