diff --git a/butterknife-annotations/src/main/java/butterknife/BindView.java b/butterknife-annotations/src/main/java/butterknife/BindView.java
index 4770bf69..2a8146ba 100644
--- a/butterknife-annotations/src/main/java/butterknife/BindView.java
+++ b/butterknife-annotations/src/main/java/butterknife/BindView.java
@@ -1,6 +1,7 @@
 package butterknife;
 
 import android.support.annotation.IdRes;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
@@ -14,8 +15,11 @@
  * {@literal @}BindView(R.id.title) TextView title;
  * </code></pre>
  */
-@Retention(CLASS) @Target(FIELD)
+@Retention(CLASS)
+@Target(FIELD)
 public @interface BindView {
-  /** View ID to which the field will be bound. */
-  @IdRes int value();
+    /**
+     * View ID to which the field will be bound.
+     */
+    @IdRes int value();
 }
diff --git a/butterknife-compiler/build.gradle b/butterknife-compiler/build.gradle
index 5775e644..3553ef39 100644
--- a/butterknife-compiler/build.gradle
+++ b/butterknife-compiler/build.gradle
@@ -5,22 +5,22 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  implementation project(':butterknife-annotations')
-  implementation deps.auto.common
-  implementation deps.guava
-  api deps.javapoet
-  compileOnly deps.auto.service
-  compileOnly files(org.gradle.internal.jvm.Jvm.current().getToolsJar())
+    implementation project(':butterknife-annotations')
+    implementation deps.auto.common
+    implementation deps.guava
+    api deps.javapoet
+    compileOnly deps.auto.service
+    compileOnly files(org.gradle.internal.jvm.Jvm.current().getToolsJar())
 
-  testImplementation deps.junit
-  testImplementation deps.truth
+    testImplementation deps.junit
+    testImplementation deps.truth
 }
 
 checkstyle {
-  configFile rootProject.file('checkstyle.xml')
-  showViolations true
-  //Remove this when tests are less verbose, i.e. using JavaPoet
-  sourceSets = [sourceSets.main]
+    configFile rootProject.file('checkstyle.xml')
+    showViolations true
+    //Remove this when tests are less verbose, i.e. using JavaPoet
+    sourceSets = [sourceSets.main]
 }
 
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
index b20aff4a..3f036af9 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
@@ -3,6 +3,7 @@
 import butterknife.OnTouch;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
+
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
@@ -13,6 +14,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.WildcardTypeName;
+
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -22,6 +24,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -36,745 +39,772 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-/** A set of all the bindings requested by a single type. */
+/**
+ * A set of all the bindings requested by a single type.
+ */
 final class BindingSet {
-  static final ClassName UTILS = ClassName.get("butterknife.internal", "Utils");
-  private static final ClassName VIEW = ClassName.get("android.view", "View");
-  private static final ClassName CONTEXT = ClassName.get("android.content", "Context");
-  private static final ClassName RESOURCES = ClassName.get("android.content.res", "Resources");
-  private static final ClassName UI_THREAD =
-      ClassName.get("android.support.annotation", "UiThread");
-  private static final ClassName CALL_SUPER =
-      ClassName.get("android.support.annotation", "CallSuper");
-  private static final ClassName SUPPRESS_LINT =
-      ClassName.get("android.annotation", "SuppressLint");
-  private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");
-  static final ClassName BITMAP_FACTORY = ClassName.get("android.graphics", "BitmapFactory");
-  static final ClassName CONTEXT_COMPAT =
-      ClassName.get("android.support.v4.content", "ContextCompat");
-  static final ClassName ANIMATION_UTILS =
-          ClassName.get("android.view.animation", "AnimationUtils");
-
-  private final TypeName targetTypeName;
-  private final ClassName bindingClassName;
-  private final boolean isFinal;
-  private final boolean isView;
-  private final boolean isActivity;
-  private final boolean isDialog;
-  private final ImmutableList<ViewBinding> viewBindings;
-  private final ImmutableList<FieldCollectionViewBinding> collectionBindings;
-  private final ImmutableList<ResourceBinding> resourceBindings;
-  private final BindingSet parentBinding;
-
-  private BindingSet(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
-      boolean isView, boolean isActivity, boolean isDialog, ImmutableList<ViewBinding> viewBindings,
-      ImmutableList<FieldCollectionViewBinding> collectionBindings,
-      ImmutableList<ResourceBinding> resourceBindings, BindingSet parentBinding) {
-    this.isFinal = isFinal;
-    this.targetTypeName = targetTypeName;
-    this.bindingClassName = bindingClassName;
-    this.isView = isView;
-    this.isActivity = isActivity;
-    this.isDialog = isDialog;
-    this.viewBindings = viewBindings;
-    this.collectionBindings = collectionBindings;
-    this.resourceBindings = resourceBindings;
-    this.parentBinding = parentBinding;
-  }
-
-  JavaFile brewJava(int sdk, boolean debuggable) {
-    return JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable))
-        .addFileComment("Generated code from Butter Knife. Do not modify!")
-        .build();
-  }
-
-  private TypeSpec createType(int sdk, boolean debuggable) {
-    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
-        .addModifiers(PUBLIC);
-    if (isFinal) {
-      result.addModifiers(FINAL);
-    }
+    static final ClassName UTILS = ClassName.get("butterknife.internal", "Utils");
+    private static final ClassName VIEW = ClassName.get("android.view", "View");
+    private static final ClassName CONTEXT = ClassName.get("android.content", "Context");
+    private static final ClassName RESOURCES = ClassName.get("android.content.res", "Resources");
+    private static final ClassName UI_THREAD =
+            ClassName.get("android.support.annotation", "UiThread");
+    private static final ClassName CALL_SUPER =
+            ClassName.get("android.support.annotation", "CallSuper");
+    private static final ClassName SUPPRESS_LINT =
+            ClassName.get("android.annotation", "SuppressLint");
+    private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");
+    static final ClassName BITMAP_FACTORY = ClassName.get("android.graphics", "BitmapFactory");
+    static final ClassName CONTEXT_COMPAT =
+            ClassName.get("android.support.v4.content", "ContextCompat");
+    static final ClassName ANIMATION_UTILS =
+            ClassName.get("android.view.animation", "AnimationUtils");
 
-    if (parentBinding != null) {
-      result.superclass(parentBinding.bindingClassName);
-    } else {
-      result.addSuperinterface(UNBINDER);
-    }
+    private final TypeName targetTypeName;
+    private final ClassName bindingClassName;
+    private final boolean isFinal;
+    private final boolean isView;
+    private final boolean isActivity;
+    private final boolean isDialog;
+    private final ImmutableList<ViewBinding> viewBindings;
+    private final ImmutableList<FieldCollectionViewBinding> collectionBindings;
+    private final ImmutableList<ResourceBinding> resourceBindings;
+    private final BindingSet parentBinding;
+
+    private BindingSet(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+                       boolean isView, boolean isActivity, boolean isDialog, ImmutableList<ViewBinding> viewBindings,
+                       ImmutableList<FieldCollectionViewBinding> collectionBindings,
+                       ImmutableList<ResourceBinding> resourceBindings, BindingSet parentBinding) {
+        this.isFinal = isFinal;
+        this.targetTypeName = targetTypeName;
+        this.bindingClassName = bindingClassName;
+        this.isView = isView;
+        this.isActivity = isActivity;
+        this.isDialog = isDialog;
+        this.viewBindings = viewBindings;
+        this.collectionBindings = collectionBindings;
+        this.resourceBindings = resourceBindings;
+        this.parentBinding = parentBinding;
+    }
+
+    JavaFile brewJava(int sdk, boolean debuggable) {
+        return JavaFile.builder(bindingClassName.packageName(), createType(sdk, debuggable))
+                .addFileComment("Generated code from Butter Knife. Do not modify!")
+                .build();
+    }
+
+    /**
+     * @param sdk
+     * @param debuggable
+     * @return TypeSpec 表示一个类、接口、或者枚举声明，可以用来构造一个 JavaFile
+     *          TypeSpec 与注解中的 Type 相对应
+     */
+    private TypeSpec createType(int sdk, boolean debuggable) {
+        TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
+                .addModifiers(PUBLIC);
+        if (isFinal) {
+            result.addModifiers(FINAL);
+        }
 
-    if (hasTargetField()) {
-      result.addField(targetTypeName, "target", PRIVATE);
-    }
+        // parentBinding 如果有父类，就继承该类，否则实现 UNBINDER 接口，用来解绑
+        if (parentBinding != null) {
+            result.superclass(parentBinding.bindingClassName);
+        } else {
+            result.addSuperinterface(UNBINDER);
+        }
 
-    if (isView) {
-      result.addMethod(createBindingConstructorForView());
-    } else if (isActivity) {
-      result.addMethod(createBindingConstructorForActivity());
-    } else if (isDialog) {
-      result.addMethod(createBindingConstructorForDialog());
-    }
-    if (!constructorNeedsView()) {
-      // Add a delegating constructor with a target type + view signature for reflective use.
-      result.addMethod(createBindingViewDelegateConstructor());
-    }
-    result.addMethod(createBindingConstructor(sdk, debuggable));
+        if (hasTargetField()) {
+            result.addField(targetTypeName, "target", PRIVATE);
+        }
 
-    if (hasViewBindings() || parentBinding == null) {
-      result.addMethod(createBindingUnbindMethod(result));
-    }
+        if (isView) {
+            result.addMethod(createBindingConstructorForView());
+        } else if (isActivity) {
+            result.addMethod(createBindingConstructorForActivity());
+        } else if (isDialog) {
+            result.addMethod(createBindingConstructorForDialog());
+        }
+        if (!constructorNeedsView()) {
+            // Add a delegating constructor with a target type + view signature for reflective use.
+            result.addMethod(createBindingViewDelegateConstructor());
+        }
+        result.addMethod(createBindingConstructor(sdk, debuggable));
 
-    return result.build();
-  }
-
-  private MethodSpec createBindingViewDelegateConstructor() {
-    return MethodSpec.constructorBuilder()
-        .addJavadoc("@deprecated Use {@link #$T($T, $T)} for direct creation.\n    "
-                + "Only present for runtime invocation through {@code ButterKnife.bind()}.\n",
-            bindingClassName, targetTypeName, CONTEXT)
-        .addAnnotation(Deprecated.class)
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target")
-        .addParameter(VIEW, "source")
-        .addStatement(("this(target, source.getContext())"))
-        .build();
-  }
-
-  private MethodSpec createBindingConstructorForView() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target)");
-    } else {
-      builder.addStatement("this(target, target.getContext())");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructorForActivity() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target.getWindow().getDecorView())");
-    } else {
-      builder.addStatement("this(target, target)");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructorForDialog() {
-    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC)
-        .addParameter(targetTypeName, "target");
-    if (constructorNeedsView()) {
-      builder.addStatement("this(target, target.getWindow().getDecorView())");
-    } else {
-      builder.addStatement("this(target, target.getContext())");
-    }
-    return builder.build();
-  }
-
-  private MethodSpec createBindingConstructor(int sdk, boolean debuggable) {
-    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
-        .addAnnotation(UI_THREAD)
-        .addModifiers(PUBLIC);
-
-    if (hasMethodBindings()) {
-      constructor.addParameter(targetTypeName, "target", FINAL);
-    } else {
-      constructor.addParameter(targetTypeName, "target");
-    }
+        if (hasViewBindings() || parentBinding == null) {
+            result.addMethod(createBindingUnbindMethod(result));
+        }
 
-    if (constructorNeedsView()) {
-      constructor.addParameter(VIEW, "source");
-    } else {
-      constructor.addParameter(CONTEXT, "context");
+        return result.build();
+    }
+
+    private MethodSpec createBindingViewDelegateConstructor() {
+        return MethodSpec.constructorBuilder()
+                .addJavadoc("@deprecated Use {@link #$T($T, $T)} for direct creation.\n    "
+                                + "Only present for runtime invocation through {@code ButterKnife.bind()}.\n",
+                        bindingClassName, targetTypeName, CONTEXT)
+                .addAnnotation(Deprecated.class)
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target")
+                .addParameter(VIEW, "source")
+                .addStatement(("this(target, source.getContext())"))
+                .build();
+    }
+
+    private MethodSpec createBindingConstructorForView() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target)");
+        } else {
+            builder.addStatement("this(target, target.getContext())");
+        }
+        return builder.build();
     }
 
-    if (hasUnqualifiedResourceBindings()) {
-      // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
-      constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-          .addMember("value", "$S", "ResourceType")
-          .build());
+    private MethodSpec createBindingConstructorForActivity() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target.getWindow().getDecorView())");
+        } else {
+            builder.addStatement("this(target, target)");
+        }
+        return builder.build();
     }
 
-    if (hasOnTouchMethodBindings()) {
-      constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
-          .addMember("value", "$S", "ClickableViewAccessibility")
-          .build());
+    private MethodSpec createBindingConstructorForDialog() {
+        MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC)
+                .addParameter(targetTypeName, "target");
+        if (constructorNeedsView()) {
+            builder.addStatement("this(target, target.getWindow().getDecorView())");
+        } else {
+            builder.addStatement("this(target, target.getContext())");
+        }
+        return builder.build();
     }
 
-    if (parentBinding != null) {
-      if (parentBinding.constructorNeedsView()) {
-        constructor.addStatement("super(target, source)");
-      } else if (constructorNeedsView()) {
-        constructor.addStatement("super(target, source.getContext())");
-      } else {
-        constructor.addStatement("super(target, context)");
-      }
-      constructor.addCode("\n");
-    }
-    if (hasTargetField()) {
-      constructor.addStatement("this.target = target");
-      constructor.addCode("\n");
-    }
+    private MethodSpec createBindingConstructor(int sdk, boolean debuggable) {
+        MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
+                .addAnnotation(UI_THREAD)
+                .addModifiers(PUBLIC);
 
-    if (hasViewBindings()) {
-      if (hasViewLocal()) {
-        // Local variable in which all views will be temporarily stored.
-        constructor.addStatement("$T view", VIEW);
-      }
-      for (ViewBinding binding : viewBindings) {
-        addViewBinding(constructor, binding, debuggable);
-      }
-      for (FieldCollectionViewBinding binding : collectionBindings) {
-        constructor.addStatement("$L", binding.render(debuggable));
-      }
-
-      if (!resourceBindings.isEmpty()) {
-        constructor.addCode("\n");
-      }
-    }
+        if (hasMethodBindings()) {
+            constructor.addParameter(targetTypeName, "target", FINAL);
+        } else {
+            constructor.addParameter(targetTypeName, "target");
+        }
 
-    if (!resourceBindings.isEmpty()) {
-      if (constructorNeedsView()) {
-        constructor.addStatement("$T context = source.getContext()", CONTEXT);
-      }
-      if (hasResourceBindingsNeedingResource(sdk)) {
-        constructor.addStatement("$T res = context.getResources()", RESOURCES);
-      }
-      for (ResourceBinding binding : resourceBindings) {
-        constructor.addStatement("$L", binding.render(sdk));
-      }
-    }
+        if (constructorNeedsView()) {
+            constructor.addParameter(VIEW, "source");
+        } else {
+            constructor.addParameter(CONTEXT, "context");
+        }
 
-    return constructor.build();
-  }
+        if (hasUnqualifiedResourceBindings()) {
+            // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
+            constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "ResourceType")
+                    .build());
+        }
 
-  private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass) {
-    MethodSpec.Builder result = MethodSpec.methodBuilder("unbind")
-        .addAnnotation(Override.class)
-        .addModifiers(PUBLIC);
-    if (!isFinal && parentBinding == null) {
-      result.addAnnotation(CALL_SUPER);
-    }
+        if (hasOnTouchMethodBindings()) {
+            constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
+                    .addMember("value", "$S", "ClickableViewAccessibility")
+                    .build());
+        }
 
-    if (hasTargetField()) {
-      if (hasFieldBindings()) {
-        result.addStatement("$T target = this.target", targetTypeName);
-      }
-      result.addStatement("if (target == null) throw new $T($S)", IllegalStateException.class,
-          "Bindings already cleared.");
-      result.addStatement("$N = null", hasFieldBindings() ? "this.target" : "target");
-      result.addCode("\n");
-      for (ViewBinding binding : viewBindings) {
-        if (binding.getFieldBinding() != null) {
-          result.addStatement("target.$L = null", binding.getFieldBinding().getName());
-        }
-      }
-      for (FieldCollectionViewBinding binding : collectionBindings) {
-        result.addStatement("target.$L = null", binding.name);
-      }
-    }
+        if (parentBinding != null) {
+            if (parentBinding.constructorNeedsView()) {
+                constructor.addStatement("super(target, source)");
+            } else if (constructorNeedsView()) {
+                constructor.addStatement("super(target, source.getContext())");
+            } else {
+                constructor.addStatement("super(target, context)");
+            }
+            constructor.addCode("\n");
+        }
+        if (hasTargetField()) {
+            constructor.addStatement("this.target = target");
+            constructor.addCode("\n");
+        }
 
-    if (hasMethodBindings()) {
-      result.addCode("\n");
-      for (ViewBinding binding : viewBindings) {
-        addFieldAndUnbindStatement(bindingClass, result, binding);
-      }
-    }
+        if (hasViewBindings()) {
+            if (hasViewLocal()) {
+                // Local variable in which all views will be temporarily stored.
+                constructor.addStatement("$T view", VIEW);
+            }
+            for (ViewBinding binding : viewBindings) {
+                addViewBinding(constructor, binding, debuggable);
+            }
+            for (FieldCollectionViewBinding binding : collectionBindings) {
+                constructor.addStatement("$L", binding.render(debuggable));
+            }
 
-    if (parentBinding != null) {
-      result.addCode("\n");
-      result.addStatement("super.unbind()");
-    }
-    return result.build();
-  }
-
-  private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
-      ViewBinding bindings) {
-    // Only add fields to the binding if there are method bindings.
-    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
-        bindings.getMethodBindings();
-    if (classMethodBindings.isEmpty()) {
-      return;
-    }
+            if (!resourceBindings.isEmpty()) {
+                constructor.addCode("\n");
+            }
+        }
 
-    String fieldName =
-        bindings.isBoundToRoot()
-            ? "viewSource"
-            : "view" + Integer.toHexString(bindings.getId().value);
-    result.addField(VIEW, fieldName, PRIVATE);
+        if (!resourceBindings.isEmpty()) {
+            if (constructorNeedsView()) {
+                constructor.addStatement("$T context = source.getContext()", CONTEXT);
+            }
+            if (hasResourceBindingsNeedingResource(sdk)) {
+                constructor.addStatement("$T res = context.getResources()", RESOURCES);
+            }
+            for (ResourceBinding binding : resourceBindings) {
+                constructor.addStatement("$L", binding.render(sdk));
+            }
+        }
 
-    // We only need to emit the null check if there are zero required bindings.
-    boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
-    if (needsNullChecked) {
-      unbindMethod.beginControlFlow("if ($N != null)", fieldName);
+        return constructor.build();
     }
 
-    for (ListenerClass listenerClass : classMethodBindings.keySet()) {
-      // We need to keep a reference to the listener
-      // in case we need to unbind it via a remove method.
-      boolean requiresRemoval = !"".equals(listenerClass.remover());
-      String listenerField = "null";
-      if (requiresRemoval) {
-        TypeName listenerClassName = bestGuess(listenerClass.type());
-        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
-        result.addField(listenerClassName, listenerField, PRIVATE);
-      }
-
-      if (!VIEW_TYPE.equals(listenerClass.targetType())) {
-        unbindMethod.addStatement("(($T) $N).$N($N)", bestGuess(listenerClass.targetType()),
-            fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
-      } else {
-        unbindMethod.addStatement("$N.$N($N)", fieldName,
-            removerOrSetter(listenerClass, requiresRemoval), listenerField);
-      }
-
-      if (requiresRemoval) {
-        unbindMethod.addStatement("$N = null", listenerField);
-      }
-    }
+    private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass) {
+        MethodSpec.Builder result = MethodSpec.methodBuilder("unbind")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC);
+        if (!isFinal && parentBinding == null) {
+            result.addAnnotation(CALL_SUPER);
+        }
 
-    unbindMethod.addStatement("$N = null", fieldName);
+        if (hasTargetField()) {
+            if (hasFieldBindings()) {
+                result.addStatement("$T target = this.target", targetTypeName);
+            }
+            result.addStatement("if (target == null) throw new $T($S)", IllegalStateException.class,
+                    "Bindings already cleared.");
+            result.addStatement("$N = null", hasFieldBindings() ? "this.target" : "target");
+            result.addCode("\n");
+            for (ViewBinding binding : viewBindings) {
+                if (binding.getFieldBinding() != null) {
+                    result.addStatement("target.$L = null", binding.getFieldBinding().getName());
+                }
+            }
+            for (FieldCollectionViewBinding binding : collectionBindings) {
+                result.addStatement("target.$L = null", binding.name);
+            }
+        }
 
-    if (needsNullChecked) {
-      unbindMethod.endControlFlow();
-    }
-  }
-
-  private String removerOrSetter(ListenerClass listenerClass, boolean requiresRemoval) {
-    return requiresRemoval
-        ? listenerClass.remover()
-        : listenerClass.setter();
-  }
-
-  private void addViewBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
-    if (binding.isSingleFieldBinding()) {
-      // Optimize the common case where there's a single binding directly to a field.
-      FieldViewBinding fieldBinding = binding.getFieldBinding();
-      CodeBlock.Builder builder = CodeBlock.builder()
-          .add("target.$L = ", fieldBinding.getName());
-
-      boolean requiresCast = requiresCast(fieldBinding.getType());
-      if (!debuggable || (!requiresCast && !fieldBinding.isRequired())) {
-        if (requiresCast) {
-          builder.add("($T) ", fieldBinding.getType());
-        }
-        builder.add("source.findViewById($L)", binding.getId().code);
-      } else {
-        builder.add("$T.find", UTILS);
-        builder.add(fieldBinding.isRequired() ? "RequiredView" : "OptionalView");
-        if (requiresCast) {
-          builder.add("AsType");
-        }
-        builder.add("(source, $L", binding.getId().code);
-        if (fieldBinding.isRequired() || requiresCast) {
-          builder.add(", $S", asHumanDescription(singletonList(fieldBinding)));
-        }
-        if (requiresCast) {
-          builder.add(", $T.class", fieldBinding.getRawType());
-        }
-        builder.add(")");
-      }
-      result.addStatement("$L", builder.build());
-      return;
-    }
+        if (hasMethodBindings()) {
+            result.addCode("\n");
+            for (ViewBinding binding : viewBindings) {
+                addFieldAndUnbindStatement(bindingClass, result, binding);
+            }
+        }
 
-    List<MemberViewBinding> requiredBindings = binding.getRequiredBindings();
-    if (!debuggable || requiredBindings.isEmpty()) {
-      result.addStatement("view = source.findViewById($L)", binding.getId().code);
-    } else if (!binding.isBoundToRoot()) {
-      result.addStatement("view = $T.findRequiredView(source, $L, $S)", UTILS,
-          binding.getId().code, asHumanDescription(requiredBindings));
+        if (parentBinding != null) {
+            result.addCode("\n");
+            result.addStatement("super.unbind()");
+        }
+        return result.build();
     }
 
-    addFieldBinding(result, binding, debuggable);
-    addMethodBindings(result, binding, debuggable);
-  }
-
-  private void addFieldBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
-    FieldViewBinding fieldBinding = binding.getFieldBinding();
-    if (fieldBinding != null) {
-      if (requiresCast(fieldBinding.getType())) {
-        if (debuggable) {
-          result.addStatement("target.$L = $T.castView(view, $L, $S, $T.class)",
-              fieldBinding.getName(), UTILS, binding.getId().code,
-              asHumanDescription(singletonList(fieldBinding)), fieldBinding.getRawType());
-        } else {
-          result.addStatement("target.$L = ($T) view", fieldBinding.getName(),
-              fieldBinding.getType());
+    private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
+                                            ViewBinding bindings) {
+        // Only add fields to the binding if there are method bindings.
+        Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+                bindings.getMethodBindings();
+        if (classMethodBindings.isEmpty()) {
+            return;
+        }
+
+        String fieldName =
+                bindings.isBoundToRoot()
+                        ? "viewSource"
+                        : "view" + Integer.toHexString(bindings.getId().value);
+        result.addField(VIEW, fieldName, PRIVATE);
+
+        // We only need to emit the null check if there are zero required bindings.
+        boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
+        if (needsNullChecked) {
+            unbindMethod.beginControlFlow("if ($N != null)", fieldName);
+        }
+
+        for (ListenerClass listenerClass : classMethodBindings.keySet()) {
+            // We need to keep a reference to the listener
+            // in case we need to unbind it via a remove method.
+            boolean requiresRemoval = !"".equals(listenerClass.remover());
+            String listenerField = "null";
+            if (requiresRemoval) {
+                TypeName listenerClassName = bestGuess(listenerClass.type());
+                listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+                result.addField(listenerClassName, listenerField, PRIVATE);
+            }
+
+            if (!VIEW_TYPE.equals(listenerClass.targetType())) {
+                unbindMethod.addStatement("(($T) $N).$N($N)", bestGuess(listenerClass.targetType()),
+                        fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
+            } else {
+                unbindMethod.addStatement("$N.$N($N)", fieldName,
+                        removerOrSetter(listenerClass, requiresRemoval), listenerField);
+            }
+
+            if (requiresRemoval) {
+                unbindMethod.addStatement("$N = null", listenerField);
+            }
+        }
+
+        unbindMethod.addStatement("$N = null", fieldName);
+
+        if (needsNullChecked) {
+            unbindMethod.endControlFlow();
         }
-      } else {
-        result.addStatement("target.$L = view", fieldBinding.getName());
-      }
-    }
-  }
-
-  private void addMethodBindings(MethodSpec.Builder result, ViewBinding binding,
-      boolean debuggable) {
-    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
-        binding.getMethodBindings();
-    if (classMethodBindings.isEmpty()) {
-      return;
     }
 
-    // We only need to emit the null check if there are zero required bindings.
-    boolean needsNullChecked = binding.getRequiredBindings().isEmpty();
-    if (needsNullChecked) {
-      result.beginControlFlow("if (view != null)");
+    private String removerOrSetter(ListenerClass listenerClass, boolean requiresRemoval) {
+        return requiresRemoval
+                ? listenerClass.remover()
+                : listenerClass.setter();
     }
 
-    // Add the view reference to the binding.
-    String fieldName = "viewSource";
-    String bindName = "source";
-    if (!binding.isBoundToRoot()) {
-      fieldName = "view" + Integer.toHexString(binding.getId().value);
-      bindName = "view";
+    private void addViewBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+        if (binding.isSingleFieldBinding()) {
+            // Optimize the common case where there's a single binding directly to a field.
+            FieldViewBinding fieldBinding = binding.getFieldBinding();
+            CodeBlock.Builder builder = CodeBlock.builder()
+                    .add("target.$L = ", fieldBinding.getName());
+
+            boolean requiresCast = requiresCast(fieldBinding.getType());
+            if (!debuggable || (!requiresCast && !fieldBinding.isRequired())) {
+                if (requiresCast) {
+                    builder.add("($T) ", fieldBinding.getType());
+                }
+                builder.add("source.findViewById($L)", binding.getId().code);
+            } else {
+                builder.add("$T.find", UTILS);
+                builder.add(fieldBinding.isRequired() ? "RequiredView" : "OptionalView");
+                if (requiresCast) {
+                    builder.add("AsType");
+                }
+                builder.add("(source, $L", binding.getId().code);
+                if (fieldBinding.isRequired() || requiresCast) {
+                    builder.add(", $S", asHumanDescription(singletonList(fieldBinding)));
+                }
+                if (requiresCast) {
+                    builder.add(", $T.class", fieldBinding.getRawType());
+                }
+                builder.add(")");
+            }
+            result.addStatement("$L", builder.build());
+            return;
+        }
+
+        List<MemberViewBinding> requiredBindings = binding.getRequiredBindings();
+        if (!debuggable || requiredBindings.isEmpty()) {
+            result.addStatement("view = source.findViewById($L)", binding.getId().code);
+        } else if (!binding.isBoundToRoot()) {
+            result.addStatement("view = $T.findRequiredView(source, $L, $S)", UTILS,
+                    binding.getId().code, asHumanDescription(requiredBindings));
+        }
+
+        addFieldBinding(result, binding, debuggable);
+        addMethodBindings(result, binding, debuggable);
     }
-    result.addStatement("$L = $N", fieldName, bindName);
-
-    for (Map.Entry<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> e
-        : classMethodBindings.entrySet()) {
-      ListenerClass listener = e.getKey();
-      Map<ListenerMethod, Set<MethodViewBinding>> methodBindings = e.getValue();
-
-      TypeSpec.Builder callback = TypeSpec.anonymousClassBuilder("")
-          .superclass(ClassName.bestGuess(listener.type()));
-
-      for (ListenerMethod method : getListenerMethods(listener)) {
-        MethodSpec.Builder callbackMethod = MethodSpec.methodBuilder(method.name())
-            .addAnnotation(Override.class)
-            .addModifiers(PUBLIC)
-            .returns(bestGuess(method.returnType()));
-        String[] parameterTypes = method.parameters();
-        for (int i = 0, count = parameterTypes.length; i < count; i++) {
-          callbackMethod.addParameter(bestGuess(parameterTypes[i]), "p" + i);
-        }
-
-        boolean hasReturnType = !"void".equals(method.returnType());
-        CodeBlock.Builder builder = CodeBlock.builder();
-        if (hasReturnType) {
-          builder.add("return ");
-        }
-
-        if (methodBindings.containsKey(method)) {
-          for (MethodViewBinding methodBinding : methodBindings.get(method)) {
-            builder.add("target.$L(", methodBinding.getName());
-            List<Parameter> parameters = methodBinding.getParameters();
-            String[] listenerParameters = method.parameters();
-            for (int i = 0, count = parameters.size(); i < count; i++) {
-              if (i > 0) {
-                builder.add(", ");
-              }
-
-              Parameter parameter = parameters.get(i);
-              int listenerPosition = parameter.getListenerPosition();
-
-              if (parameter.requiresCast(listenerParameters[listenerPosition])) {
+
+    private void addFieldBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+        FieldViewBinding fieldBinding = binding.getFieldBinding();
+        if (fieldBinding != null) {
+            if (requiresCast(fieldBinding.getType())) {
                 if (debuggable) {
-                  builder.add("$T.castParam(p$L, $S, $L, $S, $L, $T.class)", UTILS,
-                      listenerPosition, method.name(), listenerPosition, methodBinding.getName(), i,
-                      parameter.getType());
+                    result.addStatement("target.$L = $T.castView(view, $L, $S, $T.class)",
+                            fieldBinding.getName(), UTILS, binding.getId().code,
+                            asHumanDescription(singletonList(fieldBinding)), fieldBinding.getRawType());
                 } else {
-                  builder.add("($T) p$L", parameter.getType(), listenerPosition);
+                    result.addStatement("target.$L = ($T) view", fieldBinding.getName(),
+                            fieldBinding.getType());
                 }
-              } else {
-                builder.add("p$L", listenerPosition);
-              }
-            }
-            builder.add(");\n");
-          }
-        } else if (hasReturnType) {
-          builder.add("$L;\n", method.defaultReturn());
-        }
-        callbackMethod.addCode(builder.build());
-        callback.addMethod(callbackMethod.build());
-      }
-
-      boolean requiresRemoval = listener.remover().length() != 0;
-      String listenerField = null;
-      if (requiresRemoval) {
-        TypeName listenerClassName = bestGuess(listener.type());
-        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
-        result.addStatement("$L = $L", listenerField, callback.build());
-      }
-
-      if (!VIEW_TYPE.equals(listener.targetType())) {
-        result.addStatement("(($T) $N).$L($L)", bestGuess(listener.targetType()), bindName,
-            listener.setter(), requiresRemoval ? listenerField : callback.build());
-      } else {
-        result.addStatement("$N.$L($L)", bindName, listener.setter(),
-            requiresRemoval ? listenerField : callback.build());
-      }
+            } else {
+                result.addStatement("target.$L = view", fieldBinding.getName());
+            }
+        }
     }
 
-    if (needsNullChecked) {
-      result.endControlFlow();
-    }
-  }
+    private void addMethodBindings(MethodSpec.Builder result, ViewBinding binding,
+                                   boolean debuggable) {
+        Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+                binding.getMethodBindings();
+        if (classMethodBindings.isEmpty()) {
+            return;
+        }
 
-  private static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
-    if (listener.method().length == 1) {
-      return Arrays.asList(listener.method());
-    }
+        // We only need to emit the null check if there are zero required bindings.
+        boolean needsNullChecked = binding.getRequiredBindings().isEmpty();
+        if (needsNullChecked) {
+            result.beginControlFlow("if (view != null)");
+        }
 
-    try {
-      List<ListenerMethod> methods = new ArrayList<>();
-      Class<? extends Enum<?>> callbacks = listener.callbacks();
-      for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
-        Field callbackField = callbacks.getField(callbackMethod.name());
-        ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
-        if (method == null) {
-          throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
-              callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
-              callbackMethod.name(), ListenerMethod.class.getSimpleName()));
-        }
-        methods.add(method);
-      }
-      return methods;
-    } catch (NoSuchFieldException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  static String asHumanDescription(Collection<? extends MemberViewBinding> bindings) {
-    Iterator<? extends MemberViewBinding> iterator = bindings.iterator();
-    switch (bindings.size()) {
-      case 1:
-        return iterator.next().getDescription();
-      case 2:
-        return iterator.next().getDescription() + " and " + iterator.next().getDescription();
-      default:
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0, count = bindings.size(); i < count; i++) {
-          if (i != 0) {
-            builder.append(", ");
-          }
-          if (i == count - 1) {
-            builder.append("and ");
-          }
-          builder.append(iterator.next().getDescription());
-        }
-        return builder.toString();
-    }
-  }
-
-  private static TypeName bestGuess(String type) {
-    switch (type) {
-      case "void": return TypeName.VOID;
-      case "boolean": return TypeName.BOOLEAN;
-      case "byte": return TypeName.BYTE;
-      case "char": return TypeName.CHAR;
-      case "double": return TypeName.DOUBLE;
-      case "float": return TypeName.FLOAT;
-      case "int": return TypeName.INT;
-      case "long": return TypeName.LONG;
-      case "short": return TypeName.SHORT;
-      default:
-        int left = type.indexOf('<');
-        if (left != -1) {
-          ClassName typeClassName = ClassName.bestGuess(type.substring(0, left));
-          List<TypeName> typeArguments = new ArrayList<>();
-          do {
-            typeArguments.add(WildcardTypeName.subtypeOf(Object.class));
-            left = type.indexOf('<', left + 1);
-          } while (left != -1);
-          return ParameterizedTypeName.get(typeClassName,
-              typeArguments.toArray(new TypeName[typeArguments.size()]));
-        }
-        return ClassName.bestGuess(type);
-    }
-  }
-
-  /** True when this type's bindings require a view hierarchy. */
-  private boolean hasViewBindings() {
-    return !viewBindings.isEmpty() || !collectionBindings.isEmpty();
-  }
-
-  /** True when this type's bindings use raw integer values instead of {@code R} references. */
-  private boolean hasUnqualifiedResourceBindings() {
-    for (ResourceBinding binding : resourceBindings) {
-      if (!binding.id().qualifed) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** True when this type's bindings use Resource directly instead of Context. */
-  private boolean hasResourceBindingsNeedingResource(int sdk) {
-    for (ResourceBinding binding : resourceBindings) {
-      if (binding.requiresResources(sdk)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasMethodBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (!bindings.getMethodBindings().isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasOnTouchMethodBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.getMethodBindings()
-          .containsKey(OnTouch.class.getAnnotation(ListenerClass.class))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean hasFieldBindings() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.getFieldBinding() != null) {
-        return true;
-      }
-    }
-    return !collectionBindings.isEmpty();
-  }
-
-  private boolean hasTargetField() {
-    return hasFieldBindings() || hasMethodBindings();
-  }
-
-  private boolean hasViewLocal() {
-    for (ViewBinding bindings : viewBindings) {
-      if (bindings.requiresLocal()) {
-        return true;
-      }
-    }
-    return false;
-  }
+        // Add the view reference to the binding.
+        String fieldName = "viewSource";
+        String bindName = "source";
+        if (!binding.isBoundToRoot()) {
+            fieldName = "view" + Integer.toHexString(binding.getId().value);
+            bindName = "view";
+        }
+        result.addStatement("$L = $N", fieldName, bindName);
+
+        for (Map.Entry<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> e
+                : classMethodBindings.entrySet()) {
+            ListenerClass listener = e.getKey();
+            Map<ListenerMethod, Set<MethodViewBinding>> methodBindings = e.getValue();
+
+            TypeSpec.Builder callback = TypeSpec.anonymousClassBuilder("")
+                    .superclass(ClassName.bestGuess(listener.type()));
+
+            for (ListenerMethod method : getListenerMethods(listener)) {
+                MethodSpec.Builder callbackMethod = MethodSpec.methodBuilder(method.name())
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bestGuess(method.returnType()));
+                String[] parameterTypes = method.parameters();
+                for (int i = 0, count = parameterTypes.length; i < count; i++) {
+                    callbackMethod.addParameter(bestGuess(parameterTypes[i]), "p" + i);
+                }
 
-  /** True if this binding requires a view. Otherwise only a context is needed. */
-  private boolean constructorNeedsView() {
-    return hasViewBindings() //
-        || parentBinding != null && parentBinding.constructorNeedsView();
-  }
+                boolean hasReturnType = !"void".equals(method.returnType());
+                CodeBlock.Builder builder = CodeBlock.builder();
+                if (hasReturnType) {
+                    builder.add("return ");
+                }
 
-  static boolean requiresCast(TypeName type) {
-    return !VIEW_TYPE.equals(type.toString());
-  }
+                if (methodBindings.containsKey(method)) {
+                    for (MethodViewBinding methodBinding : methodBindings.get(method)) {
+                        builder.add("target.$L(", methodBinding.getName());
+                        List<Parameter> parameters = methodBinding.getParameters();
+                        String[] listenerParameters = method.parameters();
+                        for (int i = 0, count = parameters.size(); i < count; i++) {
+                            if (i > 0) {
+                                builder.add(", ");
+                            }
+
+                            Parameter parameter = parameters.get(i);
+                            int listenerPosition = parameter.getListenerPosition();
+
+                            if (parameter.requiresCast(listenerParameters[listenerPosition])) {
+                                if (debuggable) {
+                                    builder.add("$T.castParam(p$L, $S, $L, $S, $L, $T.class)", UTILS,
+                                            listenerPosition, method.name(), listenerPosition, methodBinding.getName(), i,
+                                            parameter.getType());
+                                } else {
+                                    builder.add("($T) p$L", parameter.getType(), listenerPosition);
+                                }
+                            } else {
+                                builder.add("p$L", listenerPosition);
+                            }
+                        }
+                        builder.add(");\n");
+                    }
+                } else if (hasReturnType) {
+                    builder.add("$L;\n", method.defaultReturn());
+                }
+                callbackMethod.addCode(builder.build());
+                callback.addMethod(callbackMethod.build());
+            }
 
-  @Override public String toString() {
-    return bindingClassName.toString();
-  }
+            boolean requiresRemoval = listener.remover().length() != 0;
+            String listenerField = null;
+            if (requiresRemoval) {
+                TypeName listenerClassName = bestGuess(listener.type());
+                listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+                result.addStatement("$L = $L", listenerField, callback.build());
+            }
+
+            if (!VIEW_TYPE.equals(listener.targetType())) {
+                result.addStatement("(($T) $N).$L($L)", bestGuess(listener.targetType()), bindName,
+                        listener.setter(), requiresRemoval ? listenerField : callback.build());
+            } else {
+                result.addStatement("$N.$L($L)", bindName, listener.setter(),
+                        requiresRemoval ? listenerField : callback.build());
+            }
+        }
 
-  static Builder newBuilder(TypeElement enclosingElement) {
-    TypeMirror typeMirror = enclosingElement.asType();
+        if (needsNullChecked) {
+            result.endControlFlow();
+        }
+    }
 
-    boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);
-    boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);
-    boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);
+    private static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
+        if (listener.method().length == 1) {
+            return Arrays.asList(listener.method());
+        }
 
-    TypeName targetType = TypeName.get(typeMirror);
-    if (targetType instanceof ParameterizedTypeName) {
-      targetType = ((ParameterizedTypeName) targetType).rawType;
+        try {
+            List<ListenerMethod> methods = new ArrayList<>();
+            Class<? extends Enum<?>> callbacks = listener.callbacks();
+            for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
+                Field callbackField = callbacks.getField(callbackMethod.name());
+                ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
+                if (method == null) {
+                    throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
+                            callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
+                            callbackMethod.name(), ListenerMethod.class.getSimpleName()));
+                }
+                methods.add(method);
+            }
+            return methods;
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError(e);
+        }
     }
 
-    String packageName = getPackage(enclosingElement).getQualifiedName().toString();
-    String className = enclosingElement.getQualifiedName().toString().substring(
-        packageName.length() + 1).replace('.', '$');
-    ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding");
+    static String asHumanDescription(Collection<? extends MemberViewBinding> bindings) {
+        Iterator<? extends MemberViewBinding> iterator = bindings.iterator();
+        switch (bindings.size()) {
+            case 1:
+                return iterator.next().getDescription();
+            case 2:
+                return iterator.next().getDescription() + " and " + iterator.next().getDescription();
+            default:
+                StringBuilder builder = new StringBuilder();
+                for (int i = 0, count = bindings.size(); i < count; i++) {
+                    if (i != 0) {
+                        builder.append(", ");
+                    }
+                    if (i == count - 1) {
+                        builder.append("and ");
+                    }
+                    builder.append(iterator.next().getDescription());
+                }
+                return builder.toString();
+        }
+    }
 
-    boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);
-    return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);
-  }
+    private static TypeName bestGuess(String type) {
+        switch (type) {
+            case "void":
+                return TypeName.VOID;
+            case "boolean":
+                return TypeName.BOOLEAN;
+            case "byte":
+                return TypeName.BYTE;
+            case "char":
+                return TypeName.CHAR;
+            case "double":
+                return TypeName.DOUBLE;
+            case "float":
+                return TypeName.FLOAT;
+            case "int":
+                return TypeName.INT;
+            case "long":
+                return TypeName.LONG;
+            case "short":
+                return TypeName.SHORT;
+            default:
+                int left = type.indexOf('<');
+                if (left != -1) {
+                    ClassName typeClassName = ClassName.bestGuess(type.substring(0, left));
+                    List<TypeName> typeArguments = new ArrayList<>();
+                    do {
+                        typeArguments.add(WildcardTypeName.subtypeOf(Object.class));
+                        left = type.indexOf('<', left + 1);
+                    } while (left != -1);
+                    return ParameterizedTypeName.get(typeClassName,
+                            typeArguments.toArray(new TypeName[typeArguments.size()]));
+                }
+                return ClassName.bestGuess(type);
+        }
+    }
 
-  static final class Builder {
-    private final TypeName targetTypeName;
-    private final ClassName bindingClassName;
-    private final boolean isFinal;
-    private final boolean isView;
-    private final boolean isActivity;
-    private final boolean isDialog;
+    /**
+     * True when this type's bindings require a view hierarchy.
+     */
+    private boolean hasViewBindings() {
+        return !viewBindings.isEmpty() || !collectionBindings.isEmpty();
+    }
 
-    private BindingSet parentBinding;
-
-    private final Map<Id, ViewBinding.Builder> viewIdMap = new LinkedHashMap<>();
-    private final ImmutableList.Builder<FieldCollectionViewBinding> collectionBindings =
-        ImmutableList.builder();
-    private final ImmutableList.Builder<ResourceBinding> resourceBindings = ImmutableList.builder();
-
-    private Builder(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
-        boolean isView, boolean isActivity, boolean isDialog) {
-      this.targetTypeName = targetTypeName;
-      this.bindingClassName = bindingClassName;
-      this.isFinal = isFinal;
-      this.isView = isView;
-      this.isActivity = isActivity;
-      this.isDialog = isDialog;
+    /**
+     * True when this type's bindings use raw integer values instead of {@code R} references.
+     */
+    private boolean hasUnqualifiedResourceBindings() {
+        for (ResourceBinding binding : resourceBindings) {
+            if (!binding.id().qualifed) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    void addField(Id id, FieldViewBinding binding) {
-      getOrCreateViewBindings(id).setFieldBinding(binding);
+    /**
+     * True when this type's bindings use Resource directly instead of Context.
+     */
+    private boolean hasResourceBindingsNeedingResource(int sdk) {
+        for (ResourceBinding binding : resourceBindings) {
+            if (binding.requiresResources(sdk)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    void addFieldCollection(FieldCollectionViewBinding binding) {
-      collectionBindings.add(binding);
+    private boolean hasMethodBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (!bindings.getMethodBindings().isEmpty()) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    boolean addMethod(
-        Id id,
-        ListenerClass listener,
-        ListenerMethod method,
-        MethodViewBinding binding) {
-      ViewBinding.Builder viewBinding = getOrCreateViewBindings(id);
-      if (viewBinding.hasMethodBinding(listener, method) && !"void".equals(method.returnType())) {
+    private boolean hasOnTouchMethodBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.getMethodBindings()
+                    .containsKey(OnTouch.class.getAnnotation(ListenerClass.class))) {
+                return true;
+            }
+        }
         return false;
-      }
-      viewBinding.addMethodBinding(listener, method, binding);
-      return true;
     }
 
-    void addResource(ResourceBinding binding) {
-      resourceBindings.add(binding);
+    private boolean hasFieldBindings() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.getFieldBinding() != null) {
+                return true;
+            }
+        }
+        return !collectionBindings.isEmpty();
+    }
+
+    private boolean hasTargetField() {
+        return hasFieldBindings() || hasMethodBindings();
     }
 
-    void setParent(BindingSet parent) {
-      this.parentBinding = parent;
+    private boolean hasViewLocal() {
+        for (ViewBinding bindings : viewBindings) {
+            if (bindings.requiresLocal()) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    String findExistingBindingName(Id id) {
-      ViewBinding.Builder builder = viewIdMap.get(id);
-      if (builder == null) {
-        return null;
-      }
-      FieldViewBinding fieldBinding = builder.fieldBinding;
-      if (fieldBinding == null) {
-        return null;
-      }
-      return fieldBinding.getName();
+    /**
+     * True if this binding requires a view. Otherwise only a context is needed.
+     */
+    private boolean constructorNeedsView() {
+        return hasViewBindings() //
+                || parentBinding != null && parentBinding.constructorNeedsView();
     }
 
-    private ViewBinding.Builder getOrCreateViewBindings(Id id) {
-      ViewBinding.Builder viewId = viewIdMap.get(id);
-      if (viewId == null) {
-        viewId = new ViewBinding.Builder(id);
-        viewIdMap.put(id, viewId);
-      }
-      return viewId;
+    static boolean requiresCast(TypeName type) {
+        return !VIEW_TYPE.equals(type.toString());
     }
 
-    BindingSet build() {
-      ImmutableList.Builder<ViewBinding> viewBindings = ImmutableList.builder();
-      for (ViewBinding.Builder builder : viewIdMap.values()) {
-        viewBindings.add(builder.build());
-      }
-      return new BindingSet(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,
-          viewBindings.build(), collectionBindings.build(), resourceBindings.build(),
-          parentBinding);
+    @Override
+    public String toString() {
+        return bindingClassName.toString();
+    }
+
+    static Builder newBuilder(TypeElement enclosingElement) {
+        TypeMirror typeMirror = enclosingElement.asType();
+
+        boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);
+        boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);
+        boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);
+
+        TypeName targetType = TypeName.get(typeMirror);
+        if (targetType instanceof ParameterizedTypeName) {
+            targetType = ((ParameterizedTypeName) targetType).rawType;
+        }
+
+        String packageName = getPackage(enclosingElement).getQualifiedName().toString();
+        String className = enclosingElement.getQualifiedName().toString().substring(
+                packageName.length() + 1).replace('.', '$');
+        ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding");
+
+        boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);
+        return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);
+    }
+
+    static final class Builder {
+        private final TypeName targetTypeName;
+        private final ClassName bindingClassName;
+        private final boolean isFinal;
+        private final boolean isView;
+        private final boolean isActivity;
+        private final boolean isDialog;
+
+        private BindingSet parentBinding;
+
+        private final Map<Id, ViewBinding.Builder> viewIdMap = new LinkedHashMap<>();
+        private final ImmutableList.Builder<FieldCollectionViewBinding> collectionBindings =
+                ImmutableList.builder();
+        private final ImmutableList.Builder<ResourceBinding> resourceBindings = ImmutableList.builder();
+
+        private Builder(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+                        boolean isView, boolean isActivity, boolean isDialog) {
+            this.targetTypeName = targetTypeName;
+            this.bindingClassName = bindingClassName;
+            this.isFinal = isFinal;
+            this.isView = isView;
+            this.isActivity = isActivity;
+            this.isDialog = isDialog;
+        }
+
+        void addField(Id id, FieldViewBinding binding) {
+            getOrCreateViewBindings(id).setFieldBinding(binding);
+        }
+
+        void addFieldCollection(FieldCollectionViewBinding binding) {
+            collectionBindings.add(binding);
+        }
+
+        boolean addMethod(
+                Id id,
+                ListenerClass listener,
+                ListenerMethod method,
+                MethodViewBinding binding) {
+            ViewBinding.Builder viewBinding = getOrCreateViewBindings(id);
+            if (viewBinding.hasMethodBinding(listener, method) && !"void".equals(method.returnType())) {
+                return false;
+            }
+            viewBinding.addMethodBinding(listener, method, binding);
+            return true;
+        }
+
+        void addResource(ResourceBinding binding) {
+            resourceBindings.add(binding);
+        }
+
+        void setParent(BindingSet parent) {
+            this.parentBinding = parent;
+        }
+
+        String findExistingBindingName(Id id) {
+            ViewBinding.Builder builder = viewIdMap.get(id);
+            if (builder == null) {
+                return null;
+            }
+            FieldViewBinding fieldBinding = builder.fieldBinding;
+            if (fieldBinding == null) {
+                return null;
+            }
+            return fieldBinding.getName();
+        }
+
+        private ViewBinding.Builder getOrCreateViewBindings(Id id) {
+            ViewBinding.Builder viewId = viewIdMap.get(id);
+            if (viewId == null) {
+                viewId = new ViewBinding.Builder(id);
+                viewIdMap.put(id, viewId);
+            }
+            return viewId;
+        }
+
+        BindingSet build() {
+            ImmutableList.Builder<ViewBinding> viewBindings = ImmutableList.builder();
+            for (ViewBinding.Builder builder : viewIdMap.values()) {
+                viewBindings.add(builder.build());
+            }
+            return new BindingSet(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,
+                    viewBindings.build(), collectionBindings.build(), resourceBindings.build(),
+                    parentBinding);
+        }
     }
-  }
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index e09ece21..7ebe7a86 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -154,11 +154,15 @@ public synchronized void init(ProcessingEnvironment env) {
             }
         }
 
+        // 取到 OPTION_DEBUGGABLE 的值
         debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
 
         elementUtils = env.getElementUtils();
         typeUtils = env.getTypeUtils();
         filer = env.getFiler();
+        // processingEnv 是 AbstractProcessor 中的 protected 修饰的 ProcessingEnvironment
+        // init(ProcessingEnvironment processingEnv)中直接将参数processingEnv 赋值给了变量 processingEnv
+        // （此处直接将 processingEnv 变为 env ，结果应该是一样的）
         try {
             trees = Trees.instance(processingEnv);
         } catch (IllegalArgumentException ignored) {
@@ -205,7 +209,7 @@ public synchronized void init(ProcessingEnvironment env) {
         annotations.add(BindString.class);
         annotations.add(BindView.class);
         annotations.add(BindViews.class);
-        annotations.addAll(LISTENERS); // LISTENERS 中包含的是跟“事件”相关的注解
+        annotations.addAll(LISTENERS); // 监听器相关注解
 
         return annotations;
     }
@@ -220,7 +224,9 @@ public synchronized void init(ProcessingEnvironment env) {
     public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
         Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
 
+        // Entry 为 Map 中的一个实体，包含键值对
         for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
+            // typeElement 主要是用来打印错误信息，我们真正需要的是 binding，我们用它来生成 Java 文件
             TypeElement typeElement = entry.getKey();
             BindingSet binding = entry.getValue();
 
@@ -1342,7 +1348,7 @@ private void printMessage(Kind kind, Element element, String message, Object[] a
         if (args.length > 0) {
             message = String.format(message, args);
         }
-
+        // 打印错误信息
         processingEnv.getMessager().printMessage(kind, message, element);
     }
 
@@ -1390,8 +1396,10 @@ private void scanForRClasses(RoundEnvironment env) {
             for (Element element : env.getElementsAnnotatedWith(annotation)) {
                 JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
                 if (tree != null) { // tree can be null if the references are compiled types and not source
+                    //获取R文件的包元素
+                    // 这里set的package获取的是对应的注解声明所在的类的路径,例com.example.butterknife.library.adapter
                     scanner.setCurrentPackage(elementUtils.getPackageOf(element));
-                    tree.accept(scanner);
+                    tree.accept(scanner);//遍历语法树
                 }
             }
         }
@@ -1400,6 +1408,7 @@ private void scanForRClasses(RoundEnvironment env) {
                 : scanner.getRClasses().entrySet()) {
             PackageElement respectivePackageName = packageNameToRClassSet.getKey();
             for (Symbol.ClassSymbol rClass : packageNameToRClassSet.getValue()) {
+                //解析R文件
                 parseRClass(respectivePackageName, rClass, scanner.getReferenced());
             }
         }
@@ -1417,6 +1426,7 @@ private void parseRClass(PackageElement respectivePackageName, Symbol.ClassSymbo
 
         JCTree tree = (JCTree) trees.getTree(element);
         if (tree != null) { // tree can be null if the references are compiled types and not source
+            // 利用IdScanner寻找R文件内部类,如array,attr,string等
             IdScanner idScanner =
                     new IdScanner(symbols, elementUtils.getPackageOf(element), respectivePackageName,
                             referenced);
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
index 6e82d46e..15b64c8b 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
@@ -1,7 +1,11 @@
 package butterknife.compiler;
 
-/** A field or method view binding. */
+/**
+ * A field or method view binding.
+ */
 interface MemberViewBinding {
-  /** A description of the binding in human readable form (e.g., "field 'foo'"). */
-  String getDescription();
+    /**
+     * A description of the binding in human readable form (e.g., "field 'foo'").
+     */
+    String getDescription();
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
index e4d1c4b7..ac649caa 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
@@ -5,29 +5,30 @@
 import java.util.List;
 
 final class MethodViewBinding implements MemberViewBinding {
-  private final String name;
-  private final List<Parameter> parameters;
-  private final boolean required;
+    private final String name;
+    private final List<Parameter> parameters;
+    private final boolean required;
 
-  MethodViewBinding(String name, List<Parameter> parameters, boolean required) {
-    this.name = name;
-    this.parameters = Collections.unmodifiableList(new ArrayList<>(parameters));
-    this.required = required;
-  }
+    MethodViewBinding(String name, List<Parameter> parameters, boolean required) {
+        this.name = name;
+        this.parameters = Collections.unmodifiableList(new ArrayList<>(parameters));
+        this.required = required;
+    }
 
-  public String getName() {
-    return name;
-  }
+    public String getName() {
+        return name;
+    }
 
-  public List<Parameter> getParameters() {
-    return parameters;
-  }
+    public List<Parameter> getParameters() {
+        return parameters;
+    }
 
-  @Override public String getDescription() {
-    return "method '" + name + "'";
-  }
+    @Override
+    public String getDescription() {
+        return "method '" + name + "'";
+    }
 
-  public boolean isRequired() {
-    return required;
-  }
+    public boolean isRequired() {
+        return required;
+    }
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java
index 085124cd..d6a917c9 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java
@@ -2,6 +2,7 @@
 
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
+
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -10,106 +11,106 @@
 import java.util.Set;
 
 final class ViewBinding {
-  private final Id id;
-  private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings;
-  private final FieldViewBinding fieldBinding;
-
-  ViewBinding(Id id, Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings,
-      FieldViewBinding fieldBinding) {
-    this.id = id;
-    this.methodBindings = methodBindings;
-    this.fieldBinding = fieldBinding;
-  }
-
-  public Id getId() {
-    return id;
-  }
-
-  public FieldViewBinding getFieldBinding() {
-    return fieldBinding;
-  }
-
-  public Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> getMethodBindings() {
-    return methodBindings;
-  }
-
-  public List<MemberViewBinding> getRequiredBindings() {
-    List<MemberViewBinding> requiredBindings = new ArrayList<>();
-    if (fieldBinding != null && fieldBinding.isRequired()) {
-      requiredBindings.add(fieldBinding);
-    }
-    for (Map<ListenerMethod, Set<MethodViewBinding>> methodBinding : methodBindings.values()) {
-      for (Set<MethodViewBinding> set : methodBinding.values()) {
-        for (MethodViewBinding binding : set) {
-          if (binding.isRequired()) {
-            requiredBindings.add(binding);
-          }
-        }
-      }
+    private final Id id;
+    private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings;
+    private final FieldViewBinding fieldBinding;
+
+    ViewBinding(Id id, Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings,
+                FieldViewBinding fieldBinding) {
+        this.id = id;
+        this.methodBindings = methodBindings;
+        this.fieldBinding = fieldBinding;
     }
-    return requiredBindings;
-  }
 
-  public boolean isSingleFieldBinding() {
-    return methodBindings.isEmpty() && fieldBinding != null;
-  }
-
-  public boolean requiresLocal() {
-    if (isBoundToRoot()) {
-      return false;
-    }
-    if (isSingleFieldBinding()) {
-      return false;
+    public Id getId() {
+        return id;
     }
-    return true;
-  }
-
-  public boolean isBoundToRoot() {
-    return ButterKnifeProcessor.NO_ID.equals(id);
-  }
 
-  public static final class Builder {
-    private final Id id;
+    public FieldViewBinding getFieldBinding() {
+        return fieldBinding;
+    }
 
-    private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings =
-        new LinkedHashMap<>();
-    FieldViewBinding fieldBinding;
+    public Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> getMethodBindings() {
+        return methodBindings;
+    }
 
-    Builder(Id id) {
-      this.id = id;
+    public List<MemberViewBinding> getRequiredBindings() {
+        List<MemberViewBinding> requiredBindings = new ArrayList<>();
+        if (fieldBinding != null && fieldBinding.isRequired()) {
+            requiredBindings.add(fieldBinding);
+        }
+        for (Map<ListenerMethod, Set<MethodViewBinding>> methodBinding : methodBindings.values()) {
+            for (Set<MethodViewBinding> set : methodBinding.values()) {
+                for (MethodViewBinding binding : set) {
+                    if (binding.isRequired()) {
+                        requiredBindings.add(binding);
+                    }
+                }
+            }
+        }
+        return requiredBindings;
     }
 
-    public boolean hasMethodBinding(ListenerClass listener, ListenerMethod method) {
-      Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
-      return methods != null && methods.containsKey(method);
+    public boolean isSingleFieldBinding() {
+        return methodBindings.isEmpty() && fieldBinding != null;
     }
 
-    public void addMethodBinding(ListenerClass listener, ListenerMethod method,
-        MethodViewBinding binding) {
-      Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
-      Set<MethodViewBinding> set = null;
-      if (methods == null) {
-        methods = new LinkedHashMap<>();
-        methodBindings.put(listener, methods);
-      } else {
-        set = methods.get(method);
-      }
-      if (set == null) {
-        set = new LinkedHashSet<>();
-        methods.put(method, set);
-      }
-      set.add(binding);
+    public boolean requiresLocal() {
+        if (isBoundToRoot()) {
+            return false;
+        }
+        if (isSingleFieldBinding()) {
+            return false;
+        }
+        return true;
     }
 
-    public void setFieldBinding(FieldViewBinding fieldBinding) {
-      if (this.fieldBinding != null) {
-        throw new AssertionError();
-      }
-      this.fieldBinding = fieldBinding;
+    public boolean isBoundToRoot() {
+        return ButterKnifeProcessor.NO_ID.equals(id);
     }
 
-    public ViewBinding build() {
-      return new ViewBinding(id, methodBindings, fieldBinding);
+    public static final class Builder {
+        private final Id id;
+
+        private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings =
+                new LinkedHashMap<>();
+        FieldViewBinding fieldBinding;
+
+        Builder(Id id) {
+            this.id = id;
+        }
+
+        public boolean hasMethodBinding(ListenerClass listener, ListenerMethod method) {
+            Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
+            return methods != null && methods.containsKey(method);
+        }
+
+        public void addMethodBinding(ListenerClass listener, ListenerMethod method,
+                                     MethodViewBinding binding) {
+            Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
+            Set<MethodViewBinding> set = null;
+            if (methods == null) {
+                methods = new LinkedHashMap<>();
+                methodBindings.put(listener, methods);
+            } else {
+                set = methods.get(method);
+            }
+            if (set == null) {
+                set = new LinkedHashSet<>();
+                methods.put(method, set);
+            }
+            set.add(binding);
+        }
+
+        public void setFieldBinding(FieldViewBinding fieldBinding) {
+            if (this.fieldBinding != null) {
+                throw new AssertionError();
+            }
+            this.fieldBinding = fieldBinding;
+        }
+
+        public ViewBinding build() {
+            return new ViewBinding(id, methodBindings, fieldBinding);
+        }
     }
-  }
 }
diff --git a/butterknife/src/main/java/butterknife/internal/Utils.java b/butterknife/src/main/java/butterknife/internal/Utils.java
index e9101f74..ba01b1e9 100644
--- a/butterknife/src/main/java/butterknife/internal/Utils.java
+++ b/butterknife/src/main/java/butterknife/internal/Utils.java
@@ -12,139 +12,140 @@
 import android.support.v4.graphics.drawable.DrawableCompat;
 import android.util.TypedValue;
 import android.view.View;
+
 import java.lang.reflect.Array;
 import java.util.List;
 
 @SuppressWarnings("WeakerAccess") // Used by generated code.
 public final class Utils {
-  private static final TypedValue VALUE = new TypedValue();
-
-  @UiThread // Implicit synchronization for use of shared resource VALUE.
-  public static Drawable getTintedDrawable(Context context,
-      @DrawableRes int id, @AttrRes int tintAttrId) {
-    boolean attributeFound = context.getTheme().resolveAttribute(tintAttrId, VALUE, true);
-    if (!attributeFound) {
-      throw new Resources.NotFoundException("Required tint color attribute with name "
-          + context.getResources().getResourceEntryName(tintAttrId)
-          + " and attribute ID "
-          + tintAttrId
-          + " was not found.");
+    private static final TypedValue VALUE = new TypedValue();
+
+    @UiThread // Implicit synchronization for use of shared resource VALUE.
+    public static Drawable getTintedDrawable(Context context,
+                                             @DrawableRes int id, @AttrRes int tintAttrId) {
+        boolean attributeFound = context.getTheme().resolveAttribute(tintAttrId, VALUE, true);
+        if (!attributeFound) {
+            throw new Resources.NotFoundException("Required tint color attribute with name "
+                    + context.getResources().getResourceEntryName(tintAttrId)
+                    + " and attribute ID "
+                    + tintAttrId
+                    + " was not found.");
+        }
+
+        Drawable drawable = ContextCompat.getDrawable(context, id);
+        drawable = DrawableCompat.wrap(drawable.mutate());
+        int color = ContextCompat.getColor(context, VALUE.resourceId);
+        DrawableCompat.setTint(drawable, color);
+        return drawable;
     }
 
-    Drawable drawable = ContextCompat.getDrawable(context, id);
-    drawable = DrawableCompat.wrap(drawable.mutate());
-    int color = ContextCompat.getColor(context, VALUE.resourceId);
-    DrawableCompat.setTint(drawable, color);
-    return drawable;
-  }
-
-  @UiThread // Implicit synchronization for use of shared resource VALUE.
-  public static float getFloat(Context context, @DimenRes int id) {
-    TypedValue value = VALUE;
-    context.getResources().getValue(id, value, true);
-    if (value.type == TypedValue.TYPE_FLOAT) {
-      return value.getFloat();
+    @UiThread // Implicit synchronization for use of shared resource VALUE.
+    public static float getFloat(Context context, @DimenRes int id) {
+        TypedValue value = VALUE;
+        context.getResources().getValue(id, value, true);
+        if (value.type == TypedValue.TYPE_FLOAT) {
+            return value.getFloat();
+        }
+        throw new Resources.NotFoundException("Resource ID #0x" + Integer.toHexString(id)
+                + " type #0x" + Integer.toHexString(value.type) + " is not valid");
     }
-    throw new Resources.NotFoundException("Resource ID #0x" + Integer.toHexString(id)
-        + " type #0x" + Integer.toHexString(value.type) + " is not valid");
-  }
-
-  @SafeVarargs
-  public static <T> T[] arrayOf(T... views) {
-    return filterNull(views);
-  }
-
-  @SafeVarargs
-  public static <T> List<T> listOf(T... views) {
-    return new ImmutableList<>(filterNull(views));
-  }
-
-  private static <T> T[] filterNull(T[] views) {
-    int end = 0;
-    int length = views.length;
-    for (int i = 0; i < length; i++) {
-      T view = views[i];
-      if (view != null) {
-        views[end++] = view;
-      }
+
+    @SafeVarargs
+    public static <T> T[] arrayOf(T... views) {
+        return filterNull(views);
     }
-    if (end == length) {
-      return views;
+
+    @SafeVarargs
+    public static <T> List<T> listOf(T... views) {
+        return new ImmutableList<>(filterNull(views));
     }
-    //noinspection unchecked
-    T[] newViews = (T[]) Array.newInstance(views.getClass().getComponentType(), end);
-    System.arraycopy(views, 0, newViews, 0, end);
-    return newViews;
-  }
-
-  public static <T> T findOptionalViewAsType(View source, @IdRes int id, String who,
-      Class<T> cls) {
-    View view = source.findViewById(id);
-    return castView(view, id, who, cls);
-  }
-
-  public static View findRequiredView(View source, @IdRes int id, String who) {
-    View view = source.findViewById(id);
-    if (view != null) {
-      return view;
+
+    private static <T> T[] filterNull(T[] views) {
+        int end = 0;
+        int length = views.length;
+        for (int i = 0; i < length; i++) {
+            T view = views[i];
+            if (view != null) {
+                views[end++] = view;
+            }
+        }
+        if (end == length) {
+            return views;
+        }
+        //noinspection unchecked
+        T[] newViews = (T[]) Array.newInstance(views.getClass().getComponentType(), end);
+        System.arraycopy(views, 0, newViews, 0, end);
+        return newViews;
     }
-    String name = getResourceEntryName(source, id);
-    throw new IllegalStateException("Required view '"
-        + name
-        + "' with ID "
-        + id
-        + " for "
-        + who
-        + " was not found. If this view is optional add '@Nullable' (fields) or '@Optional'"
-        + " (methods) annotation.");
-  }
-
-  public static <T> T findRequiredViewAsType(View source, @IdRes int id, String who,
-      Class<T> cls) {
-    View view = findRequiredView(source, id, who);
-    return castView(view, id, who, cls);
-  }
-
-  public static <T> T castView(View view, @IdRes int id, String who, Class<T> cls) {
-    try {
-      return cls.cast(view);
-    } catch (ClassCastException e) {
-      String name = getResourceEntryName(view, id);
-      throw new IllegalStateException("View '"
-          + name
-          + "' with ID "
-          + id
-          + " for "
-          + who
-          + " was of the wrong type. See cause for more info.", e);
+
+    public static <T> T findOptionalViewAsType(View source, @IdRes int id, String who,
+                                               Class<T> cls) {
+        View view = source.findViewById(id);
+        return castView(view, id, who, cls);
     }
-  }
-
-  public static <T> T castParam(Object value, String from, int fromPos, String to, int toPos,
-      Class<T> cls) {
-    try {
-      return cls.cast(value);
-    } catch (ClassCastException e) {
-      throw new IllegalStateException("Parameter #"
-          + (fromPos + 1)
-          + " of method '"
-          + from
-          + "' was of the wrong type for parameter #"
-          + (toPos + 1)
-          + " of method '"
-          + to
-          + "'. See cause for more info.", e);
+
+    public static View findRequiredView(View source, @IdRes int id, String who) {
+        View view = source.findViewById(id);
+        if (view != null) {
+            return view;
+        }
+        String name = getResourceEntryName(source, id);
+        throw new IllegalStateException("Required view '"
+                + name
+                + "' with ID "
+                + id
+                + " for "
+                + who
+                + " was not found. If this view is optional add '@Nullable' (fields) or '@Optional'"
+                + " (methods) annotation.");
     }
-  }
 
-  private static String getResourceEntryName(View view, @IdRes int id) {
-    if (view.isInEditMode()) {
-      return "<unavailable while editing>";
+    public static <T> T findRequiredViewAsType(View source, @IdRes int id, String who,
+                                               Class<T> cls) {
+        View view = findRequiredView(source, id, who);
+        return castView(view, id, who, cls);
     }
-    return view.getContext().getResources().getResourceEntryName(id);
-  }
 
-  private Utils() {
-    throw new AssertionError("No instances.");
-  }
+    public static <T> T castView(View view, @IdRes int id, String who, Class<T> cls) {
+        try {
+            return cls.cast(view);
+        } catch (ClassCastException e) {
+            String name = getResourceEntryName(view, id);
+            throw new IllegalStateException("View '"
+                    + name
+                    + "' with ID "
+                    + id
+                    + " for "
+                    + who
+                    + " was of the wrong type. See cause for more info.", e);
+        }
+    }
+
+    public static <T> T castParam(Object value, String from, int fromPos, String to, int toPos,
+                                  Class<T> cls) {
+        try {
+            return cls.cast(value);
+        } catch (ClassCastException e) {
+            throw new IllegalStateException("Parameter #"
+                    + (fromPos + 1)
+                    + " of method '"
+                    + from
+                    + "' was of the wrong type for parameter #"
+                    + (toPos + 1)
+                    + " of method '"
+                    + to
+                    + "'. See cause for more info.", e);
+        }
+    }
+
+    private static String getResourceEntryName(View view, @IdRes int id) {
+        if (view.isInEditMode()) {
+            return "<unavailable while editing>";
+        }
+        return view.getContext().getResources().getResourceEntryName(id);
+    }
+
+    private Utils() {
+        throw new AssertionError("No instances.");
+    }
 }
