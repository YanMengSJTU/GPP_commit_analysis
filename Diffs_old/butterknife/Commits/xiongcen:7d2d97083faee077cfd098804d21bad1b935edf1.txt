diff --git a/build.gradle b/build.gradle
index 42dd66f8..4f914c14 100644
--- a/build.gradle
+++ b/build.gradle
@@ -37,7 +37,7 @@ subprojects { project ->
       }
     }
     dependencies {
-      classpath 'com.android.tools.build:gradle:2.2.2'
+      classpath 'com.android.tools.build:gradle:2.2.3'
       classpath 'gradle.plugin.com.kageiit:lintrules:1.1.2'
     }
   }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
index 02d69fba..2d6dd16a 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
@@ -88,11 +88,13 @@ JavaFile brewJava(int sdk) {
 
   private TypeSpec createType(int sdk) {
     TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
+        // 添加修饰符为 public，生成的类是 public 的
         .addModifiers(PUBLIC);
     if (isFinal) {
       result.addModifiers(FINAL);
     }
 
+    /** 其实 Bind 过程也是有继承关系的，我有一个 Activity A 有注入，另一个 B 继承它，那么生成注入 B 的成员的代码时，就要把 A 的注入一起捎上 */
     if (parentBinding != null) {
       result.superclass(parentBinding.bindingClassName);
     } else {
@@ -103,6 +105,7 @@ private TypeSpec createType(int sdk) {
       result.addField(targetTypeName, "target", PRIVATE);
     }
 
+    // 这里的代码很关键，我们的绝大多数注入用到的代码都在这里了
     if (isView) {
       result.addMethod(createBindingConstructorForView());
     } else if (isActivity) {
@@ -120,6 +123,7 @@ private TypeSpec createType(int sdk) {
       result.addMethod(createBindingUnbindMethod(result));
     }
 
+    // 输出一个BingdingSet对象
     return result.build();
   }
 
@@ -138,6 +142,7 @@ private MethodSpec createBindingViewDelegateConstructor() {
   }
 
   private MethodSpec createBindingConstructorForView() {
+    // 创建构造函数
     MethodSpec.Builder builder = MethodSpec.constructorBuilder()
         .addAnnotation(UI_THREAD)
         .addModifiers(PUBLIC)
@@ -224,6 +229,8 @@ private MethodSpec createBindingConstructor(int sdk) {
     if (hasViewBindings()) {
       if (hasViewLocal()) {
         // Local variable in which all views will be temporarily stored.
+        /** 这里就是注入 view了，addViewBindings 这个方法其实就生成功能上类似
+        TextView textView = (TextView) findViewById(...) 的代码 */
         constructor.addStatement("$T view", VIEW);
       }
       for (ViewBinding binding : viewBindings) {
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index 20900661..cc1af822 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -177,14 +177,17 @@
   }
 
   @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+    // 解析注解
     Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
 
+    // 解析完成以后，需要生成的代码结构已经都有了，它们都存在于每一个 BindingSet 当中
     for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
       TypeElement typeElement = entry.getKey();
       BindingSet binding = entry.getValue();
 
       JavaFile javaFile = binding.brewJava(sdk);
       try {
+        // 这一步完成真正的代码生成
         javaFile.writeTo(filer);
       } catch (IOException e) {
         error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
@@ -409,6 +412,7 @@ private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder>
       Set<TypeElement> erasedTargetNames) {
     TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
+    // 检验 element 是否符合条件
     // Start by verifying common generated code restrictions.
     boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
         || isBindingInWrongPackage(BindView.class, element);
@@ -467,6 +471,7 @@ private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder
       Set<TypeElement> erasedTargetNames) {
     TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
+    // 检验 element 是否符合条件
     // Start by verifying common generated code restrictions.
     boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
         || isBindingInWrongPackage(BindViews.class, element);
@@ -493,6 +498,7 @@ private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder
       }
       kind = FieldCollectionViewBinding.Kind.LIST;
     } else {
+      // 显然这里被注入的对象类型不能是 Iterable，List 除外~
       error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
           enclosingElement.getQualifiedName(), element.getSimpleName());
       hasError = true;
@@ -503,6 +509,7 @@ private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder
     }
 
     // Verify that the target type extends from View.
+    // 验证被注入的是View的子类
     if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
       if (viewType.getKind() == TypeKind.ERROR) {
         note(element, "@%s List or array with unresolved type (%s) "
@@ -519,6 +526,7 @@ private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder
 
     // Assemble information on the field.
     String name = element.getSimpleName().toString();
+    // 以前已经确认是单值绑定，所以出现了参数为0个的情况就报错
     int[] ids = element.getAnnotation(BindViews.class).value();
     if (ids.length == 0) {
       error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
@@ -546,7 +554,7 @@ private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder
     for (int id : ids) {
       idVars.add(getId(id));
     }
-
+    // 根据注解信息来生成注入关系，并添加到builderMap中
     BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
     builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required));
 
diff --git a/butterknife/src/main/java/butterknife/ButterKnife.java b/butterknife/src/main/java/butterknife/ButterKnife.java
index aa2db57c..5d6c86ca 100644
--- a/butterknife/src/main/java/butterknife/ButterKnife.java
+++ b/butterknife/src/main/java/butterknife/ButterKnife.java
@@ -216,26 +216,31 @@ private static Unbinder createBinding(@NonNull Object target, @NonNull View sour
   @Nullable @CheckResult @UiThread
   private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
     Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
+    // 先找缓存
     if (bindingCtor != null) {
       if (debug) Log.d(TAG, "HIT: Cached in binding map.");
       return bindingCtor;
     }
+    // 检查下是否支持这个类
     String clsName = cls.getName();
     if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
       if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
       return null;
     }
     try {
+      // 找到类名为Activity的类名+"_ViewBinding"的类，实例化，并返回
       Class<?> bindingClass = Class.forName(clsName + "_ViewBinding");
       //noinspection unchecked
       bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
       if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
     } catch (ClassNotFoundException e) {
       if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
+      // 注意这里支持了继承关系
       bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
     } catch (NoSuchMethodException e) {
       throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
     }
+    // 缓存 bindingCtor
     BINDINGS.put(cls, bindingCtor);
     return bindingCtor;
   }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a65e9c08..4c9056e7 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
