diff --git a/butterknife/src/main/java/butterknife/ButterKnife.java b/butterknife/src/main/java/butterknife/ButterKnife.java
index acd68ed9..5c0bb5be 100644
--- a/butterknife/src/main/java/butterknife/ButterKnife.java
+++ b/butterknife/src/main/java/butterknife/ButterKnife.java
@@ -19,6 +19,8 @@
 /**
  * Field and method binding for Android views. Use this class to simplify finding views and
  * attaching listeners by binding them with annotations.
+ * 成员变量与方法的注解针对Android中的View  使用这个类简化寻找视图以及
+ * 附加监听器  通过给监听器添加上相应的注解
  * <p>
  * Finding views from your activity is as easy as:
  * <pre><code>
@@ -79,23 +81,28 @@
  * </code></pre>
  */
 public final class ButterKnife {
+  //创建实体对象的方法不向外暴露
   private ButterKnife() {
     throw new AssertionError("No instances.");
   }
 
   /** An unbinder contract that can be bind with {@link butterknife.Unbinder}. */
   @SuppressWarnings("unused") // Used by generated code.
+  //解绑定的接口
   public interface Unbinder {
     void unbind();
   }
 
   /** An action that can be applied to a list of views. */
+  //内部支持的数据结构是继承View的数据类型
   public interface Action<T extends View> {
     /** Apply the action on the {@code view} which is at {@code index} in the list. */
+    //将这个action应用到在指定索引的集合中的View的元素
     void apply(@NonNull T view, int index);
   }
 
   /** A setter that can apply a value to a list of views. */
+  //这是一个setter方法 能够将一个数值设置给一个集合视图中的指定索引的元素
   public interface Setter<T extends View, V> {
     /** Set the {@code value} on the {@code view} which is at {@code index} in the list. */
     void set(@NonNull T view, V value, int index);
@@ -104,7 +111,9 @@ private ButterKnife() {
   private static final String TAG = "ButterKnife";
   private static boolean debug = false;
 
+  //HashMap 是 Class与 ViewBinder之间的匹配
   static final Map<Class<?>, ViewBinder<Object>> BINDERS = new LinkedHashMap<>();
+  //实现一个ViewBinder的接口 但是方法体内是空得实现
   static final ViewBinder<Object> NOP_VIEW_BINDER = new ViewBinder<Object>() {
     @Override public void bind(Finder finder, Object target, Object source) { }
   };
@@ -116,9 +125,10 @@ public static void setDebug(boolean debug) {
 
   /**
    * Bind annotated fields and methods in the specified {@link Activity}. The current content
+   * 绑定注解的成员变量与方法在指定的Activity中  这个目前的View内容被当做view的根节点
    * view is used as the view root.
    *
-   * @param target Target activity for view binding.
+   * @param target Target activity for view binding. 为了绑定view的目标的节点
    */
   public static void bind(@NonNull Activity target) {
     bind(target, target, Finder.ACTIVITY);
@@ -127,7 +137,7 @@ public static void bind(@NonNull Activity target) {
   /**
    * Bind annotated fields and methods in the specified {@link View}. The view and its children
    * are used as the view root.
-   *
+   * 绑定拥有注解的成员变量以及方法在指定的View中  这个View以及他得子节点被用来作为View的父节点
    * @param target Target view for view binding.
    */
   @NonNull
@@ -184,10 +194,13 @@ public static void bind(@NonNull Object target, @NonNull Dialog source) {
   }
 
   static void bind(@NonNull Object target, @NonNull Object source, @NonNull Finder finder) {
+    //首先通过反射机制 找到注解目标上面的类的
     Class<?> targetClass = target.getClass();
     try {
       if (debug) Log.d(TAG, "Looking up view binder for " + targetClass.getName());
+      //为指定的Class找到对应的ViewBinder的对象
       ViewBinder<Object> viewBinder = findViewBinderForClass(targetClass);
+      //然后调用viewBinder的bind方法去做绑定
       viewBinder.bind(finder, target, source);
     } catch (Exception e) {
       throw new RuntimeException("Unable to bind views for " + targetClass.getName(), e);
@@ -197,30 +210,37 @@ static void bind(@NonNull Object target, @NonNull Object source, @NonNull Finder
   @NonNull
   private static ViewBinder<Object> findViewBinderForClass(Class<?> cls)
       throws IllegalAccessException, InstantiationException {
+    //从HashMap中找到对应的ViewBinder的对象
     ViewBinder<Object> viewBinder = BINDERS.get(cls);
     if (viewBinder != null) {
       if (debug) Log.d(TAG, "HIT: Cached in view binder map.");
       return viewBinder;
     }
+    //如果缓存中没有
     String clsName = cls.getName();
+    //如果包名是系统框架  禁止搜索  返回一个空实现的NOP_VIEW_BINDER
     if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
       if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
       return NOP_VIEW_BINDER;
     }
     try {
+      //找到对应的类的内部类的ViewBinder的实现
       Class<?> viewBindingClass = Class.forName(clsName + "$$ViewBinder");
       //noinspection unchecked
+      //创建对应的ViewBinder的对象实例
       viewBinder = (ViewBinder<Object>) viewBindingClass.newInstance();
       if (debug) Log.d(TAG, "HIT: Loaded view binder class.");
     } catch (ClassNotFoundException e) {
       if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
       viewBinder = findViewBinderForClass(cls.getSuperclass());
     }
+    //同时将其加入到缓存中
     BINDERS.put(cls, viewBinder);
     return viewBinder;
   }
 
   /** Apply the specified {@code actions} across the {@code list} of views. */
+  //将指定的action应用到View得集合
   @SafeVarargs public static <T extends View> void apply(@NonNull List<T> list,
       @NonNull Action<? super T>... actions) {
     for (int i = 0, count = list.size(); i < count; i++) {
diff --git a/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java b/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
index c9c73a84..d6b243bc 100644
--- a/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
+++ b/butterknife/src/main/java/butterknife/internal/DebouncingOnClickListener.java
@@ -6,6 +6,8 @@
  * A {@linkplain View.OnClickListener click listener} that debounces multiple clicks posted in the
  * same frame. A click on one button disables all buttons for that frame.
  */
+//在相同的数据帧 禁止View在一段时间内被多次点击
+  //这是一个抽象类
 public abstract class DebouncingOnClickListener implements View.OnClickListener {
   private static boolean enabled = true;
 
diff --git a/butterknife/src/main/java/butterknife/internal/Finder.java b/butterknife/src/main/java/butterknife/internal/Finder.java
index effd6de4..59e10fb3 100644
--- a/butterknife/src/main/java/butterknife/internal/Finder.java
+++ b/butterknife/src/main/java/butterknife/internal/Finder.java
@@ -6,8 +6,11 @@
 import android.view.View;
 
 @SuppressWarnings("UnusedDeclaration") // Used by generated code.
+//由自动生成代码的框架使用
+//定义了框架的几个大类的枚举   每一个枚举实现了枚举类内部定义的方法
 public enum Finder {
   VIEW {
+      //对在View中寻找View的方法进行重写
     @Override protected View findView(Object source, int id) {
       return ((View) source).findViewById(id);
     }
@@ -19,6 +22,7 @@
     @Override protected String getResourceEntryName(Object source, int id) {
       final View view = (View) source;
       // In edit mode, getResourceEntryName() is unsupported due to use of BridgeResources
+        //在编辑模式下 getResourceEntryName由于桥接资源的使用  是不被支持的
       if (view.isInEditMode()) {
         return "<unavailable while editing>";
       }
@@ -26,6 +30,7 @@
     }
   },
   ACTIVITY {
+      //定义了Activity findViewById
     @Override protected View findView(Object source, int id) {
       return ((Activity) source).findViewById(id);
     }
@@ -44,6 +49,8 @@
     }
   };
 
+    //对于枚举类自身而言  定义的是泛型  其内部每一个单独的枚举能够对已经定义的方法额模板进行重载
+
   public <T> T findRequiredView(Object source, int id, String who) {
     T view = findOptionalView(source, id, who);
     if (view == null) {
@@ -59,7 +66,7 @@
     }
     return view;
   }
-
+    //通过可选择的View 来找到真正的获取View的方式
   public <T> T findOptionalView(Object source, int id, String who) {
     View view = findView(source, id);
     return castView(view, id, who);
@@ -101,11 +108,14 @@
     }
   }
 
+    //抽象类
   protected String getResourceEntryName(Object source, int id) {
     return getContext(source).getResources().getResourceEntryName(id);
   }
 
+    //抽象方法 findView
   protected abstract View findView(Object source, int id);
 
+    //抽象方法获取getContext
   public abstract Context getContext(Object source);
 }
diff --git a/butterknife/src/main/java/butterknife/internal/ImmutableList.java b/butterknife/src/main/java/butterknife/internal/ImmutableList.java
index 35129842..f0360604 100644
--- a/butterknife/src/main/java/butterknife/internal/ImmutableList.java
+++ b/butterknife/src/main/java/butterknife/internal/ImmutableList.java
@@ -5,8 +5,10 @@
 
 /**
  * An immutable list of views which is lighter than {@code
+ * 一个不可改变的view的列表的集合比Collections.unmodifiableList要轻量级一些
  * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(foo, bar)))}.
  */
+//支持快速随机访问   因为没有提供add与set方法  所以说是不可改变的
 final class ImmutableList<T> extends AbstractList<T> implements RandomAccess {
   private final T[] views;
 
diff --git a/butterknife/src/main/java/butterknife/internal/Utils.java b/butterknife/src/main/java/butterknife/internal/Utils.java
index cd158d50..75783b8d 100644
--- a/butterknife/src/main/java/butterknife/internal/Utils.java
+++ b/butterknife/src/main/java/butterknife/internal/Utils.java
@@ -14,10 +14,12 @@
 
 @SuppressWarnings("deprecation") //
 public final class Utils {
+  //判断是否是支持v4包
   private static final boolean HAS_SUPPORT_V4 = hasSupportV4();
 
   private static boolean hasSupportV4() {
     try {
+      //通过反射判断有相应的class
       Class.forName("android.support.v4.graphics.drawable.DrawableCompat");
       return true;
     } catch (ClassNotFoundException ignored) {
@@ -27,6 +29,7 @@ private static boolean hasSupportV4() {
 
   public static Drawable getTintedDrawable(Resources res, Resources.Theme theme,
       @DrawableRes int id, @AttrRes int tintAttrId) {
+    //这个功能是需要v4进行支持的
     if (HAS_SUPPORT_V4) {
       return SupportV4.getTintedDrawable(res, theme, id, tintAttrId);
     }
diff --git a/butterknife/src/main/java/butterknife/internal/ViewBinder.java b/butterknife/src/main/java/butterknife/internal/ViewBinder.java
index f0234899..2c602293 100644
--- a/butterknife/src/main/java/butterknife/internal/ViewBinder.java
+++ b/butterknife/src/main/java/butterknife/internal/ViewBinder.java
@@ -1,5 +1,6 @@
 package butterknife.internal;
-
+//定义绑定视图的ViewBinder 同时是支持泛型的
 public interface ViewBinder<T> {
+  //有三个参数
   void bind(Finder finder, T target, Object source);
 }
