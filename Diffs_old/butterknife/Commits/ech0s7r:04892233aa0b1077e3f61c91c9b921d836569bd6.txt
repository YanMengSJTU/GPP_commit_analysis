diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 00000000..8d8f6cb8
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="JakeWharton/butterknife"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  ./gradlew uploadArchives
+  echo "Snapshot deployed!"
+fi
diff --git a/.gitignore b/.gitignore
index 133735f7..49cdbbe4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,18 +1,8 @@
-.classpath
-.project
-.settings
-eclipsebin
-
 bin
 gen
-build
 out
 lib
 
-target
-pom.xml.*
-release.properties
-
 .idea
 *.iml
 classes
@@ -20,3 +10,10 @@ classes
 obj
 
 .DS_Store
+
+# Gradle
+.gradle
+jniLibs
+build
+local.properties
+reports
diff --git a/.travis.yml b/.travis.yml
index 5b9b4762..31ff57fe 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,15 +1,36 @@
 language: android
 
 jdk:
- - oraclejdk7
- - oraclejdk8
+  - oraclejdk8
 
-android:
-  components:
-    - build-tools-20.0.0
-    - android-16
-  licenses:
-    - android-sdk-license-5be876d5
+before_install:
+  # Install SDK license so Android Gradle plugin can install deps.
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" >> "$ANDROID_HOME/licenses/android-sdk-license"
+  # Install the rest of tools (e.g., avdmanager)
+  - sdkmanager tools
+  # Install the system image
+  - sdkmanager "system-images;android-18;default;armeabi-v7a"
+  # Create and start emulator for the script. Meant to race the install task.
+  - echo no | avdmanager create avd --force -n test -k "system-images;android-18;default;armeabi-v7a"
+  - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
+
+install: ./gradlew clean assemble assembleAndroidTest --stacktrace
+
+before_script:
+  - android-wait-for-emulator
+  - adb shell input keyevent 82
+
+script: ./gradlew check connectedCheck --stacktrace
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "ESbreW4FNMPQhV1zbFb9iBvhFWFbVHecaig3Si3+4nrJCMn9x4nqB18ZcU+Aviw67WQNcuSH4I0Hl08uknl+kzE/xKEfPLmu28bptXRCSued49aL11i2aQmRj5nqP2yxkinhtRGOQxzIo56NmFt7sIcEXODM3D5a6q7s9tlvPfw="
+    - secure: "JWEeqx0CWBqAkjcREHUg3Ei8wxqp59HZag8EidSLwmekgPJQwipwuEeXMZyPCGJCP+4ijUirtS/hRApi37BW0LYdt+XR7dI1TSZ0HFLTLqSPfWfsUcjmGpmoqVUv8FLVhC+KA42YeEhqkEaCUW92gJeAyK8swxDqGHAPT/sfKRA="
 
 branches:
   except:
@@ -17,3 +38,15 @@ branches:
 
 notifications:
   email: false
+
+sudo: false
+
+before_cache:
+  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
+
+cache:
+  directories:
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
+    - $HOME/.android/build-cache
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e7cd9259..5a78f11c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,287 @@
 Change Log
 ==========
 
+Version 10.1.0 *(2019-02-13)*
+-----------------------------
+
+ * New: Listeners which require return values (e.g., long click) can now be bound to methods returning `void`.
+   The default value of `true` will be returned in this case.
+ * New: Add support for `@OnTextChanged` and `@OnPageChange` to reflection backend.
+ * Remove enforcement of required views in the reflection backend. Most `@Nullable` annotations do not have
+   runtime retention so they can't be checked at runtime with reflection. Instead of forcing everyone to find
+   a new annotation, this enforcement is now dropped. While this might lead to nulls in otherwise required
+   view bindings, they'll either be unused or quickly cause a `NullPointerException`.
+
+
+Version 10.0.0 *(2019-01-03)*
+-----------------------------
+
+ * Equivalent to 9.0.0 but only supports AndroidX-enabled builds.
+ * Removed APIs deprecated in 9.0.0.
+
+
+Version 9.0.0 *(2019-01-03)*
+----------------------------
+
+ * New: Support for AndroidX. Requires `android.useAndroidX=true` in `gradle.properties` to generate
+   AndroidX code.
+
+ * New: A `butterknife-runtime` artifact has been extracted from `butterknife` which contains the APIs
+   required for the generated code but does not contain the code to reflectively look up the generated
+   code. This allows you to reference the generated code directly such that R8/ProGuard optimization can
+   rename both the generated code and your classes. `ButterKnife.bind` and the consumer R8/ProGuard rules
+   remain in the old `butterknife` artifact.
+ 
+ * New: Experimental `butterknife-reflect` artifact eliminates the need to run the annotation
+   processor for IDE builds. This artifact is binary compatible with `butterknife` so it can be interchanged
+   depending on how your build is being invoked. See [its README](butterknife-reflect/README.md) for more
+   information. Currently about 90% of functionality is covered. File bugs for anything that does not work.
+
+   Note: This artifact requires Java 8. There's no good reason for this except to push the ecosystem to
+   having this be a default. As of AGP 3.2 there is no reason not to do this.
+
+ * New: Lint checks have been ported to UAST and now work on Kotlin code.
+ 
+ * Helpers such as `apply` have been deprecated on `ButterKnife` and are now available on the `ViewCollections` class.
+
+ * Add support for Android Gradle plugin 3.3 and newer where `R` is no longer generated as Java source. This
+   has a side-effect of removing support for Android Gradle plugin 3.0.x (and older).
+ * Use Java 8 bytecode for all artifacts as announced in RC1 release notes.
+ * Fix: Allow `@BindFont` to work prior to API 26 using `ResourcesCompat`.
+ * Fix: Update Android Gradle plugin to 3.1 or newer to fix binary incompatibilities.
+ * Fix: Correct generated resource annotation names when running Turkish locale.
+ * Fix: Use the application ID instead of the resource package for generating `R2`.
+ * Cache the fact that a class hierarchy has no remaining bindings to prevent traversing the hierarchy
+   multiple times.
+ * Deprecated methods from 8.x have been removed.
+
+
+Version 9.0.0-rc3 *(2018-12-20)*
+--------------------------------
+
+ * Fix: Correct generated resource annotation names when running Turkish locale.
+ * Cache the fact that a class hierarchy has no remaining bindings to prevent traversing the hierarchy
+   multiple times.
+
+
+Version 9.0.0-rc2 *(2018-11-19)*
+--------------------------------
+
+ * Add support for Android Gradle plugin 3.3 and newer where `R` is no longer generated as Java source. This
+   has a side-effect of removing support for Android Gradle plugin 3.0.x (and older).
+ * Use Java 8 bytecode for all artifacts as announced in RC1 release notes.
+
+
+Version 9.0.0-rc1 *(2018-10-10)*
+--------------------------------
+
+ * New: Support for AndroidX. Requires `android.useAndroidX=true` in `gradle.properties` to generate
+   AndroidX code.
+
+ * New: A `butterknife-runtime` artifact has been extracted from `butterknife` which contains the APIs
+   required for the generated code but does not contain the code to reflectively look up the generated
+   code. This allows you to reference the generated code directly such that R8/ProGuard optimization can
+   rename both the generated code and your classes. `ButterKnife.bind` and the consumer R8/ProGuard rules
+   remain in the old `butterknife` artifact.
+ 
+ * New: Experimental `butterknife-reflect` artifact eliminates the need to run the annotation
+   processor for IDE builds. This artifact is binary compatible with `butterknife` so it can be interchanged
+   depending on how your build is being invoked. See [its README](butterknife-reflect/README.md) for more
+   information. Currently about 90% of functionality is covered. File bugs for anything that does not work.
+
+   Note: This artifact requires Java 8. There's no good reason for this except to push the ecosystem to
+   having this be a default. As of AGP 3.2 there is no reason not to do this.
+
+ * New: Lint checks have been ported to UAST and now work on Kotlin code.
+
+ * Fix: Allow `@BindFont` to work prior to API 26 using `ResourcesCompat`.
+ * Fix: Update Android Gradle plugin to 3.1 or newer to fix binary incompatibilities.
+ * Fix: Use the application ID instead of the resource package for generating `R2`.
+ * Deprecated methods from 8.x have been removed.
+
+Note: The next release candidate will switch all artifacts to require Java 8 bytecode which will force
+your applications to enable Java 8 bytecode. As of AGP 3.2 there is no cost to this, and there is no
+reason to have it set any lower.
+
+
+Version 8.8.1 *(2017-08-09)*
+----------------------------
+
+ * Fix: Properly emit casts for single-bound view subtypes when `butterknife.debuggable` is set to `false`.
+
+
+Version 8.8.0 *(2017-08-04)*
+----------------------------
+
+ * New: Processor option `butterknife.debuggable` controls whether debug information is generated. When
+   specified as `false`, checks for required views being non-null are elided and casts are no longer guarded
+   with user-friendly error messages. This reduces the amount of generated code for release builds at the
+   expense of less friendly exceptions when something breaks.
+ * Deprecate the `findById` methods. Compile against API 26 and use the normal `findViewById` for the same
+   functionality.
+ * Fix: Correct `@BindFont` code generation on pre-API 26 builds to pass a `Context` (not a `Resources`) to
+   `ResourceCompat`.
+
+
+Version 8.7.0 *(2017-07-07)*
+----------------------------
+
+ * New: `@BindFont` annotation binds `Typeface` instances with an optional style. Requires support libraries
+   26.0.0-beta1 or newer.
+ * New: `@BindAnim` annotation binds `Animation` instances.
+ * New: Generate `R2` constants for animation, layout, menu, plurals, styles, and styleables.
+ * Fix: Properly catch and re-throw type cast exceptions when method binding arguments do not match.
+
+
+Version 8.6.0 *(2017-05-16)*
+----------------------------
+
+ * Plugin was ported to Kotlin and updated to support future Android Gradle plugin versions.
+ * Fix: Properly handle multiple library modules using Butter Knife and defining the same ID.
+ * Fix: Use the same classloader of the binding target to load the generated view binding class.
+
+
+Version 8.5.1 *(2017-01-24)*
+----------------------------
+
+ * Fix: Tweak bundled ProGuard rules to only retain the two-argument constructor accessed via reflection.
+
+
+Version 8.5.0 *(2017-01-23)*
+----------------------------
+
+ * Emit `@SuppressLint` when using `@OnTouch` to avoid a lint warning.
+ * Migrate lint checks from Lombok AST to JetBrains PSI.
+ * Annotations are no longer claimed by the processor.
+ * Based on the minimum SDK version (as specified by `butterknife.minSdk` until http://b.android.com/187527 is
+   released) the generated code now changes to use newer APIs when available.
+ * Generated classes now include single-argument overloads for `View`, `Activity`, and `Dialog` subclasses.
+ * Generated classes are no longer generic.
+ * Minimum supported SDK is now 9.
+
+
+Version 8.4.0 *(2016-08-26)*
+----------------------------
+
+ * New: `@BindFloat` annotation for dimensions whose format is of type 'float'. See the annotation for more
+   information.
+ * Generated constructors are now annotated with `@UiThread` and non-final, base classes `unbind()` methods
+   are annotated with `@CallSuper`.
+
+
+Version 8.3.0 *(2016-08-23)*
+----------------------------
+
+ * New: Support for Jack compiler in application projects.
+ * Fix: Generate ~20% less code and ~40% less methods.
+ * Fix: Allow `@BindView` to reference types which are generated by other annotation processors.
+ * Experimental: The generated view binding class can now be used directly. This allows ProGuard shrinking,
+   optimization, and obfuscation to work without any rules being needed. For a class `Test`, the binding
+   class will be named `Test_ViewBinding`. Calling its constructor will bind the instance passed in, and
+   the create object is also the implementation of `Unbinder` that can be used to unbind the views.
+   Note: The API of this generated code is subject to backwards-incompatible changes until v9.0.
+
+
+Version 8.2.1 *(2016-07-11)*
+----------------------------
+
+ * Fix: Do not emit `android.R` imports in generated code.
+ * Fix: Ensure the processor does not crash when scanning for `R` classes. This can occur when used in a
+   Kotlin project.
+
+
+Version 8.2.0 *(2016-07-10)*
+----------------------------
+
+ * New: Support for library projects. Requires application of a Butter Knife Gradle plugin. See README for
+   details.
+ * New: Generated code now emits `R` references instead of raw integer IDs.
+ * Fix: `@OnPageChange` listener binding now uses the 'add'/'remove' methods on `ViewPager` instead of 'set'.
+
+
+Version 8.1.0 *(2016-06-14)*
+----------------------------
+
+ * New: Change the structure of generated view binders to optimize for performance and generated code. This
+   should result in faster binding (not that it's slow) and a reduction of methods.
+ * Fix: Call the correct method on `TextView` to unbind `@OnTextChanged` uses.
+ * Fix: Properly handle package names which contain uppercase letters.
+
+
+Version 8.0.1 *(2016-04-27)*
+----------------------------
+
+ * Fix: ProGuard rules now prevent obfuscation of only types which reference ButterKnife annotations.
+ * Eliminate some of the generated machinery when referenced from `final` types.
+
+
+Version 8.0.0 *(2016-04-25)*
+----------------------------
+
+ *  `@Bind` becomes `@BindView` and `@BindViews` (one view and multiple views, respectively).
+ *  Calls to `bind` now return an `Unbinder` instance which can be used to `null` references. This replaces
+    the `unbind` API and adds support for being able to clear listeners.
+ *  New: `@BindArray` binds `String`, `CharSequence`, and `int` arrays and `TypeArray` to fields.
+ *  New: `@BindBitmap` binds `Bitmap` instances from resources to fields.
+ *  `@BindDrawable` now supports a `tint` field which accepts a theme attribute.
+ *  The runtime and compiler are now split into two artifacts.
+
+    ```groovy
+    compile 'com.jakewharton:butterknife:8.0.0'
+    apt 'com.jakewharton:butterknife-compiler:8.0.0'
+    ```
+ *  New: `apply` overloads which accept a single view and arrays of views.
+ *  ProGuard rules now ship inside of the library and are included automatically.
+ *  `@Optional` annotation is back to mark methods as being optional.
+
+
+Version 7.0.1 *(2015-06-30)*
+----------------------------
+
+ * Fix: Correct `ClassCastException` which occurred when `@Nullable` array bindings had missing views.
+
+
+Version 7.0.0 *(2015-06-27)*
+----------------------------
+
+ * `@Bind` replaces `@InjectView` and `@InjectViews`.
+ * `ButterKnife.bind` and `ButterKnife.unbind` replaces `ButterKnife.inject` and `ButterKnife.reset`, respectively.
+ * `@Optional` has been removed. Use `@Nullable` from the 'support-annotations' library, or any other annotation
+   named "Nullable".
+ * New: Resource binding annotations!
+   * `@BindBool` binds an `R.bool` ID to a `boolean` field.
+   * `@BindColor` binds an `R.color` ID to an `int` or `ColorStateList` field.
+   * `@BindDimen` binds an `R.dimen` ID to an `int` (for pixel size) or `float` (for exact value) field.
+   * `@BindDrawable` binds an `R.drawable` ID to a `Drawable` field.
+   * `@BindInt` binds an `R.int` ID to an `int` field.
+   * `@BindString` binds an `R.string` ID to a `String` field.
+ * Fix: Missing views will be filtered out from list and array bindings.
+ * Note: If you are using Proguard, the generated class name has changed from being suffixed with `$$ViewInjector`
+   to `$$ViewBinder`.
+
+
+Version 6.1.0 *(2015-01-29)*
+----------------------------
+
+ * New: Support for injecting interface types everywhere that views were previously supported (e.g., `Checkable`).
+ * Eliminate reflection-based method invocation for injection and resetting. This makes performance slightly faster
+   (although if you are worried about the performance of Butter Knife you have other problems). The only reflection
+   in the library is a single `Class.forName` lookup for each type.
+
+
+Version 6.0.0 *(2014-10-27)*
+----------------------------
+
+ * New: Listeners can bind to the root view being injected by omitting a view ID on the annotation.
+ * New: Exceptions thrown from missing views now include the human-readable ID name (e.g., 'button1').
+ * Specifying multiple fields binding to the same ID is now considered an error.
+ * `findById` overload for view lookup on `Dialog` instances.
+ * Experimental: Click listeners are now globally debounced per frame. This means that only a single click
+   will be processed per frame preventing race conditions due to queued input events.
+ * Experimental: Multiple methods can bind to the same listener provided that listener's callback method
+   does not require a return value.
+
+
 Version 5.1.2 *(2014-08-01)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 203cd9d2..4b1a719e 100644
--- a/README.md
+++ b/README.md
@@ -3,18 +3,21 @@ Butter Knife
 
 ![Logo](website/static/logo.png)
 
-View "injection" library for Android which uses annotation processing to generate boilerplate code
-for you.
+Field and method binding for Android views which uses annotation processing to generate boilerplate
+code for you.
 
- * Eliminate `findViewById` calls by using `@InjectView` on fields.
- * Group multiple views in a list using `@InjectViews`. Operate on all of them at once with actions,
+ * Eliminate `findViewById` calls by using `@BindView` on fields.
+ * Group multiple views in a list or array. Operate on all of them at once with actions,
    setters, or properties.
  * Eliminate anonymous inner-classes for listeners by annotating methods with `@OnClick` and others.
+ * Eliminate resource lookups by using resource annotations on fields.
 
 ```java
 class ExampleActivity extends Activity {
-  @InjectView(R.id.user) EditText username;
-  @InjectView(R.id.pass) EditText password;
+  @BindView(R.id.user) EditText username;
+  @BindView(R.id.pass) EditText password;
+
+  @BindString(R.string.login_error) String loginErrorMessage;
 
   @OnClick(R.id.submit) void submit() {
     // TODO call server...
@@ -23,8 +26,8 @@ class ExampleActivity extends Activity {
   @Override public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.simple_activity);
-    ButterKnife.inject(this);
-    // TODO Use "injected" views...
+    ButterKnife.bind(this);
+    // TODO Use fields...
   }
 }
 ```
@@ -38,19 +41,63 @@ __Remember: A butter knife is like [a dagger][1] only infinitely less sharp.__
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.jakewharton</groupId>
-  <artifactId>butterknife</artifactId>
-  <version>5.1.2</version>
-</dependency>
+```groovy
+android {
+  ...
+  // Butterknife requires Java 8.
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+}
+
+dependencies {
+  implementation 'com.jakewharton:butterknife:10.1.0'
+  annotationProcessor 'com.jakewharton:butterknife-compiler:10.1.0'
+}
+```
+
+If you are using Kotlin, replace `annotationProcessor` with `kapt`.
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+
+
+Library projects
+--------------------
+
+To use Butter Knife in a library, add the plugin to your `buildscript`:
+
+```groovy
+buildscript {
+  repositories {
+    mavenCentral()
+    google()
+   }
+  dependencies {
+    classpath 'com.jakewharton:butterknife-gradle-plugin:10.1.0'
+  }
+}
 ```
-or Gradle:
+
+and then apply it in your module:
+
 ```groovy
-compile 'com.jakewharton:butterknife:5.1.2'
+apply plugin: 'com.android.library'
+apply plugin: 'com.jakewharton.butterknife'
 ```
 
+Now make sure you use `R2` instead of `R` inside all Butter Knife annotations.
+
+```java
+class ExampleActivity extends Activity {
+  @BindView(R2.id.user) EditText username;
+  @BindView(R2.id.pass) EditText password;
+...
+}
+```
+
+
 
 License
 -------
@@ -72,5 +119,6 @@ License
 
 
  [1]: http://square.github.com/dagger/
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.jakewharton&a=butterknife&v=LATEST
+ [2]: https://search.maven.org/remote_content?g=com.jakewharton&a=butterknife&v=LATEST
  [3]: http://jakewharton.github.com/butterknife/
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/RELEASING.md b/RELEASING.md
new file mode 100644
index 00000000..9f872c7b
--- /dev/null
+++ b/RELEASING.md
@@ -0,0 +1,16 @@
+Releasing
+========
+
+ 1. Change the version in `gradle.properties` to a non-SNAPSHOT version.
+ 2. Update the `CHANGELOG.md` for the impending release.
+ 3. Update the `README.md` with the new version.
+ 4. `git commit -am "Prepare for release X.Y.Z."` (where X.Y.Z is the new version)
+ 5. `./gradlew clean uploadArchives`.
+ 6. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
+ 7. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
+ 8. Update the `gradle.properties` to the next SNAPSHOT version.
+ 9. `git commit -am "Prepare next development version."`
+ 10. `git push && git push --tags`
+ 11. Update the two sample modules to point to the newly released version.
+
+If step 5 or 6 fails, drop the Sonatype repo, fix the problem, commit, and start again at step 5.
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..c411ba8e
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,117 @@
+apply plugin: 'com.github.ben-manes.versions'
+
+buildscript {
+  ext.versions = [
+      'minSdk': 14,
+      'compileSdk': 28,
+
+      'androidTools': '26.2.0',
+      'kotlin': '1.2.71',
+
+      'release': '8.8.1',
+  ]
+
+  ext.deps = [
+      android: [
+          'runtime': 'com.google.android:android:4.1.1.4',
+          'gradlePlugin': "com.android.tools.build:gradle:3.1.4",
+      ],
+      'androidx': [
+          'core': "androidx.core:core:1.0.0",
+          'viewpager': "androidx.viewpager:viewpager:1.0.0",
+          'annotations': "androidx.annotation:annotation:1.0.0",
+          'test': [
+              'runner': 'androidx.test:runner:1.1.0',
+              'rules': 'androidx.test:rules:1.1.0',
+          ],
+      ],
+      'lint': [
+          'core': "com.android.tools.lint:lint:${versions.androidTools}",
+          'api': "com.android.tools.lint:lint-api:${versions.androidTools}",
+          'checks': "com.android.tools.lint:lint-checks:${versions.androidTools}",
+          'tests': "com.android.tools.lint:lint-tests:${versions.androidTools}",
+      ],
+      javapoet: 'com.squareup:javapoet:1.10.0',
+      junit: 'junit:junit:4.12',
+      truth: 'com.google.truth:truth:0.42',
+      compiletesting: 'com.google.testing.compile:compile-testing:0.15',
+      'auto': [
+          'service': 'com.google.auto.service:auto-service:1.0-rc4',
+          'common': 'com.google.auto:auto-common:0.10',
+      ],
+      'guava': 'com.google.guava:guava:24.0-jre',
+      'release': [
+          'runtime': "com.jakewharton:butterknife:${versions.release}",
+          'compiler': "com.jakewharton:butterknife-compiler:${versions.release}"
+      ],
+      'kotlin': [
+          'stdLibJdk8': "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${versions.kotlin}",
+      ]
+  ]
+
+  repositories {
+    mavenCentral()
+    google()
+    jcenter()
+    gradlePluginPortal()
+  }
+
+  dependencies {
+    classpath 'com.android.tools.build:gradle:3.2.0'
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
+    classpath 'com.github.ben-manes:gradle-versions-plugin:0.17.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
+  }
+}
+
+subprojects { project ->
+  group = GROUP
+  version = VERSION_NAME
+
+  repositories {
+    mavenCentral()
+    google()
+    jcenter()
+  }
+
+  apply plugin: 'net.ltgt.errorprone'
+
+  dependencies {
+    errorprone 'com.google.errorprone:error_prone_core:2.3.1'
+  }
+
+  // TODO figure out why this causes codegen to fail in android tests.
+  //def nullaway = dependencies.create('com.uber.nullaway:nullaway:0.5.5')
+  //configurations.all { Configuration configuration ->
+  //  if (configuration.name.endsWith('nnotationProcessor')) {
+  //    configuration.dependencies.add(nullaway)
+  //  }
+  //}
+  //
+  //tasks.withType(JavaCompile) {
+  //  options.compilerArgs += [
+  //      '-Xep:NullAway:ERROR',
+  //      '-XepOpt:NullAway:AnnotatedPackages=butterknife',
+  //  ]
+  //}
+
+  if (!project.name.equals('butterknife-gradle-plugin')) {
+    apply plugin: 'checkstyle'
+
+    task checkstyle(type: Checkstyle) {
+      configFile rootProject.file('checkstyle.xml')
+      source 'src/main/java'
+      ignoreFailures false
+      showViolations true
+      include '**/*.java'
+
+      classpath = files()
+    }
+
+    afterEvaluate {
+      if (project.tasks.findByName('check')) {
+        check.dependsOn('checkstyle')
+      }
+    }
+  }
+}
diff --git a/butterknife-annotations/build.gradle b/butterknife-annotations/build.gradle
new file mode 100644
index 00000000..03d03882
--- /dev/null
+++ b/butterknife-annotations/build.gradle
@@ -0,0 +1,17 @@
+apply plugin: 'java-library'
+apply plugin: 'checkstyle'
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+checkstyle {
+  configFile rootProject.file('checkstyle.xml')
+  showViolations true
+}
+
+dependencies {
+  compileOnly deps.android.runtime
+  api deps.androidx.annotations
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-annotations/gradle.properties b/butterknife-annotations/gradle.properties
new file mode 100644
index 00000000..11d49ada
--- /dev/null
+++ b/butterknife-annotations/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Butterknife Annotations
+POM_ARTIFACT_ID=butterknife-annotations
+POM_PACKAGING=jar
diff --git a/butterknife-annotations/src/main/java/butterknife/BindAnim.java b/butterknife-annotations/src/main/java/butterknife/BindAnim.java
new file mode 100644
index 00000000..95d7e073
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindAnim.java
@@ -0,0 +1,21 @@
+package butterknife;
+
+import androidx.annotation.AnimRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified animation resource ID.
+ * <pre><code>
+ * {@literal @}BindAnim(R.anim.fade_in) Animation fadeIn;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindAnim {
+  /** Animation resource ID to which the field will be bound. */
+  @AnimRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindArray.java b/butterknife-annotations/src/main/java/butterknife/BindArray.java
new file mode 100644
index 00000000..b590b69d
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindArray.java
@@ -0,0 +1,38 @@
+package butterknife;
+
+import androidx.annotation.ArrayRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified array resource ID. The type of array will be inferred from the
+ * annotated element.
+ *
+ * String array:
+ * <pre><code>
+ * {@literal @}BindArray(R.array.countries) String[] countries;
+ * </code></pre>
+ *
+ * Int array:
+ * <pre><code>
+ * {@literal @}BindArray(R.array.phones) int[] phones;
+ * </code></pre>
+ *
+ * Text array:
+ * <pre><code>
+ * {@literal @}BindArray(R.array.options) CharSequence[] options;
+ * </code></pre>
+ *
+ * {@link android.content.res.TypedArray}:
+ * <pre><code>
+ * {@literal @}BindArray(R.array.icons) TypedArray icons;
+ * </code></pre>
+ */
+@Retention(RUNTIME) @Target(FIELD)
+public @interface BindArray {
+  /** Array resource ID to which the field will be bound. */
+  @ArrayRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindBitmap.java b/butterknife-annotations/src/main/java/butterknife/BindBitmap.java
new file mode 100644
index 00000000..795b230e
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindBitmap.java
@@ -0,0 +1,22 @@
+package butterknife;
+
+import android.graphics.Bitmap;
+import androidx.annotation.DrawableRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to a {@link Bitmap} from the specified drawable resource ID.
+ * <pre><code>
+ * {@literal @}BindBitmap(R.drawable.logo) Bitmap logo;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindBitmap {
+  /** Drawable resource ID from which the {@link Bitmap} will be created. */
+  @DrawableRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindBool.java b/butterknife-annotations/src/main/java/butterknife/BindBool.java
new file mode 100644
index 00000000..eb6347dd
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindBool.java
@@ -0,0 +1,21 @@
+package butterknife;
+
+import androidx.annotation.BoolRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified boolean resource ID.
+ * <pre><code>
+ * {@literal @}BindBool(R.bool.is_tablet) boolean isTablet;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindBool {
+  /** Boolean resource ID to which the field will be bound. */
+  @BoolRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindColor.java b/butterknife-annotations/src/main/java/butterknife/BindColor.java
new file mode 100644
index 00000000..2691cf5a
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindColor.java
@@ -0,0 +1,23 @@
+package butterknife;
+
+import androidx.annotation.ColorRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified color resource ID. Type can be {@code int} or
+ * {@link android.content.res.ColorStateList}.
+ * <pre><code>
+ * {@literal @}BindColor(R.color.background_green) int green;
+ * {@literal @}BindColor(R.color.background_green_selector) ColorStateList greenSelector;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindColor {
+  /** Color resource ID to which the field will be bound. */
+  @ColorRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindDimen.java b/butterknife-annotations/src/main/java/butterknife/BindDimen.java
new file mode 100644
index 00000000..49fa9185
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindDimen.java
@@ -0,0 +1,23 @@
+package butterknife;
+
+import androidx.annotation.DimenRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified dimension resource ID. Type can be {@code int} for pixel size or
+ * {@code float} for exact amount.
+ * <pre><code>
+ * {@literal @}BindDimen(R.dimen.horizontal_gap) int gapPx;
+ * {@literal @}BindDimen(R.dimen.horizontal_gap) float gap;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindDimen {
+  /** Dimension resource ID to which the field will be bound. */
+  @DimenRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindDrawable.java b/butterknife-annotations/src/main/java/butterknife/BindDrawable.java
new file mode 100644
index 00000000..76fa9a03
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindDrawable.java
@@ -0,0 +1,29 @@
+package butterknife;
+
+import androidx.annotation.AttrRes;
+import androidx.annotation.DrawableRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static butterknife.internal.Constants.NO_RES_ID;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified drawable resource ID.
+ * <pre><code>
+ * {@literal @}BindDrawable(R.drawable.placeholder)
+ * Drawable placeholder;
+ * {@literal @}BindDrawable(value = R.drawable.placeholder, tint = R.attr.colorAccent)
+ * Drawable tintedPlaceholder;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindDrawable {
+  /** Drawable resource ID to which the field will be bound. */
+  @DrawableRes int value();
+
+  /** Color attribute resource ID that is used to tint the drawable. */
+  @AttrRes int tint() default NO_RES_ID;
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindFloat.java b/butterknife-annotations/src/main/java/butterknife/BindFloat.java
new file mode 100644
index 00000000..400e844f
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindFloat.java
@@ -0,0 +1,25 @@
+package butterknife;
+
+import androidx.annotation.DimenRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified dimension resource ID whose type is explicitly defined as float.
+ * <p>
+ * This is different than simply reading a normal dimension as a float value which
+ * {@link BindDimen @BindDimen} supports. The resource must be defined as a float like
+ * {@code <item name="whatever" format="float" type="dimen">1.1</item>}.
+ * <pre><code>
+ * {@literal @}BindFloat(R.dimen.image_ratio) float imageRatio;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindFloat {
+  /** Float resource ID to which the field will be bound. */
+  @DimenRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindFont.java b/butterknife-annotations/src/main/java/butterknife/BindFont.java
new file mode 100644
index 00000000..ff3420ac
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindFont.java
@@ -0,0 +1,37 @@
+package butterknife;
+
+import android.graphics.Typeface;
+import androidx.annotation.FontRes;
+import androidx.annotation.IntDef;
+import androidx.annotation.RestrictTo;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static androidx.annotation.RestrictTo.Scope.LIBRARY;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified font resource ID.
+ * <pre><code>
+ * {@literal @}BindFont(R.font.comic_sans) Typeface comicSans;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindFont {
+  /** Font resource ID to which the field will be bound. */
+  @FontRes int value();
+
+  @TypefaceStyle int style() default Typeface.NORMAL;
+
+  @IntDef({
+      Typeface.NORMAL,
+      Typeface.BOLD,
+      Typeface.ITALIC,
+      Typeface.BOLD_ITALIC
+  })
+  @RestrictTo(LIBRARY)
+  @interface TypefaceStyle {
+  }
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindInt.java b/butterknife-annotations/src/main/java/butterknife/BindInt.java
new file mode 100644
index 00000000..15593081
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindInt.java
@@ -0,0 +1,21 @@
+package butterknife;
+
+import androidx.annotation.IntegerRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified integer resource ID.
+ * <pre><code>
+ * {@literal @}BindInt(R.int.columns) int columns;
+ * </code></pre>
+ */
+@Target(FIELD)
+@Retention(RUNTIME)
+public @interface BindInt {
+  /** Integer resource ID to which the field will be bound. */
+  @IntegerRes int value();
+}
diff --git a/butterknife-annotations/src/main/java/butterknife/BindString.java b/butterknife-annotations/src/main/java/butterknife/BindString.java
new file mode 100644
index 00000000..a31b5509
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindString.java
@@ -0,0 +1,20 @@
+package butterknife;
+
+import androidx.annotation.StringRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the specified string resource ID.
+ * <pre><code>
+ * {@literal @}BindString(R.string.username_error) String usernameErrorText;
+ * </code></pre>
+ */
+@Retention(RUNTIME) @Target(FIELD)
+public @interface BindString {
+  /** String resource ID to which the field will be bound. */
+  @StringRes int value();
+}
diff --git a/butterknife/src/main/java/butterknife/InjectView.java b/butterknife-annotations/src/main/java/butterknife/BindView.java
similarity index 60%
rename from butterknife/src/main/java/butterknife/InjectView.java
rename to butterknife-annotations/src/main/java/butterknife/BindView.java
index 3d401071..13c56dab 100644
--- a/butterknife/src/main/java/butterknife/InjectView.java
+++ b/butterknife-annotations/src/main/java/butterknife/BindView.java
@@ -1,22 +1,21 @@
 package butterknife;
 
+import androidx.annotation.IdRes;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a field to the view for the specified ID. The view will automatically be cast to the field
  * type.
  * <pre><code>
- * {@literal @}InjectView(R.id.title) TextView title;
+ * {@literal @}BindView(R.id.title) TextView title;
  * </code></pre>
- *
- * @see Optional
  */
-@Retention(CLASS) @Target(FIELD)
-public @interface InjectView {
+@Retention(RUNTIME) @Target(FIELD)
+public @interface BindView {
   /** View ID to which the field will be bound. */
-  int value();
+  @IdRes int value();
 }
diff --git a/butterknife-annotations/src/main/java/butterknife/BindViews.java b/butterknife-annotations/src/main/java/butterknife/BindViews.java
new file mode 100644
index 00000000..890b5693
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/BindViews.java
@@ -0,0 +1,22 @@
+package butterknife;
+
+import androidx.annotation.IdRes;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Bind a field to the view for the specified ID. The view will automatically be cast to the field
+ * type.
+ * <pre><code>
+ * {@literal @}BindViews({ R.id.title, R.id.subtitle })
+ * List&lt;TextView&gt; titles;
+ * </code></pre>
+ */
+@Retention(RUNTIME) @Target(FIELD)
+public @interface BindViews {
+  /** View IDs to which the field will be bound. */
+  @IdRes int[] value();
+}
diff --git a/butterknife/src/main/java/butterknife/OnCheckedChanged.java b/butterknife-annotations/src/main/java/butterknife/OnCheckedChanged.java
similarity index 81%
rename from butterknife/src/main/java/butterknife/OnCheckedChanged.java
rename to butterknife-annotations/src/main/java/butterknife/OnCheckedChanged.java
index 787c7cb1..4d9b280d 100644
--- a/butterknife/src/main/java/butterknife/OnCheckedChanged.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnCheckedChanged.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,14 +9,14 @@
 
 import static android.widget.CompoundButton.OnCheckedChangeListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnCheckedChangeListener OnCheckedChangeListener} on the view for
  * each ID specified.
  * <pre><code>
  * {@literal @}OnCheckedChanged(R.id.example) void onChecked(boolean checked) {
- *   Toast.makeText(this, checked ? "Checked!" : "Unchecked!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, checked ? "Checked!" : "Unchecked!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from
@@ -22,10 +24,9 @@
  * onCheckedChanged} may be used on the method.
  *
  * @see OnCheckedChangeListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.widget.CompoundButton",
     setter = "setOnCheckedChangeListener",
@@ -40,5 +41,5 @@
 )
 public @interface OnCheckedChanged {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnClick.java b/butterknife-annotations/src/main/java/butterknife/OnClick.java
similarity index 74%
rename from butterknife/src/main/java/butterknife/OnClick.java
rename to butterknife-annotations/src/main/java/butterknife/OnClick.java
index d8faee5b..ffebeb06 100644
--- a/butterknife/src/main/java/butterknife/OnClick.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnClick.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,13 +9,13 @@
 
 import static android.view.View.OnClickListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnClickListener OnClickListener} on the view for each ID specified.
  * <pre><code>
  * {@literal @}OnClick(R.id.example) void onClick() {
- *   Toast.makeText(this, "Clicked!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Clicked!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from
@@ -21,14 +23,13 @@
  * method.
  *
  * @see OnClickListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.view.View",
     setter = "setOnClickListener",
-    type = "butterknife.internal.DebouncedOnClickListener",
+    type = "butterknife.internal.DebouncingOnClickListener",
     method = @ListenerMethod(
         name = "doClick",
         parameters = "android.view.View"
@@ -36,5 +37,5 @@
 )
 public @interface OnClick {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnEditorAction.java b/butterknife-annotations/src/main/java/butterknife/OnEditorAction.java
similarity index 76%
rename from butterknife/src/main/java/butterknife/OnEditorAction.java
rename to butterknife-annotations/src/main/java/butterknife/OnEditorAction.java
index ab3be7f5..ebaa57c6 100644
--- a/butterknife/src/main/java/butterknife/OnEditorAction.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnEditorAction.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,26 +9,27 @@
 
 import static android.widget.TextView.OnEditorActionListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnEditorActionListener OnEditorActionListener} on the view for each
  * ID specified.
  * <pre><code>
  * {@literal @}OnEditorAction(R.id.example) boolean onEditorAction(KeyEvent key) {
- *   Toast.makeText(this, "Pressed: " + key, LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Pressed: " + key, Toast.LENGTH_SHORT).show();
  *   return true;
  * }
  * </code></pre>
  * Any number of parameters from
  * {@link OnEditorActionListener#onEditorAction(android.widget.TextView, int, android.view.KeyEvent)
  * onEditorAction} may be used on the method.
+ * <p>
+ * If the return type of the method is {@code void}, true will be returned from the listener.
  *
  * @see OnEditorActionListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.widget.TextView",
     setter = "setOnEditorActionListener",
@@ -39,10 +42,10 @@
             "android.view.KeyEvent"
         },
         returnType = "boolean",
-        defaultReturn = "false"
+        defaultReturn = "true"
     )
 )
 public @interface OnEditorAction {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnFocusChange.java b/butterknife-annotations/src/main/java/butterknife/OnFocusChange.java
similarity index 78%
rename from butterknife/src/main/java/butterknife/OnFocusChange.java
rename to butterknife-annotations/src/main/java/butterknife/OnFocusChange.java
index 060b2c2d..a388812f 100644
--- a/butterknife/src/main/java/butterknife/OnFocusChange.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnFocusChange.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,24 +9,23 @@
 
 import static android.view.View.OnFocusChangeListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnFocusChangeListener OnFocusChangeListener} on the view for each ID
  * specified.
  * <pre><code>
- * {@literal @}OnFocusChanged(R.id.example) void onFocusChanged(boolean focused) {
- *   Toast.makeText(this, focused ? "Gained focus" : "Lost focus", LENGTH_SHORT).show();
+ * {@literal @}OnFocusChange(R.id.example) void onFocusChanged(boolean focused) {
+ *   Toast.makeText(this, focused ? "Gained focus" : "Lost focus", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from {@link OnFocusChangeListener#onFocusChange(android.view.View,
  * boolean) onFocusChange} may be used on the method.
  *
  * @see OnFocusChangeListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.view.View",
     setter = "setOnFocusChangeListener",
@@ -39,5 +40,5 @@
 )
 public @interface OnFocusChange {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnItemClick.java b/butterknife-annotations/src/main/java/butterknife/OnItemClick.java
similarity index 85%
rename from butterknife/src/main/java/butterknife/OnItemClick.java
rename to butterknife-annotations/src/main/java/butterknife/OnItemClick.java
index 367c3fc7..4362f79e 100644
--- a/butterknife/src/main/java/butterknife/OnItemClick.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnItemClick.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,24 +9,23 @@
 
 import static android.widget.AdapterView.OnItemClickListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnItemClickListener OnItemClickListener} on the view for each ID
  * specified.
  * <pre><code>
  * {@literal @}OnItemClick(R.id.example_list) void onItemClick(int position) {
- *   Toast.makeText(this, "Clicked position " + position + "!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Clicked position " + position + "!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from {@link OnItemClickListener#onItemClick(android.widget.AdapterView,
  * android.view.View, int, long) onItemClick} may be used on the method.
  *
  * @see OnItemClickListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.widget.AdapterView<?>",
     setter = "setOnItemClickListener",
@@ -41,5 +42,5 @@
 )
 public @interface OnItemClick {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnItemLongClick.java b/butterknife-annotations/src/main/java/butterknife/OnItemLongClick.java
similarity index 79%
rename from butterknife/src/main/java/butterknife/OnItemLongClick.java
rename to butterknife-annotations/src/main/java/butterknife/OnItemLongClick.java
index 88632eab..0f1ca8b9 100644
--- a/butterknife/src/main/java/butterknife/OnItemLongClick.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnItemLongClick.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,26 +9,27 @@
 
 import static android.widget.AdapterView.OnItemLongClickListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnItemLongClickListener OnItemLongClickListener} on the view for each
  * ID specified.
  * <pre><code>
  * {@literal @}OnItemLongClick(R.id.example_list) boolean onItemLongClick(int position) {
- *   Toast.makeText(this, "Long clicked position " + position + "!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Long clicked position " + position + "!", Toast.LENGTH_SHORT).show();
  *   return true;
  * }
  * </code></pre>
  * Any number of parameters from
  * {@link OnItemLongClickListener#onItemLongClick(android.widget.AdapterView, android.view.View,
  * int, long) onItemLongClick} may be used on the method.
+ * <p>
+ * If the return type of the method is {@code void}, true will be returned from the listener.
  *
  * @see OnItemLongClickListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.widget.AdapterView<?>",
     setter = "setOnItemLongClickListener",
@@ -40,10 +43,10 @@
             "long"
         },
         returnType = "boolean",
-        defaultReturn = "false"
+        defaultReturn = "true"
     )
 )
 public @interface OnItemLongClick {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnItemSelected.java b/butterknife-annotations/src/main/java/butterknife/OnItemSelected.java
similarity index 91%
rename from butterknife/src/main/java/butterknife/OnItemSelected.java
rename to butterknife-annotations/src/main/java/butterknife/OnItemSelected.java
index a19964ce..22a8664d 100644
--- a/butterknife/src/main/java/butterknife/OnItemSelected.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnItemSelected.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -14,7 +16,7 @@
  * ID specified.
  * <pre><code>
  * {@literal @}OnItemSelected(R.id.example_list) void onItemSelected(int position) {
- *   Toast.makeText(this, "Selected position " + position + "!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Selected position " + position + "!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from
@@ -25,12 +27,11 @@
  * <pre><code>
  * {@literal @}OnItemSelected(value = R.id.example_list, callback = NOTHING_SELECTED)
  * void onNothingSelected() {
- *   Toast.makeText(this, "Nothing selected!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Nothing selected!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  *
  * @see OnItemSelectedListener
- * @see Optional
  */
 @Target(METHOD)
 @Retention(CLASS)
@@ -42,7 +43,7 @@
 )
 public @interface OnItemSelected {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 
   /** Listener callback to which the method will be bound. */
   Callback callback() default Callback.ITEM_SELECTED;
diff --git a/butterknife/src/main/java/butterknife/OnLongClick.java b/butterknife-annotations/src/main/java/butterknife/OnLongClick.java
similarity index 72%
rename from butterknife/src/main/java/butterknife/OnLongClick.java
rename to butterknife-annotations/src/main/java/butterknife/OnLongClick.java
index 422864e0..55d7fed6 100644
--- a/butterknife/src/main/java/butterknife/OnLongClick.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnLongClick.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,24 +9,26 @@
 
 import static android.view.View.OnLongClickListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnLongClickListener OnLongClickListener} on the view for each ID
  * specified.
  * <pre><code>
  * {@literal @}OnLongClick(R.id.example) boolean onLongClick() {
- *   Toast.makeText(this, "Long clicked!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Long clicked!", Toast.LENGTH_SHORT).show();
  *   return true;
  * }
  * </code></pre>
  * Any number of parameters from {@link OnLongClickListener#onLongClick(android.view.View)} may be
  * used on the method.
+ * <p>
+ * If the return type of the method is {@code void}, true will be returned from the listener.
  *
  * @see OnLongClickListener
- * @see Optional
  */
-@Retention(CLASS) @Target(METHOD)
+@Target(METHOD)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.view.View",
     setter = "setOnLongClickListener",
@@ -35,10 +39,10 @@
             "android.view.View"
         },
         returnType = "boolean",
-        defaultReturn = "false"
+        defaultReturn = "true"
     )
 )
 public @interface OnLongClick {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/OnPageChange.java b/butterknife-annotations/src/main/java/butterknife/OnPageChange.java
similarity index 75%
rename from butterknife/src/main/java/butterknife/OnPageChange.java
rename to butterknife-annotations/src/main/java/butterknife/OnPageChange.java
index 19ad3874..8cf18b57 100644
--- a/butterknife/src/main/java/butterknife/OnPageChange.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnPageChange.java
@@ -1,18 +1,20 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@code OnPageChangeListener} on the view for each ID specified.
  * <pre><code>
  * {@literal @}OnPageChange(R.id.example_pager) void onPageSelected(int position) {
- *   Toast.makeText(this, "Selected " + position + "!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Selected " + position + "!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from {@code onPageSelected} may be used on the method.
@@ -21,23 +23,22 @@
  * <pre><code>
  * {@literal @}OnPageChange(value = R.id.example_pager, callback = PAGE_SCROLL_STATE_CHANGED)
  * void onPageStateChanged(int state) {
- *   Toast.makeText(this, "State changed: " + state + "!", LENGTH_SHORT).show();
+ *   Toast.makeText(this, "State changed: " + state + "!", Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
- *
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
-    targetType = "android.support.v4.view.ViewPager",
-    setter = "setOnPageChangeListener",
-    type = "android.support.v4.view.ViewPager.OnPageChangeListener",
+    targetType = "androidx.viewpager.widget.ViewPager",
+    setter = "addOnPageChangeListener",
+    remover = "removeOnPageChangeListener",
+    type = "androidx.viewpager.widget.ViewPager.OnPageChangeListener",
     callbacks = OnPageChange.Callback.class
 )
 public @interface OnPageChange {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 
   /** Listener callback to which the method will be bound. */
   Callback callback() default Callback.PAGE_SELECTED;
diff --git a/butterknife/src/main/java/butterknife/OnTextChanged.java b/butterknife-annotations/src/main/java/butterknife/OnTextChanged.java
similarity index 79%
rename from butterknife/src/main/java/butterknife/OnTextChanged.java
rename to butterknife-annotations/src/main/java/butterknife/OnTextChanged.java
index 7889180c..b823b443 100644
--- a/butterknife/src/main/java/butterknife/OnTextChanged.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnTextChanged.java
@@ -1,19 +1,21 @@
 package butterknife;
 
 import android.text.TextWatcher;
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Bind a method to an {@link TextWatcher TextWatcher} on the view for each ID specified.
+ * Bind a method to a {@link TextWatcher TextWatcher} on the view for each ID specified.
  * <pre><code>
  * {@literal @}OnTextChanged(R.id.example) void onTextChanged(CharSequence text) {
- *   Toast.makeText(this, "Text changed: " + text, LENGTH_SHORT).show();
+ *   Toast.makeText(this, "Text changed: " + text, Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  * Any number of parameters from {@link TextWatcher#onTextChanged(CharSequence, int, int, int)
@@ -22,25 +24,25 @@
  * To bind to methods other than {@code onTextChanged}, specify a different {@code callback}.
  * <pre><code>
  * {@literal @}OnTextChanged(value = R.id.example, callback = BEFORE_TEXT_CHANGED)
- * void onBeforeTextChanged(CharSequence text {
- *   Toast.makeText(this, "Before text changed: " + text, LENGTH_SHORT).show();
+ * void onBeforeTextChanged(CharSequence text) {
+ *   Toast.makeText(this, "Before text changed: " + text, Toast.LENGTH_SHORT).show();
  * }
  * </code></pre>
  *
  * @see TextWatcher
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.widget.TextView",
     setter = "addTextChangedListener",
+    remover = "removeTextChangedListener",
     type = "android.text.TextWatcher",
     callbacks = OnTextChanged.Callback.class
 )
 public @interface OnTextChanged {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 
   /** Listener callback to which the method will be bound. */
   Callback callback() default Callback.TEXT_CHANGED;
diff --git a/butterknife/src/main/java/butterknife/OnTouch.java b/butterknife-annotations/src/main/java/butterknife/OnTouch.java
similarity index 69%
rename from butterknife/src/main/java/butterknife/OnTouch.java
rename to butterknife-annotations/src/main/java/butterknife/OnTouch.java
index daf917d6..669e0f6d 100644
--- a/butterknife/src/main/java/butterknife/OnTouch.java
+++ b/butterknife-annotations/src/main/java/butterknife/OnTouch.java
@@ -1,5 +1,7 @@
 package butterknife;
 
+import android.view.View;
+import androidx.annotation.IdRes;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
 import java.lang.annotation.Retention;
@@ -7,24 +9,26 @@
 
 import static android.view.View.OnTouchListener;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Bind a method to an {@link OnTouchListener OnTouchListener} on the view for each ID specified.
  * <pre><code>
- * {@literal @}OnTouch(R.id.example) void onTouch() {
- *   Toast.makeText(this, "Touched!", LENGTH_SHORT).show();
+ * {@literal @}OnTouch(R.id.example) boolean onTouch() {
+ *   Toast.makeText(this, "Touched!", Toast.LENGTH_SHORT).show();
+ *   return false;
  * }
  * </code></pre>
  * Any number of parameters from
  * {@link OnTouchListener#onTouch(android.view.View, android.view.MotionEvent) onTouch} may be used
  * on the method.
+ * <p>
+ * If the return type of the method is {@code void}, true will be returned from the listener.
  *
  * @see OnTouchListener
- * @see Optional
  */
 @Target(METHOD)
-@Retention(CLASS)
+@Retention(RUNTIME)
 @ListenerClass(
     targetType = "android.view.View",
     setter = "setOnTouchListener",
@@ -36,10 +40,10 @@
             "android.view.MotionEvent"
         },
         returnType = "boolean",
-        defaultReturn = "false"
+        defaultReturn = "true"
     )
 )
 public @interface OnTouch {
   /** View IDs to which the method will be bound. */
-  int[] value();
+  @IdRes int[] value() default { View.NO_ID };
 }
diff --git a/butterknife/src/main/java/butterknife/Optional.java b/butterknife-annotations/src/main/java/butterknife/Optional.java
similarity index 57%
rename from butterknife/src/main/java/butterknife/Optional.java
rename to butterknife-annotations/src/main/java/butterknife/Optional.java
index 8299e22a..adc95d2c 100644
--- a/butterknife/src/main/java/butterknife/Optional.java
+++ b/butterknife-annotations/src/main/java/butterknife/Optional.java
@@ -3,16 +3,16 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Denote that the view specified by the injection is not required to be present.
  * <pre><code>
- * {@literal @}Optional @InjectView(R.id.title) TextView subtitleView;
+ * {@literal @}Optional @OnClick(R.id.subtitle) void onSubtitleClick() {}
  * </code></pre>
  */
-@Retention(CLASS) @Target({ FIELD, METHOD })
+@Target(METHOD)
+@Retention(RUNTIME)
 public @interface Optional {
 }
diff --git a/butterknife-annotations/src/main/java/butterknife/internal/Constants.java b/butterknife-annotations/src/main/java/butterknife/internal/Constants.java
new file mode 100644
index 00000000..bde58d1f
--- /dev/null
+++ b/butterknife-annotations/src/main/java/butterknife/internal/Constants.java
@@ -0,0 +1,8 @@
+package butterknife.internal;
+
+public class Constants {
+
+  private Constants() { }
+
+  public static final int NO_RES_ID = -1;
+}
diff --git a/butterknife/src/main/java/butterknife/internal/ListenerClass.java b/butterknife-annotations/src/main/java/butterknife/internal/ListenerClass.java
similarity index 74%
rename from butterknife/src/main/java/butterknife/internal/ListenerClass.java
rename to butterknife-annotations/src/main/java/butterknife/internal/ListenerClass.java
index 1c992c2f..e6d3ed5f 100644
--- a/butterknife/src/main/java/butterknife/internal/ListenerClass.java
+++ b/butterknife-annotations/src/main/java/butterknife/internal/ListenerClass.java
@@ -10,15 +10,18 @@
 public @interface ListenerClass {
   String targetType();
 
-  /** Name of the setter method on the {@link #targetType() target type} for the listener. */
+  /** Name of the setter method on the {@linkplain #targetType() target type} for the listener. */
   String setter();
 
+  /**
+   * Name of the method on the {@linkplain #targetType() target type} to remove the listener. If
+   * empty {@link #setter()} will be used by default.
+   */
+  String remover() default "";
+
   /** Fully-qualified class name of the listener type. */
   String type();
 
-  /** The number of generic arguments for the type. This used used for casting the view. */
-  int genericArguments() default 0;
-
   /** Enum which declares the listener callback methods. Mutually exclusive to {@link #method()}. */
   Class<? extends Enum<?>> callbacks() default NONE.class;
 
diff --git a/butterknife/src/main/java/butterknife/internal/ListenerMethod.java b/butterknife-annotations/src/main/java/butterknife/internal/ListenerMethod.java
similarity index 91%
rename from butterknife/src/main/java/butterknife/internal/ListenerMethod.java
rename to butterknife-annotations/src/main/java/butterknife/internal/ListenerMethod.java
index 31ab24f0..ca62d675 100644
--- a/butterknife/src/main/java/butterknife/internal/ListenerMethod.java
+++ b/butterknife-annotations/src/main/java/butterknife/internal/ListenerMethod.java
@@ -14,7 +14,7 @@
   /** List of method parameters. If the type is not a primitive it must be fully-qualified. */
   String[] parameters() default { };
 
-  /** Primative or fully-qualified return type of the listener method. May also be {@code void}. */
+  /** Primitive or fully-qualified return type of the listener method. May also be {@code void}. */
   String returnType() default "void";
 
   /** If {@link #returnType()} is not {@code void} this value is returned when no binding exists. */
diff --git a/butterknife-compiler/build.gradle b/butterknife-compiler/build.gradle
new file mode 100644
index 00000000..077bc65d
--- /dev/null
+++ b/butterknife-compiler/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'java-library'
+apply plugin: 'checkstyle'
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  implementation project(':butterknife-annotations')
+  implementation deps.auto.common
+  implementation deps.guava
+  api deps.javapoet
+  compileOnly deps.auto.service
+  compileOnly files(org.gradle.internal.jvm.Jvm.current().getToolsJar())
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+}
+
+checkstyle {
+  configFile rootProject.file('checkstyle.xml')
+  showViolations true
+  //Remove this when tests are less verbose, i.e. using JavaPoet
+  sourceSets = [sourceSets.main]
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-compiler/gradle.properties b/butterknife-compiler/gradle.properties
new file mode 100644
index 00000000..ae693e1b
--- /dev/null
+++ b/butterknife-compiler/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Butterknife Compiler
+POM_ARTIFACT_ID=butterknife-compiler
+POM_PACKAGING=jar
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
new file mode 100644
index 00000000..e5a891d0
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/BindingSet.java
@@ -0,0 +1,789 @@
+package butterknife.compiler;
+
+import butterknife.OnTouch;
+import butterknife.internal.ListenerClass;
+import butterknife.internal.ListenerMethod;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.WildcardTypeName;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+import static butterknife.compiler.ButterKnifeProcessor.ACTIVITY_TYPE;
+import static butterknife.compiler.ButterKnifeProcessor.DIALOG_TYPE;
+import static butterknife.compiler.ButterKnifeProcessor.VIEW_TYPE;
+import static butterknife.compiler.ButterKnifeProcessor.isSubtypeOfType;
+import static com.google.auto.common.MoreElements.getPackage;
+import static java.util.Collections.singletonList;
+import static java.util.Objects.requireNonNull;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/** A set of all the bindings requested by a single type. */
+final class BindingSet {
+  static final ClassName UTILS = ClassName.get("butterknife.internal", "Utils");
+  private static final ClassName VIEW = ClassName.get("android.view", "View");
+  private static final ClassName CONTEXT = ClassName.get("android.content", "Context");
+  private static final ClassName RESOURCES = ClassName.get("android.content.res", "Resources");
+  private static final ClassName UI_THREAD =
+      ClassName.get("androidx.annotation", "UiThread");
+  private static final ClassName CALL_SUPER =
+      ClassName.get("androidx.annotation", "CallSuper");
+  private static final ClassName SUPPRESS_LINT =
+      ClassName.get("android.annotation", "SuppressLint");
+  private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");
+  static final ClassName BITMAP_FACTORY = ClassName.get("android.graphics", "BitmapFactory");
+  static final ClassName CONTEXT_COMPAT =
+      ClassName.get("androidx.core.content", "ContextCompat");
+  static final ClassName ANIMATION_UTILS =
+          ClassName.get("android.view.animation", "AnimationUtils");
+
+  private final TypeName targetTypeName;
+  private final ClassName bindingClassName;
+  private final boolean isFinal;
+  private final boolean isView;
+  private final boolean isActivity;
+  private final boolean isDialog;
+  private final ImmutableList<ViewBinding> viewBindings;
+  private final ImmutableList<FieldCollectionViewBinding> collectionBindings;
+  private final ImmutableList<ResourceBinding> resourceBindings;
+  private final @Nullable BindingSet parentBinding;
+
+  private BindingSet(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+      boolean isView, boolean isActivity, boolean isDialog, ImmutableList<ViewBinding> viewBindings,
+      ImmutableList<FieldCollectionViewBinding> collectionBindings,
+      ImmutableList<ResourceBinding> resourceBindings, @Nullable BindingSet parentBinding) {
+    this.isFinal = isFinal;
+    this.targetTypeName = targetTypeName;
+    this.bindingClassName = bindingClassName;
+    this.isView = isView;
+    this.isActivity = isActivity;
+    this.isDialog = isDialog;
+    this.viewBindings = viewBindings;
+    this.collectionBindings = collectionBindings;
+    this.resourceBindings = resourceBindings;
+    this.parentBinding = parentBinding;
+  }
+
+  JavaFile brewJava(int sdk, boolean debuggable) {
+    TypeSpec bindingConfiguration = createType(sdk, debuggable);
+    return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)
+        .addFileComment("Generated code from Butter Knife. Do not modify!")
+        .build();
+  }
+
+  private TypeSpec createType(int sdk, boolean debuggable) {
+    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())
+        .addModifiers(PUBLIC);
+    if (isFinal) {
+      result.addModifiers(FINAL);
+    }
+
+    if (parentBinding != null) {
+      result.superclass(parentBinding.bindingClassName);
+    } else {
+      result.addSuperinterface(UNBINDER);
+    }
+
+    if (hasTargetField()) {
+      result.addField(targetTypeName, "target", PRIVATE);
+    }
+
+    if (isView) {
+      result.addMethod(createBindingConstructorForView());
+    } else if (isActivity) {
+      result.addMethod(createBindingConstructorForActivity());
+    } else if (isDialog) {
+      result.addMethod(createBindingConstructorForDialog());
+    }
+    if (!constructorNeedsView()) {
+      // Add a delegating constructor with a target type + view signature for reflective use.
+      result.addMethod(createBindingViewDelegateConstructor());
+    }
+    result.addMethod(createBindingConstructor(sdk, debuggable));
+
+    if (hasViewBindings() || parentBinding == null) {
+      result.addMethod(createBindingUnbindMethod(result));
+    }
+
+    return result.build();
+  }
+
+  private MethodSpec createBindingViewDelegateConstructor() {
+    return MethodSpec.constructorBuilder()
+        .addJavadoc("@deprecated Use {@link #$T($T, $T)} for direct creation.\n    "
+                + "Only present for runtime invocation through {@code ButterKnife.bind()}.\n",
+            bindingClassName, targetTypeName, CONTEXT)
+        .addAnnotation(Deprecated.class)
+        .addAnnotation(UI_THREAD)
+        .addModifiers(PUBLIC)
+        .addParameter(targetTypeName, "target")
+        .addParameter(VIEW, "source")
+        .addStatement(("this(target, source.getContext())"))
+        .build();
+  }
+
+  private MethodSpec createBindingConstructorForView() {
+    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+        .addAnnotation(UI_THREAD)
+        .addModifiers(PUBLIC)
+        .addParameter(targetTypeName, "target");
+    if (constructorNeedsView()) {
+      builder.addStatement("this(target, target)");
+    } else {
+      builder.addStatement("this(target, target.getContext())");
+    }
+    return builder.build();
+  }
+
+  private MethodSpec createBindingConstructorForActivity() {
+    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+        .addAnnotation(UI_THREAD)
+        .addModifiers(PUBLIC)
+        .addParameter(targetTypeName, "target");
+    if (constructorNeedsView()) {
+      builder.addStatement("this(target, target.getWindow().getDecorView())");
+    } else {
+      builder.addStatement("this(target, target)");
+    }
+    return builder.build();
+  }
+
+  private MethodSpec createBindingConstructorForDialog() {
+    MethodSpec.Builder builder = MethodSpec.constructorBuilder()
+        .addAnnotation(UI_THREAD)
+        .addModifiers(PUBLIC)
+        .addParameter(targetTypeName, "target");
+    if (constructorNeedsView()) {
+      builder.addStatement("this(target, target.getWindow().getDecorView())");
+    } else {
+      builder.addStatement("this(target, target.getContext())");
+    }
+    return builder.build();
+  }
+
+  private MethodSpec createBindingConstructor(int sdk, boolean debuggable) {
+    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
+        .addAnnotation(UI_THREAD)
+        .addModifiers(PUBLIC);
+
+    if (hasMethodBindings()) {
+      constructor.addParameter(targetTypeName, "target", FINAL);
+    } else {
+      constructor.addParameter(targetTypeName, "target");
+    }
+
+    if (constructorNeedsView()) {
+      constructor.addParameter(VIEW, "source");
+    } else {
+      constructor.addParameter(CONTEXT, "context");
+    }
+
+    if (hasUnqualifiedResourceBindings()) {
+      // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.
+      constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
+          .addMember("value", "$S", "ResourceType")
+          .build());
+    }
+
+    if (hasOnTouchMethodBindings()) {
+      constructor.addAnnotation(AnnotationSpec.builder(SUPPRESS_LINT)
+          .addMember("value", "$S", "ClickableViewAccessibility")
+          .build());
+    }
+
+    if (parentBinding != null) {
+      if (parentBinding.constructorNeedsView()) {
+        constructor.addStatement("super(target, source)");
+      } else if (constructorNeedsView()) {
+        constructor.addStatement("super(target, source.getContext())");
+      } else {
+        constructor.addStatement("super(target, context)");
+      }
+      constructor.addCode("\n");
+    }
+    if (hasTargetField()) {
+      constructor.addStatement("this.target = target");
+      constructor.addCode("\n");
+    }
+
+    if (hasViewBindings()) {
+      if (hasViewLocal()) {
+        // Local variable in which all views will be temporarily stored.
+        constructor.addStatement("$T view", VIEW);
+      }
+      for (ViewBinding binding : viewBindings) {
+        addViewBinding(constructor, binding, debuggable);
+      }
+      for (FieldCollectionViewBinding binding : collectionBindings) {
+        constructor.addStatement("$L", binding.render(debuggable));
+      }
+
+      if (!resourceBindings.isEmpty()) {
+        constructor.addCode("\n");
+      }
+    }
+
+    if (!resourceBindings.isEmpty()) {
+      if (constructorNeedsView()) {
+        constructor.addStatement("$T context = source.getContext()", CONTEXT);
+      }
+      if (hasResourceBindingsNeedingResource(sdk)) {
+        constructor.addStatement("$T res = context.getResources()", RESOURCES);
+      }
+      for (ResourceBinding binding : resourceBindings) {
+        constructor.addStatement("$L", binding.render(sdk));
+      }
+    }
+
+    return constructor.build();
+  }
+
+  private MethodSpec createBindingUnbindMethod(TypeSpec.Builder bindingClass) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("unbind")
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC);
+    if (!isFinal && parentBinding == null) {
+      result.addAnnotation(CALL_SUPER);
+    }
+
+    if (hasTargetField()) {
+      if (hasFieldBindings()) {
+        result.addStatement("$T target = this.target", targetTypeName);
+      }
+      result.addStatement("if (target == null) throw new $T($S)", IllegalStateException.class,
+          "Bindings already cleared.");
+      result.addStatement("$N = null", hasFieldBindings() ? "this.target" : "target");
+      result.addCode("\n");
+      for (ViewBinding binding : viewBindings) {
+        if (binding.getFieldBinding() != null) {
+          result.addStatement("target.$L = null", binding.getFieldBinding().getName());
+        }
+      }
+      for (FieldCollectionViewBinding binding : collectionBindings) {
+        result.addStatement("target.$L = null", binding.name);
+      }
+    }
+
+    if (hasMethodBindings()) {
+      result.addCode("\n");
+      for (ViewBinding binding : viewBindings) {
+        addFieldAndUnbindStatement(bindingClass, result, binding);
+      }
+    }
+
+    if (parentBinding != null) {
+      result.addCode("\n");
+      result.addStatement("super.unbind()");
+    }
+    return result.build();
+  }
+
+  private void addFieldAndUnbindStatement(TypeSpec.Builder result, MethodSpec.Builder unbindMethod,
+      ViewBinding bindings) {
+    // Only add fields to the binding if there are method bindings.
+    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+        bindings.getMethodBindings();
+    if (classMethodBindings.isEmpty()) {
+      return;
+    }
+
+    String fieldName =
+        bindings.isBoundToRoot()
+            ? "viewSource"
+            : "view" + Integer.toHexString(bindings.getId().value);
+    result.addField(VIEW, fieldName, PRIVATE);
+
+    // We only need to emit the null check if there are zero required bindings.
+    boolean needsNullChecked = bindings.getRequiredBindings().isEmpty();
+    if (needsNullChecked) {
+      unbindMethod.beginControlFlow("if ($N != null)", fieldName);
+    }
+
+    for (ListenerClass listenerClass : classMethodBindings.keySet()) {
+      // We need to keep a reference to the listener
+      // in case we need to unbind it via a remove method.
+      boolean requiresRemoval = !"".equals(listenerClass.remover());
+      String listenerField = "null";
+      if (requiresRemoval) {
+        TypeName listenerClassName = bestGuess(listenerClass.type());
+        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+        result.addField(listenerClassName, listenerField, PRIVATE);
+      }
+
+      String targetType = listenerClass.targetType();
+      if (!VIEW_TYPE.equals(targetType)) {
+        unbindMethod.addStatement("(($T) $N).$N($N)", bestGuess(targetType),
+            fieldName, removerOrSetter(listenerClass, requiresRemoval), listenerField);
+      } else {
+        unbindMethod.addStatement("$N.$N($N)", fieldName,
+            removerOrSetter(listenerClass, requiresRemoval), listenerField);
+      }
+
+      if (requiresRemoval) {
+        unbindMethod.addStatement("$N = null", listenerField);
+      }
+    }
+
+    unbindMethod.addStatement("$N = null", fieldName);
+
+    if (needsNullChecked) {
+      unbindMethod.endControlFlow();
+    }
+  }
+
+  private String removerOrSetter(ListenerClass listenerClass, boolean requiresRemoval) {
+    return requiresRemoval
+        ? listenerClass.remover()
+        : listenerClass.setter();
+  }
+
+  private void addViewBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+    if (binding.isSingleFieldBinding()) {
+      // Optimize the common case where there's a single binding directly to a field.
+      FieldViewBinding fieldBinding = requireNonNull(binding.getFieldBinding());
+      CodeBlock.Builder builder = CodeBlock.builder()
+          .add("target.$L = ", fieldBinding.getName());
+
+      boolean requiresCast = requiresCast(fieldBinding.getType());
+      if (!debuggable || (!requiresCast && !fieldBinding.isRequired())) {
+        if (requiresCast) {
+          builder.add("($T) ", fieldBinding.getType());
+        }
+        builder.add("source.findViewById($L)", binding.getId().code);
+      } else {
+        builder.add("$T.find", UTILS);
+        builder.add(fieldBinding.isRequired() ? "RequiredView" : "OptionalView");
+        if (requiresCast) {
+          builder.add("AsType");
+        }
+        builder.add("(source, $L", binding.getId().code);
+        if (fieldBinding.isRequired() || requiresCast) {
+          builder.add(", $S", asHumanDescription(singletonList(fieldBinding)));
+        }
+        if (requiresCast) {
+          builder.add(", $T.class", fieldBinding.getRawType());
+        }
+        builder.add(")");
+      }
+      result.addStatement("$L", builder.build());
+      return;
+    }
+
+    List<MemberViewBinding> requiredBindings = binding.getRequiredBindings();
+    if (!debuggable || requiredBindings.isEmpty()) {
+      result.addStatement("view = source.findViewById($L)", binding.getId().code);
+    } else if (!binding.isBoundToRoot()) {
+      result.addStatement("view = $T.findRequiredView(source, $L, $S)", UTILS,
+          binding.getId().code, asHumanDescription(requiredBindings));
+    }
+
+    addFieldBinding(result, binding, debuggable);
+    addMethodBindings(result, binding, debuggable);
+  }
+
+  private void addFieldBinding(MethodSpec.Builder result, ViewBinding binding, boolean debuggable) {
+    FieldViewBinding fieldBinding = binding.getFieldBinding();
+    if (fieldBinding != null) {
+      if (requiresCast(fieldBinding.getType())) {
+        if (debuggable) {
+          result.addStatement("target.$L = $T.castView(view, $L, $S, $T.class)",
+              fieldBinding.getName(), UTILS, binding.getId().code,
+              asHumanDescription(singletonList(fieldBinding)), fieldBinding.getRawType());
+        } else {
+          result.addStatement("target.$L = ($T) view", fieldBinding.getName(),
+              fieldBinding.getType());
+        }
+      } else {
+        result.addStatement("target.$L = view", fieldBinding.getName());
+      }
+    }
+  }
+
+  private void addMethodBindings(MethodSpec.Builder result, ViewBinding binding,
+      boolean debuggable) {
+    Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> classMethodBindings =
+        binding.getMethodBindings();
+    if (classMethodBindings.isEmpty()) {
+      return;
+    }
+
+    // We only need to emit the null check if there are zero required bindings.
+    boolean needsNullChecked = binding.getRequiredBindings().isEmpty();
+    if (needsNullChecked) {
+      result.beginControlFlow("if (view != null)");
+    }
+
+    // Add the view reference to the binding.
+    String fieldName = "viewSource";
+    String bindName = "source";
+    if (!binding.isBoundToRoot()) {
+      fieldName = "view" + Integer.toHexString(binding.getId().value);
+      bindName = "view";
+    }
+    result.addStatement("$L = $N", fieldName, bindName);
+
+    for (Map.Entry<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> e
+        : classMethodBindings.entrySet()) {
+      ListenerClass listener = e.getKey();
+      Map<ListenerMethod, Set<MethodViewBinding>> methodBindings = e.getValue();
+
+      TypeSpec.Builder callback = TypeSpec.anonymousClassBuilder("")
+          .superclass(ClassName.bestGuess(listener.type()));
+
+      for (ListenerMethod method : getListenerMethods(listener)) {
+        MethodSpec.Builder callbackMethod = MethodSpec.methodBuilder(method.name())
+            .addAnnotation(Override.class)
+            .addModifiers(PUBLIC)
+            .returns(bestGuess(method.returnType()));
+        String[] parameterTypes = method.parameters();
+        for (int i = 0, count = parameterTypes.length; i < count; i++) {
+          callbackMethod.addParameter(bestGuess(parameterTypes[i]), "p" + i);
+        }
+
+        boolean hasReturnValue = false;
+        CodeBlock.Builder builder = CodeBlock.builder();
+        Set<MethodViewBinding> methodViewBindings = methodBindings.get(method);
+        if (methodViewBindings != null) {
+          for (MethodViewBinding methodBinding : methodViewBindings) {
+            if (methodBinding.hasReturnValue()) {
+              hasReturnValue = true;
+              builder.add("return "); // TODO what about multiple methods?
+            }
+            builder.add("target.$L(", methodBinding.getName());
+            List<Parameter> parameters = methodBinding.getParameters();
+            String[] listenerParameters = method.parameters();
+            for (int i = 0, count = parameters.size(); i < count; i++) {
+              if (i > 0) {
+                builder.add(", ");
+              }
+
+              Parameter parameter = parameters.get(i);
+              int listenerPosition = parameter.getListenerPosition();
+
+              if (parameter.requiresCast(listenerParameters[listenerPosition])) {
+                if (debuggable) {
+                  builder.add("$T.castParam(p$L, $S, $L, $S, $L, $T.class)", UTILS,
+                      listenerPosition, method.name(), listenerPosition, methodBinding.getName(), i,
+                      parameter.getType());
+                } else {
+                  builder.add("($T) p$L", parameter.getType(), listenerPosition);
+                }
+              } else {
+                builder.add("p$L", listenerPosition);
+              }
+            }
+            builder.add(");\n");
+          }
+        }
+
+        if (!"void".equals(method.returnType()) && !hasReturnValue) {
+          builder.add("return $L;\n", method.defaultReturn());
+        }
+
+        callbackMethod.addCode(builder.build());
+        callback.addMethod(callbackMethod.build());
+      }
+
+      boolean requiresRemoval = listener.remover().length() != 0;
+      String listenerField = null;
+      if (requiresRemoval) {
+        TypeName listenerClassName = bestGuess(listener.type());
+        listenerField = fieldName + ((ClassName) listenerClassName).simpleName();
+        result.addStatement("$L = $L", listenerField, callback.build());
+      }
+
+      String targetType = listener.targetType();
+      if (!VIEW_TYPE.equals(targetType)) {
+        result.addStatement("(($T) $N).$L($L)", bestGuess(targetType), bindName,
+            listener.setter(), requiresRemoval ? listenerField : callback.build());
+      } else {
+        result.addStatement("$N.$L($L)", bindName, listener.setter(),
+            requiresRemoval ? listenerField : callback.build());
+      }
+    }
+
+    if (needsNullChecked) {
+      result.endControlFlow();
+    }
+  }
+
+  private static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
+    if (listener.method().length == 1) {
+      return Arrays.asList(listener.method());
+    }
+
+    try {
+      List<ListenerMethod> methods = new ArrayList<>();
+      Class<? extends Enum<?>> callbacks = listener.callbacks();
+      for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
+        Field callbackField = callbacks.getField(callbackMethod.name());
+        ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
+        if (method == null) {
+          throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
+              callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
+              callbackMethod.name(), ListenerMethod.class.getSimpleName()));
+        }
+        methods.add(method);
+      }
+      return methods;
+    } catch (NoSuchFieldException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  static String asHumanDescription(Collection<? extends MemberViewBinding> bindings) {
+    Iterator<? extends MemberViewBinding> iterator = bindings.iterator();
+    switch (bindings.size()) {
+      case 1:
+        return iterator.next().getDescription();
+      case 2:
+        return iterator.next().getDescription() + " and " + iterator.next().getDescription();
+      default:
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0, count = bindings.size(); i < count; i++) {
+          if (i != 0) {
+            builder.append(", ");
+          }
+          if (i == count - 1) {
+            builder.append("and ");
+          }
+          builder.append(iterator.next().getDescription());
+        }
+        return builder.toString();
+    }
+  }
+
+  private static TypeName bestGuess(String type) {
+    switch (type) {
+      case "void": return TypeName.VOID;
+      case "boolean": return TypeName.BOOLEAN;
+      case "byte": return TypeName.BYTE;
+      case "char": return TypeName.CHAR;
+      case "double": return TypeName.DOUBLE;
+      case "float": return TypeName.FLOAT;
+      case "int": return TypeName.INT;
+      case "long": return TypeName.LONG;
+      case "short": return TypeName.SHORT;
+      default:
+        int left = type.indexOf('<');
+        if (left != -1) {
+          ClassName typeClassName = ClassName.bestGuess(type.substring(0, left));
+          List<TypeName> typeArguments = new ArrayList<>();
+          do {
+            typeArguments.add(WildcardTypeName.subtypeOf(Object.class));
+            left = type.indexOf('<', left + 1);
+          } while (left != -1);
+          return ParameterizedTypeName.get(typeClassName,
+              typeArguments.toArray(new TypeName[typeArguments.size()]));
+        }
+        return ClassName.bestGuess(type);
+    }
+  }
+
+  /** True when this type's bindings require a view hierarchy. */
+  private boolean hasViewBindings() {
+    return !viewBindings.isEmpty() || !collectionBindings.isEmpty();
+  }
+
+  /** True when this type's bindings use raw integer values instead of {@code R} references. */
+  private boolean hasUnqualifiedResourceBindings() {
+    for (ResourceBinding binding : resourceBindings) {
+      if (!binding.id().qualifed) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** True when this type's bindings use Resource directly instead of Context. */
+  private boolean hasResourceBindingsNeedingResource(int sdk) {
+    for (ResourceBinding binding : resourceBindings) {
+      if (binding.requiresResources(sdk)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private boolean hasMethodBindings() {
+    for (ViewBinding bindings : viewBindings) {
+      if (!bindings.getMethodBindings().isEmpty()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private boolean hasOnTouchMethodBindings() {
+    for (ViewBinding bindings : viewBindings) {
+      if (bindings.getMethodBindings()
+          .containsKey(OnTouch.class.getAnnotation(ListenerClass.class))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private boolean hasFieldBindings() {
+    for (ViewBinding bindings : viewBindings) {
+      if (bindings.getFieldBinding() != null) {
+        return true;
+      }
+    }
+    return !collectionBindings.isEmpty();
+  }
+
+  private boolean hasTargetField() {
+    return hasFieldBindings() || hasMethodBindings();
+  }
+
+  private boolean hasViewLocal() {
+    for (ViewBinding bindings : viewBindings) {
+      if (bindings.requiresLocal()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** True if this binding requires a view. Otherwise only a context is needed. */
+  private boolean constructorNeedsView() {
+    return hasViewBindings() //
+        || (parentBinding != null && parentBinding.constructorNeedsView());
+  }
+
+  static boolean requiresCast(TypeName type) {
+    return !VIEW_TYPE.equals(type.toString());
+  }
+
+  @Override public String toString() {
+    return bindingClassName.toString();
+  }
+
+  static Builder newBuilder(TypeElement enclosingElement) {
+    TypeMirror typeMirror = enclosingElement.asType();
+
+    boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);
+    boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE);
+    boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE);
+
+    TypeName targetType = TypeName.get(typeMirror);
+    if (targetType instanceof ParameterizedTypeName) {
+      targetType = ((ParameterizedTypeName) targetType).rawType;
+    }
+
+    String packageName = getPackage(enclosingElement).getQualifiedName().toString();
+    String className = enclosingElement.getQualifiedName().toString().substring(
+        packageName.length() + 1).replace('.', '$');
+    ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding");
+
+    boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL);
+    return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog);
+  }
+
+  static final class Builder {
+    private final TypeName targetTypeName;
+    private final ClassName bindingClassName;
+    private final boolean isFinal;
+    private final boolean isView;
+    private final boolean isActivity;
+    private final boolean isDialog;
+
+    private @Nullable BindingSet parentBinding;
+
+    private final Map<Id, ViewBinding.Builder> viewIdMap = new LinkedHashMap<>();
+    private final ImmutableList.Builder<FieldCollectionViewBinding> collectionBindings =
+        ImmutableList.builder();
+    private final ImmutableList.Builder<ResourceBinding> resourceBindings = ImmutableList.builder();
+
+    private Builder(TypeName targetTypeName, ClassName bindingClassName, boolean isFinal,
+        boolean isView, boolean isActivity, boolean isDialog) {
+      this.targetTypeName = targetTypeName;
+      this.bindingClassName = bindingClassName;
+      this.isFinal = isFinal;
+      this.isView = isView;
+      this.isActivity = isActivity;
+      this.isDialog = isDialog;
+    }
+
+    void addField(Id id, FieldViewBinding binding) {
+      getOrCreateViewBindings(id).setFieldBinding(binding);
+    }
+
+    void addFieldCollection(FieldCollectionViewBinding binding) {
+      collectionBindings.add(binding);
+    }
+
+    boolean addMethod(
+        Id id,
+        ListenerClass listener,
+        ListenerMethod method,
+        MethodViewBinding binding) {
+      ViewBinding.Builder viewBinding = getOrCreateViewBindings(id);
+      if (viewBinding.hasMethodBinding(listener, method) && !"void".equals(method.returnType())) {
+        return false;
+      }
+      viewBinding.addMethodBinding(listener, method, binding);
+      return true;
+    }
+
+    void addResource(ResourceBinding binding) {
+      resourceBindings.add(binding);
+    }
+
+    void setParent(BindingSet parent) {
+      this.parentBinding = parent;
+    }
+
+    @Nullable String findExistingBindingName(Id id) {
+      ViewBinding.Builder builder = viewIdMap.get(id);
+      if (builder == null) {
+        return null;
+      }
+      FieldViewBinding fieldBinding = builder.fieldBinding;
+      if (fieldBinding == null) {
+        return null;
+      }
+      return fieldBinding.getName();
+    }
+
+    private ViewBinding.Builder getOrCreateViewBindings(Id id) {
+      ViewBinding.Builder viewId = viewIdMap.get(id);
+      if (viewId == null) {
+        viewId = new ViewBinding.Builder(id);
+        viewIdMap.put(id, viewId);
+      }
+      return viewId;
+    }
+
+    BindingSet build() {
+      ImmutableList.Builder<ViewBinding> viewBindings = ImmutableList.builder();
+      for (ViewBinding.Builder builder : viewIdMap.values()) {
+        viewBindings.add(builder.build());
+      }
+      return new BindingSet(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,
+          viewBindings.build(), collectionBindings.build(), resourceBindings.build(),
+          parentBinding);
+    }
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
new file mode 100644
index 00000000..3f30e35d
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -0,0 +1,1385 @@
+package butterknife.compiler;
+
+import butterknife.BindAnim;
+import butterknife.BindArray;
+import butterknife.BindBitmap;
+import butterknife.BindBool;
+import butterknife.BindColor;
+import butterknife.BindDimen;
+import butterknife.BindDrawable;
+import butterknife.BindFloat;
+import butterknife.BindFont;
+import butterknife.BindInt;
+import butterknife.BindString;
+import butterknife.BindView;
+import butterknife.BindViews;
+import butterknife.OnCheckedChanged;
+import butterknife.OnClick;
+import butterknife.OnEditorAction;
+import butterknife.OnFocusChange;
+import butterknife.OnItemClick;
+import butterknife.OnItemLongClick;
+import butterknife.OnItemSelected;
+import butterknife.OnLongClick;
+import butterknife.OnPageChange;
+import butterknife.OnTextChanged;
+import butterknife.OnTouch;
+import butterknife.Optional;
+import butterknife.compiler.FieldTypefaceBinding.TypefaceStyles;
+import butterknife.internal.ListenerClass;
+import butterknife.internal.ListenerMethod;
+import com.google.auto.common.SuperficialValidation;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.TypeName;
+import com.sun.source.util.Trees;
+import com.sun.tools.javac.code.Symbol;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.TreeScanner;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Deque;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+import static butterknife.internal.Constants.NO_RES_ID;
+import static java.util.Objects.requireNonNull;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+@AutoService(Processor.class)
+@SuppressWarnings("NullAway") // TODO fix all these...
+public final class ButterKnifeProcessor extends AbstractProcessor {
+  // TODO remove when http://b.android.com/187527 is released.
+  private static final String OPTION_SDK_INT = "butterknife.minSdk";
+  private static final String OPTION_DEBUGGABLE = "butterknife.debuggable";
+  static final Id NO_ID = new Id(NO_RES_ID);
+  static final String VIEW_TYPE = "android.view.View";
+  static final String ACTIVITY_TYPE = "android.app.Activity";
+  static final String DIALOG_TYPE = "android.app.Dialog";
+  private static final String COLOR_STATE_LIST_TYPE = "android.content.res.ColorStateList";
+  private static final String BITMAP_TYPE = "android.graphics.Bitmap";
+  private static final String ANIMATION_TYPE = "android.view.animation.Animation";
+  private static final String DRAWABLE_TYPE = "android.graphics.drawable.Drawable";
+  private static final String TYPED_ARRAY_TYPE = "android.content.res.TypedArray";
+  private static final String TYPEFACE_TYPE = "android.graphics.Typeface";
+  private static final String NULLABLE_ANNOTATION_NAME = "Nullable";
+  private static final String STRING_TYPE = "java.lang.String";
+  private static final String LIST_TYPE = List.class.getCanonicalName();
+  private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
+      OnCheckedChanged.class, //
+      OnClick.class, //
+      OnEditorAction.class, //
+      OnFocusChange.class, //
+      OnItemClick.class, //
+      OnItemLongClick.class, //
+      OnItemSelected.class, //
+      OnLongClick.class, //
+      OnPageChange.class, //
+      OnTextChanged.class, //
+      OnTouch.class //
+  );
+
+  private Types typeUtils;
+  private Filer filer;
+  private @Nullable Trees trees;
+
+  private int sdk = 1;
+  private boolean debuggable = true;
+
+  private final RScanner rScanner = new RScanner();
+
+  @Override public synchronized void init(ProcessingEnvironment env) {
+    super.init(env);
+
+    String sdk = env.getOptions().get(OPTION_SDK_INT);
+    if (sdk != null) {
+      try {
+        this.sdk = Integer.parseInt(sdk);
+      } catch (NumberFormatException e) {
+        env.getMessager()
+            .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '"
+                + sdk
+                + "'. Falling back to API 1 support.");
+      }
+    }
+
+    debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
+
+    typeUtils = env.getTypeUtils();
+    filer = env.getFiler();
+    try {
+      trees = Trees.instance(processingEnv);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
+  @Override public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(OPTION_SDK_INT, OPTION_DEBUGGABLE);
+  }
+
+  @Override public Set<String> getSupportedAnnotationTypes() {
+    Set<String> types = new LinkedHashSet<>();
+    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
+      types.add(annotation.getCanonicalName());
+    }
+    return types;
+  }
+
+  private Set<Class<? extends Annotation>> getSupportedAnnotations() {
+    Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
+
+    annotations.add(BindAnim.class);
+    annotations.add(BindArray.class);
+    annotations.add(BindBitmap.class);
+    annotations.add(BindBool.class);
+    annotations.add(BindColor.class);
+    annotations.add(BindDimen.class);
+    annotations.add(BindDrawable.class);
+    annotations.add(BindFloat.class);
+    annotations.add(BindFont.class);
+    annotations.add(BindInt.class);
+    annotations.add(BindString.class);
+    annotations.add(BindView.class);
+    annotations.add(BindViews.class);
+    annotations.addAll(LISTENERS);
+
+    return annotations;
+  }
+
+  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
+
+    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
+      TypeElement typeElement = entry.getKey();
+      BindingSet binding = entry.getValue();
+
+      JavaFile javaFile = binding.brewJava(sdk, debuggable);
+      try {
+        javaFile.writeTo(filer);
+      } catch (IOException e) {
+        error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
+      }
+    }
+
+    return false;
+  }
+
+  private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
+    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
+    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
+
+    // Process each @BindAnim element.
+    for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceAnimation(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindAnim.class, e);
+      }
+    }
+
+    // Process each @BindArray element.
+    for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceArray(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindArray.class, e);
+      }
+    }
+
+    // Process each @BindBitmap element.
+    for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceBitmap(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindBitmap.class, e);
+      }
+    }
+
+    // Process each @BindBool element.
+    for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceBool(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindBool.class, e);
+      }
+    }
+
+    // Process each @BindColor element.
+    for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceColor(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindColor.class, e);
+      }
+    }
+
+    // Process each @BindDimen element.
+    for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceDimen(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindDimen.class, e);
+      }
+    }
+
+    // Process each @BindDrawable element.
+    for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceDrawable(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindDrawable.class, e);
+      }
+    }
+
+    // Process each @BindFloat element.
+    for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceFloat(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindFloat.class, e);
+      }
+    }
+
+    // Process each @BindFont element.
+    for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceFont(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindFont.class, e);
+      }
+    }
+
+    // Process each @BindInt element.
+    for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceInt(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindInt.class, e);
+      }
+    }
+
+    // Process each @BindString element.
+    for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseResourceString(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindString.class, e);
+      }
+    }
+
+    // Process each @BindView element.
+    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
+      // we don't SuperficialValidation.validateElement(element)
+      // so that an unresolved View type can be generated by later processing rounds
+      try {
+        parseBindView(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindView.class, e);
+      }
+    }
+
+    // Process each @BindViews element.
+    for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
+      // we don't SuperficialValidation.validateElement(element)
+      // so that an unresolved View type can be generated by later processing rounds
+      try {
+        parseBindViews(element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        logParsingError(element, BindViews.class, e);
+      }
+    }
+
+    // Process each annotation that corresponds to a listener.
+    for (Class<? extends Annotation> listener : LISTENERS) {
+      findAndParseListener(env, listener, builderMap, erasedTargetNames);
+    }
+
+    // Associate superclass binders with their subclass binders. This is a queue-based tree walk
+    // which starts at the roots (superclasses) and walks to the leafs (subclasses).
+    Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
+        new ArrayDeque<>(builderMap.entrySet());
+    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
+    while (!entries.isEmpty()) {
+      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();
+
+      TypeElement type = entry.getKey();
+      BindingSet.Builder builder = entry.getValue();
+
+      TypeElement parentType = findParentType(type, erasedTargetNames);
+      if (parentType == null) {
+        bindingMap.put(type, builder.build());
+      } else {
+        BindingSet parentBinding = bindingMap.get(parentType);
+        if (parentBinding != null) {
+          builder.setParent(parentBinding);
+          bindingMap.put(type, builder.build());
+        } else {
+          // Has a superclass binding but we haven't built it yet. Re-enqueue for later.
+          entries.addLast(entry);
+        }
+      }
+    }
+
+    return bindingMap;
+  }
+
+  private void logParsingError(Element element, Class<? extends Annotation> annotation,
+      Exception e) {
+    StringWriter stackTrace = new StringWriter();
+    e.printStackTrace(new PrintWriter(stackTrace));
+    error(element, "Unable to parse @%s binding.\n\n%s", annotation.getSimpleName(), stackTrace);
+  }
+
+  private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass,
+      String targetThing, Element element) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify field or method modifiers.
+    Set<Modifier> modifiers = element.getModifiers();
+    if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
+      error(element, "@%s %s must not be private or static. (%s.%s)",
+          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify containing type.
+    if (enclosingElement.getKind() != CLASS) {
+      error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
+          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify containing class visibility is not private.
+    if (enclosingElement.getModifiers().contains(PRIVATE)) {
+      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
+          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    return hasError;
+  }
+
+  private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
+      Element element) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+    String qualifiedName = enclosingElement.getQualifiedName().toString();
+
+    if (qualifiedName.startsWith("android.")) {
+      error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
+          annotationClass.getSimpleName(), qualifiedName);
+      return true;
+    }
+    if (qualifiedName.startsWith("java.")) {
+      error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
+          annotationClass.getSimpleName(), qualifiedName);
+      return true;
+    }
+
+    return false;
+  }
+
+  private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+      Set<TypeElement> erasedTargetNames) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Start by verifying common generated code restrictions.
+    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
+        || isBindingInWrongPackage(BindView.class, element);
+
+    // Verify that the target type extends from View.
+    TypeMirror elementType = element.asType();
+    if (elementType.getKind() == TypeKind.TYPEVAR) {
+      TypeVariable typeVariable = (TypeVariable) elementType;
+      elementType = typeVariable.getUpperBound();
+    }
+    Name qualifiedName = enclosingElement.getQualifiedName();
+    Name simpleName = element.getSimpleName();
+    if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
+      if (elementType.getKind() == TypeKind.ERROR) {
+        note(element, "@%s field with unresolved type (%s) "
+                + "must elsewhere be generated as a View or interface. (%s.%s)",
+            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
+      } else {
+        error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
+            BindView.class.getSimpleName(), qualifiedName, simpleName);
+        hasError = true;
+      }
+    }
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    int id = element.getAnnotation(BindView.class).value();
+    BindingSet.Builder builder = builderMap.get(enclosingElement);
+    Id resourceId = elementToId(element, BindView.class, id);
+    if (builder != null) {
+      String existingBindingName = builder.findExistingBindingName(resourceId);
+      if (existingBindingName != null) {
+        error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
+            BindView.class.getSimpleName(), id, existingBindingName,
+            enclosingElement.getQualifiedName(), element.getSimpleName());
+        return;
+      }
+    } else {
+      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    }
+
+    String name = simpleName.toString();
+    TypeName type = TypeName.get(elementType);
+    boolean required = isFieldRequired(element);
+
+    builder.addField(resourceId, new FieldViewBinding(name, type, required));
+
+    // Add the type-erased version to the valid binding targets set.
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+      Set<TypeElement> erasedTargetNames) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Start by verifying common generated code restrictions.
+    boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
+        || isBindingInWrongPackage(BindViews.class, element);
+
+    // Verify that the type is a List or an array.
+    TypeMirror elementType = element.asType();
+    String erasedType = doubleErasure(elementType);
+    TypeMirror viewType = null;
+    FieldCollectionViewBinding.Kind kind = null;
+    if (elementType.getKind() == TypeKind.ARRAY) {
+      ArrayType arrayType = (ArrayType) elementType;
+      viewType = arrayType.getComponentType();
+      kind = FieldCollectionViewBinding.Kind.ARRAY;
+    } else if (LIST_TYPE.equals(erasedType)) {
+      DeclaredType declaredType = (DeclaredType) elementType;
+      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+      if (typeArguments.size() != 1) {
+        error(element, "@%s List must have a generic component. (%s.%s)",
+            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+            element.getSimpleName());
+        hasError = true;
+      } else {
+        viewType = typeArguments.get(0);
+      }
+      kind = FieldCollectionViewBinding.Kind.LIST;
+    } else {
+      error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      hasError = true;
+    }
+    if (viewType != null && viewType.getKind() == TypeKind.TYPEVAR) {
+      TypeVariable typeVariable = (TypeVariable) viewType;
+      viewType = typeVariable.getUpperBound();
+    }
+
+    // Verify that the target type extends from View.
+    if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
+      if (viewType.getKind() == TypeKind.ERROR) {
+        note(element, "@%s List or array with unresolved type (%s) "
+                + "must elsewhere be generated as a View or interface. (%s.%s)",
+            BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
+            element.getSimpleName());
+      } else {
+        error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
+            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+            element.getSimpleName());
+        hasError = true;
+      }
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int[] ids = element.getAnnotation(BindViews.class).value();
+    if (ids.length == 0) {
+      error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      hasError = true;
+    }
+
+    Integer duplicateId = findDuplicate(ids);
+    if (duplicateId != null) {
+      error(element, "@%s annotation contains duplicate ID %d. (%s.%s)",
+          BindViews.class.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    if (hasError) {
+      return;
+    }
+
+    TypeName type = TypeName.get(requireNonNull(viewType));
+    boolean required = isFieldRequired(element);
+
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addFieldCollection(new FieldCollectionViewBinding(name, type, requireNonNull(kind),
+        new ArrayList<>(elementToIds(element, BindViews.class, ids).values()), required));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceAnimation(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is Animation.
+    if (!ANIMATION_TYPE.equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'Animation'. (%s.%s)",
+          BindAnim.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindAnim.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindAnim.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindAnim.class).value();
+    Id resourceId = elementToId(element, BindAnim.class, id);
+
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(new FieldAnimationBinding(resourceId, name));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceBool(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is bool.
+    if (element.asType().getKind() != TypeKind.BOOLEAN) {
+      error(element, "@%s field type must be 'boolean'. (%s.%s)",
+          BindBool.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindBool.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindBool.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindBool.class).value();
+    Id resourceId = elementToId(element, BindBool.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(
+        new FieldResourceBinding(resourceId, name, FieldResourceBinding.Type.BOOL));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceColor(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is int or ColorStateList.
+    boolean isColorStateList = false;
+    TypeMirror elementType = element.asType();
+    if (COLOR_STATE_LIST_TYPE.equals(elementType.toString())) {
+      isColorStateList = true;
+    } else if (elementType.getKind() != TypeKind.INT) {
+      error(element, "@%s field type must be 'int' or 'ColorStateList'. (%s.%s)",
+          BindColor.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindColor.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindColor.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindColor.class).value();
+    Id resourceId = elementToId(element, BindColor.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+
+    FieldResourceBinding.Type colorStateList = FieldResourceBinding.Type.COLOR_STATE_LIST;
+    FieldResourceBinding.Type color = FieldResourceBinding.Type.COLOR;
+    builder.addResource(new FieldResourceBinding(
+        resourceId,
+        name,
+        isColorStateList ? colorStateList : color));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceDimen(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is int or ColorStateList.
+    boolean isInt = false;
+    TypeMirror elementType = element.asType();
+    if (elementType.getKind() == TypeKind.INT) {
+      isInt = true;
+    } else if (elementType.getKind() != TypeKind.FLOAT) {
+      error(element, "@%s field type must be 'int' or 'float'. (%s.%s)",
+          BindDimen.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindDimen.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindDimen.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindDimen.class).value();
+    Id resourceId = elementToId(element, BindDimen.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(new FieldResourceBinding(resourceId, name,
+        isInt ? FieldResourceBinding.Type.DIMEN_AS_INT : FieldResourceBinding.Type.DIMEN_AS_FLOAT));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceBitmap(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is Bitmap.
+    if (!BITMAP_TYPE.equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'Bitmap'. (%s.%s)",
+          BindBitmap.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindBitmap.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindBitmap.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindBitmap.class).value();
+    Id resourceId = elementToId(element, BindBitmap.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(
+        new FieldResourceBinding(resourceId, name, FieldResourceBinding.Type.BITMAP));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceDrawable(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is Drawable.
+    if (!DRAWABLE_TYPE.equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'Drawable'. (%s.%s)",
+          BindDrawable.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindDrawable.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindDrawable.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindDrawable.class).value();
+    int tint = element.getAnnotation(BindDrawable.class).tint();
+    Map<Integer, Id> resourceIds = elementToIds(element, BindDrawable.class, new int[] {id, tint});
+
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(new FieldDrawableBinding(resourceIds.get(id), name, resourceIds.get(tint)));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceFloat(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is float.
+    if (element.asType().getKind() != TypeKind.FLOAT) {
+      error(element, "@%s field type must be 'float'. (%s.%s)",
+          BindFloat.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindFloat.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindFloat.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindFloat.class).value();
+    Id resourceId = elementToId(element, BindFloat.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(
+        new FieldResourceBinding(resourceId, name, FieldResourceBinding.Type.FLOAT));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceFont(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is a Typeface.
+    if (!TYPEFACE_TYPE.equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'Typeface'. (%s.%s)",
+          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindFont.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindFont.class, element);
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    BindFont bindFont = element.getAnnotation(BindFont.class);
+
+    int styleValue = bindFont.style();
+    TypefaceStyles style = TypefaceStyles.fromValue(styleValue);
+    if (style == null) {
+      error(element, "@%s style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (%s.%s)",
+          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(), name);
+      hasError = true;
+    }
+
+    if (hasError) {
+      return;
+    }
+
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    Id resourceId = elementToId(element, BindFont.class, bindFont.value());
+    builder.addResource(new FieldTypefaceBinding(resourceId, name, style));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceInt(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is int.
+    if (element.asType().getKind() != TypeKind.INT) {
+      error(element, "@%s field type must be 'int'. (%s.%s)", BindInt.class.getSimpleName(),
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindInt.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindInt.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindInt.class).value();
+    Id resourceId = elementToId(element, BindInt.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(
+        new FieldResourceBinding(resourceId, name, FieldResourceBinding.Type.INT));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceString(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is String.
+    if (!STRING_TYPE.equals(element.asType().toString())) {
+      error(element, "@%s field type must be 'String'. (%s.%s)",
+          BindString.class.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindString.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindString.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindString.class).value();
+    Id resourceId = elementToId(element, BindString.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(
+        new FieldResourceBinding(resourceId, name, FieldResourceBinding.Type.STRING));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private void parseResourceArray(Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    boolean hasError = false;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify that the target type is supported.
+    FieldResourceBinding.Type type = getArrayResourceMethodName(element);
+    if (type == null) {
+      error(element,
+          "@%s field type must be one of: String[], int[], CharSequence[], %s. (%s.%s)",
+          BindArray.class.getSimpleName(), TYPED_ARRAY_TYPE, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify common generated code restrictions.
+    hasError |= isInaccessibleViaGeneratedCode(BindArray.class, "fields", element);
+    hasError |= isBindingInWrongPackage(BindArray.class, element);
+
+    if (hasError) {
+      return;
+    }
+
+    // Assemble information on the field.
+    String name = element.getSimpleName().toString();
+    int id = element.getAnnotation(BindArray.class).value();
+    Id resourceId = elementToId(element, BindArray.class, id);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    builder.addResource(new FieldResourceBinding(resourceId, name, requireNonNull(type)));
+
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  /**
+   * Returns a method name from the {@code android.content.res.Resources} class for array resource
+   * binding, null if the element type is not supported.
+   */
+  private static @Nullable FieldResourceBinding.Type getArrayResourceMethodName(Element element) {
+    TypeMirror typeMirror = element.asType();
+    if (TYPED_ARRAY_TYPE.equals(typeMirror.toString())) {
+      return FieldResourceBinding.Type.TYPED_ARRAY;
+    }
+    if (TypeKind.ARRAY.equals(typeMirror.getKind())) {
+      ArrayType arrayType = (ArrayType) typeMirror;
+      String componentType = arrayType.getComponentType().toString();
+      if (STRING_TYPE.equals(componentType)) {
+        return FieldResourceBinding.Type.STRING_ARRAY;
+      } else if ("int".equals(componentType)) {
+        return FieldResourceBinding.Type.INT_ARRAY;
+      } else if ("java.lang.CharSequence".equals(componentType)) {
+        return FieldResourceBinding.Type.TEXT_ARRAY;
+      }
+    }
+    return null;
+  }
+
+  /** Returns the first duplicate element inside an array, null if there are no duplicates. */
+  private static @Nullable Integer findDuplicate(int[] array) {
+    Set<Integer> seenElements = new LinkedHashSet<>();
+
+    for (int element : array) {
+      if (!seenElements.add(element)) {
+        return element;
+      }
+    }
+
+    return null;
+  }
+
+  /** Uses both {@link Types#erasure} and string manipulation to strip any generic types. */
+  private String doubleErasure(TypeMirror elementType) {
+    String name = typeUtils.erasure(elementType).toString();
+    int typeParamStart = name.indexOf('<');
+    if (typeParamStart != -1) {
+      name = name.substring(0, typeParamStart);
+    }
+    return name;
+  }
+
+  private void findAndParseListener(RoundEnvironment env,
+      Class<? extends Annotation> annotationClass,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+    for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
+      if (!SuperficialValidation.validateElement(element)) continue;
+      try {
+        parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);
+      } catch (Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+
+        error(element, "Unable to generate view binder for @%s.\n\n%s",
+            annotationClass.getSimpleName(), stackTrace.toString());
+      }
+    }
+  }
+
+  private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
+      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames)
+      throws Exception {
+    // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
+    if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
+      throw new IllegalStateException(
+          String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
+    }
+
+    ExecutableElement executableElement = (ExecutableElement) element;
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Assemble information on the method.
+    Annotation annotation = element.getAnnotation(annotationClass);
+    Method annotationValue = annotationClass.getDeclaredMethod("value");
+    if (annotationValue.getReturnType() != int[].class) {
+      throw new IllegalStateException(
+          String.format("@%s annotation value() type not int[].", annotationClass));
+    }
+
+    int[] ids = (int[]) annotationValue.invoke(annotation);
+    String name = executableElement.getSimpleName().toString();
+    boolean required = isListenerRequired(executableElement);
+
+    // Verify that the method and its containing class are accessible via generated code.
+    boolean hasError = isInaccessibleViaGeneratedCode(annotationClass, "methods", element);
+    hasError |= isBindingInWrongPackage(annotationClass, element);
+
+    Integer duplicateId = findDuplicate(ids);
+    if (duplicateId != null) {
+      error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
+          annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      hasError = true;
+    }
+
+    ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
+    if (listener == null) {
+      throw new IllegalStateException(
+          String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
+              annotationClass.getSimpleName()));
+    }
+
+    for (int id : ids) {
+      if (id == NO_ID.value) {
+        if (ids.length == 1) {
+          if (!required) {
+            error(element, "ID-free binding must not be annotated with @Optional. (%s.%s)",
+                enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+          }
+        } else {
+          error(element, "@%s annotation contains invalid ID %d. (%s.%s)",
+              annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
+              element.getSimpleName());
+          hasError = true;
+        }
+      }
+    }
+
+    ListenerMethod method;
+    ListenerMethod[] methods = listener.method();
+    if (methods.length > 1) {
+      throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
+          annotationClass.getSimpleName()));
+    } else if (methods.length == 1) {
+      if (listener.callbacks() != ListenerClass.NONE.class) {
+        throw new IllegalStateException(
+            String.format("Both method() and callback() defined on @%s.",
+                annotationClass.getSimpleName()));
+      }
+      method = methods[0];
+    } else {
+      Method annotationCallback = annotationClass.getDeclaredMethod("callback");
+      Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
+      Field callbackField = callback.getDeclaringClass().getField(callback.name());
+      method = callbackField.getAnnotation(ListenerMethod.class);
+      if (method == null) {
+        throw new IllegalStateException(
+            String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
+                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
+                callback.name()));
+      }
+    }
+
+    // Verify that the method has equal to or less than the number of parameters as the listener.
+    List<? extends VariableElement> methodParameters = executableElement.getParameters();
+    if (methodParameters.size() > method.parameters().length) {
+      error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
+          annotationClass.getSimpleName(), method.parameters().length,
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      hasError = true;
+    }
+
+    // Verify method return type matches the listener.
+    TypeMirror returnType = executableElement.getReturnType();
+    if (returnType instanceof TypeVariable) {
+      TypeVariable typeVariable = (TypeVariable) returnType;
+      returnType = typeVariable.getUpperBound();
+    }
+    String returnTypeString = returnType.toString();
+    boolean hasReturnValue = !"void".equals(returnTypeString);
+    if (!returnTypeString.equals(method.returnType()) && hasReturnValue) {
+      error(element, "@%s methods must have a '%s' return type. (%s.%s)",
+          annotationClass.getSimpleName(), method.returnType(),
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      hasError = true;
+    }
+
+    if (hasError) {
+      return;
+    }
+
+    Parameter[] parameters = Parameter.NONE;
+    if (!methodParameters.isEmpty()) {
+      parameters = new Parameter[methodParameters.size()];
+      BitSet methodParameterUsed = new BitSet(methodParameters.size());
+      String[] parameterTypes = method.parameters();
+      for (int i = 0; i < methodParameters.size(); i++) {
+        VariableElement methodParameter = methodParameters.get(i);
+        TypeMirror methodParameterType = methodParameter.asType();
+        if (methodParameterType instanceof TypeVariable) {
+          TypeVariable typeVariable = (TypeVariable) methodParameterType;
+          methodParameterType = typeVariable.getUpperBound();
+        }
+
+        for (int j = 0; j < parameterTypes.length; j++) {
+          if (methodParameterUsed.get(j)) {
+            continue;
+          }
+          if ((isSubtypeOfType(methodParameterType, parameterTypes[j])
+              && isSubtypeOfType(methodParameterType, VIEW_TYPE))
+              || isTypeEqual(methodParameterType, parameterTypes[j])
+              || isInterface(methodParameterType)) {
+            parameters[i] = new Parameter(j, TypeName.get(methodParameterType));
+            methodParameterUsed.set(j);
+            break;
+          }
+        }
+        if (parameters[i] == null) {
+          StringBuilder builder = new StringBuilder();
+          builder.append("Unable to match @")
+              .append(annotationClass.getSimpleName())
+              .append(" method arguments. (")
+              .append(enclosingElement.getQualifiedName())
+              .append('.')
+              .append(element.getSimpleName())
+              .append(')');
+          for (int j = 0; j < parameters.length; j++) {
+            Parameter parameter = parameters[j];
+            builder.append("\n\n  Parameter #")
+                .append(j + 1)
+                .append(": ")
+                .append(methodParameters.get(j).asType().toString())
+                .append("\n    ");
+            if (parameter == null) {
+              builder.append("did not match any listener parameters");
+            } else {
+              builder.append("matched listener parameter #")
+                  .append(parameter.getListenerPosition() + 1)
+                  .append(": ")
+                  .append(parameter.getType());
+            }
+          }
+          builder.append("\n\nMethods may have up to ")
+              .append(method.parameters().length)
+              .append(" parameter(s):\n");
+          for (String parameterType : method.parameters()) {
+            builder.append("\n  ").append(parameterType);
+          }
+          builder.append(
+              "\n\nThese may be listed in any order but will be searched for from top to bottom.");
+          error(executableElement, builder.toString());
+          return;
+        }
+      }
+    }
+
+    MethodViewBinding binding =
+        new MethodViewBinding(name, Arrays.asList(parameters), required, hasReturnValue);
+    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+    Map<Integer, Id> resourceIds = elementToIds(element, annotationClass, ids);
+
+    for (Map.Entry<Integer, Id> entry : resourceIds.entrySet()) {
+      if (!builder.addMethod(entry.getValue(), listener, method, binding)) {
+        error(element, "Multiple listener methods with return value specified for ID %d. (%s.%s)",
+            entry.getKey(), enclosingElement.getQualifiedName(), element.getSimpleName());
+        return;
+      }
+    }
+
+    // Add the type-erased version to the valid binding targets set.
+    erasedTargetNames.add(enclosingElement);
+  }
+
+  private boolean isInterface(TypeMirror typeMirror) {
+    return typeMirror instanceof DeclaredType
+        && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
+  }
+
+  static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
+    if (isTypeEqual(typeMirror, otherType)) {
+      return true;
+    }
+    if (typeMirror.getKind() != TypeKind.DECLARED) {
+      return false;
+    }
+    DeclaredType declaredType = (DeclaredType) typeMirror;
+    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+    if (typeArguments.size() > 0) {
+      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
+      typeString.append('<');
+      for (int i = 0; i < typeArguments.size(); i++) {
+        if (i > 0) {
+          typeString.append(',');
+        }
+        typeString.append('?');
+      }
+      typeString.append('>');
+      if (typeString.toString().equals(otherType)) {
+        return true;
+      }
+    }
+    Element element = declaredType.asElement();
+    if (!(element instanceof TypeElement)) {
+      return false;
+    }
+    TypeElement typeElement = (TypeElement) element;
+    TypeMirror superType = typeElement.getSuperclass();
+    if (isSubtypeOfType(superType, otherType)) {
+      return true;
+    }
+    for (TypeMirror interfaceType : typeElement.getInterfaces()) {
+      if (isSubtypeOfType(interfaceType, otherType)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
+    return otherType.equals(typeMirror.toString());
+  }
+
+  private BindingSet.Builder getOrCreateBindingBuilder(
+      Map<TypeElement, BindingSet.Builder> builderMap, TypeElement enclosingElement) {
+    BindingSet.Builder builder = builderMap.get(enclosingElement);
+    if (builder == null) {
+      builder = BindingSet.newBuilder(enclosingElement);
+      builderMap.put(enclosingElement, builder);
+    }
+    return builder;
+  }
+
+  /** Finds the parent binder type in the supplied set, if any. */
+  private @Nullable TypeElement findParentType(TypeElement typeElement, Set<TypeElement> parents) {
+    TypeMirror type;
+    while (true) {
+      type = typeElement.getSuperclass();
+      if (type.getKind() == TypeKind.NONE) {
+        return null;
+      }
+      typeElement = (TypeElement) ((DeclaredType) type).asElement();
+      if (parents.contains(typeElement)) {
+        return typeElement;
+      }
+    }
+  }
+
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  private void error(Element element, String message, Object... args) {
+    printMessage(Kind.ERROR, element, message, args);
+  }
+
+  private void note(Element element, String message, Object... args) {
+    printMessage(Kind.NOTE, element, message, args);
+  }
+
+  private void printMessage(Kind kind, Element element, String message, Object[] args) {
+    if (args.length > 0) {
+      message = String.format(message, args);
+    }
+
+    processingEnv.getMessager().printMessage(kind, message, element);
+  }
+
+  private Id elementToId(Element element, Class<? extends Annotation> annotation, int value) {
+    JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
+    if (tree != null) { // tree can be null if the references are compiled types and not source
+      rScanner.reset();
+      tree.accept(rScanner);
+      if (!rScanner.resourceIds.isEmpty()) {
+        return rScanner.resourceIds.values().iterator().next();
+      }
+    }
+    return new Id(value);
+  }
+
+  private Map<Integer, Id> elementToIds(Element element, Class<? extends Annotation> annotation,
+      int[] values) {
+    Map<Integer, Id> resourceIds = new LinkedHashMap<>();
+    JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
+    if (tree != null) { // tree can be null if the references are compiled types and not source
+      rScanner.reset();
+      tree.accept(rScanner);
+      resourceIds = rScanner.resourceIds;
+    }
+
+    // Every value looked up should have an Id
+    for (int value : values) {
+      resourceIds.putIfAbsent(value, new Id(value));
+    }
+    return resourceIds;
+  }
+
+  private static boolean hasAnnotationWithName(Element element, String simpleName) {
+    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+      String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();
+      if (simpleName.equals(annotationName)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static boolean isFieldRequired(Element element) {
+    return !hasAnnotationWithName(element, NULLABLE_ANNOTATION_NAME);
+  }
+
+  private static boolean isListenerRequired(ExecutableElement element) {
+    return element.getAnnotation(Optional.class) == null;
+  }
+
+  private static @Nullable AnnotationMirror getMirror(Element element,
+      Class<? extends Annotation> annotation) {
+    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
+      if (annotationMirror.getAnnotationType().toString().equals(annotation.getCanonicalName())) {
+        return annotationMirror;
+      }
+    }
+    return null;
+  }
+
+  private static class RScanner extends TreeScanner {
+    Map<Integer, Id> resourceIds = new LinkedHashMap<>();
+
+    @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
+      Symbol symbol = jcFieldAccess.sym;
+      if (symbol.getEnclosingElement() != null
+          && symbol.getEnclosingElement().getEnclosingElement() != null
+          && symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
+        try {
+          int value = (Integer) requireNonNull(((Symbol.VarSymbol) symbol).getConstantValue());
+          resourceIds.put(value, new Id(value, symbol));
+        } catch (Exception ignored) { }
+      }
+    }
+
+    @Override public void visitLiteral(JCTree.JCLiteral jcLiteral) {
+      try {
+        int value = (Integer) jcLiteral.value;
+        resourceIds.put(value, new Id(value));
+      } catch (Exception ignored) { }
+    }
+
+    void reset() {
+      resourceIds.clear();
+    }
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldAnimationBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldAnimationBinding.java
new file mode 100644
index 00000000..739261af
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldAnimationBinding.java
@@ -0,0 +1,28 @@
+package butterknife.compiler;
+
+import com.squareup.javapoet.CodeBlock;
+
+import static butterknife.compiler.BindingSet.ANIMATION_UTILS;
+
+final class FieldAnimationBinding implements ResourceBinding {
+  private final Id id;
+  private final String name;
+
+  FieldAnimationBinding(Id id, String name) {
+    this.id = id;
+    this.name = name;
+  }
+
+  @Override public Id id() {
+    return id;
+  }
+
+  @Override public boolean requiresResources(int sdk) {
+    return false;
+  }
+
+  @Override public CodeBlock render(int sdk) {
+    return CodeBlock.of("target.$L = $T.loadAnimation(context, $L)", name, ANIMATION_UTILS,
+            id.code);
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldCollectionViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldCollectionViewBinding.java
new file mode 100644
index 00000000..b68f6dc5
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldCollectionViewBinding.java
@@ -0,0 +1,75 @@
+package butterknife.compiler;
+
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import java.util.List;
+
+import static butterknife.compiler.BindingSet.UTILS;
+import static butterknife.compiler.BindingSet.requiresCast;
+
+final class FieldCollectionViewBinding {
+  enum Kind {
+    ARRAY("arrayFilteringNull"),
+    LIST("listFilteringNull");
+
+    final String factoryName;
+
+    Kind(String factoryName) {
+      this.factoryName = factoryName;
+    }
+  }
+
+  final String name;
+  private final TypeName type;
+  private final Kind kind;
+  private final boolean required;
+  private final List<Id> ids;
+
+  FieldCollectionViewBinding(String name, TypeName type, Kind kind, List<Id> ids,
+      boolean required) {
+    this.name = name;
+    this.type = type;
+    this.kind = kind;
+    this.ids = ids;
+    this.required = required;
+  }
+
+  CodeBlock render(boolean debuggable) {
+    CodeBlock.Builder builder = CodeBlock.builder()
+        .add("target.$L = $T.$L(", name, UTILS, kind.factoryName);
+    for (int i = 0; i < ids.size(); i++) {
+      if (i > 0) {
+        builder.add(", ");
+      }
+      builder.add("\n");
+
+      Id id = ids.get(i);
+      boolean requiresCast = requiresCast(type);
+      if (!debuggable) {
+        if (requiresCast) {
+          builder.add("($T) ", type);
+        }
+        builder.add("source.findViewById($L)", id.code);
+      } else if (!requiresCast && !required) {
+        builder.add("source.findViewById($L)", id.code);
+      } else {
+        builder.add("$T.find", UTILS);
+        builder.add(required ? "RequiredView" : "OptionalView");
+        if (requiresCast) {
+          builder.add("AsType");
+        }
+        builder.add("(source, $L, \"field '$L'\"", id.code, name);
+        if (requiresCast) {
+          TypeName rawType = type;
+          if (rawType instanceof ParameterizedTypeName) {
+            rawType = ((ParameterizedTypeName) rawType).rawType;
+          }
+          builder.add(", $T.class", rawType);
+        }
+        builder.add(")");
+      }
+    }
+    return builder.add(")").build();
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldDrawableBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldDrawableBinding.java
new file mode 100644
index 00000000..b888a3f0
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldDrawableBinding.java
@@ -0,0 +1,38 @@
+package butterknife.compiler;
+
+import com.squareup.javapoet.CodeBlock;
+
+import static butterknife.compiler.BindingSet.CONTEXT_COMPAT;
+import static butterknife.compiler.BindingSet.UTILS;
+import static butterknife.internal.Constants.NO_RES_ID;
+
+final class FieldDrawableBinding implements ResourceBinding {
+  private final Id id;
+  private final String name;
+  private final Id tintAttributeId;
+
+  FieldDrawableBinding(Id id, String name, Id tintAttributeId) {
+    this.id = id;
+    this.name = name;
+    this.tintAttributeId = tintAttributeId;
+  }
+
+  @Override public Id id() {
+    return id;
+  }
+
+  @Override public boolean requiresResources(int sdk) {
+    return false;
+  }
+
+  @Override public CodeBlock render(int sdk) {
+    if (tintAttributeId.value != NO_RES_ID) {
+      return CodeBlock.of("target.$L = $T.getTintedDrawable(context, $L, $L)", name, UTILS, id.code,
+          tintAttributeId.code);
+    }
+    if (sdk >= 21) {
+      return CodeBlock.of("target.$L = context.getDrawable($L)", name, id.code);
+    }
+    return CodeBlock.of("target.$L = $T.getDrawable(context, $L)", name, CONTEXT_COMPAT, id.code);
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldResourceBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldResourceBinding.java
new file mode 100644
index 00000000..4bf9e7be
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldResourceBinding.java
@@ -0,0 +1,108 @@
+package butterknife.compiler;
+
+import androidx.annotation.Nullable;
+import com.google.common.collect.ImmutableList;
+import com.google.errorprone.annotations.Immutable;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+final class FieldResourceBinding implements ResourceBinding {
+  enum Type {
+    BITMAP(new ResourceMethod(BindingSet.BITMAP_FACTORY, "decodeResource", true, 1)),
+    BOOL("getBoolean"),
+    COLOR(new ResourceMethod(BindingSet.CONTEXT_COMPAT, "getColor", false, 1),
+        new ResourceMethod(null, "getColor", false, 23)),
+    COLOR_STATE_LIST(new ResourceMethod(BindingSet.CONTEXT_COMPAT,
+        "getColorStateList", false, 1),
+        new ResourceMethod(null, "getColorStateList", false, 23)),
+    DIMEN_AS_INT("getDimensionPixelSize"),
+    DIMEN_AS_FLOAT("getDimension"),
+    FLOAT(new ResourceMethod(BindingSet.UTILS, "getFloat", false, 1)),
+    INT("getInteger"),
+    INT_ARRAY("getIntArray"),
+    STRING("getString"),
+    STRING_ARRAY("getStringArray"),
+    TEXT_ARRAY("getTextArray"),
+    TYPED_ARRAY("obtainTypedArray");
+
+    private final ImmutableList<ResourceMethod> methods;
+
+    Type(ResourceMethod... methods) {
+      List<ResourceMethod> methodList = new ArrayList<>(methods.length);
+      Collections.addAll(methodList, methods);
+      Collections.sort(methodList);
+      Collections.reverse(methodList);
+      this.methods = ImmutableList.copyOf(methodList);
+    }
+
+    Type(String methodName) {
+      methods = ImmutableList.of(new ResourceMethod(null, methodName, true, 1));
+    }
+
+    ResourceMethod methodForSdk(int sdk) {
+      for (ResourceMethod method : methods) {
+        if (method.sdk <= sdk) {
+          return method;
+        }
+      }
+      throw new AssertionError();
+    }
+  }
+
+  @Immutable
+  static final class ResourceMethod implements Comparable<ResourceMethod> {
+    @SuppressWarnings("Immutable")
+    final @Nullable ClassName typeName;
+    final String name;
+    final boolean requiresResources;
+    final int sdk;
+
+    ResourceMethod(@Nullable ClassName typeName, String name, boolean requiresResources, int sdk) {
+      this.typeName = typeName;
+      this.name = name;
+      this.requiresResources = requiresResources;
+      this.sdk = sdk;
+    }
+
+    @Override public int compareTo(ResourceMethod other) {
+      return Integer.compare(sdk, other.sdk);
+    }
+  }
+
+  private final Id id;
+  private final String name;
+  private final Type type;
+
+  FieldResourceBinding(Id id, String name, Type type) {
+    this.id = id;
+    this.name = name;
+    this.type = type;
+  }
+
+  @Override public Id id() {
+    return id;
+  }
+
+  @Override public boolean requiresResources(int sdk) {
+    return type.methodForSdk(sdk).requiresResources;
+  }
+
+  @Override public CodeBlock render(int sdk) {
+    ResourceMethod method = type.methodForSdk(sdk);
+    if (method.typeName == null) {
+      if (method.requiresResources) {
+        return CodeBlock.of("target.$L = res.$L($L)", name, method.name, id.code);
+      }
+      return CodeBlock.of("target.$L = context.$L($L)", name, method.name, id.code);
+    }
+    if (method.requiresResources) {
+      return CodeBlock.of("target.$L = $T.$L(res, $L)", name, method.typeName, method.name,
+          id.code);
+    }
+    return CodeBlock.of("target.$L = $T.$L(context, $L)", name, method.typeName, method.name,
+        id.code);
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldTypefaceBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldTypefaceBinding.java
new file mode 100644
index 00000000..21d79116
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldTypefaceBinding.java
@@ -0,0 +1,62 @@
+package butterknife.compiler;
+
+import androidx.annotation.Nullable;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+final class FieldTypefaceBinding implements ResourceBinding {
+  private static final ClassName RESOURCES_COMPAT =
+      ClassName.get("androidx.core.content.res", "ResourcesCompat");
+  private static final ClassName TYPEFACE = ClassName.get("android.graphics", "Typeface");
+
+  /** Keep in sync with {@link android.graphics.Typeface} constants. */
+  enum TypefaceStyles {
+    NORMAL(0),
+    BOLD(1),
+    ITALIC(2),
+    BOLD_ITALIC(3);
+
+    final int value;
+
+    TypefaceStyles(int value) {
+      this.value = value;
+    }
+
+    @Nullable static TypefaceStyles fromValue(int value) {
+      for (TypefaceStyles style : values()) {
+        if (style.value == value) {
+          return style;
+        }
+      }
+      return null;
+    }
+  }
+
+  private final Id id;
+  private final String name;
+  private final TypefaceStyles style;
+
+  FieldTypefaceBinding(Id id, String name, TypefaceStyles style) {
+    this.id = id;
+    this.name = name;
+    this.style = style;
+  }
+
+  @Override public Id id() {
+    return id;
+  }
+
+  @Override public boolean requiresResources(int sdk) {
+    return sdk >= 26;
+  }
+
+  @Override public CodeBlock render(int sdk) {
+    CodeBlock typeface = sdk >= 26
+        ? CodeBlock.of("res.getFont($L)", id.code)
+        : CodeBlock.of("$T.getFont(context, $L)", RESOURCES_COMPAT, id.code);
+    if (style != TypefaceStyles.NORMAL) {
+      typeface = CodeBlock.of("$1T.create($2L, $1T.$3L)", TYPEFACE, typeface, style);
+    }
+    return CodeBlock.of("target.$L = $L", name, typeface);
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/FieldViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/FieldViewBinding.java
new file mode 100644
index 00000000..0abd6974
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/FieldViewBinding.java
@@ -0,0 +1,40 @@
+package butterknife.compiler;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+
+final class FieldViewBinding implements MemberViewBinding {
+  private final String name;
+  private final TypeName type;
+  private final boolean required;
+
+  FieldViewBinding(String name, TypeName type, boolean required) {
+    this.name = name;
+    this.type = type;
+    this.required = required;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public TypeName getType() {
+    return type;
+  }
+
+  public ClassName getRawType() {
+    if (type instanceof ParameterizedTypeName) {
+      return ((ParameterizedTypeName) type).rawType;
+    }
+    return (ClassName) type;
+  }
+
+  @Override public String getDescription() {
+    return "field '" + name + "'";
+  }
+
+  public boolean isRequired() {
+    return required;
+  }
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/Id.java b/butterknife-compiler/src/main/java/butterknife/compiler/Id.java
new file mode 100644
index 00000000..84fd6a1d
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/Id.java
@@ -0,0 +1,51 @@
+package butterknife.compiler;
+
+import androidx.annotation.Nullable;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.sun.tools.javac.code.Symbol;
+
+/**
+ * Represents an ID of an Android resource.
+ */
+final class Id {
+  private static final ClassName ANDROID_R = ClassName.get("android", "R");
+  private static final String R = "R";
+
+  final int value;
+  final CodeBlock code;
+  final boolean qualifed;
+
+  Id(int value) {
+    this(value, null);
+  }
+
+  Id(int value, @Nullable Symbol rSymbol) {
+    this.value = value;
+    if (rSymbol != null) {
+      ClassName className = ClassName.get(rSymbol.packge().getQualifiedName().toString(), R,
+          rSymbol.enclClass().name.toString());
+      String resourceName = rSymbol.name.toString();
+
+      this.code = className.topLevelClassName().equals(ANDROID_R)
+        ? CodeBlock.of("$L.$N", className, resourceName)
+        : CodeBlock.of("$T.$N", className, resourceName);
+      this.qualifed = true;
+    } else {
+      this.code = CodeBlock.of("$L", value);
+      this.qualifed = false;
+    }
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Id && value == ((Id) o).value;
+  }
+
+  @Override public int hashCode() {
+    return value;
+  }
+
+  @Override public String toString() {
+    throw new UnsupportedOperationException("Please use value or code explicitly");
+  }
+}
diff --git a/butterknife/src/main/java/butterknife/internal/Binding.java b/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
similarity index 53%
rename from butterknife/src/main/java/butterknife/internal/Binding.java
rename to butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
index 1ab24e66..6e82d46e 100644
--- a/butterknife/src/main/java/butterknife/internal/Binding.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/MemberViewBinding.java
@@ -1,7 +1,7 @@
-package butterknife.internal;
+package butterknife.compiler;
 
-/** A field or method view injection binding. */
-interface Binding {
+/** A field or method view binding. */
+interface MemberViewBinding {
   /** A description of the binding in human readable form (e.g., "field 'foo'"). */
   String getDescription();
 }
diff --git a/butterknife/src/main/java/butterknife/internal/ListenerBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
similarity index 61%
rename from butterknife/src/main/java/butterknife/internal/ListenerBinding.java
rename to butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
index d4c53996..179d7e53 100644
--- a/butterknife/src/main/java/butterknife/internal/ListenerBinding.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/MethodViewBinding.java
@@ -1,18 +1,21 @@
-package butterknife.internal;
+package butterknife.compiler;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-final class ListenerBinding implements Binding {
+final class MethodViewBinding implements MemberViewBinding {
   private final String name;
   private final List<Parameter> parameters;
   private final boolean required;
+  private final boolean hasReturnValue;
 
-  ListenerBinding(String name, List<Parameter> parameters, boolean required) {
+  MethodViewBinding(String name, List<Parameter> parameters, boolean required,
+      boolean hasReturnValue) {
     this.name = name;
-    this.parameters = Collections.unmodifiableList(new ArrayList<Parameter>(parameters));
+    this.parameters = Collections.unmodifiableList(new ArrayList<>(parameters));
     this.required = required;
+    this.hasReturnValue = hasReturnValue;
   }
 
   public String getName() {
@@ -30,4 +33,8 @@ public String getName() {
   public boolean isRequired() {
     return required;
   }
+
+  public boolean hasReturnValue() {
+    return hasReturnValue;
+  }
 }
diff --git a/butterknife/src/main/java/butterknife/internal/Parameter.java b/butterknife-compiler/src/main/java/butterknife/compiler/Parameter.java
similarity index 56%
rename from butterknife/src/main/java/butterknife/internal/Parameter.java
rename to butterknife-compiler/src/main/java/butterknife/compiler/Parameter.java
index df0c34ab..308a8593 100644
--- a/butterknife/src/main/java/butterknife/internal/Parameter.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/Parameter.java
@@ -1,13 +1,15 @@
-package butterknife.internal;
+package butterknife.compiler;
+
+import com.squareup.javapoet.TypeName;
 
 /** Represents a parameter type and its position in the listener method. */
 final class Parameter {
   static final Parameter[] NONE = new Parameter[0];
 
   private final int listenerPosition;
-  private final String type;
+  private final TypeName type;
 
-  Parameter(int listenerPosition, String type) {
+  Parameter(int listenerPosition, TypeName type) {
     this.listenerPosition = listenerPosition;
     this.type = type;
   }
@@ -16,7 +18,11 @@ int getListenerPosition() {
     return listenerPosition;
   }
 
-  String getType() {
+  TypeName getType() {
     return type;
   }
+
+  public boolean requiresCast(String toType) {
+    return !type.toString().equals(toType);
+  }
 }
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ResourceBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/ResourceBinding.java
new file mode 100644
index 00000000..42b63acb
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ResourceBinding.java
@@ -0,0 +1,12 @@
+package butterknife.compiler;
+
+import com.squareup.javapoet.CodeBlock;
+
+interface ResourceBinding {
+  Id id();
+
+  /** True if the code for this binding requires a 'res' variable for {@code Resources} access. */
+  boolean requiresResources(int sdk);
+
+  CodeBlock render(int sdk);
+}
diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java b/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java
new file mode 100644
index 00000000..f2d49f3d
--- /dev/null
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ViewBinding.java
@@ -0,0 +1,116 @@
+package butterknife.compiler;
+
+import butterknife.internal.ListenerClass;
+import butterknife.internal.ListenerMethod;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+final class ViewBinding {
+  private final Id id;
+  private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings;
+  private final @Nullable FieldViewBinding fieldBinding;
+
+  ViewBinding(Id id, Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings,
+      @Nullable FieldViewBinding fieldBinding) {
+    this.id = id;
+    this.methodBindings = methodBindings;
+    this.fieldBinding = fieldBinding;
+  }
+
+  public Id getId() {
+    return id;
+  }
+
+  public @Nullable FieldViewBinding getFieldBinding() {
+    return fieldBinding;
+  }
+
+  public Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> getMethodBindings() {
+    return methodBindings;
+  }
+
+  public List<MemberViewBinding> getRequiredBindings() {
+    List<MemberViewBinding> requiredBindings = new ArrayList<>();
+    if (fieldBinding != null && fieldBinding.isRequired()) {
+      requiredBindings.add(fieldBinding);
+    }
+    for (Map<ListenerMethod, Set<MethodViewBinding>> methodBinding : methodBindings.values()) {
+      for (Set<MethodViewBinding> set : methodBinding.values()) {
+        for (MethodViewBinding binding : set) {
+          if (binding.isRequired()) {
+            requiredBindings.add(binding);
+          }
+        }
+      }
+    }
+    return requiredBindings;
+  }
+
+  public boolean isSingleFieldBinding() {
+    return methodBindings.isEmpty() && fieldBinding != null;
+  }
+
+  public boolean requiresLocal() {
+    if (isBoundToRoot()) {
+      return false;
+    }
+    if (isSingleFieldBinding()) {
+      return false;
+    }
+    return true;
+  }
+
+  public boolean isBoundToRoot() {
+    return ButterKnifeProcessor.NO_ID.equals(id);
+  }
+
+  public static final class Builder {
+    private final Id id;
+
+    private final Map<ListenerClass, Map<ListenerMethod, Set<MethodViewBinding>>> methodBindings =
+        new LinkedHashMap<>();
+    @Nullable FieldViewBinding fieldBinding;
+
+    Builder(Id id) {
+      this.id = id;
+    }
+
+    public boolean hasMethodBinding(ListenerClass listener, ListenerMethod method) {
+      Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
+      return methods != null && methods.containsKey(method);
+    }
+
+    public void addMethodBinding(ListenerClass listener, ListenerMethod method,
+        MethodViewBinding binding) {
+      Map<ListenerMethod, Set<MethodViewBinding>> methods = methodBindings.get(listener);
+      Set<MethodViewBinding> set = null;
+      if (methods == null) {
+        methods = new LinkedHashMap<>();
+        methodBindings.put(listener, methods);
+      } else {
+        set = methods.get(method);
+      }
+      if (set == null) {
+        set = new LinkedHashSet<>();
+        methods.put(method, set);
+      }
+      set.add(binding);
+    }
+
+    public void setFieldBinding(FieldViewBinding fieldBinding) {
+      if (this.fieldBinding != null) {
+        throw new AssertionError();
+      }
+      this.fieldBinding = fieldBinding;
+    }
+
+    public ViewBinding build() {
+      return new ViewBinding(id, methodBindings, fieldBinding);
+    }
+  }
+}
diff --git a/butterknife-compiler/src/test/java/butterknife/compiler/BindingSetTest.java b/butterknife-compiler/src/test/java/butterknife/compiler/BindingSetTest.java
new file mode 100644
index 00000000..26f8d78c
--- /dev/null
+++ b/butterknife-compiler/src/test/java/butterknife/compiler/BindingSetTest.java
@@ -0,0 +1,37 @@
+package butterknife.compiler;
+
+import org.junit.Test;
+
+import static butterknife.compiler.BindingSet.asHumanDescription;
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+
+public class BindingSetTest {
+  @Test public void humanDescriptionJoinWorks() {
+    MemberViewBinding one = new TestViewBinding("one");
+    MemberViewBinding two = new TestViewBinding("two");
+    MemberViewBinding three = new TestViewBinding("three");
+
+    String result1 = asHumanDescription(singletonList(one));
+    assertThat(result1).isEqualTo("one");
+
+    String result2 = asHumanDescription(asList(one, two));
+    assertThat(result2).isEqualTo("one and two");
+
+    String result3 = asHumanDescription(asList(one, two, three));
+    assertThat(result3).isEqualTo("one, two, and three");
+  }
+
+  private static class TestViewBinding implements MemberViewBinding {
+    private final String description;
+
+    private TestViewBinding(String description) {
+      this.description = description;
+    }
+
+    @Override public String getDescription() {
+      return description;
+    }
+  }
+}
diff --git a/butterknife-gradle-plugin/build.gradle b/butterknife-gradle-plugin/build.gradle
new file mode 100644
index 00000000..9b027ef6
--- /dev/null
+++ b/butterknife-gradle-plugin/build.gradle
@@ -0,0 +1,20 @@
+apply plugin: 'java-gradle-plugin'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  compileOnly gradleApi()
+
+  implementation deps.android.gradlePlugin
+  implementation deps.javapoet
+  implementation deps.kotlin.stdLibJdk8
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+  testImplementation deps.androidx.annotations
+  testImplementation deps.compiletesting
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-gradle-plugin/gradle.properties b/butterknife-gradle-plugin/gradle.properties
new file mode 100644
index 00000000..8edce620
--- /dev/null
+++ b/butterknife-gradle-plugin/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Butterknife Gradle Plugin
+POM_ARTIFACT_ID=butterknife-gradle-plugin
+POM_PACKAGING=jar
diff --git a/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ButterKnifePlugin.kt b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ButterKnifePlugin.kt
new file mode 100644
index 00000000..d72b63a9
--- /dev/null
+++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ButterKnifePlugin.kt
@@ -0,0 +1,94 @@
+package butterknife.plugin
+
+import com.android.build.gradle.AppExtension
+import com.android.build.gradle.AppPlugin
+import com.android.build.gradle.FeatureExtension
+import com.android.build.gradle.FeaturePlugin
+import com.android.build.gradle.LibraryExtension
+import com.android.build.gradle.LibraryPlugin
+import com.android.build.gradle.api.BaseVariant
+import com.android.build.gradle.internal.res.GenerateLibraryRFileTask
+import com.android.build.gradle.internal.res.LinkApplicationAndroidResourcesTask
+import groovy.util.XmlSlurper
+import org.gradle.api.DomainObjectSet
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.plugins.ExtensionContainer
+import java.util.concurrent.atomic.AtomicBoolean
+import kotlin.reflect.KClass
+
+class ButterKnifePlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.plugins.all {
+      when (it) {
+        is FeaturePlugin -> {
+          project.extensions[FeatureExtension::class].run {
+            configureR2Generation(project, featureVariants)
+            configureR2Generation(project, libraryVariants)
+          }
+        }
+        is LibraryPlugin -> {
+          project.extensions[LibraryExtension::class].run {
+            configureR2Generation(project, libraryVariants)
+          }
+        }
+        is AppPlugin -> {
+          project.extensions[AppExtension::class].run {
+            configureR2Generation(project, applicationVariants)
+          }
+        }
+      }
+    }
+  }
+
+  // Parse the variant's main manifest file in order to get the package id which is used to create
+  // R.java in the right place.
+  private fun getPackageName(variant : BaseVariant) : String {
+    val slurper = XmlSlurper(false, false)
+    val list = variant.sourceSets.map { it.manifestFile }
+
+    // According to the documentation, the earlier files in the list are meant to be overridden by the later ones.
+    // So the first file in the sourceSets list should be main.
+    val result = slurper.parse(list[0])
+    return result.getProperty("@package").toString()
+  }
+
+  private fun configureR2Generation(project: Project, variants: DomainObjectSet<out BaseVariant>) {
+    variants.all { variant ->
+      val outputDir = project.buildDir.resolve(
+          "generated/source/r2/${variant.dirName}")
+
+      val rPackage = getPackageName(variant)
+      val once = AtomicBoolean()
+      variant.outputs.all { output ->
+        val processResources = output.processResources
+
+        // Though there might be multiple outputs, their R files are all the same. Thus, we only
+        // need to configure the task once with the R.java input and action.
+        if (once.compareAndSet(false, true)) {
+          // TODO: switch to better API once exists in AGP (https://issuetracker.google.com/118668005)
+          val rFile =
+              project.files(
+                  when (processResources) {
+                    is GenerateLibraryRFileTask -> processResources.textSymbolOutputFile
+                    is LinkApplicationAndroidResourcesTask -> processResources.textSymbolOutputFile
+                    else -> throw RuntimeException(
+                        "Minimum supported Android Gradle Plugin is 3.1.0")
+                  })
+                  .builtBy(processResources)
+          project.tasks.create("generate${variant.name.capitalize()}R2", R2Generator::class.java) {
+            it.outputDir = outputDir
+            it.rFile = rFile
+            it.packageName = rPackage
+            it.className = "R2"
+            variant.registerJavaGeneratingTask(it, outputDir)
+          }
+        }
+      }
+    }
+  }
+
+  private operator fun <T : Any> ExtensionContainer.get(type: KClass<T>): T {
+    return getByType(type.java)
+  }
+}
diff --git a/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.kt b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.kt
new file mode 100644
index 00000000..463a7531
--- /dev/null
+++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.kt
@@ -0,0 +1,64 @@
+package butterknife.plugin
+
+import com.squareup.javapoet.ClassName
+import com.squareup.javapoet.FieldSpec
+import com.squareup.javapoet.JavaFile
+import com.squareup.javapoet.TypeSpec
+import java.util.Locale
+import javax.lang.model.element.Modifier.FINAL
+import javax.lang.model.element.Modifier.PUBLIC
+import javax.lang.model.element.Modifier.STATIC
+
+
+private const val ANNOTATION_PACKAGE = "androidx.annotation"
+internal val SUPPORTED_TYPES = setOf("anim", "array", "attr", "bool", "color", "dimen",
+    "drawable", "id", "integer", "layout", "menu", "plurals", "string", "style", "styleable")
+
+/**
+ * Generates a class that contains all supported field names in an R file as final values.
+ * Also enables adding support annotations to indicate the type of resource for every field.
+ */
+class FinalRClassBuilder(
+  private val packageName: String,
+  private val className: String
+) {
+
+  private var resourceTypes = mutableMapOf<String, TypeSpec.Builder>()
+
+  fun build(): JavaFile {
+    val result = TypeSpec.classBuilder(className)
+        .addModifiers(PUBLIC, FINAL)
+    for (type in SUPPORTED_TYPES) {
+      resourceTypes.get(type)?.let {
+        result.addType(it.build())
+      }
+    }
+    return JavaFile.builder(packageName, result.build())
+        .addFileComment("Generated code from Butter Knife gradle plugin. Do not modify!")
+        .build()
+  }
+
+  fun addResourceField(type: String, fieldName: String, fieldValue: String) {
+    if (type !in SUPPORTED_TYPES) {
+      return
+    }
+    val fieldSpecBuilder = FieldSpec.builder(Int::class.javaPrimitiveType, fieldName)
+        .addModifiers(PUBLIC, STATIC, FINAL)
+        .initializer(fieldValue)
+
+    fieldSpecBuilder.addAnnotation(getSupportAnnotationClass(type))
+
+    val resourceType =
+        resourceTypes.getOrPut(type) {
+          TypeSpec.classBuilder(type).addModifiers(PUBLIC, STATIC, FINAL)
+        }
+    resourceType.addField(fieldSpecBuilder.build())
+  }
+
+  private fun getSupportAnnotationClass(type: String): ClassName {
+    return ClassName.get(ANNOTATION_PACKAGE, type.capitalize(Locale.US) + "Res")
+  }
+
+  // TODO https://youtrack.jetbrains.com/issue/KT-28933
+  private fun String.capitalize(locale: Locale) = substring(0, 1).toUpperCase(locale) + substring(1)
+}
diff --git a/butterknife-gradle-plugin/src/main/java/butterknife/plugin/R2Generator.kt b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/R2Generator.kt
new file mode 100644
index 00000000..96e723d0
--- /dev/null
+++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/R2Generator.kt
@@ -0,0 +1,41 @@
+package butterknife.plugin
+
+import org.gradle.api.DefaultTask
+import org.gradle.api.file.FileCollection
+import org.gradle.api.tasks.Input
+import org.gradle.api.tasks.InputFiles
+import org.gradle.api.tasks.OutputDirectory
+import org.gradle.api.tasks.TaskAction
+import java.io.File
+
+open class R2Generator : DefaultTask() {
+  @get:OutputDirectory
+  var outputDir: File? = null
+
+  @get:InputFiles
+  var rFile: FileCollection? = null
+
+  @get:Input
+  var packageName: String? = null
+
+  @get:Input
+  var className: String? = null
+
+  @Suppress("unused") // Invoked by Gradle.
+  @TaskAction
+  fun brewJava() {
+    brewJava(rFile!!.singleFile, outputDir!!, packageName!!, className!!)
+  }
+}
+
+fun brewJava(
+  rFile: File,
+  outputDir: File,
+  packageName: String,
+  className: String
+) {
+  FinalRClassBuilder(packageName, className)
+      .also { ResourceSymbolListReader(it).readSymbolTable(rFile) }
+      .build()
+      .writeTo(outputDir)
+}
diff --git a/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ResourceSymbolListReader.kt b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ResourceSymbolListReader.kt
new file mode 100644
index 00000000..1bcf57fb
--- /dev/null
+++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/ResourceSymbolListReader.kt
@@ -0,0 +1,28 @@
+package butterknife.plugin
+
+import java.io.File
+
+class ResourceSymbolListReader(private val builder: FinalRClassBuilder) {
+
+  fun readSymbolTable(symbolTable: File) {
+    symbolTable.forEachLine { processLine(it) }
+  }
+
+  private fun processLine(line: String) {
+    val values = line.split(' ')
+    if (values.size < 4) {
+      return
+    }
+    val javaType = values[0]
+    if (javaType != "int") {
+      return
+    }
+    val symbolType = values[1]
+    if (symbolType !in SUPPORTED_TYPES) {
+      return
+    }
+    val name = values[2]
+    val value = values[3]
+    builder.addResourceField(symbolType, name, value)
+  }
+}
diff --git a/butterknife-gradle-plugin/src/main/resources/META-INF/gradle-plugins/com.jakewharton.butterknife.properties b/butterknife-gradle-plugin/src/main/resources/META-INF/gradle-plugins/com.jakewharton.butterknife.properties
new file mode 100644
index 00000000..b5f8ecf3
--- /dev/null
+++ b/butterknife-gradle-plugin/src/main/resources/META-INF/gradle-plugins/com.jakewharton.butterknife.properties
@@ -0,0 +1 @@
+implementation-class=butterknife.plugin.ButterKnifePlugin
diff --git a/butterknife-gradle-plugin/src/test/AndroidManifest.xml b/butterknife-gradle-plugin/src/test/AndroidManifest.xml
new file mode 100644
index 00000000..b9637928
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/AndroidManifest.xml
@@ -0,0 +1 @@
+<manifest package="com.example.butterknife"/>
diff --git a/butterknife-gradle-plugin/src/test/build.gradle b/butterknife-gradle-plugin/src/test/build.gradle
new file mode 100644
index 00000000..92f5a7c9
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/build.gradle
@@ -0,0 +1,66 @@
+plugins {
+    id 'com.android.application'
+    id 'com.jakewharton.butterknife'
+}
+
+repositories {
+    google()
+}
+
+android {
+    compileSdkVersion 28
+
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_1_8
+        targetCompatibility = JavaVersion.VERSION_1_8
+    }
+
+    defaultConfig {
+        // This is different than the manifest.
+        applicationId 'com.example.butterknife'
+        minSdkVersion 27
+        targetSdkVersion 27
+        versionCode 1
+        versionName '1.0.0'
+    }
+
+    // Add differing applicationIdSuffixes for debug and release to ensure that the gradle plugin
+    // finds the R.java file correctly.
+    buildTypes {
+        debug {
+            applicationIdSuffix = ".debug"
+        }
+        release {
+            applicationIdSuffix = ".release"
+        }
+    }
+
+    flavorDimensions "flavorA"
+
+    // Override the applicationId in flavors to ensure that the gradle plugin
+    // finds the R.java file correctly.
+    productFlavors {
+        flavorA {
+            applicationId "foo.bar"
+        }
+
+        flavorB {
+            applicationId "bar.foo"
+        }
+    }
+
+    sourceSets {
+        main.java.srcDirs += '../../../../../butterknife/src/main/java'
+        main.java.srcDirs += '../../../../../butterknife-runtime/src/main/java'
+        main.java.srcDirs += '../../../../../butterknife-annotations/src/main/java'
+    }
+
+    lintOptions {
+        checkReleaseBuilds false
+    }
+
+}
+
+dependencies {
+    implementation "androidx.core:core:1.0.0"
+}
diff --git a/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/java/butterknife/test/ButteryActivity.java b/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/java/butterknife/test/ButteryActivity.java
new file mode 100644
index 00000000..6f3a4dec
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/java/butterknife/test/ButteryActivity.java
@@ -0,0 +1,21 @@
+package butterknife.test;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.widget.TextView;
+import butterknife.ButterKnife;
+import butterknife.BindView;
+import com.example.butterknife.R;
+import com.example.butterknife.R2;
+
+class ButteryActivity extends Activity {
+
+  @BindView(R2.id.title) TextView title;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    ButterKnife.bind(this);
+
+  }
+
+}
\ No newline at end of file
diff --git a/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/res/layout/activity_layout.xml b/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/res/layout/activity_layout.xml
new file mode 100644
index 00000000..2a409b84
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/fixtures/suffix_parsed_properly/src/main/res/layout/activity_layout.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent"
+  android:orientation="vertical"
+  android:padding="8dp"
+  tools:ignore="SelectableText">
+  <TextView
+    android:id="@+id/title"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:gravity="center"
+    android:textSize="50sp"/>
+</LinearLayout>
diff --git a/butterknife-gradle-plugin/src/test/java/butterknife/plugin/AndroidHome.kt b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/AndroidHome.kt
new file mode 100644
index 00000000..75592461
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/AndroidHome.kt
@@ -0,0 +1,25 @@
+package butterknife.plugin
+
+import java.io.File
+import java.util.Properties
+
+
+internal fun androidHome(): String {
+    val env = System.getenv("ANDROID_HOME")
+    if (env != null) {
+        return env
+    }
+    val localProp = File(File(System.getProperty("user.dir")).parentFile, "local.properties")
+    if (localProp.exists()) {
+        val prop = Properties()
+        localProp.inputStream().use {
+            prop.load(it)
+        }
+        val sdkHome = prop.getProperty("sdk.dir")
+        if (sdkHome != null) {
+            return sdkHome
+        }
+    }
+    throw IllegalStateException(
+            "Missing 'ANDROID_HOME' environment variable or local.properties with 'sdk.dir'")
+}
\ No newline at end of file
diff --git a/butterknife-gradle-plugin/src/test/java/butterknife/plugin/BuildFilesRule.kt b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/BuildFilesRule.kt
new file mode 100644
index 00000000..fa358db9
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/BuildFilesRule.kt
@@ -0,0 +1,42 @@
+package butterknife.plugin
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+import java.io.File
+
+class BuildFilesRule(private val root: File) : TestRule {
+    override fun apply(base: Statement, description: Description): Statement {
+        return object : Statement() {
+            override fun evaluate() {
+                val settingsFile = File(root, "settings.gradle")
+                val hasSettingsFile = settingsFile.exists()
+                if (!hasSettingsFile) settingsFile.writeText("")
+                val buildFile = File(root, "build.gradle")
+                val hasBuildFile = buildFile.exists()
+                if (hasBuildFile) {
+                    assertThat(buildFile.readText())
+                } else {
+                    val buildFileTemplate = File(root, "../../build.gradle").readText()
+                    buildFile.writeText(buildFileTemplate)
+                }
+
+                val manifestFile = File(root, "src/main/AndroidManifest.xml")
+                val hasManifestFile = manifestFile.exists()
+                if (!hasManifestFile) {
+                    val manifestFileTemplate = File(root, "../../AndroidManifest.xml").readText()
+                    manifestFile.writeText(manifestFileTemplate)
+                }
+
+                try {
+                    base.evaluate()
+                } finally {
+                    if (!hasSettingsFile) settingsFile.delete()
+                    if (!hasBuildFile) buildFile.delete()
+                    if (!hasManifestFile) manifestFile.delete()
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FinalRClassBuilderTest.kt b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FinalRClassBuilderTest.kt
new file mode 100644
index 00000000..656cdddb
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FinalRClassBuilderTest.kt
@@ -0,0 +1,31 @@
+package butterknife.plugin
+
+import com.google.common.truth.Truth.assertAbout
+import com.google.testing.compile.JavaFileObjects
+import com.google.testing.compile.JavaSourceSubjectFactory.javaSource
+import org.junit.Assert.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class FinalRClassBuilderTest {
+  @Rule @JvmField val tempFolder = TemporaryFolder()
+
+  @Test fun brewJava() {
+    val packageName = "com.butterknife.example"
+    val rFile = tempFolder.newFile("R.txt").also {
+      it.writeText(javaClass.getResource("/fixtures/R.txt").readText())
+    }
+
+    val outputDir = tempFolder.newFolder()
+    brewJava(rFile, outputDir, packageName, "R2")
+
+    val actual = outputDir.resolve("com/butterknife/example/R2.java").readText()
+    val expected = javaClass.getResource("/fixtures/R2.java").readText()
+
+    assertEquals(expected.trim(), actual.trim())
+
+    val actualJava = JavaFileObjects.forSourceString("$packageName.R2", actual)
+    assertAbout(javaSource()).that(actualJava).compilesWithoutError()
+  }
+}
diff --git a/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FixturesTest.kt b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FixturesTest.kt
new file mode 100644
index 00000000..8a4966c1
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/java/butterknife/plugin/FixturesTest.kt
@@ -0,0 +1,51 @@
+package butterknife.plugin
+
+import com.google.common.truth.Truth.assertThat
+import org.gradle.testkit.runner.GradleRunner
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import org.junit.runners.Parameterized.Parameters
+import java.io.File
+
+
+@RunWith(Parameterized::class)
+class FixturesTest(val fixtureRoot: File, val name: String) {
+    @Suppress("unused") // Used by JUnit reflectively.
+    @get:Rule val buildFilesRule = BuildFilesRule(fixtureRoot)
+
+    @Test fun execute() {
+        val androidHome = androidHome()
+        File(fixtureRoot, "local.properties").writeText("sdk.dir=$androidHome\n")
+
+        val runner = GradleRunner.create()
+                .withProjectDir(fixtureRoot)
+                .withPluginClasspath()
+                .withArguments("clean", "assembleDebug", "assembleRelease", "--stacktrace")
+
+        if (File(fixtureRoot, "ignored.txt").exists()) {
+            println("Skipping ignored test $name.")
+            return
+        }
+
+        val expectedFailure = File(fixtureRoot, "failure.txt")
+        if (expectedFailure.exists()) {
+            val result = runner.buildAndFail()
+            for (chunk in expectedFailure.readText().split("\n\n")) {
+                assertThat(result.output).contains(chunk)
+            }
+        } else {
+            val result = runner.build()
+            assertThat(result.output).contains("BUILD SUCCESSFUL")
+        }
+    }
+
+    companion object {
+        @Suppress("unused") // Used by Parameterized JUnit runner reflectively.
+        @Parameters(name = "{1}")
+        @JvmStatic fun parameters() = File("src/test/fixtures").listFiles()
+                .filter { it.isDirectory }
+                .map { arrayOf(it, it.name) }
+    }
+}
\ No newline at end of file
diff --git a/butterknife-gradle-plugin/src/test/resources/fixtures/R.txt b/butterknife-gradle-plugin/src/test/resources/fixtures/R.txt
new file mode 100644
index 00000000..1117f0d8
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/resources/fixtures/R.txt
@@ -0,0 +1,18 @@
+int unsupported res 0x7f040000
+int anim res 0x7f040001
+int array res 0x7f040002
+int attr res 0x7f040003
+int bool res 0x7f040004
+int color res 0x7f040005
+int dimen res 0x7f040006
+int drawable res 0x7f040007
+int id res 0x7f040008
+int integer res 0x7f040009
+int layout res 0x7f040010
+int menu res 0x7f040011
+int plurals res 0x7f040012
+int string res 0x7f040013
+int style res 0x7f040014
+int[] styleable resArray { 0x7f040003 , 0x7f040015 }
+int styleable resArray_child 0
+int styleable resArray_child2 1
diff --git a/butterknife-gradle-plugin/src/test/resources/fixtures/R2.java b/butterknife-gradle-plugin/src/test/resources/fixtures/R2.java
new file mode 100644
index 00000000..095214bb
--- /dev/null
+++ b/butterknife-gradle-plugin/src/test/resources/fixtures/R2.java
@@ -0,0 +1,98 @@
+// Generated code from Butter Knife gradle plugin. Do not modify!
+package com.butterknife.example;
+
+import androidx.annotation.AnimRes;
+import androidx.annotation.ArrayRes;
+import androidx.annotation.AttrRes;
+import androidx.annotation.BoolRes;
+import androidx.annotation.ColorRes;
+import androidx.annotation.DimenRes;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.IdRes;
+import androidx.annotation.IntegerRes;
+import androidx.annotation.LayoutRes;
+import androidx.annotation.MenuRes;
+import androidx.annotation.PluralsRes;
+import androidx.annotation.StringRes;
+import androidx.annotation.StyleRes;
+import androidx.annotation.StyleableRes;
+
+public final class R2 {
+  public static final class anim {
+    @AnimRes
+    public static final int res = 0x7f040001;
+  }
+
+  public static final class array {
+    @ArrayRes
+    public static final int res = 0x7f040002;
+  }
+
+  public static final class attr {
+    @AttrRes
+    public static final int res = 0x7f040003;
+  }
+
+  public static final class bool {
+    @BoolRes
+    public static final int res = 0x7f040004;
+  }
+
+  public static final class color {
+    @ColorRes
+    public static final int res = 0x7f040005;
+  }
+
+  public static final class dimen {
+    @DimenRes
+    public static final int res = 0x7f040006;
+  }
+
+  public static final class drawable {
+    @DrawableRes
+    public static final int res = 0x7f040007;
+  }
+
+  public static final class id {
+    @IdRes
+    public static final int res = 0x7f040008;
+  }
+
+  public static final class integer {
+    @IntegerRes
+    public static final int res = 0x7f040009;
+  }
+
+  public static final class layout {
+    @LayoutRes
+    public static final int res = 0x7f040010;
+  }
+
+  public static final class menu {
+    @MenuRes
+    public static final int res = 0x7f040011;
+  }
+
+  public static final class plurals {
+    @PluralsRes
+    public static final int res = 0x7f040012;
+  }
+
+  public static final class string {
+    @StringRes
+    public static final int res = 0x7f040013;
+  }
+
+  public static final class style {
+    @StyleRes
+    public static final int res = 0x7f040014;
+  }
+
+  public static final class styleable {
+    @StyleableRes
+    public static final int resArray_child = 0;
+
+    @StyleableRes
+    public static final int resArray_child2 = 1;
+  }
+}
diff --git a/butterknife-integration-test/build.gradle b/butterknife-integration-test/build.gradle
new file mode 100644
index 00000000..e604af1f
--- /dev/null
+++ b/butterknife-integration-test/build.gradle
@@ -0,0 +1,70 @@
+apply plugin: 'com.android.application'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  defaultConfig {
+    applicationId 'com.example.butterknife'
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
+    versionCode 1
+    versionName '1.0.0'
+
+    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
+  }
+
+  lintOptions {
+    textReport true
+    textOutput "stdout"
+    checkAllWarnings true
+    warningsAsErrors true
+    disable 'UnknownNullness'
+    showAll true
+    explainIssues true
+    // We run a full lint analysis as build part in CI, so skip vital checks for assemble tasks.
+    checkReleaseBuilds false
+  }
+
+  buildTypes {
+    debug {
+      minifyEnabled true
+      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'src/main/proguard.pro'
+      testProguardFile 'src/androidTest/proguard.pro'
+    }
+  }
+
+  productFlavors {
+    flavorDimensions 'runtime'
+
+    reflect {
+      dimension 'runtime'
+    }
+    codegen {
+      dimension 'runtime'
+    }
+  }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
+}
+
+dependencies {
+  reflectImplementation project(':butterknife-reflect')
+
+  codegenImplementation project(':butterknife')
+  codegenAnnotationProcessor project(':butterknife-compiler')
+  androidTestCodegenAnnotationProcessor project(':butterknife-compiler')
+
+  androidTestImplementation deps.junit
+  androidTestImplementation deps.truth
+  androidTestImplementation deps.androidx.test.runner
+  androidTestImplementation deps.androidx.test.rules
+}
diff --git a/butterknife-integration-test/src/androidTest/font_licenses.txt b/butterknife-integration-test/src/androidTest/font_licenses.txt
new file mode 100644
index 00000000..0b83a9a7
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/font_licenses.txt
@@ -0,0 +1,93 @@
+Copyright 2006 The Inconsolata Project Authors
+
+This Font Software is licensed under the SIL Open Font License, Version 1.1.
+This license is copied below, and is also available with a FAQ at:
+http://scripts.sil.org/OFL
+
+
+-----------------------------------------------------------
+SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
+-----------------------------------------------------------
+
+PREAMBLE
+The goals of the Open Font License (OFL) are to stimulate worldwide
+development of collaborative font projects, to support the font creation
+efforts of academic and linguistic communities, and to provide a free and
+open framework in which fonts may be shared and improved in partnership
+with others.
+
+The OFL allows the licensed fonts to be used, studied, modified and
+redistributed freely as long as they are not sold by themselves. The
+fonts, including any derivative works, can be bundled, embedded, 
+redistributed and/or sold with any software provided that any reserved
+names are not used by derivative works. The fonts and derivatives,
+however, cannot be released under any other type of license. The
+requirement for fonts to remain under this license does not apply
+to any document created using the fonts or their derivatives.
+
+DEFINITIONS
+"Font Software" refers to the set of files released by the Copyright
+Holder(s) under this license and clearly marked as such. This may
+include source files, build scripts and documentation.
+
+"Reserved Font Name" refers to any names specified as such after the
+copyright statement(s).
+
+"Original Version" refers to the collection of Font Software components as
+distributed by the Copyright Holder(s).
+
+"Modified Version" refers to any derivative made by adding to, deleting,
+or substituting -- in part or in whole -- any of the components of the
+Original Version, by changing formats or by porting the Font Software to a
+new environment.
+
+"Author" refers to any designer, engineer, programmer, technical
+writer or other person who contributed to the Font Software.
+
+PERMISSION & CONDITIONS
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of the Font Software, to use, study, copy, merge, embed, modify,
+redistribute, and sell modified and unmodified copies of the Font
+Software, subject to the following conditions:
+
+1) Neither the Font Software nor any of its individual components,
+in Original or Modified Versions, may be sold by itself.
+
+2) Original or Modified Versions of the Font Software may be bundled,
+redistributed and/or sold with any software, provided that each copy
+contains the above copyright notice and this license. These can be
+included either as stand-alone text files, human-readable headers or
+in the appropriate machine-readable metadata fields within text or
+binary files as long as those fields can be easily viewed by the user.
+
+3) No Modified Version of the Font Software may use the Reserved Font
+Name(s) unless explicit written permission is granted by the corresponding
+Copyright Holder. This restriction only applies to the primary font name as
+presented to the users.
+
+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
+Software shall not be used to promote, endorse or advertise any
+Modified Version, except to acknowledge the contribution(s) of the
+Copyright Holder(s) and the Author(s) or with their explicit written
+permission.
+
+5) The Font Software, modified or unmodified, in part or in whole,
+must be distributed entirely under this license, and must not be
+distributed under any other license. The requirement for fonts to
+remain under this license does not apply to any document created
+using the Font Software.
+
+TERMINATION
+This license becomes null and void if any of the above conditions are
+not met.
+
+DISCLAIMER
+THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
+DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
+OTHER DEALINGS IN THE FONT SOFTWARE.
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindAnimTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindAnimTest.java
new file mode 100644
index 00000000..fdfc9c2f
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindAnimTest.java
@@ -0,0 +1,28 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import android.view.animation.Animation;
+import butterknife.BindAnim;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import org.junit.Test;
+
+import static org.junit.Assert.assertNotNull;
+
+public final class BindAnimTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindAnim(android.R.anim.fade_in) Animation actual;
+  }
+
+  @Test public void anim() {
+    Target target = new Target();
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertNotNull(target.actual); // Check more?
+
+    unbinder.unbind();
+    assertNotNull(target.actual);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindArrayTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindArrayTest.java
new file mode 100644
index 00000000..792b403f
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindArrayTest.java
@@ -0,0 +1,62 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindArray;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindArrayTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class StringArrayTarget {
+    @BindArray(R.array.string_one_two_three) String[] actual;
+  }
+
+  @Test public void asStringArray() {
+    StringArrayTarget target = new StringArrayTarget();
+    String[] expected = context.getResources().getStringArray(R.array.string_one_two_three);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+
+  static class IntArrayTarget {
+    @BindArray(R.array.int_one_two_three) int[] actual;
+  }
+
+  @Test public void asIntArray() {
+    IntArrayTarget target = new IntArrayTarget();
+    int[] expected = context.getResources().getIntArray(R.array.int_one_two_three);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+
+  static class CharSequenceArrayTarget {
+    @BindArray(R.array.int_one_two_three) CharSequence[] actual;
+  }
+
+  @Test public void asCharSequenceArray() {
+    CharSequenceArrayTarget target = new CharSequenceArrayTarget();
+    CharSequence[] expected = context.getResources().getTextArray(R.array.int_one_two_three);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBitmapTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBitmapTest.java
new file mode 100644
index 00000000..c918af45
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBitmapTest.java
@@ -0,0 +1,34 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindBitmap;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public final class BindBitmapTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindBitmap(R.drawable.pixel) Bitmap actual;
+  }
+
+  @Test public void asBitmap() {
+    Target target = new Target();
+    Bitmap expected = BitmapFactory.decodeResource(context.getResources(), R.drawable.pixel);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertTrue(target.actual.sameAs(expected));
+
+    unbinder.unbind();
+    assertTrue(target.actual.sameAs(expected));
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBoolTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBoolTest.java
new file mode 100644
index 00000000..6a2be219
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindBoolTest.java
@@ -0,0 +1,32 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindBool;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindBoolTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindBool(R.bool.just_true) boolean actual;
+  }
+
+  @Test public void asBoolean() {
+    Target target = new Target();
+    boolean expected = context.getResources().getBoolean(R.bool.just_true);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindColorTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindColorTest.java
new file mode 100644
index 00000000..99eaa0d7
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindColorTest.java
@@ -0,0 +1,48 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindColorTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class IntTarget {
+    @BindColor(R.color.red) int actual;
+  }
+
+  @Test public void asInt() {
+    IntTarget target = new IntTarget();
+    int expected = context.getResources().getColor(R.color.red);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+
+  static class ColorStateListTarget {
+    @BindColor(R.color.colors) ColorStateList actual;
+  }
+
+  @Test public void asColorStateList() {
+    ColorStateListTarget target = new ColorStateListTarget();
+    ColorStateList expected = context.getResources().getColorStateList(R.color.colors);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual.toString()).isEqualTo(expected.toString());
+
+    unbinder.unbind();
+    assertThat(target.actual.toString()).isEqualTo(expected.toString());
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDimenTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDimenTest.java
new file mode 100644
index 00000000..538e643c
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDimenTest.java
@@ -0,0 +1,47 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindDimen;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindDimenTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class IntTarget {
+    @BindDimen(R.dimen.twelve_point_two_dp) int actual;
+  }
+
+  @Test public void asInt() {
+    IntTarget target = new IntTarget();
+    int expected = context.getResources().getDimensionPixelSize(R.dimen.twelve_point_two_dp);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+
+  static class FloatTarget {
+    @BindDimen(R.dimen.twelve_point_two_dp) float actual;
+  }
+
+  @Test public void asFloat() {
+    FloatTarget target = new FloatTarget();
+    float expected = context.getResources().getDimension(R.dimen.twelve_point_two_dp);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDrawableTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDrawableTest.java
new file mode 100644
index 00000000..37f47c50
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindDrawableTest.java
@@ -0,0 +1,33 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindDrawable;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindDrawableTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindDrawable(R.drawable.circle) Drawable actual;
+  }
+
+  @Test public void asDrawable() {
+    Target target = new Target();
+    Drawable expected = context.getResources().getDrawable(R.drawable.circle);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual.getConstantState()).isEqualTo(expected.getConstantState());
+
+    unbinder.unbind();
+    assertThat(target.actual.getConstantState()).isEqualTo(expected.getConstantState());
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFloatTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFloatTest.java
new file mode 100644
index 00000000..5e2e1e8a
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFloatTest.java
@@ -0,0 +1,35 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.util.TypedValue;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindFloat;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindFloatTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindFloat(R.dimen.twelve_point_two) float actual;
+  }
+
+  @Test public void asFloat() {
+    Target target = new Target();
+    TypedValue value = new TypedValue();
+    context.getResources().getValue(R.dimen.twelve_point_two, value, true);
+    float expected = value.getFloat();
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFontTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFontTest.java
new file mode 100644
index 00000000..b2cb1c57
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindFontTest.java
@@ -0,0 +1,53 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.graphics.Typeface;
+import android.view.View;
+import androidx.core.content.res.ResourcesCompat;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.SdkSuppress;
+import butterknife.BindFont;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static android.graphics.Typeface.BOLD;
+import static com.google.common.truth.Truth.assertThat;
+
+@SdkSuppress(minSdkVersion = 24) // AndroidX problems on earlier versions
+public final class BindFontTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class TargetTypeface {
+    @BindFont(R.font.inconsolata_regular) Typeface actual;
+  }
+
+  @Test public void typeface() {
+    TargetTypeface target = new TargetTypeface();
+    Typeface expected = ResourcesCompat.getFont(context, R.font.inconsolata_regular);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isSameAs(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isSameAs(expected);
+  }
+
+  static class TargetStyle {
+    @BindFont(value = R.font.inconsolata_regular, style = BOLD) Typeface actual;
+  }
+
+  @Test public void style() {
+    TargetStyle target = new TargetStyle();
+    Typeface expected =
+        Typeface.create(ResourcesCompat.getFont(context, R.font.inconsolata_regular), BOLD);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isSameAs(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isSameAs(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindIntTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindIntTest.java
new file mode 100644
index 00000000..4900d396
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindIntTest.java
@@ -0,0 +1,32 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindInt;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindIntTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindInt(R.integer.twelve) int actual;
+  }
+
+  @Test public void asInt() {
+    Target target = new Target();
+    int expected = context.getResources().getInteger(R.integer.twelve);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindStringTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindStringTest.java
new file mode 100644
index 00000000..6a8ce976
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindStringTest.java
@@ -0,0 +1,32 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import butterknife.BindString;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindStringTest {
+  private final Context context = InstrumentationRegistry.getContext();
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindString(R.string.hey) String actual;
+  }
+
+  @Test public void simpleInt() {
+    Target target = new Target();
+    String expected = context.getString(R.string.hey);
+
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isEqualTo(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isEqualTo(expected);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewTest.java
new file mode 100644
index 00000000..7f7fd62f
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewTest.java
@@ -0,0 +1,27 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindViewTest {
+  static class TargetView {
+    @BindView(1) View actual;
+  }
+
+  @Test public void view() {
+    View tree = ViewTree.create(1);
+    View expected = tree.findViewById(1);
+
+    TargetView target = new TargetView();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).isSameAs(expected);
+
+    unbinder.unbind();
+    assertThat(target.actual).isNull();
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewsTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewsTest.java
new file mode 100644
index 00000000..61370435
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/BindViewsTest.java
@@ -0,0 +1,47 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindViews;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import java.util.List;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class BindViewsTest {
+  static class TargetViewArray {
+    @BindViews({1, 2, 3}) View[] actual;
+  }
+
+  @Test public void array() {
+    View tree = ViewTree.create(1, 2, 3);
+    View expected1 = tree.findViewById(1);
+    View expected2 = tree.findViewById(2);
+    View expected3 = tree.findViewById(3);
+
+    TargetViewArray target = new TargetViewArray();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).asList().containsExactly(expected1, expected2, expected3).inOrder();
+
+    unbinder.unbind();
+    assertThat(target.actual).isNull();
+  }
+  static class TargetViewList {
+    @BindViews({1, 2, 3}) List<View> actual;
+  }
+
+  @Test public void list() {
+    View tree = ViewTree.create(1, 2, 3);
+    View expected1 = tree.findViewById(1);
+    View expected2 = tree.findViewById(2);
+    View expected3 = tree.findViewById(3);
+
+    TargetViewList target = new TargetViewList();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertThat(target.actual).containsExactly(expected1, expected2, expected3).inOrder();
+
+    unbinder.unbind();
+    assertThat(target.actual).isNull();
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnCheckedChangedTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnCheckedChangedTest.java
new file mode 100644
index 00000000..d2ecc713
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnCheckedChangedTest.java
@@ -0,0 +1,238 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CompoundButton;
+import android.widget.FrameLayout;
+import android.widget.ToggleButton;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnCheckedChanged;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import com.example.butterknife.BuildConfig;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assume.assumeFalse;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnCheckedChangedTest {
+  static final class Simple {
+    int clicks = 0;
+
+    @OnCheckedChanged(1) void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void simple() {
+    View tree = ViewTree.create(ToggleButton.class, 1);
+    View view1 = tree.findViewById(1);
+
+    Simple target = new Simple();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(1, target.clicks);
+  }
+
+  static final class MultipleBindings {
+    int clicks = 0;
+
+    @OnCheckedChanged(1) void click1() {
+      clicks++;
+    }
+
+    @OnCheckedChanged(1) void clicks2() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleBindings() {
+    assumeFalse("Not implemented", BuildConfig.FLAVOR.equals("reflect")); // TODO
+
+    View tree = ViewTree.create(ToggleButton.class, 1);
+    View view1 = tree.findViewById(1);
+
+    MultipleBindings target = new MultipleBindings();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class Visibilities {
+    int clicks = 0;
+
+    @OnCheckedChanged(1) public void publicClick() {
+      clicks++;
+    }
+
+    @OnCheckedChanged(2) void packageClick() {
+      clicks++;
+    }
+
+    @OnCheckedChanged(3) protected void protectedClick() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void visibilities() {
+    View tree = ViewTree.create(ToggleButton.class, 1, 2, 3);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+    View view3 = tree.findViewById(3);
+
+    Visibilities target = new Visibilities();
+    ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    view2.performClick();
+    assertEquals(2, target.clicks);
+
+    view3.performClick();
+    assertEquals(3, target.clicks);
+  }
+
+  static final class MultipleIds {
+    int clicks = 0;
+
+    @OnCheckedChanged({1, 2}) void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleIds() {
+    View tree = ViewTree.create(ToggleButton.class, 1, 2);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+
+    MultipleIds target = new MultipleIds();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    view2.performClick();
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    view2.performClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class OptionalId {
+    int clicks = 0;
+
+    @Optional @OnCheckedChanged(1) public void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdPresent() {
+    View tree = ViewTree.create(ToggleButton.class, 1);
+    View view1 = tree.findViewById(1);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(1, target.clicks);
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdAbsent() {
+    View tree = ViewTree.create(ToggleButton.class, 2);
+    View view2 = tree.findViewById(2);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view2.performClick();
+    assertEquals(0, target.clicks);
+
+    unbinder.unbind();
+    view2.performClick();
+    assertEquals(0, target.clicks);
+  }
+
+  static final class ArgumentCast {
+    interface MyInterface {}
+
+    View last;
+
+    @OnCheckedChanged(1) void clickTextView(CompoundButton view) {
+      last = view;
+    }
+
+    @OnCheckedChanged(2) void clickButton(ToggleButton view) {
+      last = view;
+    }
+
+    @OnCheckedChanged(3) void clickMyInterface(MyInterface view) {
+      last = (View) view;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void argumentCast() {
+    class MyView extends ToggleButton implements ArgumentCast.MyInterface {
+      MyView(Context context) {
+        super(context);
+      }
+    }
+
+    View view1 = new MyView(InstrumentationRegistry.getContext());
+    view1.setId(1);
+    View view2 = new MyView(InstrumentationRegistry.getContext());
+    view2.setId(2);
+    View view3 = new MyView(InstrumentationRegistry.getContext());
+    view3.setId(3);
+    ViewGroup tree = new FrameLayout(InstrumentationRegistry.getContext());
+    tree.addView(view1);
+    tree.addView(view2);
+    tree.addView(view3);
+
+    ArgumentCast target = new ArgumentCast();
+    ButterKnife.bind(target, tree);
+
+    view1.performClick();
+    assertSame(view1, target.last);
+
+    view2.performClick();
+    assertSame(view2, target.last);
+
+    view3.performClick();
+    assertSame(view3, target.last);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnClickTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnClickTest.java
new file mode 100644
index 00000000..9893f1a4
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnClickTest.java
@@ -0,0 +1,254 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import com.example.butterknife.BuildConfig;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assume.assumeFalse;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnClickTest {
+  static final class Simple {
+    int clicks = 0;
+
+    @OnClick(1) void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void simple() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    Simple target = new Simple();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(1, target.clicks);
+  }
+
+  static final class MultipleBindings {
+    int clicks = 0;
+
+    @OnClick(1) void click1() {
+      clicks++;
+    }
+
+    @OnClick(1) void clicks2() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleBindings() {
+    assumeFalse("Not implemented", BuildConfig.FLAVOR.equals("reflect")); // TODO
+
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    MultipleBindings target = new MultipleBindings();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class Visibilities {
+    int clicks = 0;
+
+    @OnClick(1) public void publicClick() {
+      clicks++;
+    }
+
+    @OnClick(2) void packageClick() {
+      clicks++;
+    }
+
+    @OnClick(3) protected void protectedClick() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void visibilities() {
+    View tree = ViewTree.create(1, 2, 3);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+    View view3 = tree.findViewById(3);
+
+    Visibilities target = new Visibilities();
+    ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    view2.performClick();
+    assertEquals(2, target.clicks);
+
+    view3.performClick();
+    assertEquals(3, target.clicks);
+  }
+
+  static final class MultipleIds {
+    int clicks = 0;
+
+    @OnClick({1, 2}) void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleIds() {
+    View tree = ViewTree.create(1, 2);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+
+    MultipleIds target = new MultipleIds();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    view2.performClick();
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    view2.performClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class OptionalId {
+    int clicks = 0;
+
+    @Optional @OnClick(1) public void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdPresent() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performClick();
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performClick();
+    assertEquals(1, target.clicks);
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdAbsent() {
+    View tree = ViewTree.create(2);
+    View view2 = tree.findViewById(2);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view2.performClick();
+    assertEquals(0, target.clicks);
+
+    unbinder.unbind();
+    view2.performClick();
+    assertEquals(0, target.clicks);
+  }
+
+  static final class ArgumentCast {
+    interface MyInterface {}
+
+    View last;
+
+    @OnClick(1) void clickView(View view) {
+      last = view;
+    }
+
+    @OnClick(2) void clickTextView(TextView view) {
+      last = view;
+    }
+
+    @OnClick(3) void clickButton(Button view) {
+      last = view;
+    }
+
+    @OnClick(4) void clickMyInterface(MyInterface view) {
+      last = (View) view;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void argumentCast() {
+    class MyView extends Button implements ArgumentCast.MyInterface {
+      MyView(Context context) {
+        super(context);
+      }
+
+      @Override public boolean post(Runnable action) {
+        // Because of DebouncingOnClickListener, we run any posted Runnables synchronously.
+        action.run();
+        return true;
+      }
+    }
+
+    View view1 = new MyView(InstrumentationRegistry.getContext());
+    view1.setId(1);
+    View view2 = new MyView(InstrumentationRegistry.getContext());
+    view2.setId(2);
+    View view3 = new MyView(InstrumentationRegistry.getContext());
+    view3.setId(3);
+    View view4 = new MyView(InstrumentationRegistry.getContext());
+    view4.setId(4);
+    ViewGroup tree = new FrameLayout(InstrumentationRegistry.getContext());
+    tree.addView(view1);
+    tree.addView(view2);
+    tree.addView(view3);
+    tree.addView(view4);
+
+    ArgumentCast target = new ArgumentCast();
+    ButterKnife.bind(target, tree);
+
+    view1.performClick();
+    assertSame(view1, target.last);
+
+    view2.performClick();
+    assertSame(view2, target.last);
+
+    view3.performClick();
+    assertSame(view3, target.last);
+
+    view4.performClick();
+    assertSame(view4, target.last);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemClickTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemClickTest.java
new file mode 100644
index 00000000..6c08cfbd
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemClickTest.java
@@ -0,0 +1,265 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsSpinner;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnItemClick;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import com.example.butterknife.BuildConfig;
+import com.example.butterknife.library.SimpleAdapter;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assume.assumeFalse;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnItemClickTest {
+    static class TestSpinner extends AbsSpinner {
+        public TestSpinner(Context context) {
+            super(context);
+            setAdapter(new SimpleAdapter(context));
+        }
+
+        void performItemClick(int position) {
+            if (position < 0) {
+                return;
+            }
+
+            AdapterView.OnItemClickListener listener = getOnItemClickListener();
+            if (listener != null) {
+                listener.onItemClick(this, null, position, NO_ID);
+            }
+        }
+    }
+
+    static final class Simple {
+        int clickedPosition = -1;
+
+        @OnItemClick(1) void itemClick(int position) {
+            clickedPosition = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void simple() {
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        Simple target = new Simple();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner.performItemClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemClick(1);
+        assertEquals(0, target.clickedPosition);
+    }
+
+
+    static final class MultipleBindings {
+        int clickedPosition1 = -1;
+        int clickedPosition2 = -1;
+
+        @OnItemClick(1) void itemClick1(int position) {
+            clickedPosition1 = position;
+        }
+
+        @OnItemClick(1) void itemClick2(int position) {
+            clickedPosition2 = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void multipleBindings() {
+        assumeFalse("Not implemented", BuildConfig.FLAVOR.equals("reflect")); // TODO
+
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        MultipleBindings target = new MultipleBindings();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition1);
+        assertEquals(-1, target.clickedPosition2);
+
+        spinner.performItemClick(0);
+        assertEquals(0, target.clickedPosition1);
+        assertEquals(0, target.clickedPosition2);
+
+        unbinder.unbind();
+        spinner.performItemClick(1);
+        assertEquals(0, target.clickedPosition1);
+        assertEquals(0, target.clickedPosition2);
+    }
+
+
+    static final class Visibilities {
+        int clickedPosition = -1;
+
+        @OnItemClick(1) public void publicItemClick(int position) {
+            clickedPosition = position;
+        }
+
+        @OnItemClick(2) void packageItemClick(int position) {
+            clickedPosition = position;
+        }
+
+        @OnItemClick(3) protected void protectedItemClick(int position) {
+            clickedPosition = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void visibilities() {
+        View tree = ViewTree.create(TestSpinner.class, 1, 2, 3);
+        TestSpinner spinner1 = tree.findViewById(1);
+        TestSpinner spinner2 = tree.findViewById(2);
+        TestSpinner spinner3 = tree.findViewById(3);
+
+        Visibilities target = new Visibilities();
+        ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner1.performItemClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        spinner2.performItemClick(1);
+        assertEquals(1, target.clickedPosition);
+
+        spinner3.performItemClick(2);
+        assertEquals(2, target.clickedPosition);
+    }
+
+    static final class MultipleIds {
+        int clickedPosition = -1;
+
+        @OnItemClick({1, 2}) void itemClick(int position) {
+            clickedPosition = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void multipleIds() {
+        View tree = ViewTree.create(TestSpinner.class, 1, 2);
+        TestSpinner spinner1 = tree.findViewById(1);
+        TestSpinner spinner2 = tree.findViewById(2);
+
+        MultipleIds target = new MultipleIds();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner1.performItemClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        spinner2.performItemClick(1);
+        assertEquals(1, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner1.performItemClick(2);
+        assertEquals(1, target.clickedPosition);
+        spinner2.performItemClick(2);
+        assertEquals(1, target.clickedPosition);
+    }
+
+    static final class OptionalId {
+        int clickedPosition = -1;
+
+        @Optional @OnItemClick(1) void itemClick(int position) {
+            clickedPosition = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void optionalIdPresent() {
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        OptionalId target = new OptionalId();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner.performItemClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemClick(1);
+        assertEquals(0, target.clickedPosition);
+    }
+
+    @UiThreadTest
+    @Test public void optionalIdAbsent() {
+        View tree = ViewTree.create(TestSpinner.class, 2);
+        TestSpinner spinner = tree.findViewById(2);
+
+        OptionalId target = new OptionalId();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner.performItemClick(0);
+        assertEquals(-1, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemClick(0);
+        assertEquals(-1, target.clickedPosition);
+    }
+
+    static final class ArgumentCast {
+        interface MyInterface {}
+
+        View last;
+
+        @OnItemClick(1) void itemClickAdapterView(AdapterView<?> view) {
+            last = view;
+        }
+
+        @OnItemClick(2) void itemClickAbsSpinner(AbsSpinner view) {
+            last = view;
+        }
+
+        @OnItemClick(3) void itemClickMyInterface(ArgumentCast.MyInterface view) {
+            last = (View) view;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void argumentCast() {
+        class MySpinner extends TestSpinner implements ArgumentCast.MyInterface {
+            MySpinner(Context context) {
+                super(context);
+            }
+        }
+
+        Context context = InstrumentationRegistry.getContext();
+        TestSpinner spinner1 = new MySpinner(context);
+        spinner1.setId(1);
+        TestSpinner spinner2 = new MySpinner(context);
+        spinner2.setId(2);
+        TestSpinner spinner3 = new MySpinner(context);
+        spinner3.setId(3);
+        ViewGroup tree = new FrameLayout(context);
+        tree.addView(spinner1);
+        tree.addView(spinner2);
+        tree.addView(spinner3);
+
+        ArgumentCast target = new ArgumentCast();
+        ButterKnife.bind(target, tree);
+
+        spinner1.performItemClick(0);
+        assertSame(spinner1, target.last);
+
+        spinner2.performItemClick(0);
+        assertSame(spinner2, target.last);
+
+        spinner3.performItemClick(0);
+        assertSame(spinner3, target.last);
+    }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemLongClickTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemLongClickTest.java
new file mode 100644
index 00000000..60a2f505
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemLongClickTest.java
@@ -0,0 +1,267 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsSpinner;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnItemLongClick;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import com.example.butterknife.library.SimpleAdapter;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnItemLongClickTest {
+    static class TestSpinner extends AbsSpinner {
+        public TestSpinner(Context context) {
+            super(context);
+            setAdapter(new SimpleAdapter(context));
+        }
+
+        boolean performItemLongClick(int position) {
+            if (position >= 0) {
+                AdapterView.OnItemLongClickListener listener = getOnItemLongClickListener();
+                if (listener != null) {
+                    return listener.onItemLongClick(this, null, position, NO_ID);
+                }
+            }
+
+            return false;
+        }
+    }
+
+    static final class Simple {
+        boolean returnValue = true;
+        int clickedPosition = -1;
+
+        @OnItemLongClick(1) boolean itemClick(int position) {
+            clickedPosition = position;
+            return returnValue;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void simple() {
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        Simple target = new Simple();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        assertTrue(spinner.performItemLongClick(0));
+        assertEquals(0, target.clickedPosition);
+
+        target.returnValue = false;
+        assertFalse(spinner.performItemLongClick(1));
+        assertEquals(1, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemLongClick(2);
+        assertEquals(1, target.clickedPosition);
+    }
+
+    static final class ReturnVoid {
+        int clickedPosition = -1;
+
+        @OnItemLongClick(1) void itemLongClick(int position) {
+            clickedPosition = position;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void returnVoid() {
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        ReturnVoid target = new ReturnVoid();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        assertTrue(spinner.performItemLongClick(0));
+        assertEquals(0, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemLongClick(1);
+        assertEquals(0, target.clickedPosition);
+    }
+
+    static final class Visibilities {
+        int clickedPosition = -1;
+
+        @OnItemLongClick(1) public boolean publicItemLongClick(int position) {
+            clickedPosition = position;
+            return true;
+        }
+
+        @OnItemLongClick(2) boolean packageItemLongClick(int position) {
+            clickedPosition = position;
+            return true;
+        }
+
+        @OnItemLongClick(3) protected boolean protectedItemLongClick(int position) {
+            clickedPosition = position;
+            return true;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void visibilities() {
+        View tree = ViewTree.create(TestSpinner.class, 1, 2, 3);
+        TestSpinner spinner1 = tree.findViewById(1);
+        TestSpinner spinner2 = tree.findViewById(2);
+        TestSpinner spinner3 = tree.findViewById(3);
+
+        Visibilities target = new Visibilities();
+        ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner1.performItemLongClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        spinner2.performItemLongClick(1);
+        assertEquals(1, target.clickedPosition);
+
+        spinner3.performItemLongClick(2);
+        assertEquals(2, target.clickedPosition);
+    }
+
+    static final class MultipleIds {
+        int clickedPosition = -1;
+
+        @OnItemLongClick({1, 2}) boolean itemLongClick(int position) {
+            clickedPosition = position;
+            return true;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void multipleIds() {
+        View tree = ViewTree.create(TestSpinner.class, 1, 2);
+        TestSpinner spinner1 = tree.findViewById(1);
+        TestSpinner spinner2 = tree.findViewById(2);
+
+        MultipleIds target = new MultipleIds();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner1.performItemLongClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        spinner2.performItemLongClick(1);
+        assertEquals(1, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner1.performItemLongClick(2);
+        assertEquals(1, target.clickedPosition);
+        spinner2.performItemLongClick(2);
+        assertEquals(1, target.clickedPosition);
+    }
+
+    static final class OptionalId {
+        int clickedPosition = -1;
+
+        @Optional @OnItemLongClick(1) boolean itemLongClick(int position) {
+            clickedPosition = position;
+            return true;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void optionalIdPresent() {
+        View tree = ViewTree.create(TestSpinner.class, 1);
+        TestSpinner spinner = tree.findViewById(1);
+
+        OptionalId target = new OptionalId();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner.performItemLongClick(0);
+        assertEquals(0, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemLongClick(1);
+        assertEquals(0, target.clickedPosition);
+    }
+
+    @UiThreadTest
+    @Test public void optionalIdAbsent() {
+        View tree = ViewTree.create(TestSpinner.class, 2);
+        TestSpinner spinner = tree.findViewById(2);
+
+        OptionalId target = new OptionalId();
+        Unbinder unbinder = ButterKnife.bind(target, tree);
+        assertEquals(-1, target.clickedPosition);
+
+        spinner.performItemLongClick(0);
+        assertEquals(-1, target.clickedPosition);
+
+        unbinder.unbind();
+        spinner.performItemLongClick(0);
+        assertEquals(-1, target.clickedPosition);
+    }
+
+    static final class ArgumentCast {
+        interface MyInterface {}
+
+        View last;
+
+        @OnItemLongClick(1) boolean itemLongClickAdapterView(AdapterView<?> view) {
+            last = view;
+            return true;
+        }
+
+        @OnItemLongClick(2) boolean itemLongClickAbsSpinner(AbsSpinner view) {
+            last = view;
+            return true;
+        }
+
+        @OnItemLongClick(3) boolean itemLongClickMyInterface(ArgumentCast.MyInterface view) {
+            last = (View) view;
+            return true;
+        }
+    }
+
+    @UiThreadTest
+    @Test public void argumentCast() {
+        class MySpinner extends TestSpinner implements ArgumentCast.MyInterface {
+            MySpinner(Context context) {
+                super(context);
+            }
+        }
+
+        Context context = InstrumentationRegistry.getContext();
+        TestSpinner spinner1 = new MySpinner(context);
+        spinner1.setId(1);
+        TestSpinner spinner2 = new MySpinner(context);
+        spinner2.setId(2);
+        TestSpinner spinner3 = new MySpinner(context);
+        spinner3.setId(3);
+        ViewGroup tree = new FrameLayout(context);
+        tree.addView(spinner1);
+        tree.addView(spinner2);
+        tree.addView(spinner3);
+
+        ArgumentCast target = new ArgumentCast();
+        ButterKnife.bind(target, tree);
+
+        spinner1.performItemLongClick(0);
+        assertSame(spinner1, target.last);
+
+        spinner2.performItemLongClick(0);
+        assertSame(spinner2, target.last);
+
+        spinner3.performItemLongClick(0);
+        assertSame(spinner3, target.last);
+    }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemSelectedTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemSelectedTest.java
new file mode 100644
index 00000000..8a37518d
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnItemSelectedTest.java
@@ -0,0 +1,387 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsSpinner;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnItemSelected;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import com.example.butterknife.BuildConfig;
+import com.example.butterknife.library.SimpleAdapter;
+import org.junit.Before;
+import org.junit.Test;
+
+import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assume.assumeFalse;
+
+@SuppressWarnings("unused") // Used by code gen.
+public final class OnItemSelectedTest {
+  static class TestSpinner extends AbsSpinner {
+    public TestSpinner(Context context) {
+      super(context);
+      setAdapter(new SimpleAdapter(context));
+    }
+
+    void performSelection(int position) {
+      if (position < 0) {
+        return;
+      }
+
+      AdapterView.OnItemSelectedListener listener = getOnItemSelectedListener();
+      if (listener != null) {
+        listener.onItemSelected(this, null, position, NO_ID);
+      }
+    }
+
+    void clearSelection() {
+      AdapterView.OnItemSelectedListener listener = getOnItemSelectedListener();
+      if (listener != null) {
+        listener.onNothingSelected(this);
+      }
+    }
+  }
+
+  @Before public void ignoreIfReflect() {
+    assumeFalse("Not implemented", BuildConfig.FLAVOR.equals("reflect")); // TODO
+  }
+
+  static final class Simple {
+    int selectedPosition = -1;
+
+    @OnItemSelected(1) void select(int position) {
+      selectedPosition = position;
+    }
+
+    @OnItemSelected(value = 1, callback = NOTHING_SELECTED) void clear() {
+      selectedPosition = -1;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void simple() {
+    View tree = ViewTree.create(TestSpinner.class, 1);
+    TestSpinner spinner = tree.findViewById(1);
+
+    Simple target = new Simple();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(-1, target.selectedPosition);
+
+    spinner.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner.performSelection(1);
+    unbinder.unbind();
+    spinner.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+    spinner.clearSelection();
+    assertEquals(1, target.selectedPosition);
+  }
+
+  static final class MultipleBindings {
+    int selectedPosition1 = -1;
+    int selectedPosition2 = -1;
+
+    @OnItemSelected(1) void select1(int position) {
+      selectedPosition1 = position;
+    }
+
+    @OnItemSelected(1) void select2(int position) {
+      selectedPosition2 = position;
+    }
+
+    @OnItemSelected(value = 1, callback = NOTHING_SELECTED) void clear1() {
+      selectedPosition1 = -1;
+    }
+
+    @OnItemSelected(value = 1, callback = NOTHING_SELECTED) void clear2() {
+      selectedPosition2 = -1;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleBindings() {
+    View tree = ViewTree.create(TestSpinner.class, 1);
+    TestSpinner spinner = tree.findViewById(1);
+
+    MultipleBindings target = new MultipleBindings();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(-1, target.selectedPosition1);
+    assertEquals(-1, target.selectedPosition2);
+
+    spinner.performSelection(0);
+    assertEquals(0, target.selectedPosition1);
+    assertEquals(0, target.selectedPosition2);
+
+    spinner.clearSelection();
+    assertEquals(-1, target.selectedPosition1);
+    assertEquals(-1, target.selectedPosition2);
+
+    spinner.performSelection(1);
+    unbinder.unbind();
+    spinner.performSelection(0);
+    assertEquals(1, target.selectedPosition1);
+    assertEquals(1, target.selectedPosition2);
+    spinner.clearSelection();
+    assertEquals(1, target.selectedPosition1);
+    assertEquals(1, target.selectedPosition2);
+  }
+
+  static final class Visibilities {
+    int selectedPosition = -1;
+
+    @OnItemSelected(1) public void publicSelect(int position) {
+      selectedPosition = position;
+    }
+
+    @OnItemSelected(2) void packageSelect(int position) {
+      selectedPosition = position;
+    }
+
+    @OnItemSelected(3) protected void protectedSelect(int position) {
+      selectedPosition = position;
+    }
+
+    @OnItemSelected(value = 1, callback = NOTHING_SELECTED) public void publicClear() {
+      selectedPosition = -1;
+    }
+
+    @OnItemSelected(value = 2, callback = NOTHING_SELECTED) void packageClear() {
+      selectedPosition = -1;
+    }
+
+    @OnItemSelected(value = 3, callback = NOTHING_SELECTED) protected void protectedClear() {
+      selectedPosition = -1;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void visibilities() {
+    View tree = ViewTree.create(TestSpinner.class, 1, 2, 3);
+    TestSpinner spinner1 = tree.findViewById(1);
+    TestSpinner spinner2 = tree.findViewById(2);
+    TestSpinner spinner3 = tree.findViewById(3);
+
+    Visibilities target = new Visibilities();
+    ButterKnife.bind(target, tree);
+    assertEquals(-1, target.selectedPosition);
+
+    spinner1.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner1.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner2.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner2.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner3.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner3.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+  }
+
+  static final class MultipleIdPermutation {
+    int selectedPosition = -1;
+
+    @OnItemSelected({1, 2}) void select(int position) {
+      selectedPosition = position;
+    }
+
+    @OnItemSelected(value = {1, 3}, callback = NOTHING_SELECTED) void clear() {
+      selectedPosition = -1;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleIdPermutation() {
+    View tree = ViewTree.create(TestSpinner.class, 1, 2, 3);
+    TestSpinner spinner1 = tree.findViewById(1);
+    TestSpinner spinner2 = tree.findViewById(2);
+    TestSpinner spinner3 = tree.findViewById(3);
+
+    MultipleIdPermutation target = new MultipleIdPermutation();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(-1, target.selectedPosition);
+
+    spinner1.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner1.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner2.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner2.clearSelection();
+    assertEquals(0, target.selectedPosition);
+
+    spinner3.performSelection(1);
+    assertEquals(0, target.selectedPosition);
+
+    spinner3.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner1.performSelection(1);
+    unbinder.unbind();
+    spinner1.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+    spinner2.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+    spinner3.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+    spinner1.clearSelection();
+    assertEquals(1, target.selectedPosition);
+    spinner2.clearSelection();
+    assertEquals(1, target.selectedPosition);
+    spinner3.clearSelection();
+    assertEquals(1, target.selectedPosition);
+  }
+
+  static final class OptionalId {
+    int selectedPosition = -1;
+
+    @Optional @OnItemSelected(1) void select(int position) {
+      selectedPosition = position;
+    }
+
+    @Optional @OnItemSelected(value = 1, callback = NOTHING_SELECTED) void clear() {
+      selectedPosition = -1;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdPresent() {
+    View tree = ViewTree.create(TestSpinner.class, 1);
+    TestSpinner spinner = tree.findViewById(1);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(-1, target.selectedPosition);
+
+    spinner.performSelection(0);
+    assertEquals(0, target.selectedPosition);
+
+    spinner.clearSelection();
+    assertEquals(-1, target.selectedPosition);
+
+    spinner.performSelection(1);
+    unbinder.unbind();
+    spinner.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+    spinner.clearSelection();
+    assertEquals(1, target.selectedPosition);
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdAbsent() {
+    View tree = ViewTree.create(TestSpinner.class, 2);
+    TestSpinner spinner = tree.findViewById(2);
+
+    OptionalId target = new OptionalId();
+    target.selectedPosition = 1;
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(1, target.selectedPosition);
+
+    spinner.performSelection(0);
+    assertEquals(1, target.selectedPosition);
+
+    spinner.clearSelection();
+    assertEquals(1, target.selectedPosition);
+
+    unbinder.unbind();
+    spinner.performSelection(1);
+    assertEquals(1, target.selectedPosition);
+    spinner.clearSelection();
+    assertEquals(1, target.selectedPosition);
+  }
+
+  static final class ArgumentCast {
+    interface MyInterface {}
+
+    View last;
+
+    @OnItemSelected(1) void selectAdapterView(AdapterView<?> view) {
+      last = view;
+    }
+
+    @OnItemSelected(2) void selectAbsSpinner(AbsSpinner view) {
+      last = view;
+    }
+
+    @OnItemSelected(3) void selectMyInterface(MyInterface view) {
+      last = (View) view;
+    }
+
+    @OnItemSelected(value = 1, callback = NOTHING_SELECTED)
+    void clearAdapterView(AdapterView<?> view) {
+      last = view;
+    }
+
+    @OnItemSelected(value = 2, callback = NOTHING_SELECTED)
+    void clearAbsSpinner(AbsSpinner view) {
+      last = view;
+    }
+
+    @OnItemSelected(value = 3, callback = NOTHING_SELECTED)
+    void clearMyInterface(MyInterface view) {
+      last = (View) view;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void argumentCast() {
+    class MySpinner extends TestSpinner implements ArgumentCast.MyInterface {
+      MySpinner(Context context) {
+        super(context);
+      }
+    }
+
+    Context context = InstrumentationRegistry.getContext();
+    TestSpinner spinner1 = new MySpinner(context);
+    spinner1.setId(1);
+    TestSpinner spinner2 = new MySpinner(context);
+    spinner2.setId(2);
+    TestSpinner spinner3 = new MySpinner(context);
+    spinner3.setId(3);
+    ViewGroup tree = new FrameLayout(context);
+    tree.addView(spinner1);
+    tree.addView(spinner2);
+    tree.addView(spinner3);
+
+    ArgumentCast target = new ArgumentCast();
+    ButterKnife.bind(target, tree);
+
+    spinner1.performSelection(0);
+    assertSame(spinner1, target.last);
+
+    spinner2.performSelection(0);
+    assertSame(spinner2, target.last);
+
+    spinner3.performSelection(0);
+    assertSame(spinner3, target.last);
+
+    spinner1.clearSelection();
+    assertSame(spinner1, target.last);
+
+    spinner2.clearSelection();
+    assertSame(spinner2, target.last);
+
+    spinner3.clearSelection();
+    assertSame(spinner3, target.last);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnLongClickTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnLongClickTest.java
new file mode 100644
index 00000000..019f5b9e
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnLongClickTest.java
@@ -0,0 +1,257 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnLongClick;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnLongClickTest {
+  static final class Simple {
+    boolean returnValue = true;
+    int clicks = 0;
+
+    @OnLongClick(1) boolean click() {
+      clicks++;
+      return returnValue;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void simple() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    Simple target = new Simple();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    assertTrue(view1.performLongClick());
+    assertEquals(1, target.clicks);
+
+    target.returnValue = false;
+    assertFalse(view1.performLongClick());
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performLongClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class ReturnVoid {
+    int clicks = 0;
+
+    @OnLongClick(1) void click() {
+      clicks++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void returnVoid() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    ReturnVoid target = new ReturnVoid();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    assertTrue(view1.performLongClick());
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performLongClick();
+    assertEquals(1, target.clicks);
+  }
+
+  static final class Visibilities {
+    int clicks = 0;
+
+    @OnLongClick(1) public boolean publicClick() {
+      clicks++;
+      return true;
+    }
+
+    @OnLongClick(2) boolean packageClick() {
+      clicks++;
+      return true;
+    }
+
+    @OnLongClick(3) protected boolean protectedClick() {
+      clicks++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void visibilities() {
+    View tree = ViewTree.create(1, 2, 3);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+    View view3 = tree.findViewById(3);
+
+    Visibilities target = new Visibilities();
+    ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performLongClick();
+    assertEquals(1, target.clicks);
+
+    view2.performLongClick();
+    assertEquals(2, target.clicks);
+
+    view3.performLongClick();
+    assertEquals(3, target.clicks);
+  }
+
+  static final class MultipleIds {
+    int clicks = 0;
+
+    @OnLongClick({1, 2}) boolean click() {
+      clicks++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleIds() {
+    View tree = ViewTree.create(1, 2);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+
+    MultipleIds target = new MultipleIds();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performLongClick();
+    assertEquals(1, target.clicks);
+
+    view2.performLongClick();
+    assertEquals(2, target.clicks);
+
+    unbinder.unbind();
+    view1.performLongClick();
+    view2.performLongClick();
+    assertEquals(2, target.clicks);
+  }
+
+  static final class OptionalId {
+    int clicks = 0;
+
+    @Optional @OnLongClick(1) public boolean click() {
+      clicks++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdPresent() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view1.performLongClick();
+    assertEquals(1, target.clicks);
+
+    unbinder.unbind();
+    view1.performLongClick();
+    assertEquals(1, target.clicks);
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdAbsent() {
+    View tree = ViewTree.create(2);
+    View view2 = tree.findViewById(2);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.clicks);
+
+    view2.performLongClick();
+    assertEquals(0, target.clicks);
+
+    unbinder.unbind();
+    view2.performLongClick();
+    assertEquals(0, target.clicks);
+  }
+
+  static final class ArgumentCast {
+    interface MyInterface {}
+
+    View last;
+
+    @OnLongClick(1) boolean clickView(View view) {
+      last = view;
+      return true;
+    }
+
+    @OnLongClick(2) boolean clickTextView(TextView view) {
+      last = view;
+      return true;
+    }
+
+    @OnLongClick(3) boolean clickButton(Button view) {
+      last = view;
+      return true;
+    }
+
+    @OnLongClick(4) boolean clickMyInterface(MyInterface view) {
+      last = (View) view;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void argumentCast() {
+    class MyView extends Button implements ArgumentCast.MyInterface {
+      MyView(Context context) {
+        super(context);
+      }
+    }
+
+    View view1 = new MyView(InstrumentationRegistry.getContext());
+    view1.setId(1);
+    View view2 = new MyView(InstrumentationRegistry.getContext());
+    view2.setId(2);
+    View view3 = new MyView(InstrumentationRegistry.getContext());
+    view3.setId(3);
+    View view4 = new MyView(InstrumentationRegistry.getContext());
+    view4.setId(4);
+    ViewGroup tree = new FrameLayout(InstrumentationRegistry.getContext());
+    tree.addView(view1);
+    tree.addView(view2);
+    tree.addView(view3);
+    tree.addView(view4);
+
+    ArgumentCast target = new ArgumentCast();
+    ButterKnife.bind(target, tree);
+
+    view1.performLongClick();
+    assertSame(view1, target.last);
+
+    view2.performLongClick();
+    assertSame(view2, target.last);
+
+    view3.performLongClick();
+    assertSame(view3, target.last);
+
+    view4.performLongClick();
+    assertSame(view4, target.last);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnTouchTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnTouchTest.java
new file mode 100644
index 00000000..497f7096
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/OnTouchTest.java
@@ -0,0 +1,264 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.annotation.UiThreadTest;
+import butterknife.ButterKnife;
+import butterknife.OnTouch;
+import butterknife.Optional;
+import butterknife.Unbinder;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+@SuppressWarnings("unused") // Used reflectively / by code gen.
+public final class OnTouchTest {
+  static final class Simple {
+    boolean returnValue = true;
+    int touches = 0;
+
+    @OnTouch(1) boolean touch() {
+      touches++;
+      return returnValue;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void simple() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    Simple target = new Simple();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    assertTrue(performTouch(view1));
+    assertEquals(1, target.touches);
+
+    target.returnValue = false;
+    assertFalse(performTouch(view1));
+    assertEquals(2, target.touches);
+
+    unbinder.unbind();
+    performTouch(view1);
+    assertEquals(2, target.touches);
+  }
+
+  static final class ReturnVoid {
+    int touches = 0;
+
+    @OnTouch(1) void touch() {
+      touches++;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void returnVoid() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    ReturnVoid target = new ReturnVoid();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    assertTrue(performTouch(view1));
+    assertEquals(1, target.touches);
+
+    unbinder.unbind();
+    performTouch(view1);
+    assertEquals(1, target.touches);
+  }
+
+  static final class Visibilities {
+    int touches = 0;
+
+    @OnTouch(1) public boolean publicTouch() {
+      touches++;
+      return true;
+    }
+
+    @OnTouch(2) boolean packageTouch() {
+      touches++;
+      return true;
+    }
+
+    @OnTouch(3) protected boolean protectedTouch() {
+      touches++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void visibilities() {
+    View tree = ViewTree.create(1, 2, 3);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+    View view3 = tree.findViewById(3);
+
+    Visibilities target = new Visibilities();
+    ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    performTouch(view1);
+    assertEquals(1, target.touches);
+
+    performTouch(view2);
+    assertEquals(2, target.touches);
+
+    performTouch(view3);
+    assertEquals(3, target.touches);
+  }
+
+  static final class MultipleIds {
+    int touches = 0;
+
+    @OnTouch({1, 2}) boolean touch() {
+      touches++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void multipleIds() {
+    View tree = ViewTree.create(1, 2);
+    View view1 = tree.findViewById(1);
+    View view2 = tree.findViewById(2);
+
+    MultipleIds target = new MultipleIds();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    performTouch(view1);
+    assertEquals(1, target.touches);
+
+    performTouch(view2);
+    assertEquals(2, target.touches);
+
+    unbinder.unbind();
+    performTouch(view1);
+    performTouch(view2);
+    assertEquals(2, target.touches);
+  }
+
+  static final class OptionalId {
+    int touches = 0;
+
+    @Optional @OnTouch(1) public boolean touch() {
+      touches++;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdPresent() {
+    View tree = ViewTree.create(1);
+    View view1 = tree.findViewById(1);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    performTouch(view1);
+    assertEquals(1, target.touches);
+
+    unbinder.unbind();
+    performTouch(view1);
+    assertEquals(1, target.touches);
+  }
+
+  @UiThreadTest
+  @Test public void optionalIdAbsent() {
+    View tree = ViewTree.create(2);
+    View view2 = tree.findViewById(2);
+
+    OptionalId target = new OptionalId();
+    Unbinder unbinder = ButterKnife.bind(target, tree);
+    assertEquals(0, target.touches);
+
+    performTouch(view2);
+    assertEquals(0, target.touches);
+
+    unbinder.unbind();
+    performTouch(view2);
+    assertEquals(0, target.touches);
+  }
+
+  static final class ArgumentCast {
+    interface MyInterface {}
+
+    View last;
+
+    @OnTouch(1) boolean touchView(View view) {
+      last = view;
+      return true;
+    }
+
+    @OnTouch(2) boolean touchTextView(TextView view) {
+      last = view;
+      return true;
+    }
+
+    @OnTouch(3) boolean touchButton(Button view) {
+      last = view;
+      return true;
+    }
+
+    @OnTouch(4) boolean touchMyInterface(ArgumentCast.MyInterface view) {
+      last = (View) view;
+      return true;
+    }
+  }
+
+  @UiThreadTest
+  @Test public void argumentCast() {
+    class MyView extends Button implements ArgumentCast.MyInterface {
+      MyView(Context context) {
+        super(context);
+      }
+    }
+
+    Context context = InstrumentationRegistry.getContext();
+    View view1 = new MyView(context);
+    view1.setId(1);
+    View view2 = new MyView(context);
+    view2.setId(2);
+    View view3 = new MyView(context);
+    view3.setId(3);
+    View view4 = new MyView(context);
+    view4.setId(4);
+    ViewGroup tree = new FrameLayout(context);
+    tree.addView(view1);
+    tree.addView(view2);
+    tree.addView(view3);
+    tree.addView(view4);
+
+    ArgumentCast target = new ArgumentCast();
+    ButterKnife.bind(target, tree);
+
+    performTouch(view1);
+    assertSame(view1, target.last);
+
+    performTouch(view2);
+    assertSame(view2, target.last);
+
+    performTouch(view3);
+    assertSame(view3, target.last);
+
+    performTouch(view4);
+    assertSame(view4, target.last);
+  }
+
+  private static boolean performTouch(View view) {
+    MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_DOWN, 0, 0, 0);
+    return view.dispatchTouchEvent(event);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/ViewTree.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/ViewTree.java
new file mode 100644
index 00000000..cae85884
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/functional/ViewTree.java
@@ -0,0 +1,52 @@
+package com.example.butterknife.functional;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import androidx.test.InstrumentationRegistry;
+import java.lang.reflect.InvocationTargetException;
+
+final class ViewTree {
+  static View create(int... ids) {
+    return create(View.class, ids);
+  }
+
+  static View create(Class<? extends View> cls, int... ids) {
+    Context context = InstrumentationRegistry.getContext();
+    ViewGroup group = new FrameLayout(context);
+    for (int id : ids) {
+      View view;
+      if (cls == View.class) {
+        view = new NoPostView(context);
+      } else {
+        try {
+          view = cls.getConstructor(Context.class).newInstance(context);
+        } catch (IllegalAccessException | InstantiationException | NoSuchMethodException e) {
+          throw new RuntimeException(e);
+        } catch (InvocationTargetException e) {
+          Throwable cause = e.getCause();
+          if (cause instanceof RuntimeException) throw (RuntimeException) cause;
+          if (cause instanceof Error) throw (Error) cause;
+          throw new RuntimeException(cause);
+        }
+      }
+
+      view.setId(id);
+      group.addView(view);
+    }
+    return group;
+  }
+
+  private static final class NoPostView extends View {
+    NoPostView(Context context) {
+      super(context);
+    }
+
+    @Override public boolean post(Runnable action) {
+      // Because of DebouncingOnClickListener, we run any posted Runnables synchronously.
+      action.run();
+      return true;
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleActivityTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleActivityTest.java
new file mode 100644
index 00000000..d7da3011
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleActivityTest.java
@@ -0,0 +1,40 @@
+package com.example.butterknife.library;
+
+import androidx.test.rule.ActivityTestRule;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import com.example.butterknife.R;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class SimpleActivityTest {
+  @Rule public final ActivityTestRule<SimpleActivity> activityRule =
+      new ActivityTestRule<>(SimpleActivity.class);
+
+  @Test public void verifyContentViewBinding() {
+    SimpleActivity activity = activityRule.getActivity();
+
+    Unbinder unbinder = ButterKnife.bind(activity);
+    verifySimpleActivityBound(activity);
+    unbinder.unbind();
+    verifySimpleActivityUnbound(activity);
+  }
+
+  protected static void verifySimpleActivityBound(SimpleActivity activity) {
+    assertThat(activity.title.getId()).isEqualTo(R.id.title);
+    assertThat(activity.subtitle.getId()).isEqualTo(R.id.subtitle);
+    assertThat(activity.hello.getId()).isEqualTo(R.id.hello);
+    assertThat(activity.listOfThings.getId()).isEqualTo(R.id.list_of_things);
+    assertThat(activity.footer.getId()).isEqualTo(R.id.footer);
+  }
+
+  protected static void verifySimpleActivityUnbound(SimpleActivity activity) {
+    assertThat(activity.title).isNull();
+    assertThat(activity.subtitle).isNull();
+    assertThat(activity.hello).isNull();
+    assertThat(activity.listOfThings).isNull();
+    assertThat(activity.footer).isNull();
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleAdapterTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleAdapterTest.java
new file mode 100644
index 00000000..382a22df
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/library/SimpleAdapterTest.java
@@ -0,0 +1,23 @@
+package com.example.butterknife.library;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import com.example.butterknife.R;
+import org.junit.Test;
+
+import static com.example.butterknife.library.SimpleAdapter.ViewHolder;
+import static com.google.common.truth.Truth.assertThat;
+
+public class SimpleAdapterTest {
+  @Test public void verifyViewHolderViews() {
+    Context context = InstrumentationRegistry.getTargetContext();
+
+    View root = View.inflate(context, R.layout.simple_list_item, null);
+    ViewHolder holder = new ViewHolder(root);
+
+    assertThat(holder.word.getId()).isEqualTo(R.id.word);
+    assertThat(holder.length.getId()).isEqualTo(R.id.length);
+    assertThat(holder.position.getId()).isEqualTo(R.id.position);
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/java/com/example/butterknife/unbinder/UnbinderTest.java b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/unbinder/UnbinderTest.java
new file mode 100644
index 00000000..81eb766d
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/java/com/example/butterknife/unbinder/UnbinderTest.java
@@ -0,0 +1,50 @@
+package com.example.butterknife.unbinder;
+
+import android.content.Context;
+import android.view.View;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import androidx.test.InstrumentationRegistry;
+import butterknife.ButterKnife;
+import butterknife.Unbinder;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class UnbinderTest {
+  private final Context context = InstrumentationRegistry.getContext();
+
+  @Test public void verifyContentViewBinding() {
+    FrameLayout frameLayout = new FrameLayout(context);
+    Button button1 = new Button(context);
+    button1.setId(android.R.id.button1);
+    frameLayout.addView(button1);
+    Button button2 = new Button(context);
+    button2.setId(android.R.id.button2);
+    frameLayout.addView(button2);
+    Button button3 = new Button(context);
+    button3.setId(android.R.id.button3);
+    frameLayout.addView(button3);
+    View content = new View(context);
+    content.setId(android.R.id.content);
+    frameLayout.addView(content);
+    H h = new H(frameLayout);
+
+    Unbinder unbinder = ButterKnife.bind(h, frameLayout);
+    verifyHBound(h);
+    unbinder.unbind();
+    verifyHUnbound(h);
+  }
+
+  private void verifyHBound(H h) {
+    assertThat(h.button1).isNotNull();
+    assertThat(h.button2).isNotNull();
+    assertThat(h.button3).isNotNull();
+  }
+
+  private void verifyHUnbound(H h) {
+    assertThat(h.button1).isNull();
+    assertThat(h.button2).isNull();
+    assertThat(h.button3).isNull();
+  }
+}
diff --git a/butterknife-integration-test/src/androidTest/proguard.pro b/butterknife-integration-test/src/androidTest/proguard.pro
new file mode 100644
index 00000000..4807b6d1
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/proguard.pro
@@ -0,0 +1,5 @@
+-dontoptimize
+-dontobfuscate
+-dontshrink
+-dontnote **
+-dontwarn **
diff --git a/butterknife-integration-test/src/androidTest/res/color/colors.xml b/butterknife-integration-test/src/androidTest/res/color/colors.xml
new file mode 100644
index 00000000..2af4b135
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/res/color/colors.xml
@@ -0,0 +1,11 @@
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item
+      android:color="#ffff0000"
+      android:state_pressed="true"
+      />
+  <item
+      android:color="#ff0000ff"
+      android:state_focused="true"
+      />
+  <item android:color="#ff000000"/>
+</selector>
diff --git a/butterknife-integration-test/src/androidTest/res/drawable/circle.xml b/butterknife-integration-test/src/androidTest/res/drawable/circle.xml
new file mode 100644
index 00000000..54496c5b
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/res/drawable/circle.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="oval"
+    >
+  <size
+      android:height="10px"
+      android:width="10px"
+      />
+  <solid
+      android:color="#fff"
+      />
+</shape>
diff --git a/butterknife-integration-test/src/androidTest/res/drawable/pixel.png b/butterknife-integration-test/src/androidTest/res/drawable/pixel.png
new file mode 100644
index 00000000..9644db32
Binary files /dev/null and b/butterknife-integration-test/src/androidTest/res/drawable/pixel.png differ
diff --git a/butterknife-integration-test/src/androidTest/res/font/inconsolata_regular.ttf b/butterknife-integration-test/src/androidTest/res/font/inconsolata_regular.ttf
new file mode 100644
index 00000000..fc981ce7
Binary files /dev/null and b/butterknife-integration-test/src/androidTest/res/font/inconsolata_regular.ttf differ
diff --git a/butterknife-integration-test/src/androidTest/res/values/values.xml b/butterknife-integration-test/src/androidTest/res/values/values.xml
new file mode 100644
index 00000000..f53d702e
--- /dev/null
+++ b/butterknife-integration-test/src/androidTest/res/values/values.xml
@@ -0,0 +1,18 @@
+<resources>
+  <bool name="just_true">true</bool>
+  <color name="red">#ffff0000</color>
+  <integer name="twelve">12</integer>
+  <dimen name="twelve_point_two_dp">12.2dp</dimen>
+  <item name="twelve_point_two" format="float" type="dimen">12.2</item>
+  <string name="hey">Hey</string>
+  <string-array name="string_one_two_three">
+    <item>One</item>
+    <item>Two</item>
+    <item>Three</item>
+  </string-array>
+  <integer-array name="int_one_two_three">
+    <item>1</item>
+    <item>2</item>
+    <item>3</item>
+  </integer-array>
+</resources>
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindAnimFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindAnimFailureTest.java
new file mode 100644
index 00000000..79bd2521
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindAnimFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindAnim;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindAnimFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindAnim(1) String actual;
+  }
+
+  @Test public void typeMustBeAnimation() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindAnim field type must be 'Animation'. "
+              + "(com.example.butterknife.functional.BindAnimFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindArrayFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindArrayFailureTest.java
new file mode 100644
index 00000000..5740af10
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindArrayFailureTest.java
@@ -0,0 +1,31 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindArray;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindArrayFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindArray(1) String actual;
+  }
+
+  @Test public void typeMustBeSupported() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindArray field type must be one of: "
+              + "String[], int[], CharSequence[], android.content.res.TypedArray. "
+              + "(com.example.butterknife.functional.BindArrayFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBitmapFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBitmapFailureTest.java
new file mode 100644
index 00000000..c46c3295
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBitmapFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindBitmap;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindBitmapFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindBitmap(1) String actual;
+  }
+
+  @Test public void typeMustBeBitmap() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindBitmap field type must be 'Bitmap'. "
+              + "(com.example.butterknife.functional.BindBitmapFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBoolFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBoolFailureTest.java
new file mode 100644
index 00000000..d0b23508
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindBoolFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindBool;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindBoolFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindBool(1) String actual;
+  }
+
+  @Test public void typeMustBeBool() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindBool field type must be 'boolean'. "
+              + "(com.example.butterknife.functional.BindBoolFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindColorFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindColorFailureTest.java
new file mode 100644
index 00000000..eb666f49
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindColorFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindColorFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindColor(1) String actual;
+  }
+
+  @Test public void typeMustBeIntOrColorStateList() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindColor field type must be 'int' or 'ColorStateList'. "
+              + "(com.example.butterknife.functional.BindColorFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDimenFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDimenFailureTest.java
new file mode 100644
index 00000000..8bbddfbf
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDimenFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindDimen;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindDimenFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindDimen(1) String actual;
+  }
+
+  @Test public void typeMustBeIntOrFloat() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindDimen field type must be 'int' or 'float'. "
+              + "(com.example.butterknife.functional.BindDimenFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDrawableFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDrawableFailureTest.java
new file mode 100644
index 00000000..74cc0b4e
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindDrawableFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindDrawable;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindDrawableFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindDrawable(1) String actual;
+  }
+
+  @Test public void typeMustBeDrawable() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindDrawable field type must be 'Drawable'. "
+              + "(com.example.butterknife.functional.BindDrawableFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFloatFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFloatFailureTest.java
new file mode 100644
index 00000000..c188d977
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFloatFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindFloat;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindFloatFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindFloat(1) String actual;
+  }
+
+  @Test public void typeMustBeFloat() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindFloat field type must be 'float'. "
+              + "(com.example.butterknife.functional.BindFloatFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFontFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFontFailureTest.java
new file mode 100644
index 00000000..fcbca3fb
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindFontFailureTest.java
@@ -0,0 +1,51 @@
+package com.example.butterknife.functional;
+
+import android.graphics.Typeface;
+import android.view.View;
+import androidx.test.filters.SdkSuppress;
+import butterknife.BindFont;
+import butterknife.ButterKnife;
+import com.example.butterknife.test.R;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindFontFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class TargetType {
+    @BindFont(1) String actual;
+  }
+
+  @Test public void typeMustBeTypeface() {
+    TargetType target = new TargetType();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindFont field type must be 'Typeface'. "
+              + "(com.example.butterknife.functional.BindFontFailureTest$TargetType.actual)");
+    }
+  }
+
+  static class TargetStyle {
+    @BindFont(value = R.font.inconsolata_regular, style = 5) Typeface actual;
+  }
+
+  @SdkSuppress(minSdkVersion = 24) // AndroidX problems on earlier versions
+  @Test public void styleMustBeValid() {
+    TargetStyle target = new TargetStyle();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindFont style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. "
+              + "(com.example.butterknife.functional.BindFontFailureTest$TargetStyle.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindIntFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindIntFailureTest.java
new file mode 100644
index 00000000..cdd970ce
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindIntFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindInt;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindIntFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindInt(1) String actual;
+  }
+
+  @Test public void typeMustBeInt() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindInt field type must be 'int'. "
+              + "(com.example.butterknife.functional.BindIntFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindStringFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindStringFailureTest.java
new file mode 100644
index 00000000..f68d78bf
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindStringFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindString;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindStringFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class Target {
+    @BindString(1) boolean actual;
+  }
+
+  @Test public void typeMustBeString() {
+    Target target = new Target();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindString field type must be 'String'. "
+              + "(com.example.butterknife.functional.BindStringFailureTest$Target.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewFailureTest.java
new file mode 100644
index 00000000..912b68bc
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewFailureTest.java
@@ -0,0 +1,30 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindViewFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class NotView {
+    @BindView(1) String actual;
+  }
+
+  @Test public void failsIfNotView() {
+    NotView target = new NotView();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindView fields must extend from View or be an interface. "
+              + "(com.example.butterknife.functional.BindViewFailureTest$NotView.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewsFailureTest.java b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewsFailureTest.java
new file mode 100644
index 00000000..78983566
--- /dev/null
+++ b/butterknife-integration-test/src/androidTestReflect/java/com/example/butterknife/functional/BindViewsFailureTest.java
@@ -0,0 +1,100 @@
+package com.example.butterknife.functional;
+
+import android.view.View;
+import butterknife.BindViews;
+import butterknife.ButterKnife;
+import java.util.Deque;
+import java.util.List;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class BindViewsFailureTest {
+  private final View tree = ViewTree.create(1);
+
+  static class NoIds {
+    @BindViews({}) View[] actual;
+  }
+
+  @Test public void failsIfNoIds() {
+    NoIds target = new NoIds();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindViews must specify at least one ID. "
+              + "(com.example.butterknife.functional.BindViewsFailureTest$NoIds.actual)");
+    }
+  }
+
+  static class NoGenericType {
+    @BindViews(1) List actual;
+  }
+
+  @Test public void failsIfNoGenericType() {
+    NoGenericType target = new NoGenericType();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindViews List must have a generic component. "
+              + "(com.example.butterknife.functional.BindViewsFailureTest$NoGenericType.actual)");
+    }
+  }
+
+  static class BadCollection {
+    @BindViews(1) Deque<View> actual;
+  }
+
+  @Test public void failsIfUnsupportedCollection() {
+    BadCollection target = new BadCollection();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindViews must be a List or array. "
+              + "(com.example.butterknife.functional.BindViewsFailureTest$BadCollection.actual)");
+    }
+  }
+
+  static class ListNotView {
+    @BindViews(1) List<String> actual;
+  }
+
+  @Test public void failsIfGenericNotView() {
+    ListNotView target = new ListNotView();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindViews List or array type must extend from View or be an interface. "
+              + "(com.example.butterknife.functional.BindViewsFailureTest$ListNotView.actual)");
+    }
+  }
+
+  static class ArrayNotView {
+    @BindViews(1) List<String> actual;
+  }
+
+  @Test public void failsIfArrayNotView() {
+    ArrayNotView target = new ArrayNotView();
+
+    try {
+      ButterKnife.bind(target, tree);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessageThat()
+          .isEqualTo("@BindViews List or array type must extend from View or be an interface. "
+              + "(com.example.butterknife.functional.BindViewsFailureTest$ArrayNotView.actual)");
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/main/AndroidManifest.xml b/butterknife-integration-test/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..f3d3b89a
--- /dev/null
+++ b/butterknife-integration-test/src/main/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.example.butterknife">
+
+  <application
+      android:allowBackup="false"
+      android:fullBackupContent="false"
+      android:label="@string/app_name"
+      android:name=".SimpleApp"
+      tools:ignore="MissingApplicationIcon,UnusedAttribute,GoogleAppIndexingWarning">
+
+    <activity
+        android:label="@string/app_name"
+        android:name=".library.SimpleActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
diff --git a/butterknife-sample/src/main/java/com/example/butterknife/SimpleApp.java b/butterknife-integration-test/src/main/java/com/example/butterknife/SimpleApp.java
similarity index 100%
rename from butterknife-sample/src/main/java/com/example/butterknife/SimpleApp.java
rename to butterknife-integration-test/src/main/java/com/example/butterknife/SimpleApp.java
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java
new file mode 100644
index 00000000..f72eb3e4
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java
@@ -0,0 +1,76 @@
+package com.example.butterknife.library;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.View;
+import android.view.animation.AlphaAnimation;
+import android.widget.Button;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+import butterknife.Action;
+import butterknife.BindString;
+import butterknife.BindView;
+import butterknife.BindViews;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+import butterknife.OnItemClick;
+import butterknife.OnLongClick;
+import butterknife.ViewCollections;
+import com.example.butterknife.R;
+import java.util.List;
+
+import static android.widget.Toast.LENGTH_SHORT;
+
+public class SimpleActivity extends Activity {
+  private static final Action<View> ALPHA_FADE = (view, index) -> {
+    AlphaAnimation alphaAnimation = new AlphaAnimation(0, 1);
+    alphaAnimation.setFillBefore(true);
+    alphaAnimation.setDuration(500);
+    alphaAnimation.setStartOffset(index * 100);
+    view.startAnimation(alphaAnimation);
+  };
+
+  @BindView(R.id.title) TextView title;
+  @BindView(R.id.subtitle) TextView subtitle;
+  @BindView(R.id.hello) Button hello;
+  @BindView(R.id.list_of_things) ListView listOfThings;
+  @BindView(R.id.footer) TextView footer;
+  @BindString(R.string.app_name) String butterKnife;
+  @BindString(R.string.field_method) String fieldMethod;
+  @BindString(R.string.by_jake_wharton) String byJakeWharton;
+  @BindString(R.string.say_hello) String sayHello;
+
+  @BindViews({ R.id.title, R.id.subtitle, R.id.hello }) List<View> headerViews;
+
+  private SimpleAdapter adapter;
+
+  @OnClick(R.id.hello) void sayHello() {
+    Toast.makeText(this, "Hello, views!", LENGTH_SHORT).show();
+    ViewCollections.run(headerViews, ALPHA_FADE);
+  }
+
+  @OnLongClick(R.id.hello) boolean sayGetOffMe() {
+    Toast.makeText(this, "Let go of me!", LENGTH_SHORT).show();
+    return true;
+  }
+
+  @OnItemClick(R.id.list_of_things) void onItemClick(int position) {
+    Toast.makeText(this, "You clicked: " + adapter.getItem(position), LENGTH_SHORT).show();
+  }
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.simple_activity);
+    ButterKnife.bind(this);
+
+    // Contrived code to use the bound fields.
+    title.setText(butterKnife);
+    subtitle.setText(fieldMethod);
+    footer.setText(byJakeWharton);
+    hello.setText(sayHello);
+
+    adapter = new SimpleAdapter(this);
+    listOfThings.setAdapter(adapter);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleAdapter.java b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleAdapter.java
new file mode 100644
index 00000000..5e68d5d1
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleAdapter.java
@@ -0,0 +1,64 @@
+package com.example.butterknife.library;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.TextView;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import com.example.butterknife.R;
+
+import java.util.Locale;
+
+public class SimpleAdapter extends BaseAdapter {
+  private static final String[] CONTENTS = "The quick brown fox jumps over the lazy dog".split(" ");
+
+  private final LayoutInflater inflater;
+
+  public SimpleAdapter(Context context) {
+    inflater = LayoutInflater.from(context);
+  }
+
+  @Override public int getCount() {
+    return CONTENTS.length;
+  }
+
+  @Override public String getItem(int position) {
+    return CONTENTS[position];
+  }
+
+  @Override public long getItemId(int position) {
+    return position;
+  }
+
+  @Override public View getView(int position, View view, ViewGroup parent) {
+    ViewHolder holder;
+    if (view != null) {
+      holder = (ViewHolder) view.getTag();
+    } else {
+      view = inflater.inflate(R.layout.simple_list_item, parent, false);
+      holder = new ViewHolder(view);
+      view.setTag(holder);
+    }
+
+    String word = getItem(position);
+    holder.word.setText(String.format(Locale.getDefault(), "Word: %s", word));
+    holder.length.setText(String.format(Locale.getDefault(), "Length: %d", word.length()));
+    holder.position.setText(String.format(Locale.getDefault(), "Position: %d", position));
+    // Note: don't actually do string concatenation like this in an adapter's getView.
+
+    return view;
+  }
+
+  static final class ViewHolder {
+    @BindView(R.id.word) TextView word;
+    @BindView(R.id.length) TextView length;
+    @BindView(R.id.position) TextView position;
+
+    ViewHolder(View view) {
+      ButterKnife.bind(this, view);
+    }
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java
new file mode 100644
index 00000000..f1344c69
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java
@@ -0,0 +1,15 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class A {
+
+  @BindColor(android.R.color.black) @ColorInt int blackColor;
+
+  public A(View view) {
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/B.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/B.java
new file mode 100644
index 00000000..d6115123
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/B.java
@@ -0,0 +1,16 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class B extends A {
+
+  @BindColor(android.R.color.white) @ColorInt int whiteColor;
+
+  public B(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java
new file mode 100644
index 00000000..f5568184
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java
@@ -0,0 +1,18 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+
+public class C extends B {
+
+  @BindColor(android.R.color.transparent) @ColorInt int transparentColor;
+  @BindView(android.R.id.button1) View button1;
+
+  public C(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/D.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/D.java
new file mode 100644
index 00000000..3e760279
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/D.java
@@ -0,0 +1,16 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class D extends C {
+
+  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;
+
+  public D(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/E.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/E.java
new file mode 100644
index 00000000..4f54510c
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/E.java
@@ -0,0 +1,16 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class E extends C {
+
+  @BindColor(android.R.color.background_dark) @ColorInt int backgroundDarkColor;
+
+  public E(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/F.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/F.java
new file mode 100644
index 00000000..bedf258e
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/F.java
@@ -0,0 +1,16 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public final class F extends D {
+
+  @BindColor(android.R.color.background_light) @ColorInt int backgroundLightColor;
+
+  public F(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/G.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/G.java
new file mode 100644
index 00000000..e643bf65
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/G.java
@@ -0,0 +1,23 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+
+public class G extends E {
+
+  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;
+  @BindView(android.R.id.button2) View button2;
+
+  public G(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+
+  @OnClick(android.R.id.content) public void onClick() {
+
+  }
+}
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/H.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/H.java
new file mode 100644
index 00000000..c4dab646
--- /dev/null
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/H.java
@@ -0,0 +1,18 @@
+package com.example.butterknife.unbinder;
+
+import android.view.View;
+import androidx.annotation.ColorInt;
+import butterknife.BindColor;
+import butterknife.BindView;
+import butterknife.ButterKnife;
+
+public class H extends G {
+
+  @BindColor(android.R.color.holo_green_dark) @ColorInt int holoGreenDark;
+  @BindView(android.R.id.button3) View button3;
+
+  public H(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/butterknife-integration-test/src/main/proguard.pro b/butterknife-integration-test/src/main/proguard.pro
new file mode 100644
index 00000000..87c34705
--- /dev/null
+++ b/butterknife-integration-test/src/main/proguard.pro
@@ -0,0 +1,22 @@
+-dontoptimize
+-dontobfuscate
+-dontnote **
+-dontwarn **
+
+# STUFF USED BY TESTS:
+
+-keep class butterknife.internal.Utils {
+  <methods>;
+}
+
+-keep class butterknife.Unbinder {
+  void unbind();
+}
+
+-keep class com.example.butterknife.unbinder.H {
+  <init>(...);
+}
+
+-keep class androidx.core.** {
+  <methods>;
+}
diff --git a/butterknife-integration-test/src/main/res/layout/simple_activity.xml b/butterknife-integration-test/src/main/res/layout/simple_activity.xml
new file mode 100644
index 00000000..d95547a8
--- /dev/null
+++ b/butterknife-integration-test/src/main/res/layout/simple_activity.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:tools="http://schemas.android.com/tools"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical"
+              android:padding="8dp"
+              tools:ignore="SelectableText">
+    <TextView
+            android:id="@+id/title"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:textSize="50sp"/>
+    <TextView
+            android:id="@+id/subtitle"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:textSize="20sp"/>
+    <Button
+            android:id="@+id/hello"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="1"
+            android:layout_margin="10dp"/>
+    <ListView
+            android:id="@+id/list_of_things"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="1"
+            android:layout_margin="10dp"/>
+    <TextView
+            android:id="@+id/footer"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center"
+            android:textSize="17sp"
+            android:textStyle="italic"/>
+</LinearLayout>
diff --git a/butterknife-integration-test/src/main/res/layout/simple_list_item.xml b/butterknife-integration-test/src/main/res/layout/simple_list_item.xml
new file mode 100644
index 00000000..8d57d86a
--- /dev/null
+++ b/butterknife-integration-test/src/main/res/layout/simple_list_item.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:tools="http://schemas.android.com/tools"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical"
+              tools:ignore="SelectableText">
+    <TextView
+            android:id="@+id/word"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+    <TextView
+            android:id="@+id/length"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+    <TextView
+            android:id="@+id/position"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+</LinearLayout>
diff --git a/butterknife-integration-test/src/main/res/values/strings.xml b/butterknife-integration-test/src/main/res/values/strings.xml
new file mode 100644
index 00000000..11580e25
--- /dev/null
+++ b/butterknife-integration-test/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<resources>
+  <string name="app_name">Butter Knife</string>
+  <string name="field_method">Field and method binding for Android views.</string>
+  <string name="by_jake_wharton">by Jake Wharton</string>
+  <string name="say_hello">Say Hello</string>
+</resources>
diff --git a/butterknife-lint/build.gradle b/butterknife-lint/build.gradle
new file mode 100644
index 00000000..fb63a78f
--- /dev/null
+++ b/butterknife-lint/build.gradle
@@ -0,0 +1,29 @@
+apply plugin: 'java-library'
+apply plugin: 'checkstyle'
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  compileOnly deps.lint.api
+  compileOnly deps.lint.checks
+
+  testImplementation deps.junit
+  testImplementation deps.lint.core
+  testImplementation deps.lint.tests
+  testImplementation(deps.truth) {
+    exclude group: 'com.google.guava', module: 'guava'
+  }
+}
+
+jar {
+  manifest {
+    attributes 'Lint-Registry-v2': 'butterknife.lint.LintRegistry'
+  }
+}
+
+checkstyle {
+  configFile rootProject.file('checkstyle.xml')
+  showViolations true
+  sourceSets = [sourceSets.main]
+}
diff --git a/butterknife-lint/src/main/java/butterknife/lint/InvalidR2UsageDetector.java b/butterknife-lint/src/main/java/butterknife/lint/InvalidR2UsageDetector.java
new file mode 100644
index 00000000..08cdfda5
--- /dev/null
+++ b/butterknife-lint/src/main/java/butterknife/lint/InvalidR2UsageDetector.java
@@ -0,0 +1,112 @@
+package butterknife.lint;
+
+import com.android.tools.lint.client.api.UElementHandler;
+import com.android.tools.lint.detector.api.Category;
+import com.android.tools.lint.detector.api.Detector;
+import com.android.tools.lint.detector.api.Implementation;
+import com.android.tools.lint.detector.api.Issue;
+import com.android.tools.lint.detector.api.JavaContext;
+import com.android.tools.lint.detector.api.LintUtils;
+import com.android.tools.lint.detector.api.Scope;
+import com.android.tools.lint.detector.api.Severity;
+import com.google.common.collect.ImmutableSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import org.jetbrains.uast.UAnnotation;
+import org.jetbrains.uast.UClass;
+import org.jetbrains.uast.UElement;
+import org.jetbrains.uast.UExpression;
+import org.jetbrains.uast.UFile;
+import org.jetbrains.uast.UQualifiedReferenceExpression;
+import org.jetbrains.uast.USimpleNameReferenceExpression;
+import org.jetbrains.uast.visitor.AbstractUastVisitor;
+
+/**
+ * Custom lint rule to make sure that generated R2 is not referenced outside annotations.
+ */
+public class InvalidR2UsageDetector extends Detector implements Detector.UastScanner {
+  private static final String LINT_ERROR_BODY = "R2 should only be used inside annotations";
+  private static final String LINT_ERROR_TITLE = "Invalid usage of R2";
+  private static final String ISSUE_ID = "InvalidR2Usage";
+  private static final Set<String> SUPPORTED_TYPES =
+      ImmutableSet.of("array", "attr", "bool", "color", "dimen", "drawable", "id", "integer",
+          "string");
+
+  static final Issue ISSUE =
+      Issue.create(ISSUE_ID, LINT_ERROR_TITLE, LINT_ERROR_BODY, Category.CORRECTNESS, 6,
+          Severity.ERROR, new Implementation(InvalidR2UsageDetector.class, Scope.JAVA_FILE_SCOPE));
+
+  private static final String R2 = "R2";
+
+  @Override public List<Class<? extends UElement>> getApplicableUastTypes() {
+    return Collections.singletonList(UClass.class);
+  }
+
+  @Override public UElementHandler createUastHandler(final JavaContext context) {
+    return new UElementHandler() {
+      @Override public void visitClass(UClass node) {
+        node.accept(new R2UsageVisitor(context));
+      }
+    };
+  }
+
+  private static class R2UsageVisitor extends AbstractUastVisitor {
+    private final JavaContext context;
+
+    R2UsageVisitor(JavaContext context) {
+      this.context = context;
+    }
+
+    @Override public boolean visitAnnotation(UAnnotation annotation) {
+      // skip annotations
+      return true;
+    }
+
+    @Override public boolean visitQualifiedReferenceExpression(UQualifiedReferenceExpression node) {
+      detectR2(context, node);
+      return super.visitQualifiedReferenceExpression(node);
+    }
+
+    @Override
+    public boolean visitSimpleNameReferenceExpression(USimpleNameReferenceExpression node) {
+      detectR2(context, node);
+      return super.visitSimpleNameReferenceExpression(node);
+    }
+
+    private static void detectR2(JavaContext context, UElement node) {
+      UFile sourceFile = context.getUastFile();
+      List<UClass> classes = sourceFile.getClasses();
+      if (!classes.isEmpty() && classes.get(0).getName() != null) {
+        String qualifiedName = classes.get(0).getName();
+        if (qualifiedName.contains("_ViewBinder")
+            || qualifiedName.contains("_ViewBinding")
+            || qualifiedName.equals(R2)) {
+          // skip generated files and R2
+          return;
+        }
+      }
+      boolean isR2 = isR2Expression(node);
+      if (isR2 && !context.isSuppressedWithComment(node, ISSUE)) {
+        context.report(ISSUE, node, context.getLocation(node), LINT_ERROR_BODY);
+      }
+    }
+
+    private static boolean isR2Expression(UElement node) {
+      UElement parentNode = node.getUastParent();
+      if (parentNode == null) {
+        return false;
+      }
+      String text = node.asSourceString();
+      UElement parent = LintUtils.skipParentheses(parentNode);
+      return (text.equals(R2) || text.contains(".R2"))
+          && parent instanceof UExpression
+          && endsWithAny(parent.asSourceString(), SUPPORTED_TYPES);
+    }
+
+    private static boolean endsWithAny(String text, Set<String> possibleValues) {
+      String[] tokens = text.split("\\.");
+      return tokens.length > 1 && possibleValues.contains(tokens[tokens.length - 1]);
+    }
+  }
+}
diff --git a/butterknife-lint/src/main/java/butterknife/lint/LintRegistry.java b/butterknife-lint/src/main/java/butterknife/lint/LintRegistry.java
new file mode 100644
index 00000000..6d37fec4
--- /dev/null
+++ b/butterknife-lint/src/main/java/butterknife/lint/LintRegistry.java
@@ -0,0 +1,21 @@
+package butterknife.lint;
+
+import com.android.tools.lint.client.api.IssueRegistry;
+import com.android.tools.lint.detector.api.ApiKt;
+import com.android.tools.lint.detector.api.Issue;
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+
+/**
+ * Contains references to all custom lint checks for butterknife.
+ */
+public class LintRegistry extends IssueRegistry {
+
+  @Override public List<Issue> getIssues() {
+    return ImmutableList.of(InvalidR2UsageDetector.ISSUE);
+  }
+
+  @Override public int getApi() {
+    return ApiKt.CURRENT_API;
+  }
+}
diff --git a/butterknife-lint/src/test/java/butterknife/lint/InvalidR2UsageDetectorTest.java b/butterknife-lint/src/test/java/butterknife/lint/InvalidR2UsageDetectorTest.java
new file mode 100644
index 00000000..d655f943
--- /dev/null
+++ b/butterknife-lint/src/test/java/butterknife/lint/InvalidR2UsageDetectorTest.java
@@ -0,0 +1,137 @@
+package butterknife.lint;
+
+import com.android.tools.lint.checks.infrastructure.TestFile;
+import org.junit.Test;
+
+import static com.android.tools.lint.checks.infrastructure.TestFiles.java;
+import static com.android.tools.lint.checks.infrastructure.TestLintTask.lint;
+
+public final class InvalidR2UsageDetectorTest {
+  private static final TestFile BIND_TEST = java(""
+      + "package sample.r2;\n"
+      + "\n"
+      + "import java.lang.annotation.ElementType;\n"
+      + "import java.lang.annotation.Retention;\n"
+      + "import java.lang.annotation.RetentionPolicy;\n"
+      + "import java.lang.annotation.Target;\n"
+      + "\n"
+      + "@Retention(RetentionPolicy.SOURCE) @Target({ ElementType.FIELD, ElementType.METHOD })\n"
+      + "public @interface BindTest {\n"
+      + "  int value();\n"
+      + "}\n");
+
+  private static final TestFile R2 = java(""
+      + "package sample.r2;\n"
+      + "\n"
+      + "public final class R2 {\n"
+      + "  public static final class array {\n"
+      + "    public static final int res = 0x7f040001;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class attr {\n"
+      + "    public static final int res = 0x7f040002;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class bool {\n"
+      + "    public static final int res = 0x7f040003;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class color {\n"
+      + "    public static final int res = 0x7f040004;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class dimen {\n"
+      + "    public static final int res = 0x7f040005;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class drawable {\n"
+      + "    public static final int res = 0x7f040006;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class id {\n"
+      + "    public static final int res = 0x7f040007;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class integer {\n"
+      + "    public static final int res = 0x7f040008;\n"
+      + "  }\n"
+      + "\n"
+      + "  public static final class string {\n"
+      + "    public static final int res = 0x7f040009;\n"
+      + "  }\n"
+      + "}");
+
+  @Test public void noR2Usage() {
+    lint() //
+        .files(R2, //
+            java("" //
+                + "package sample;\n" //
+                + "class NoR2Usage {}\n")) //
+        .issues(InvalidR2UsageDetector.ISSUE) //
+        .run() //
+        .expectClean();
+  }
+
+  @Test public void usesR2InAnnotations() {
+    lint() //
+        .files(R2, BIND_TEST, //
+            java(""
+                + "package sample.r2;\n"
+                + "\n"
+                + "public class R2UsageInAnnotations {\n"
+                + "\n"
+                + "  @BindTest(sample.r2.R2.string.res) String test;\n"
+                + "\n"
+                + "  @BindTest(R2.id.res) public void foo() {}\n"
+                + "}\n") //
+        ) //
+        .issues(InvalidR2UsageDetector.ISSUE) //
+        .run() //
+        .expectClean();
+  }
+
+  @Test public void usesR2OutsideAnnotations() {
+    lint() //
+        .files(R2, //
+            java(""
+                + "package sample.r2;\n"
+                + "\n"
+                + "public class R2UsageOutsideAnnotations {\n"
+                + "\n"
+                + "  int array = sample.r2.R2.array.res;\n"
+                + "\n"
+                + "  public void foo(int color) {}\n"
+                + "\n"
+                + "  public void bar() {\n"
+                + "    foo(R2.color.res);\n"
+                + "  }\n"
+                + "}\n" //
+            )) //
+        .issues(InvalidR2UsageDetector.ISSUE) //
+        .run() //
+        .expectErrorCount(2) //
+        .expectWarningCount(0);
+  }
+
+  @Test public void usesR2WithSuppression() {
+    lint() //
+        .files(R2, java(""
+            + "package sample.r2;\n"
+            + "\n"
+            + "public class R2UsageWithSuppression {\n"
+            + "\n"
+            + "  @SuppressWarnings(\"InvalidR2Usage\")\n"
+            + "  int bool = sample.r2.R2.bool.res;\n"
+            + "\n"
+            + "  public void foo(int attr) {}\n"
+            + "\n"
+            + "  @SuppressWarnings(\"InvalidR2Usage\")\n"
+            + "  public void bar() {\n"
+            + "    foo(R2.attr.res);\n"
+            + "  }\n"
+            + "}\n")) //
+        .issues(InvalidR2UsageDetector.ISSUE) //
+        .run() //
+        .expectClean();
+  }
+}
diff --git a/butterknife-lint/src/test/java/butterknife/lint/LintRegistryTest.java b/butterknife-lint/src/test/java/butterknife/lint/LintRegistryTest.java
new file mode 100644
index 00000000..53c7480f
--- /dev/null
+++ b/butterknife-lint/src/test/java/butterknife/lint/LintRegistryTest.java
@@ -0,0 +1,11 @@
+package butterknife.lint;
+
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class LintRegistryTest {
+  @Test public void issues() {
+    assertThat(new LintRegistry().getIssues()).contains(InvalidR2UsageDetector.ISSUE);
+  }
+}
diff --git a/butterknife-reflect/README.md b/butterknife-reflect/README.md
new file mode 100644
index 00000000..a4f06e8d
--- /dev/null
+++ b/butterknife-reflect/README.md
@@ -0,0 +1,61 @@
+ButterKnife Reflect
+===================
+
+The `butterknife-reflect` artifact is an API-compatible replacement for `butterknife` which uses
+100% reflection to fulfill field and method bindings for use during development.
+
+
+Er, what? Why would I want this?
+--------------------------------
+
+The normal `butterknife` artifact requires the use of `butterknife-compiler` as an annotation
+processor for compile-time validation of your bindings and code generation for runtime performance.
+This is a desirable feature for your CI and release builds, but it slows down iterative development.
+By using `butterknife-reflect` for only your IDE builds, you have one less annotation processor
+sitting between you and your running app. This is especially important for Kotlin-only or
+Java/Kotlin mixed projects using KAPT. And if `butterknife-compiler` is your only annotation
+processor for a module, using `butterknife-reflect` means that **zero** annotation processors run
+during development.
+
+
+Can I use this in production?
+-----------------------------
+
+No.
+
+Well technically you _can_, but don't. It's slow, inefficient, and lacks the level of validation
+that normal Butter Knife usage provides.
+
+
+Usage
+-----
+
+Kotlin modules:
+```groovy
+dependencies {
+  if (properties.containsKey('android.injected.invoked.from.ide')) {
+    implementation 'com.jakewharton:butterknife-reflect:<version>'
+  } else {
+    implementation 'com.jakewharton:butterknife:<version>'
+    kapt 'com.jakewharton:butterknife-compiler:<version>'
+  }
+}
+```
+
+Java modules:
+```groovy
+dependencies {
+  if (properties.containsKey('android.injected.invoked.from.ide')) {
+    implementation 'com.jakewharton:butterknife-reflect:<version>'
+  } else {
+    implementation 'com.jakewharton:butterknife:<version>'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:<version>'
+  }
+}
+```
+
+_(Replacing `<version>` with whatever version you are using.)_
+
+If you have a dedicated variant for development you can skip the `if` check and simply add
+`butterknife-reflect` to that variant and `butterknife`+`butterknife-compiler` for the regular
+variants.
diff --git a/butterknife-reflect/build.gradle b/butterknife-reflect/build.gradle
new file mode 100644
index 00000000..d4d5d941
--- /dev/null
+++ b/butterknife-reflect/build.gradle
@@ -0,0 +1,35 @@
+apply plugin: 'com.android.library'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+
+    consumerProguardFiles 'proguard-rules.txt'
+  }
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  lintOptions {
+    textReport true
+    textOutput 'stdout'
+    // We run a full lint analysis as build part in CI, so skip vital checks for assemble tasks.
+    checkReleaseBuilds false
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+dependencies {
+  api project(':butterknife-runtime')
+  api deps.androidx.viewpager
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-reflect/gradle.properties b/butterknife-reflect/gradle.properties
new file mode 100644
index 00000000..f4fbc045
--- /dev/null
+++ b/butterknife-reflect/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=butterknife-reflect
+POM_NAME=ButterKnife Reflect
+POM_PACKAGING=aar
diff --git a/butterknife-reflect/proguard-rules.txt b/butterknife-reflect/proguard-rules.txt
new file mode 100644
index 00000000..977eba49
--- /dev/null
+++ b/butterknife-reflect/proguard-rules.txt
@@ -0,0 +1,2 @@
+-keepclassmembers class * { @butterknife.* <methods>; }
+-keepclassmembers class * { @butterknife.* <fields>; }
diff --git a/butterknife-reflect/src/main/AndroidManifest.xml b/butterknife-reflect/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..3306b63c
--- /dev/null
+++ b/butterknife-reflect/src/main/AndroidManifest.xml
@@ -0,0 +1 @@
+<manifest package="butterknife.reflect"/>
diff --git a/butterknife-reflect/src/main/java/butterknife/ButterKnife.java b/butterknife-reflect/src/main/java/butterknife/ButterKnife.java
new file mode 100644
index 00000000..fcf3fff5
--- /dev/null
+++ b/butterknife-reflect/src/main/java/butterknife/ButterKnife.java
@@ -0,0 +1,1208 @@
+package butterknife;
+
+import android.app.Activity;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.AdapterView;
+import android.widget.CompoundButton;
+import android.widget.TextView;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.core.content.ContextCompat;
+import androidx.core.content.res.ResourcesCompat;
+import androidx.viewpager.widget.ViewPager;
+import butterknife.internal.Constants;
+import butterknife.internal.Utils;
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Member;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
+import static java.util.Collections.singletonList;
+
+public final class ButterKnife {
+  private ButterKnife() {
+    throw new AssertionError();
+  }
+
+  private static final String TAG = "ButterKnife";
+  private static boolean debug = false;
+
+  /** Control whether debug logging is enabled. */
+  public static void setDebug(boolean debug) {
+    ButterKnife.debug = debug;
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@link Activity}. The current content
+   * view is used as the view root.
+   *
+   * @param target Target activity for view binding.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Activity target) {
+    View sourceView = target.getWindow().getDecorView();
+    return bind(target, sourceView);
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@link View}. The view and its children
+   * are used as the view root.
+   *
+   * @param target Target view for view binding.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull View target) {
+    return bind(target, target);
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@link Dialog}. The current content
+   * view is used as the view root.
+   *
+   * @param target Target dialog for view binding.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Dialog target) {
+    View sourceView = target.getWindow().getDecorView();
+    return bind(target, sourceView);
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+   * {@link Activity} as the view root.
+   *
+   * @param target Target class for view binding.
+   * @param source Activity on which IDs will be looked up.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
+    View sourceView = source.getWindow().getDecorView();
+    return bind(target, sourceView);
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+   * {@link Dialog} as the view root.
+   *
+   * @param target Target class for view binding.
+   * @param source Dialog on which IDs will be looked up.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
+    View sourceView = source.getWindow().getDecorView();
+    return bind(target, sourceView);
+  }
+
+  /**
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+   * {@link View} as the view root.
+   *
+   * @param target Target class for view binding.
+   * @param source View root on which IDs will be looked up.
+   */
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull View source) {
+    List<Unbinder> unbinders = new ArrayList<>();
+    Class<?> targetClass = target.getClass();
+    if ((targetClass.getModifiers() & PRIVATE) != 0) {
+      throw new IllegalArgumentException(targetClass.getName() + " must not be private.");
+    }
+
+    while (true) {
+      String clsName = targetClass.getName();
+      if (clsName.startsWith("android.") || clsName.startsWith("java.")
+          || clsName.startsWith("androidx.")) {
+        break;
+      }
+
+      for (Field field : targetClass.getDeclaredFields()) {
+        int unbinderStartingSize = unbinders.size();
+        Unbinder unbinder;
+
+        unbinder = parseBindView(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindViews(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindAnim(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindArray(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindBitmap(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindBool(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindColor(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindDimen(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindDrawable(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindFloat(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindFont(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindInt(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseBindString(target, field, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        if (unbinders.size() - unbinderStartingSize > 1) {
+          throw new IllegalStateException(
+              "More than one bind annotation on " + targetClass.getName() + "." + field.getName());
+        }
+      }
+
+      for (Method method : targetClass.getDeclaredMethods()) {
+        Unbinder unbinder;
+
+        unbinder = parseOnCheckedChanged(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnClick(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnEditorAction(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnFocusChange(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnItemClick(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnItemLongClick(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnLongClick(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnPageChange(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnTextChanged(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+
+        unbinder = parseOnTouch(target, method, source);
+        if (unbinder != null) unbinders.add(unbinder);
+      }
+
+      targetClass = targetClass.getSuperclass();
+    }
+
+    if (unbinders.isEmpty()) {
+      if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
+      return Unbinder.EMPTY;
+    }
+
+    if (debug) Log.d(TAG, "HIT: Reflectively found " + unbinders.size() + " bindings.");
+    return new CompositeUnbinder(unbinders);
+  }
+
+  private static @Nullable Unbinder parseBindView(Object target, Field field, View source) {
+    BindView bindView = field.getAnnotation(BindView.class);
+    if (bindView == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindView.value();
+    Class<?> viewClass = field.getType();
+    if (!View.class.isAssignableFrom(viewClass) && !viewClass.isInterface()) {
+      throw new IllegalStateException(
+          "@BindView fields must extend from View or be an interface. ("
+              + field.getDeclaringClass().getName()
+              + '.'
+              + field.getName()
+              + ')');
+    }
+
+    String who = "field '" + field.getName() + "'";
+    Object view = Utils.findOptionalViewAsType(source, id, who, viewClass);
+    trySet(field, target, view);
+
+    return new FieldUnbinder(target, field);
+  }
+
+  private static @Nullable Unbinder parseBindViews(Object target, Field field, View source) {
+    BindViews bindViews = field.getAnnotation(BindViews.class);
+    if (bindViews == null) {
+      return null;
+    }
+    validateMember(field);
+
+    Class<?> fieldClass = field.getType();
+    Class<?> viewClass;
+    boolean isArray = fieldClass.isArray();
+    if (isArray) {
+      viewClass = fieldClass.getComponentType();
+    } else if (fieldClass == List.class) {
+      Type fieldType = field.getGenericType();
+      if (fieldType instanceof ParameterizedType) {
+        Type viewType = ((ParameterizedType) fieldType).getActualTypeArguments()[0];
+        // TODO real rawType impl!!!!
+        viewClass = (Class<?>) viewType;
+      } else {
+        throw new IllegalStateException("@BindViews List must have a generic component. ("
+            + field.getDeclaringClass().getName()
+            + '.'
+            + field.getName()
+            + ')');
+      }
+    } else {
+      throw new IllegalStateException("@BindViews must be a List or array. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    if (!View.class.isAssignableFrom(viewClass) && !viewClass.isInterface()) {
+      throw new IllegalStateException(
+          "@BindViews List or array type must extend from View or be an interface. ("
+              + field.getDeclaringClass().getName()
+              + '.'
+              + field.getName()
+              + ')');
+    }
+
+    int[] ids = bindViews.value();
+    if (ids.length == 0) {
+      throw new IllegalStateException("@BindViews must specify at least one ID. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+
+    List<Object> views = new ArrayList<>(ids.length);
+    String who = "field '" + field.getName() + "'";
+    for (int id : ids) {
+      Object view = Utils.findOptionalViewAsType(source, id, who, viewClass);
+      if (view != null) {
+        views.add(view);
+      }
+    }
+
+    Object value;
+    if (isArray) {
+      Object[] viewArray = (Object[]) Array.newInstance(viewClass, views.size());
+      value = views.toArray(viewArray);
+    } else {
+      value = views;
+    }
+
+    trySet(field, target, value);
+    return new FieldUnbinder(target, field);
+  }
+
+  private static @Nullable Unbinder parseBindAnim(Object target, Field field, View source) {
+    BindAnim bindAnim = field.getAnnotation(BindAnim.class);
+    if (bindAnim == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindAnim.value();
+    Context context = source.getContext();
+
+    Object value;
+    Class<?> fieldType = field.getType();
+    if (fieldType == Animation.class) {
+      value = AnimationUtils.loadAnimation(context, id);
+    } else {
+      throw new IllegalStateException("@BindAnim field type must be 'Animation'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindArray(Object target, Field field, View source) {
+    BindArray bindArray = field.getAnnotation(BindArray.class);
+    if (bindArray == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindArray.value();
+    Resources resources = source.getContext().getResources();
+
+    Object value;
+    Class<?> fieldType = field.getType();
+    if (fieldType == TypedArray.class) {
+      value = resources.obtainTypedArray(id);
+    } else if (fieldType.isArray()) {
+      Class<?> componentType = fieldType.getComponentType();
+      if (componentType == String.class) {
+        value = resources.getStringArray(id);
+      } else if (componentType == int.class) {
+        value = resources.getIntArray(id);
+      } else if (componentType == CharSequence.class) {
+        value = resources.getTextArray(id);
+      } else {
+        throw new IllegalStateException("@BindArray field type must be one of: "
+            + "String[], int[], CharSequence[], android.content.res.TypedArray. ("
+            + field.getDeclaringClass().getName()
+            + '.'
+            + field.getName()
+            + ')');
+      }
+    } else {
+      throw new IllegalStateException("@BindArray field type must be one of: "
+          + "String[], int[], CharSequence[], android.content.res.TypedArray. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindBitmap(Object target, Field field, View source) {
+    BindBitmap bindBitmap = field.getAnnotation(BindBitmap.class);
+    if (bindBitmap == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindBitmap.value();
+    Resources resources = source.getContext().getResources();
+
+    Object value;
+    Class<?> fieldType = field.getType();
+    if (fieldType == Bitmap.class) {
+      value = BitmapFactory.decodeResource(resources, id);
+    } else {
+      throw new IllegalStateException("@BindBitmap field type must be 'Bitmap'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindBool(Object target, Field field, View source) {
+    BindBool bindBool = field.getAnnotation(BindBool.class);
+    if (bindBool == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindBool.value();
+    Resources resources = source.getContext().getResources();
+
+    Object value;
+    Class<?> fieldType = field.getType();
+    if (fieldType == boolean.class) {
+      value = resources.getBoolean(id);
+    } else {
+      throw new IllegalStateException("@BindBool field type must be 'boolean'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindColor(Object target, Field field, View source) {
+    BindColor bindColor = field.getAnnotation(BindColor.class);
+    if (bindColor == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindColor.value();
+    Context context = source.getContext();
+
+    Object value;
+    Class<?> fieldType = field.getType();
+    if (fieldType == int.class) {
+      value = ContextCompat.getColor(context, id);
+    } else if (fieldType == ColorStateList.class) {
+      value = ContextCompat.getColorStateList(context, id);
+    } else {
+      throw new IllegalStateException("@BindColor field type must be 'int' or 'ColorStateList'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindDimen(Object target, Field field, View source) {
+    BindDimen bindDimen = field.getAnnotation(BindDimen.class);
+    if (bindDimen == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindDimen.value();
+    Resources resources = source.getContext().getResources();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == int.class) {
+      value = resources.getDimensionPixelSize(id);
+    } else if (fieldType == float.class) {
+      value = resources.getDimension(id);
+    } else {
+      throw new IllegalStateException("@BindDimen field type must be 'int' or 'float'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindDrawable(Object target, Field field, View source) {
+    BindDrawable bindDrawable = field.getAnnotation(BindDrawable.class);
+    if (bindDrawable == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindDrawable.value();
+    int tint = bindDrawable.tint();
+    Context context = source.getContext();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == Drawable.class) {
+      value = tint != Constants.NO_RES_ID
+          ? Utils.getTintedDrawable(context, id, tint)
+          : ContextCompat.getDrawable(context, id);
+    } else {
+      throw new IllegalStateException("@BindDrawable field type must be 'Drawable'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindFloat(Object target, Field field, View source) {
+    BindFloat bindInt = field.getAnnotation(BindFloat.class);
+    if (bindInt == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindInt.value();
+    Context context = source.getContext();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == float.class) {
+      value = Utils.getFloat(context, id);
+    } else {
+      throw new IllegalStateException("@BindFloat field type must be 'float'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindFont(Object target, Field field, View source) {
+    BindFont bindFont = field.getAnnotation(BindFont.class);
+    if (bindFont == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindFont.value();
+    int style = bindFont.style();
+    Context context = source.getContext();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == Typeface.class) {
+      Typeface font = ResourcesCompat.getFont(context, id);
+      switch (style) {
+        case Typeface.NORMAL:
+          value = font;
+          break;
+        case Typeface.BOLD:
+        case Typeface.ITALIC:
+        case Typeface.BOLD_ITALIC:
+          value = Typeface.create(font, style);
+          break;
+        default:
+          throw new IllegalStateException(
+              "@BindFont style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. ("
+                  + field.getDeclaringClass().getName()
+                  + '.'
+                  + field.getName()
+                  + ')');
+      }
+    } else {
+      throw new IllegalStateException("@BindFont field type must be 'Typeface'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindInt(Object target, Field field, View source) {
+    BindInt bindInt = field.getAnnotation(BindInt.class);
+    if (bindInt == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindInt.value();
+    Resources resources = source.getContext().getResources();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == int.class) {
+      value = resources.getInteger(id);
+    } else {
+      throw new IllegalStateException("@BindInt field type must be 'int'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseBindString(Object target, Field field, View source) {
+    BindString bindString = field.getAnnotation(BindString.class);
+    if (bindString == null) {
+      return null;
+    }
+    validateMember(field);
+
+    int id = bindString.value();
+    Context context = source.getContext();
+
+    Class<?> fieldType = field.getType();
+    Object value;
+    if (fieldType == String.class) {
+      value = context.getString(id);
+    } else {
+      throw new IllegalStateException("@BindString field type must be 'String'. ("
+          + field.getDeclaringClass().getName()
+          + '.'
+          + field.getName()
+          + ')');
+    }
+    trySet(field, target, value);
+
+    return Unbinder.EMPTY;
+  }
+
+  private static @Nullable Unbinder parseOnCheckedChanged(final Object target, final Method method,
+      View source) {
+    OnCheckedChanged onCheckedChanged = method.getAnnotation(OnCheckedChanged.class);
+    if (onCheckedChanged == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_CHECKED_CHANGED_TYPES);
+
+    List<CompoundButton> views =
+        findViews(source, onCheckedChanged.value(), isRequired(method), method.getName(),
+            CompoundButton.class);
+
+    ViewCollections.set(views, ON_CHECKED_CHANGE,
+        (buttonView, isChecked) -> tryInvoke(method, target,
+            argumentTransformer.transform(buttonView, isChecked)));
+
+    return new ListenerUnbinder<>(views, ON_CHECKED_CHANGE);
+  }
+
+  private static @Nullable Unbinder parseOnClick(final Object target, final Method method,
+      View source) {
+    OnClick onClick = method.getAnnotation(OnClick.class);
+    if (onClick == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_CLICK_TYPES);
+
+    List<View> views =
+        findViews(source, onClick.value(), isRequired(method), method.getName(), View.class);
+
+    ViewCollections.set(views, ON_CLICK,
+        v -> tryInvoke(method, target, argumentTransformer.transform(v)));
+
+    return new ListenerUnbinder<>(views, ON_CLICK);
+  }
+
+  private static @Nullable Unbinder parseOnEditorAction(final Object target, final Method method,
+      View source) {
+    OnEditorAction onEditorAction = method.getAnnotation(OnEditorAction.class);
+    if (onEditorAction == null) {
+      return null;
+    }
+    validateMember(method);
+    final boolean propagateReturn = validateReturnType(method, boolean.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_EDITOR_ACTION_TYPES);
+
+    List<TextView> views =
+        findViews(source, onEditorAction.value(), isRequired(method), method.getName(),
+            TextView.class);
+
+    ViewCollections.set(views, ON_EDITOR_ACTION, (v, actionId, event) -> {
+      Object value = tryInvoke(method, target, argumentTransformer.transform(v, actionId, event));
+      //noinspection SimplifiableConditionalExpression
+      return propagateReturn
+          ? (boolean) value
+          : true;
+    });
+
+    return new ListenerUnbinder<>(views, ON_EDITOR_ACTION);
+  }
+
+  private static @Nullable Unbinder parseOnFocusChange(final Object target, final Method method,
+      View source) {
+    OnFocusChange onFocusChange = method.getAnnotation(OnFocusChange.class);
+    if (onFocusChange == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_FOCUS_CHANGE_TYPES);
+
+    List<View> views =
+        findViews(source, onFocusChange.value(), isRequired(method), method.getName(), View.class);
+
+    ViewCollections.set(views, ON_FOCUS_CHANGE,
+        (v, hasFocus) -> tryInvoke(method, target, argumentTransformer.transform(v, hasFocus)));
+
+    return new ListenerUnbinder<>(views, ON_FOCUS_CHANGE);
+  }
+
+  private static @Nullable Unbinder parseOnItemClick(final Object target, final Method method,
+      View source) {
+    OnItemClick onItemClick = method.getAnnotation(OnItemClick.class);
+    if (onItemClick == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_ITEM_CLICK_TYPES);
+
+    List<AdapterView<?>> views =
+        findViews(source, onItemClick.value(), isRequired(method), method.getName(),
+            AdapterView.class);
+
+    ViewCollections.set(views, ON_ITEM_CLICK,
+        (parent, view, position, id) -> tryInvoke(method, target,
+            argumentTransformer.transform(parent, view, position, id)));
+
+    return new ListenerUnbinder<>(views, ON_ITEM_CLICK);
+  }
+
+  private static @Nullable Unbinder parseOnItemLongClick(final Object target, final Method method,
+      View source) {
+    OnItemLongClick onItemLongClick = method.getAnnotation(OnItemLongClick.class);
+    if (onItemLongClick == null) {
+      return null;
+    }
+    validateMember(method);
+    final boolean propagateReturn = validateReturnType(method, boolean.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_ITEM_LONG_CLICK_TYPES);
+
+    List<AdapterView<?>> views =
+        findViews(source, onItemLongClick.value(), isRequired(method), method.getName(),
+            AdapterView.class);
+
+    ViewCollections.set(views, ON_ITEM_LONG_CLICK, (parent, view, position, id) -> {
+      Object value =
+          tryInvoke(method, target, argumentTransformer.transform(parent, view, position, id));
+      //noinspection SimplifiableConditionalExpression
+      return propagateReturn
+          ? (boolean) value
+          : true;
+    });
+
+    return new ListenerUnbinder<>(views, ON_ITEM_LONG_CLICK);
+  }
+
+  private static @Nullable Unbinder parseOnLongClick(final Object target, final Method method,
+      View source) {
+    OnLongClick onLongClick = method.getAnnotation(OnLongClick.class);
+    if (onLongClick == null) {
+      return null;
+    }
+    validateMember(method);
+    final boolean propagateReturn = validateReturnType(method, boolean.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_LONG_CLICK_TYPES);
+
+    List<View> views =
+        findViews(source, onLongClick.value(), isRequired(method), method.getName(), View.class);
+
+    ViewCollections.set(views, ON_LONG_CLICK, v -> {
+      Object returnValue = tryInvoke(method, target, argumentTransformer.transform(v));
+      //noinspection SimplifiableConditionalExpression
+      return propagateReturn
+          ? (boolean) returnValue
+          : true;
+    });
+
+    return new ListenerUnbinder<>(views, ON_LONG_CLICK);
+  }
+
+  private static @Nullable Unbinder parseOnPageChange(final Object target, final Method method,
+      View source) {
+    OnPageChange onPageChange = method.getAnnotation(OnPageChange.class);
+    if (onPageChange == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+
+    List<ViewPager> views =
+        findViews(source, onPageChange.value(), isRequired(method), method.getName(),
+            ViewPager.class);
+
+    ViewPager.OnPageChangeListener listener;
+    switch (onPageChange.callback()) {
+      case PAGE_SCROLLED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, ON_PAGE_SCROLLED_TYPES);
+        listener = new ViewPager.SimpleOnPageChangeListener() {
+          @Override public void onPageScrolled(int position, float positionOffset,
+              int positionOffsetPixels) {
+            tryInvoke(method, target,
+                argumentTransformer.transform(position, positionOffset, positionOffsetPixels));
+          }
+        };
+        break;
+      }
+      case PAGE_SELECTED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, ON_PAGE_SELECTED_TYPES);
+        listener = new ViewPager.SimpleOnPageChangeListener() {
+          @Override public void onPageSelected(int position) {
+            tryInvoke(method, target, argumentTransformer.transform(position));
+          }
+        };
+        break;
+      }
+      case PAGE_SCROLL_STATE_CHANGED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, ON_PAGE_SCROLL_STATE_CHANGED_TYPES);
+        listener = new ViewPager.SimpleOnPageChangeListener() {
+          @Override public void onPageScrollStateChanged(int state) {
+            tryInvoke(method, target, argumentTransformer.transform(state));
+          }
+        };
+        break;
+      }
+      default:
+        throw new AssertionError();
+    }
+
+    ViewCollections.set(views, ADD_ON_PAGE_CHANGE, listener);
+    return new ListenerUnbinder<>(views, REMOVE_ON_PAGE_CHANGE, listener);
+  }
+
+  private static @Nullable Unbinder parseOnTextChanged(Object target, Method method, View source) {
+    OnTextChanged onTextChanged = method.getAnnotation(OnTextChanged.class);
+    if (onTextChanged == null) {
+      return null;
+    }
+    validateMember(method);
+    validateReturnType(method, void.class);
+
+    List<TextView> views =
+        findViews(source, onTextChanged.value(), isRequired(method), method.getName(), View.class);
+
+    TextWatcher textWatcher;
+    switch (onTextChanged.callback()) {
+      case TEXT_CHANGED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, ON_TEXT_CHANGED_TYPES);
+        textWatcher = new EmptyTextWatcher() {
+          @Override public void onTextChanged(CharSequence s, int start, int before, int count) {
+            tryInvoke(method, target, argumentTransformer.transform(s, start, before, count));
+          }
+        };
+        break;
+      }
+      case BEFORE_TEXT_CHANGED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, BEFORE_TEXT_CHANGED_TYPES);
+        textWatcher = new EmptyTextWatcher() {
+          @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            tryInvoke(method, target, argumentTransformer.transform(s, start, count, after));
+          }
+        };
+        break;
+      }
+      case AFTER_TEXT_CHANGED: {
+        ArgumentTransformer argumentTransformer =
+            createArgumentTransformer(method, AFTER_TEXT_CHANGED_TYPES);
+        textWatcher = new EmptyTextWatcher() {
+          @Override public void afterTextChanged(Editable s) {
+            tryInvoke(method, target, argumentTransformer.transform(s));
+          }
+        };
+        break;
+      }
+      default:
+        throw new AssertionError();
+    }
+
+    ViewCollections.set(views, ADD_TEXT_WATCHER, textWatcher);
+    return new ListenerUnbinder<>(views, REMOVE_TEXT_WATCHER, textWatcher);
+  }
+
+  private static @Nullable Unbinder parseOnTouch(final Object target, final Method method,
+      View source) {
+    OnTouch onTouch = method.getAnnotation(OnTouch.class);
+    if (onTouch == null) {
+      return null;
+    }
+    validateMember(method);
+    final boolean propagateReturn = validateReturnType(method, boolean.class);
+    final ArgumentTransformer argumentTransformer =
+        createArgumentTransformer(method, ON_TOUCH_TYPES);
+
+    List<View> views =
+        findViews(source, onTouch.value(), isRequired(method), method.getName(), View.class);
+
+    ViewCollections.set(views, ON_TOUCH, (v, event) -> {
+      Object returnValue = tryInvoke(method, target, argumentTransformer.transform(v));
+      //noinspection SimplifiableConditionalExpression
+      return propagateReturn
+          ? (boolean) returnValue
+          : true;
+    });
+
+    return new ListenerUnbinder<>(views, ON_TOUCH);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends View> List<T> findViews(View source, int[] ids, boolean isRequired,
+      String name, Class<? extends View> cls) {
+    if (ids.length == 1 && ids[0] == View.NO_ID) {
+      return singletonList((T) cls.cast(source));
+    }
+
+    String who = "method '" + name + "'";
+    List<T> views = new ArrayList<>(ids.length);
+    for (int id : ids) {
+      if (isRequired) {
+        views.add((T) Utils.findRequiredViewAsType(source, id, who, cls));
+      } else {
+        T view = (T) Utils.findOptionalViewAsType(source, id, who, cls);
+        if (view != null) {
+          views.add(view);
+        }
+      }
+    }
+    return views;
+  }
+
+  private static <T extends AccessibleObject & Member> void validateMember(T object) {
+    int modifiers = object.getModifiers();
+    if ((modifiers & (PRIVATE | STATIC)) != 0) {
+      throw new IllegalStateException(object.getDeclaringClass().getName()
+          + "."
+          + object.getName()
+          + " must not be private or static");
+    }
+    if ((modifiers & PUBLIC) == 0) {
+      object.setAccessible(true);
+    }
+  }
+
+  /** Returns true when the return value should be propagated. Use a default otherwise. */
+  private static boolean validateReturnType(Method method, Class<?> expected) {
+    Class<?> returnType = method.getReturnType();
+    if (returnType == void.class) {
+      return false;
+    }
+    if (returnType != expected) {
+      String expectedType = "'" + expected.getName() + "'";
+      if (expected != void.class) {
+        expectedType = "'void' or " + expectedType;
+      }
+      throw new IllegalStateException(method.getDeclaringClass().getName()
+          + "."
+          + method.getName()
+          + " must have return type of "
+          + expectedType);
+    }
+    return true;
+  }
+
+  private static boolean isRequired(Method method) {
+    return method.getAnnotation(Optional.class) == null;
+  }
+
+  private static ArgumentTransformer createArgumentTransformer(Method method,
+      Class<?>[] callbackParameterTypes) {
+    Class<?>[] targetParameterTypes = method.getParameterTypes();
+
+    int targetParameterLength = targetParameterTypes.length;
+    if (targetParameterLength == 0) {
+      // Special case the common case of no arguments.
+      return ArgumentTransformer.EMPTY;
+    }
+
+    int callbackParameterLength = callbackParameterTypes.length;
+    if (targetParameterLength > callbackParameterLength) {
+      throw new IllegalStateException(method.getDeclaringClass().getName()
+          + "."
+          + method.getName()
+          + " must have at most "
+          + callbackParameterLength
+          + " parameter(s).");
+    }
+
+    if (Arrays.equals(targetParameterTypes, callbackParameterTypes)) {
+      // Special case the common case of exact argument match.
+      return ArgumentTransformer.IDENTITY;
+    }
+
+    boolean[] callbackIndexUsed = new boolean[callbackParameterLength];
+    final int[] indexMap = new int[targetParameterLength];
+    nextTarget: for (int targetIndex = 0; targetIndex < targetParameterLength; targetIndex++) {
+      Class<?> targetParameterType = targetParameterTypes[targetIndex];
+      for (int callbackIndex = 0; callbackIndex < callbackParameterLength; callbackIndex++) {
+        if (callbackIndexUsed[callbackIndex]) {
+          continue; // We have already used this callback argument.
+        }
+        Class<?> callbackParameterType = callbackParameterTypes[callbackIndex];
+
+        if (/* exact match */
+            callbackParameterType.equals(targetParameterType)
+            /* or subtype of view */
+            || (View.class.isAssignableFrom(callbackParameterType)
+                && callbackParameterType.isAssignableFrom(targetParameterType))
+            /* or interface (like Checkable) */
+            || targetParameterType.isInterface()) {
+          indexMap[targetIndex] = callbackIndex;
+          callbackIndexUsed[callbackIndex] = true;
+          continue nextTarget; // This avoids the error handling code if loop exits normally.
+        }
+      }
+
+      StringBuilder builder = new StringBuilder();
+      builder.append("Unable to match ")
+          .append(method.getDeclaringClass().getName())
+          .append('.')
+          .append(method.getName())
+          .append(" method arguments.");
+      for (int i = 0; i < targetParameterLength; i++) {
+        builder.append("\n\n  Parameter #")
+            .append(i + 1)
+            .append(": ")
+            .append(targetParameterTypes[i].getName())
+            .append("\n    ");
+        if (i < targetIndex) {
+          builder.append("matched listener parameter #")
+              .append(indexMap[i])
+              .append(": ")
+              .append(callbackParameterTypes[indexMap[i]].getName());
+        } else {
+          builder.append("did not match any listener parameters");
+        }
+      }
+      builder.append("\n\nMethods may have up to ")
+          .append(callbackParameterLength)
+          .append(" parameter(s):\n");
+      for (Class<?> callbackParameter : callbackParameterTypes) {
+        builder.append("\n  ").append(callbackParameter.getName());
+      }
+      builder.append(
+          "\n\nThese may be listed in any order but will be searched for from top to bottom.");
+      throw new IllegalStateException(builder.toString());
+    }
+
+    return new ArgumentTransformer() {
+      @Override public Object[] transform(Object... arguments) {
+        Object[] newArguments = new Object[indexMap.length];
+        for (int i = 0; i < indexMap.length; i++) {
+          newArguments[i] = arguments[indexMap[i]];
+        }
+        return newArguments;
+      }
+
+      @Override public String toString() {
+        StringBuilder builder = new StringBuilder("ArgumentTransformer[");
+        for (int i = 0; i < indexMap.length; i++) {
+          if (i > 0) {
+            builder.append(", ");
+          }
+          builder.append(i).append(" => ").append(indexMap[i]);
+        }
+        return builder.append(']').toString();
+      }
+    };
+  }
+
+  static void trySet(Field field, Object target, @Nullable Object value) {
+    try {
+      field.set(target, value);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Unable to assign " + value + " to " + field + " on " + target, e);
+    }
+  }
+
+  private static Object tryInvoke(Method method, Object target, Object... arguments) {
+    Throwable cause;
+    try {
+      return method.invoke(target, arguments);
+    } catch (IllegalAccessException e) {
+      cause = e;
+    } catch (InvocationTargetException e) {
+      cause = e;
+    }
+    throw new RuntimeException(
+        "Unable to invoke " + method + " on " + target + " with arguments "
+            + Arrays.toString(arguments), cause);
+  }
+
+  private static final Setter<CompoundButton, CompoundButton.OnCheckedChangeListener>
+      ON_CHECKED_CHANGE = (view, value, index) -> view.setOnCheckedChangeListener(value);
+  private static final Setter<View, View.OnClickListener> ON_CLICK =
+      (view, value, index) -> view.setOnClickListener(value);
+  private static final Setter<TextView, TextView.OnEditorActionListener> ON_EDITOR_ACTION =
+      (view, value, index) -> view.setOnEditorActionListener(value);
+  private static final Setter<View, View.OnFocusChangeListener> ON_FOCUS_CHANGE =
+      (view, value, index) -> view.setOnFocusChangeListener(value);
+  private static final Setter<AdapterView<?>, AdapterView.OnItemClickListener> ON_ITEM_CLICK =
+      (view, value, index) -> view.setOnItemClickListener(value);
+  private static final Setter<AdapterView<?>, AdapterView.OnItemLongClickListener>
+      ON_ITEM_LONG_CLICK = (view, value, index) -> view.setOnItemLongClickListener(value);
+  private static final Setter<View, View.OnLongClickListener> ON_LONG_CLICK =
+      (view, value, index) -> view.setOnLongClickListener(value);
+  private static final Setter<View, View.OnTouchListener> ON_TOUCH =
+      (view, value, index) -> view.setOnTouchListener(value);
+  private static final Setter<ViewPager, ViewPager.OnPageChangeListener> ADD_ON_PAGE_CHANGE =
+      (view, value, index) -> view.addOnPageChangeListener(value);
+  private static final Setter<ViewPager, ViewPager.OnPageChangeListener> REMOVE_ON_PAGE_CHANGE =
+      (view, value, index) -> view.removeOnPageChangeListener(value);
+  private static final Setter<TextView, TextWatcher> ADD_TEXT_WATCHER =
+      (view, value, index) -> view.addTextChangedListener(value);
+  private static final Setter<TextView, TextWatcher> REMOVE_TEXT_WATCHER =
+      (view, value, index) -> view.removeTextChangedListener(value);
+
+  private static final Class<?>[] ON_CHECKED_CHANGED_TYPES =
+      { CompoundButton.class, boolean.class };
+  private static final Class<?>[] ON_CLICK_TYPES = { View.class };
+  private static final Class<?>[] ON_EDITOR_ACTION_TYPES =
+      { TextView.class, int.class, KeyEvent.class };
+  private static final Class<?>[] ON_FOCUS_CHANGE_TYPES = { View.class, boolean.class };
+  private static final Class<?>[] ON_ITEM_CLICK_TYPES =
+      { AdapterView.class, View.class, int.class, long.class };
+  private static final Class<?>[] ON_ITEM_LONG_CLICK_TYPES = ON_ITEM_CLICK_TYPES;
+  private static final Class<?>[] ON_LONG_CLICK_TYPES = ON_CLICK_TYPES;
+  private static final Class<?>[] ON_PAGE_SCROLLED_TYPES = { int.class, float.class, int.class };
+  private static final Class<?>[] ON_PAGE_SELECTED_TYPES = { int.class };
+  private static final Class<?>[] ON_PAGE_SCROLL_STATE_CHANGED_TYPES = { int.class };
+  private static final Class<?>[] ON_TEXT_CHANGED_TYPES =
+      { CharSequence.class, int.class, int.class, int.class };
+  private static final Class<?>[] BEFORE_TEXT_CHANGED_TYPES = ON_TEXT_CHANGED_TYPES;
+  private static final Class<?>[] AFTER_TEXT_CHANGED_TYPES = { Editable.class };
+  private static final Class<?>[] ON_TOUCH_TYPES = { View.class, MotionEvent.class };
+
+  private interface ArgumentTransformer {
+    ArgumentTransformer EMPTY = new ArgumentTransformer() {
+      private final Object[] empty = new Object[0];
+
+      @Override public Object[] transform(Object... arguments) {
+        return empty;
+      }
+
+      @Override public String toString() {
+        return "ArgumentTransformer[empty]";
+      }
+    };
+    ArgumentTransformer IDENTITY = new ArgumentTransformer() {
+      @Override public Object[] transform(Object... arguments) {
+        return arguments;
+      }
+
+      @Override public String toString() {
+        return "ArgumentTransformer[identity]";
+      }
+    };
+
+    Object[] transform(Object... arguments);
+  }
+}
diff --git a/butterknife-reflect/src/main/java/butterknife/CompositeUnbinder.java b/butterknife-reflect/src/main/java/butterknife/CompositeUnbinder.java
new file mode 100644
index 00000000..5e5adb47
--- /dev/null
+++ b/butterknife-reflect/src/main/java/butterknife/CompositeUnbinder.java
@@ -0,0 +1,23 @@
+package butterknife;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import java.util.List;
+
+final class CompositeUnbinder implements Unbinder {
+  private @Nullable List<Unbinder> unbinders;
+
+  CompositeUnbinder(@NonNull List<Unbinder> unbinders) {
+    this.unbinders = unbinders;
+  }
+
+  @Override public void unbind() {
+    if (unbinders == null) {
+      throw new IllegalStateException("Bindings already cleared.");
+    }
+    for (Unbinder unbinder : unbinders) {
+      unbinder.unbind();
+    }
+    unbinders = null;
+  }
+}
diff --git a/butterknife-reflect/src/main/java/butterknife/EmptyTextWatcher.java b/butterknife-reflect/src/main/java/butterknife/EmptyTextWatcher.java
new file mode 100644
index 00000000..3b578dee
--- /dev/null
+++ b/butterknife-reflect/src/main/java/butterknife/EmptyTextWatcher.java
@@ -0,0 +1,15 @@
+package butterknife;
+
+import android.text.Editable;
+import android.text.TextWatcher;
+
+class EmptyTextWatcher implements TextWatcher {
+  @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+  }
+
+  @Override public void onTextChanged(CharSequence s, int start, int before, int count) {
+  }
+
+  @Override public void afterTextChanged(Editable s) {
+  }
+}
diff --git a/butterknife-reflect/src/main/java/butterknife/FieldUnbinder.java b/butterknife-reflect/src/main/java/butterknife/FieldUnbinder.java
new file mode 100644
index 00000000..915c567a
--- /dev/null
+++ b/butterknife-reflect/src/main/java/butterknife/FieldUnbinder.java
@@ -0,0 +1,19 @@
+package butterknife;
+
+import java.lang.reflect.Field;
+
+import static butterknife.ButterKnife.trySet;
+
+final class FieldUnbinder implements Unbinder {
+  private final Object target;
+  private final Field field;
+
+  FieldUnbinder(Object target, Field field) {
+    this.target = target;
+    this.field = field;
+  }
+
+  @Override public void unbind() {
+    trySet(field, target, null);
+  }
+}
diff --git a/butterknife-reflect/src/main/java/butterknife/ListenerUnbinder.java b/butterknife-reflect/src/main/java/butterknife/ListenerUnbinder.java
new file mode 100644
index 00000000..063f294d
--- /dev/null
+++ b/butterknife-reflect/src/main/java/butterknife/ListenerUnbinder.java
@@ -0,0 +1,26 @@
+package butterknife;
+
+import android.view.View;
+import java.util.List;
+
+final class ListenerUnbinder<V extends View, L> implements Unbinder {
+  private final List<V> targets;
+  private final Setter<V, L> setter;
+  private final L listener;
+
+  ListenerUnbinder(List<V> targets, Setter<V, L> setter) {
+    this.targets = targets;
+    this.setter = setter;
+    this.listener = null;
+  }
+
+  ListenerUnbinder(List<V> targets, Setter<V, L> setter, L listener) {
+    this.targets = targets;
+    this.setter = setter;
+    this.listener = listener;
+  }
+
+  @Override public void unbind() {
+    ViewCollections.set(targets, setter, listener);
+  }
+}
diff --git a/butterknife-runtime/build.gradle b/butterknife-runtime/build.gradle
new file mode 100644
index 00000000..02944b05
--- /dev/null
+++ b/butterknife-runtime/build.gradle
@@ -0,0 +1,70 @@
+apply plugin: 'com.android.library'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+
+    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
+
+    javaCompileOptions {
+      annotationProcessorOptions {
+        includeCompileClasspath = true
+      }
+    }
+  }
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  lintOptions {
+    textReport true
+    textOutput 'stdout'
+    // We run a full lint analysis as build part in CI, so skip vital checks for assemble tasks.
+    checkReleaseBuilds false
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+dependencies {
+  api project(':butterknife-annotations')
+  api deps.androidx.core
+
+  lintChecks project(':butterknife-lint')
+
+  androidTestImplementation deps.junit
+  androidTestImplementation deps.truth
+  androidTestImplementation deps.androidx.test.runner
+  androidTestAnnotationProcessor project(':butterknife-compiler')
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+  testImplementation deps.compiletesting
+  testImplementation files(getRuntimeJar())
+  testImplementation files(org.gradle.internal.jvm.Jvm.current().getToolsJar())
+  testImplementation project(':butterknife-compiler')
+  testImplementation deps.androidx.annotations
+}
+
+def getRuntimeJar() {
+  try {
+    final File javaBase = new File(System.getProperty("java.home")).getCanonicalFile();
+    File runtimeJar = new File(javaBase, "lib/rt.jar");
+    if (runtimeJar.exists()) {
+      return runtimeJar;
+    }
+    runtimeJar = new File(javaBase, "jre/lib/rt.jar");
+    return runtimeJar.exists() ? runtimeJar : null;
+  } catch (IOException e) {
+    throw new RuntimeException(e);
+  }
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife-runtime/gradle.properties b/butterknife-runtime/gradle.properties
new file mode 100644
index 00000000..db9751f9
--- /dev/null
+++ b/butterknife-runtime/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=butterknife-runtime
+POM_NAME=ButterKnife Runtime
+POM_PACKAGING=aar
diff --git a/butterknife-runtime/src/androidTest/java/butterknife/ViewCollectionsTest.java b/butterknife-runtime/src/androidTest/java/butterknife/ViewCollectionsTest.java
new file mode 100644
index 00000000..4694c3f9
--- /dev/null
+++ b/butterknife-runtime/src/androidTest/java/butterknife/ViewCollectionsTest.java
@@ -0,0 +1,206 @@
+package butterknife;
+
+import android.content.Context;
+import android.util.Property;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import java.util.List;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.Arrays.asList;
+
+public class ViewCollectionsTest {
+  private static final Property<View, Boolean> PROPERTY_ENABLED =
+      new Property<View, Boolean>(Boolean.class, "enabled") {
+        @Override public Boolean get(View view) {
+          return view.isEnabled();
+        }
+
+        @Override public void set(View view, Boolean enabled) {
+          view.setEnabled(enabled);
+        }
+      };
+  private static final Setter<View, Boolean> SETTER_ENABLED =
+      (view, value, index) -> view.setEnabled(value);
+  private static final Action<View> ACTION_DISABLE = (view, index) -> view.setEnabled(false);
+  private static final Action<View> ACTION_ZERO_ALPHA = (view, index) -> view.setAlpha(0f);
+
+  private final Context context = InstrumentationRegistry.getContext();
+
+  @Test public void propertyAppliedToView() {
+    View view = new View(context);
+    assertThat(view.isEnabled()).isTrue();
+
+    ViewCollections.set(view, PROPERTY_ENABLED, false);
+    assertThat(view.isEnabled()).isFalse();
+  }
+
+  @Test public void propertyAppliedToEveryViewInList() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    List<View> views = asList(view1, view2, view3);
+    ViewCollections.set(views, PROPERTY_ENABLED, false);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+
+  @Test public void propertyAppliedToEveryViewInArray() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    View[] views = new View[] { view1, view2, view3 };
+    ViewCollections.set(views, PROPERTY_ENABLED, false);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+
+  @Test public void actionAppliedToView() {
+    View view = new View(context);
+    assertThat(view.isEnabled()).isTrue();
+
+    ViewCollections.run(view, ACTION_DISABLE);
+
+    assertThat(view.isEnabled()).isFalse();
+  }
+
+  @Test public void actionsAppliedToView() {
+    View view = new View(context);
+    assertThat(view.isEnabled()).isTrue();
+    assertThat(view.getAlpha()).isEqualTo(1f);
+
+    ViewCollections.run(view, ACTION_DISABLE, ACTION_ZERO_ALPHA);
+    assertThat(view.isEnabled()).isFalse();
+    assertThat(view.getAlpha()).isEqualTo(0f);
+  }
+
+  @Test public void actionAppliedToEveryViewInList() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    List<View> views = asList(view1, view2, view3);
+    ViewCollections.run(views, ACTION_DISABLE);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+
+  @Test public void actionAppliedToEveryViewInArray() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    View[] views = new View[] { view1, view2, view3 };
+    ViewCollections.run(views, ACTION_DISABLE);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+
+  @Test public void actionsAppliedToEveryViewInList() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+    assertThat(view1.getAlpha()).isEqualTo(1f);
+    assertThat(view2.getAlpha()).isEqualTo(1f);
+    assertThat(view3.getAlpha()).isEqualTo(1f);
+
+    List<View> views = asList(view1, view2, view3);
+    ViewCollections.run(views, ACTION_DISABLE, ACTION_ZERO_ALPHA);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+    assertThat(view1.getAlpha()).isEqualTo(0f);
+    assertThat(view2.getAlpha()).isEqualTo(0f);
+    assertThat(view3.getAlpha()).isEqualTo(0f);
+  }
+
+  @Test public void actionsAppliedToEveryViewInArray() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+    assertThat(view1.getAlpha()).isEqualTo(1f);
+    assertThat(view2.getAlpha()).isEqualTo(1f);
+    assertThat(view3.getAlpha()).isEqualTo(1f);
+
+    View[] views = new View[] { view1, view2, view3 };
+    ViewCollections.run(views, ACTION_DISABLE, ACTION_ZERO_ALPHA);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+    assertThat(view1.getAlpha()).isEqualTo(0f);
+    assertThat(view2.getAlpha()).isEqualTo(0f);
+    assertThat(view3.getAlpha()).isEqualTo(0f);
+  }
+
+  @Test public void setterAppliedToView() {
+    View view = new View(context);
+    assertThat(view.isEnabled()).isTrue();
+
+    ViewCollections.set(view, SETTER_ENABLED, false);
+
+    assertThat(view.isEnabled()).isFalse();
+  }
+
+  @Test public void setterAppliedToEveryViewInList() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    List<View> views = asList(view1, view2, view3);
+    ViewCollections.set(views, SETTER_ENABLED, false);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+
+  @Test public void setterAppliedToEveryViewInArray() {
+    View view1 = new View(context);
+    View view2 = new View(context);
+    View view3 = new View(context);
+    assertThat(view1.isEnabled()).isTrue();
+    assertThat(view2.isEnabled()).isTrue();
+    assertThat(view3.isEnabled()).isTrue();
+
+    View[] views = new View[] { view1, view2, view3 };
+    ViewCollections.set(views, SETTER_ENABLED, false);
+
+    assertThat(view1.isEnabled()).isFalse();
+    assertThat(view2.isEnabled()).isFalse();
+    assertThat(view3.isEnabled()).isFalse();
+  }
+}
diff --git a/butterknife-runtime/src/androidTest/java/butterknife/internal/UtilsTest.java b/butterknife-runtime/src/androidTest/java/butterknife/internal/UtilsTest.java
new file mode 100644
index 00000000..2470e710
--- /dev/null
+++ b/butterknife-runtime/src/androidTest/java/butterknife/internal/UtilsTest.java
@@ -0,0 +1,47 @@
+package butterknife.internal;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class UtilsTest {
+  @Test public void finderThrowsNiceError() {
+    Context context = InstrumentationRegistry.getContext();
+    View view = new View(context);
+    try {
+      Utils.findRequiredView(view, android.R.id.button1, "yo mama");
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Required view 'button1' with ID "
+          + android.R.id.button1
+          + " for yo mama was not found. If this view is optional add '@Nullable' (fields) or '@Optional' (methods) annotation.");
+    }
+  }
+
+  @Test public void finderThrowsLessNiceErrorInEditMode() {
+    Context context = InstrumentationRegistry.getContext();
+    View view = new EditModeView(context);
+    try {
+      Utils.findRequiredView(view, android.R.id.button1, "yo mama");
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Required view '<unavailable while editing>' "
+          + "with ID " + android.R.id.button1
+          + " for yo mama was not found. If this view is optional add '@Nullable' (fields) or '@Optional' (methods) annotation.");
+    }
+  }
+
+  static final class EditModeView extends View {
+    EditModeView(Context context) {
+      super(context);
+    }
+
+    @Override public boolean isInEditMode() {
+      return true;
+    }
+  }
+}
diff --git a/butterknife-runtime/src/main/AndroidManifest.xml b/butterknife-runtime/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..e116347b
--- /dev/null
+++ b/butterknife-runtime/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="butterknife.runtime"/>
diff --git a/butterknife-runtime/src/main/java/butterknife/Action.java b/butterknife-runtime/src/main/java/butterknife/Action.java
new file mode 100644
index 00000000..596f3572
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/Action.java
@@ -0,0 +1,11 @@
+package butterknife;
+
+import android.view.View;
+import androidx.annotation.NonNull;
+import androidx.annotation.UiThread;
+
+/** An action that can be applied to a list of views. */
+public interface Action<T extends View> {
+  /** Apply the action on the {@code view} which is at {@code index} in the list. */
+  @UiThread void apply(@NonNull T view, int index);
+}
diff --git a/butterknife-runtime/src/main/java/butterknife/Setter.java b/butterknife-runtime/src/main/java/butterknife/Setter.java
new file mode 100644
index 00000000..abecb72f
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/Setter.java
@@ -0,0 +1,12 @@
+package butterknife;
+
+import android.view.View;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+
+/** A setter that can apply a value to a list of views. */
+public interface Setter<T extends View, V> {
+  /** Set the {@code value} on the {@code view} which is at {@code index} in the list. */
+  @UiThread void set(@NonNull T view, @Nullable V value, int index);
+}
diff --git a/butterknife-runtime/src/main/java/butterknife/Unbinder.java b/butterknife-runtime/src/main/java/butterknife/Unbinder.java
new file mode 100644
index 00000000..0b477534
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/Unbinder.java
@@ -0,0 +1,10 @@
+package butterknife;
+
+import androidx.annotation.UiThread;
+
+/** An unbinder contract that will unbind views when called. */
+public interface Unbinder {
+  @UiThread void unbind();
+
+  Unbinder EMPTY = () -> { };
+}
diff --git a/butterknife-runtime/src/main/java/butterknife/ViewCollections.java b/butterknife-runtime/src/main/java/butterknife/ViewCollections.java
new file mode 100644
index 00000000..9a4c1cf8
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/ViewCollections.java
@@ -0,0 +1,124 @@
+package butterknife;
+
+import android.util.Property;
+import android.view.View;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import java.util.List;
+
+/** Convenience methods for working with view collections. */
+public final class ViewCollections {
+  /** Apply the specified {@code actions} across the {@code list} of views. */
+  @UiThread
+  @SafeVarargs public static <T extends View> void run(@NonNull List<T> list,
+      @NonNull Action<? super T>... actions) {
+    for (int i = 0, count = list.size(); i < count; i++) {
+      for (Action<? super T> action : actions) {
+        action.apply(list.get(i), i);
+      }
+    }
+  }
+
+  /** Apply the specified {@code actions} across the {@code array} of views. */
+  @UiThread
+  @SafeVarargs public static <T extends View> void run(@NonNull T[] array,
+      @NonNull Action<? super T>... actions) {
+    for (int i = 0, count = array.length; i < count; i++) {
+      for (Action<? super T> action : actions) {
+        action.apply(array[i], i);
+      }
+    }
+  }
+
+  /** Apply the specified {@code action} across the {@code list} of views. */
+  @UiThread
+  public static <T extends View> void run(@NonNull List<T> list,
+      @NonNull Action<? super T> action) {
+    for (int i = 0, count = list.size(); i < count; i++) {
+      action.apply(list.get(i), i);
+    }
+  }
+
+  /** Apply the specified {@code action} across the {@code array} of views. */
+  @UiThread
+  public static <T extends View> void run(@NonNull T[] array, @NonNull Action<? super T> action) {
+    for (int i = 0, count = array.length; i < count; i++) {
+      action.apply(array[i], i);
+    }
+  }
+
+  /** Apply {@code actions} to {@code view}. */
+  @UiThread
+  @SafeVarargs public static <T extends View> void run(@NonNull T view,
+      @NonNull Action<? super T>... actions) {
+    for (Action<? super T> action : actions) {
+      action.apply(view, 0);
+    }
+  }
+
+  /** Apply {@code action} to {@code view}. */
+  @UiThread
+  public static <T extends View> void run(@NonNull T view, @NonNull Action<? super T> action) {
+    action.apply(view, 0);
+  }
+
+  /** Set the {@code value} using the specified {@code setter} across the {@code list} of views. */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull List<T> list,
+      @NonNull Setter<? super T, V> setter, @Nullable V value) {
+    for (int i = 0, count = list.size(); i < count; i++) {
+      setter.set(list.get(i), value, i);
+    }
+  }
+
+  /** Set the {@code value} using the specified {@code setter} across the {@code array} of views. */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull T[] array,
+      @NonNull Setter<? super T, V> setter, @Nullable V value) {
+    for (int i = 0, count = array.length; i < count; i++) {
+      setter.set(array[i], value, i);
+    }
+  }
+
+  /** Set {@code value} on {@code view} using {@code setter}. */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull T view,
+      @NonNull Setter<? super T, V> setter, @Nullable V value) {
+    setter.set(view, value, 0);
+  }
+
+  /**
+   * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
+   */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull List<T> list,
+      @NonNull Property<? super T, V> setter, @Nullable V value) {
+    //noinspection ForLoopReplaceableByForEach
+    for (int i = 0, count = list.size(); i < count; i++) {
+      setter.set(list.get(i), value);
+    }
+  }
+
+  /**
+   * Apply the specified {@code value} across the {@code array} of views using the {@code property}.
+   */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull T[] array,
+      @NonNull Property<? super T, V> setter, @Nullable V value) {
+    //noinspection ForLoopReplaceableByForEach
+    for (int i = 0, count = array.length; i < count; i++) {
+      setter.set(array[i], value);
+    }
+  }
+
+  /** Apply {@code value} to {@code view} using {@code property}. */
+  @UiThread
+  public static <T extends View, V> void set(@NonNull T view,
+      @NonNull Property<? super T, V> setter, @Nullable V value) {
+    setter.set(view, value);
+  }
+
+  private ViewCollections() {
+  }
+}
diff --git a/butterknife-runtime/src/main/java/butterknife/internal/DebouncingOnClickListener.java b/butterknife-runtime/src/main/java/butterknife/internal/DebouncingOnClickListener.java
new file mode 100644
index 00000000..b1de399e
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/internal/DebouncingOnClickListener.java
@@ -0,0 +1,23 @@
+package butterknife.internal;
+
+import android.view.View;
+
+/**
+ * A {@linkplain View.OnClickListener click listener} that debounces multiple clicks posted in the
+ * same frame. A click on one button disables all buttons for that frame.
+ */
+public abstract class DebouncingOnClickListener implements View.OnClickListener {
+  static boolean enabled = true;
+
+  private static final Runnable ENABLE_AGAIN = () -> enabled = true;
+
+  @Override public final void onClick(View v) {
+    if (enabled) {
+      enabled = false;
+      v.post(ENABLE_AGAIN);
+      doClick(v);
+    }
+  }
+
+  public abstract void doClick(View v);
+}
diff --git a/butterknife/src/main/java/butterknife/ImmutableViewList.java b/butterknife-runtime/src/main/java/butterknife/internal/ImmutableList.java
similarity index 71%
rename from butterknife/src/main/java/butterknife/ImmutableViewList.java
rename to butterknife-runtime/src/main/java/butterknife/internal/ImmutableList.java
index 399a3671..35129842 100644
--- a/butterknife/src/main/java/butterknife/ImmutableViewList.java
+++ b/butterknife-runtime/src/main/java/butterknife/internal/ImmutableList.java
@@ -1,6 +1,5 @@
-package butterknife;
+package butterknife.internal;
 
-import android.view.View;
 import java.util.AbstractList;
 import java.util.RandomAccess;
 
@@ -8,10 +7,10 @@
  * An immutable list of views which is lighter than {@code
  * Collections.unmodifiableList(new ArrayList<>(Arrays.asList(foo, bar)))}.
  */
-final class ImmutableViewList<T extends View> extends AbstractList<T> implements RandomAccess {
+final class ImmutableList<T> extends AbstractList<T> implements RandomAccess {
   private final T[] views;
 
-  ImmutableViewList(T[] views) {
+  ImmutableList(T[] views) {
     this.views = views;
   }
 
@@ -24,7 +23,7 @@
   }
 
   @Override public boolean contains(Object o) {
-    for (View view : views) {
+    for (T view : views) {
       if (view == o) {
         return true;
       }
diff --git a/butterknife-runtime/src/main/java/butterknife/internal/Utils.java b/butterknife-runtime/src/main/java/butterknife/internal/Utils.java
new file mode 100644
index 00000000..9032ad76
--- /dev/null
+++ b/butterknife-runtime/src/main/java/butterknife/internal/Utils.java
@@ -0,0 +1,142 @@
+package butterknife.internal;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.util.TypedValue;
+import android.view.View;
+import androidx.annotation.AttrRes;
+import androidx.annotation.DimenRes;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.IdRes;
+import androidx.annotation.UiThread;
+import androidx.core.content.ContextCompat;
+import androidx.core.graphics.drawable.DrawableCompat;
+import java.util.Arrays;
+import java.util.List;
+
+@SuppressWarnings("WeakerAccess") // Used by generated code.
+public final class Utils {
+  private static final TypedValue VALUE = new TypedValue();
+
+  @UiThread // Implicit synchronization for use of shared resource VALUE.
+  public static Drawable getTintedDrawable(Context context,
+      @DrawableRes int id, @AttrRes int tintAttrId) {
+    boolean attributeFound = context.getTheme().resolveAttribute(tintAttrId, VALUE, true);
+    if (!attributeFound) {
+      throw new Resources.NotFoundException("Required tint color attribute with name "
+          + context.getResources().getResourceEntryName(tintAttrId)
+          + " and attribute ID "
+          + tintAttrId
+          + " was not found.");
+    }
+
+    Drawable drawable = ContextCompat.getDrawable(context, id);
+    drawable = DrawableCompat.wrap(drawable.mutate());
+    int color = ContextCompat.getColor(context, VALUE.resourceId);
+    DrawableCompat.setTint(drawable, color);
+    return drawable;
+  }
+
+  @UiThread // Implicit synchronization for use of shared resource VALUE.
+  public static float getFloat(Context context, @DimenRes int id) {
+    TypedValue value = VALUE;
+    context.getResources().getValue(id, value, true);
+    if (value.type == TypedValue.TYPE_FLOAT) {
+      return value.getFloat();
+    }
+    throw new Resources.NotFoundException("Resource ID #0x" + Integer.toHexString(id)
+        + " type #0x" + Integer.toHexString(value.type) + " is not valid");
+  }
+
+  @SafeVarargs
+  public static <T> T[] arrayFilteringNull(T... views) {
+    int end = 0;
+    int length = views.length;
+    for (int i = 0; i < length; i++) {
+      T view = views[i];
+      if (view != null) {
+        views[end++] = view;
+      }
+    }
+    return end == length
+        ? views
+        : Arrays.copyOfRange(views, 0, end);
+  }
+
+  @SafeVarargs
+  public static <T> List<T> listFilteringNull(T... views) {
+    return new ImmutableList<>(arrayFilteringNull(views));
+  }
+
+  public static <T> T findOptionalViewAsType(View source, @IdRes int id, String who,
+      Class<T> cls) {
+    View view = source.findViewById(id);
+    return castView(view, id, who, cls);
+  }
+
+  public static View findRequiredView(View source, @IdRes int id, String who) {
+    View view = source.findViewById(id);
+    if (view != null) {
+      return view;
+    }
+    String name = getResourceEntryName(source, id);
+    throw new IllegalStateException("Required view '"
+        + name
+        + "' with ID "
+        + id
+        + " for "
+        + who
+        + " was not found. If this view is optional add '@Nullable' (fields) or '@Optional'"
+        + " (methods) annotation.");
+  }
+
+  public static <T> T findRequiredViewAsType(View source, @IdRes int id, String who,
+      Class<T> cls) {
+    View view = findRequiredView(source, id, who);
+    return castView(view, id, who, cls);
+  }
+
+  public static <T> T castView(View view, @IdRes int id, String who, Class<T> cls) {
+    try {
+      return cls.cast(view);
+    } catch (ClassCastException e) {
+      String name = getResourceEntryName(view, id);
+      throw new IllegalStateException("View '"
+          + name
+          + "' with ID "
+          + id
+          + " for "
+          + who
+          + " was of the wrong type. See cause for more info.", e);
+    }
+  }
+
+  public static <T> T castParam(Object value, String from, int fromPos, String to, int toPos,
+      Class<T> cls) {
+    try {
+      return cls.cast(value);
+    } catch (ClassCastException e) {
+      throw new IllegalStateException("Parameter #"
+          + (fromPos + 1)
+          + " of method '"
+          + from
+          + "' was of the wrong type for parameter #"
+          + (toPos + 1)
+          + " of method '"
+          + to
+          + "'. See cause for more info.", e);
+    }
+  }
+
+  private static String getResourceEntryName(View view, @IdRes int id) {
+    if (view.isInEditMode()) {
+      return "<unavailable while editing>";
+    }
+    return view.getContext().getResources().getResourceEntryName(id);
+  }
+
+  private Utils() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindAnimTest.java b/butterknife-runtime/src/test/java/butterknife/BindAnimTest.java
new file mode 100644
index 00000000..34e4a776
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindAnimTest.java
@@ -0,0 +1,30 @@
+package butterknife;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Test;
+
+import javax.tools.JavaFileObject;
+
+import butterknife.compiler.ButterKnifeProcessor;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class BindAnimTest {
+  @Test public void typeMustBeAnimation() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindAnim;\n"
+        + "public class Test {\n"
+        + "  @BindAnim(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindAnim field type must be 'Animation'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindArrayTest.java b/butterknife-runtime/src/test/java/butterknife/BindArrayTest.java
new file mode 100644
index 00000000..36eec904
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindArrayTest.java
@@ -0,0 +1,82 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindArrayTest {
+  @Test public void typedArray() throws Exception {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindArray;\n"
+        + "import android.content.res.TypedArray;\n"
+        + "public class Test {\n"
+        + "  @BindArray(1) TypedArray one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.obtainTypedArray(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void typeMustBeSupported() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindArray;\n"
+        + "public class Test {\n"
+        + "  @BindArray(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindArray field type must be one of: String[], int[], CharSequence[], "
+                + "android.content.res.TypedArray. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindBitmapTest.java b/butterknife-runtime/src/test/java/butterknife/BindBitmapTest.java
new file mode 100644
index 00000000..4a1e42a6
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindBitmapTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindBitmapTest {
+  @Test public void typeMustBeBitmap() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindBitmap;\n"
+        + "public class Test {\n"
+        + "  @BindBitmap(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindBitmap field type must be 'Bitmap'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindBoolTest.java b/butterknife-runtime/src/test/java/butterknife/BindBoolTest.java
new file mode 100644
index 00000000..e32031cb
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindBoolTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindBoolTest {
+  @Test public void typeMustBeBoolean() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindBool;\n"
+        + "public class Test {\n"
+        + "  @BindBool(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindBool field type must be 'boolean'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindColorTest.java b/butterknife-runtime/src/test/java/butterknife/BindColorTest.java
new file mode 100644
index 00000000..d6f83f3e
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindColorTest.java
@@ -0,0 +1,128 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindColorTest {
+  @Test public void simpleIntSdk23() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class Test {\n"
+        + "  @BindColor(1) int one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    target.one = context.getColor(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.minSdk=23")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void simpleColorStateListSdk23() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.content.res.ColorStateList;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class Test {\n"
+        + "  @BindColor(1) ColorStateList one;\n"
+        +"}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    target.one = context.getColorStateList(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.minSdk=23")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void typeMustBeIntOrColorStateList() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class Test {\n"
+        + "  @BindColor(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindColor field type must be 'int' or 'ColorStateList'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindDimenTest.java b/butterknife-runtime/src/test/java/butterknife/BindDimenTest.java
new file mode 100644
index 00000000..0b0d235a
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindDimenTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindDimenTest {
+  @Test public void typeMustBeIntOrFloat() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindDimen;\n"
+        + "public class Test {\n"
+        + "  @BindDimen(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindDimen field type must be 'int' or 'float'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindDrawableTest.java b/butterknife-runtime/src/test/java/butterknife/BindDrawableTest.java
new file mode 100644
index 00000000..ebed6890
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindDrawableTest.java
@@ -0,0 +1,130 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindDrawableTest {
+  @Test public void simpleSdk21() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.graphics.drawable.Drawable;\n"
+        + "import butterknife.BindDrawable;\n"
+        + "public class Test {\n"
+        + "  @BindDrawable(1) Drawable one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    target.one = context.getDrawable(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.minSdk=21")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void withTint() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.graphics.drawable.Drawable;\n"
+        + "import butterknife.BindDrawable;\n"
+        + "public class Test {\n"
+        + "  @BindDrawable(value = 1, tint = 2) Drawable one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    target.one = Utils.getTintedDrawable(context, 1, 2);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void typeMustBeDrawable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindDrawable;\n"
+        + "public class Test {\n"
+        + "  @BindDrawable(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindDrawable field type must be 'Drawable'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindFloatTest.java b/butterknife-runtime/src/test/java/butterknife/BindFloatTest.java
new file mode 100644
index 00000000..56980458
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindFloatTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindFloatTest {
+  @Test public void typeMustBeFloat() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindFloat;\n"
+        + "public class Test {\n"
+        + "  @BindFloat(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindFloat field type must be 'float'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindFontTest.java b/butterknife-runtime/src/test/java/butterknife/BindFontTest.java
new file mode 100644
index 00000000..6374c5a6
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindFontTest.java
@@ -0,0 +1,152 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class BindFontTest {
+  @Test public void simpleIntSdk26() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.graphics.Typeface;\n"
+        + "import butterknife.BindFont;\n"
+        + "public class Test {\n"
+        + "  @BindFont(1) Typeface one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.getFont(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.minSdk=26")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void styleSdk26() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.graphics.Typeface;\n"
+        + "import butterknife.BindFont;\n"
+        + "public class Test {\n"
+        + "  @BindFont(value = 1, style = Typeface.BOLD) Typeface one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.graphics.Typeface;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = Typeface.create(res.getFont(1), Typeface.BOLD);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.minSdk=26")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void typeMustBeTypeface() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindFont;\n"
+        + "public class Test {\n"
+        + "  @BindFont(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindFont field type must be 'Typeface'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void styleMustBeValid() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.graphics.Typeface;\n"
+        + "import butterknife.BindFont;\n"
+        + "public class Test {\n"
+        + "  @BindFont(value = 1, style = 5) Typeface one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindFont style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (test.Test.one)")
+        .in(source).onLine(5);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindIntTest.java b/butterknife-runtime/src/test/java/butterknife/BindIntTest.java
new file mode 100644
index 00000000..0b7ef2ca
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindIntTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindIntTest {
+  @Test public void typeMustBeInt() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindInt;\n"
+        + "public class Test {\n"
+        + "  @BindInt(1) String one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindInt field type must be 'int'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindStringTest.java b/butterknife-runtime/src/test/java/butterknife/BindStringTest.java
new file mode 100644
index 00000000..27d68879
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindStringTest.java
@@ -0,0 +1,27 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class BindStringTest {
+  @Test public void typeMustBeString() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindString;\n"
+        + "public class Test {\n"
+        + "  @BindString(1) boolean one;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindString field type must be 'String'. (test.Test.one)")
+        .in(source).onLine(4);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindViewTest.java b/butterknife-runtime/src/test/java/butterknife/BindViewTest.java
new file mode 100644
index 00000000..76bae63c
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindViewTest.java
@@ -0,0 +1,929 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import javax.tools.StandardLocation;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+public class BindViewTest {
+  @Test public void bindingViewNonDebuggable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = source.findViewById(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.debuggable=false")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingViewSubclassNonDebuggable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.widget.TextView;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) TextView thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = (TextView) source.findViewById(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.debuggable=false")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingGeneratedView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindView;\n"
+        + "@PerformGeneration\n"
+        + "public class Test {\n"
+        + "    @BindView(1) GeneratedView thing;\n"
+        + "}"
+    );
+
+    // w/o the GeneratingProcessor it can't find `class GeneratedView`
+    assertAbout(javaSources()).that(ImmutableList.of(source, TestGeneratingProcessor.ANNOTATION))
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("cannot find symbol");
+
+    // now the GeneratingProcessor should let it compile
+    assertAbout(javaSources()).that(ImmutableList.of(source, TestGeneratingProcessor.ANNOTATION))
+        .processedWith(new ButterKnifeProcessor(), new TestGeneratingProcessor("GeneratedView",
+            "package test;",
+            "import android.content.Context;",
+            "import android.view.View;",
+            "public class GeneratedView extends View {",
+            "  public GeneratedView(Context context) {",
+            "    super(context);",
+            "  }",
+            "}"
+        ))
+        .compilesWithoutError()
+        .withNoteContaining("@BindView field with unresolved type (GeneratedView)").and()
+        .withNoteContaining("must elsewhere be generated as a View or interface").and()
+        .and()
+        .generatesFileNamed(StandardLocation.CLASS_OUTPUT, "test", "Test_ViewBinding.class");
+  }
+
+  @Test public void bindingViewFinalClass() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public final class Test {\n"
+        + "    @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public final class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingViewFinalClassWithBaseClass() {
+    JavaFileObject baseSource = JavaFileObjects.forSourceString("test.Base", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Base {\n"
+        + "    @BindView(1) View thing;\n"
+        + "}"
+    );
+    JavaFileObject testSource = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public final class Test extends Base {\n"
+        + "    @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingBaseSource = JavaFileObjects.forSourceString("test/Base_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Base_ViewBinding implements Unbinder {\n"
+        + "  private Base target;\n"
+        + "  @UiThread\n"
+        + "  public Base_ViewBinding(Base target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Base target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingTestSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public final class Test_ViewBinding extends Base_ViewBinding {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null\n"
+        + "    target.thing = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(baseSource, testSource))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingBaseSource, bindingTestSource);
+  }
+
+  @Test public void bindingViewUppercasePackageName() {
+    JavaFileObject source = JavaFileObjects.forSourceString("com.Example.Test", ""
+        + "package com.Example;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package com.Example;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingInterface() throws Exception {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    interface TestInterface {}\n"
+        + "    @BindView(1) TestInterface thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredViewAsType(source, 1, \"field 'thing'\", Test.TestInterface.class);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void genericType() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.widget.EditText;\n"
+        + "import android.widget.TextView;\n"
+        + "import butterknife.BindView;\n"
+        + "class Test<T extends TextView> {\n"
+        + "    @BindView(1) T thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredViewAsType(source, 1, \"field 'thing'\", TextView.class);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        // found raw type: test.Test
+        //   missing type arguments for generic class test.Test<T>
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void oneFindPerId() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View thing1;\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"field 'thing1' and method 'doStuff'\");\n"
+        + "    target.thing1 = view;\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing1 = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void oneFindPerIdWithCast() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.widget.Button;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) Button thing1;\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.Button;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"field 'thing1' and method 'doStuff'\");\n"
+        + "    target.thing1 = Utils.castView(view, 1, \"field 'thing1'\", Button.class);\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing1 = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void fieldVisibility() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) public View thing1;\n"
+        + "  @BindView(2) View thing2;\n"
+        + "  @BindView(3) protected View thing3;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings();
+  }
+
+  @Test public void nullable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @interface Nullable {}\n"
+        + "  @Nullable @BindView(1) View view;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.view = source.findViewById(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void superclass() {
+    JavaFileObject source1 = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View view;\n"
+        + "}"
+    );
+
+    JavaFileObject source2 = JavaFileObjects.forSourceString("test.TestOne", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class TestOne extends Test {\n"
+        + "  @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject source3 = JavaFileObjects.forSourceString("test.TestTwo", ""
+        + "package test;\n"
+        + "public class TestTwo extends Test {\n"
+        + "}"
+    );
+
+    JavaFileObject binding1Source = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.view = Utils.findRequiredView(source, 1, \"field 'view'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject binding2Source = JavaFileObjects.forSourceString("test/TestOne_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class TestOne_ViewBinding extends Test_ViewBinding {\n"
+        + "  private TestOne target;\n"
+        + "  @UiThread\n"
+        + "  public TestOne_ViewBinding(TestOne target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    TestOne target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source1, source2, source3))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(binding1Source, binding2Source);
+  }
+
+  @Test public void genericSuperclass() {
+    JavaFileObject source1 = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test<T> {\n"
+        + "  @BindView(1) View view;\n"
+        + "}"
+    );
+
+    JavaFileObject source2 = JavaFileObjects.forSourceString("test.TestOne", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class TestOne extends Test<String> {\n"
+        + "  @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    JavaFileObject source3 = JavaFileObjects.forSourceString("test.TestTwo", ""
+        + "package test;\n"
+        + "public class TestTwo extends Test<Object> {\n"
+        + "}"
+    );
+
+    JavaFileObject binding1Source = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.view = Utils.findRequiredView(source, 1, \"field 'view'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject binding2Source = JavaFileObjects.forSourceString("test/TestOne_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class TestOne_ViewBinding extends Test_ViewBinding {\n"
+        + "  private TestOne target;\n"
+        + "  @UiThread\n"
+        + "  public TestOne_ViewBinding(TestOne target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.findRequiredView(source, 1, \"field 'thing'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    TestOne target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null\n"
+        + "    target.thing = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source1, source2, source3))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        // found raw type: test.Test
+        //   missing type arguments for generic class test.Test<T>
+        .compilesWithoutError()
+        .and()
+        .generatesSources(binding1Source, binding2Source);
+  }
+
+  @Test public void failsInJavaPackage() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package java.test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindView-annotated class incorrectly in Java framework package. (java.test.Test)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsInAndroidPackage() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package android.test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindView-annotated class incorrectly in Android framework package. (android.test.Test)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfInPrivateClass() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  private static class Inner {\n"
+        + "    @BindView(1) View thing;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindView fields may not be contained in private classes. (test.Test.Inner.thing)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfNotView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) String thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindView fields must extend from View or be an interface. (test.Test.thing)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsIfInInterface() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public interface Test {\n"
+        + "    @BindView(1) View thing = null;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindView fields may only be contained in classes. (test.Test.thing)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsIfPrivate() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) private View thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindView fields must not be private or static. (test.Test.thing)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfStatic() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) static View thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindView fields must not be private or static. (test.Test.thing)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void duplicateBindingFails() throws Exception {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test {\n"
+        + "    @BindView(1) View thing1;\n"
+        + "    @BindView(1) View thing2;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Attempt to use @BindView for an already bound ID 1 on 'thing1'. (test.Test.thing2)")
+        .in(source).onLine(6);
+  }
+
+  @Test public void failsOptionalRootViewBinding() throws Exception {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.OnClick;\n"
+        + "import butterknife.Optional;\n"
+        + "public class Test extends View {\n"
+        + "  @Optional @OnClick void doStuff() {}\n"
+        + "  public Test(Context context) {\n"
+        + "    super(context);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource())
+        .that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "ID-free binding must not be annotated with @Optional. (test.Test.doStuff)")
+        .in(source)
+        .onLine(7);
+  }
+
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/BindViewsTest.java b/butterknife-runtime/src/test/java/butterknife/BindViewsTest.java
new file mode 100644
index 00000000..db927bef
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/BindViewsTest.java
@@ -0,0 +1,600 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import javax.tools.StandardLocation;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+public class BindViewsTest {
+  @Test public void bindingArrayWithGenerics() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test<T extends View> {\n"
+        + "    @BindViews({1, 2, 3}) T[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        Utils.findRequiredView(source, 1, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, 2, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, 3, \"field 'thing'\"));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        // found raw type: test.Test
+        //   missing type arguments for generic class test.Test<T>
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingArrayWithCast() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.widget.TextView;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "    @BindViews({1, 2, 3}) TextView[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        Utils.findRequiredViewAsType(source, 1, \"field 'thing'\", TextView.class), \n"
+        + "        Utils.findRequiredViewAsType(source, 2, \"field 'thing'\", TextView.class), \n"
+        + "        Utils.findRequiredViewAsType(source, 3, \"field 'thing'\", TextView.class));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingArrayNonDebuggable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "    @BindViews({1, 2, 3}) View[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        source.findViewById(1), \n"
+        + "        source.findViewById(2), \n"
+        + "        source.findViewById(3));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.debuggable=false")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingArrayWithCastNonDebuggable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.widget.TextView;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "    @BindViews({1, 2, 3}) TextView[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        (TextView) source.findViewById(1), \n"
+        + "        (TextView) source.findViewById(2), \n"
+        + "        (TextView) source.findViewById(3));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.debuggable=false")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingGeneratedView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "@PerformGeneration\n"
+        + "public class Test {\n"
+        + "    @BindViews({1, 2}) List<GeneratedView> things;\n"
+        + "}"
+    );
+
+    // w/o the GeneratingProcessor it can't find `class GeneratedView`
+    assertAbout(javaSources()).that(ImmutableList.of(source, TestGeneratingProcessor.ANNOTATION))
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("cannot find symbol");
+
+    // now the GeneratingProcessor should let it compile
+    assertAbout(javaSources()).that(ImmutableList.of(source, TestGeneratingProcessor.ANNOTATION))
+        .processedWith(new ButterKnifeProcessor(), new TestGeneratingProcessor("GeneratedView",
+            "package test;",
+            "import android.content.Context;",
+            "import android.view.View;",
+            "public class GeneratedView extends View {",
+            "  public GeneratedView(Context context) {",
+            "    super(context);",
+            "  }",
+            "}"
+        ))
+        .compilesWithoutError()
+        .withNoteContaining("@BindViews List or array with unresolved type (GeneratedView)").and()
+        .withNoteContaining("must elsewhere be generated as a View or interface").and()
+        .and()
+        .generatesFileNamed(StandardLocation.CLASS_OUTPUT, "test", "Test_ViewBinding.class");
+  }
+
+  @Test public void bindingListOfInterface() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "    interface TestInterface {}\n"
+        + "    @BindViews({1, 2, 3}) List<TestInterface> thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.listFilteringNull(\n"
+        + "        Utils.findRequiredViewAsType(source, 1, \"field 'thing'\", Test.TestInterface.class), \n"
+        + "        Utils.findRequiredViewAsType(source, 2, \"field 'thing'\", Test.TestInterface.class), \n"
+        + "        Utils.findRequiredViewAsType(source, 3, \"field 'thing'\", Test.TestInterface.class));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingListWithGenerics() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test<T extends View> {\n"
+        + "    @BindViews({1, 2, 3}) List<T> thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.listFilteringNull(\n"
+        + "        Utils.findRequiredView(source, 1, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, 2, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, 3, \"field 'thing'\"));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        // found raw type: test.Test
+        //   missing type arguments for generic class test.Test<T>
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void nullableList() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "    @interface Nullable {}\n"
+        + "    @Nullable @BindViews({1, 2, 3}) List<View> thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.listFilteringNull(\n"
+        + "        source.findViewById(1), \n"
+        + "        source.findViewById(2), \n"
+        + "        source.findViewById(3));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources( bindingSource);
+  }
+
+  @Test public void failsIfNoIds() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "  @BindViews({}) List<View> thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindViews must specify at least one ID. (test.Test.thing)")
+        .in(source).onLine(6);
+  }
+
+  @Test public void failsIfNoGenericType() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "  @BindViews(1) List thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindViews List must have a generic component. (test.Test.thing)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfUnsupportedCollection() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.Deque;\n"
+        + "public class Test {\n"
+        + "  @BindViews(1) Deque<View> thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindViews must be a List or array. (test.Test.thing)")
+        .in(source).onLine(6);
+  }
+
+  @Test public void failsIfGenericNotView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "  @BindViews(1) List<String> thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindViews List or array type must extend from View or be an interface. (test.Test.thing)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfArrayNotView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "  @BindViews(1) String[] thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@BindViews List or array type must extend from View or be an interface. (test.Test.thing)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsIfContainsDuplicateIds() throws Exception {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "import java.util.List;\n"
+        + "public class Test {\n"
+        + "    @BindViews({1, 1}) List<View> thing;\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@BindViews annotation contains duplicate ID 1. (test.Test.thing)")
+        .in(source).onLine(6);
+  }
+
+  @Test public void bindingArrayWithRScanner() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.R;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "    @BindViews({R.color.black, R.color.white}) View[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        Utils.findRequiredView(source, android.R.color.black, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, android.R.color.white, \"field 'thing'\"));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void bindingArrayWithMixedRAndLiteral() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.R;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindViews;\n"
+        + "public class Test {\n"
+        + "    @BindViews({R.color.black, 2, R.color.white}) View[] thing;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.thing = Utils.arrayFilteringNull(\n"
+        + "        Utils.findRequiredView(source, android.R.color.black, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, 2, \"field 'thing'\"), \n"
+        + "        Utils.findRequiredView(source, android.R.color.white, \"field 'thing'\"));\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.thing = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/ExtendActivityTest.java b/butterknife-runtime/src/test/java/butterknife/ExtendActivityTest.java
new file mode 100644
index 00000000..24c1a525
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/ExtendActivityTest.java
@@ -0,0 +1,120 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class ExtendActivityTest {
+  @Test public void onlyResources() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.app.Activity;"
+        + "import android.content.Context;"
+        + "import butterknife.BindBool;"
+        + "public class Test extends Activity {"
+        + "  @BindBool(1) boolean one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target);\n"
+        + "  }\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.getBoolean(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void views() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.app.Activity;"
+        + "import android.content.Context;"
+        + "import android.view.View;"
+        + "import butterknife.BindView;"
+        + "public class Test extends Activity {"
+        + "  @BindView(1) View one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target.getWindow().getDecorView());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.one = Utils.findRequiredView(source, 1, \"field 'one'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.one = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/ExtendDialogTest.java b/butterknife-runtime/src/test/java/butterknife/ExtendDialogTest.java
new file mode 100644
index 00000000..7f7c636b
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/ExtendDialogTest.java
@@ -0,0 +1,126 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class ExtendDialogTest {
+  @Test public void onlyResources() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.app.Dialog;"
+        + "import android.content.Context;"
+        + "import butterknife.BindBool;"
+        + "public class Test extends Dialog {"
+        + "  Test(Context context) {"
+        + "    super(context);"
+        + "  }"
+        + "  @BindBool(1) boolean one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target.getContext());\n"
+        + "  }\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.getBoolean(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void views() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.app.Dialog;"
+        + "import android.content.Context;"
+        + "import android.view.View;"
+        + "import butterknife.BindView;"
+        + "public class Test extends Dialog {"
+        + "  Test(Context context) {"
+        + "    super(context);"
+        + "  }"
+        + "  @BindView(1) View one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target.getWindow().getDecorView());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.one = Utils.findRequiredView(source, 1, \"field 'one'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.one = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/ExtendViewTest.java b/butterknife-runtime/src/test/java/butterknife/ExtendViewTest.java
new file mode 100644
index 00000000..c25d7d8c
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/ExtendViewTest.java
@@ -0,0 +1,125 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class ExtendViewTest {
+  @Test public void onlyResources() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.content.Context;"
+        + "import android.view.View;"
+        + "import butterknife.BindBool;"
+        + "public class Test extends View {"
+        + "  Test(Context context) {"
+        + "    super(context);"
+        + "  }"
+        + "  @BindBool(1) boolean one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "import java.lang.SuppressWarnings;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target.getContext());\n"
+        + "  }\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  @SuppressWarnings(\"ResourceType\")\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.getBoolean(1);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void views() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import android.content.Context;"
+        + "import android.view.View;"
+        + "import butterknife.BindView;"
+        + "public class Test extends View {"
+        + "  Test(Context context) {"
+        + "    super(context);"
+        + "  }"
+        + "  @BindView(1) View one;"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target);\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.one = Utils.findRequiredView(source, 1, \"field 'one'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.one = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnClickTest.java b/butterknife-runtime/src/test/java/butterknife/OnClickTest.java
new file mode 100644
index 00000000..d2df0551
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnClickTest.java
@@ -0,0 +1,412 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnClickTest {
+  @Test public void findOnlyCalledOnce() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View view;\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"field 'view' and method 'doStuff'\");\n"
+        + "    target.view = view;\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void methodCastsArgumentNonDebuggable() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.Button;\n"
+        + "import android.widget.TextView;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  interface TestInterface {}\n"
+        + "  @OnClick(0) void click0() {}\n"
+        + "  @OnClick(1) void click1(View view) {}\n"
+        + "  @OnClick(2) void click2(TextView view) {}\n"
+        + "  @OnClick(3) void click3(Button button) {}\n"
+        + "  @OnClick(4) void click4(TestInterface thing) {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.Button;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view0;\n"
+        + "  private View view1;\n"
+        + "  private View view2;\n"
+        + "  private View view3;\n"
+        + "  private View view4;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = source.findViewById(0);\n"
+        + "    view0 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.click0();\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = source.findViewById(1);\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.click1(p0);\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = source.findViewById(2);\n"
+        + "    view2 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.click2((TextView) p0);\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = source.findViewById(3);\n"
+        + "    view3 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.click3((Button) p0);\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = source.findViewById(4);\n"
+        + "    view4 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.click4((Test.TestInterface) p0);\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view0.setOnClickListener(null);\n"
+        + "    view0 = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "    view2.setOnClickListener(null);\n"
+        + "    view2 = null;\n"
+        + "    view3.setOnClickListener(null);\n"
+        + "    view3 = null;\n"
+        + "    view4.setOnClickListener(null);\n"
+        + "    view4 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing", "-Abutterknife.debuggable=false")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void optionalAndRequiredSkipsNullCheck() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.OnClick;\n"
+        + "import butterknife.Optional;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View view;\n"
+        + "  @Optional @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"field 'view'\");\n"
+        + "    target.view = view;\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void failsInJavaPackage() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package java.test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@OnClick-annotated class incorrectly in Java framework package. (java.test.Test)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsInAndroidPackage() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package android.test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@OnClick-annotated class incorrectly in Android framework package. (android.test.Test)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsIfHasReturnType() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1)\n"
+        + "  public String doStuff() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@OnClick methods must have a 'void' return type. (test.Test.doStuff)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfPrivateMethod() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1)\n"
+        + "  private void doStuff() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@OnClick methods must not be private or static. (test.Test.doStuff)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfStatic() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1)\n"
+        + "  public static void doStuff() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@OnClick methods must not be private or static. (test.Test.doStuff)")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfParameterNotView() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1)\n"
+        + "  public void doStuff(String thing) {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(""
+            + "Unable to match @OnClick method arguments. (test.Test.doStuff)\n"
+            + "  \n"
+            + "    Parameter #1: java.lang.String\n"
+            + "      did not match any listener parameters\n"
+            + "  \n"
+            + "  Methods may have up to 1 parameter(s):\n"
+            + "  \n"
+            + "    android.view.View\n"
+            + "  \n"
+            + "  These may be listed in any order but will be searched for from top to bottom.")
+        .in(source).onLine(5);
+  }
+
+  @Test public void failsIfMoreThanOneParameter() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1)\n"
+        + "  public void doStuff(View thing, View otherThing) {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@OnClick methods can have at most 1 parameter(s). (test.Test.doStuff)")
+        .in(source).onLine(6);
+  }
+
+  @Test public void failsIfInInterface() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public interface Test {\n"
+        + "  @OnClick(1)\n"
+        + "  void doStuff();\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@OnClick methods may only be contained in classes. (test.Test.doStuff)")
+        .in(source).onLine(3);
+  }
+
+  @Test public void failsIfHasDuplicateIds() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick({1, 2, 3, 1})\n"
+        + "  void doStuff() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@OnClick annotation for method contains duplicate ID 1. (test.Test.doStuff)")
+        .in(source).onLine(5);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnEditorActionTest.java b/butterknife-runtime/src/test/java/butterknife/OnEditorActionTest.java
new file mode 100644
index 00000000..7541a00c
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnEditorActionTest.java
@@ -0,0 +1,122 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnEditorActionTest {
+  @Test public void editorAction() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnEditorAction;\n"
+        + "public class Test {\n"
+        + "  @OnEditorAction(1) boolean doStuff() { return false; }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.KeyEvent;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((TextView) view).setOnEditorActionListener(new TextView.OnEditorActionListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onEditorAction(TextView p0, int p1, KeyEvent p2) {\n"
+        + "        return target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((TextView) view1).setOnEditorActionListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void defaultReturnValue() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnEditorAction;\n"
+        + "public class Test {\n"
+        + "  @OnEditorAction(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.KeyEvent;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((TextView) view).setOnEditorActionListener(new TextView.OnEditorActionListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onEditorAction(TextView p0, int p1, KeyEvent p2) {\n"
+        + "        target.doStuff();\n"
+        + "        return true;\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((TextView) view1).setOnEditorActionListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnFocusChangeTest.java b/butterknife-runtime/src/test/java/butterknife/OnFocusChangeTest.java
new file mode 100644
index 00000000..32bec043
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnFocusChangeTest.java
@@ -0,0 +1,64 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnFocusChangeTest {
+  @Test public void focusChange() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnFocusChange;\n"
+        + "public class Test {\n"
+        + "  @OnFocusChange(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    view.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n"
+        + "      @Override\n"
+        + "      public void onFocusChange(View p0, boolean p1) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view1.setOnFocusChangeListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnItemClickTest.java b/butterknife-runtime/src/test/java/butterknife/OnItemClickTest.java
new file mode 100644
index 00000000..31435325
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnItemClickTest.java
@@ -0,0 +1,418 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+/** This augments {@link OnClickTest} with tests that exercise callbacks with parameters. */
+public class OnItemClickTest {
+  @Test public void onItemClickBinding() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import butterknife.OnItemClick;"
+        + "public class Test {"
+        + "  @OnItemClick(1) void doStuff() {}"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void onItemClickBindingWithParameters() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemClick(1) void doStuff(\n"
+        + "    AdapterView<?> parent,\n"
+        + "    View view,\n"
+        + "    int position,\n"
+        + "    long id\n"
+        + "  ) {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff(p0, p1, p2, p3);\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void onItemClickBindingWithParameterSubset() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.ListView;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemClick(1) void doStuff(\n"
+        + "    ListView parent,\n"
+        + "    int position\n"
+        + "  ) {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import android.widget.ListView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff(Utils.castParam(p0, \"onItemClick\", 0, \"doStuff\", 0, ListView.class), p2);\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void onItemClickBindingWithParameterSubsetAndGenerics() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.ListView;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test<T extends ListView> {\n"
+        + "  @OnItemClick(1) void doStuff(\n"
+        + "    T parent,\n"
+        + "    int position\n"
+        + "  ) {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import android.widget.ListView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff(Utils.castParam(p0, \"onItemClick\", 0, \"doStuff\", 0, ListView.class)\n"
+        + "        , p2);\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        // found raw type: test.Test
+        //   missing type arguments for generic class test.Test<T>
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void onClickRootViewBinding() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.widget.ListView;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test extends ListView {\n"
+        + "  @OnItemClick void doStuff() {}\n"
+        + "  public Test(Context context) {\n"
+        + "    super(context);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View viewSource;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target);\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    viewSource = source;\n"
+        + "    ((AdapterView<?>) source).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) viewSource).setOnItemClickListener(null);\n"
+        + "    viewSource = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void onClickRootViewAnyTypeBinding() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemClick void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View viewSource;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    viewSource = source;\n"
+        + "    ((AdapterView<?>) source).setOnItemClickListener(new AdapterView.OnItemClickListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) viewSource).setOnItemClickListener(null);\n"
+        + "    viewSource = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void failsWithInvalidId() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemClick({1, -1}) void doStuff() {}\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining("@OnItemClick annotation contains invalid ID -1. (test.Test.doStuff)")
+        .in(source).onLine(4);
+  }
+
+  @Test public void failsWithInvalidParameterConfiguration() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import butterknife.OnItemClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemClick(1) void doStuff(\n"
+        + "    AdapterView<?> parent,\n"
+        + "    View view,\n"
+        + "    View whatIsThis\n"
+        + "  ) {}\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(""
+            + "Unable to match @OnItemClick method arguments. (test.Test.doStuff)\n"
+            + "  \n"
+            + "    Parameter #1: android.widget.AdapterView<?>\n"
+            + "      matched listener parameter #1: android.widget.AdapterView<?>\n"
+            + "  \n"
+            + "    Parameter #2: android.view.View\n"
+            + "      matched listener parameter #2: android.view.View\n"
+            + "  \n"
+            + "    Parameter #3: android.view.View\n"
+            + "      did not match any listener parameters\n"
+            + "  \n"
+            + "  Methods may have up to 4 parameter(s):\n"
+            + "  \n"
+            + "    android.widget.AdapterView<?>\n"
+            + "    android.view.View\n"
+            + "    int\n"
+            + "    long\n"
+            + "  \n"
+            + "  These may be listed in any order but will be searched for from top to bottom.")
+        .in(source).onLine(6);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnItemLongClickTest.java b/butterknife-runtime/src/test/java/butterknife/OnItemLongClickTest.java
new file mode 100644
index 00000000..20dc76eb
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnItemLongClickTest.java
@@ -0,0 +1,120 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnItemLongClickTest {
+  @Test public void itemLongClick() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnItemLongClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemLongClick(1) boolean doStuff() { return false; }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onItemLongClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        return target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemLongClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void defaultReturnValue() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnItemLongClick;\n"
+        + "public class Test {\n"
+        + "  @OnItemLongClick(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onItemLongClick(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff();\n"
+        + "        return true;\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemLongClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnItemSelectedTest.java b/butterknife-runtime/src/test/java/butterknife/OnItemSelectedTest.java
new file mode 100644
index 00000000..11449b13
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnItemSelectedTest.java
@@ -0,0 +1,280 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+/** This augments {@link OnClickTest} with tests that exercise callbacks with multiple methods. */
+public class OnItemSelectedTest {
+  @Test public void defaultMethod() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnItemSelected;\n"
+        + "public class Test {\n"
+        + "  @OnItemSelected(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemSelectedListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void nonDefaultMethod() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import butterknife.OnItemSelected;"
+        + "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;"
+        + "public class Test {"
+        + "  @OnItemSelected(value = 1, callback = NOTHING_SELECTED)"
+        + "  void doStuff() {}"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemSelectedListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void allMethods() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import butterknife.OnItemSelected;"
+        + "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;"
+        + "public class Test {"
+        + "  @OnItemSelected(1)"
+        + "  void onItemSelected() {}"
+        + "  @OnItemSelected(value = 1, callback = NOTHING_SELECTED)"
+        + "  void onNothingSelected() {}"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'onItemSelected' and method 'onNothingSelected'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.onItemSelected();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "        target.onNothingSelected();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemSelectedListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void multipleBindingPermutation() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;"
+        + "import butterknife.OnItemSelected;"
+        + "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;"
+        + "public class Test {"
+        + "  @OnItemSelected({ 1, 2 })"
+        + "  void onItemSelected() {}"
+        + "  @OnItemSelected(value = { 1, 3 }, callback = NOTHING_SELECTED)"
+        + "  void onNothingSelected() {}"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.AdapterView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  private View view2;\n"
+        + "  private View view3;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'onItemSelected' and method 'onNothingSelected'\");\n"
+        + "    view1 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.onItemSelected();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "        target.onNothingSelected();\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = Utils.findRequiredView(source, 2, \"method 'onItemSelected'\");\n"
+        + "    view2 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "        target.onItemSelected();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view = Utils.findRequiredView(source, 3, \"method 'onNothingSelected'\");\n"
+        + "    view3 = view;\n"
+        + "    ((AdapterView<?>) view).setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n"
+        + "      @Override\n"
+        + "      public void onItemSelected(AdapterView<?> p0, View p1, int p2, long p3) {\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onNothingSelected(AdapterView<?> p0) {\n"
+        + "        target.onNothingSelected();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((AdapterView<?>) view1).setOnItemSelectedListener(null);\n"
+        + "    view1 = null;\n"
+        + "    ((AdapterView<?>) view2).setOnItemSelectedListener(null);\n"
+        + "    view2 = null;\n"
+        + "    ((AdapterView<?>) view3).setOnItemSelectedListener(null);\n"
+        + "    view3 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnPageChangeTest.java b/butterknife-runtime/src/test/java/butterknife/OnPageChangeTest.java
new file mode 100644
index 00000000..cfd5ff8f
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnPageChangeTest.java
@@ -0,0 +1,77 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static butterknife.TestStubs.ANDROIDX_VIEW_PAGER;
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+public class OnPageChangeTest {
+  @Test public void pageChange() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnPageChange;\n"
+        + "public class Test {\n"
+        + "  @OnPageChange(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.viewpager.widget.ViewPager;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  private ViewPager.OnPageChangeListener view1OnPageChangeListener;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    view1OnPageChangeListener = new ViewPager.OnPageChangeListener() {\n"
+        + "      @Override\n"
+        + "      public void onPageSelected(int p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onPageScrolled(int p0, float p1, int p2) {\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void onPageScrollStateChanged(int p0) {\n"
+        + "      }\n"
+        + "    };\n"
+        + "    ((ViewPager) view).addOnPageChangeListener(view1OnPageChangeListener);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((ViewPager) view1).removeOnPageChangeListener(view1OnPageChangeListener);\n"
+        + "    view1OnPageChangeListener = null;\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources())
+        .that(asList(source, ANDROIDX_VIEW_PAGER))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnTextChangedTest.java b/butterknife-runtime/src/test/java/butterknife/OnTextChangedTest.java
new file mode 100644
index 00000000..dcc98467
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnTextChangedTest.java
@@ -0,0 +1,225 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnTextChangedTest {
+  @Test public void textChanged() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnTextChanged;\n"
+        + "public class Test {\n"
+        + "  @OnTextChanged(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.text.Editable;\n"
+        + "import android.text.TextWatcher;\n"
+        + "import android.view.View;\n"
+        + "import android.widget.TextView;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.CharSequence;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  private TextWatcher view1TextWatcher;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    view1TextWatcher = new TextWatcher() {\n"
+        + "      @Override\n"
+        + "      public void onTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void beforeTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+        + "      }\n"
+        + "      @Override\n"
+        + "      public void afterTextChanged(Editable p0) {\n"
+        + "      }\n"
+        + "    };\n"
+        + "    ((TextView) view).addTextChangedListener(view1TextWatcher);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    ((TextView) view1).removeTextChangedListener(view1TextWatcher);\n"
+        + "    view1TextWatcher = null;\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void textChangedWithParameter() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+            + "package test;\n"
+            + "import butterknife.OnTextChanged;\n"
+            + "public class Test {\n"
+            + "  @OnTextChanged(1) void doStuff(CharSequence p0) {}\n"
+            + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+            + "package test;\n"
+            + "import android.text.Editable;\n"
+            + "import android.text.TextWatcher;\n"
+            + "import android.view.View;\n"
+            + "import android.widget.TextView;\n"
+            + "import androidx.annotation.CallSuper;\n"
+            + "import androidx.annotation.UiThread;\n"
+            + "import butterknife.Unbinder;\n"
+            + "import butterknife.internal.Utils;\n"
+            + "import java.lang.CharSequence;\n"
+            + "import java.lang.IllegalStateException;\n"
+            + "import java.lang.Override;\n"
+            + "public class Test_ViewBinding implements Unbinder {\n"
+            + "  private Test target;\n"
+            + "  private View view1;\n"
+            + "  private TextWatcher view1TextWatcher;\n"
+            + "  @UiThread\n"
+            + "  public Test_ViewBinding(final Test target, View source) {\n"
+            + "    this.target = target;\n"
+            + "    View view;\n"
+            + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+            + "    view1 = view;\n"
+            + "    view1TextWatcher = new TextWatcher() {\n"
+            + "      @Override\n"
+            + "      public void onTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+            + "        target.doStuff(p0);\n"
+            + "      }\n"
+            + "      @Override\n"
+            + "      public void beforeTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+            + "      }\n"
+            + "      @Override\n"
+            + "      public void afterTextChanged(Editable p0) {\n"
+            + "      }\n"
+            + "    };\n"
+            + "    ((TextView) view).addTextChangedListener(view1TextWatcher);\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  @CallSuper\n"
+            + "  public void unbind() {\n"
+            + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+            + "    target = null;\n"
+            + "    ((TextView) view1).removeTextChangedListener(view1TextWatcher);\n"
+            + "    view1TextWatcher = null;\n"
+            + "    view1 = null;\n"
+            + "  }\n"
+            + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+            .withCompilerOptions("-Xlint:-processing")
+            .processedWith(new ButterKnifeProcessor())
+            .compilesWithoutWarnings()
+            .and()
+            .generatesSources(bindingSource);
+  }
+
+  @Test public void textChangedWithParameters() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+            + "package test;\n"
+            + "import butterknife.OnTextChanged;\n"
+            + "public class Test {\n"
+            + "  @OnTextChanged(1) void doStuff(CharSequence p0, int p1, int p2, int p3) {}\n"
+            + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+            + "package test;\n"
+            + "import android.text.Editable;\n"
+            + "import android.text.TextWatcher;\n"
+            + "import android.view.View;\n"
+            + "import android.widget.TextView;\n"
+            + "import androidx.annotation.CallSuper;\n"
+            + "import androidx.annotation.UiThread;\n"
+            + "import butterknife.Unbinder;\n"
+            + "import butterknife.internal.Utils;\n"
+            + "import java.lang.CharSequence;\n"
+            + "import java.lang.IllegalStateException;\n"
+            + "import java.lang.Override;\n"
+            + "public class Test_ViewBinding implements Unbinder {\n"
+            + "  private Test target;\n"
+            + "  private View view1;\n"
+            + "  private TextWatcher view1TextWatcher;\n"
+            + "  @UiThread\n"
+            + "  public Test_ViewBinding(final Test target, View source) {\n"
+            + "    this.target = target;\n"
+            + "    View view;\n"
+            + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+            + "    view1 = view;\n"
+            + "    view1TextWatcher = new TextWatcher() {\n"
+            + "      @Override\n"
+            + "      public void onTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+            + "        target.doStuff(p0, p1, p2, p3);\n"
+            + "      }\n"
+            + "      @Override\n"
+            + "      public void beforeTextChanged(CharSequence p0, int p1, int p2, int p3) {\n"
+            + "      }\n"
+            + "      @Override\n"
+            + "      public void afterTextChanged(Editable p0) {\n"
+            + "      }\n"
+            + "    };\n"
+            + "    ((TextView) view).addTextChangedListener(view1TextWatcher);\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  @CallSuper\n"
+            + "  public void unbind() {\n"
+            + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+            + "    target = null;\n"
+            + "    ((TextView) view1).removeTextChangedListener(view1TextWatcher);\n"
+            + "    view1TextWatcher = null;\n"
+            + "    view1 = null;\n"
+            + "  }\n"
+            + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+            .withCompilerOptions("-Xlint:-processing")
+            .processedWith(new ButterKnifeProcessor())
+            .compilesWithoutWarnings()
+            .and()
+            .generatesSources(bindingSource);
+  }
+
+  @Test public void textChangedWithWrongParameter() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+            + "package test;\n"
+            + "import butterknife.OnTextChanged;\n"
+            + "public class Test {\n"
+            + "  @OnTextChanged(1) void doStuff(String p0, int p1, int p2, int p3) {}\n"
+            + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+            .withCompilerOptions("-Xlint:-processing")
+            .processedWith(new ButterKnifeProcessor())
+            .failsToCompile();
+  }
+
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/OnTouchTest.java b/butterknife-runtime/src/test/java/butterknife/OnTouchTest.java
new file mode 100644
index 00000000..06e3701c
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/OnTouchTest.java
@@ -0,0 +1,142 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public class OnTouchTest {
+  @Test public void touch() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnTouch;\n"
+        + "public class Test {\n"
+        + "  @OnTouch(1) boolean doStuff() { return false; }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.annotation.SuppressLint;\n"
+        + "import android.view.MotionEvent;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  @SuppressLint(\"ClickableViewAccessibility\")\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    view.setOnTouchListener(new View.OnTouchListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onTouch(View p0, MotionEvent p1) {\n"
+        + "        return target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view1.setOnTouchListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void defaultReturnValue() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnTouch;\n"
+        + "public class Test {\n"
+        + "  @OnTouch(1) void doStuff() {}\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.annotation.SuppressLint;\n"
+        + "import android.view.MotionEvent;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  @SuppressLint(\"ClickableViewAccessibility\")\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff'\");\n"
+        + "    view1 = view;\n"
+        + "    view.setOnTouchListener(new View.OnTouchListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onTouch(View p0, MotionEvent p1) {\n"
+        + "        target.doStuff();\n"
+        + "        return true;\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view1.setOnTouchListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void failsMultipleListenersWithReturnValue() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnTouch;\n"
+        + "public class Test {\n"
+        + "  @OnTouch(1) boolean doStuff1() {}\n"
+        + "  @OnTouch(1) boolean doStuff2() {}\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .processedWith(new ButterKnifeProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Multiple listener methods with return value specified for ID 1. (test.Test.doStuff2)")
+        .in(source).onLine(5);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/RClassTest.java b/butterknife-runtime/src/test/java/butterknife/RClassTest.java
new file mode 100644
index 00000000..65acf98e
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/RClassTest.java
@@ -0,0 +1,425 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+public class RClassTest {
+
+  private static final JavaFileObject NON_FINAL_R = JavaFileObjects.forSourceString("test.R", ""
+      + "package test;\n"
+      + "public final class R {\n"
+      + "  public static final class array {\n"
+      + "    public static int res = 0x7f040001;\n"
+      + "  }\n"
+      + "  public static final class bool {\n"
+      + "    public static int res = 0x7f040002;\n"
+      + "  }\n"
+      + "  public static final class color {\n"
+      + "    public static int res = 0x7f040003;\n"
+      + "  }\n"
+      + "  public static final class integer {\n"
+      + "    public static int res = 0x7f040004;\n"
+      + "  }\n"
+      + "  public static final class styleable {\n"
+      + "    public static int[] ActionBar = { 0x7f010001, 0x7f010003 };\n"
+      + "  }\n"
+      + "}"
+  );
+
+  private static final JavaFileObject FINAL_R = JavaFileObjects.forSourceString("test.R", ""
+      + "package test;\n"
+      + "public final class R {\n"
+      + "  public static final class array {\n"
+      + "    public static final int res = 0x7f040001;\n"
+      + "  }\n"
+      + "  public static final class bool {\n"
+      + "    public static final int res = 0x7f040002;\n"
+      + "  }\n"
+      + "  public static final class color {\n"
+      + "    public static final int res = 0x7f040003;\n"
+      + "  }\n"
+      + "  public static final class integer {\n"
+      + "    public static final int res = 0x7f040004;\n"
+      + "  }\n"
+      + "  public static final class string {\n"
+      + "    public static final int res = 0x7f040005;\n"
+      + "  }\n"
+      + "  public static final class styleable {\n"
+      + "    public static final int[] ActionBar = { 0x7f010001, 0x7f010003 };\n"
+      + "  }\n"
+      + "}"
+  );
+
+  private static final JavaFileObject R2 = JavaFileObjects.forSourceString("test.R2", ""
+      + "package test;\n"
+      + "public final class R2 {\n"
+      + "  public static final class array {\n"
+      + "    public static final int res = 0x7f040001;\n"
+      + "  }\n"
+      + "  public static final class bool {\n"
+      + "    public static final int res = 0x7f040002;\n"
+      + "  }\n"
+      + "  public static final class color {\n"
+      + "    public static final int res = 0x7f040003;\n"
+      + "  }\n"
+      + "  public static final class integer {\n"
+      + "    public static final int res = 0x7f040004;\n"
+      + "  }\n"
+      + "  public static final class string {\n"
+      + "    public static final int res = 0x7f040005;\n"
+      + "  }\n"
+      + "}"
+  );
+
+  @Test public void library() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindInt;\n"
+        + "public class Test {\n"
+        + "  @BindInt(R2.integer.res) int one;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.one = res.getInteger(R.integer.res);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source, NON_FINAL_R, R2))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void issue779() {
+    JavaFileObject r2Bar = JavaFileObjects.forSourceString("test.bar.R2", ""
+        + "package test.bar;\n"
+        + "public final class R2 {\n"
+        + "  public static final class array {\n"
+        + "    public static final int res = 0x7f040001;\n"
+        + "  }\n"
+        + "  public static final class bool {\n"
+        + "    public static final int res = 0x7f040002;\n"
+        + "  }\n"
+        + "  public static final class color {\n"
+        + "    public static final int res = 0x7f040003;\n"
+        + "  }\n"
+        + "  public static final class id {\n"
+        + "    public static final int res = 0x7f040004;\n"
+        + "  }\n"
+        + "  public static final class string {\n"
+        + "    public static final int res = 0x7f040005;\n"
+        + "  }\n"
+        + "}");
+
+    JavaFileObject nonFinalRBar = JavaFileObjects.forSourceString("test.bar.R", ""
+        + "package test.bar;\n"
+        + "public final class R {\n"
+        + "  public static final class array {\n"
+        + "    public static int res = 0x7f040001;\n"
+        + "  }\n"
+        + "  public static final class bool {\n"
+        + "    public static int res = 0x7f040002;\n"
+        + "  }\n"
+        + "  public static final class color {\n"
+        + "    public static int res = 0x7f040003;\n"
+        + "  }\n"
+        + "  public static final class id {\n"
+        + "    public static int res = 0x7f040004;\n"
+        + "  }\n"
+        + "  public static final class styleable {\n"
+        + "    public static int[] ActionBar = { 0x7f010001, 0x7f010003 };\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject nonFinalRFoo = JavaFileObjects.forSourceString("test.foo.R", ""
+        + "package test.foo;\n"
+        + "public final class R {\n"
+        + "  public static final class array {\n"
+        + "    public static int res = 0x7f040001;\n"
+        + "  }\n"
+        + "  public static final class bool {\n"
+        + "    public static int res = 0x7f040002;\n"
+        + "  }\n"
+        + "  public static final class color {\n"
+        + "    public static int res = 0x7f040003;\n"
+        + "  }\n"
+        + "  public static final class id {\n"
+        + "    public static int bogus = 0x7f040004;\n"
+        + "  }\n"
+        + "  public static final class styleable {\n"
+        + "    public static int[] ActionBar = { 0x7f010001, 0x7f010003 };\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject r2Foo = JavaFileObjects.forSourceString("test.foo.R2", ""
+        + "package test.foo;\n"
+        + "public final class R2 {\n"
+        + "  public static final class array {\n"
+        + "    public static final int res = 0x7f040001;\n"
+        + "  }\n"
+        + "  public static final class bool {\n"
+        + "    public static final int res = 0x7f040002;\n"
+        + "  }\n"
+        + "  public static final class color {\n"
+        + "    public static final int res = 0x7f040003;\n"
+        + "  }\n"
+        + "  public static final class id {\n"
+        + "    public static final int bogus = 0x7f040004;\n"
+        + "  }\n"
+        + "  public static final class string {\n"
+        + "    public static final int res = 0x7f040005;\n"
+        + "  }\n"
+        + "}");
+
+    JavaFileObject fooSource = JavaFileObjects.forSourceString("test.foo.FooTest", ""
+        + "package test.foo;\n"
+        + "import android.app.Activity;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "public class FooTest extends Activity {\n"
+        + "  @BindView(R2.id.bogus) View one;\n"
+        + "}"
+    );
+
+    JavaFileObject barSource = JavaFileObjects.forSourceString("test.bar.Test", ""
+        + "package test.bar;\n"
+        + "import android.app.Activity;\n"
+        + "import butterknife.BindView;\n"
+        + "public class Test extends Activity {\n"
+        + "  @BindView(R2.id.res) CustomView one;\n"
+        + "}"
+    );
+
+    JavaFileObject customView = JavaFileObjects.forSourceString("test.bar.CustomView", ""
+        + "package test.bar;\n"
+        + "import android.view.View;\n"
+        + "import android.content.Context;\n"
+        + "public class CustomView extends View {\n"
+        + "  public CustomView(Context context) {\n"
+        + "    super(context);"
+        + "  }"
+        + "}"
+    );
+
+    JavaFileObject bindingSourceBar = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test.bar;\n\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target) {\n"
+        + "    this(target, target.getWindow().getDecorView());\n"
+        + "  }\n\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.one = Utils.findRequiredViewAsType(source, R.id.res, \"field 'one'\", " +
+        "CustomView.class);\n"
+        + "  }\n\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        +
+        "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n\n"
+        + "    target.one = null;\n\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSourceFoo = JavaFileObjects.forSourceString("test/FooTest_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test.foo;\n\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class FooTest_ViewBinding implements Unbinder {\n"
+        + "  private FooTest target;\n\n"
+        + "  @UiThread\n"
+        + "  public FooTest_ViewBinding(FooTest target) {\n"
+        + "    this(target, target.getWindow().getDecorView());\n"
+        + "  }\n\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(FooTest target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    target.one = Utils.findRequiredView(source, R.id.bogus, \"field 'one'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    FooTest target = this.target;\n"
+        +
+        "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n\n"
+        + "    this.target = null;\n\n"
+        + "    target.one = null;\n\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources())
+        .that(asList(customView, fooSource, barSource, nonFinalRBar, nonFinalRFoo, r2Bar, r2Foo))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSourceBar);
+
+    assertAbout(javaSources())
+        .that(asList(customView, fooSource, barSource, nonFinalRBar, nonFinalRFoo, r2Bar, r2Foo))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSourceFoo);
+  }
+
+  @Test public void app() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindBool;\n"
+        + "public class Test {\n"
+        + "  @BindBool(R.bool.res) boolean bool;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.content.res.Resources;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    Resources res = context.getResources();\n"
+        + "    target.bool = res.getBoolean(R.bool.res);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source, FINAL_R))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void compiledRClass() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class Test {\n"
+        + "  @BindColor(android.R.color.black) int black;\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(Test, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(Test target, Context context) {\n"
+        + "    target.black = ContextCompat.getColor(context, android.R.color.black);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source, NON_FINAL_R))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/TestGeneratingProcessor.java b/butterknife-runtime/src/test/java/butterknife/TestGeneratingProcessor.java
new file mode 100644
index 00000000..72a13522
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/TestGeneratingProcessor.java
@@ -0,0 +1,59 @@
+package butterknife;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+
+/**
+ * A test {@link javax.annotation.processing.Processor} that produces one file.
+ *
+ * To use it, include {@link #ANNOTATION} in your source set and
+ * mark something with @PerformGeneration so the processor has something to latch onto
+ */
+public class TestGeneratingProcessor extends AbstractProcessor {
+
+  public static final JavaFileObject ANNOTATION = JavaFileObjects.forSourceString("test.PerformGeneration", ""
+          + "package test;\n"
+          + "import java.lang.annotation.*;\n"
+          + "@Target(ElementType.TYPE)\n"
+          + "public @interface PerformGeneration {\n"
+          + "}");
+
+  private final String generatedClassName;
+  private final String generatedSource;
+  private boolean processed;
+
+  TestGeneratingProcessor(String generatedClassName, String... source) {
+    this.generatedClassName = generatedClassName;
+    this.generatedSource = Joiner.on("\n").join(source);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of("test.PerformGeneration");
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    if (!processed) {
+      processed = true;
+      try (Writer writer = processingEnv.getFiler()
+          .createSourceFile(generatedClassName)
+          .openWriter()) {
+        writer.append(generatedSource);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return false;
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/TestStubs.java b/butterknife-runtime/src/test/java/butterknife/TestStubs.java
new file mode 100644
index 00000000..df562958
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/TestStubs.java
@@ -0,0 +1,25 @@
+package butterknife;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+
+final class TestStubs {
+  static final JavaFileObject ANDROIDX_CONTEXT_COMPAT =
+      JavaFileObjects.forSourceString("androidx.core.content.ContextCompat", ""
+          + "package androidx.core.content;\n"
+          + "public class ContextCompat {}");
+
+  static final JavaFileObject ANDROIDX_VIEW_PAGER =
+      JavaFileObjects.forSourceString("androidx.viewpager.widget.ViewPager", ""
+          + "package androidx.viewpager.widget;\n"
+          + "\n"
+          + "public interface ViewPager {\n"
+          + "  void addOnPageChangeListener(OnPageChangeListener listener);\n"
+          + "  void removeOnPageChangeListener(OnPageChangeListener listener);\n"
+          + "  interface OnPageChangeListener {\n"
+          + "    void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);\n"
+          + "    void onPageSelected(int position);\n"
+          + "    void onPageScrollStateChanged(int state);\n"
+          + "  }\n"
+          + "}\n");
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/UnbinderTest.java b/butterknife-runtime/src/test/java/butterknife/UnbinderTest.java
new file mode 100644
index 00000000..f9eb717a
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/UnbinderTest.java
@@ -0,0 +1,529 @@
+package butterknife;
+
+import butterknife.compiler.ButterKnifeProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+public class UnbinderTest {
+  @Test public void multipleBindings() {
+    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.OnClick;\n"
+        + "import butterknife.OnLongClick;\n"
+        + "public class Test {\n"
+        + "  @BindView(1) View view;\n"
+        + "  @BindView(2) View view2;\n"
+        + "  @OnClick(1) void doStuff() {}\n"
+        + "  @OnLongClick(1) boolean doMoreStuff() { return false; }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingSource = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"field 'view', method 'doStuff', and method 'doMoreStuff'\");\n"
+        + "    target.view = view;\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "    view.setOnLongClickListener(new View.OnLongClickListener() {\n"
+        + "      @Override\n"
+        + "      public boolean onLongClick(View p0) {\n"
+        + "        return target.doMoreStuff();\n"
+        + "      }\n"
+        + "    });\n"
+        + "    target.view2 = Utils.findRequiredView(source, 2, \"field 'view2'\");\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    Test target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.view = null;\n"
+        + "    target.view2 = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1.setOnLongClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSource()).that(source)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(bindingSource);
+  }
+
+  @Test public void unbindingThroughAbstractChild() {
+    JavaFileObject source1 = JavaFileObjects.forSourceString("test.Test", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class Test {\n"
+        + "  @OnClick(1) void doStuff1() { }\n"
+        + "}"
+    );
+
+    JavaFileObject source2 = JavaFileObjects.forSourceString("test.TestOne", ""
+        + "package test;\n"
+        + "public abstract class TestOne extends Test {\n"
+        + "}"
+    );
+
+    JavaFileObject source3 = JavaFileObjects.forSourceString("test.TestTwo", ""
+        + "package test;\n"
+        + "import butterknife.OnClick;\n"
+        + "class TestTwo extends TestOne {\n"
+        + "  @OnClick(1) void doStuff2() { }\n"
+        + "}"
+    );
+
+    JavaFileObject binding1Source = JavaFileObjects.forSourceString("test/Test_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class Test_ViewBinding implements Unbinder {\n"
+        + "  private Test target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(final Test target, View source) {\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff1'\");\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff1();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject binding2Source = JavaFileObjects.forSourceString("test/TestTwo_ViewBinding", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class TestTwo_ViewBinding extends Test_ViewBinding {\n"
+        + "  private TestTwo target;\n"
+        + "  private View view1;\n"
+        + "  @UiThread\n"
+        + "  public TestTwo_ViewBinding(final TestTwo target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    view = Utils.findRequiredView(source, 1, \"method 'doStuff2'\");\n"
+        + "    view1 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.doStuff2();\n"
+        + "      }\n"
+        + "    });\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    target = null;\n"
+        + "    view1.setOnClickListener(null);\n"
+        + "    view1 = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources()).that(asList(source1, source2, source3))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(binding1Source, binding2Source);
+  }
+
+  @Test public void fullIntegration() {
+    JavaFileObject sourceA = JavaFileObjects.forSourceString("test.A", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class A {\n"
+        + "  @BindColor(android.R.color.black) @ColorInt int blackColor;\n"
+        + "  public A(View view) {\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceB = JavaFileObjects.forSourceString("test.B", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class B extends A {\n"
+        + "  @BindColor(android.R.color.white) @ColorInt int whiteColor;\n"
+        + "  public B(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceC = JavaFileObjects.forSourceString("test.C", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class C extends B {\n"
+        + "  @BindColor(android.R.color.transparent) @ColorInt int transparentColor;\n"
+        + "  @BindView(android.R.id.button1) View button1;\n"
+        + "  public C(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceD = JavaFileObjects.forSourceString("test.D", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class D extends C {\n"
+        + "  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;\n"
+        + "  public D(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceE = JavaFileObjects.forSourceString("test.E", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class E extends C {\n"
+        + "  @BindColor(android.R.color.background_dark) @ColorInt int backgroundDarkColor;\n"
+        + "  public E(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceF = JavaFileObjects.forSourceString("test.F", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class F extends D {\n"
+        + "  @BindColor(android.R.color.background_light) @ColorInt int backgroundLightColor;\n"
+        + "  public F(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceG = JavaFileObjects.forSourceString("test.G", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.BindColor;\n"
+        + "import butterknife.OnClick;\n"
+        + "public class G extends E {\n"
+        + "  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;\n"
+        + "  @BindView(android.R.id.button2) View button2;\n"
+        + "  public G(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "  @OnClick(android.R.id.content) public void onClick() {\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject sourceH = JavaFileObjects.forSourceString("test.H", ""
+        + "package test;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.ColorInt;\n"
+        + "import butterknife.BindView;\n"
+        + "import butterknife.BindColor;\n"
+        + "public class H extends G {\n"
+        + "  @BindColor(android.R.color.holo_green_dark) @ColorInt int holoGreenDark;\n"
+        + "  @BindView(android.R.id.button3) View button3;\n"
+        + "  public H(View view) {\n"
+        + "    super(view);\n"
+        + "  }\n"
+        + "}\n");
+
+    JavaFileObject bindingASource = JavaFileObjects.forSourceString("test/A_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.CallSuper;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import butterknife.Unbinder;\n"
+        + "import java.lang.Deprecated;\n"
+        + "import java.lang.Override;\n"
+        + "public class A_ViewBinding implements Unbinder {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(A, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(A target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public A_ViewBinding(A target, Context context) {\n"
+        + "    target.blackColor = ContextCompat.getColor(context, android.R.color.black);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  @CallSuper\n"
+        + "  public void unbind() {\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingBSource = JavaFileObjects.forSourceString("test/B_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import java.lang.Deprecated;\n"
+        + "public class B_ViewBinding extends A_ViewBinding {\n"
+        + "  /**\n"
+        + "   * @deprecated Use {@link #Test_ViewBinding(B, Context)} for direct creation.\n"
+        + "   *     Only present for runtime invocation through {@code ButterKnife.bind()}.\n"
+        + "   */\n"
+        + "  @Deprecated\n"
+        + "  @UiThread\n"
+        + "  public Test_ViewBinding(B target, View source) {\n"
+        + "    this(target, source.getContext());\n"
+        + "  }\n"
+        + "  @UiThread\n"
+        + "  public B_ViewBinding(B target, Context context) {\n"
+        + "    super(target, context);\n"
+        + "    target.whiteColor = ContextCompat.getColor(context, android.R.color.white);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingCSource = JavaFileObjects.forSourceString("test/C_ViewBinding", ""
+        + "// Generated code from Butter Knife. Do not modify!\n"
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class C_ViewBinding extends B_ViewBinding {\n"
+        + "  private C target;\n"
+        + "  @UiThread\n"
+        + "  public C_ViewBinding(C target, View source) {\n"
+        + "    super(target, source.getContext());\n"
+        + "    this.target = target;\n"
+        + "    target.button1 = Utils.findRequiredView(source, android.R.id.button1, \"field 'button1'\");\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.transparentColor = ContextCompat.getColor(context, android.R.color.transparent);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    C target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.button1 = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingDSource = JavaFileObjects.forSourceString("test/D_ViewBinding", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "public class D_ViewBinding extends C_ViewBinding {\n"
+        + "  @UiThread\n"
+        + "  public D_ViewBinding(D target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.grayColor = ContextCompat.getColor(context, android.R.color.darker_gray);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingESource = JavaFileObjects.forSourceString("test/E_ViewBinding", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "public class E_ViewBinding extends C_ViewBinding {\n"
+        + "  @UiThread\n"
+        + "  public E_ViewBinding(E target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.backgroundDarkColor = ContextCompat.getColor(context, android.R.color.background_dark);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingFSource = JavaFileObjects.forSourceString("test/F_ViewBinding", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "public class F_ViewBinding extends D_ViewBinding {\n"
+        + "  @UiThread\n"
+        + "  public F_ViewBinding(F target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.backgroundLightColor = ContextCompat.getColor(context, android.R.color.background_light);\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingGSource = JavaFileObjects.forSourceString("test/G_ViewBinding", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import butterknife.internal.DebouncingOnClickListener;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class G_ViewBinding extends E_ViewBinding {\n"
+        + "  private G target;\n"
+        + "  private View view1020002;\n"
+        + "  @UiThread\n"
+        + "  public G_ViewBinding(final G target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    View view;\n"
+        + "    target.button2 = Utils.findRequiredView(source, android.R.id.button2, \"field 'button2'\");\n"
+        + "    view = Utils.findRequiredView(source, android.R.id.content, \"method 'onClick'\");\n"
+        + "    view1020002 = view;\n"
+        + "    view.setOnClickListener(new DebouncingOnClickListener() {\n"
+        + "      @Override\n"
+        + "      public void doClick(View p0) {\n"
+        + "        target.onClick();\n"
+        + "      }\n"
+        + "    });\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.grayColor = ContextCompat.getColor(context, android.R.color.darker_gray);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    G target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null\n"
+        + "    target.button2 = null;\n"
+        + "    view1020002.setOnClickListener(null);\n"
+        + "    view1020002 = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    JavaFileObject bindingHSource = JavaFileObjects.forSourceString("test/H_ViewBinding", ""
+        + "package test;\n"
+        + "import android.content.Context;\n"
+        + "import android.view.View;\n"
+        + "import androidx.annotation.UiThread;\n"
+        + "import androidx.core.content.ContextCompat;\n"
+        + "import butterknife.internal.Utils;\n"
+        + "import java.lang.IllegalStateException;\n"
+        + "import java.lang.Override;\n"
+        + "public class H_ViewBinding extends G_ViewBinding {\n"
+        + "  private H target;\n"
+        + "  @UiThread\n"
+        + "  public H_ViewBinding(H target, View source) {\n"
+        + "    super(target, source);\n"
+        + "    this.target = target;\n"
+        + "    target.button3 = Utils.findRequiredView(source, android.R.id.button3, \"field 'button3'\");\n"
+        + "    Context context = source.getContext();\n"
+        + "    target.holoGreenDark = ContextCompat.getColor(context, android.R.color.holo_green_dark);\n"
+        + "  }\n"
+        + "  @Override\n"
+        + "  public void unbind() {\n"
+        + "    H target = this.target;\n"
+        + "    if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");\n"
+        + "    this.target = null;\n"
+        + "    target.button3 = null;\n"
+        + "    super.unbind();\n"
+        + "  }\n"
+        + "}"
+    );
+
+    assertAbout(javaSources())
+        .that(asList(
+            sourceA,
+            sourceB,
+            sourceC,
+            sourceD,
+            sourceE,
+            sourceF,
+            sourceG,
+            sourceH))
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new ButterKnifeProcessor())
+        .compilesWithoutWarnings()
+        .and()
+        .generatesSources(
+            bindingASource,
+            bindingBSource,
+            bindingCSource,
+            bindingDSource,
+            bindingESource,
+            bindingFSource,
+            bindingGSource,
+            bindingHSource);
+  }
+}
diff --git a/butterknife-runtime/src/test/java/butterknife/UtilsTest.java b/butterknife-runtime/src/test/java/butterknife/UtilsTest.java
new file mode 100644
index 00000000..67386b7a
--- /dev/null
+++ b/butterknife-runtime/src/test/java/butterknife/UtilsTest.java
@@ -0,0 +1,50 @@
+package butterknife;
+
+import butterknife.internal.Utils;
+import org.junit.Test;
+
+import static butterknife.internal.Utils.arrayFilteringNull;
+import static butterknife.internal.Utils.listFilteringNull;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public final class UtilsTest {
+  @Test public void listOfFiltersNull() {
+    assertThat(listFilteringNull(null, null, null)).isEmpty();
+    assertThat(listFilteringNull("One", null, null)).containsExactly("One");
+    assertThat(listFilteringNull(null, "One", null)).containsExactly("One");
+    assertThat(listFilteringNull(null, null, "One")).containsExactly("One");
+    assertThat(listFilteringNull("One", "Two", null)).containsExactly("One", "Two");
+    assertThat(listFilteringNull("One", null, "Two")).containsExactly("One", "Two");
+    assertThat(listFilteringNull(null, "One", "Two")).containsExactly("One", "Two");
+    assertThat(listFilteringNull("One", "Two", "Three")).containsExactly("One", "Two", "Three");
+  }
+
+  @Test public void arrayFilteringNullRemovesNulls() {
+    assertThat(arrayFilteringNull(null, null, null)).isEmpty();
+    assertThat(arrayFilteringNull("One", null, null)).asList().containsExactly("One");
+    assertThat(arrayFilteringNull(null, "One", null)).asList().containsExactly("One");
+    assertThat(arrayFilteringNull(null, null, "One")).asList().containsExactly("One");
+    assertThat(arrayFilteringNull("One", "Two", null)).asList().containsExactly("One", "Two");
+    assertThat(arrayFilteringNull("One", null, "Two")).asList().containsExactly("One", "Two");
+    assertThat(arrayFilteringNull(null, "One", "Two")).asList().containsExactly("One", "Two");
+  }
+
+  @Test public void arrayFilteringNullReturnsOriginalWhenNoNulls() {
+    String[] input = { "One", "Two", "Three" };
+    String[] actual = arrayFilteringNull(input);
+    assertThat(actual).isSameAs(input);
+    // Even though we got the same reference back check to ensure its contents weren't mutated.
+    assertThat(actual).asList().containsExactly("One", "Two", "Three");
+  }
+
+  @Test public void testCastParam() {
+    try {
+      Utils.castParam("abc", "Foo", 3, "foo()", 4, Integer.class);
+      fail();
+    } catch (IllegalStateException ise) {
+      assertThat(ise.getMessage()).isEqualTo(
+          "Parameter #4 of method 'Foo' was of the wrong type for parameter #5 of method 'foo()'. See cause for more info.");
+    }
+  }
+}
diff --git a/butterknife-sample/pom.xml b/butterknife-sample/pom.xml
deleted file mode 100644
index ef9efd7b..00000000
--- a/butterknife-sample/pom.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.jakewharton</groupId>
-    <artifactId>butterknife-parent</artifactId>
-    <version>5.1.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>butterknife-sample</artifactId>
-  <name>Butter Knife Sample</name>
-  <packaging>apk</packaging>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.jakewharton</groupId>
-      <artifactId>butterknife</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>fest-android</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-        <extensions>true</extensions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/butterknife-sample/src/test/java/com/example/butterknife/SimpleActivityTest.java b/butterknife-sample/src/test/java/com/example/butterknife/SimpleActivityTest.java
deleted file mode 100644
index d4a2df8c..00000000
--- a/butterknife-sample/src/test/java/com/example/butterknife/SimpleActivityTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.example.butterknife;
-
-import butterknife.ButterKnife;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.fest.assertions.api.ANDROID.assertThat;
-
-@RunWith(RobolectricTestRunner.class)
-public class SimpleActivityTest {
-  @Test public void verifyContentViewInjection() {
-    SimpleActivity activity = Robolectric.buildActivity(SimpleActivity.class) //
-        .create() //
-        .get();
-
-    assertThat(activity.title).hasId(R.id.title);
-    assertThat(activity.subtitle).hasId(R.id.subtitle);
-    assertThat(activity.hello).hasId(R.id.hello);
-    assertThat(activity.listOfThings).hasId(R.id.list_of_things);
-    assertThat(activity.footer).hasId(R.id.footer);
-
-    ButterKnife.reset(activity);
-    assertThat(activity.title).isNull();
-    assertThat(activity.subtitle).isNull();
-    assertThat(activity.hello).isNull();
-    assertThat(activity.listOfThings).isNull();
-    assertThat(activity.footer).isNull();
-  }
-}
diff --git a/butterknife-sample/src/test/java/com/example/butterknife/SimpleAdapterTest.java b/butterknife-sample/src/test/java/com/example/butterknife/SimpleAdapterTest.java
deleted file mode 100644
index be6a1450..00000000
--- a/butterknife-sample/src/test/java/com/example/butterknife/SimpleAdapterTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.example.butterknife;
-
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import butterknife.ButterKnife;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import static com.example.butterknife.SimpleAdapter.ViewHolder;
-import static org.fest.assertions.api.ANDROID.assertThat;
-
-@RunWith(RobolectricTestRunner.class)
-public class SimpleAdapterTest {
-  @Test public void verifyViewHolderViews() {
-    Context context = Robolectric.application;
-
-    View root = LayoutInflater.from(context).inflate(R.layout.simple_list_item, null);
-    ViewHolder holder = new ViewHolder(root);
-
-    assertThat(holder.word).hasId(R.id.word);
-    assertThat(holder.length).hasId(R.id.length);
-    assertThat(holder.position).hasId(R.id.position);
-
-    ButterKnife.reset(holder);
-    assertThat(holder.word).isNull();
-    assertThat(holder.length).isNull();
-    assertThat(holder.position).isNull();
-  }
-}
diff --git a/butterknife/build.gradle b/butterknife/build.gradle
new file mode 100644
index 00000000..4b045262
--- /dev/null
+++ b/butterknife/build.gradle
@@ -0,0 +1,41 @@
+apply plugin: 'com.android.library'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+
+    consumerProguardFiles 'proguard-rules.txt'
+
+    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
+  }
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  lintOptions {
+    textReport true
+    textOutput 'stdout'
+    // We run a full lint analysis as build part in CI, so skip vital checks for assemble tasks.
+    checkReleaseBuilds false
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+dependencies {
+  api project(':butterknife-runtime')
+
+  androidTestImplementation deps.junit
+  androidTestImplementation deps.truth
+  androidTestImplementation deps.androidx.test.runner
+  androidTestAnnotationProcessor project(':butterknife-compiler')
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/butterknife/gradle.properties b/butterknife/gradle.properties
new file mode 100644
index 00000000..fc97e9b8
--- /dev/null
+++ b/butterknife/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=butterknife
+POM_NAME=Butterknife
+POM_PACKAGING=aar
diff --git a/butterknife/pom.xml b/butterknife/pom.xml
deleted file mode 100644
index 026170f9..00000000
--- a/butterknife/pom.xml
+++ /dev/null
@@ -1,68 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.jakewharton</groupId>
-    <artifactId>butterknife-parent</artifactId>
-    <version>5.1.3-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>butterknife</artifactId>
-  <name>Butter Knife</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>fest-android</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.testing.compile</groupId>
-      <artifactId>compile-testing</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>butterknife.internal:butterknife.internal.*</excludePackageNames>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/butterknife/proguard-rules.txt b/butterknife/proguard-rules.txt
new file mode 100644
index 00000000..dd010a40
--- /dev/null
+++ b/butterknife/proguard-rules.txt
@@ -0,0 +1,8 @@
+# Retain generated class which implement Unbinder.
+-keep public class * implements butterknife.Unbinder { public <init>(**, android.view.View); }
+
+# Prevent obfuscation of types which use ButterKnife annotations since the simple name
+# is used to reflectively look up the generated ViewBinding.
+-keep class butterknife.*
+-keepclasseswithmembernames class * { @butterknife.* <methods>; }
+-keepclasseswithmembernames class * { @butterknife.* <fields>; }
diff --git a/butterknife/src/androidTest/java/butterknife/ButterKnifeTest.java b/butterknife/src/androidTest/java/butterknife/ButterKnifeTest.java
new file mode 100644
index 00000000..06634f61
--- /dev/null
+++ b/butterknife/src/androidTest/java/butterknife/ButterKnifeTest.java
@@ -0,0 +1,38 @@
+package butterknife;
+
+import android.content.Context;
+import android.view.View;
+import androidx.test.InstrumentationRegistry;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public class ButterKnifeTest {
+  private final Context context = InstrumentationRegistry.getContext();
+
+  @Before @After // Clear out cache of binders before and after each test.
+  public void resetViewsCache() {
+    ButterKnife.BINDINGS.clear();
+  }
+
+  @Test public void zeroBindingsBindDoesNotThrowExceptionAndCaches() {
+    class Example {
+    }
+
+    Example example = new Example();
+    View view = new View(context);
+    assertThat(ButterKnife.BINDINGS).isEmpty();
+    assertThat(ButterKnife.bind(example, view)).isSameAs(Unbinder.EMPTY);
+    assertThat(ButterKnife.BINDINGS).containsEntry(Example.class, null);
+  }
+
+  @Test public void bindingKnownPackagesIsNoOp() {
+    View view = new View(context);
+    ButterKnife.bind(view);
+    assertThat(ButterKnife.BINDINGS).isEmpty();
+    ButterKnife.bind(new Object(), view);
+    assertThat(ButterKnife.BINDINGS).isEmpty();
+  }
+}
diff --git a/butterknife/src/main/AndroidManifest.xml b/butterknife/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..b5e34f17
--- /dev/null
+++ b/butterknife/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="butterknife"/>
diff --git a/butterknife/src/main/java/butterknife/ButterKnife.java b/butterknife/src/main/java/butterknife/ButterKnife.java
index e9817495..84606c9a 100644
--- a/butterknife/src/main/java/butterknife/ButterKnife.java
+++ b/butterknife/src/main/java/butterknife/ButterKnife.java
@@ -1,58 +1,50 @@
 package butterknife;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Dialog;
-import android.os.Build;
 import android.util.Log;
-import android.util.Property;
 import android.view.View;
-import butterknife.internal.ButterKnifeProcessor;
+import androidx.annotation.CheckResult;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.annotation.VisibleForTesting;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import static butterknife.internal.ButterKnifeProcessor.ANDROID_PREFIX;
-import static butterknife.internal.ButterKnifeProcessor.JAVA_PREFIX;
-
 /**
- * View "injection" utilities. Use this class to simplify finding views and attaching listeners by
- * injecting them.
+ * Field and method binding for Android views. Use this class to simplify finding views and
+ * attaching listeners by binding them with annotations.
  * <p>
- * Injecting views from your activity is as easy as:
+ * Finding views from your activity is as easy as:
  * <pre><code>
  * public class ExampleActivity extends Activity {
- *   {@literal @}InjectView(R.id.title) EditText titleView;
- *   {@literal @}InjectView(R.id.subtitle) EditText subtitleView;
+ *   {@literal @}BindView(R.id.title) EditText titleView;
+ *   {@literal @}BindView(R.id.subtitle) EditText subtitleView;
  *
  *   {@literal @}Override protected void onCreate(Bundle savedInstanceState) {
  *     super.onCreate(savedInstanceState);
  *     setContentView(R.layout.example_activity);
- *     ButterKnife.inject(this);
+ *     ButterKnife.bind(this);
  *   }
  * }
  * </code></pre>
- * Injection can be performed directly on an {@linkplain #inject(Activity) activity}, a
- * {@linkplain #inject(View) view}, or a {@linkplain #inject(Dialog) dialog}. Alternate objects to
- * inject can be specified along with an {@linkplain #inject(Object, Activity) activity},
- * {@linkplain #inject(Object, View) view}, or
- * {@linkplain #inject(Object, android.app.Dialog) dialog}.
+ * Binding can be performed directly on an {@linkplain #bind(Activity) activity}, a
+ * {@linkplain #bind(View) view}, or a {@linkplain #bind(Dialog) dialog}. Alternate objects to
+ * bind can be specified along with an {@linkplain #bind(Object, Activity) activity},
+ * {@linkplain #bind(Object, View) view}, or
+ * {@linkplain #bind(Object, android.app.Dialog) dialog}.
  * <p>
  * Group multiple views together into a {@link List} or array.
  * <pre><code>
- * {@literal @}InjectViews({R.id.first_name, R.id.middle_name, R.id.last_name})
+ * {@literal @}BindView({R.id.first_name, R.id.middle_name, R.id.last_name})
  * List<EditText> nameViews;
  * </code></pre>
- * There are three convenience methods for working with view collections:
- * <ul>
- * <li>{@link #apply(List, Action)} &ndash; Applies an action to each view.</li>
- * <li>{@link #apply(List, Setter, Object)} &ndash; Applies a setter value to each view.</li>
- * <li>{@link #apply(List, Property, Object)} &ndash; Applies a property value to each view.</li>
- * </ul>
  * <p>
- * To inject listeners to your views you can annotate your methods:
+ * To bind listeners to your views you can annotate your methods:
  * <pre><code>
  * {@literal @}OnClick(R.id.submit) void onSubmit() {
  *   // React to button click.
@@ -65,90 +57,30 @@
  * }
  * </code></pre>
  * <p>
- * Be default, views are required to be present in the layout for both field and method injections.
- * If a view is optional add the {@link Optional @Optional} annotation.
+ * Be default, views are required to be present in the layout for both field and method bindings.
+ * If a view is optional add a {@code @Nullable} annotation for fields (such as the one in the
+ * <a href="http://tools.android.com/tech-docs/support-annotations">support-annotations</a> library)
+ * or the {@code @Optional} annotation for methods.
  * <pre><code>
- * {@literal @}Optional @InjectView(R.id.title) TextView subtitleView;
+ * {@literal @}Nullable @BindView(R.id.title) TextView subtitleView;
+ * </code></pre>
+ * Resources can also be bound to fields to simplify programmatically working with views:
+ * <pre><code>
+ * {@literal @}BindBool(R.bool.is_tablet) boolean isTablet;
+ * {@literal @}BindInt(R.integer.columns) int columns;
+ * {@literal @}BindColor(R.color.error_red) int errorRed;
  * </code></pre>
- *
- * @see InjectView
- * @see InjectViews
- * @see OnCheckedChanged
- * @see OnClick
- * @see OnEditorAction
- * @see OnFocusChange
- * @see OnItemClick
- * @see OnItemLongClick
- * @see OnItemSelected
- * @see OnLongClick
- * @see OnPageChange
- * @see OnTextChanged
- * @see OnTouch
  */
 public final class ButterKnife {
   private ButterKnife() {
     throw new AssertionError("No instances.");
   }
 
-  /** DO NOT USE: Exposed for generated code. */
-  public enum Finder {
-    VIEW {
-      @Override public View findOptionalView(Object source, int id) {
-        return ((View) source).findViewById(id);
-      }
-    },
-    ACTIVITY {
-      @Override public View findOptionalView(Object source, int id) {
-        return ((Activity) source).findViewById(id);
-      }
-    },
-    DIALOG {
-      @Override public View findOptionalView(Object source, int id) {
-        return ((Dialog) source).findViewById(id);
-      }
-    };
-
-    public static <T extends View> T[] arrayOf(T... views) {
-      return views;
-    }
-
-    public static <T extends View> List<T> listOf(T... views) {
-      return new ImmutableViewList<T>(views);
-    }
-
-    public View findRequiredView(Object source, int id, String who) {
-      View view = findOptionalView(source, id);
-      if (view == null) {
-        throw new IllegalStateException("Required view with id '"
-            + id
-            + "' for "
-            + who
-            + " was not found. If this view is optional add '@Optional' annotation.");
-      }
-      return view;
-    }
-
-    public abstract View findOptionalView(Object source, int id);
-  }
-
-  /** An action that can be applied to a list of views. */
-  public interface Action<T extends View> {
-    /** Apply the action on the {@code view} which is at {@code index} in the list. */
-    void apply(T view, int index);
-  }
-
-  /** A setter that can apply a value to a list of views. */
-  public interface Setter<T extends View, V> {
-    /** Set the {@code value} on the {@code view} which is at {@code index} in the list. */
-    void set(T view, V value, int index);
-  }
-
   private static final String TAG = "ButterKnife";
   private static boolean debug = false;
 
-  static final Map<Class<?>, Method> INJECTORS = new LinkedHashMap<Class<?>, Method>();
-  static final Map<Class<?>, Method> RESETTERS = new LinkedHashMap<Class<?>, Method>();
-  static final Method NO_OP = null;
+  @VisibleForTesting
+  static final Map<Class<?>, Constructor<? extends Unbinder>> BINDINGS = new LinkedHashMap<>();
 
   /** Control whether debug logging is enabled. */
   public static void setDebug(boolean debug) {
@@ -156,201 +88,127 @@ public static void setDebug(boolean debug) {
   }
 
   /**
-   * Inject annotated fields and methods in the specified {@link Activity}. The current content
+   * BindView annotated fields and methods in the specified {@link Activity}. The current content
    * view is used as the view root.
    *
-   * @param target Target activity for field injection.
+   * @param target Target activity for view binding.
    */
-  public static void inject(Activity target) {
-    inject(target, target, Finder.ACTIVITY);
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Activity target) {
+    View sourceView = target.getWindow().getDecorView();
+    return bind(target, sourceView);
   }
 
   /**
-   * Inject annotated fields and methods in the specified {@link View}. The view and its children
+   * BindView annotated fields and methods in the specified {@link View}. The view and its children
    * are used as the view root.
    *
-   * @param target Target view for field injection.
+   * @param target Target view for view binding.
    */
-  public static void inject(View target) {
-    inject(target, target, Finder.VIEW);
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull View target) {
+    return bind(target, target);
   }
 
   /**
-   * Inject annotated fields and methods in the specified {@link Dialog}. The current content
+   * BindView annotated fields and methods in the specified {@link Dialog}. The current content
    * view is used as the view root.
    *
-   * @param target Target dialog for field injection.
+   * @param target Target dialog for view binding.
    */
-  public static void inject(Dialog target) {
-    inject(target, target, Finder.DIALOG);
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Dialog target) {
+    View sourceView = target.getWindow().getDecorView();
+    return bind(target, sourceView);
   }
 
   /**
-   * Inject annotated fields and methods in the specified {@code target} using the {@code source}
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
    * {@link Activity} as the view root.
    *
-   * @param target Target class for field injection.
+   * @param target Target class for view binding.
    * @param source Activity on which IDs will be looked up.
    */
-  public static void inject(Object target, Activity source) {
-    inject(target, source, Finder.ACTIVITY);
-  }
-
-  /**
-   * Inject annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link View} as the view root.
-   *
-   * @param target Target class for field injection.
-   * @param source View root on which IDs will be looked up.
-   */
-  public static void inject(Object target, View source) {
-    inject(target, source, Finder.VIEW);
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
+    View sourceView = source.getWindow().getDecorView();
+    return bind(target, sourceView);
   }
 
   /**
-   * Inject annotated fields and methods in the specified {@code target} using the {@code source}
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
    * {@link Dialog} as the view root.
    *
-   * @param target Target class for field injection.
+   * @param target Target class for view binding.
    * @param source Dialog on which IDs will be looked up.
    */
-  public static void inject(Object target, Dialog source) {
-    inject(target, source, Finder.DIALOG);
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
+    View sourceView = source.getWindow().getDecorView();
+    return bind(target, sourceView);
   }
 
   /**
-   * Reset fields annotated with {@link InjectView @InjectView} and {@link InjectViews @InjectViews}
-   * to {@code null}.
-   * <p>
-   * This should only be used in the {@code onDestroyView} method of a fragment.
+   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+   * {@link View} as the view root.
    *
-   * @param target Target class for field reset.
+   * @param target Target class for view binding.
+   * @param source View root on which IDs will be looked up.
    */
-  public static void reset(Object target) {
+  @NonNull @UiThread
+  public static Unbinder bind(@NonNull Object target, @NonNull View source) {
     Class<?> targetClass = target.getClass();
-    try {
-      if (debug) Log.d(TAG, "Looking up view injector for " + targetClass.getName());
-      Method reset = findResettersForClass(targetClass);
-      if (reset != null) {
-        reset.invoke(null, target);
-      }
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      Throwable t = e;
-      if (t instanceof InvocationTargetException) {
-        t = t.getCause();
-      }
-      throw new RuntimeException("Unable to reset views for " + target, t);
+    if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName());
+    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);
+
+    if (constructor == null) {
+      return Unbinder.EMPTY;
     }
-  }
 
-  static void inject(Object target, Object source, Finder finder) {
-    Class<?> targetClass = target.getClass();
+    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
     try {
-      if (debug) Log.d(TAG, "Looking up view injector for " + targetClass.getName());
-      Method inject = findInjectorForClass(targetClass);
-      if (inject != null) {
-        inject.invoke(null, finder, target, source);
+      return constructor.newInstance(target, source);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Unable to invoke " + constructor, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Unable to invoke " + constructor, e);
+    } catch (InvocationTargetException e) {
+      Throwable cause = e.getCause();
+      if (cause instanceof RuntimeException) {
+        throw (RuntimeException) cause;
       }
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      Throwable t = e;
-      if (t instanceof InvocationTargetException) {
-        t = t.getCause();
+      if (cause instanceof Error) {
+        throw (Error) cause;
       }
-      throw new RuntimeException("Unable to inject views for " + target, t);
-    }
-  }
-
-  private static Method findInjectorForClass(Class<?> cls) throws NoSuchMethodException {
-    Method inject = INJECTORS.get(cls);
-    if (inject != null) {
-      if (debug) Log.d(TAG, "HIT: Cached in injector map.");
-      return inject;
-    }
-    String clsName = cls.getName();
-    if (clsName.startsWith(ANDROID_PREFIX) || clsName.startsWith(JAVA_PREFIX)) {
-      if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
-      return NO_OP;
-    }
-    try {
-      Class<?> injector = Class.forName(clsName + ButterKnifeProcessor.SUFFIX);
-      inject = injector.getMethod("inject", Finder.class, cls, Object.class);
-      if (debug) Log.d(TAG, "HIT: Class loaded injection class.");
-    } catch (ClassNotFoundException e) {
-      if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
-      inject = findInjectorForClass(cls.getSuperclass());
+      throw new RuntimeException("Unable to create binding instance.", cause);
     }
-    INJECTORS.put(cls, inject);
-    return inject;
   }
 
-  private static Method findResettersForClass(Class<?> cls) throws NoSuchMethodException {
-    Method inject = RESETTERS.get(cls);
-    if (inject != null) {
-      if (debug) Log.d(TAG, "HIT: Cached in injector map.");
-      return inject;
+  @Nullable @CheckResult @UiThread
+  private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
+    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
+    if (bindingCtor != null || BINDINGS.containsKey(cls)) {
+      if (debug) Log.d(TAG, "HIT: Cached in binding map.");
+      return bindingCtor;
     }
     String clsName = cls.getName();
-    if (clsName.startsWith(ANDROID_PREFIX) || clsName.startsWith(JAVA_PREFIX)) {
+    if (clsName.startsWith("android.") || clsName.startsWith("java.")
+        || clsName.startsWith("androidx.")) {
       if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
-      return NO_OP;
+      return null;
     }
     try {
-      Class<?> injector = Class.forName(clsName + ButterKnifeProcessor.SUFFIX);
-      inject = injector.getMethod("reset", cls);
-      if (debug) Log.d(TAG, "HIT: Class loaded injection class.");
+      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");
+      //noinspection unchecked
+      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
+      if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
     } catch (ClassNotFoundException e) {
       if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
-      inject = findResettersForClass(cls.getSuperclass());
+      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
     }
-    RESETTERS.put(cls, inject);
-    return inject;
-  }
-
-  /** Apply the specified {@code action} across the {@code list} of views. */
-  public static <T extends View> void apply(List<T> list, Action<? super T> action) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      action.apply(list.get(i), i);
-    }
-  }
-
-  /** Set the {@code value} using the specified {@code setter} across the {@code list} of views. */
-  public static <T extends View, V> void apply(List<T> list, Setter<? super T, V> setter, V value) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value, i);
-    }
-  }
-
-  /**
-   * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
-   */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  public static <T extends View, V> void apply(List<T> list, Property<? super T, V> setter,
-      V value) {
-    //noinspection ForLoopReplaceableByForEach
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value);
-    }
-  }
-
-  /** Simpler version of {@link View#findViewById(int)} which infers the target type. */
-  @SuppressWarnings({ "unchecked", "UnusedDeclaration" }) // Checked by runtime cast. Public API.
-  public static <T extends View> T findById(View view, int id) {
-    return (T) view.findViewById(id);
-  }
-
-  /** Simpler version of {@link Activity#findViewById(int)} which infers the target type. */
-  @SuppressWarnings({ "unchecked", "UnusedDeclaration" }) // Checked by runtime cast. Public API.
-  public static <T extends View> T findById(Activity activity, int id) {
-    return (T) activity.findViewById(id);
-  }
-
-  /** Simpler version of {@link Dialog#findViewById(int)} which infers the target type. */
-  @SuppressWarnings({ "unchecked", "UnusedDeclaration" }) // Checked by runtime cast. Public API.
-  public static <T extends View> T findById(Dialog dialog, int id) {
-    return (T) dialog.findViewById(id);
+    BINDINGS.put(cls, bindingCtor);
+    return bindingCtor;
   }
 }
diff --git a/butterknife/src/main/java/butterknife/InjectViews.java b/butterknife/src/main/java/butterknife/InjectViews.java
deleted file mode 100644
index 0a5145f6..00000000
--- a/butterknife/src/main/java/butterknife/InjectViews.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package butterknife;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import java.util.List;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.RetentionPolicy.CLASS;
-
-/**
- * Bind a field to the view for each ID specified in a {@link List} or array. Each view will
- * automatically be cast to the list or array type.
- * <pre><code>
- * {@literal @}InjectViews({R.id.first_name, R.id.middle_name, R.id.last_name})
- * List&lt;TextView&gt; nameViews;
- *
- * {@literal @}InjectViews({R.id.address_line_1, R.id.address_line_2})
- * EditText[] addressViews;
- * </code></pre>
- */
-@Retention(CLASS) @Target(FIELD)
-public @interface InjectViews {
-  /** View IDs to which the field will be bound. */
-  int[] value();
-}
diff --git a/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java b/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java
deleted file mode 100644
index 9eb91d7d..00000000
--- a/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java
+++ /dev/null
@@ -1,619 +0,0 @@
-package butterknife.internal;
-
-import butterknife.InjectView;
-import butterknife.InjectViews;
-import butterknife.OnCheckedChanged;
-import butterknife.OnClick;
-import butterknife.OnEditorAction;
-import butterknife.OnFocusChange;
-import butterknife.OnItemClick;
-import butterknife.OnItemLongClick;
-import butterknife.OnItemSelected;
-import butterknife.OnLongClick;
-import butterknife.OnPageChange;
-import butterknife.OnTextChanged;
-import butterknife.OnTouch;
-import butterknife.Optional;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Filer;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.JavaFileObject;
-
-import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.tools.Diagnostic.Kind.ERROR;
-
-public final class ButterKnifeProcessor extends AbstractProcessor {
-  public static final String SUFFIX = "$$ViewInjector";
-  public static final String ANDROID_PREFIX = "android.";
-  public static final String JAVA_PREFIX = "java.";
-  static final String VIEW_TYPE = "android.view.View";
-  private static final String LIST_TYPE = List.class.getCanonicalName();
-  private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
-      OnCheckedChanged.class, //
-      OnClick.class, //
-      OnEditorAction.class, //
-      OnFocusChange.class, //
-      OnItemClick.class, //
-      OnItemLongClick.class, //
-      OnItemSelected.class, //
-      OnLongClick.class, //
-      OnPageChange.class, //
-      OnTextChanged.class, //
-      OnTouch.class //
-  );
-
-  private Elements elementUtils;
-  private Types typeUtils;
-  private Filer filer;
-
-  @Override public synchronized void init(ProcessingEnvironment env) {
-    super.init(env);
-
-    elementUtils = env.getElementUtils();
-    typeUtils = env.getTypeUtils();
-    filer = env.getFiler();
-  }
-
-  @Override public Set<String> getSupportedAnnotationTypes() {
-    Set<String> supportTypes = new LinkedHashSet<String>();
-    supportTypes.add(InjectView.class.getCanonicalName());
-    supportTypes.add(InjectViews.class.getCanonicalName());
-    for (Class<? extends Annotation> listener : LISTENERS) {
-      supportTypes.add(listener.getCanonicalName());
-    }
-
-    return supportTypes;
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
-    Map<TypeElement, ViewInjector> targetClassMap = findAndParseTargets(env);
-
-    for (Map.Entry<TypeElement, ViewInjector> entry : targetClassMap.entrySet()) {
-      TypeElement typeElement = entry.getKey();
-      ViewInjector viewInjector = entry.getValue();
-
-      try {
-        JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);
-        Writer writer = jfo.openWriter();
-        writer.write(viewInjector.brewJava());
-        writer.flush();
-        writer.close();
-      } catch (IOException e) {
-        error(typeElement, "Unable to write injector for type %s: %s", typeElement, e.getMessage());
-      }
-    }
-
-    return true;
-  }
-
-  private Map<TypeElement, ViewInjector> findAndParseTargets(RoundEnvironment env) {
-    Map<TypeElement, ViewInjector> targetClassMap = new LinkedHashMap<TypeElement, ViewInjector>();
-    Set<String> erasedTargetNames = new LinkedHashSet<String>();
-
-    // Process each @InjectView element.
-    for (Element element : env.getElementsAnnotatedWith(InjectView.class)) {
-      try {
-        parseInjectView(element, targetClassMap, erasedTargetNames);
-      } catch (Exception e) {
-        StringWriter stackTrace = new StringWriter();
-        e.printStackTrace(new PrintWriter(stackTrace));
-
-        error(element, "Unable to generate view injector for @InjectView.\n\n%s", stackTrace);
-      }
-    }
-
-    // Process each @InjectViews element.
-    for (Element element : env.getElementsAnnotatedWith(InjectViews.class)) {
-      try {
-        parseInjectViews(element, targetClassMap, erasedTargetNames);
-      } catch (Exception e) {
-        StringWriter stackTrace = new StringWriter();
-        e.printStackTrace(new PrintWriter(stackTrace));
-
-        error(element, "Unable to generate view injector for @InjectViews.\n\n%s", stackTrace);
-      }
-    }
-
-    // Process each annotation that corresponds to a listener.
-    for (Class<? extends Annotation> listener : LISTENERS) {
-      findAndParseListener(env, listener, targetClassMap, erasedTargetNames);
-    }
-
-    // Try to find a parent injector for each injector.
-    for (Map.Entry<TypeElement, ViewInjector> entry : targetClassMap.entrySet()) {
-      String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetNames);
-      if (parentClassFqcn != null) {
-        entry.getValue().setParentInjector(parentClassFqcn + SUFFIX);
-      }
-    }
-
-    return targetClassMap;
-  }
-
-  private boolean isValidForGeneratedCode(Class<? extends Annotation> annotationClass,
-      String targetThing, Element element) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify method modifiers.
-    Set<Modifier> modifiers = element.getModifiers();
-    if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
-      error(element, "@%s %s must not be private or static. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
-
-    // Verify containing type.
-    if (enclosingElement.getKind() != CLASS) {
-      error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
-
-    // Verify containing class visibility is not private.
-    if (enclosingElement.getModifiers().contains(PRIVATE)) {
-      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
-
-    return hasError;
-  }
-
-  private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
-      Element element) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-    String qualifiedName = enclosingElement.getQualifiedName().toString();
-
-    if (qualifiedName.startsWith(ANDROID_PREFIX)) {
-      error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
-    }
-    if (qualifiedName.startsWith(JAVA_PREFIX)) {
-      error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
-    }
-
-    return false;
-  }
-
-  private void parseInjectView(Element element, Map<TypeElement, ViewInjector> targetClassMap,
-      Set<String> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type extends from View.
-    TypeMirror elementType = element.asType();
-    if (elementType instanceof TypeVariable) {
-      TypeVariable typeVariable = (TypeVariable) elementType;
-      elementType = typeVariable.getUpperBound();
-    }
-    if (!isSubtypeOfType(elementType, VIEW_TYPE)) {
-      error(element, "@InjectView fields must extend from View. (%s.%s)",
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-
-    // Verify common generated code restrictions.
-    hasError |= isValidForGeneratedCode(InjectView.class, "fields", element);
-    hasError |= isBindingInWrongPackage(InjectView.class, element);
-
-    // Check for the other field annotation.
-    if (element.getAnnotation(InjectViews.class) != null) {
-      error(element, "Only one of @InjectView and @InjectViews is allowed. (%s.%s)",
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-
-    if (hasError) {
-      return;
-    }
-
-    // Assemble information on the injection point.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(InjectView.class).value();
-    String type = elementType.toString();
-    boolean required = element.getAnnotation(Optional.class) == null;
-
-    ViewInjector viewInjector = getOrCreateTargetClass(targetClassMap, enclosingElement);
-    ViewBinding binding = new ViewBinding(name, type, required);
-    viewInjector.addView(id, binding);
-
-    // Add the type-erased version to the valid injection targets set.
-    erasedTargetNames.add(enclosingElement.toString());
-  }
-
-  private void parseInjectViews(Element element, Map<TypeElement, ViewInjector> targetClassMap,
-      Set<String> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the type is a List or an array.
-    TypeMirror elementType = element.asType();
-    String erasedType = doubleErasure(elementType);
-    TypeMirror viewType = null;
-    CollectionBinding.Kind kind = null;
-    if (elementType.getKind() == TypeKind.ARRAY) {
-      ArrayType arrayType = (ArrayType) elementType;
-      viewType = arrayType.getComponentType();
-      kind = CollectionBinding.Kind.ARRAY;
-    } else if (LIST_TYPE.equals(erasedType)) {
-      DeclaredType declaredType = (DeclaredType) elementType;
-      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-      if (typeArguments.size() != 1) {
-        error(element, "@InjectViews List must have a generic component. (%s.%s)",
-            enclosingElement.getQualifiedName(), element.getSimpleName());
-        hasError = true;
-      } else {
-        viewType = typeArguments.get(0);
-      }
-      kind = CollectionBinding.Kind.LIST;
-    } else {
-      error(element, "@InjectViews must be a List or array. (%s.%s)",
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-    if (viewType instanceof TypeVariable) {
-      TypeVariable typeVariable = (TypeVariable) viewType;
-      viewType = typeVariable.getUpperBound();
-    }
-
-    // Verify that the target type extends from View.
-    if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE)) {
-      error(element, "@InjectViews type must extend from View. (%s.%s)",
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-
-    // Verify common generated code restrictions.
-    hasError |= isValidForGeneratedCode(InjectViews.class, "fields", element);
-    hasError |= isBindingInWrongPackage(InjectViews.class, element);
-
-    if (hasError) {
-      return;
-    }
-
-    // Assemble information on the injection point.
-    String name = element.getSimpleName().toString();
-    int[] ids = element.getAnnotation(InjectViews.class).value();
-    if (ids.length == 0) {
-      error(element, "@InjectViews must specify at least one ID. (%s.%s)",
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      return;
-    }
-
-    assert viewType != null; // Always false as hasError would have been true.
-    String type = viewType.toString();
-    boolean required = element.getAnnotation(Optional.class) == null;
-
-    ViewInjector viewInjector = getOrCreateTargetClass(targetClassMap, enclosingElement);
-    CollectionBinding binding = new CollectionBinding(name, type, kind, required);
-    viewInjector.addCollection(ids, binding);
-
-    erasedTargetNames.add(enclosingElement.toString());
-  }
-
-  /** Uses both {@link Types#erasure} and string manipulation to strip any generic types. */
-  private String doubleErasure(TypeMirror elementType) {
-    String name = typeUtils.erasure(elementType).toString();
-    int typeParamStart = name.indexOf('<');
-    if (typeParamStart != -1) {
-      name = name.substring(0, typeParamStart);
-    }
-    return name;
-  }
-
-  private void findAndParseListener(RoundEnvironment env,
-      Class<? extends Annotation> annotationClass, Map<TypeElement, ViewInjector> targetClassMap,
-      Set<String> erasedTargetNames) {
-    for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
-      try {
-        parseListenerAnnotation(annotationClass, element, targetClassMap, erasedTargetNames);
-      } catch (Exception e) {
-        StringWriter stackTrace = new StringWriter();
-        e.printStackTrace(new PrintWriter(stackTrace));
-
-        error(element, "Unable to generate view injector for @%s.\n\n%s",
-            annotationClass.getSimpleName(), stackTrace.toString());
-      }
-    }
-  }
-
-  private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
-      Map<TypeElement, ViewInjector> targetClassMap, Set<String> erasedTargetNames)
-      throws Exception {
-    // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
-    if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
-      throw new IllegalStateException(
-          String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
-    }
-
-    ExecutableElement executableElement = (ExecutableElement) element;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Assemble information on the injection point.
-    Annotation annotation = element.getAnnotation(annotationClass);
-    Method annotationValue = annotationClass.getDeclaredMethod("value");
-    if (annotationValue.getReturnType() != int[].class) {
-      throw new IllegalStateException(
-          String.format("@%s annotation value() type not int[].", annotationClass));
-    }
-
-    int[] ids = (int[]) annotationValue.invoke(annotation);
-    String name = executableElement.getSimpleName().toString();
-    boolean required = element.getAnnotation(Optional.class) == null;
-
-    // Verify that the method and its containing class are accessible via generated code.
-    boolean hasError = isValidForGeneratedCode(annotationClass, "methods", element);
-    hasError |= isBindingInWrongPackage(annotationClass, element);
-
-    Set<Integer> seenIds = new LinkedHashSet<Integer>();
-    for (int id : ids) {
-      if (!seenIds.add(id)) {
-        error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
-            annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-        hasError = true;
-      }
-    }
-
-    ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
-    if (listener == null) {
-      throw new IllegalStateException(
-          String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
-              annotationClass.getSimpleName()));
-    }
-
-    ListenerMethod method;
-    ListenerMethod[] methods = listener.method();
-    if (methods.length > 1) {
-      throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
-          annotationClass.getSimpleName()));
-    } else if (methods.length == 1) {
-      if (listener.callbacks() != ListenerClass.NONE.class) {
-        throw new IllegalStateException(
-            String.format("Both method() and callback() defined on @%s.",
-                annotationClass.getSimpleName()));
-      }
-      method = methods[0];
-    } else {
-      Method annotationCallback = annotationClass.getDeclaredMethod("callback");
-      Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
-      Field callbackField = callback.getDeclaringClass().getField(callback.name());
-      method = callbackField.getAnnotation(ListenerMethod.class);
-      if (method == null) {
-        throw new IllegalStateException(
-            String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
-                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
-                callback.name()));
-      }
-    }
-
-    // Verify that the method has equal to or less than the number of parameters as the listener.
-    List<? extends VariableElement> methodParameters = executableElement.getParameters();
-    if (methodParameters.size() > method.parameters().length) {
-      error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
-          annotationClass.getSimpleName(), method.parameters().length,
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-
-    // Verify method return type matches the listener.
-    TypeMirror returnType = executableElement.getReturnType();
-    if (returnType instanceof TypeVariable) {
-      TypeVariable typeVariable = (TypeVariable) returnType;
-      returnType = typeVariable.getUpperBound();
-    }
-    if (!returnType.toString().equals(method.returnType())) {
-      error(element, "@%s methods must have a '%s' return type. (%s.%s)",
-          annotationClass.getSimpleName(), method.returnType(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-
-    if (hasError) {
-      return;
-    }
-
-    Parameter[] parameters = Parameter.NONE;
-    if (!methodParameters.isEmpty()) {
-      parameters = new Parameter[methodParameters.size()];
-      BitSet methodParameterUsed = new BitSet(methodParameters.size());
-      String[] parameterTypes = method.parameters();
-      for (int i = 0; i < methodParameters.size(); i++) {
-        VariableElement methodParameter = methodParameters.get(i);
-        TypeMirror methodParameterType = methodParameter.asType();
-        if (methodParameterType instanceof TypeVariable) {
-          TypeVariable typeVariable = (TypeVariable) methodParameterType;
-          methodParameterType = typeVariable.getUpperBound();
-        }
-
-        for (int j = 0; j < parameterTypes.length; j++) {
-          if (methodParameterUsed.get(j)) {
-            continue;
-          }
-          if (isSubtypeOfType(methodParameterType, parameterTypes[j])) {
-            parameters[i] = new Parameter(j, methodParameterType.toString());
-            methodParameterUsed.set(j);
-            break;
-          }
-        }
-        if (parameters[i] == null) {
-          StringBuilder builder = new StringBuilder();
-          builder.append("Unable to match @")
-              .append(annotationClass.getSimpleName())
-              .append(" method arguments. (")
-              .append(enclosingElement.getQualifiedName())
-              .append('.')
-              .append(element.getSimpleName())
-              .append(')');
-          for (int j = 0; j < parameters.length; j++) {
-            Parameter parameter = parameters[j];
-            builder.append("\n\n  Parameter #")
-                .append(j + 1)
-                .append(": ")
-                .append(methodParameters.get(j).asType().toString())
-                .append("\n    ");
-            if (parameter == null) {
-              builder.append("did not match any listener parameters");
-            } else {
-              builder.append("matched listener parameter #")
-                  .append(parameter.getListenerPosition() + 1)
-                  .append(": ")
-                  .append(parameter.getType());
-            }
-          }
-          builder.append("\n\nMethods may have up to ")
-              .append(method.parameters().length)
-              .append(" parameter(s):\n");
-          for (String parameterType : method.parameters()) {
-            builder.append("\n  ").append(parameterType);
-          }
-          builder.append(
-              "\n\nThese may be listed in any order but will be searched for from top to bottom.");
-          error(executableElement, builder.toString());
-          return;
-        }
-      }
-    }
-
-    ListenerBinding binding = new ListenerBinding(name, Arrays.asList(parameters), required);
-    ViewInjector viewInjector = getOrCreateTargetClass(targetClassMap, enclosingElement);
-    for (int id : ids) {
-      if (!viewInjector.addListener(id, listener, method, binding)) {
-        error(element, "Multiple @%s methods declared for ID %s in %s.",
-            annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName());
-        return;
-      }
-    }
-
-    // Add the type-erased version to the valid injection targets set.
-    erasedTargetNames.add(enclosingElement.toString());
-  }
-
-  private boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
-    if (otherType.equals(typeMirror.toString())) {
-      return true;
-    }
-    if (!(typeMirror instanceof DeclaredType)) {
-      return false;
-    }
-    DeclaredType declaredType = (DeclaredType) typeMirror;
-    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-    if (typeArguments.size() > 0) {
-      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
-      typeString.append('<');
-      for (int i = 0; i < typeArguments.size(); i++) {
-        if (i > 0) {
-          typeString.append(',');
-        }
-        typeString.append('?');
-      }
-      typeString.append('>');
-      if (typeString.toString().equals(otherType)) {
-        return true;
-      }
-    }
-    Element element = declaredType.asElement();
-    if (!(element instanceof TypeElement)) {
-      return false;
-    }
-    TypeElement typeElement = (TypeElement) element;
-    TypeMirror superType = typeElement.getSuperclass();
-    if (isSubtypeOfType(superType, otherType)) {
-      return true;
-    }
-    for (TypeMirror interfaceType : typeElement.getInterfaces()) {
-      if (isSubtypeOfType(interfaceType, otherType)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private ViewInjector getOrCreateTargetClass(Map<TypeElement, ViewInjector> targetClassMap,
-      TypeElement enclosingElement) {
-    ViewInjector viewInjector = targetClassMap.get(enclosingElement);
-    if (viewInjector == null) {
-      String targetType = enclosingElement.getQualifiedName().toString();
-      String classPackage = getPackageName(enclosingElement);
-      String className = getClassName(enclosingElement, classPackage) + SUFFIX;
-
-      viewInjector = new ViewInjector(classPackage, className, targetType);
-      targetClassMap.put(enclosingElement, viewInjector);
-    }
-    return viewInjector;
-  }
-
-  private static String getClassName(TypeElement type, String packageName) {
-    int packageLen = packageName.length() + 1;
-    return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
-  }
-
-  /** Finds the parent injector type in the supplied set, if any. */
-  private String findParentFqcn(TypeElement typeElement, Set<String> parents) {
-    TypeMirror type;
-    while (true) {
-      type = typeElement.getSuperclass();
-      if (type.getKind() == TypeKind.NONE) {
-        return null;
-      }
-      typeElement = (TypeElement) ((DeclaredType) type).asElement();
-      if (parents.contains(typeElement.toString())) {
-        String packageName = getPackageName(typeElement);
-        return packageName + "." + getClassName(typeElement, packageName);
-      }
-    }
-  }
-
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
-
-  private void error(Element element, String message, Object... args) {
-    if (args.length > 0) {
-      message = String.format(message, args);
-    }
-    processingEnv.getMessager().printMessage(ERROR, message, element);
-  }
-
-  private String getPackageName(TypeElement type) {
-    return elementUtils.getPackageOf(type).getQualifiedName().toString();
-  }
-}
diff --git a/butterknife/src/main/java/butterknife/internal/CollectionBinding.java b/butterknife/src/main/java/butterknife/internal/CollectionBinding.java
deleted file mode 100644
index 4ae18327..00000000
--- a/butterknife/src/main/java/butterknife/internal/CollectionBinding.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package butterknife.internal;
-
-final class CollectionBinding implements Binding {
-  enum Kind {
-    ARRAY,
-    LIST
-  }
-
-  private final String name;
-  private final String type;
-  private final Kind kind;
-  private final boolean required;
-
-  CollectionBinding(String name, String type, Kind kind, boolean required) {
-    this.name = name;
-    this.type = type;
-    this.kind = kind;
-    this.required = required;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public String getType() {
-    return type;
-  }
-
-  public Kind getKind() {
-    return kind;
-  }
-
-  public boolean isRequired() {
-    return required;
-  }
-
-  @Override public String getDescription() {
-    return "field '" + name + "'";
-  }
-}
diff --git a/butterknife/src/main/java/butterknife/internal/DebouncedOnClickListener.java b/butterknife/src/main/java/butterknife/internal/DebouncedOnClickListener.java
deleted file mode 100644
index 9117f0ed..00000000
--- a/butterknife/src/main/java/butterknife/internal/DebouncedOnClickListener.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package butterknife.internal;
-
-import android.view.View;
-
-/**
- * A {@link View.OnClickListener} that enables debouncing of multiple clicks posted in a row.
- *
- * Once a click is fired, a post is enqueued to the main thread looper queue and no further click
- * is allowed until that post is dequeued.
- *
- * A click on one button disables all buttons.
- *
- */
-public abstract class DebouncedOnClickListener implements View.OnClickListener {
-
-  /**
-   * This is static because we want to disable clicks for all click listeners.
-   */
-  private static boolean enabled = true;
-
-  private static final Runnable ENABLE_AGAIN = new Runnable() {
-    @Override public void run() {
-      enabled = true;
-    }
-  };
-
-  @Override public final void onClick(View v) {
-    if (enabled) {
-      enabled = false;
-      v.post(ENABLE_AGAIN);
-      doClick(v);
-    }
-  }
-
-  public abstract void doClick(View v);
-}
diff --git a/butterknife/src/main/java/butterknife/internal/ViewBinding.java b/butterknife/src/main/java/butterknife/internal/ViewBinding.java
deleted file mode 100644
index 328371fc..00000000
--- a/butterknife/src/main/java/butterknife/internal/ViewBinding.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package butterknife.internal;
-
-final class ViewBinding implements Binding {
-  private final String name;
-  private final String type;
-  private final boolean required;
-
-  ViewBinding(String name, String type, boolean required) {
-    this.name = name;
-    this.type = type;
-    this.required = required;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public String getType() {
-    return type;
-  }
-
-  @Override public String getDescription() {
-    return "field '" + name + "'";
-  }
-
-  public boolean isRequired() {
-    return required;
-  }
-}
diff --git a/butterknife/src/main/java/butterknife/internal/ViewInjection.java b/butterknife/src/main/java/butterknife/internal/ViewInjection.java
deleted file mode 100644
index b83c4c32..00000000
--- a/butterknife/src/main/java/butterknife/internal/ViewInjection.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package butterknife.internal;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-final class ViewInjection {
-  private final int id;
-  private final Set<ViewBinding> viewBindings = new LinkedHashSet<ViewBinding>();
-  private final Map<ListenerClass, Map<ListenerMethod, ListenerBinding>> listenerBindings =
-      new LinkedHashMap<ListenerClass, Map<ListenerMethod, ListenerBinding>>();
-
-  ViewInjection(int id) {
-    this.id = id;
-  }
-
-  public int getId() {
-    return id;
-  }
-
-  public Collection<ViewBinding> getViewBindings() {
-    return viewBindings;
-  }
-
-  public Map<ListenerClass, Map<ListenerMethod, ListenerBinding>> getListenerBindings() {
-    return listenerBindings;
-  }
-
-  public boolean hasListenerBinding(ListenerClass listener, ListenerMethod method) {
-    Map<ListenerMethod, ListenerBinding> methods = listenerBindings.get(listener);
-    return methods != null && methods.containsKey(method);
-  }
-
-  public void addListenerBinding(ListenerClass listener, ListenerMethod method,
-      ListenerBinding binding) {
-    Map<ListenerMethod, ListenerBinding> methods = listenerBindings.get(listener);
-    if (methods == null) {
-      methods = new LinkedHashMap<ListenerMethod, ListenerBinding>();
-      listenerBindings.put(listener, methods);
-    }
-    ListenerBinding existing = methods.get(method);
-    if (existing != null) {
-      throw new IllegalStateException("View "
-          + id
-          + " already has listener binding for "
-          + listener.type()
-          + "."
-          + method.name()
-          + " on "
-          + existing.getDescription());
-    }
-    methods.put(method, binding);
-  }
-
-  public void addViewBinding(ViewBinding viewBinding) {
-    viewBindings.add(viewBinding);
-  }
-
-  public List<Binding> getRequiredBindings() {
-    List<Binding> requiredBindings = new ArrayList<Binding>();
-    for (ViewBinding viewBinding : viewBindings) {
-      if (viewBinding.isRequired()) {
-        requiredBindings.add(viewBinding);
-      }
-    }
-    for (Map<ListenerMethod, ListenerBinding> methodBinding : listenerBindings.values()) {
-      for (ListenerBinding binding : methodBinding.values()) {
-        if (binding.isRequired()) {
-          requiredBindings.add(binding);
-        }
-      }
-    }
-    return requiredBindings;
-  }
-}
diff --git a/butterknife/src/main/java/butterknife/internal/ViewInjector.java b/butterknife/src/main/java/butterknife/internal/ViewInjector.java
deleted file mode 100644
index ff4f9c99..00000000
--- a/butterknife/src/main/java/butterknife/internal/ViewInjector.java
+++ /dev/null
@@ -1,371 +0,0 @@
-package butterknife.internal;
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import static butterknife.internal.ButterKnifeProcessor.VIEW_TYPE;
-
-final class ViewInjector {
-  private final Map<Integer, ViewInjection> viewIdMap = new LinkedHashMap<Integer, ViewInjection>();
-  private final Map<CollectionBinding, int[]> collectionBindings =
-      new LinkedHashMap<CollectionBinding, int[]>();
-  private final String classPackage;
-  private final String className;
-  private final String targetClass;
-  private String parentInjector;
-
-  ViewInjector(String classPackage, String className, String targetClass) {
-    this.classPackage = classPackage;
-    this.className = className;
-    this.targetClass = targetClass;
-  }
-
-  void addView(int id, ViewBinding binding) {
-    getOrCreateViewInjection(id).addViewBinding(binding);
-  }
-
-  boolean addListener(int id, ListenerClass listener, ListenerMethod method,
-      ListenerBinding binding) {
-    ViewInjection viewInjection = getOrCreateViewInjection(id);
-    if (viewInjection.hasListenerBinding(listener, method)) {
-      return false;
-    }
-    viewInjection.addListenerBinding(listener, method, binding);
-    return true;
-  }
-
-  void addCollection(int[] ids, CollectionBinding binding) {
-    collectionBindings.put(binding, ids);
-  }
-
-  void setParentInjector(String parentInjector) {
-    this.parentInjector = parentInjector;
-  }
-
-  private ViewInjection getOrCreateViewInjection(int id) {
-    ViewInjection viewId = viewIdMap.get(id);
-    if (viewId == null) {
-      viewId = new ViewInjection(id);
-      viewIdMap.put(id, viewId);
-    }
-    return viewId;
-  }
-
-  String getFqcn() {
-    return classPackage + "." + className;
-  }
-
-  String brewJava() {
-    StringBuilder builder = new StringBuilder();
-    builder.append("// Generated code from Butter Knife. Do not modify!\n");
-    builder.append("package ").append(classPackage).append(";\n\n");
-    builder.append("import android.view.View;\n");
-    builder.append("import butterknife.ButterKnife.Finder;\n\n");
-    builder.append("public class ").append(className).append(" {\n");
-    emitInject(builder);
-    builder.append('\n');
-    emitReset(builder);
-    builder.append("}\n");
-    return builder.toString();
-  }
-
-  private void emitInject(StringBuilder builder) {
-    builder.append("  public static void inject(Finder finder, final ")
-        .append(targetClass)
-        .append(" target, Object source) {\n");
-
-    // Emit a call to the superclass injector, if any.
-    if (parentInjector != null) {
-      builder.append("    ")
-          .append(parentInjector)
-          .append(".inject(finder, target, source);\n\n");
-    }
-
-    // Local variable in which all views will be temporarily stored.
-    builder.append("    View view;\n");
-
-    // Loop over each view injection and emit it.
-    for (ViewInjection injection : viewIdMap.values()) {
-      emitViewInjection(builder, injection);
-    }
-
-    // Loop over each collection binding and emit it.
-    for (Map.Entry<CollectionBinding, int[]> entry : collectionBindings.entrySet()) {
-      emitCollectionBinding(builder, entry.getKey(), entry.getValue());
-    }
-
-    builder.append("  }\n");
-  }
-
-  private void emitCollectionBinding(StringBuilder builder, CollectionBinding binding, int[] ids) {
-    builder.append("    target.").append(binding.getName()).append(" = ");
-
-    switch (binding.getKind()) {
-      case ARRAY:
-        builder.append("Finder.arrayOf(");
-        break;
-      case LIST:
-        builder.append("Finder.listOf(");
-        break;
-      default:
-        throw new IllegalStateException("Unknown kind: " + binding.getKind());
-    }
-
-    for (int i = 0; i < ids.length; i++) {
-      if (i > 0) {
-        builder.append(',');
-      }
-      builder.append("\n        ");
-      emitCastIfNeeded(builder, binding.getType());
-      if (binding.isRequired()) {
-        builder.append("finder.findRequiredView(source, ")
-            .append(ids[i])
-            .append(", \"")
-            .append(binding.getName())
-            .append("\")");
-      } else {
-        builder.append("finder.findOptionalView(source, ")
-            .append(ids[i])
-            .append(")");
-      }
-    }
-
-    builder.append("\n    );");
-  }
-
-  private void emitViewInjection(StringBuilder builder, ViewInjection injection) {
-    builder.append("    view = ");
-
-    List<Binding> requiredBindings = injection.getRequiredBindings();
-    if (requiredBindings.isEmpty()) {
-      builder.append("finder.findOptionalView(source, ")
-          .append(injection.getId())
-          .append(");\n");
-    } else {
-      builder.append("finder.findRequiredView(source, ")
-          .append(injection.getId())
-          .append(", \"");
-      emitHumanDescription(builder, requiredBindings);
-      builder.append("\");\n");
-    }
-
-    emitViewBindings(builder, injection);
-    emitListenerBindings(builder, injection);
-  }
-
-  private void emitViewBindings(StringBuilder builder, ViewInjection injection) {
-    Collection<ViewBinding> viewBindings = injection.getViewBindings();
-    if (viewBindings.isEmpty()) {
-      return;
-    }
-
-    for (ViewBinding viewBinding : viewBindings) {
-      builder.append("    target.")
-          .append(viewBinding.getName())
-          .append(" = ");
-      emitCastIfNeeded(builder, viewBinding.getType());
-      builder.append("view;\n");
-    }
-  }
-
-  private void emitListenerBindings(StringBuilder builder, ViewInjection injection) {
-    Map<ListenerClass, Map<ListenerMethod, ListenerBinding>> bindings =
-        injection.getListenerBindings();
-    if (bindings.isEmpty()) {
-      return;
-    }
-
-    String extraIndent = "";
-
-    // We only need to emit the null check if there are zero required bindings.
-    boolean needsNullChecked = injection.getRequiredBindings().isEmpty();
-    if (needsNullChecked) {
-      builder.append("    if (view != null) {\n");
-      extraIndent = "  ";
-    }
-
-    for (Map.Entry<ListenerClass, Map<ListenerMethod, ListenerBinding>> e : bindings.entrySet()) {
-      ListenerClass listener = e.getKey();
-      Map<ListenerMethod, ListenerBinding> methodBindings = e.getValue();
-
-      // Emit: ((OWNER_TYPE) view).SETTER_NAME(
-      boolean needsCast = !VIEW_TYPE.equals(listener.targetType());
-      builder.append(extraIndent)
-          .append("    ");
-      if (needsCast) {
-        builder.append("((").append(listener.targetType());
-        if (listener.genericArguments() > 0) {
-          builder.append('<');
-          for (int i = 0; i < listener.genericArguments(); i++) {
-            if (i > 0) {
-              builder.append(", ");
-            }
-            builder.append('?');
-          }
-          builder.append('>');
-        }
-        builder.append(") ");
-      }
-      builder.append("view");
-      if (needsCast) {
-        builder.append(')');
-      }
-      builder.append('.')
-          .append(listener.setter())
-          .append("(\n");
-
-      // Emit: new TYPE() {
-      builder.append(extraIndent)
-          .append("      new ")
-          .append(listener.type())
-          .append("() {\n");
-
-      for (ListenerMethod method : getListenerMethods(listener)) {
-        // Emit: @Override public RETURN_TYPE METHOD_NAME(
-        builder.append(extraIndent)
-            .append("        @Override public ")
-            .append(method.returnType())
-            .append(' ')
-            .append(method.name())
-            .append("(\n");
-
-        // Emit listener method arguments, each on their own line.
-        String[] parameterTypes = method.parameters();
-        for (int i = 0, count = parameterTypes.length; i < count; i++) {
-          builder.append(extraIndent)
-              .append("          ")
-              .append(parameterTypes[i])
-              .append(" p")
-              .append(i);
-          if (i < count - 1) {
-            builder.append(',');
-          }
-          builder.append('\n');
-        }
-
-        // Emit end of parameters, start of body.
-        builder.append(extraIndent).append("        ) {\n");
-
-        // Set up the return statement, if needed.
-        builder.append(extraIndent).append("          ");
-        boolean hasReturnType = !"void".equals(method.returnType());
-        if (hasReturnType) {
-          builder.append("return ");
-        }
-
-        if (methodBindings.containsKey(method)) {
-          ListenerBinding binding = methodBindings.get(method);
-          builder.append("target.").append(binding.getName()).append('(');
-          List<Parameter> parameters = binding.getParameters();
-          String[] listenerParameters = method.parameters();
-          for (int i = 0, count = parameters.size(); i < count; i++) {
-            Parameter parameter = parameters.get(i);
-            int listenerPosition = parameter.getListenerPosition();
-            emitCastIfNeeded(builder, listenerParameters[listenerPosition], parameter.getType());
-            builder.append('p').append(listenerPosition);
-            if (i < count - 1) {
-              builder.append(", ");
-            }
-          }
-          builder.append(");");
-        } else if (hasReturnType) {
-          builder.append(method.defaultReturn()).append(';');
-        }
-        builder.append('\n');
-
-        // Emit end of listener method.
-        builder.append(extraIndent).append("        }\n");
-      }
-
-      // Emit end of listener class body and close the setter method call.
-      builder.append(extraIndent).append("      });\n");
-    }
-
-    if (needsNullChecked) {
-      builder.append("    }\n");
-    }
-  }
-
-  static List<ListenerMethod> getListenerMethods(ListenerClass listener) {
-    if (listener.method().length == 1) {
-      return Arrays.asList(listener.method());
-    }
-
-    try {
-      List<ListenerMethod> methods = new ArrayList<ListenerMethod>();
-      Class<? extends Enum<?>> callbacks = listener.callbacks();
-      for (Enum<?> callbackMethod : callbacks.getEnumConstants()) {
-        Field callbackField = callbacks.getField(callbackMethod.name());
-        ListenerMethod method = callbackField.getAnnotation(ListenerMethod.class);
-        if (method == null) {
-          throw new IllegalStateException(String.format("@%s's %s.%s missing @%s annotation.",
-              callbacks.getEnclosingClass().getSimpleName(), callbacks.getSimpleName(),
-              callbackMethod.name(), ListenerMethod.class.getSimpleName()));
-        }
-        methods.add(method);
-      }
-      return methods;
-    } catch (NoSuchFieldException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private void emitReset(StringBuilder builder) {
-    builder.append("  public static void reset(").append(targetClass).append(" target) {\n");
-    if (parentInjector != null) {
-      builder.append("    ")
-          .append(parentInjector)
-          .append(".reset(target);\n\n");
-    }
-    for (ViewInjection injection : viewIdMap.values()) {
-      for (ViewBinding viewBinding : injection.getViewBindings()) {
-        builder.append("    target.").append(viewBinding.getName()).append(" = null;\n");
-      }
-    }
-    for (CollectionBinding collectionBinding : collectionBindings.keySet()) {
-      builder.append("    target.").append(collectionBinding.getName()).append(" = null;\n");
-    }
-    builder.append("  }\n");
-  }
-
-  static void emitCastIfNeeded(StringBuilder builder, String viewType) {
-    emitCastIfNeeded(builder, VIEW_TYPE, viewType);
-  }
-
-  static void emitCastIfNeeded(StringBuilder builder, String sourceType, String destinationType) {
-    // Only emit a cast if the source and destination type do not match.
-    if (!sourceType.equals(destinationType)) {
-      builder.append('(').append(destinationType).append(") ");
-    }
-  }
-
-  static void emitHumanDescription(StringBuilder builder, List<Binding> bindings) {
-    switch (bindings.size()) {
-      case 1:
-        builder.append(bindings.get(0).getDescription());
-        break;
-      case 2:
-        builder.append(bindings.get(0).getDescription())
-            .append(" and ")
-            .append(bindings.get(1).getDescription());
-        break;
-      default:
-        for (int i = 0, count = bindings.size(); i < count; i++) {
-          Binding requiredField = bindings.get(i);
-          if (i != 0) {
-            builder.append(", ");
-          }
-          if (i == count - 1) {
-            builder.append("and ");
-          }
-          builder.append(requiredField.getDescription());
-        }
-        break;
-    }
-  }
-}
diff --git a/butterknife/src/main/java/butterknife/package-info.java b/butterknife/src/main/java/butterknife/package-info.java
index 2770d490..8b0a8718 100644
--- a/butterknife/src/main/java/butterknife/package-info.java
+++ b/butterknife/src/main/java/butterknife/package-info.java
@@ -1,19 +1,14 @@
 /**
- * View "injection" library for Android which uses annotation processing to generate boilerplate
- * code for you.
+ * Field and method binding for Android views which uses annotation processing to generate
+ * boilerplate code for you.
  * <p>
  * <ul>
  * <li>Eliminate {@link android.view.View#findViewById findViewById} calls by using
- * {@link butterknife.InjectView @InjectView} on fields.</li>
- * <li>Group multiple views in a {@linkplain java.util.List list} using
- * {@link butterknife.InjectViews @InjectViews}. Operate on all of them at once with
- * {@linkplain butterknife.ButterKnife#apply(java.util.List, butterknife.ButterKnife.Action)
- * actions}, {@linkplain butterknife.ButterKnife#apply(java.util.List,
- * butterknife.ButterKnife.Setter, Object) setters}, or
- * {@linkplain butterknife.ButterKnife#apply(java.util.List, android.util.Property, Object)
- * properties}.</li>
+ * {@link butterknife.BindView @BindView} on fields.</li>
+ * <li>Group multiple views in a {@linkplain java.util.List list} or array.
  * <li>Eliminate anonymous inner-classes for listeners by annotating methods with
  * {@link butterknife.OnClick @OnClick} and others.</li>
+ * <li>Eliminate resource lookups by using resource annotations on fields.</li>
  * </ul>
  */
 package butterknife;
diff --git a/butterknife/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/butterknife/src/main/resources/META-INF/services/javax.annotation.processing.Processor
deleted file mode 100644
index dda8ba87..00000000
--- a/butterknife/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ /dev/null
@@ -1 +0,0 @@
-butterknife.internal.ButterKnifeProcessor
diff --git a/butterknife/src/test/java/butterknife/ButterKnifeTest.java b/butterknife/src/test/java/butterknife/ButterKnifeTest.java
deleted file mode 100644
index 76fef637..00000000
--- a/butterknife/src/test/java/butterknife/ButterKnifeTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package butterknife;
-
-import android.app.Activity;
-import android.util.Property;
-import android.view.View;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import static org.fest.assertions.api.ANDROID.assertThat;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.entry;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class ButterKnifeTest {
-  private static final Property<View, Boolean> PROPERTY_ENABLED =
-      new Property<View, Boolean>(Boolean.class, "enabled") {
-        @Override public Boolean get(View view) {
-          return view.isEnabled();
-        }
-
-        @Override public void set(View view, Boolean enabled) {
-          view.setEnabled(enabled);
-        }
-      };
-  private static final ButterKnife.Setter<View, Boolean> SETTER_ENABLED =
-      new ButterKnife.Setter<View, Boolean>() {
-        @Override public void set(View view, Boolean value, int index) {
-          view.setEnabled(value);
-        }
-      };
-  private static final ButterKnife.Action<View> ACTION_DISABLE = new ButterKnife.Action<View>() {
-    @Override public void apply(View view, int index) {
-      view.setEnabled(false);
-    }
-  };
-
-  @Before @After // Clear out cache of injectors and resetters before and after each test.
-  public void resetViewsCache() {
-    ButterKnife.INJECTORS.clear();
-    ButterKnife.RESETTERS.clear();
-  }
-
-  @Test public void propertyAppliedToEveryView() {
-    View view1 = new View(Robolectric.application);
-    View view2 = new View(Robolectric.application);
-    View view3 = new View(Robolectric.application);
-    assertThat(view1).isEnabled();
-    assertThat(view2).isEnabled();
-    assertThat(view3).isEnabled();
-
-    List<View> views = Arrays.asList(view1, view2, view3);
-    ButterKnife.apply(views, PROPERTY_ENABLED, false);
-
-    assertThat(view1).isDisabled();
-    assertThat(view2).isDisabled();
-    assertThat(view3).isDisabled();
-  }
-
-  @Test public void actionAppliedToEveryView() {
-    View view1 = new View(Robolectric.application);
-    View view2 = new View(Robolectric.application);
-    View view3 = new View(Robolectric.application);
-    assertThat(view1).isEnabled();
-    assertThat(view2).isEnabled();
-    assertThat(view3).isEnabled();
-
-    List<View> views = Arrays.asList(view1, view2, view3);
-    ButterKnife.apply(views, ACTION_DISABLE);
-
-    assertThat(view1).isDisabled();
-    assertThat(view2).isDisabled();
-    assertThat(view3).isDisabled();
-  }
-
-  @Test public void setterAppliedToEveryView() {
-    View view1 = new View(Robolectric.application);
-    View view2 = new View(Robolectric.application);
-    View view3 = new View(Robolectric.application);
-    assertThat(view1).isEnabled();
-    assertThat(view2).isEnabled();
-    assertThat(view3).isEnabled();
-
-    List<View> views = Arrays.asList(view1, view2, view3);
-    ButterKnife.apply(views, SETTER_ENABLED, false);
-
-    assertThat(view1).isDisabled();
-    assertThat(view2).isDisabled();
-    assertThat(view3).isDisabled();
-  }
-
-  @Test public void zeroInjectionsInjectDoesNotThrowException() {
-    class Example {
-    }
-
-    Example example = new Example();
-    ButterKnife.inject(example, null, null);
-    assertThat(ButterKnife.INJECTORS).contains(entry(Example.class, ButterKnife.NO_OP));
-  }
-
-  @Test public void zeroInjectionsResetDoesNotThrowException() {
-    class Example {
-    }
-
-    Example example = new Example();
-    ButterKnife.reset(example);
-    assertThat(ButterKnife.RESETTERS).contains(entry(Example.class, ButterKnife.NO_OP));
-  }
-
-  @Test public void injectingKnownPackagesIsNoOp() {
-    ButterKnife.inject(new Activity());
-    assertThat(ButterKnife.INJECTORS).isEmpty();
-    ButterKnife.inject(new Object(), new Activity());
-    assertThat(ButterKnife.INJECTORS).isEmpty();
-    ButterKnife.reset(new Object());
-    assertThat(ButterKnife.RESETTERS).isEmpty();
-    ButterKnife.reset(new Activity());
-    assertThat(ButterKnife.RESETTERS).isEmpty();
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/AllTheThingsTest.java b/butterknife/src/test/java/butterknife/internal/AllTheThingsTest.java
deleted file mode 100644
index 4ee70470..00000000
--- a/butterknife/src/test/java/butterknife/internal/AllTheThingsTest.java
+++ /dev/null
@@ -1,399 +0,0 @@
-package butterknife.internal;
-
-import android.text.Editable;
-import android.view.KeyEvent;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.CompoundButton;
-import android.widget.TextView;
-import butterknife.InjectView;
-import butterknife.InjectViews;
-import butterknife.OnCheckedChanged;
-import butterknife.OnClick;
-import butterknife.OnEditorAction;
-import butterknife.OnFocusChange;
-import butterknife.OnItemClick;
-import butterknife.OnItemLongClick;
-import butterknife.OnItemSelected;
-import butterknife.OnLongClick;
-import butterknife.OnPageChange;
-import butterknife.OnTextChanged;
-import butterknife.Optional;
-import com.google.common.io.Files;
-import com.google.testing.compile.JavaFileObjects;
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.List;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-@SuppressWarnings("UnusedDeclaration")
-public class AllTheThingsTest {
-  @Test public void allTheThings() throws IOException {
-    File file = new File("src/test/java/butterknife/internal/AllTheThingsTest.java");
-    String content = Files.toString(file, StandardCharsets.UTF_8);
-
-    ASSERT.about(javaSource())
-        .that(JavaFileObjects.forSourceString("butterknife.internal.AllTheThingsTest", content))
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError();
-  }
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @InjectView(10) View injectView;
-  @Optional @InjectView(20) View optinalInjectView;
-
-  @InjectView(30) TextView injectTextView;
-  @Optional @InjectView(40) TextView optinalInjectTextView;
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @InjectViews(50) List<View> injectViewsListOne;
-  @InjectViews({ 60, 70 }) List<View> injectViewsListMultiple;
-
-  @InjectViews(80) List<TextView> injectTextViewsListOne;
-  @InjectViews({ 90, 100 }) List<TextView> injectTextViewsListMultiple;
-
-  @InjectViews(110) View[] injectViewsArrayOne;
-  @InjectViews({ 120, 130 }) View[] injectViewsArrayMultiple;
-
-  @InjectViews(140) TextView[] injectTextViewsArrayOne;
-  @InjectViews({ 150, 160 }) TextView[] injectTextViewsArrayMultiple;
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnCheckedChanged(170)
-  void checkedChanged() {}
-  @OnCheckedChanged(180)
-  void checkedChanged(CompoundButton one) {}
-  @OnCheckedChanged(190)
-  void checkedChanged(boolean two) {}
-  @OnCheckedChanged(200)
-  void checkedChanged(CompoundButton one, boolean two) {}
-
-  @OnCheckedChanged({ 210, 220 })
-  void checkedChangedMultiple() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnClick(240)
-  void click() {}
-  @OnClick(250)
-  void click(View one) {}
-
-  @OnClick({ 260, 270 })
-  void clickMultiple() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnEditorAction(290)
-  boolean editorAction() { return false; }
-  @OnEditorAction(300)
-  boolean editorAction(TextView one) { return false; }
-  @OnEditorAction(310)
-  boolean editorAction(int one) { return false; }
-  @OnEditorAction(320)
-  boolean editorAction(KeyEvent one) { return false; }
-  @OnEditorAction(330)
-  boolean editorAction(TextView one, int two) { return false; }
-  @OnEditorAction(340)
-  boolean editorAction(TextView one, KeyEvent two) { return false; }
-  @OnEditorAction(350)
-  boolean editorAction(int one, KeyEvent two) { return false; }
-  @OnEditorAction(360)
-  boolean editorAction(TextView one, int two, KeyEvent three) { return false; }
-
-  @OnEditorAction({ 370, 380 })
-  boolean editorActionMultiple() { return false; }
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnFocusChange(400)
-  void focusChange() {}
-  @OnFocusChange(410)
-  void focusChange(View one) {}
-  @OnFocusChange(420)
-  void focusChange(boolean one) {}
-  @OnFocusChange(430)
-  void focusChange(View one, boolean two) {}
-
-  @OnFocusChange({ 440, 450 })
-  void focusChangeMultiple() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnItemClick(470)
-  void itemClick() {}
-  @OnItemClick(480)
-  void itemClick(AdapterView<?> one) {}
-  @OnItemClick(490)
-  void itemClick(View one) {}
-  @OnItemClick(500)
-  void itemClick(int one) {}
-  @OnItemClick(510)
-  void itemClick(long one) {}
-  @OnItemClick(520)
-  void itemClick(AdapterView<?> one, View two) {}
-  @OnItemClick(530)
-  void itemClick(AdapterView<?> one, int two) {}
-  @OnItemClick(540)
-  void itemClick(AdapterView<?> one, long two) {}
-  @OnItemClick(550)
-  void itemClick(View one, long two) {}
-  @OnItemClick(560)
-  void itemClick(int one, long two) {}
-  @OnItemClick(570)
-  void itemClick(AdapterView<?> one, View two, int three) {}
-  @OnItemClick(580)
-  void itemClick(AdapterView<?> one, View two, long three) {}
-  @OnItemClick(590)
-  void itemClick(AdapterView<?> one, int two, long three) {}
-  @OnItemClick(600)
-  void itemClick(View one, int two, long three) {}
-  @OnItemClick(610)
-  void itemClick(AdapterView<?> one, View two, int three, long four) {}
-
-  @OnItemClick({ 620, 630 })
-  void itemClickMultiple() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnItemLongClick(650)
-  boolean itemLongClick() { return false; }
-  @OnItemLongClick(660)
-  boolean itemLongClick(AdapterView<?> one) { return false; }
-  @OnItemLongClick(670)
-  boolean itemLongClick(View one) { return false; }
-  @OnItemLongClick(680)
-  boolean itemLongClick(int one) { return false; }
-  @OnItemLongClick(690)
-  boolean itemLongClick(long one) { return false; }
-  @OnItemLongClick(700)
-  boolean itemLongClick(AdapterView<?> one, View two) { return false; }
-  @OnItemLongClick(710)
-  boolean itemLongClick(AdapterView<?> one, int two) { return false; }
-  @OnItemLongClick(720)
-  boolean itemLongClick(AdapterView<?> one, long two) { return false; }
-  @OnItemLongClick(730)
-  boolean itemLongClick(View one, long two) { return false; }
-  @OnItemLongClick(740)
-  boolean itemLongClick(int one, long two) { return false; }
-  @OnItemLongClick(750)
-  boolean itemLongClick(AdapterView<?> one, View two, int three) { return false; }
-  @OnItemLongClick(760)
-  boolean itemLongClick(AdapterView<?> one, View two, long three) { return false; }
-  @OnItemLongClick(770)
-  boolean itemLongClick(AdapterView<?> one, int two, long three) { return false; }
-  @OnItemLongClick(780)
-  boolean itemLongClick(View one, int two, long three) { return false; }
-  @OnItemLongClick(790)
-  boolean itemLongClick(AdapterView<?> one, View two, int three, long four) { return false; }
-
-  @OnItemLongClick({ 800, 810 })
-  boolean itemLongClickMultiple() { return false; }
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnItemSelected(830)
-  void itemSelected() {}
-  @OnItemSelected(840)
-  void itemSelected(AdapterView<?> one) {}
-  @OnItemSelected(850)
-  void itemSelected(View one) {}
-  @OnItemSelected(860)
-  void itemSelected(int one) {}
-  @OnItemSelected(870)
-  void itemSelected(long one) {}
-  @OnItemSelected(880)
-  void itemSelected(AdapterView<?> one, View two) {}
-  @OnItemSelected(890)
-  void itemSelected(AdapterView<?> one, int two) {}
-  @OnItemSelected(900)
-  void itemSelected(AdapterView<?> one, long two) {}
-  @OnItemSelected(910)
-  void itemSelected(View one, long two) {}
-  @OnItemSelected(920)
-  void itemSelected(int one, long two) {}
-  @OnItemSelected(930)
-  void itemSelected(AdapterView<?> one, View two, int three) {}
-  @OnItemSelected(940)
-  void itemSelected(AdapterView<?> one, View two, long three) {}
-  @OnItemSelected(950)
-  void itemSelected(AdapterView<?> one, int two, long three) {}
-  @OnItemSelected(960)
-  void itemSelected(View one, int two, long three) {}
-  @OnItemSelected(970)
-  void itemSelected(AdapterView<?> one, View two, int three, long four) {}
-
-  @OnItemSelected({ 980, 990 })
-  void itemSelectedMultiple() {}
-  @OnItemSelected(value = { 1000, 1010 }, callback = OnItemSelected.Callback.NOTHING_SELECTED)
-  void nothingSelectedMultiple() {}
-
-  @OnItemSelected(value = 1020, callback = OnItemSelected.Callback.ITEM_SELECTED)
-  void itemSelectedQualifiedDefault() {}
-
-  @OnItemSelected(value = 1030, callback = OnItemSelected.Callback.NOTHING_SELECTED)
-  void nothingSelected() {}
-  @OnItemSelected(value = 1040, callback = OnItemSelected.Callback.NOTHING_SELECTED)
-  void nothingSelected(AdapterView<?> one) {}
-
-  @OnItemSelected(1050)
-  void itemSelectedBothMethods() {}
-  @OnItemSelected(value = 1050, callback = OnItemSelected.Callback.NOTHING_SELECTED)
-  void nothingSelectedBothMethods() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnLongClick(1060)
-  boolean longClick() { return false; }
-  @OnLongClick(1070)
-  boolean longClick(View one) { return false; }
-
-  @OnLongClick({ 1080, 1090 })
-  boolean longClickMultiple() { return false; }
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnPageChange(1110)
-  void pageChange() {}
-  @OnPageChange(1120)
-  void pageChange(int one) {}
-
-  @OnPageChange({ 1130, 1140 })
-  void pageChangeMultiple() {}
-
-  @OnPageChange(value = 1150, callback = OnPageChange.Callback.PAGE_SELECTED)
-  void pageChangeQualifiedDefault() {}
-
-  @OnPageChange(value = 1160, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled() {}
-  @OnPageChange(value = 1170, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled(int one) {}
-  @OnPageChange(value = 1180, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled(float two) {}
-  // A single-argument method matching the third parameter can't happen.
-  //@OnPageChange(value = 1190, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  //void pageScrolled(int three) {}
-  @OnPageChange(value = 1200, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled(int one, float two) {}
-  @OnPageChange(value = 1210, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled(float one, int two) {}
-  @OnPageChange(value = 1220, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolled(int one, float two, int three) {}
-
-  @OnPageChange(value = { 1230, 1240 }, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolledMultiple() {}
-
-  @OnPageChange(value = 1250, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChanged() {}
-  @OnPageChange(value = 1260, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChanged(int one) {}
-
-  @OnPageChange(value = { 1270, 1280 }, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChangedMultiple() {}
-
-  @OnPageChange(1290)
-  void pageChangeFirstTwoMethods() {}
-  @OnPageChange(value = 1290, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolledFirstTwoMethods() {}
-
-  @OnPageChange(value = 1300, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolledSecondTwoMethods() {}
-  @OnPageChange(value = 1300, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChangedSecondTwoMethods() {}
-
-  @OnPageChange(1310)
-  void pageChangeOuterTwoMethods() {}
-  @OnPageChange(value = 1310, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChangedOuterTwoMethods() {}
-
-  @OnPageChange(1320)
-  void pageChangeAllMethods() {}
-  @OnPageChange(value = 1320, callback = OnPageChange.Callback.PAGE_SCROLLED)
-  void pageScrolledAllMethods() {}
-  @OnPageChange(value = 1320, callback = OnPageChange.Callback.PAGE_SCROLL_STATE_CHANGED)
-  void pageScrollStateChangedAllMethods() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  @OnTextChanged(1330)
-  void textChanged() {}
-  @OnTextChanged(1340)
-  void textChanged(CharSequence one) {}
-  @OnTextChanged(1350)
-  void textChanged(int one) {}
-  @OnTextChanged(1360)
-  void textChanged(CharSequence one, int two) {}
-  @OnTextChanged(1370)
-  void textChanged(int one, int two) {}
-  @OnTextChanged(1380)
-  void textChanged(CharSequence one, int two, int three) {}
-  @OnTextChanged(1390)
-  void textChanged(int one, int two, int three) {}
-  @OnTextChanged(1400)
-  void textChanged(CharSequence one, int two, int three, int four) {}
-
-  @OnTextChanged({ 1410, 1420 })
-  void textChangedMultiple() {}
-
-  @OnTextChanged(value = 1430, callback = OnTextChanged.Callback.TEXT_CHANGED)
-  void textChangedQualifiedDefault() {}
-
-  @OnTextChanged(value = 1440, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged() {}
-  @OnTextChanged(value = 1450, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(CharSequence one) {}
-  @OnTextChanged(value = 1460, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(int one) {}
-  @OnTextChanged(value = 1470, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(CharSequence one, int two) {}
-  @OnTextChanged(value = 1480, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(int one, int two) {}
-  @OnTextChanged(value = 1490, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(CharSequence one, int two, int three) {}
-  @OnTextChanged(value = 1500, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(int one, int two, int three) {}
-  @OnTextChanged(value = 1510, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChanged(CharSequence one, int two, int three, int four) {}
-
-  @OnTextChanged(value = { 1520, 1530 }, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChangedMultiple() {}
-
-  @OnTextChanged(value = 1540, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChanged() {}
-  @OnTextChanged(value = 1550, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChanged(Editable one) {}
-
-  @OnTextChanged(value = { 1560, 1570}, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChangedMultiple() {}
-
-  @OnTextChanged(1580)
-  void textChangedFirstTwoMethods() {}
-  @OnTextChanged(value = 1580, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChangedFirstTwoMethods() {}
-
-  @OnTextChanged(value = 1590, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChangedSecondTwoMethods() {}
-  @OnTextChanged(value = 1590, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChangedSecondTwoMethods() {}
-
-  @OnTextChanged(1600)
-  void textChangedOuterTwoMethods() {}
-  @OnTextChanged(value = 1600, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChangedOuterTwoMethods() {}
-
-  @OnTextChanged(1610)
-  void textChangedAllMethods() {}
-  @OnTextChanged(value = 1610, callback = OnTextChanged.Callback.BEFORE_TEXT_CHANGED)
-  void beforeTextChangedAllMethods() {}
-  @OnTextChanged(value = 1610, callback = OnTextChanged.Callback.AFTER_TEXT_CHANGED)
-  void afterTextChangedAllMethods() {}
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-}
diff --git a/butterknife/src/test/java/butterknife/internal/InjectViewTest.java b/butterknife/src/test/java/butterknife/internal/InjectViewTest.java
deleted file mode 100644
index 3a0b0475..00000000
--- a/butterknife/src/test/java/butterknife/internal/InjectViewTest.java
+++ /dev/null
@@ -1,447 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-
-import org.junit.Test;
-
-import javax.tools.JavaFileObject;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class InjectViewTest {
-  @Test public void injectingView() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "    @InjectView(1) View thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'thing'\");",
-            "    target.thing = view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void genericType() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.widget.EditText;",
-        "import android.widget.TextView;",
-        "import butterknife.InjectView;",
-        "class Test<T extends TextView> extends Activity {",
-        "    @InjectView(1) T thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'thing'\");",
-            "    target.thing = (android.widget.TextView) view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void oneFindPerId() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) View thing1;",
-        "  @InjectView(1) View thing2;",
-        "  @InjectView(1) View thing3;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'thing1', field 'thing2', and field 'thing3'\");",
-            "    target.thing1 = view;",
-            "    target.thing2 = view;",
-            "    target.thing3 = view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing1 = null;",
-            "    target.thing2 = null;",
-            "    target.thing3 = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void fieldVisibility() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) public View thing1;",
-        "  @InjectView(1) View thing2;",
-        "  @InjectView(1) protected View thing3;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError();
-  }
-
-  @Test public void optional() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.Optional;",
-        "public class Test extends Activity {",
-        "  @Optional @InjectView(1) View view;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findOptionalView(source, 1);",
-            "    target.view = view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.view = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void superclass() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.Optional;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) View view;",
-        "}",
-        "class TestOne extends Test {",
-        "  @InjectView(1) View thing;",
-        "}",
-        "class TestTwo extends Test {",
-        "}"
-    ));
-
-    JavaFileObject expectedSource1 = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'view'\");",
-            "    target.view = view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.view = null;",
-            "  }",
-            "}"
-        ));
-
-    JavaFileObject expectedSource2 = JavaFileObjects.forSourceString("test/TestOne$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class TestOne$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.TestOne target, Object source) {",
-            "    test.Test$$ViewInjector.inject(finder, target, source);",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'thing'\");",
-            "    target.thing = view;",
-            "  }",
-            "  public static void reset(test.TestOne target) {",
-            "    test.Test$$ViewInjector.reset(target);",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource1, expectedSource2);
-  }
-
-  @Test public void genericSuperclass() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.Optional;",
-        "public class Test<T> extends Activity {",
-        "  @InjectView(1) View view;",
-        "}",
-        "class TestOne extends Test<String> {",
-        "  @InjectView(1) View thing;",
-        "}",
-        "class TestTwo extends Test<Object> {",
-        "}"
-    ));
-
-    JavaFileObject expectedSource1 = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'view'\");",
-            "    target.view = view;",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.view = null;",
-            "  }",
-            "}"
-        ));
-
-    JavaFileObject expectedSource2 = JavaFileObjects.forSourceString("test/TestOne$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class TestOne$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.TestOne target, Object source) {",
-            "    test.Test$$ViewInjector.inject(finder, target, source);",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'thing'\");",
-            "    target.thing = view;",
-            "  }",
-            "  public static void reset(test.TestOne target) {",
-            "    test.Test$$ViewInjector.reset(target);",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource1, expectedSource2);
-  }
-
-  @Test public void failsInJavaPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package java.test;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test {",
-        "  @InjectView(1) View thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectView-annotated class incorrectly in Java framework package. (java.test.Test)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsInAndroidPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package android.test;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test {",
-        "  @InjectView(1) View thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectView-annotated class incorrectly in Android framework package. (android.test.Test)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfInPrivateClass() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test {",
-        "  private static class Inner {",
-        "    @InjectView(1) View thing;",
-        "  }",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectView fields may not be contained in private classes. (test.Test.Inner.thing)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfNotView() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) String thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectView fields must extend from View. (test.Test.thing)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfInInterface() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public interface Test {",
-        "    @InjectView(1) View thing = null;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectView fields may only be contained in classes. (test.Test.thing)")
-        .in(source).onLine(4);
-  }
-
-  @Test public void failsIfPrivate() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "    @InjectView(1) private View thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectView fields must not be private or static. (test.Test.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfStatic() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "public class Test extends Activity {",
-        "    @InjectView(1) static View thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectView fields must not be private or static. (test.Test.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfBothAnnotations() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.InjectViews;",
-        "public class Test extends Activity {",
-        "    @InjectView(1) @InjectViews(1) View thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "Only one of @InjectView and @InjectViews is allowed. (test.Test.thing)")
-        .in(source).onLine(7);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/InjectViewsTest.java b/butterknife/src/test/java/butterknife/internal/InjectViewsTest.java
deleted file mode 100644
index 31390e6d..00000000
--- a/butterknife/src/test/java/butterknife/internal/InjectViewsTest.java
+++ /dev/null
@@ -1,444 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class InjectViewsTest {
-  @Test public void injectingArray() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "public class Test extends Activity {",
-        "    @InjectViews({1, 2, 3}) View[] thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.arrayOf(",
-            "        finder.findRequiredView(source, 1, \"thing\"),",
-            "        finder.findRequiredView(source, 2, \"thing\"),",
-            "        finder.findRequiredView(source, 3, \"thing\")",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void injectingArrayWithGenerics() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "public class Test<T extends View> extends Activity {",
-        "    @InjectViews({1, 2, 3}) T[] thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.arrayOf(",
-            "        finder.findRequiredView(source, 1, \"thing\"),",
-            "        finder.findRequiredView(source, 2, \"thing\"),",
-            "        finder.findRequiredView(source, 3, \"thing\")",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void injectingArrayWithCast() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.widget.TextView;",
-        "import butterknife.InjectViews;",
-        "public class Test extends Activity {",
-        "    @InjectViews({1, 2, 3}) TextView[] thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.arrayOf(",
-            "        (android.widget.TextView) finder.findRequiredView(source, 1, \"thing\"),",
-            "        (android.widget.TextView) finder.findRequiredView(source, 2, \"thing\"),",
-            "        (android.widget.TextView) finder.findRequiredView(source, 3, \"thing\")",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void injectingList() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test extends Activity {",
-        "    @InjectViews({1, 2, 3}) List<View> thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.listOf(",
-            "        finder.findRequiredView(source, 1, \"thing\"),",
-            "        finder.findRequiredView(source, 2, \"thing\"),",
-            "        finder.findRequiredView(source, 3, \"thing\")",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void injectingListWithGenerics() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test<T extends View> extends Activity {",
-        "    @InjectViews({1, 2, 3}) List<T> thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.listOf(",
-            "        finder.findRequiredView(source, 1, \"thing\"),",
-            "        finder.findRequiredView(source, 2, \"thing\"),",
-            "        finder.findRequiredView(source, 3, \"thing\")",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void optional() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import butterknife.Optional;",
-        "import java.util.List;",
-        "public class Test extends Activity {",
-        "    @Optional @InjectViews({1, 2, 3}) List<View> thing;",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    target.thing = Finder.listOf(",
-            "        finder.findOptionalView(source, 1),",
-            "        finder.findOptionalView(source, 2),",
-            "        finder.findOptionalView(source, 3)",
-            "    );",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.thing = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void failsIfNoIds() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test {",
-        "  @InjectViews({}) List<View> thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectViews must specify at least one ID. (test.Test.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfNoGenericType() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test {",
-        "  @InjectViews(1) List thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews List must have a generic component. (test.Test.thing)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfUnsupportedCollection() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.Deque;",
-        "public class Test {",
-        "  @InjectViews(1) Deque<View> thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews must be a List or array. (test.Test.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfGenericNotView() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test extends Activity {",
-        "  @InjectViews(1) List<String> thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectViews type must extend from View. (test.Test.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfArrayNotView() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;", "import android.app.Activity;", "import butterknife.InjectViews;",
-        "public class Test extends Activity {", "  @InjectViews(1) String[] thing;", "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectViews type must extend from View. (test.Test.thing)")
-        .in(source).onLine(5);
-  }
-
-
-  @Test public void failsInJavaPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package java.test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "public class Test {",
-        "  @InjectViews(1) View[] thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews-annotated class incorrectly in Java framework package. (java.test.Test)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsInAndroidPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package android.test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "public class Test {",
-        "  @InjectViews(1) View[] thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews-annotated class incorrectly in Android framework package. (android.test.Test)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfInPrivateClass() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test {",
-        "  private static class Inner {",
-        "    @InjectViews(1) List<View> thing;",
-        "  }",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews fields may not be contained in private classes. (test.Test.Inner.thing)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfInInterface() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public interface Test {",
-        "    @InjectViews(1) List<View> thing = null;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@InjectViews fields may only be contained in classes. (test.Test.thing)")
-        .in(source).onLine(5);
-  }
-
-  @Test public void failsIfPrivate() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test extends Activity {",
-        "    @InjectViews(1) private List<View> thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectViews fields must not be private or static. (test.Test.thing)")
-        .in(source).onLine(7);
-  }
-
-  @Test public void failsIfStatic() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectViews;",
-        "import java.util.List;",
-        "public class Test extends Activity {",
-        "    @InjectViews(1) static List<View> thing;",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@InjectViews fields must not be private or static. (test.Test.thing)")
-        .in(source).onLine(7);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnCheckedChangedTest.java b/butterknife/src/test/java/butterknife/internal/OnCheckedChangedTest.java
deleted file mode 100644
index 6aac750a..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnCheckedChangedTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnCheckedChangedTest {
-  @Test public void checkedChanged() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnCheckedChanged;",
-        "public class Test extends Activity {",
-        "  @OnCheckedChanged(1) void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.CompoundButton) view).setOnCheckedChangeListener(new android.widget.CompoundButton.OnCheckedChangeListener() {",
-            "      @Override public void onCheckedChanged(android.widget.CompoundButton p0, boolean p1) {",
-            "        target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnClickTest.java b/butterknife/src/test/java/butterknife/internal/OnClickTest.java
deleted file mode 100644
index 636d3b2d..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnClickTest.java
+++ /dev/null
@@ -1,475 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-
-import org.junit.Test;
-
-import javax.tools.JavaFileObject;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnClickTest {
-  @Test public void onClickInjection() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1) void doStuff() {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void findOnlyCalledOnce() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) View view;",
-        "  @OnClick(1) void doStuff() {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'view' and method 'doStuff'\");",
-            "    target.view = view;",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.view = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void methodVisibility() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1) public void thing1() {}",
-        "  @OnClick(2) void thing2() {}",
-        "  @OnClick(3) protected void thing3() {}",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError();
-  }
-
-  @Test public void methodCastsArgument() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import android.widget.Button;",
-        "import android.widget.TextView;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(0) void click0() {}",
-        "  @OnClick(1) void click1(View view) {}",
-        "  @OnClick(2) void click2(TextView view) {}",
-        "  @OnClick(3) void click3(Button button) {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 0, \"method 'click0'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click0();",
-            "      }",
-            "    });",
-            "    view = finder.findRequiredView(source, 1, \"method 'click1'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click1(p0);",
-            "      }",
-            "    });",
-            "    view = finder.findRequiredView(source, 2, \"method 'click2'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click2((android.widget.TextView) p0);",
-            "      }",
-            "    });",
-            "    view = finder.findRequiredView(source, 3, \"method 'click3'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click3((android.widget.Button) p0);",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void methodWithMultipleIds() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick({1, 2, 3}) void click() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'click'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click();",
-            "      }",
-            "    });",
-            "    view = finder.findRequiredView(source, 2, \"method 'click'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click();",
-            "      }",
-            "    });",
-            "    view = finder.findRequiredView(source, 3, \"method 'click'\");",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.click();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void optional() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "import butterknife.Optional;",
-        "public class Test extends Activity {",
-        "  @Optional @OnClick(1) void doStuff() {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findOptionalView(source, 1);",
-            "    if (view != null) {",
-            "      view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "        @Override public void doClick(android.view.View p0) {",
-            "          target.doStuff();",
-            "        }",
-            "      });",
-            "    }",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-
-  @Test public void optionalAndRequiredSkipsNullCheck() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.InjectView;",
-        "import butterknife.OnClick;",
-        "import butterknife.Optional;",
-        "public class Test extends Activity {",
-        "  @InjectView(1) View view;",
-        "  @Optional @OnClick(1) void doStuff() {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"field 'view'\");",
-            "    target.view = view;",
-            "    view.setOnClickListener(new butterknife.internal.DebouncedOnClickListener() {",
-            "      @Override public void doClick(android.view.View p0) {",
-            "        target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "    target.view = null;",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-
-  @Test public void failsInJavaPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package java.test;",
-        "import butterknife.OnClick;",
-        "public class Test {",
-        "  @OnClick(1) void doStuff() {}",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnClick-annotated class incorrectly in Java framework package. (java.test.Test)")
-        .in(source).onLine(4);
-  }
-
-  @Test public void failsInAndroidPackage() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package android.test;",
-        "import butterknife.OnClick;",
-        "public class Test {",
-        "  @OnClick(1) void doStuff() {}",
-        "}"
-    ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnClick-annotated class incorrectly in Android framework package. (android.test.Test)")
-        .in(source).onLine(4);
-  }
-
-  @Test public void failsIfHasReturnType() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1)",
-        "  public String doStuff() {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@OnClick methods must have a 'void' return type. (test.Test.doStuff)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfPrivateMethod() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1)",
-        "  private void doStuff() {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@OnClick methods must not be private or static. (test.Test.doStuff)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfStatic() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1)",
-        "  public static void doStuff() {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining("@OnClick methods must not be private or static. (test.Test.doStuff)")
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfParameterNotView() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1)",
-        "  public void doStuff(String thing) {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(Joiner.on('\n').join(
-            "Unable to match @OnClick method arguments. (test.Test.doStuff)",
-            "  ",
-            "    Parameter #1: java.lang.String",
-            "      did not match any listener parameters",
-            "  ",
-            "  Methods may have up to 1 parameter(s):",
-            "  ",
-            "    android.view.View",
-            "  ",
-            "  These may be listed in any order but will be searched for from top to bottom."))
-        .in(source).onLine(6);
-  }
-
-  @Test public void failsIfMoreThanOneParameter() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick(1)",
-        "  public void doStuff(View thing, View otherThing) {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnClick methods can have at most 1 parameter(s). (test.Test.doStuff)")
-        .in(source).onLine(7);
-  }
-
-  @Test public void failsIfInInterface() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import butterknife.OnClick;",
-        "public interface Test {",
-        "  @OnClick(1)",
-        "  void doStuff();",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnClick methods may only be contained in classes. (test.Test.doStuff)")
-        .in(source).onLine(3);
-  }
-
-  @Test public void failsIfHasDuplicateIds() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnClick;",
-        "public class Test extends Activity {",
-        "  @OnClick({1, 2, 3, 1})",
-        "  void doStuff() {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnClick annotation for method contains duplicate ID 1. (test.Test.doStuff)")
-        .in(source).onLine(6);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnEditorActionTest.java b/butterknife/src/test/java/butterknife/internal/OnEditorActionTest.java
deleted file mode 100644
index 93644da7..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnEditorActionTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnEditorActionTest {
-  @Test public void editorAction() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnEditorAction;",
-        "public class Test extends Activity {",
-        "  @OnEditorAction(1) boolean doStuff() { return false; }",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.TextView) view).setOnEditorActionListener(new android.widget.TextView.OnEditorActionListener() {",
-            "      @Override public boolean onEditorAction(android.widget.TextView p0, int p1, android.view.KeyEvent p2) {",
-            "        return target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnFocusChangeTest.java b/butterknife/src/test/java/butterknife/internal/OnFocusChangeTest.java
deleted file mode 100644
index 6c5f18be..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnFocusChangeTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnFocusChangeTest {
-  @Test public void focusChange() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnFocusChange;",
-        "public class Test extends Activity {",
-        "  @OnFocusChange(1) void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    view.setOnFocusChangeListener(new android.view.View.OnFocusChangeListener() {",
-            "      @Override public void onFocusChange(android.view.View p0, boolean p1) {",
-            "        target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnItemClickTest.java b/butterknife/src/test/java/butterknife/internal/OnItemClickTest.java
deleted file mode 100644
index d26d60b9..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnItemClickTest.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-/** This augments {@link OnClickTest} with tests that exercise callbacks with parameters. */
-public class OnItemClickTest {
-  @Test public void onClickInjection() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemClick;",
-        "public class Test extends Activity {",
-        "  @OnItemClick(1) void doStuff() {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemClickListener(",
-            "      new android.widget.AdapterView.OnItemClickListener() {",
-            "        @Override public void onItemClick(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.doStuff();",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void onClickInjectionWithParameters() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import android.widget.AdapterView;",
-        "import butterknife.OnItemClick;",
-        "public class Test extends Activity {",
-        "  @OnItemClick(1) void doStuff(",
-        "    AdapterView<?> parent,",
-        "    View view,",
-        "    int position,",
-        "    long id",
-        "  ) {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemClickListener(",
-            "      new android.widget.AdapterView.OnItemClickListener() {",
-            "        @Override public void onItemClick(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.doStuff(p0, p1, p2, p3);",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void onClickInjectionWithParameterSubset() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import android.widget.ListView;",
-        "import butterknife.OnItemClick;",
-        "public class Test extends Activity {",
-        "  @OnItemClick(1) void doStuff(",
-        "    ListView parent,",
-        "    int position",
-        "  ) {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemClickListener(",
-            "      new android.widget.AdapterView.OnItemClickListener() {",
-            "        @Override public void onItemClick(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.doStuff((android.widget.ListView) p0, p2);",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void onClickInjectionWithParameterSubsetAndGenerics() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import android.widget.ListView;",
-        "import butterknife.OnItemClick;",
-        "public class Test<T extends ListView> extends Activity {",
-        "  @OnItemClick(1) void doStuff(",
-        "    T parent,",
-        "    int position",
-        "  ) {}",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemClickListener(",
-            "      new android.widget.AdapterView.OnItemClickListener() {",
-            "        @Override public void onItemClick(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.doStuff((android.widget.ListView) p0, p2);",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void failsWithInvalidParameterConfiguration() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import android.view.View;",
-        "import android.widget.AdapterView;",
-        "import butterknife.OnItemClick;",
-        "public class Test extends Activity {",
-        "  @OnItemClick(1) void doStuff(",
-        "    AdapterView<?> parent,",
-        "    View view,",
-        "    View whatIsThis",
-        "  ) {}",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(Joiner.on('\n').join(
-            "Unable to match @OnItemClick method arguments. (test.Test.doStuff)",
-            "  ",
-            "    Parameter #1: android.widget.AdapterView<?>",
-            "      matched listener parameter #1: android.widget.AdapterView<?>",
-            "  ",
-            "    Parameter #2: android.view.View",
-            "      matched listener parameter #2: android.view.View",
-            "  ",
-            "    Parameter #3: android.view.View",
-            "      did not match any listener parameters",
-            "  ",
-            "  Methods may have up to 4 parameter(s):",
-            "  ",
-            "    android.widget.AdapterView<?>",
-            "    android.view.View",
-            "    int",
-            "    long",
-            "  ",
-            "  These may be listed in any order but will be searched for from top to bottom."))
-        .in(source).onLine(7);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnItemLongClickTest.java b/butterknife/src/test/java/butterknife/internal/OnItemLongClickTest.java
deleted file mode 100644
index 37e252a8..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnItemLongClickTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnItemLongClickTest {
-  @Test public void itemLongClick() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemLongClick;",
-        "public class Test extends Activity {",
-        "  @OnItemLongClick(1) boolean doStuff() { return false; }",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemLongClickListener(new android.widget.AdapterView.OnItemLongClickListener() {",
-            "      @Override public boolean onItemLongClick(android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "        return target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnItemSelectedTest.java b/butterknife/src/test/java/butterknife/internal/OnItemSelectedTest.java
deleted file mode 100644
index 0ca9aef8..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnItemSelectedTest.java
+++ /dev/null
@@ -1,215 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-/** This augments {@link OnClickTest} with tests that exercise callbacks with multiple methods. */
-public class OnItemSelectedTest {
-  @Test public void defaultMethod() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemSelected;",
-        "public class Test extends Activity {",
-        "  @OnItemSelected(1) void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.doStuff();",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void nonDefaultMethod() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemSelected;",
-        "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;",
-        "public class Test extends Activity {",
-        "  @OnItemSelected(value = 1, callback = NOTHING_SELECTED)",
-        "  void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "          target.doStuff();",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void allMethods() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemSelected;",
-        "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;",
-        "public class Test extends Activity {",
-        "  @OnItemSelected(1)",
-        "  void onItemSelected() {}",
-        "  @OnItemSelected(value = 1, callback = NOTHING_SELECTED)",
-        "  void onNothingSelected() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'onItemSelected' and method 'onNothingSelected'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.onItemSelected();",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "          target.onNothingSelected();",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void multipleBindingPermutation() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnItemSelected;",
-        "import static butterknife.OnItemSelected.Callback.NOTHING_SELECTED;",
-        "public class Test extends Activity {",
-        "  @OnItemSelected({ 1, 2 })",
-        "  void onItemSelected() {}",
-        "  @OnItemSelected(value = { 1, 3 }, callback = NOTHING_SELECTED)",
-        "  void onNothingSelected() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'onItemSelected' and method 'onNothingSelected'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.onItemSelected();",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "          target.onNothingSelected();",
-            "        }",
-            "      });",
-            "    view = finder.findRequiredView(source, 2, \"method 'onItemSelected'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "          target.onItemSelected();",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "        }",
-            "      });",
-            "    view = finder.findRequiredView(source, 3, \"method 'onNothingSelected'\");",
-            "    ((android.widget.AdapterView<?>) view).setOnItemSelectedListener(",
-            "      new android.widget.AdapterView.OnItemSelectedListener() {",
-            "        @Override public void onItemSelected(",
-            "            android.widget.AdapterView<?> p0, android.view.View p1, int p2, long p3) {",
-            "        }",
-            "        @Override public void onNothingSelected(",
-            "            android.widget.AdapterView<?> p0) {",
-            "          target.onNothingSelected();",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnLongClickTest.java b/butterknife/src/test/java/butterknife/internal/OnLongClickTest.java
deleted file mode 100644
index 324ac311..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnLongClickTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-/** This augments {@link OnClickTest} with tests that exercise callbacks with return types. */
-public class OnLongClickTest {
-  @Test public void onLongClickInjection() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnLongClick;",
-        "public class Test extends Activity {",
-        "  @OnLongClick(1) boolean doStuff() {",
-        "    return true;",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    view.setOnLongClickListener(",
-            "      new android.view.View.OnLongClickListener() {",
-            "        @Override public boolean onLongClick(android.view.View p0) {",
-            "          return target.doStuff();",
-            "        }",
-            "      });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-
-  @Test public void failsIfMissingReturnType() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnLongClick;",
-        "public class Test extends Activity {",
-        "  @OnLongClick(1)",
-        "  public void doStuff() {",
-        "  }",
-        "}"));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .failsToCompile()
-        .withErrorContaining(
-            "@OnLongClick methods must have a 'boolean' return type. (test.Test.doStuff)")
-        .in(source).onLine(6);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnPageChangeTest.java b/butterknife/src/test/java/butterknife/internal/OnPageChangeTest.java
deleted file mode 100644
index 270f121f..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnPageChangeTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnPageChangeTest {
-  @Test public void pageChange() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnPageChange;",
-        "public class Test extends Activity {",
-        "  @OnPageChange(1) void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.support.v4.view.ViewPager) view).setOnPageChangeListener(new android.support.v4.view.ViewPager.OnPageChangeListener() {",
-            "      @Override public void onPageSelected(int p0) {",
-            "        target.doStuff();",
-            "      }",
-            "      @Override public void onPageScrolled(int p0, float p1, int p2) {",
-            "      }",
-            "      @Override public void onPageScrollStateChanged(int p0) {",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnTextChangedTest.java b/butterknife/src/test/java/butterknife/internal/OnTextChangedTest.java
deleted file mode 100644
index 09b816c5..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnTextChangedTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnTextChangedTest {
-  @Test public void textChanged() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnTextChanged;",
-        "public class Test extends Activity {",
-        "  @OnTextChanged(1) void doStuff() {}",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    ((android.widget.TextView) view).addTextChangedListener(new android.text.TextWatcher() {",
-            "      @Override public void onTextChanged(java.lang.CharSequence p0, int p1, int p2, int p3) {",
-            "        target.doStuff();",
-            "      }",
-            "      @Override public void beforeTextChanged(java.lang.CharSequence p0, int p1, int p2, int p3) {",
-            "      }",
-            "      @Override public void afterTextChanged(android.text.Editable p0) {",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/OnTouchTest.java b/butterknife/src/test/java/butterknife/internal/OnTouchTest.java
deleted file mode 100644
index cffa3a8c..00000000
--- a/butterknife/src/test/java/butterknife/internal/OnTouchTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package butterknife.internal;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-
-import static butterknife.internal.ProcessorTestUtilities.butterknifeProcessors;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class OnTouchTest {
-  @Test public void touch() {
-    JavaFileObject source = JavaFileObjects.forSourceString("test.Test", Joiner.on('\n').join(
-        "package test;",
-        "import android.app.Activity;",
-        "import butterknife.OnTouch;",
-        "public class Test extends Activity {",
-        "  @OnTouch(1) boolean doStuff() { return false; }",
-        "}"
-    ));
-
-    JavaFileObject expectedSource = JavaFileObjects.forSourceString("test/Test$$ViewInjector",
-        Joiner.on('\n').join(
-            "package test;",
-            "import android.view.View;",
-            "import butterknife.ButterKnife.Finder;",
-            "public class Test$$ViewInjector {",
-            "  public static void inject(Finder finder, final test.Test target, Object source) {",
-            "    View view;",
-            "    view = finder.findRequiredView(source, 1, \"method 'doStuff'\");",
-            "    view.setOnTouchListener(new android.view.View.OnTouchListener() {",
-            "      @Override public boolean onTouch(android.view.View p0, android.view.MotionEvent p1) {",
-            "        return target.doStuff();",
-            "      }",
-            "    });",
-            "  }",
-            "  public static void reset(test.Test target) {",
-            "  }",
-            "}"
-        ));
-
-    ASSERT.about(javaSource()).that(source)
-        .processedWith(butterknifeProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedSource);
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/ProcessorTestUtilities.java b/butterknife/src/test/java/butterknife/internal/ProcessorTestUtilities.java
deleted file mode 100644
index d954c309..00000000
--- a/butterknife/src/test/java/butterknife/internal/ProcessorTestUtilities.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package butterknife.internal;
-
-import java.util.Arrays;
-
-import javax.annotation.processing.Processor;
-
-final class ProcessorTestUtilities {
-  static Iterable<? extends Processor> butterknifeProcessors() {
-    return Arrays.asList(
-        new ButterKnifeProcessor()
-    );
-  }
-}
diff --git a/butterknife/src/test/java/butterknife/internal/ViewInjectorTest.java b/butterknife/src/test/java/butterknife/internal/ViewInjectorTest.java
deleted file mode 100644
index 46ca7932..00000000
--- a/butterknife/src/test/java/butterknife/internal/ViewInjectorTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package butterknife.internal;
-
-import org.junit.Test;
-
-import static butterknife.internal.ViewInjector.emitHumanDescription;
-import static java.util.Arrays.asList;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class ViewInjectorTest {
-  @Test public void humanDescriptionJoinWorks() {
-    Binding one = new TestBinding("one");
-    Binding two = new TestBinding("two");
-    Binding three = new TestBinding("three");
-
-    StringBuilder builder1 = new StringBuilder();
-    emitHumanDescription(builder1, asList(one));
-    assertThat(builder1.toString()).isEqualTo("one");
-
-    StringBuilder builder2 = new StringBuilder();
-    emitHumanDescription(builder2, asList(one, two));
-    assertThat(builder2.toString()).isEqualTo("one and two");
-
-    StringBuilder builder3 = new StringBuilder();
-    emitHumanDescription(builder3, asList(one, two, three));
-    assertThat(builder3.toString()).isEqualTo("one, two, and three");
-  }
-
-  private static class TestBinding implements Binding {
-    private final String description;
-
-    private TestBinding(String description) {
-      this.description = description;
-    }
-
-    @Override public String getDescription() {
-      return description;
-    }
-  }
-}
diff --git a/checkstyle.xml b/checkstyle.xml
index efc74936..bf3140b8 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://checkstyle.sourceforge.net/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
   <!--module name="NewlineAtEndOfFile"/-->
@@ -16,7 +16,7 @@
 
   <!-- Space after 'for' and 'if' -->
   <module name="RegexpSingleline">
-    <property name="format" value="^\s*(for|if)[^ ]"/>
+    <property name="format" value="^\s*(for|if)\b[^ ]"/>
     <property name="message" value="Space needed before opening parenthesis."/>
   </module>
 
@@ -27,7 +27,7 @@
   </module>
 
   <module name="TreeWalker">
-    <property name="cacheFile" value="${checkstyle.cache.file}"/>
+    <!--<property name="cacheFile" value="${checkstyle.cache.file}"/>-->
 
     <!-- Checks for Javadoc comments.                     -->
     <!-- See http://checkstyle.sf.net/config_javadoc.html -->
@@ -70,7 +70,7 @@
       <property name="max" value="100"/>
     </module>
     <!--<module name="MethodLength"/>-->
-    <module name="ParameterNumber"/>
+    <!--<module name="ParameterNumber"/>-->
 
 
     <!-- Checks for whitespace                               -->
@@ -78,7 +78,9 @@
     <module name="GenericWhitespace"/>
     <module name="EmptyForIteratorPad"/>
     <module name="MethodParamPad"/>
-    <module name="NoWhitespaceAfter"/>
+    <module name="NoWhitespaceAfter">
+      <property name="tokens" value="INC, DEC, UNARY_MINUS, UNARY_PLUS, BNOT, LNOT, DOT, ARRAY_DECLARATOR, INDEX_OP"/>
+    </module>
     <module name="NoWhitespaceBefore"/>
     <module name="OperatorWrap"/>
     <module name="ParenPad"/>
@@ -95,8 +97,10 @@
 
     <!-- Checks for blocks. You know, those {}'s         -->
     <!-- See http://checkstyle.sf.net/config_blocks.html -->
-    <module name="AvoidNestedBlocks"/>
-    <module name="EmptyBlock"/>
+    <module name="AvoidNestedBlocks">
+        <property name="allowInSwitchCase" value="true"/>
+    </module>
+    <!--<module name="EmptyBlock"/>-->
     <module name="LeftCurly"/>
     <module name="NeedBraces">
         <property name="tokens" value="LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_WHILE"/>
@@ -106,9 +110,9 @@
 
     <!-- Checks for common coding problems               -->
     <!-- See http://checkstyle.sf.net/config_coding.html -->
-    <module name="AvoidInlineConditionals"/>
+    <!--<module name="AvoidInlineConditionals"/>-->
     <module name="CovariantEquals"/>
-    <module name="DoubleCheckedLocking"/>
+    <!--<module name="DoubleCheckedLocking"/>-->
     <module name="EmptyStatement"/>
     <module name="EqualsAvoidNull"/>
     <module name="EqualsHashCode"/>
@@ -117,7 +121,6 @@
     <module name="InnerAssignment"/>
     <!--<module name="MagicNumber"/>-->
     <module name="MissingSwitchDefault"/>
-    <module name="RedundantThrows"/>
     <module name="SimplifyBooleanExpression"/>
     <module name="SimplifyBooleanReturn"/>
 
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..f23da41e
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,21 @@
+GROUP=com.jakewharton
+VERSION_NAME=10.1.1-SNAPSHOT
+
+POM_DESCRIPTION=Field and method binding for Android views.
+
+POM_URL=https://github.com/JakeWharton/butterknife/
+POM_SCM_URL=https://github.com/JakeWharton/butterknife/
+POM_SCM_CONNECTION=scm:git:git://github.com/JakeWharton/butterknife.git
+POM_SCM_DEV_CONNECTION=scm:git:ssh://git@github.com/JakeWharton/butterknife.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=jakewharton
+POM_DEVELOPER_NAME=Jake Wharton
+
+org.gradle.jvmargs=-Xmx1536M
+
+# TODO https://issuetracker.google.com/issues/73450622
+android.enableAapt2=false
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
new file mode 100644
index 00000000..ea3f6bbb
--- /dev/null
+++ b/gradle/gradle-mvn-push.gradle
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+version = VERSION_NAME
+group = GROUP
+
+def isReleaseBuild() {
+  return VERSION_NAME.contains("SNAPSHOT") == false
+}
+
+def getReleaseRepositoryUrl() {
+  return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+      : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+}
+
+def getSnapshotRepositoryUrl() {
+  return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+      : "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+def getRepositoryUsername() {
+  return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
+}
+
+def getRepositoryPassword() {
+  return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
+}
+
+afterEvaluate { project ->
+  uploadArchives {
+    repositories {
+      mavenDeployer {
+        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        repository(url: getReleaseRepositoryUrl()) {
+          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+        }
+        snapshotRepository(url: getSnapshotRepositoryUrl()) {
+          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+        }
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+  }
+
+  signing {
+    required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+    sign configurations.archives
+  }
+
+  if (project.getPlugins().hasPlugin('com.android.application') ||
+      project.getPlugins().hasPlugin('com.android.library')) {
+    task install(type: Upload, dependsOn: assemble) {
+      repositories.mavenInstaller {
+        configuration = configurations.archives
+
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+
+    task androidJavadocs(type: Javadoc) {
+      source = android.sourceSets.main.java.source
+      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+      classifier = 'javadoc'
+      from androidJavadocs.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+      classifier = 'sources'
+      from android.sourceSets.main.java.source
+    }
+  } else {
+    install {
+      repositories.mavenInstaller {
+        pom.groupId = GROUP
+        pom.artifactId = POM_ARTIFACT_ID
+        pom.version = VERSION_NAME
+
+        pom.project {
+          name POM_NAME
+          packaging POM_PACKAGING
+          description POM_DESCRIPTION
+          url POM_URL
+
+          scm {
+            url POM_SCM_URL
+            connection POM_SCM_CONNECTION
+            developerConnection POM_SCM_DEV_CONNECTION
+          }
+
+          licenses {
+            license {
+              name POM_LICENCE_NAME
+              url POM_LICENCE_URL
+              distribution POM_LICENCE_DIST
+            }
+          }
+
+          developers {
+            developer {
+              id POM_DEVELOPER_ID
+              name POM_DEVELOPER_NAME
+            }
+          }
+        }
+      }
+    }
+
+    task sourcesJar(type: Jar, dependsOn:classes) {
+      classifier = 'sources'
+      from sourceSets.main.allSource
+    }
+
+    task javadocJar(type: Jar, dependsOn:javadoc) {
+      classifier = 'javadoc'
+      from javadoc.destinationDir
+    }
+  }
+
+  if (JavaVersion.current().isJava8Compatible()) {
+    allprojects {
+      tasks.withType(Javadoc) {
+        options.addStringOption('Xdoclint:none', '-quiet')
+      }
+    }
+  }
+
+  artifacts {
+    if (project.getPlugins().hasPlugin('com.android.application') ||
+        project.getPlugins().hasPlugin('com.android.library')) {
+      archives androidSourcesJar
+      archives androidJavadocsJar
+    } else {
+      archives sourcesJar
+      archives javadocJar
+    }
+  }
+}
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..94336fca
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..290541c7
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.3-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..cccdd3d5
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..e95643d6
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,84 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index 90e25295..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,160 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>com.jakewharton</groupId>
-  <artifactId>butterknife-parent</artifactId>
-  <version>5.1.3-SNAPSHOT</version>
-  <packaging>pom</packaging>
-
-  <name>Butter Knife (Parent)</name>
-  <description>View "injection" for Android.</description>
-  <url>http://github.com/JakeWharton/butterknife/</url>
-  <inceptionYear>2013</inceptionYear>
-
-  <modules>
-    <module>butterknife</module>
-    <module>butterknife-sample</module>
-  </modules>
-
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <java.version>1.6</java.version>
-    <fest.version>2.0M10</fest.version>
-    <android.version>4.1.1.4</android.version>
-    <android.platform>16</android.platform>
-    <junit.version>4.10</junit.version>
-    <robolectric.version>2.2</robolectric.version>
-    <fest.android.version>1.0.7</fest.android.version>
-    <compile-test.version>0.5</compile-test.version>
-  </properties>
-
-  <scm>
-    <url>http://github.com/JakeWharton/butterknife/</url>
-    <connection>scm:git:git://github.com/JakeWharton/butterknife.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/JakeWharton/butterknife.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/JakeWharton/butterknife/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.easytesting</groupId>
-        <artifactId>fest-assert-core</artifactId>
-        <version>${fest.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>fest-android</artifactId>
-        <version>${fest.android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.robolectric</groupId>
-        <artifactId>robolectric</artifactId>
-        <version>${robolectric.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.testing.compile</groupId>
-        <artifactId>compile-testing</artifactId>
-        <version>${compile-test.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
-          <showWarnings>true</showWarnings>
-        </configuration>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.4</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-    </plugins>
-
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.0</version>
-          <configuration>
-            <sdk>
-              <platform>${android.platform}</platform>
-            </sdk>
-          </configuration>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.9</version>
-          <configuration>
-            <additionalparam>-Xdoclint:none</additionalparam>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-  </build>
-</project>
diff --git a/sample/app/build.gradle b/sample/app/build.gradle
new file mode 100644
index 00000000..1125c960
--- /dev/null
+++ b/sample/app/build.gradle
@@ -0,0 +1,50 @@
+apply plugin: 'com.android.application'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_7
+    targetCompatibility = JavaVersion.VERSION_1_7
+  }
+
+  defaultConfig {
+    applicationId 'com.example.butterknife'
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
+    versionCode 1
+    versionName '1.0.0'
+  }
+
+  lintOptions {
+    textReport true
+    textOutput 'stdout'
+  }
+
+  buildTypes {
+    debug {
+      minifyEnabled true
+    }
+  }
+}
+
+dependencies {
+  implementation deps.release.runtime
+  annotationProcessor deps.release.compiler
+
+  implementation project(':sample:library')
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+}
+
+afterEvaluate {
+  tasks.withType(com.android.build.gradle.internal.tasks.AndroidTestTask) { task ->
+    task.doFirst {
+      logging.level = LogLevel.INFO
+    }
+    task.doLast {
+      logging.level = LogLevel.LIFECYCLE
+    }
+  }
+}
diff --git a/butterknife-sample/AndroidManifest.xml b/sample/app/src/main/AndroidManifest.xml
similarity index 69%
rename from butterknife-sample/AndroidManifest.xml
rename to sample/app/src/main/AndroidManifest.xml
index ebc0c10a..4549e5e3 100644
--- a/butterknife-sample/AndroidManifest.xml
+++ b/sample/app/src/main/AndroidManifest.xml
@@ -1,21 +1,20 @@
 <?xml version="1.0" encoding="utf-8"?>
-
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    android:versionCode="1"
-    android:versionName="1.0"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.example.butterknife">
 
-  <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
-
   <application
+      android:allowBackup="false"
       android:label="@string/app_name"
-      android:name=".SimpleApp">
+      android:name=".SimpleApp"
+      tools:ignore="GoogleAppIndexingWarning,MissingApplicationIcon">
 
     <activity
         android:label="@string/app_name"
-        android:name=".SimpleActivity">
+        android:name=".library.SimpleActivity">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
+
         <category android:name="android.intent.category.LAUNCHER"/>
         <category android:name="android.intent.category.DEFAULT"/>
       </intent-filter>
diff --git a/sample/app/src/main/java/com/example/butterknife/SimpleApp.java b/sample/app/src/main/java/com/example/butterknife/SimpleApp.java
new file mode 100644
index 00000000..d3fa2787
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/SimpleApp.java
@@ -0,0 +1,11 @@
+package com.example.butterknife;
+
+import android.app.Application;
+import butterknife.ButterKnife;
+
+public class SimpleApp extends Application {
+  @Override public void onCreate() {
+    super.onCreate();
+    ButterKnife.setDebug(BuildConfig.DEBUG);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/A.java b/sample/app/src/main/java/com/example/butterknife/unbinder/A.java
new file mode 100644
index 00000000..d0d7615f
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/A.java
@@ -0,0 +1,16 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class A {
+
+  @BindColor(android.R.color.black) @ColorInt int blackColor;
+
+  public A(View view) {
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/B.java b/sample/app/src/main/java/com/example/butterknife/unbinder/B.java
new file mode 100644
index 00000000..3a7b73db
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/B.java
@@ -0,0 +1,17 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class B extends A {
+
+  @BindColor(android.R.color.white) @ColorInt int whiteColor;
+
+  public B(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/C.java b/sample/app/src/main/java/com/example/butterknife/unbinder/C.java
new file mode 100644
index 00000000..dcd7e13a
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/C.java
@@ -0,0 +1,19 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindView;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class C extends B {
+
+  @BindColor(android.R.color.transparent) @ColorInt int transparentColor;
+  @BindView(android.R.id.button1) View button1;
+
+  public C(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/D.java b/sample/app/src/main/java/com/example/butterknife/unbinder/D.java
new file mode 100644
index 00000000..35a91039
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/D.java
@@ -0,0 +1,17 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class D extends C {
+
+  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;
+
+  public D(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/E.java b/sample/app/src/main/java/com/example/butterknife/unbinder/E.java
new file mode 100644
index 00000000..8b76b3c5
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/E.java
@@ -0,0 +1,17 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class E extends C {
+
+  @BindColor(android.R.color.background_dark) @ColorInt int backgroundDarkColor;
+
+  public E(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/F.java b/sample/app/src/main/java/com/example/butterknife/unbinder/F.java
new file mode 100644
index 00000000..351f8ddd
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/F.java
@@ -0,0 +1,17 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public final class F extends D {
+
+  @BindColor(android.R.color.background_light) @ColorInt int backgroundLightColor;
+
+  public F(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/G.java b/sample/app/src/main/java/com/example/butterknife/unbinder/G.java
new file mode 100644
index 00000000..f2a08ef6
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/G.java
@@ -0,0 +1,24 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindView;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+
+public class G extends E {
+
+  @BindColor(android.R.color.darker_gray) @ColorInt int grayColor;
+  @BindView(android.R.id.button2) View button2;
+
+  public G(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+
+  @OnClick(android.R.id.content) public void onClick() {
+
+  }
+}
diff --git a/sample/app/src/main/java/com/example/butterknife/unbinder/H.java b/sample/app/src/main/java/com/example/butterknife/unbinder/H.java
new file mode 100644
index 00000000..f8656842
--- /dev/null
+++ b/sample/app/src/main/java/com/example/butterknife/unbinder/H.java
@@ -0,0 +1,19 @@
+package com.example.butterknife.unbinder;
+
+import androidx.annotation.ColorInt;
+import android.view.View;
+
+import butterknife.BindView;
+import butterknife.BindColor;
+import butterknife.ButterKnife;
+
+public class H extends G {
+
+  @BindColor(android.R.color.primary_text_dark) @ColorInt int grayColor;
+  @BindView(android.R.id.button3) View button3;
+
+  public H(View view) {
+    super(view);
+    ButterKnife.bind(this, view);
+  }
+}
diff --git a/sample/library/build.gradle b/sample/library/build.gradle
new file mode 100644
index 00000000..18001747
--- /dev/null
+++ b/sample/library/build.gradle
@@ -0,0 +1,30 @@
+buildscript {
+  repositories {
+    mavenCentral()
+    jcenter()
+    google()
+  }
+
+  dependencies {
+    classpath "com.jakewharton:butterknife-gradle-plugin:${versions.release}"
+  }
+}
+
+apply plugin: 'com.android.library'
+apply plugin: 'com.jakewharton.butterknife'
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+}
+
+dependencies {
+  implementation deps.release.runtime
+  annotationProcessor deps.release.compiler
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+}
diff --git a/sample/library/src/main/AndroidManifest.xml b/sample/library/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..d788df0f
--- /dev/null
+++ b/sample/library/src/main/AndroidManifest.xml
@@ -0,0 +1 @@
+<manifest package="com.example.butterknife.library"/>
diff --git a/butterknife-sample/src/main/java/com/example/butterknife/SimpleActivity.java b/sample/library/src/main/java/com/example/butterknife/library/SimpleActivity.java
similarity index 62%
rename from butterknife-sample/src/main/java/com/example/butterknife/SimpleActivity.java
rename to sample/library/src/main/java/com/example/butterknife/library/SimpleActivity.java
index 89fe3c13..1d96194a 100644
--- a/butterknife-sample/src/main/java/com/example/butterknife/SimpleActivity.java
+++ b/sample/library/src/main/java/com/example/butterknife/library/SimpleActivity.java
@@ -1,16 +1,18 @@
-package com.example.butterknife;
+package com.example.butterknife.library;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.os.Bundle;
+import androidx.annotation.NonNull;
 import android.view.View;
 import android.view.animation.AlphaAnimation;
 import android.widget.Button;
 import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
+import butterknife.BindView;
+import butterknife.BindViews;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
-import butterknife.InjectViews;
 import butterknife.OnClick;
 import butterknife.OnItemClick;
 import butterknife.OnLongClick;
@@ -20,7 +22,7 @@
 
 public class SimpleActivity extends Activity {
   private static final ButterKnife.Action<View> ALPHA_FADE = new ButterKnife.Action<View>() {
-    @Override public void apply(View view, int index) {
+    @Override public void apply(@NonNull View view, int index) {
       AlphaAnimation alphaAnimation = new AlphaAnimation(0, 1);
       alphaAnimation.setFillBefore(true);
       alphaAnimation.setDuration(500);
@@ -29,39 +31,39 @@
     }
   };
 
-  @InjectView(R.id.title) TextView title;
-  @InjectView(R.id.subtitle) TextView subtitle;
-  @InjectView(R.id.hello) Button hello;
-  @InjectView(R.id.list_of_things) ListView listOfThings;
-  @InjectView(R.id.footer) TextView footer;
+  @BindView(R2.id.title) TextView title;
+  @BindView(R2.id.subtitle) TextView subtitle;
+  @BindView(R2.id.hello) Button hello;
+  @BindView(R2.id.list_of_things) ListView listOfThings;
+  @BindView(R2.id.footer) TextView footer;
 
-  @InjectViews({ R.id.title, R.id.subtitle, R.id.hello })
-  List<View> headerViews;
+  @BindViews({ R2.id.title, R2.id.subtitle, R2.id.hello }) List<View> headerViews;
 
   private SimpleAdapter adapter;
 
-  @OnClick(R.id.hello) void sayHello() {
+  @OnClick(R2.id.hello) void sayHello() {
     Toast.makeText(this, "Hello, views!", LENGTH_SHORT).show();
     ButterKnife.apply(headerViews, ALPHA_FADE);
   }
 
-  @OnLongClick(R.id.hello) boolean sayGetOffMe() {
+  @OnLongClick(R2.id.hello) boolean sayGetOffMe() {
     Toast.makeText(this, "Let go of me!", LENGTH_SHORT).show();
     return true;
   }
 
-  @OnItemClick(R.id.list_of_things) void onItemClick(int position) {
+  @OnItemClick(R2.id.list_of_things) void onItemClick(int position) {
     Toast.makeText(this, "You clicked: " + adapter.getItem(position), LENGTH_SHORT).show();
   }
 
+  @SuppressLint("SetTextI18n") //
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.simple_activity);
-    ButterKnife.inject(this);
+    ButterKnife.bind(this);
 
-    // Contrived code to use the "injected" views.
+    // Contrived code to use the bound fields.
     title.setText("Butter Knife");
-    subtitle.setText("View \"injection\" for Android.");
+    subtitle.setText("Field and method binding for Android views.");
     footer.setText("by Jake Wharton");
     hello.setText("Say Hello");
 
diff --git a/butterknife-sample/src/main/java/com/example/butterknife/SimpleAdapter.java b/sample/library/src/main/java/com/example/butterknife/library/SimpleAdapter.java
similarity index 74%
rename from butterknife-sample/src/main/java/com/example/butterknife/SimpleAdapter.java
rename to sample/library/src/main/java/com/example/butterknife/library/SimpleAdapter.java
index f5a00178..567f560b 100644
--- a/butterknife-sample/src/main/java/com/example/butterknife/SimpleAdapter.java
+++ b/sample/library/src/main/java/com/example/butterknife/library/SimpleAdapter.java
@@ -1,17 +1,17 @@
-package com.example.butterknife;
+package com.example.butterknife.library;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import butterknife.BindView;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
 
 public class SimpleAdapter extends BaseAdapter {
-  private static final String[] CONTENTS =
-      "The quick brown fox jumps over the lazy dog".split(" ");
+  private static final String[] CONTENTS = "The quick brown fox jumps over the lazy dog".split(" ");
 
   private final LayoutInflater inflater;
 
@@ -31,6 +31,7 @@ public SimpleAdapter(Context context) {
     return position;
   }
 
+  @SuppressLint("SetTextI18n") //
   @Override public View getView(int position, View view, ViewGroup parent) {
     ViewHolder holder;
     if (view != null) {
@@ -50,13 +51,13 @@ public SimpleAdapter(Context context) {
     return view;
   }
 
-  static class ViewHolder {
-    @InjectView(R.id.word) TextView word;
-    @InjectView(R.id.length) TextView length;
-    @InjectView(R.id.position) TextView position;
+  static final class ViewHolder {
+    @BindView(R2.id.word) TextView word;
+    @BindView(R2.id.length) TextView length;
+    @BindView(R2.id.position) TextView position;
 
     ViewHolder(View view) {
-      ButterKnife.inject(this, view);
+      ButterKnife.bind(this, view);
     }
   }
 }
diff --git a/butterknife-sample/res/layout/simple_activity.xml b/sample/library/src/main/res/layout/simple_activity.xml
similarity index 100%
rename from butterknife-sample/res/layout/simple_activity.xml
rename to sample/library/src/main/res/layout/simple_activity.xml
diff --git a/butterknife-sample/res/layout/simple_list_item.xml b/sample/library/src/main/res/layout/simple_list_item.xml
similarity index 100%
rename from butterknife-sample/res/layout/simple_list_item.xml
rename to sample/library/src/main/res/layout/simple_list_item.xml
diff --git a/butterknife-sample/res/values/strings.xml b/sample/library/src/main/res/values/strings.xml
similarity index 100%
rename from butterknife-sample/res/values/strings.xml
rename to sample/library/src/main/res/values/strings.xml
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..9ecaae16
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,13 @@
+include ':butterknife'
+include ':butterknife-annotations'
+include ':butterknife-compiler'
+include ':butterknife-gradle-plugin'
+include ':butterknife-integration-test'
+include ':butterknife-lint'
+include ':butterknife-reflect'
+include ':butterknife-runtime'
+
+//include ':sample:app'
+//include ':sample:library'
+
+rootProject.name = 'butterknife-parent'
diff --git a/website/ide-eclipse.html b/website/ide-eclipse.html
index ea13e0c4..e1cf729d 100644
--- a/website/ide-eclipse.html
+++ b/website/ide-eclipse.html
@@ -5,7 +5,7 @@
     <meta charset="utf-8">
     <title>Butter Knife</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="View &quot;injection&quot; library for Android.">
+    <meta name="description" content="Field and method binding for Android views.">
     <link href="http://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" rel="stylesheet" title="roboto">
     <link href="static/bootstrap.min.css" rel="stylesheet">
     <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
@@ -18,7 +18,7 @@
         <div class="span4 side">
           <img src="static/logo.png">
           <h1>Butter Knife</h1>
-          <h2>View &quot;injection&quot; library for Android</h2>
+          <h2>Field and method binding for Android views</h2>
         </div>
         <div class="offset4 span8 main">
           <div class="main-inner">
@@ -27,7 +27,7 @@ <h2>View &quot;injection&quot; library for Android</h2>
             <h3 id="introduction">Eclipse Configuration</h3>
             <ol>
               <li>
-                <p>Right click on your project in the <em>Package Explorer</em>. Head to <em>Java Compiler &rarr; Annotation Processing</em> and check <em>"Enable project specific settings"</em>.<p>
+                <p>Right click on your project in the <em>Package Explorer</em>, go to <em>Properties</em>, head to <em>Java Compiler &rarr; Annotation Processing</em> and check <em>"Enable project specific settings"</em>.<p>
                 <p>Ensure the other annotation processing settings are the same as shown below:</p>
                 <p><img src="static/ide-eclipse1.png"/></p>
               </li>
@@ -36,7 +36,7 @@ <h3 id="introduction">Eclipse Configuration</h3>
                 <p><img src="static/ide-eclipse2.png"/></p>
               </li>
               <li>Click <em>"Ok"</em> to save the new settings. Eclipse will ask you to rebuild your project to which you should click <em>"Yes"</em></li>
-              <li>Make sure that the <code>.apt_generated/</code> folder is in your project root. It should contain files like <code>YOURACTIVITY$$ViewInjector.java</code>. If these files are not present trigger a clean build by selected <em>Project &rarr; Clean</em>. This folder and files should not be checked into revision control.
+              <li>Make sure that the <code>.apt_generated/</code> folder is in your project root. It should contain files like <code>YOURACTIVITY$$ViewBinder.java</code>. If these files are not present trigger a clean build by selected <em>Project &rarr; Clean</em>. This folder and files should not be checked into revision control.
               <li>Lastly, under <em>"Java Compiler"</em>, make sure that the <em>Compiler compliance level</em> is set to Java version 1.6 at minimum.</li>
             </ol>
 
diff --git a/website/ide-idea.html b/website/ide-idea.html
index aa57ae48..a656ac15 100644
--- a/website/ide-idea.html
+++ b/website/ide-idea.html
@@ -5,7 +5,7 @@
     <meta charset="utf-8">
     <title>Butter Knife</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="View &quot;injection&quot; library for Android.">
+    <meta name="description" content="Field and method binding for Android views.">
     <link href="http://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" rel="stylesheet" title="roboto">
     <link href="static/bootstrap.min.css" rel="stylesheet">
     <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
@@ -18,7 +18,7 @@
         <div class="span4 side">
           <img src="static/logo.png">
           <h1>Butter Knife</h1>
-          <h2>View &quot;injection&quot; library for Android</h2>
+          <h2>Field and method binding for Android views</h2>
         </div>
         <div class="offset4 span8 main">
           <div class="main-inner">
diff --git a/website/index.html b/website/index.html
index 454d5ab0..24d26521 100644
--- a/website/index.html
+++ b/website/index.html
@@ -5,8 +5,8 @@
     <meta charset="utf-8">
     <title>Butter Knife</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="View &quot;injection&quot; library for Android.">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" rel="stylesheet" title="roboto">
+    <meta name="description" content="Field and method binding for Android views.">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" rel="stylesheet" title="roboto">
     <link href="static/bootstrap.min.css" rel="stylesheet">
     <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
     <link href="static/prettify.css" rel="stylesheet">
@@ -18,43 +18,53 @@
         <div class="span4 side">
           <img src="static/logo.png">
           <h1>Butter Knife</h1>
-          <h2>View &quot;injection&quot; library for Android</h2>
+          <h2>Field and method binding for Android views</h2>
           <p><a href="javadoc/">Javadoc</a> &middot; <a href="http://stackoverflow.com/questions/ask?tags=butterknife">StackOverflow</a></p>
         </div>
         <div class="offset4 span8 main">
           <div class="main-inner">
             <h3 id="introduction">Introduction</h3>
-            <p>Annotate fields with <code>@InjectView</code> and a view ID for Butter Knife to find and automatically cast the corresponding view in your layout.</p>
+            <p>Annotate fields with <code>@BindView</code> and a view ID for Butter Knife to find and automatically cast the corresponding view in your layout.</p>
             <pre class="prettyprint">class ExampleActivity extends Activity {
-  @InjectView(R.id.title) TextView title;
-  @InjectView(R.id.subtitle) TextView subtitle;
-  @InjectView(R.id.footer) TextView footer;
+  @BindView(R.id.title) TextView title;
+  @BindView(R.id.subtitle) TextView subtitle;
+  @BindView(R.id.footer) TextView footer;
 
   @Override public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.simple_activity);
-    ButterKnife.inject(this);
-    // TODO Use "injected" views...
+    ButterKnife.bind(this);
+    // TODO Use fields...
   }
 }</pre>
-            <p>Instead of slow reflection, code is generated to perform the view look-ups. Calling <code>inject</code> delegates to this generated code that you can see and debug.</p>
+            <p>Instead of slow reflection, code is generated to perform the view look-ups. Calling <code>bind</code> delegates to this generated code that you can see and debug.</p>
             <p>The generated code for the above example is roughly equivalent to the following:</p>
-            <pre class="prettyprint">public void inject(ExampleActivity activity) {
+            <pre class="prettyprint">public void bind(ExampleActivity activity) {
   activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578);
   activity.footer = (android.widget.TextView) activity.findViewById(2130968579);
   activity.title = (android.widget.TextView) activity.findViewById(2130968577);
 }</pre>
 
-            <h4 id="non-activity">Non-Activity Injection</h4>
-            <p>You can also perform injection on arbitrary objects by supplying your own view root.</p>
+            <h4 id="resource">Resource Binding</h4>
+            <p>Bind pre-defined resources with <code>@BindBool</code>, <code>@BindColor</code>, <code>@BindDimen</code>, <code>@BindDrawable</code>, <code>@BindInt</code>, <code>@BindString</code>, which binds an <code>R.bool</code> ID (or your specified type) to its corresponding field.</p>
+            <pre class="prettyprint">class ExampleActivity extends Activity {
+  @BindString(R.string.title) String title;
+  @BindDrawable(R.drawable.graphic) Drawable graphic;
+  @BindColor(R.color.red) int red; // int or ColorStateList field
+  @BindDimen(R.dimen.spacer) float spacer; // int (for pixel size) or float (for exact value) field
+  // ...
+}</pre>
+
+            <h4 id="non-activity">Non-Activity Binding</h4>
+            <p>You can also perform binding on arbitrary objects by supplying your own view root.</p>
             <pre class="prettyprint">public class FancyFragment extends Fragment {
-  @InjectView(R.id.button1) Button button1;
-  @InjectView(R.id.button2) Button button2;
+  @BindView(R.id.button1) Button button1;
+  @BindView(R.id.button2) Button button2;
 
-  @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View view = inflater.inflate(R.layout.fancy_fragment, container, false);
-    ButterKnife.inject(this, view);
-    // TODO Use "injected" views...
+    ButterKnife.bind(this, view);
+    // TODO Use fields...
     return view;
   }
 }</pre>
@@ -77,52 +87,57 @@ <h4 id="non-activity">Non-Activity Injection</h4>
   }
 
   static class ViewHolder {
-    @InjectView(R.id.title) TextView name;
-    @InjectView(R.id.job_title) TextView jobTitle;
+    @BindView(R.id.title) TextView name;
+    @BindView(R.id.job_title) TextView jobTitle;
 
     public ViewHolder(View view) {
-      ButterKnife.inject(this, view);
+      ButterKnife.bind(this, view);
     }
   }
 }</pre>
             <p>You can see this implementation in action in the provided sample.</p>
-            <p>Calls to <code>ButterKnife.inject</code> can be made anywhere you would otherwise put <code>findViewById</code> calls.</p>
-            <p>Other provided injection APIs:</p>
+            <p>Calls to <code>ButterKnife.bind</code> can be made anywhere you would otherwise put <code>findViewById</code> calls.</p>
+            <p>Other provided binding APIs:</p>
             <ul>
-              <li>Inject arbitrary objects using an activity as the view root. If you use a pattern like MVC you can inject the controller using its activity with <code>ButterKnife.inject(this, activity)</code>.</li>
-              <li>Inject a view's children into fields using <code>ButterKnife.inject(this)</code>. If you use <code>&lt;merge></code> tags in a layout and inflate in a custom view constructor you can
+              <li>Bind arbitrary objects using an activity as the view root. If you use a pattern like MVC you can bind the controller using its activity with <code>ButterKnife.bind(this, activity)</code>.</li>
+              <li>Bind a view's children into fields using <code>ButterKnife.bind(this)</code>. If you use <code>&lt;merge></code> tags in a layout and inflate in a custom view constructor you can
    call this immediately after. Alternatively, custom view types inflated from
    XML can use it in the <code>onFinishInflate()</code> callback.</li>
             </ul>
 
             <h4 id="view-lists">View Lists</h4>
             <p>You can group multiple views into a <code>List</code> or array.</p>
-            <pre class="prettyprint">@InjectViews({ R.id.first_name, R.id.middle_name, R.id.last_name })
+            <pre class="prettyprint">@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name })
 List&lt;EditText> nameViews;</pre>
             <p>The <code>apply</code> method allows you to act on all the views in a list at once.</p>
             <pre class="prettyprint">ButterKnife.apply(nameViews, DISABLE);
 ButterKnife.apply(nameViews, ENABLED, false);</pre>
             <p><code>Action</code> and <code>Setter</code> interfaces allow specifying simple behavior.</p>
-            <pre class="prettyprint">static final Action&lt;View> DISABLE = new Action&lt;>() {
+            <pre class="prettyprint">static final ButterKnife.Action&lt;View> DISABLE = new ButterKnife.Action&lt;View>() {
   @Override public void apply(View view, int index) {
     view.setEnabled(false);
   }
-}
-static final Setter&lt;View, Boolean> ENABLED = new Setter&lt;>() {
+};
+static final ButterKnife.Setter&lt;View, Boolean> ENABLED = new ButterKnife.Setter&lt;View, Boolean>() {
   @Override public void set(View view, Boolean value, int index) {
     view.setEnabled(value);
   }
-}</pre>
+};</pre>
             <p>An Android <a href="https://developer.android.com/reference/android/util/Property.html"><code>Property</code></a> can also be used with the <code>apply</code> method.</p>
-            <pre class="prettyprint">ButterKnife.apply(nameViews, View.ALPHA, 0);</pre>
+            <pre class="prettyprint">ButterKnife.apply(nameViews, View.ALPHA, 0.0f);</pre>
 
-            <h4 id="click-injection">Click Listener Injection</h4>
-            <p>Click listeners can also automatically be configured onto methods.</p>
+            <h4 id="listener-binding">Listener Binding</h4>
+            <p>Listeners can also automatically be configured onto methods.</p>
+            <pre class="prettyprint">@OnClick(R.id.submit)
+public void submit(View view) {
+  // TODO submit data to server...
+}</pre>
+            <p>All arguments to the listener method are optional.</p>
             <pre class="prettyprint">@OnClick(R.id.submit)
 public void submit() {
   // TODO submit data to server...
 }</pre>
-            <p>You can add the view as an argument to the method. Define a specific type and it will automatically be cast.</p>
+            <p>Define a specific type and it will automatically be cast.</p>
             <pre class="prettyprint">@OnClick(R.id.submit)
 public void sayHi(Button button) {
   button.setText("Hello!");
@@ -136,30 +151,40 @@ <h4 id="click-injection">Click Listener Injection</h4>
     Toast.makeText(this, "Try again", LENGTH_SHORT).show();
   }
 }</pre>
+            <p>Custom views can bind to their own listeners by not specifying an ID.</p>
+            <pre class="prettyprint">public class FancyButton extends Button {
+  @OnClick
+  public void onClick() {
+    // TODO do something!
+  }
+}
+</pre>
 
-            <h4 id="reset">Injection Reset</h4>
-            <p>Fragments have a different view lifecycle than activities. When injecting a fragment in <code>onCreateView</code>, set the views to <code>null</code> in <code>onDestroyView</code>. Butter Knife has a <code>reset</code> method to do this automatically.</p>
+            <h4 id="reset">Binding Reset</h4>
+            <p>Fragments have a different view lifecycle than activities. When binding a fragment in <code>onCreateView</code>, set the views to <code>null</code> in <code>onDestroyView</code>. Butter Knife returns an <code>Unbinder</code> instance when you call <code>bind</code> to do this for you. Call its <code>unbind</code> method in the appropriate lifecycle callback.</p>
             <pre class="prettyprint">public class FancyFragment extends Fragment {
-  @InjectView(R.id.button1) Button button1;
-  @InjectView(R.id.button2) Button button2;
+  @BindView(R.id.button1) Button button1;
+  @BindView(R.id.button2) Button button2;
+  private Unbinder unbinder;
 
-  @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View view = inflater.inflate(R.layout.fancy_fragment, container, false);
-    ButterKnife.inject(this, view);
-    // TODO Use "injected" views...
+    unbinder = ButterKnife.bind(this, view);
+    // TODO Use fields...
     return view;
   }
 
-  @Override void onDestroyView() {
+  @Override public void onDestroyView() {
     super.onDestroyView();
-    ButterKnife.reset(this);
+    unbinder.unbind();
   }
 }</pre>
 
-            <h4 id="optional">Optional Injections</h4>
-            <p>By default, both <code>@InjectView</code> and <code>@OnClick</code> injections are required. An exception will be thrown if the target view cannot be found.</p>
-            <p>To suppress this behavior and create an optional injection, add the <code>@Optional</code> annotation to the field or method.</p>
-            <pre class="prettyprint">@Optional @InjectView(R.id.might_not_be_there) TextView mightNotBeThere;
+            <h4 id="optional">Optional Bindings</h4>
+            <p>By default, both <code>@Bind</code> and listener bindings are required. An exception will be thrown if the target view cannot be found.</p>
+            <p>To suppress this behavior and create an optional binding, add a <code>@Nullable</code> annotation to fields or the <code>@Optional</code> annotation to methods.</p>
+            <p>Note: Any annotation named <code>@Nullable</code> can be used for fields. It is encouraged to use the <code>@Nullable</code> annotation from <a href="http://tools.android.com/tech-docs/support-annotations">Android's "support-annotations" library</a>.</p>
+            <pre class="prettyprint">@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;
 
 @Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() {
   // TODO ...
@@ -177,52 +202,10 @@ <h4 id="multi-method-listeners">Multi-Method Listeners</h4>
   // TODO ...
 }</pre>
 
-            <h4 id="bonus">Bonus</h4>
-            <p>Also included are two <code>findById</code> methods which simplify code that still has to find views on a <code>View</code> or <code>Activity</code>. It uses generics to infer the return type and automatically performs the cast.</p>
-            <pre class="prettyprint">View view = LayoutInflater.from(context).inflate(R.layout.thing, null);
-TextView firstName = ButterKnife.findById(view, R.id.first_name);
-TextView lastName = ButterKnife.findById(view, R.id.last_name);
-ImageView photo = ButterKnife.findById(view, R.id.photo);</pre>
-            <p>Add a static import for <code>ButterKnife.findById</code> and enjoy even more fun.</p>
-
             <h3 id="download">Download</h3>
-            <p class="downloads">
-              <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.jakewharton&a=butterknife&v=LATEST" class="btn btn-large btn-inverse" id="download-btn">Butter Knife JAR <span class="runner-version"></span></a>
-            </p>
-            <p>The source code to the library and sample application as well as this website is <a href="http://github.com/JakeWharton/butterknife">available on GitHub</a>. The Javadoc is also <a href="javadoc/index.html">available to browse</a>.</p>
-
-            <h4>Maven</h4>
-            <p>If you are using Maven for compilation you can declare the library as a dependency.</p>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.jakewharton&lt;/groupId>
-  &lt;artifactId>butterknife&lt;/artifactId>
-  &lt;version><span class="version"><em>(insert latest version)</em></span>&lt;/version>
-&lt;/dependency></pre>
-
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.jakewharton:butterknife:<span class="version"><em>(insert latest version)</em></span>'</pre>
-            <p>Be sure to supress this lint warning in your <code>build.gradle</code>.</p>
-            <pre class="prettyprint">lintOptions {
-  disable 'InvalidPackage'
-}</pre>
-            <p>Some configurations may also require additional exclusions.</p>
-            <pre class="prettyprint">packagingOptions {
-  exclude 'META-INF/services/javax.annotation.processing.Processor'
-}</pre>
-
-            <h4 id="ide">IDE Configuration</h4>
-            <p>Some IDEs require additional configuration in order to enable annotation processing.</p>
-            <ul>
-              <li><em>IntelliJ IDEA</em> &mdash; If your project uses an external configuration (like a Maven <code>pom.xml</code>) then annotation processing should just work. If not, try <a href="ide-idea.html">manual configuration</a>.</li>
-              <li><em>Eclipse</em> &mdash; Set up <a href="ide-eclipse.html">manual configuration</a>.</li>
-            </ul>
-
-            <h4 id="proguard">ProGuard</h4>
-            <p>Butter Knife generates and uses classes dynamically which means that static analysis tools like ProGuard may think they are unused. In order to prevent them from being removed, explicitly mark them to be kept.
-                To prevent ProGuard renaming classes that use @InjectView on a member field the <code>keepnames</code> option is used.</p>
-            <pre>-dontwarn butterknife.internal.**
--keep class **$$ViewInjector { *; }
--keepnames class * { @butterknife.InjectView *;}</pre>
+            <pre class="prettyprint">implementation 'com.jakewharton:butterknife:<span class="version"><em>(insert latest version)</em></span>'
+annotationProcessor 'com.jakewharton:butterknife-compiler:<span class="version"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="license">License</h3>
             <pre class="license">Copyright 2013 Jake Wharton
@@ -244,14 +227,13 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </div>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
     <script src="static/prettify.js"></script>
     <script>
       prettyPrint();
       $.fn.artifactVersion('com.jakewharton', 'butterknife', function(version, url) {
         $('.version').text(version);
-        $('#download-btn').text('Butter Knife v' + version + ' JAR').attr('href', url);
       });
     </script>
   </body>
