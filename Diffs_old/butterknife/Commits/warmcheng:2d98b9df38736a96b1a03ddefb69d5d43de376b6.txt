diff --git a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
index 8faac8b1..e09ece21 100644
--- a/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
+++ b/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java
@@ -28,6 +28,7 @@
 import butterknife.compiler.FieldTypefaceBinding.TypefaceStyles;
 import butterknife.internal.ListenerClass;
 import butterknife.internal.ListenerMethod;
+
 import com.google.auto.common.SuperficialValidation;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableSet;
@@ -39,6 +40,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.TreeScanner;
+
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -56,6 +58,7 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -88,1437 +91,1472 @@
 
 @AutoService(Processor.class)
 public final class ButterKnifeProcessor extends AbstractProcessor {
-  // TODO remove when http://b.android.com/187527 is released.
-  private static final String OPTION_SDK_INT = "butterknife.minSdk";
-  private static final String OPTION_DEBUGGABLE = "butterknife.debuggable";
-  static final Id NO_ID = new Id(-1);
-  static final String VIEW_TYPE = "android.view.View";
-  static final String ACTIVITY_TYPE = "android.app.Activity";
-  static final String DIALOG_TYPE = "android.app.Dialog";
-  private static final String COLOR_STATE_LIST_TYPE = "android.content.res.ColorStateList";
-  private static final String BITMAP_TYPE = "android.graphics.Bitmap";
-  private static final String ANIMATION_TYPE = "android.view.animation.Animation";
-  private static final String DRAWABLE_TYPE = "android.graphics.drawable.Drawable";
-  private static final String TYPED_ARRAY_TYPE = "android.content.res.TypedArray";
-  private static final String TYPEFACE_TYPE = "android.graphics.Typeface";
-  private static final String NULLABLE_ANNOTATION_NAME = "Nullable";
-  private static final String STRING_TYPE = "java.lang.String";
-  private static final String LIST_TYPE = List.class.getCanonicalName();
-  private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
-      OnCheckedChanged.class, //
-      OnClick.class, //
-      OnEditorAction.class, //
-      OnFocusChange.class, //
-      OnItemClick.class, //
-      OnItemLongClick.class, //
-      OnItemSelected.class, //
-      OnLongClick.class, //
-      OnPageChange.class, //
-      OnTextChanged.class, //
-      OnTouch.class //
-  );
-
-  private static final List<String> SUPPORTED_TYPES = Arrays.asList(
-      "array", "attr", "bool", "color", "dimen", "drawable", "id", "integer", "string"
-  );
-
-  private Elements elementUtils;
-  private Types typeUtils;
-  private Filer filer;
-  private Trees trees;
-
-  private int sdk = 1;
-  private boolean debuggable = true;
-
-  private final Map<QualifiedId, Id> symbols = new LinkedHashMap<>();
-
-  @Override public synchronized void init(ProcessingEnvironment env) {
-    super.init(env);
-
-    String sdk = env.getOptions().get(OPTION_SDK_INT);
-    if (sdk != null) {
-      try {
-        this.sdk = Integer.parseInt(sdk);
-      } catch (NumberFormatException e) {
-        env.getMessager()
-            .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '"
-                + sdk
-                + "'. Falling back to API 1 support.");
-      }
-    }
+    // TODO remove when http://b.android.com/187527 is released.
+    private static final String OPTION_SDK_INT = "butterknife.minSdk";
+    private static final String OPTION_DEBUGGABLE = "butterknife.debuggable";
+    static final Id NO_ID = new Id(-1);
+    static final String VIEW_TYPE = "android.view.View";
+    static final String ACTIVITY_TYPE = "android.app.Activity";
+    static final String DIALOG_TYPE = "android.app.Dialog";
+    private static final String COLOR_STATE_LIST_TYPE = "android.content.res.ColorStateList";
+    private static final String BITMAP_TYPE = "android.graphics.Bitmap";
+    private static final String ANIMATION_TYPE = "android.view.animation.Animation";
+    private static final String DRAWABLE_TYPE = "android.graphics.drawable.Drawable";
+    private static final String TYPED_ARRAY_TYPE = "android.content.res.TypedArray";
+    private static final String TYPEFACE_TYPE = "android.graphics.Typeface";
+    private static final String NULLABLE_ANNOTATION_NAME = "Nullable";
+    private static final String STRING_TYPE = "java.lang.String";
+    private static final String LIST_TYPE = List.class.getCanonicalName();
+    private static final List<Class<? extends Annotation>> LISTENERS = Arrays.asList(//
+            OnCheckedChanged.class, //
+            OnClick.class, //
+            OnEditorAction.class, //
+            OnFocusChange.class, //
+            OnItemClick.class, //
+            OnItemLongClick.class, //
+            OnItemSelected.class, //
+            OnLongClick.class, //
+            OnPageChange.class, //
+            OnTextChanged.class, //
+            OnTouch.class //
+    );
+
+    private static final List<String> SUPPORTED_TYPES = Arrays.asList(
+            "array", "attr", "bool", "color", "dimen", "drawable", "id", "integer", "string"
+    );
+
+    private Elements elementUtils;
+    private Types typeUtils;
+    private Filer filer; // 文件相关的辅助类
+    private Trees trees;
+
+    private int sdk = 1;
+    private boolean debuggable = true;
+
+    private final Map<QualifiedId, Id> symbols = new LinkedHashMap<>();
+
+    @Override
+    public synchronized void init(ProcessingEnvironment env) {
+        super.init(env);
+
+        /**
+         * env.getOptions() 获取到的是一个 map ，它的 key 就是函数 getSupportedOptions() 返回的 Set 包含的值
+         */
+        String sdk = env.getOptions().get(OPTION_SDK_INT);
+        if (sdk != null) {
+            try {
+                this.sdk = Integer.parseInt(sdk);
+            } catch (NumberFormatException e) {
+                env.getMessager()
+                        .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '"
+                                + sdk
+                                + "'. Falling back to API 1 support.");
+            }
+        }
 
-    debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
+        debuggable = !"false".equals(env.getOptions().get(OPTION_DEBUGGABLE));
 
-    elementUtils = env.getElementUtils();
-    typeUtils = env.getTypeUtils();
-    filer = env.getFiler();
-    try {
-      trees = Trees.instance(processingEnv);
-    } catch (IllegalArgumentException ignored) {
+        elementUtils = env.getElementUtils();
+        typeUtils = env.getTypeUtils();
+        filer = env.getFiler();
+        try {
+            trees = Trees.instance(processingEnv);
+        } catch (IllegalArgumentException ignored) {
+        }
     }
-  }
-
-  @Override public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(OPTION_SDK_INT, OPTION_DEBUGGABLE);
-  }
 
-  @Override public Set<String> getSupportedAnnotationTypes() {
-    Set<String> types = new LinkedHashSet<>();
-    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
-      types.add(annotation.getCanonicalName());
+    @Override
+    public Set<String> getSupportedOptions() {
+        // 返回一个由 OPTION_SDK_INT 和 OPTION_DEBUGGABLE 组成的不可变的 Set
+        // 这是为了增强 processor 的功能，我们可以自定义需要的值来进行解析
+        return ImmutableSet.of(OPTION_SDK_INT, OPTION_DEBUGGABLE);
     }
-    return types;
-  }
-
-  private Set<Class<? extends Annotation>> getSupportedAnnotations() {
-    Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
-
-    annotations.add(BindAnim.class);
-    annotations.add(BindArray.class);
-    annotations.add(BindBitmap.class);
-    annotations.add(BindBool.class);
-    annotations.add(BindColor.class);
-    annotations.add(BindDimen.class);
-    annotations.add(BindDrawable.class);
-    annotations.add(BindFloat.class);
-    annotations.add(BindFont.class);
-    annotations.add(BindInt.class);
-    annotations.add(BindString.class);
-    annotations.add(BindView.class);
-    annotations.add(BindViews.class);
-    annotations.addAll(LISTENERS);
-
-    return annotations;
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
-    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
-
-    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
-      TypeElement typeElement = entry.getKey();
-      BindingSet binding = entry.getValue();
-
-      JavaFile javaFile = binding.brewJava(sdk, debuggable);
-      try {
-        javaFile.writeTo(filer);
-      } catch (IOException e) {
-        error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
-      }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+        // 返回我们支持的注解类型，然后添加到一个 Set 中进行返回，
+        // 这里 getCanonicalName() 返回的是类的完全限定名，
+        // 当该类是匿名类的时候，getName()返回的字符串中遇到“.”的时候会自动转变为“$”，这也是它和getCanonicalName()的区别，
+        // 而 getSimple() 返回的就是类的名字，丢失了包名等上下文信息
+        Set<String> types = new LinkedHashSet<>();
+        for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
+            types.add(annotation.getCanonicalName());
+        }
+        return types;
+    }
+
+    /**
+     * 返回我们支持的注解类型
+     */
+    private Set<Class<? extends Annotation>> getSupportedAnnotations() {
+
+        Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();
+
+        annotations.add(BindAnim.class);
+        annotations.add(BindArray.class);
+        annotations.add(BindBitmap.class);
+        annotations.add(BindBool.class);
+        annotations.add(BindColor.class);
+        annotations.add(BindDimen.class);
+        annotations.add(BindDrawable.class);
+        annotations.add(BindFloat.class);
+        annotations.add(BindFont.class);
+        annotations.add(BindInt.class);
+        annotations.add(BindString.class);
+        annotations.add(BindView.class);
+        annotations.add(BindViews.class);
+        annotations.addAll(LISTENERS); // LISTENERS 中包含的是跟“事件”相关的注解
+
+        return annotations;
+    }
+
+    /**
+     * @param elements 返回的所有的注解相关的 Set
+     * @param env      RoundEnvironment ,应该译为“周边环境”，用来存储扫描到的所有的注解及其相关的信息
+     *                 （注意，是所有注解，而非仅包含我们自定义的注解）
+     * @return 返回 false，表示我们只处理我们自定义的这些注解，其他注解交由其对应的注解处理器进行处理
+     */
+    @Override
+    public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+        Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);
+
+        for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
+            TypeElement typeElement = entry.getKey();
+            BindingSet binding = entry.getValue();
+
+            // 根据 BindingSet 来生成对应的  JavaFile(它是 JavaPoet 里的类)，进而再生成 Java 文件
+            JavaFile javaFile = binding.brewJava(sdk, debuggable);
+            try {
+                javaFile.writeTo(filer);
+            } catch (IOException e) {
+                error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
+            }
+        }
+
+        return false;
     }
 
-    return false;
-  }
+    private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
+        Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
+        Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
 
-  private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
-    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
-    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
+        scanForRClasses(env); // 扫描R类,获取所有的需要处理的资源的信息
 
-    scanForRClasses(env);
+        // Process each @BindAnim element.
+        for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceAnimation(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindAnim.class, e);
+            }
+        }
 
-    // Process each @BindAnim element.
-    for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceAnimation(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindAnim.class, e);
-      }
-    }
+        // Process each @BindArray element.
+        for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceArray(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindArray.class, e);
+            }
+        }
 
-    // Process each @BindArray element.
-    for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceArray(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindArray.class, e);
-      }
-    }
+        // Process each @BindBitmap element.
+        for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceBitmap(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindBitmap.class, e);
+            }
+        }
 
-    // Process each @BindBitmap element.
-    for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceBitmap(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindBitmap.class, e);
-      }
-    }
+        // Process each @BindBool element.
+        for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceBool(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindBool.class, e);
+            }
+        }
 
-    // Process each @BindBool element.
-    for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceBool(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindBool.class, e);
-      }
-    }
+        // Process each @BindColor element.
+        for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceColor(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindColor.class, e);
+            }
+        }
 
-    // Process each @BindColor element.
-    for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceColor(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindColor.class, e);
-      }
-    }
+        // Process each @BindDimen element.
+        for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceDimen(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindDimen.class, e);
+            }
+        }
 
-    // Process each @BindDimen element.
-    for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceDimen(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindDimen.class, e);
-      }
-    }
+        // Process each @BindDrawable element.
+        for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceDrawable(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindDrawable.class, e);
+            }
+        }
 
-    // Process each @BindDrawable element.
-    for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceDrawable(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindDrawable.class, e);
-      }
-    }
+        // Process each @BindFloat element.
+        for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceFloat(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindFloat.class, e);
+            }
+        }
 
-    // Process each @BindFloat element.
-    for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceFloat(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindFloat.class, e);
-      }
-    }
+        // Process each @BindFont element.
+        for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceFont(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindFont.class, e);
+            }
+        }
 
-    // Process each @BindFont element.
-    for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceFont(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindFont.class, e);
-      }
-    }
+        // Process each @BindInt element.
+        for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceInt(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindInt.class, e);
+            }
+        }
 
-    // Process each @BindInt element.
-    for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceInt(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindInt.class, e);
-      }
-    }
+        // Process each @BindString element.
+        for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseResourceString(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindString.class, e);
+            }
+        }
 
-    // Process each @BindString element.
-    for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseResourceString(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindString.class, e);
-      }
-    }
+        // Process each @BindView element.
+        for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
+            // we don't SuperficialValidation.validateElement(element)
+            // so that an unresolved View type can be generated by later processing rounds
+            try {
+                parseBindView(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindView.class, e);
+            }
+        }
 
-    // Process each @BindView element.
-    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
-      // we don't SuperficialValidation.validateElement(element)
-      // so that an unresolved View type can be generated by later processing rounds
-      try {
-        parseBindView(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindView.class, e);
-      }
-    }
+        // Process each @BindViews element.
+        for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
+            // we don't SuperficialValidation.validateElement(element)
+            // so that an unresolved View type can be generated by later processing rounds
+            try {
+                parseBindViews(element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                logParsingError(element, BindViews.class, e);
+            }
+        }
 
-    // Process each @BindViews element.
-    for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
-      // we don't SuperficialValidation.validateElement(element)
-      // so that an unresolved View type can be generated by later processing rounds
-      try {
-        parseBindViews(element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        logParsingError(element, BindViews.class, e);
-      }
-    }
+        // Process each annotation that corresponds to a listener.
+        for (Class<? extends Annotation> listener : LISTENERS) {
+            findAndParseListener(env, listener, builderMap, erasedTargetNames);
+        }
 
-    // Process each annotation that corresponds to a listener.
-    for (Class<? extends Annotation> listener : LISTENERS) {
-      findAndParseListener(env, listener, builderMap, erasedTargetNames);
-    }
+        // Associate superclass binders with their subclass binders. This is a queue-based tree walk
+        // which starts at the roots (superclasses) and walks to the leafs (subclasses).
+        Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
+                new ArrayDeque<>(builderMap.entrySet());
+        Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
+        while (!entries.isEmpty()) {
+            Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();
 
-    // Associate superclass binders with their subclass binders. This is a queue-based tree walk
-    // which starts at the roots (superclasses) and walks to the leafs (subclasses).
-    Deque<Map.Entry<TypeElement, BindingSet.Builder>> entries =
-        new ArrayDeque<>(builderMap.entrySet());
-    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();
-    while (!entries.isEmpty()) {
-      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();
-
-      TypeElement type = entry.getKey();
-      BindingSet.Builder builder = entry.getValue();
-
-      TypeElement parentType = findParentType(type, erasedTargetNames);
-      if (parentType == null) {
-        bindingMap.put(type, builder.build());
-      } else {
-        BindingSet parentBinding = bindingMap.get(parentType);
-        if (parentBinding != null) {
-          builder.setParent(parentBinding);
-          bindingMap.put(type, builder.build());
-        } else {
-          // Has a superclass binding but we haven't built it yet. Re-enqueue for later.
-          entries.addLast(entry);
+            TypeElement type = entry.getKey();
+            BindingSet.Builder builder = entry.getValue();
+
+            TypeElement parentType = findParentType(type, erasedTargetNames);
+            if (parentType == null) {
+                bindingMap.put(type, builder.build());
+            } else {
+                BindingSet parentBinding = bindingMap.get(parentType);
+                if (parentBinding != null) {
+                    builder.setParent(parentBinding);
+                    bindingMap.put(type, builder.build());
+                } else {
+                    // Has a superclass binding but we haven't built it yet. Re-enqueue for later.
+                    entries.addLast(entry);
+                }
+            }
         }
-      }
-    }
 
-    return bindingMap;
-  }
-
-  private void logParsingError(Element element, Class<? extends Annotation> annotation,
-      Exception e) {
-    StringWriter stackTrace = new StringWriter();
-    e.printStackTrace(new PrintWriter(stackTrace));
-    error(element, "Unable to parse @%s binding.\n\n%s", annotation.getSimpleName(), stackTrace);
-  }
-
-  private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass,
-      String targetThing, Element element) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify method modifiers.
-    Set<Modifier> modifiers = element.getModifiers();
-    if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
-      error(element, "@%s %s must not be private or static. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+        return bindingMap;
     }
 
-    // Verify containing type.
-    if (enclosingElement.getKind() != CLASS) {
-      error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+    private void logParsingError(Element element, Class<? extends Annotation> annotation,
+                                 Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+        error(element, "Unable to parse @%s binding.\n\n%s", annotation.getSimpleName(), stackTrace);
     }
 
-    // Verify containing class visibility is not private.
-    if (enclosingElement.getModifiers().contains(PRIVATE)) {
-      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
-          annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass,
+                                                   String targetThing, Element element) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify method modifiers.
+        Set<Modifier> modifiers = element.getModifiers();
+        if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {
+            error(element, "@%s %s must not be private or static. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    return hasError;
-  }
+        // Verify containing type.
+        if (enclosingElement.getKind() != CLASS) {
+            error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
-      Element element) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-    String qualifiedName = enclosingElement.getQualifiedName().toString();
+        // Verify containing class visibility is not private.
+        if (enclosingElement.getModifiers().contains(PRIVATE)) {
+            error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
+                    annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (qualifiedName.startsWith("android.")) {
-      error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
+        return hasError;
     }
-    if (qualifiedName.startsWith("java.")) {
-      error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
-          annotationClass.getSimpleName(), qualifiedName);
-      return true;
+
+    private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass,
+                                            Element element) {
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        String qualifiedName = enclosingElement.getQualifiedName().toString();
+
+        if (qualifiedName.startsWith("android.")) {
+            error(element, "@%s-annotated class incorrectly in Android framework package. (%s)",
+                    annotationClass.getSimpleName(), qualifiedName);
+            return true;
+        }
+        if (qualifiedName.startsWith("java.")) {
+            error(element, "@%s-annotated class incorrectly in Java framework package. (%s)",
+                    annotationClass.getSimpleName(), qualifiedName);
+            return true;
+        }
+
+        return false;
     }
 
-    return false;
-  }
+    private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+                               Set<TypeElement> erasedTargetNames) {
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-  private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
-      Set<TypeElement> erasedTargetNames) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Start by verifying common generated code restrictions.
+        boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
+                || isBindingInWrongPackage(BindView.class, element);
 
-    // Start by verifying common generated code restrictions.
-    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
-        || isBindingInWrongPackage(BindView.class, element);
+        // Verify that the target type extends from View.
+        TypeMirror elementType = element.asType();
+        if (elementType.getKind() == TypeKind.TYPEVAR) {
+            TypeVariable typeVariable = (TypeVariable) elementType;
+            elementType = typeVariable.getUpperBound();
+        }
+        Name qualifiedName = enclosingElement.getQualifiedName();
+        Name simpleName = element.getSimpleName();
+        if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
+            if (elementType.getKind() == TypeKind.ERROR) {
+                note(element, "@%s field with unresolved type (%s) "
+                                + "must elsewhere be generated as a View or interface. (%s.%s)",
+                        BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
+            } else {
+                error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
+                        BindView.class.getSimpleName(), qualifiedName, simpleName);
+                hasError = true;
+            }
+        }
 
-    // Verify that the target type extends from View.
-    TypeMirror elementType = element.asType();
-    if (elementType.getKind() == TypeKind.TYPEVAR) {
-      TypeVariable typeVariable = (TypeVariable) elementType;
-      elementType = typeVariable.getUpperBound();
-    }
-    Name qualifiedName = enclosingElement.getQualifiedName();
-    Name simpleName = element.getSimpleName();
-    if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
-      if (elementType.getKind() == TypeKind.ERROR) {
-        note(element, "@%s field with unresolved type (%s) "
-                + "must elsewhere be generated as a View or interface. (%s.%s)",
-            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
-      } else {
-        error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
-            BindView.class.getSimpleName(), qualifiedName, simpleName);
-        hasError = true;
-      }
-    }
+        if (hasError) {
+            return;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Assemble information on the field.
+        int id = element.getAnnotation(BindView.class).value();
+
+        BindingSet.Builder builder = builderMap.get(enclosingElement);
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        if (builder != null) {
+            String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
+            if (existingBindingName != null) {
+                error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
+                        BindView.class.getSimpleName(), id, existingBindingName,
+                        enclosingElement.getQualifiedName(), element.getSimpleName());
+                return;
+            }
+        } else {
+            builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        }
 
-    // Assemble information on the field.
-    int id = element.getAnnotation(BindView.class).value();
-
-    BindingSet.Builder builder = builderMap.get(enclosingElement);
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    if (builder != null) {
-      String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
-      if (existingBindingName != null) {
-        error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
-            BindView.class.getSimpleName(), id, existingBindingName,
-            enclosingElement.getQualifiedName(), element.getSimpleName());
-        return;
-      }
-    } else {
-      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    }
+        String name = simpleName.toString();
+        TypeName type = TypeName.get(elementType);
+        boolean required = isFieldRequired(element);
+
+        builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));
+
+        // Add the type-erased version to the valid binding targets set.
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private QualifiedId elementToQualifiedId(Element element, int id) {
+        return new QualifiedId(elementUtils.getPackageOf(element), id);
+    }
+
+    private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
+                                Set<TypeElement> erasedTargetNames) {
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Start by verifying common generated code restrictions.
+        boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
+                || isBindingInWrongPackage(BindViews.class, element);
+
+        // Verify that the type is a List or an array.
+        TypeMirror elementType = element.asType();
+        String erasedType = doubleErasure(elementType);
+        TypeMirror viewType = null;
+        FieldCollectionViewBinding.Kind kind = null;
+        if (elementType.getKind() == TypeKind.ARRAY) {
+            ArrayType arrayType = (ArrayType) elementType;
+            viewType = arrayType.getComponentType();
+            kind = FieldCollectionViewBinding.Kind.ARRAY;
+        } else if (LIST_TYPE.equals(erasedType)) {
+            DeclaredType declaredType = (DeclaredType) elementType;
+            List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+            if (typeArguments.size() != 1) {
+                error(element, "@%s List must have a generic component. (%s.%s)",
+                        BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+                hasError = true;
+            } else {
+                viewType = typeArguments.get(0);
+            }
+            kind = FieldCollectionViewBinding.Kind.LIST;
+        } else {
+            error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
+        if (viewType != null && viewType.getKind() == TypeKind.TYPEVAR) {
+            TypeVariable typeVariable = (TypeVariable) viewType;
+            viewType = typeVariable.getUpperBound();
+        }
 
-    String name = simpleName.toString();
-    TypeName type = TypeName.get(elementType);
-    boolean required = isFieldRequired(element);
-
-    builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));
-
-    // Add the type-erased version to the valid binding targets set.
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private QualifiedId elementToQualifiedId(Element element, int id) {
-    return new QualifiedId(elementUtils.getPackageOf(element), id);
-  }
-
-  private void parseBindViews(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
-      Set<TypeElement> erasedTargetNames) {
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Start by verifying common generated code restrictions.
-    boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element)
-        || isBindingInWrongPackage(BindViews.class, element);
-
-    // Verify that the type is a List or an array.
-    TypeMirror elementType = element.asType();
-    String erasedType = doubleErasure(elementType);
-    TypeMirror viewType = null;
-    FieldCollectionViewBinding.Kind kind = null;
-    if (elementType.getKind() == TypeKind.ARRAY) {
-      ArrayType arrayType = (ArrayType) elementType;
-      viewType = arrayType.getComponentType();
-      kind = FieldCollectionViewBinding.Kind.ARRAY;
-    } else if (LIST_TYPE.equals(erasedType)) {
-      DeclaredType declaredType = (DeclaredType) elementType;
-      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-      if (typeArguments.size() != 1) {
-        error(element, "@%s List must have a generic component. (%s.%s)",
-            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-        hasError = true;
-      } else {
-        viewType = typeArguments.get(0);
-      }
-      kind = FieldCollectionViewBinding.Kind.LIST;
-    } else {
-      error(element, "@%s must be a List or array. (%s.%s)", BindViews.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
-    if (viewType != null && viewType.getKind() == TypeKind.TYPEVAR) {
-      TypeVariable typeVariable = (TypeVariable) viewType;
-      viewType = typeVariable.getUpperBound();
-    }
+        // Verify that the target type extends from View.
+        if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
+            if (viewType.getKind() == TypeKind.ERROR) {
+                note(element, "@%s List or array with unresolved type (%s) "
+                                + "must elsewhere be generated as a View or interface. (%s.%s)",
+                        BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+            } else {
+                error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
+                        BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                        element.getSimpleName());
+                hasError = true;
+            }
+        }
 
-    // Verify that the target type extends from View.
-    if (viewType != null && !isSubtypeOfType(viewType, VIEW_TYPE) && !isInterface(viewType)) {
-      if (viewType.getKind() == TypeKind.ERROR) {
-        note(element, "@%s List or array with unresolved type (%s) "
-                + "must elsewhere be generated as a View or interface. (%s.%s)",
-            BindViews.class.getSimpleName(), viewType, enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-      } else {
-        error(element, "@%s List or array type must extend from View or be an interface. (%s.%s)",
-            BindViews.class.getSimpleName(), enclosingElement.getQualifiedName(),
-            element.getSimpleName());
-        hasError = true;
-      }
-    }
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int[] ids = element.getAnnotation(BindViews.class).value();
+        if (ids.length == 0) {
+            error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int[] ids = element.getAnnotation(BindViews.class).value();
-    if (ids.length == 0) {
-      error(element, "@%s must specify at least one ID. (%s.%s)", BindViews.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        Integer duplicateId = findDuplicate(ids);
+        if (duplicateId != null) {
+            error(element, "@%s annotation contains duplicate ID %d. (%s.%s)",
+                    BindViews.class.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    Integer duplicateId = findDuplicate(ids);
-    if (duplicateId != null) {
-      error(element, "@%s annotation contains duplicate ID %d. (%s.%s)",
-          BindViews.class.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    if (hasError) {
-      return;
-    }
+        assert viewType != null; // Always false as hasError would have been true.
+        TypeName type = TypeName.get(viewType);
+        boolean required = isFieldRequired(element);
+
+        List<Id> idVars = new ArrayList<>();
+        for (int id : ids) {
+            QualifiedId qualifiedId = elementToQualifiedId(element, id);
+            idVars.add(getId(qualifiedId));
+        }
 
-    assert viewType != null; // Always false as hasError would have been true.
-    TypeName type = TypeName.get(viewType);
-    boolean required = isFieldRequired(element);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required));
 
-    List<Id> idVars = new ArrayList<>();
-    for (int id : ids) {
-      QualifiedId qualifiedId = elementToQualifiedId(element, id);
-      idVars.add(getId(qualifiedId));
+        erasedTargetNames.add(enclosingElement);
     }
 
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required));
+    private void parseResourceAnimation(Element element,
+                                        Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    erasedTargetNames.add(enclosingElement);
-  }
+        // Verify that the target type is Animation.
+        if (!ANIMATION_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Animation'. (%s.%s)",
+                    BindAnim.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private void parseResourceAnimation(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindAnim.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindAnim.class, element);
 
-    // Verify that the target type is Animation.
-    if (!ANIMATION_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Animation'. (%s.%s)",
-          BindAnim.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindAnim.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindAnim.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindAnim.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldAnimationBinding(getId(qualifiedId), name));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindAnim.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldAnimationBinding(getId(qualifiedId), name));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceBool(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is bool.
-    if (element.asType().getKind() != TypeKind.BOOLEAN) {
-      error(element, "@%s field type must be 'boolean'. (%s.%s)",
-          BindBool.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceBool(Element element,
+                                   Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindBool.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindBool.class, element);
+        // Verify that the target type is bool.
+        if (element.asType().getKind() != TypeKind.BOOLEAN) {
+            error(element, "@%s field type must be 'boolean'. (%s.%s)",
+                    BindBool.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindBool.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindBool.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindBool.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BOOL));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceColor(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is int or ColorStateList.
-    boolean isColorStateList = false;
-    TypeMirror elementType = element.asType();
-    if (COLOR_STATE_LIST_TYPE.equals(elementType.toString())) {
-      isColorStateList = true;
-    } else if (elementType.getKind() != TypeKind.INT) {
-      error(element, "@%s field type must be 'int' or 'ColorStateList'. (%s.%s)",
-          BindColor.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindColor.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindColor.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindBool.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BOOL));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceColor(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is int or ColorStateList.
+        boolean isColorStateList = false;
+        TypeMirror elementType = element.asType();
+        if (COLOR_STATE_LIST_TYPE.equals(elementType.toString())) {
+            isColorStateList = true;
+        } else if (elementType.getKind() != TypeKind.INT) {
+            error(element, "@%s field type must be 'int' or 'ColorStateList'. (%s.%s)",
+                    BindColor.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindColor.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindColor.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindColor.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
-        isColorStateList ? FieldResourceBinding.Type.COLOR_STATE_LIST
-            : FieldResourceBinding.Type.COLOR));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceDimen(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is int or ColorStateList.
-    boolean isInt = false;
-    TypeMirror elementType = element.asType();
-    if (elementType.getKind() == TypeKind.INT) {
-      isInt = true;
-    } else if (elementType.getKind() != TypeKind.FLOAT) {
-      error(element, "@%s field type must be 'int' or 'float'. (%s.%s)",
-          BindDimen.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindDimen.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindDimen.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindColor.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
+                isColorStateList ? FieldResourceBinding.Type.COLOR_STATE_LIST
+                        : FieldResourceBinding.Type.COLOR));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceDimen(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is int or ColorStateList.
+        boolean isInt = false;
+        TypeMirror elementType = element.asType();
+        if (elementType.getKind() == TypeKind.INT) {
+            isInt = true;
+        } else if (elementType.getKind() != TypeKind.FLOAT) {
+            error(element, "@%s field type must be 'int' or 'float'. (%s.%s)",
+                    BindDimen.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindDimen.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindDimen.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindDimen.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
-        isInt ? FieldResourceBinding.Type.DIMEN_AS_INT : FieldResourceBinding.Type.DIMEN_AS_FLOAT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceBitmap(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is Bitmap.
-    if (!BITMAP_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Bitmap'. (%s.%s)",
-          BindBitmap.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindBitmap.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindBitmap.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindDimen.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name,
+                isInt ? FieldResourceBinding.Type.DIMEN_AS_INT : FieldResourceBinding.Type.DIMEN_AS_FLOAT));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindBitmap.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BITMAP));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceDrawable(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is Drawable.
-    if (!DRAWABLE_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Drawable'. (%s.%s)",
-          BindDrawable.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceBitmap(Element element,
+                                     Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindDrawable.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindDrawable.class, element);
+        // Verify that the target type is Bitmap.
+        if (!BITMAP_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Bitmap'. (%s.%s)",
+                    BindBitmap.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindBitmap.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindBitmap.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindDrawable.class).value();
-    int tint = element.getAnnotation(BindDrawable.class).tint();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    QualifiedId qualifiedTint = elementToQualifiedId(element, tint);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldDrawableBinding(getId(qualifiedId), name, getId(qualifiedTint)));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceFloat(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is float.
-    if (element.asType().getKind() != TypeKind.FLOAT) {
-      error(element, "@%s field type must be 'float'. (%s.%s)",
-          BindFloat.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindFloat.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindFloat.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindBitmap.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.BITMAP));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindFloat.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.FLOAT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceFont(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is a Typeface.
-    if (!TYPEFACE_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'Typeface'. (%s.%s)",
-          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceDrawable(Element element,
+                                       Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is Drawable.
+        if (!DRAWABLE_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Drawable'. (%s.%s)",
+                    BindDrawable.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindFont.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindFont.class, element);
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindDrawable.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindDrawable.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    BindFont bindFont = element.getAnnotation(BindFont.class);
+        if (hasError) {
+            return;
+        }
 
-    int styleValue = bindFont.style();
-    TypefaceStyles style = TypefaceStyles.fromValue(styleValue);
-    if (style == null) {
-      error(element, "@%s style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (%s.%s)",
-          BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(), name);
-      hasError = true;
-    }
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindDrawable.class).value();
+        int tint = element.getAnnotation(BindDrawable.class).tint();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        QualifiedId qualifiedTint = elementToQualifiedId(element, tint);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldDrawableBinding(getId(qualifiedId), name, getId(qualifiedTint)));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    QualifiedId qualifiedId = elementToQualifiedId(element, bindFont.value());
-    builder.addResource(new FieldTypefaceBinding(getId(qualifiedId), name, style));
+    private void parseResourceFloat(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    erasedTargetNames.add(enclosingElement);
-  }
+        // Verify that the target type is float.
+        if (element.asType().getKind() != TypeKind.FLOAT) {
+            error(element, "@%s field type must be 'float'. (%s.%s)",
+                    BindFloat.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-  private void parseResourceInt(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindFloat.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindFloat.class, element);
 
-    // Verify that the target type is int.
-    if (element.asType().getKind() != TypeKind.INT) {
-      error(element, "@%s field type must be 'int'. (%s.%s)", BindInt.class.getSimpleName(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindInt.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindInt.class, element);
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindFloat.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.FLOAT));
 
-    if (hasError) {
-      return;
+        erasedTargetNames.add(enclosingElement);
     }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindInt.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.INT));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceString(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is String.
-    if (!STRING_TYPE.equals(element.asType().toString())) {
-      error(element, "@%s field type must be 'String'. (%s.%s)",
-          BindString.class.getSimpleName(), enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+    private void parseResourceFont(Element element,
+                                   Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindString.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindString.class, element);
+        // Verify that the target type is a Typeface.
+        if (!TYPEFACE_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'Typeface'. (%s.%s)",
+                    BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindFont.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindFont.class, element);
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindString.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(
-        new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.STRING));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private void parseResourceArray(Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    boolean hasError = false;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
-
-    // Verify that the target type is supported.
-    FieldResourceBinding.Type type = getArrayResourceMethodName(element);
-    if (type == null) {
-      error(element,
-          "@%s field type must be one of: String[], int[], CharSequence[], %s. (%s.%s)",
-          BindArray.class.getSimpleName(), TYPED_ARRAY_TYPE, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
-    }
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        BindFont bindFont = element.getAnnotation(BindFont.class);
 
-    // Verify common generated code restrictions.
-    hasError |= isInaccessibleViaGeneratedCode(BindArray.class, "fields", element);
-    hasError |= isBindingInWrongPackage(BindArray.class, element);
+        int styleValue = bindFont.style();
+        TypefaceStyles style = TypefaceStyles.fromValue(styleValue);
+        if (style == null) {
+            error(element, "@%s style must be NORMAL, BOLD, ITALIC, or BOLD_ITALIC. (%s.%s)",
+                    BindFont.class.getSimpleName(), enclosingElement.getQualifiedName(), name);
+            hasError = true;
+        }
 
-    if (hasError) {
-      return;
-    }
+        if (hasError) {
+            return;
+        }
 
-    // Assemble information on the field.
-    String name = element.getSimpleName().toString();
-    int id = element.getAnnotation(BindArray.class).value();
-    QualifiedId qualifiedId = elementToQualifiedId(element, id);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    builder.addResource(new FieldResourceBinding(getId(qualifiedId), name, type));
-
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  /**
-   * Returns a method name from the {@link android.content.res.Resources} class for array resource
-   * binding, null if the element type is not supported.
-   */
-  private static FieldResourceBinding.Type getArrayResourceMethodName(Element element) {
-    TypeMirror typeMirror = element.asType();
-    if (TYPED_ARRAY_TYPE.equals(typeMirror.toString())) {
-      return FieldResourceBinding.Type.TYPED_ARRAY;
-    }
-    if (TypeKind.ARRAY.equals(typeMirror.getKind())) {
-      ArrayType arrayType = (ArrayType) typeMirror;
-      String componentType = arrayType.getComponentType().toString();
-      if (STRING_TYPE.equals(componentType)) {
-        return FieldResourceBinding.Type.STRING_ARRAY;
-      } else if ("int".equals(componentType)) {
-        return FieldResourceBinding.Type.INT_ARRAY;
-      } else if ("java.lang.CharSequence".equals(componentType)) {
-        return FieldResourceBinding.Type.TEXT_ARRAY;
-      }
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        QualifiedId qualifiedId = elementToQualifiedId(element, bindFont.value());
+        builder.addResource(new FieldTypefaceBinding(getId(qualifiedId), name, style));
+
+        erasedTargetNames.add(enclosingElement);
     }
-    return null;
-  }
 
-  /** Returns the first duplicate element inside an array, null if there are no duplicates. */
-  private static Integer findDuplicate(int[] array) {
-    Set<Integer> seenElements = new LinkedHashSet<>();
+    private void parseResourceInt(Element element,
+                                  Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
 
-    for (int element : array) {
-      if (!seenElements.add(element)) {
-        return element;
-      }
-    }
+        // Verify that the target type is int.
+        if (element.asType().getKind() != TypeKind.INT) {
+            error(element, "@%s field type must be 'int'. (%s.%s)", BindInt.class.getSimpleName(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    return null;
-  }
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindInt.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindInt.class, element);
 
-  /** Uses both {@link Types#erasure} and string manipulation to strip any generic types. */
-  private String doubleErasure(TypeMirror elementType) {
-    String name = typeUtils.erasure(elementType).toString();
-    int typeParamStart = name.indexOf('<');
-    if (typeParamStart != -1) {
-      name = name.substring(0, typeParamStart);
-    }
-    return name;
-  }
-
-  private void findAndParseListener(RoundEnvironment env,
-      Class<? extends Annotation> annotationClass,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
-    for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
-      if (!SuperficialValidation.validateElement(element)) continue;
-      try {
-        parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);
-      } catch (Exception e) {
-        StringWriter stackTrace = new StringWriter();
-        e.printStackTrace(new PrintWriter(stackTrace));
+        if (hasError) {
+            return;
+        }
 
-        error(element, "Unable to generate view binder for @%s.\n\n%s",
-            annotationClass.getSimpleName(), stackTrace.toString());
-      }
-    }
-  }
-
-  private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
-      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames)
-      throws Exception {
-    // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
-    if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
-      throw new IllegalStateException(
-          String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindInt.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.INT));
+
+        erasedTargetNames.add(enclosingElement);
     }
 
-    ExecutableElement executableElement = (ExecutableElement) element;
-    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+    private void parseResourceString(Element element,
+                                     Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is String.
+        if (!STRING_TYPE.equals(element.asType().toString())) {
+            error(element, "@%s field type must be 'String'. (%s.%s)",
+                    BindString.class.getSimpleName(), enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
+
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindString.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindString.class, element);
+
+        if (hasError) {
+            return;
+        }
+
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindString.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(
+                new FieldResourceBinding(getId(qualifiedId), name, FieldResourceBinding.Type.STRING));
+
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    private void parseResourceArray(Element element,
+                                    Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        boolean hasError = false;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Verify that the target type is supported.
+        FieldResourceBinding.Type type = getArrayResourceMethodName(element);
+        if (type == null) {
+            error(element,
+                    "@%s field type must be one of: String[], int[], CharSequence[], %s. (%s.%s)",
+                    BindArray.class.getSimpleName(), TYPED_ARRAY_TYPE, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
+            hasError = true;
+        }
+
+        // Verify common generated code restrictions.
+        hasError |= isInaccessibleViaGeneratedCode(BindArray.class, "fields", element);
+        hasError |= isBindingInWrongPackage(BindArray.class, element);
+
+        if (hasError) {
+            return;
+        }
+
+        // Assemble information on the field.
+        String name = element.getSimpleName().toString();
+        int id = element.getAnnotation(BindArray.class).value();
+        QualifiedId qualifiedId = elementToQualifiedId(element, id);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        builder.addResource(new FieldResourceBinding(getId(qualifiedId), name, type));
 
-    // Assemble information on the method.
-    Annotation annotation = element.getAnnotation(annotationClass);
-    Method annotationValue = annotationClass.getDeclaredMethod("value");
-    if (annotationValue.getReturnType() != int[].class) {
-      throw new IllegalStateException(
-          String.format("@%s annotation value() type not int[].", annotationClass));
+        erasedTargetNames.add(enclosingElement);
+    }
+
+    /**
+     * Returns a method name from the {@link android.content.res.Resources} class for array resource
+     * binding, null if the element type is not supported.
+     */
+    private static FieldResourceBinding.Type getArrayResourceMethodName(Element element) {
+        TypeMirror typeMirror = element.asType();
+        if (TYPED_ARRAY_TYPE.equals(typeMirror.toString())) {
+            return FieldResourceBinding.Type.TYPED_ARRAY;
+        }
+        if (TypeKind.ARRAY.equals(typeMirror.getKind())) {
+            ArrayType arrayType = (ArrayType) typeMirror;
+            String componentType = arrayType.getComponentType().toString();
+            if (STRING_TYPE.equals(componentType)) {
+                return FieldResourceBinding.Type.STRING_ARRAY;
+            } else if ("int".equals(componentType)) {
+                return FieldResourceBinding.Type.INT_ARRAY;
+            } else if ("java.lang.CharSequence".equals(componentType)) {
+                return FieldResourceBinding.Type.TEXT_ARRAY;
+            }
+        }
+        return null;
     }
 
-    int[] ids = (int[]) annotationValue.invoke(annotation);
-    String name = executableElement.getSimpleName().toString();
-    boolean required = isListenerRequired(executableElement);
+    /**
+     * Returns the first duplicate element inside an array, null if there are no duplicates.
+     */
+    private static Integer findDuplicate(int[] array) {
+        Set<Integer> seenElements = new LinkedHashSet<>();
 
-    // Verify that the method and its containing class are accessible via generated code.
-    boolean hasError = isInaccessibleViaGeneratedCode(annotationClass, "methods", element);
-    hasError |= isBindingInWrongPackage(annotationClass, element);
+        for (int element : array) {
+            if (!seenElements.add(element)) {
+                return element;
+            }
+        }
 
-    Integer duplicateId = findDuplicate(ids);
-    if (duplicateId != null) {
-      error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
-          annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
-          element.getSimpleName());
-      hasError = true;
+        return null;
     }
 
-    ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
-    if (listener == null) {
-      throw new IllegalStateException(
-          String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
-              annotationClass.getSimpleName()));
+    /**
+     * Uses both {@link Types#erasure} and string manipulation to strip any generic types.
+     */
+    private String doubleErasure(TypeMirror elementType) {
+        String name = typeUtils.erasure(elementType).toString();
+        int typeParamStart = name.indexOf('<');
+        if (typeParamStart != -1) {
+            name = name.substring(0, typeParamStart);
+        }
+        return name;
+    }
+
+    private void findAndParseListener(RoundEnvironment env,
+                                      Class<? extends Annotation> annotationClass,
+                                      Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames) {
+        for (Element element : env.getElementsAnnotatedWith(annotationClass)) {
+            if (!SuperficialValidation.validateElement(element)) continue;
+            try {
+                parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);
+            } catch (Exception e) {
+                StringWriter stackTrace = new StringWriter();
+                e.printStackTrace(new PrintWriter(stackTrace));
+
+                error(element, "Unable to generate view binder for @%s.\n\n%s",
+                        annotationClass.getSimpleName(), stackTrace.toString());
+            }
+        }
     }
 
-    for (int id : ids) {
-      if (id == NO_ID.value) {
-        if (ids.length == 1) {
-          if (!required) {
-            error(element, "ID-free binding must not be annotated with @Optional. (%s.%s)",
-                enclosingElement.getQualifiedName(), element.getSimpleName());
+    private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,
+                                         Map<TypeElement, BindingSet.Builder> builderMap, Set<TypeElement> erasedTargetNames)
+            throws Exception {
+        // This should be guarded by the annotation's @Target but it's worth a check for safe casting.
+        if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {
+            throw new IllegalStateException(
+                    String.format("@%s annotation must be on a method.", annotationClass.getSimpleName()));
+        }
+
+        ExecutableElement executableElement = (ExecutableElement) element;
+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+        // Assemble information on the method.
+        Annotation annotation = element.getAnnotation(annotationClass);
+        Method annotationValue = annotationClass.getDeclaredMethod("value");
+        if (annotationValue.getReturnType() != int[].class) {
+            throw new IllegalStateException(
+                    String.format("@%s annotation value() type not int[].", annotationClass));
+        }
+
+        int[] ids = (int[]) annotationValue.invoke(annotation);
+        String name = executableElement.getSimpleName().toString();
+        boolean required = isListenerRequired(executableElement);
+
+        // Verify that the method and its containing class are accessible via generated code.
+        boolean hasError = isInaccessibleViaGeneratedCode(annotationClass, "methods", element);
+        hasError |= isBindingInWrongPackage(annotationClass, element);
+
+        Integer duplicateId = findDuplicate(ids);
+        if (duplicateId != null) {
+            error(element, "@%s annotation for method contains duplicate ID %d. (%s.%s)",
+                    annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),
+                    element.getSimpleName());
             hasError = true;
-          }
+        }
+
+        ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);
+        if (listener == null) {
+            throw new IllegalStateException(
+                    String.format("No @%s defined on @%s.", ListenerClass.class.getSimpleName(),
+                            annotationClass.getSimpleName()));
+        }
+
+        for (int id : ids) {
+            if (id == NO_ID.value) {
+                if (ids.length == 1) {
+                    if (!required) {
+                        error(element, "ID-free binding must not be annotated with @Optional. (%s.%s)",
+                                enclosingElement.getQualifiedName(), element.getSimpleName());
+                        hasError = true;
+                    }
+                } else {
+                    error(element, "@%s annotation contains invalid ID %d. (%s.%s)",
+                            annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
+                            element.getSimpleName());
+                    hasError = true;
+                }
+            }
+        }
+
+        ListenerMethod method;
+        ListenerMethod[] methods = listener.method();
+        if (methods.length > 1) {
+            throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
+                    annotationClass.getSimpleName()));
+        } else if (methods.length == 1) {
+            if (listener.callbacks() != ListenerClass.NONE.class) {
+                throw new IllegalStateException(
+                        String.format("Both method() and callback() defined on @%s.",
+                                annotationClass.getSimpleName()));
+            }
+            method = methods[0];
         } else {
-          error(element, "@%s annotation contains invalid ID %d. (%s.%s)",
-              annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),
-              element.getSimpleName());
-          hasError = true;
+            Method annotationCallback = annotationClass.getDeclaredMethod("callback");
+            Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
+            Field callbackField = callback.getDeclaringClass().getField(callback.name());
+            method = callbackField.getAnnotation(ListenerMethod.class);
+            if (method == null) {
+                throw new IllegalStateException(
+                        String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
+                                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
+                                callback.name()));
+            }
         }
-      }
-    }
 
-    ListenerMethod method;
-    ListenerMethod[] methods = listener.method();
-    if (methods.length > 1) {
-      throw new IllegalStateException(String.format("Multiple listener methods specified on @%s.",
-          annotationClass.getSimpleName()));
-    } else if (methods.length == 1) {
-      if (listener.callbacks() != ListenerClass.NONE.class) {
-        throw new IllegalStateException(
-            String.format("Both method() and callback() defined on @%s.",
-                annotationClass.getSimpleName()));
-      }
-      method = methods[0];
-    } else {
-      Method annotationCallback = annotationClass.getDeclaredMethod("callback");
-      Enum<?> callback = (Enum<?>) annotationCallback.invoke(annotation);
-      Field callbackField = callback.getDeclaringClass().getField(callback.name());
-      method = callbackField.getAnnotation(ListenerMethod.class);
-      if (method == null) {
-        throw new IllegalStateException(
-            String.format("No @%s defined on @%s's %s.%s.", ListenerMethod.class.getSimpleName(),
-                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),
-                callback.name()));
-      }
-    }
+        // Verify that the method has equal to or less than the number of parameters as the listener.
+        List<? extends VariableElement> methodParameters = executableElement.getParameters();
+        if (methodParameters.size() > method.parameters().length) {
+            error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
+                    annotationClass.getSimpleName(), method.parameters().length,
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Verify that the method has equal to or less than the number of parameters as the listener.
-    List<? extends VariableElement> methodParameters = executableElement.getParameters();
-    if (methodParameters.size() > method.parameters().length) {
-      error(element, "@%s methods can have at most %s parameter(s). (%s.%s)",
-          annotationClass.getSimpleName(), method.parameters().length,
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
-    }
+        // Verify method return type matches the listener.
+        TypeMirror returnType = executableElement.getReturnType();
+        if (returnType instanceof TypeVariable) {
+            TypeVariable typeVariable = (TypeVariable) returnType;
+            returnType = typeVariable.getUpperBound();
+        }
+        if (!returnType.toString().equals(method.returnType())) {
+            error(element, "@%s methods must have a '%s' return type. (%s.%s)",
+                    annotationClass.getSimpleName(), method.returnType(),
+                    enclosingElement.getQualifiedName(), element.getSimpleName());
+            hasError = true;
+        }
 
-    // Verify method return type matches the listener.
-    TypeMirror returnType = executableElement.getReturnType();
-    if (returnType instanceof TypeVariable) {
-      TypeVariable typeVariable = (TypeVariable) returnType;
-      returnType = typeVariable.getUpperBound();
-    }
-    if (!returnType.toString().equals(method.returnType())) {
-      error(element, "@%s methods must have a '%s' return type. (%s.%s)",
-          annotationClass.getSimpleName(), method.returnType(),
-          enclosingElement.getQualifiedName(), element.getSimpleName());
-      hasError = true;
+        if (hasError) {
+            return;
+        }
+
+        Parameter[] parameters = Parameter.NONE;
+        if (!methodParameters.isEmpty()) {
+            parameters = new Parameter[methodParameters.size()];
+            BitSet methodParameterUsed = new BitSet(methodParameters.size());
+            String[] parameterTypes = method.parameters();
+            for (int i = 0; i < methodParameters.size(); i++) {
+                VariableElement methodParameter = methodParameters.get(i);
+                TypeMirror methodParameterType = methodParameter.asType();
+                if (methodParameterType instanceof TypeVariable) {
+                    TypeVariable typeVariable = (TypeVariable) methodParameterType;
+                    methodParameterType = typeVariable.getUpperBound();
+                }
+
+                for (int j = 0; j < parameterTypes.length; j++) {
+                    if (methodParameterUsed.get(j)) {
+                        continue;
+                    }
+                    if ((isSubtypeOfType(methodParameterType, parameterTypes[j])
+                            && isSubtypeOfType(methodParameterType, VIEW_TYPE))
+                            || isTypeEqual(methodParameterType, parameterTypes[j])
+                            || isInterface(methodParameterType)) {
+                        parameters[i] = new Parameter(j, TypeName.get(methodParameterType));
+                        methodParameterUsed.set(j);
+                        break;
+                    }
+                }
+                if (parameters[i] == null) {
+                    StringBuilder builder = new StringBuilder();
+                    builder.append("Unable to match @")
+                            .append(annotationClass.getSimpleName())
+                            .append(" method arguments. (")
+                            .append(enclosingElement.getQualifiedName())
+                            .append('.')
+                            .append(element.getSimpleName())
+                            .append(')');
+                    for (int j = 0; j < parameters.length; j++) {
+                        Parameter parameter = parameters[j];
+                        builder.append("\n\n  Parameter #")
+                                .append(j + 1)
+                                .append(": ")
+                                .append(methodParameters.get(j).asType().toString())
+                                .append("\n    ");
+                        if (parameter == null) {
+                            builder.append("did not match any listener parameters");
+                        } else {
+                            builder.append("matched listener parameter #")
+                                    .append(parameter.getListenerPosition() + 1)
+                                    .append(": ")
+                                    .append(parameter.getType());
+                        }
+                    }
+                    builder.append("\n\nMethods may have up to ")
+                            .append(method.parameters().length)
+                            .append(" parameter(s):\n");
+                    for (String parameterType : method.parameters()) {
+                        builder.append("\n  ").append(parameterType);
+                    }
+                    builder.append(
+                            "\n\nThese may be listed in any order but will be searched for from top to bottom.");
+                    error(executableElement, builder.toString());
+                    return;
+                }
+            }
+        }
+
+        MethodViewBinding binding = new MethodViewBinding(name, Arrays.asList(parameters), required);
+        BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
+        for (int id : ids) {
+            QualifiedId qualifiedId = elementToQualifiedId(element, id);
+            if (!builder.addMethod(getId(qualifiedId), listener, method, binding)) {
+                error(element, "Multiple listener methods with return value specified for ID %d. (%s.%s)",
+                        id, enclosingElement.getQualifiedName(), element.getSimpleName());
+                return;
+            }
+        }
+
+        // Add the type-erased version to the valid binding targets set.
+        erasedTargetNames.add(enclosingElement);
     }
 
-    if (hasError) {
-      return;
+    private boolean isInterface(TypeMirror typeMirror) {
+        return typeMirror instanceof DeclaredType
+                && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
     }
 
-    Parameter[] parameters = Parameter.NONE;
-    if (!methodParameters.isEmpty()) {
-      parameters = new Parameter[methodParameters.size()];
-      BitSet methodParameterUsed = new BitSet(methodParameters.size());
-      String[] parameterTypes = method.parameters();
-      for (int i = 0; i < methodParameters.size(); i++) {
-        VariableElement methodParameter = methodParameters.get(i);
-        TypeMirror methodParameterType = methodParameter.asType();
-        if (methodParameterType instanceof TypeVariable) {
-          TypeVariable typeVariable = (TypeVariable) methodParameterType;
-          methodParameterType = typeVariable.getUpperBound();
-        }
-
-        for (int j = 0; j < parameterTypes.length; j++) {
-          if (methodParameterUsed.get(j)) {
-            continue;
-          }
-          if ((isSubtypeOfType(methodParameterType, parameterTypes[j])
-                  && isSubtypeOfType(methodParameterType, VIEW_TYPE))
-              || isTypeEqual(methodParameterType, parameterTypes[j])
-              || isInterface(methodParameterType)) {
-            parameters[i] = new Parameter(j, TypeName.get(methodParameterType));
-            methodParameterUsed.set(j);
-            break;
-          }
-        }
-        if (parameters[i] == null) {
-          StringBuilder builder = new StringBuilder();
-          builder.append("Unable to match @")
-              .append(annotationClass.getSimpleName())
-              .append(" method arguments. (")
-              .append(enclosingElement.getQualifiedName())
-              .append('.')
-              .append(element.getSimpleName())
-              .append(')');
-          for (int j = 0; j < parameters.length; j++) {
-            Parameter parameter = parameters[j];
-            builder.append("\n\n  Parameter #")
-                .append(j + 1)
-                .append(": ")
-                .append(methodParameters.get(j).asType().toString())
-                .append("\n    ");
-            if (parameter == null) {
-              builder.append("did not match any listener parameters");
-            } else {
-              builder.append("matched listener parameter #")
-                  .append(parameter.getListenerPosition() + 1)
-                  .append(": ")
-                  .append(parameter.getType());
+    static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
+        if (isTypeEqual(typeMirror, otherType)) {
+            return true;
+        }
+        if (typeMirror.getKind() != TypeKind.DECLARED) {
+            return false;
+        }
+        DeclaredType declaredType = (DeclaredType) typeMirror;
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (typeArguments.size() > 0) {
+            StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
+            typeString.append('<');
+            for (int i = 0; i < typeArguments.size(); i++) {
+                if (i > 0) {
+                    typeString.append(',');
+                }
+                typeString.append('?');
+            }
+            typeString.append('>');
+            if (typeString.toString().equals(otherType)) {
+                return true;
             }
-          }
-          builder.append("\n\nMethods may have up to ")
-              .append(method.parameters().length)
-              .append(" parameter(s):\n");
-          for (String parameterType : method.parameters()) {
-            builder.append("\n  ").append(parameterType);
-          }
-          builder.append(
-              "\n\nThese may be listed in any order but will be searched for from top to bottom.");
-          error(executableElement, builder.toString());
-          return;
-        }
-      }
+        }
+        Element element = declaredType.asElement();
+        if (!(element instanceof TypeElement)) {
+            return false;
+        }
+        TypeElement typeElement = (TypeElement) element;
+        TypeMirror superType = typeElement.getSuperclass();
+        if (isSubtypeOfType(superType, otherType)) {
+            return true;
+        }
+        for (TypeMirror interfaceType : typeElement.getInterfaces()) {
+            if (isSubtypeOfType(interfaceType, otherType)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    MethodViewBinding binding = new MethodViewBinding(name, Arrays.asList(parameters), required);
-    BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
-    for (int id : ids) {
-      QualifiedId qualifiedId = elementToQualifiedId(element, id);
-      if (!builder.addMethod(getId(qualifiedId), listener, method, binding)) {
-        error(element, "Multiple listener methods with return value specified for ID %d. (%s.%s)",
-            id, enclosingElement.getQualifiedName(), element.getSimpleName());
-        return;
-      }
+    private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
+        return otherType.equals(typeMirror.toString());
     }
 
-    // Add the type-erased version to the valid binding targets set.
-    erasedTargetNames.add(enclosingElement);
-  }
-
-  private boolean isInterface(TypeMirror typeMirror) {
-    return typeMirror instanceof DeclaredType
-        && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;
-  }
+    private BindingSet.Builder getOrCreateBindingBuilder(
+            Map<TypeElement, BindingSet.Builder> builderMap, TypeElement enclosingElement) {
+        BindingSet.Builder builder = builderMap.get(enclosingElement);
+        if (builder == null) {
+            builder = BindingSet.newBuilder(enclosingElement);
+            builderMap.put(enclosingElement, builder);
+        }
+        return builder;
+    }
+
+    /**
+     * Finds the parent binder type in the supplied set, if any.
+     */
+    private TypeElement findParentType(TypeElement typeElement, Set<TypeElement> parents) {
+        TypeMirror type;
+        while (true) {
+            type = typeElement.getSuperclass();
+            if (type.getKind() == TypeKind.NONE) {
+                return null;
+            }
+            typeElement = (TypeElement) ((DeclaredType) type).asElement();
+            if (parents.contains(typeElement)) {
+                return typeElement;
+            }
+        }
+    }
 
-  static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {
-    if (isTypeEqual(typeMirror, otherType)) {
-      return true;
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+        // 返回支持的 JDK 版本，此处返回的是目前支持的最新版本
+        return SourceVersion.latestSupported();
     }
-    if (typeMirror.getKind() != TypeKind.DECLARED) {
-      return false;
+
+    private void error(Element element, String message, Object... args) {
+        printMessage(Kind.ERROR, element, message, args);
     }
-    DeclaredType declaredType = (DeclaredType) typeMirror;
-    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-    if (typeArguments.size() > 0) {
-      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
-      typeString.append('<');
-      for (int i = 0; i < typeArguments.size(); i++) {
-        if (i > 0) {
-          typeString.append(',');
-        }
-        typeString.append('?');
-      }
-      typeString.append('>');
-      if (typeString.toString().equals(otherType)) {
-        return true;
-      }
+
+    private void note(Element element, String message, Object... args) {
+        printMessage(Kind.NOTE, element, message, args);
     }
-    Element element = declaredType.asElement();
-    if (!(element instanceof TypeElement)) {
-      return false;
+
+    private void printMessage(Kind kind, Element element, String message, Object[] args) {
+        if (args.length > 0) {
+            message = String.format(message, args);
+        }
+
+        processingEnv.getMessager().printMessage(kind, message, element);
     }
-    TypeElement typeElement = (TypeElement) element;
-    TypeMirror superType = typeElement.getSuperclass();
-    if (isSubtypeOfType(superType, otherType)) {
-      return true;
+
+    private static boolean hasAnnotationWithName(Element element, String simpleName) {
+        for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+            String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();
+            if (simpleName.equals(annotationName)) {
+                return true;
+            }
+        }
+        return false;
     }
-    for (TypeMirror interfaceType : typeElement.getInterfaces()) {
-      if (isSubtypeOfType(interfaceType, otherType)) {
-        return true;
-      }
+
+    private static boolean isFieldRequired(Element element) {
+        return !hasAnnotationWithName(element, NULLABLE_ANNOTATION_NAME);
     }
-    return false;
-  }
-
-  private static boolean isTypeEqual(TypeMirror typeMirror, String otherType) {
-    return otherType.equals(typeMirror.toString());
-  }
-
-  private BindingSet.Builder getOrCreateBindingBuilder(
-      Map<TypeElement, BindingSet.Builder> builderMap, TypeElement enclosingElement) {
-    BindingSet.Builder builder = builderMap.get(enclosingElement);
-    if (builder == null) {
-      builder = BindingSet.newBuilder(enclosingElement);
-      builderMap.put(enclosingElement, builder);
+
+    private static boolean isListenerRequired(ExecutableElement element) {
+        return element.getAnnotation(Optional.class) == null;
     }
-    return builder;
-  }
-
-  /** Finds the parent binder type in the supplied set, if any. */
-  private TypeElement findParentType(TypeElement typeElement, Set<TypeElement> parents) {
-    TypeMirror type;
-    while (true) {
-      type = typeElement.getSuperclass();
-      if (type.getKind() == TypeKind.NONE) {
+
+    private static AnnotationMirror getMirror(Element element,
+                                              Class<? extends Annotation> annotation) {
+        for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
+            if (annotationMirror.getAnnotationType().toString().equals(annotation.getCanonicalName())) {
+                return annotationMirror;
+            }
+        }
         return null;
-      }
-      typeElement = (TypeElement) ((DeclaredType) type).asElement();
-      if (parents.contains(typeElement)) {
-        return typeElement;
-      }
     }
-  }
 
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
+    private Id getId(QualifiedId qualifiedId) {
+        if (symbols.get(qualifiedId) == null) {
+            symbols.put(qualifiedId, new Id(qualifiedId.id));
+        }
+        return symbols.get(qualifiedId);
+    }
+
+    private void scanForRClasses(RoundEnvironment env) {
+        if (trees == null) return;
 
-  private void error(Element element, String message, Object... args) {
-    printMessage(Kind.ERROR, element, message, args);
-  }
+        RClassScanner scanner = new RClassScanner();
 
-  private void note(Element element, String message, Object... args) {
-    printMessage(Kind.NOTE, element, message, args);
-  }
+        for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
+            for (Element element : env.getElementsAnnotatedWith(annotation)) {
+                JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
+                if (tree != null) { // tree can be null if the references are compiled types and not source
+                    scanner.setCurrentPackage(elementUtils.getPackageOf(element));
+                    tree.accept(scanner);
+                }
+            }
+        }
 
-  private void printMessage(Kind kind, Element element, String message, Object[] args) {
-    if (args.length > 0) {
-      message = String.format(message, args);
+        for (Map.Entry<PackageElement, Set<Symbol.ClassSymbol>> packageNameToRClassSet
+                : scanner.getRClasses().entrySet()) {
+            PackageElement respectivePackageName = packageNameToRClassSet.getKey();
+            for (Symbol.ClassSymbol rClass : packageNameToRClassSet.getValue()) {
+                parseRClass(respectivePackageName, rClass, scanner.getReferenced());
+            }
+        }
     }
 
-    processingEnv.getMessager().printMessage(kind, message, element);
-  }
+    private void parseRClass(PackageElement respectivePackageName, Symbol.ClassSymbol rClass,
+                             Set<String> referenced) {
+        TypeElement element;
 
-  private static boolean hasAnnotationWithName(Element element, String simpleName) {
-    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
-      String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();
-      if (simpleName.equals(annotationName)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private static boolean isFieldRequired(Element element) {
-    return !hasAnnotationWithName(element, NULLABLE_ANNOTATION_NAME);
-  }
-
-  private static boolean isListenerRequired(ExecutableElement element) {
-    return element.getAnnotation(Optional.class) == null;
-  }
-
-  private static AnnotationMirror getMirror(Element element,
-      Class<? extends Annotation> annotation) {
-    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
-      if (annotationMirror.getAnnotationType().toString().equals(annotation.getCanonicalName())) {
-        return annotationMirror;
-      }
+        try {
+            element = rClass;
+        } catch (MirroredTypeException mte) {
+            element = (TypeElement) typeUtils.asElement(mte.getTypeMirror());
+        }
+
+        JCTree tree = (JCTree) trees.getTree(element);
+        if (tree != null) { // tree can be null if the references are compiled types and not source
+            IdScanner idScanner =
+                    new IdScanner(symbols, elementUtils.getPackageOf(element), respectivePackageName,
+                            referenced);
+            tree.accept(idScanner);
+        } else {
+            parseCompiledR(respectivePackageName, element, referenced);
+        }
     }
-    return null;
-  }
 
-  private Id getId(QualifiedId qualifiedId) {
-    if (symbols.get(qualifiedId) == null) {
-      symbols.put(qualifiedId, new Id(qualifiedId.id));
+    private void parseCompiledR(PackageElement respectivePackageName, TypeElement rClass,
+                                Set<String> referenced) {
+        for (Element element : rClass.getEnclosedElements()) {
+            String innerClassName = element.getSimpleName().toString();
+            if (SUPPORTED_TYPES.contains(innerClassName)) {
+                for (Element enclosedElement : element.getEnclosedElements()) {
+                    if (enclosedElement instanceof VariableElement) {
+                        String fqName = elementUtils.getPackageOf(enclosedElement).getQualifiedName().toString()
+                                + ".R."
+                                + innerClassName
+                                + "."
+                                + enclosedElement.toString();
+                        if (referenced.contains(fqName)) {
+                            VariableElement variableElement = (VariableElement) enclosedElement;
+                            Object value = variableElement.getConstantValue();
+
+                            if (value instanceof Integer) {
+                                int id = (Integer) value;
+                                ClassName rClassName =
+                                        ClassName.get(elementUtils.getPackageOf(variableElement).toString(), "R",
+                                                innerClassName);
+                                String resourceName = variableElement.getSimpleName().toString();
+                                QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
+                                symbols.put(qualifiedId, new Id(id, rClassName, resourceName));
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
-    return symbols.get(qualifiedId);
-  }
 
-  private void scanForRClasses(RoundEnvironment env) {
-    if (trees == null) return;
+    private static class RClassScanner extends TreeScanner {
+        // Maps the currently evaluated rPackageName to R Classes
+        private final Map<PackageElement, Set<Symbol.ClassSymbol>> rClasses = new LinkedHashMap<>();
+        private PackageElement currentPackage;
+        private Set<String> referenced = new HashSet<>();
+
+        @Override
+        public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
+            Symbol symbol = jcFieldAccess.sym;
+            if (symbol != null
+                    && symbol.getEnclosingElement() != null
+                    && symbol.getEnclosingElement().getEnclosingElement() != null
+                    && symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
+                Set<Symbol.ClassSymbol> rClassSet = rClasses.get(currentPackage);
+                if (rClassSet == null) {
+                    rClassSet = new HashSet<>();
+                    rClasses.put(currentPackage, rClassSet);
+                }
+                referenced.add(getFqName(symbol));
+                rClassSet.add(symbol.getEnclosingElement().getEnclosingElement().enclClass());
+            }
+        }
 
-    RClassScanner scanner = new RClassScanner();
+        Map<PackageElement, Set<Symbol.ClassSymbol>> getRClasses() {
+            return rClasses;
+        }
 
-    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
-      for (Element element : env.getElementsAnnotatedWith(annotation)) {
-        JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation));
-        if (tree != null) { // tree can be null if the references are compiled types and not source
-          scanner.setCurrentPackage(elementUtils.getPackageOf(element));
-          tree.accept(scanner);
+        Set<String> getReferenced() {
+            return referenced;
         }
-      }
-    }
 
-    for (Map.Entry<PackageElement, Set<Symbol.ClassSymbol>> packageNameToRClassSet
-          : scanner.getRClasses().entrySet()) {
-      PackageElement respectivePackageName = packageNameToRClassSet.getKey();
-      for (Symbol.ClassSymbol rClass : packageNameToRClassSet.getValue()) {
-        parseRClass(respectivePackageName, rClass, scanner.getReferenced());
-      }
+        void setCurrentPackage(PackageElement packageElement) {
+            this.currentPackage = packageElement;
+        }
     }
-  }
 
-  private void parseRClass(PackageElement respectivePackageName, Symbol.ClassSymbol rClass,
-      Set<String> referenced) {
-    TypeElement element;
+    private static class IdScanner extends TreeScanner {
+        private final Map<QualifiedId, Id> ids;
+        private final PackageElement rPackageName;
+        private final PackageElement respectivePackageName;
+        private final Set<String> referenced;
 
-    try {
-      element = rClass;
-    } catch (MirroredTypeException mte) {
-      element = (TypeElement) typeUtils.asElement(mte.getTypeMirror());
-    }
+        IdScanner(Map<QualifiedId, Id> ids, PackageElement rPackageName,
+                  PackageElement respectivePackageName, Set<String> referenced) {
+            this.ids = ids;
+            this.rPackageName = rPackageName;
+            this.respectivePackageName = respectivePackageName;
+            this.referenced = referenced;
+        }
 
-    JCTree tree = (JCTree) trees.getTree(element);
-    if (tree != null) { // tree can be null if the references are compiled types and not source
-      IdScanner idScanner =
-          new IdScanner(symbols, elementUtils.getPackageOf(element), respectivePackageName,
-              referenced);
-      tree.accept(idScanner);
-    } else {
-      parseCompiledR(respectivePackageName, element, referenced);
-    }
-  }
-
-  private void parseCompiledR(PackageElement respectivePackageName, TypeElement rClass,
-      Set<String> referenced) {
-    for (Element element : rClass.getEnclosedElements()) {
-      String innerClassName = element.getSimpleName().toString();
-      if (SUPPORTED_TYPES.contains(innerClassName)) {
-        for (Element enclosedElement : element.getEnclosedElements()) {
-          if (enclosedElement instanceof VariableElement) {
-            String fqName = elementUtils.getPackageOf(enclosedElement).getQualifiedName().toString()
-                + ".R."
-                + innerClassName
-                + "."
-                + enclosedElement.toString();
-            if (referenced.contains(fqName)) {
-              VariableElement variableElement = (VariableElement) enclosedElement;
-              Object value = variableElement.getConstantValue();
-
-              if (value instanceof Integer) {
-                int id = (Integer) value;
-                ClassName rClassName =
-                    ClassName.get(elementUtils.getPackageOf(variableElement).toString(), "R",
-                        innerClassName);
-                String resourceName = variableElement.getSimpleName().toString();
-                QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
-                symbols.put(qualifiedId, new Id(id, rClassName, resourceName));
-              }
+        @Override
+        public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
+            for (JCTree tree : jcClassDecl.defs) {
+                if (tree instanceof ClassTree) {
+                    ClassTree classTree = (ClassTree) tree;
+                    String className = classTree.getSimpleName().toString();
+                    if (SUPPORTED_TYPES.contains(className)) {
+                        ClassName rClassName = ClassName.get(rPackageName.getQualifiedName().toString(), "R",
+                                className);
+                        VarScanner scanner = new VarScanner(ids, rClassName, respectivePackageName, referenced);
+                        ((JCTree) classTree).accept(scanner);
+                    }
+                }
             }
-          }
         }
-      }
-    }
-  }
-
-  private static class RClassScanner extends TreeScanner {
-    // Maps the currently evaluated rPackageName to R Classes
-    private final Map<PackageElement, Set<Symbol.ClassSymbol>> rClasses = new LinkedHashMap<>();
-    private PackageElement currentPackage;
-    private Set<String> referenced = new HashSet<>();
-
-    @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) {
-      Symbol symbol = jcFieldAccess.sym;
-      if (symbol != null
-          && symbol.getEnclosingElement() != null
-          && symbol.getEnclosingElement().getEnclosingElement() != null
-          && symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) {
-        Set<Symbol.ClassSymbol> rClassSet = rClasses.get(currentPackage);
-        if (rClassSet == null) {
-          rClassSet = new HashSet<>();
-          rClasses.put(currentPackage, rClassSet);
-        }
-        referenced.add(getFqName(symbol));
-        rClassSet.add(symbol.getEnclosingElement().getEnclosingElement().enclClass());
-      }
-    }
-
-    Map<PackageElement, Set<Symbol.ClassSymbol>> getRClasses() {
-      return rClasses;
     }
 
-    Set<String> getReferenced() {
-      return referenced;
-    }
+    private static class VarScanner extends TreeScanner {
+        private final Map<QualifiedId, Id> ids;
+        private final ClassName className;
+        private final PackageElement respectivePackageName;
+        private final Set<String> referenced;
 
-    void setCurrentPackage(PackageElement packageElement) {
-      this.currentPackage = packageElement;
-    }
-  }
-
-  private static class IdScanner extends TreeScanner {
-    private final Map<QualifiedId, Id> ids;
-    private final PackageElement rPackageName;
-    private final PackageElement respectivePackageName;
-    private final Set<String> referenced;
-
-    IdScanner(Map<QualifiedId, Id> ids, PackageElement rPackageName,
-        PackageElement respectivePackageName, Set<String> referenced) {
-      this.ids = ids;
-      this.rPackageName = rPackageName;
-      this.respectivePackageName = respectivePackageName;
-      this.referenced = referenced;
-    }
+        private VarScanner(Map<QualifiedId, Id> ids, ClassName className,
+                           PackageElement respectivePackageName, Set<String> referenced) {
+            this.ids = ids;
+            this.className = className;
+            this.respectivePackageName = respectivePackageName;
+            this.referenced = referenced;
+        }
 
-    @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
-      for (JCTree tree : jcClassDecl.defs) {
-        if (tree instanceof ClassTree) {
-          ClassTree classTree = (ClassTree) tree;
-          String className = classTree.getSimpleName().toString();
-          if (SUPPORTED_TYPES.contains(className)) {
-            ClassName rClassName = ClassName.get(rPackageName.getQualifiedName().toString(), "R",
-                    className);
-            VarScanner scanner = new VarScanner(ids, rClassName, respectivePackageName, referenced);
-            ((JCTree) classTree).accept(scanner);
-          }
-        }
-      }
-    }
-  }
-
-  private static class VarScanner extends TreeScanner {
-    private final Map<QualifiedId, Id> ids;
-    private final ClassName className;
-    private final PackageElement respectivePackageName;
-    private final Set<String> referenced;
-
-    private VarScanner(Map<QualifiedId, Id> ids, ClassName className,
-        PackageElement respectivePackageName, Set<String> referenced) {
-      this.ids = ids;
-      this.className = className;
-      this.respectivePackageName = respectivePackageName;
-      this.referenced = referenced;
+        @Override
+        public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
+            if ("int".equals(jcVariableDecl.getType().toString())) {
+                String resourceName = jcVariableDecl.getName().toString();
+                if (referenced.contains(getFqName(jcVariableDecl.sym))) {
+                    int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
+                    QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
+                    ids.put(qualifiedId, new Id(id, className, resourceName));
+                }
+            }
+        }
     }
 
-    @Override public void visitVarDef(JCTree.JCVariableDecl jcVariableDecl) {
-      if ("int".equals(jcVariableDecl.getType().toString())) {
-        String resourceName = jcVariableDecl.getName().toString();
-        if (referenced.contains(getFqName(jcVariableDecl.sym))) {
-          int id = Integer.valueOf(jcVariableDecl.getInitializer().toString());
-          QualifiedId qualifiedId = new QualifiedId(respectivePackageName, id);
-          ids.put(qualifiedId, new Id(id, className, resourceName));
-        }
-      }
+    private static String getFqName(Symbol rSymbol) {
+        return rSymbol.packge().getQualifiedName().toString()
+                + ".R."
+                + rSymbol.enclClass().name.toString()
+                + "."
+                + rSymbol.name.toString();
     }
-  }
-
-  private static String getFqName(Symbol rSymbol) {
-    return rSymbol.packge().getQualifiedName().toString()
-        + ".R."
-        + rSymbol.enclClass().name.toString()
-        + "."
-        + rSymbol.name.toString();
-  }
 }
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java
index 7097639f..469c4528 100644
--- a/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/library/SimpleActivity.java
@@ -9,6 +9,7 @@
 import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
+
 import butterknife.BindString;
 import butterknife.BindView;
 import butterknife.BindViews;
@@ -16,6 +17,7 @@
 import butterknife.OnClick;
 import butterknife.OnItemClick;
 import butterknife.OnLongClick;
+
 import com.example.butterknife.R;
 
 import java.util.List;
@@ -23,56 +25,72 @@
 import static android.widget.Toast.LENGTH_SHORT;
 
 public class SimpleActivity extends Activity {
-  private static final ButterKnife.Action<View> ALPHA_FADE = new ButterKnife.Action<View>() {
-    @Override public void apply(@NonNull View view, int index) {
-      AlphaAnimation alphaAnimation = new AlphaAnimation(0, 1);
-      alphaAnimation.setFillBefore(true);
-      alphaAnimation.setDuration(500);
-      alphaAnimation.setStartOffset(index * 100);
-      view.startAnimation(alphaAnimation);
+
+    private static final ButterKnife.Action<View> ALPHA_FADE = new ButterKnife.Action<View>() {
+        @Override
+        public void apply(@NonNull View view, int index) {
+            AlphaAnimation alphaAnimation = new AlphaAnimation(0, 1);
+            alphaAnimation.setFillBefore(true);
+            alphaAnimation.setDuration(500);
+            alphaAnimation.setStartOffset(index * 100);
+            view.startAnimation(alphaAnimation);
+        }
+    };
+
+    @BindView(R.id.title)
+    TextView title;
+    @BindView(R.id.subtitle)
+    TextView subtitle;
+    @BindView(R.id.hello)
+    Button hello;
+    @BindView(R.id.list_of_things)
+    ListView listOfThings;
+    @BindView(R.id.footer)
+    TextView footer;
+    @BindString(R.string.app_name)
+    String butterKnife;
+    @BindString(R.string.field_method)
+    String fieldMethod;
+    @BindString(R.string.by_jake_wharton)
+    String byJakeWharton;
+    @BindString(R.string.say_hello)
+    String sayHello;
+
+    @BindViews({R.id.title, R.id.subtitle, R.id.hello})
+    List<View> headerViews;
+
+    private SimpleAdapter adapter;
+
+    @OnClick(R.id.hello)
+    void sayHello() {
+        Toast.makeText(this, "Hello, views!", LENGTH_SHORT).show();
+        ButterKnife.apply(headerViews, ALPHA_FADE);
+    }
+
+    @OnLongClick(R.id.hello)
+    boolean sayGetOffMe() {
+        Toast.makeText(this, "Let go of me!", LENGTH_SHORT).show();
+        return true;
+    }
+
+    @OnItemClick(R.id.list_of_things)
+    void onItemClick(int position) {
+        Toast.makeText(this, "You clicked: " + adapter.getItem(position), LENGTH_SHORT).show();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.simple_activity);
+        ButterKnife.bind(this);
+
+        // Contrived code to use the bound fields.
+        title.setText(butterKnife);
+        subtitle.setText(fieldMethod);
+        footer.setText(byJakeWharton);
+        hello.setText(sayHello);
+
+        adapter = new SimpleAdapter(this);
+        listOfThings.setAdapter(adapter);
     }
-  };
-
-  @BindView(R.id.title) TextView title;
-  @BindView(R.id.subtitle) TextView subtitle;
-  @BindView(R.id.hello) Button hello;
-  @BindView(R.id.list_of_things) ListView listOfThings;
-  @BindView(R.id.footer) TextView footer;
-  @BindString(R.string.app_name) String butterKnife;
-  @BindString(R.string.field_method) String fieldMethod;
-  @BindString(R.string.by_jake_wharton) String byJakeWharton;
-  @BindString(R.string.say_hello) String sayHello;
-
-  @BindViews({ R.id.title, R.id.subtitle, R.id.hello }) List<View> headerViews;
-
-  private SimpleAdapter adapter;
-
-  @OnClick(R.id.hello) void sayHello() {
-    Toast.makeText(this, "Hello, views!", LENGTH_SHORT).show();
-    ButterKnife.apply(headerViews, ALPHA_FADE);
-  }
-
-  @OnLongClick(R.id.hello) boolean sayGetOffMe() {
-    Toast.makeText(this, "Let go of me!", LENGTH_SHORT).show();
-    return true;
-  }
-
-  @OnItemClick(R.id.list_of_things) void onItemClick(int position) {
-    Toast.makeText(this, "You clicked: " + adapter.getItem(position), LENGTH_SHORT).show();
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.simple_activity);
-    ButterKnife.bind(this);
-
-    // Contrived code to use the bound fields.
-    title.setText(butterKnife);
-    subtitle.setText(fieldMethod);
-    footer.setText(byJakeWharton);
-    hello.setText(sayHello);
-
-    adapter = new SimpleAdapter(this);
-    listOfThings.setAdapter(adapter);
-  }
 }
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java
index 5f4db917..821bea2d 100644
--- a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/A.java
@@ -2,14 +2,17 @@
 
 import android.support.annotation.ColorInt;
 import android.view.View;
+
 import butterknife.BindColor;
 import butterknife.ButterKnife;
 
 public class A {
 
-  @BindColor(android.R.color.black) @ColorInt int blackColor;
+    @BindColor(android.R.color.black)
+    @ColorInt
+    int blackColor;
 
-  public A(View view) {
-    ButterKnife.bind(this, view);
-  }
+    public A(View view) {
+        ButterKnife.bind(this, view);
+    }
 }
diff --git a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java
index ee69cb08..038b15e6 100644
--- a/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java
+++ b/butterknife-integration-test/src/main/java/com/example/butterknife/unbinder/C.java
@@ -2,17 +2,21 @@
 
 import android.support.annotation.ColorInt;
 import android.view.View;
+
 import butterknife.BindColor;
 import butterknife.BindView;
 import butterknife.ButterKnife;
 
 public class C extends B {
 
-  @BindColor(android.R.color.transparent) @ColorInt int transparentColor;
-  @BindView(android.R.id.button1) View button1;
+    @BindColor(android.R.color.transparent)
+    @ColorInt
+    int transparentColor;
+    @BindView(android.R.id.button1)
+    View button1;
 
-  public C(View view) {
-    super(view);
-    ButterKnife.bind(this, view);
-  }
+    public C(View view) {
+        super(view);
+        ButterKnife.bind(this, view);
+    }
 }
diff --git a/butterknife/src/main/java/butterknife/ButterKnife.java b/butterknife/src/main/java/butterknife/ButterKnife.java
index e4090708..f33306e1 100644
--- a/butterknife/src/main/java/butterknife/ButterKnife.java
+++ b/butterknife/src/main/java/butterknife/ButterKnife.java
@@ -13,6 +13,7 @@
 import android.util.Log;
 import android.util.Property;
 import android.view.View;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.LinkedHashMap;
@@ -82,276 +83,333 @@
  * </code></pre>
  */
 public final class ButterKnife {
-  private ButterKnife() {
-    throw new AssertionError("No instances.");
-  }
+    private ButterKnife() {
+        throw new AssertionError("No instances.");
+    }
 
-  /** An action that can be applied to a list of views. */
-  public interface Action<T extends View> {
-    /** Apply the action on the {@code view} which is at {@code index} in the list. */
-    @UiThread
-    void apply(@NonNull T view, int index);
-  }
+    /**
+     * An action that can be applied to a list of views.
+     */
+    public interface Action<T extends View> {
+        /**
+         * Apply the action on the {@code view} which is at {@code index} in the list.
+         */
+        @UiThread
+        void apply(@NonNull T view, int index);
+    }
 
-  /** A setter that can apply a value to a list of views. */
-  public interface Setter<T extends View, V> {
-    /** Set the {@code value} on the {@code view} which is at {@code index} in the list. */
-    @UiThread
-    void set(@NonNull T view, V value, int index);
-  }
+    /**
+     * A setter that can apply a value to a list of views.
+     */
+    public interface Setter<T extends View, V> {
+        /**
+         * Set the {@code value} on the {@code view} which is at {@code index} in the list.
+         */
+        @UiThread
+        void set(@NonNull T view, V value, int index);
+    }
 
-  private static final String TAG = "ButterKnife";
-  private static boolean debug = false;
+    private static final String TAG = "ButterKnife";
+    private static boolean debug = false;
 
-  @VisibleForTesting
-  static final Map<Class<?>, Constructor<? extends Unbinder>> BINDINGS = new LinkedHashMap<>();
+    @VisibleForTesting
+    static final Map<Class<?>, Constructor<? extends Unbinder>> BINDINGS = new LinkedHashMap<>();
 
-  /** Control whether debug logging is enabled. */
-  public static void setDebug(boolean debug) {
-    ButterKnife.debug = debug;
-  }
+    /**
+     * Control whether debug logging is enabled.
+     */
+    public static void setDebug(boolean debug) {
+        ButterKnife.debug = debug;
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@link Activity}. The current content
-   * view is used as the view root.
-   *
-   * @param target Target activity for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Activity target) {
-    View sourceView = target.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
+    /**
+     * BindView annotated fields and methods in the specified {@link Activity}. The current content
+     * view is used as the view root.
+     *
+     * @param target Target activity for view binding.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Activity target) {
+        View sourceView = target.getWindow().getDecorView();
+        return createBinding(target, sourceView);
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@link View}. The view and its children
-   * are used as the view root.
-   *
-   * @param target Target view for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull View target) {
-    return createBinding(target, target);
-  }
+    /**
+     * BindView annotated fields and methods in the specified {@link View}. The view and its children
+     * are used as the view root.
+     *
+     * @param target Target view for view binding.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull View target) {
+        return createBinding(target, target);
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@link Dialog}. The current content
-   * view is used as the view root.
-   *
-   * @param target Target dialog for view binding.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Dialog target) {
-    View sourceView = target.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
+    /**
+     * BindView annotated fields and methods in the specified {@link Dialog}. The current content
+     * view is used as the view root.
+     *
+     * @param target Target dialog for view binding.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Dialog target) {
+        View sourceView = target.getWindow().getDecorView();
+        return createBinding(target, sourceView);
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link Activity} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source Activity on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
-    View sourceView = source.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link Activity} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source Activity on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull Activity source) {
+        View sourceView = source.getWindow().getDecorView();
+        return createBinding(target, sourceView);
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link View} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source View root on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull View source) {
-    return createBinding(target, source);
-  }
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link View} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source View root on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull View source) {
+        return createBinding(target, source);
+    }
+
+    /**
+     * BindView annotated fields and methods in the specified {@code target} using the {@code source}
+     * {@link Dialog} as the view root.
+     *
+     * @param target Target class for view binding.
+     * @param source Dialog on which IDs will be looked up.
+     */
+    @NonNull
+    @UiThread
+    public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
+        View sourceView = source.getWindow().getDecorView();
+        return createBinding(target, sourceView);
+    }
 
-  /**
-   * BindView annotated fields and methods in the specified {@code target} using the {@code source}
-   * {@link Dialog} as the view root.
-   *
-   * @param target Target class for view binding.
-   * @param source Dialog on which IDs will be looked up.
-   */
-  @NonNull @UiThread
-  public static Unbinder bind(@NonNull Object target, @NonNull Dialog source) {
-    View sourceView = source.getWindow().getDecorView();
-    return createBinding(target, sourceView);
-  }
+    private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
+        Class<?> targetClass = target.getClass();
+        if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName());
+        /**
+         * 根据 targetClass 找到其对应的 targetClass_ViewBinding 类(若未加载，则将其加载进内存中，并没有去初始化)
+         */
+        Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);
 
-  private static Unbinder createBinding(@NonNull Object target, @NonNull View source) {
-    Class<?> targetClass = target.getClass();
-    if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName());
-    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);
+        if (constructor == null) {
+            return Unbinder.EMPTY;
+        }
 
-    if (constructor == null) {
-      return Unbinder.EMPTY;
+        //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
+        try {
+            // 实例化该类
+            return constructor.newInstance(target, source);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Unable to invoke " + constructor, e);
+        } catch (InstantiationException e) {
+            throw new RuntimeException("Unable to invoke " + constructor, e);
+        } catch (InvocationTargetException e) {
+            Throwable cause = e.getCause();
+            if (cause instanceof RuntimeException) {
+                throw (RuntimeException) cause;
+            }
+            if (cause instanceof Error) {
+                throw (Error) cause;
+            }
+            throw new RuntimeException("Unable to create binding instance.", cause);
+        }
     }
 
-    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.
-    try {
-      return constructor.newInstance(target, source);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException("Unable to invoke " + constructor, e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Unable to invoke " + constructor, e);
-    } catch (InvocationTargetException e) {
-      Throwable cause = e.getCause();
-      if (cause instanceof RuntimeException) {
-        throw (RuntimeException) cause;
-      }
-      if (cause instanceof Error) {
-        throw (Error) cause;
-      }
-      throw new RuntimeException("Unable to create binding instance.", cause);
+    @Nullable
+    @CheckResult
+    @UiThread
+    private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
+        // BINDINGS 是一个以cls、constructor 为键值对的 linkedHashMap ,
+        // 用来提供缓存，减少重复进行反射创建对应的类造成的性能问题
+        Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
+        if (bindingCtor != null) {
+            if (debug) Log.d(TAG, "HIT: Cached in binding map.");
+            return bindingCtor;
+        }
+        String clsName = cls.getName();
+        // 如果是系统的类，那我们就不进行生成，直接返回null
+        if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
+            if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
+            return null;
+        }
+        try {
+            /**
+             *  将自动生成的 cls_ViewBinding 类通过反射加载进来，并获取其构造函数
+             *  注意 cls.getClassLoader().loadClass 与 Class.forName(...)的区别，前者只是将类加载进来，并未进行初始化，
+             *  甚至还没有被 lingking ,只有通过cls.getClassLoader().loadClass.newInstance(...)才能实例化。
+             *  而 Class.forName(...) 加载之后的类，已经初始化。
+             * */
+            Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");
+            //noinspection unchecked
+            // cls 必须继承自 Unbinder 接口，用来取消绑定
+            bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
+            if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
+        } catch (ClassNotFoundException e) {
+            if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
+            // 支持继承关系。如果在当前类中没找到，那就尝试在父类中找(这样就保证父类中使用了 butterknife 的控件，在子类中同样有效)
+            bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
+        }
+        // 缓存 bindingCtor
+        BINDINGS.put(cls, bindingCtor);
+        return bindingCtor;
     }
-  }
 
-  @Nullable @CheckResult @UiThread
-  private static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {
-    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);
-    if (bindingCtor != null) {
-      if (debug) Log.d(TAG, "HIT: Cached in binding map.");
-      return bindingCtor;
-    }
-    String clsName = cls.getName();
-    if (clsName.startsWith("android.") || clsName.startsWith("java.")) {
-      if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search.");
-      return null;
-    }
-    try {
-      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");
-      //noinspection unchecked
-      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);
-      if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor.");
-    } catch (ClassNotFoundException e) {
-      if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName());
-      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("Unable to find binding constructor for " + clsName, e);
+    /**
+     * Apply the specified {@code actions} across the {@code list} of views.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull List<T> list,
+                                              @NonNull Action<? super T>... actions) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            for (Action<? super T> action : actions) {
+                action.apply(list.get(i), i);
+            }
+        }
     }
-    BINDINGS.put(cls, bindingCtor);
-    return bindingCtor;
-  }
 
-  /** Apply the specified {@code actions} across the {@code list} of views. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull List<T> list,
-      @NonNull Action<? super T>... actions) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      for (Action<? super T> action : actions) {
-        action.apply(list.get(i), i);
-      }
+    /**
+     * Apply the specified {@code actions} across the {@code array} of views.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull T[] array,
+                                              @NonNull Action<? super T>... actions) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            for (Action<? super T> action : actions) {
+                action.apply(array[i], i);
+            }
+        }
     }
-  }
 
-  /** Apply the specified {@code actions} across the {@code array} of views. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull T[] array,
-      @NonNull Action<? super T>... actions) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      for (Action<? super T> action : actions) {
-        action.apply(array[i], i);
-      }
+    /**
+     * Apply the specified {@code action} across the {@code list} of views.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull List<T> list,
+                                              @NonNull Action<? super T> action) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            action.apply(list.get(i), i);
+        }
     }
-  }
 
-  /** Apply the specified {@code action} across the {@code list} of views. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull List<T> list,
-      @NonNull Action<? super T> action) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      action.apply(list.get(i), i);
+    /**
+     * Apply the specified {@code action} across the {@code array} of views.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull T[] array, @NonNull Action<? super T> action) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            action.apply(array[i], i);
+        }
     }
-  }
 
-  /** Apply the specified {@code action} across the {@code array} of views. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull T[] array, @NonNull Action<? super T> action) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      action.apply(array[i], i);
+    /**
+     * Apply {@code actions} to {@code view}.
+     */
+    @UiThread
+    @SafeVarargs
+    public static <T extends View> void apply(@NonNull T view,
+                                              @NonNull Action<? super T>... actions) {
+        for (Action<? super T> action : actions) {
+            action.apply(view, 0);
+        }
     }
-  }
 
-  /** Apply {@code actions} to {@code view}. */
-  @UiThread
-  @SafeVarargs public static <T extends View> void apply(@NonNull T view,
-      @NonNull Action<? super T>... actions) {
-    for (Action<? super T> action : actions) {
-      action.apply(view, 0);
+    /**
+     * Apply {@code action} to {@code view}.
+     */
+    @UiThread
+    public static <T extends View> void apply(@NonNull T view, @NonNull Action<? super T> action) {
+        action.apply(view, 0);
     }
-  }
 
-  /** Apply {@code action} to {@code view}. */
-  @UiThread
-  public static <T extends View> void apply(@NonNull T view, @NonNull Action<? super T> action) {
-    action.apply(view, 0);
-  }
-
-  /** Set the {@code value} using the specified {@code setter} across the {@code list} of views. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull List<T> list,
-      @NonNull Setter<? super T, V> setter, V value) {
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value, i);
+    /**
+     * Set the {@code value} using the specified {@code setter} across the {@code list} of views.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull List<T> list,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        for (int i = 0, count = list.size(); i < count; i++) {
+            setter.set(list.get(i), value, i);
+        }
     }
-  }
 
-  /** Set the {@code value} using the specified {@code setter} across the {@code array} of views. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T[] array,
-      @NonNull Setter<? super T, V> setter, V value) {
-    for (int i = 0, count = array.length; i < count; i++) {
-      setter.set(array[i], value, i);
+    /**
+     * Set the {@code value} using the specified {@code setter} across the {@code array} of views.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T[] array,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        for (int i = 0, count = array.length; i < count; i++) {
+            setter.set(array[i], value, i);
+        }
     }
-  }
 
-  /** Set {@code value} on {@code view} using {@code setter}. */
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T view,
-      @NonNull Setter<? super T, V> setter, V value) {
-    setter.set(view, value, 0);
-  }
+    /**
+     * Set {@code value} on {@code view} using {@code setter}.
+     */
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T view,
+                                                 @NonNull Setter<? super T, V> setter, V value) {
+        setter.set(view, value, 0);
+    }
 
-  /**
-   * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
-   */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull List<T> list,
-      @NonNull Property<? super T, V> setter, V value) {
-    //noinspection ForLoopReplaceableByForEach
-    for (int i = 0, count = list.size(); i < count; i++) {
-      setter.set(list.get(i), value);
+    /**
+     * Apply the specified {@code value} across the {@code list} of views using the {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull List<T> list,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0, count = list.size(); i < count; i++) {
+            setter.set(list.get(i), value);
+        }
     }
-  }
 
-  /**
-   * Apply the specified {@code value} across the {@code array} of views using the {@code property}.
-   */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T[] array,
-      @NonNull Property<? super T, V> setter, V value) {
-    //noinspection ForLoopReplaceableByForEach
-    for (int i = 0, count = array.length; i < count; i++) {
-      setter.set(array[i], value);
+    /**
+     * Apply the specified {@code value} across the {@code array} of views using the {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T[] array,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0, count = array.length; i < count; i++) {
+            setter.set(array[i], value);
+        }
     }
-  }
 
-  /** Apply {@code value} to {@code view} using {@code property}. */
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
-  @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @UiThread
-  public static <T extends View, V> void apply(@NonNull T view,
-      @NonNull Property<? super T, V> setter, V value) {
-    setter.set(view, value);
-  }
+    /**
+     * Apply {@code value} to {@code view} using {@code property}.
+     */
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) // http://b.android.com/213630
+    @RequiresApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @UiThread
+    public static <T extends View, V> void apply(@NonNull T view,
+                                                 @NonNull Property<? super T, V> setter, V value) {
+        setter.set(view, value);
+    }
 }
