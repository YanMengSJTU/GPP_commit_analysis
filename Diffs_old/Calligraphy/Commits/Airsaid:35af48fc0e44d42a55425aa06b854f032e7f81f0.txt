diff --git a/CalligraphySample/build.gradle b/CalligraphySample/build.gradle
index 1466285..e64849d 100644
--- a/CalligraphySample/build.gradle
+++ b/CalligraphySample/build.gradle
@@ -1,12 +1,10 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion "24.0.0"
-
+    compileSdkVersion 27
     defaultConfig {
-        minSdkVersion 14
-        targetSdkVersion 24
+        minSdkVersion 19
+        targetSdkVersion 27
         versionCode project.ext.versionCodeInt
         versionName version
     }
@@ -25,8 +23,8 @@ android {
 dependencies {
     compile project(':calligraphy')
     compile 'io.github.inflationx:viewpump:1.0.0'
-    compile 'com.android.support:support-v4:24.0.0'
-    compile 'com.android.support:appcompat-v7:24.0.0'
+    compile 'com.android.support:support-v4:27.1.1'
+    compile 'com.android.support:appcompat-v7:27.1.1'
 
     compile 'com.jakewharton:butterknife:8.2.1'
 
diff --git a/build.gradle b/build.gradle
index 2bc2f4b..47562bf 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,9 +2,10 @@
 buildscript {
   repositories {
     jcenter()
+    google()
   }
   dependencies {
-    classpath 'com.android.tools.build:gradle:2.2.1'
+    classpath 'com.android.tools.build:gradle:3.0.1'
   }
 }
 
@@ -13,6 +14,7 @@ allprojects {
     mavenLocal()
     jcenter()
     maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
+    google()
   }
   // Is Release Build?
   version = getProperty('VERSION_NAME');
diff --git a/calligraphy/build.gradle b/calligraphy/build.gradle
index 1f62e60..b094f22 100644
--- a/calligraphy/build.gradle
+++ b/calligraphy/build.gradle
@@ -1,12 +1,10 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 25
-    buildToolsVersion "25.0.1"
-
+    compileSdkVersion 27
     defaultConfig {
-        minSdkVersion 14
-        targetSdkVersion 25
+        minSdkVersion 19
+        targetSdkVersion 27
         versionCode project.ext.versionCodeInt
         versionName version
         consumerProguardFiles 'consumer-proguard-rules.txt'
@@ -21,8 +19,8 @@ android {
 }
 
 dependencies {
-    provided 'com.android.support:appcompat-v7:25.0.1'
-    compile 'io.github.inflationx:viewpump:1.0.0'
+    provided 'com.android.support:appcompat-v7:27.1.1'
+    compile project(path: ':viewpump')
 }
 
 apply from: rootProject.file('gradle/deploy.gradle')
diff --git a/calligraphy/src/main/java/io/github/inflationx/calligraphy3/Calligraphy.java b/calligraphy/src/main/java/io/github/inflationx/calligraphy3/Calligraphy.java
index 156209f..fea2447 100644
--- a/calligraphy/src/main/java/io/github/inflationx/calligraphy3/Calligraphy.java
+++ b/calligraphy/src/main/java/io/github/inflationx/calligraphy3/Calligraphy.java
@@ -11,11 +11,11 @@
 import android.view.View;
 import android.view.ViewTreeObserver;
 import android.widget.TextView;
+import io.github.inflationx.viewpump.ReflectionUtils;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Method;
 
-import io.github.inflationx.viewpump.ReflectionUtils;
 
 class Calligraphy {
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ce4ba66..5dc4378 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Feb 09 20:44:47 PST 2017
+#Thu Sep 20 16:14:39 CST 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/settings.gradle b/settings.gradle
index 182c95d..42658b9 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1 @@
-include ':calligraphy', ':CalligraphySample'
+include ':calligraphy', ':CalligraphySample', ':viewpump'
diff --git a/viewpump/.gitignore b/viewpump/.gitignore
new file mode 100644
index 0000000..796b96d
--- /dev/null
+++ b/viewpump/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/viewpump/build.gradle b/viewpump/build.gradle
new file mode 100644
index 0000000..b450176
--- /dev/null
+++ b/viewpump/build.gradle
@@ -0,0 +1,34 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 26
+
+
+
+    defaultConfig {
+        minSdkVersion 19
+        targetSdkVersion 26
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+}
+
+dependencies {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+
+    implementation 'com.android.support:appcompat-v7:26.1.0'
+    testImplementation 'junit:junit:4.12'
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
diff --git a/viewpump/proguard-rules.pro b/viewpump/proguard-rules.pro
new file mode 100644
index 0000000..f1b4245
--- /dev/null
+++ b/viewpump/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/viewpump/src/androidTest/java/io/github/inflationx/viewpump/ExampleInstrumentedTest.java b/viewpump/src/androidTest/java/io/github/inflationx/viewpump/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..aaacdd7
--- /dev/null
+++ b/viewpump/src/androidTest/java/io/github/inflationx/viewpump/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("io.github.inflationx.viewpump.test", appContext.getPackageName());
+    }
+}
diff --git a/viewpump/src/main/AndroidManifest.xml b/viewpump/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..3a1f1e8
--- /dev/null
+++ b/viewpump/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="io.github.inflationx.viewpump"/>
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreationInterceptor.java b/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreationInterceptor.java
new file mode 100644
index 0000000..b0242b2
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreationInterceptor.java
@@ -0,0 +1,20 @@
+package io.github.inflationx.viewpump;
+
+import android.view.View;
+
+class FallbackViewCreationInterceptor implements io.github.inflationx.viewpump.Interceptor {
+
+    @Override
+    public io.github.inflationx.viewpump.InflateResult intercept(Chain chain) {
+        io.github.inflationx.viewpump.InflateRequest request = chain.request();
+        io.github.inflationx.viewpump.FallbackViewCreator viewCreator = request.fallbackViewCreator();
+        View fallbackView = viewCreator.onCreateView(request.parent(), request.name(), request.context(), request.attrs());
+
+        return io.github.inflationx.viewpump.InflateResult.builder()
+                .view(fallbackView)
+                .name(fallbackView != null ? fallbackView.getClass().getName() : request.name())
+                .context(request.context())
+                .attrs(request.attrs())
+                .build();
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreator.java b/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreator.java
new file mode 100644
index 0000000..6a03991
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/FallbackViewCreator.java
@@ -0,0 +1,12 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.View;
+
+public interface FallbackViewCreator {
+    @Nullable
+    View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @Nullable AttributeSet attrs);
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/InflateRequest.java b/viewpump/src/main/java/io/github/inflationx/viewpump/InflateRequest.java
new file mode 100644
index 0000000..2a765c0
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/InflateRequest.java
@@ -0,0 +1,126 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.View;
+
+public class InflateRequest {
+    private final String name;
+    private final Context context;
+    private final AttributeSet attrs;
+    private final View parent;
+    private final FallbackViewCreator fallbackViewCreator;
+
+    private InflateRequest(Builder builder) {
+        name = builder.name;
+        context = builder.context;
+        attrs = builder.attrs;
+        parent = builder.parent;
+        fallbackViewCreator = builder.fallbackViewCreator;
+    }
+
+    @NonNull
+    public String name() {
+        return name;
+    }
+
+    @NonNull
+    public Context context() {
+        return context;
+    }
+
+    @Nullable
+    public AttributeSet attrs() {
+        return attrs;
+    }
+
+    @Nullable
+    public View parent() {
+        return parent;
+    }
+
+    @NonNull
+    public FallbackViewCreator fallbackViewCreator() {
+        return fallbackViewCreator;
+    }
+
+    @NonNull
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    @NonNull
+    public Builder toBuilder() {
+        return new Builder(this);
+    }
+
+    @NonNull
+    @Override
+    public String toString() {
+        return "InflateRequest{" +
+                "name='" + name + '\'' +
+                ", context=" + context +
+                ", attrs=" + attrs +
+                ", parent=" + parent +
+                ", fallbackViewCreator=" + fallbackViewCreator +
+                '}';
+    }
+
+    public static final class Builder {
+        private String name;
+        private Context context;
+        private AttributeSet attrs;
+        private View parent;
+        private FallbackViewCreator fallbackViewCreator;
+
+        private Builder() { }
+
+        private Builder(InflateRequest request) {
+            this.name = request.name;
+            this.context = request.context;
+            this.attrs = request.attrs;
+            this.parent = request.parent;
+            this.fallbackViewCreator = request.fallbackViewCreator;
+        }
+
+        public Builder name(@NonNull String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder context(@NonNull Context context) {
+            this.context = context;
+            return this;
+        }
+
+        public Builder attrs(@Nullable AttributeSet attrs) {
+            this.attrs = attrs;
+            return this;
+        }
+
+        public Builder parent(@Nullable View parent) {
+            this.parent = parent;
+            return this;
+        }
+
+        public Builder fallbackViewCreator(@NonNull FallbackViewCreator fallbackViewCreator) {
+            this.fallbackViewCreator = fallbackViewCreator;
+            return this;
+        }
+
+        public InflateRequest build() {
+            if (name == null) {
+                throw new IllegalStateException("name == null");
+            }
+            if (context == null) {
+                throw new IllegalStateException("context == null");
+            }
+            if (fallbackViewCreator == null) {
+                throw new IllegalStateException("fallbackViewCreator == null");
+            }
+            return new InflateRequest(this);
+        }
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/InflateResult.java b/viewpump/src/main/java/io/github/inflationx/viewpump/InflateResult.java
new file mode 100644
index 0000000..02cd5ce
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/InflateResult.java
@@ -0,0 +1,112 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.View;
+
+public class InflateResult {
+    private final View view;
+    private final String name;
+    private final Context context;
+    private final AttributeSet attrs;
+
+    private InflateResult(Builder builder) {
+        view = builder.view;
+        name = builder.name;
+        context = builder.context;
+        attrs = builder.attrs;
+    }
+
+    @Nullable
+    public View view() {
+        return view;
+    }
+
+    @NonNull
+    public String name() {
+        return name;
+    }
+
+    @NonNull
+    public Context context() {
+        return context;
+    }
+
+    @Nullable
+    public AttributeSet attrs() {
+        return attrs;
+    }
+
+    @NonNull
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    @NonNull
+    public Builder toBuilder() {
+        return new Builder(this);
+    }
+
+    @NonNull
+    @Override
+    public String toString() {
+        return "InflateResult{" +
+                "view=" + view +
+                ", name=" + name +
+                ", context=" + context +
+                ", attrs=" + attrs +
+                '}';
+    }
+
+    public static final class Builder {
+        private View view;
+        private String name;
+        private Context context;
+        private AttributeSet attrs;
+
+        private Builder() { }
+
+        private Builder(InflateResult result) {
+            this.view = result.view;
+            this.name = result.name;
+            this.context = result.context;
+            this.attrs = result.attrs;
+        }
+
+        public Builder view(@Nullable View view) {
+            this.view = view;
+            return this;
+        }
+
+        public Builder name(@NonNull String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder context(@NonNull Context context) {
+            this.context = context;
+            return this;
+        }
+
+        public Builder attrs(@Nullable AttributeSet attrs) {
+            this.attrs = attrs;
+            return this;
+        }
+
+        public InflateResult build() {
+            if (name == null) {
+                throw new IllegalStateException("name == null");
+            }
+            if (context == null) {
+                throw new IllegalStateException("context == null");
+            }
+            if (view != null && !name.equals(view.getClass().getName())) {
+                throw new IllegalStateException("name (" + name + ") "
+                        + "must be the view's fully qualified name (" + view.getClass().getName() + ")");
+            }
+            return new InflateResult(this);
+        }
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/Interceptor.java b/viewpump/src/main/java/io/github/inflationx/viewpump/Interceptor.java
new file mode 100644
index 0000000..8ec59a1
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/Interceptor.java
@@ -0,0 +1,17 @@
+package io.github.inflationx.viewpump;
+
+/**
+ * Observes, modifies, and potentially short-circuits inflation requests going out and the
+ * corresponding views that are inflated or returned. Typically interceptors change the name
+ * of the view to be inflated, return a programmatically instantiated view, or perform actions
+ * on a view after it is inflated based on its Context or AttributeSet.
+ */
+public interface Interceptor {
+    InflateResult intercept(Chain chain);
+
+    interface Chain {
+        InflateRequest request();
+
+        InflateResult proceed(InflateRequest request);
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/InterceptorChain.java b/viewpump/src/main/java/io/github/inflationx/viewpump/InterceptorChain.java
new file mode 100644
index 0000000..68b9172
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/InterceptorChain.java
@@ -0,0 +1,46 @@
+package io.github.inflationx.viewpump;
+
+import android.support.annotation.NonNull;
+
+import java.util.List;
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain.
+ */
+class InterceptorChain implements Interceptor.Chain {
+    private final List<Interceptor> interceptors;
+    private final int index;
+    private final InflateRequest request;
+
+    InterceptorChain(@NonNull List<Interceptor> interceptors, int index, @NonNull InflateRequest request) {
+        this.interceptors = interceptors;
+        this.index = index;
+        this.request = request;
+    }
+
+    @NonNull
+    @Override
+    public InflateRequest request() {
+        return request;
+    }
+
+    @NonNull
+    @Override
+    public InflateResult proceed(@NonNull InflateRequest request) {
+        if (index >= interceptors.size()) {
+            throw new AssertionError("no interceptors added to the chain");
+        }
+
+        // Call the next interceptor in the chain.
+        InterceptorChain next = new InterceptorChain(interceptors, index + 1, request);
+        Interceptor interceptor = interceptors.get(index);
+        InflateResult result = interceptor.intercept(next);
+
+        // Confirm that the intercepted response isn't null.
+        if (result == null) {
+            throw new NullPointerException("interceptor " + interceptor + " returned null");
+        }
+
+        return result;
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectionUtils.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectionUtils.java
new file mode 100644
index 0000000..7be9f7d
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectionUtils.java
@@ -0,0 +1,59 @@
+package io.github.inflationx.viewpump;
+
+import android.util.Log;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class ReflectionUtils {
+
+    private static final String TAG = ReflectionUtils.class.getSimpleName();
+
+    static Field getField(Class clazz, String fieldName) {
+        try {
+            final Field f = clazz.getDeclaredField(fieldName);
+            f.setAccessible(true);
+            return f;
+        } catch (NoSuchFieldException ignored) {
+        }
+        return null;
+    }
+
+    static Object getValue(Field field, Object obj) {
+        try {
+            return field.get(obj);
+        } catch (IllegalAccessException ignored) {
+        }
+        return null;
+    }
+
+    static void setValue(Field field, Object obj, Object value) {
+        try {
+            field.set(obj, value);
+        } catch (IllegalAccessException ignored) {
+        }
+    }
+
+    public static Method getMethod(Class clazz, String methodName) {
+        final Method[] methods = clazz.getMethods();
+        for (Method method : methods) {
+            if (method.getName().equals(methodName)) {
+                method.setAccessible(true);
+                return method;
+            }
+        }
+        return null;
+    }
+
+    public static void invokeMethod(Object object, Method method, Object... args) {
+        try {
+            if (method == null) return;
+            method.invoke(object, args);
+        } catch (IllegalAccessException e) {
+            Log.d(TAG, "Can't access method using reflection", e);
+        } catch (InvocationTargetException e) {
+            Log.d(TAG, "Can't invoke method using reflection", e);
+        }
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectiveFallbackViewCreator.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectiveFallbackViewCreator.java
new file mode 100644
index 0000000..dbef527
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ReflectiveFallbackViewCreator.java
@@ -0,0 +1,52 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.View;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+class ReflectiveFallbackViewCreator implements FallbackViewCreator {
+
+    private static final Class<?>[] constructorSignature2 = new Class[] {
+            Context.class,
+            AttributeSet.class
+    };
+
+    private static final Class<?>[] constructorSignature1 = new Class[] {
+            Context.class
+    };
+
+    @Nullable
+    @Override
+    public View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @Nullable AttributeSet attrs) {
+        try {
+            Class<? extends View> clazz = Class.forName(name).asSubclass(View.class);
+            Constructor<? extends View> constructor;
+            Object[] constructorArgs;
+            try {
+                constructor = clazz.getConstructor(constructorSignature2);
+                constructorArgs = new Object[]{context, attrs};
+            } catch (NoSuchMethodException e) {
+                constructor = clazz.getConstructor(constructorSignature1);
+                constructorArgs = new Object[]{context};
+            }
+            constructor.setAccessible(true);
+            return constructor.newInstance(constructorArgs);
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (InstantiationException e) {
+            e.printStackTrace();
+        } catch (InvocationTargetException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPump.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPump.java
new file mode 100644
index 0000000..3b7cabe
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPump.java
@@ -0,0 +1,207 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.MainThread;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class ViewPump {
+
+    private static ViewPump INSTANCE;
+
+    /** List of interceptors. */
+    private final List<Interceptor> interceptors;
+
+    /** List that gets cleared and reused as it holds interceptors with the fallback added. */
+    private final List<Interceptor> mInterceptorsWithFallback;
+
+    /** Use Reflection to inject the private factory. */
+    private final boolean mReflection;
+
+    /** Use Reflection to intercept CustomView inflation with the correct Context. */
+    private final boolean mCustomViewCreation;
+
+    /** Store the resourceId for the layout used to inflate the View in the View tag. */
+    private final boolean mStoreLayoutResId;
+
+    /** A FallbackViewCreator used to instantiate a view via reflection when using the create() API. */
+    private static FallbackViewCreator mReflectiveFallbackViewCreator;
+
+    private ViewPump(Builder builder) {
+        interceptors = immutableList(builder.interceptors);
+        List<Interceptor> interceptorsWithFallback = builder.interceptors;
+        interceptorsWithFallback.add(new FallbackViewCreationInterceptor());
+        mInterceptorsWithFallback = immutableList(interceptorsWithFallback);
+        mReflection = builder.reflection;
+        mCustomViewCreation = builder.customViewCreation;
+        mStoreLayoutResId = builder.storeLayoutResId;
+        mReflectiveFallbackViewCreator = builder.reflectiveFallbackViewCreator;
+    }
+
+    public static void init(ViewPump viewPump) {
+        INSTANCE = viewPump;
+    }
+
+    @MainThread
+    public static ViewPump get() {
+        if (INSTANCE == null) {
+            INSTANCE = builder().build();
+        }
+        return INSTANCE;
+    }
+
+    /**
+     * Allows for programmatic creation of Views via reflection on class name that are still
+     * pre/post-processed by the inflation interceptors.
+     *
+     * @param context The context.
+     * @param clazz The class of View to be created.
+     * @return The processed view, which might not necessarily be the same type as clazz.
+     */
+    @Nullable
+    public static View create(Context context, Class<? extends View> clazz) {
+        return get().inflate(InflateRequest.builder()
+                .context(context)
+                .name(clazz.getName())
+                .fallbackViewCreator(getReflectiveFallbackViewCreator())
+                .build())
+                .view();
+    }
+
+    public InflateResult inflate(InflateRequest originalRequest) {
+        Interceptor.Chain chain = new InterceptorChain(mInterceptorsWithFallback, 0, originalRequest);
+        return chain.proceed(originalRequest);
+    }
+
+    public List<Interceptor> interceptors() {
+        return interceptors;
+    }
+
+    public boolean isReflection() {
+        return mReflection;
+    }
+
+    public boolean isCustomViewCreation() {
+        return mCustomViewCreation;
+    }
+
+    public boolean isStoreLayoutResId() {
+        return mStoreLayoutResId;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+    
+    /** Returns an immutable copy of {@code list}. */
+    private static <T> List<T> immutableList(List<T> list) {
+        return Collections.unmodifiableList(new ArrayList<>(list));
+    }
+
+    private static FallbackViewCreator getReflectiveFallbackViewCreator() {
+        if (mReflectiveFallbackViewCreator == null) {
+            mReflectiveFallbackViewCreator = new ReflectiveFallbackViewCreator();
+        }
+        return mReflectiveFallbackViewCreator;
+    }
+
+    public static final class Builder {
+
+        /** List of interceptors. */
+        private final List<Interceptor> interceptors = new ArrayList<>();
+
+        /** Use Reflection to inject the private factory. Defaults to true. */
+        private boolean reflection = true;
+
+        /** Use Reflection to intercept CustomView inflation with the correct Context. */
+        private boolean customViewCreation = true;
+
+        /** Store the resourceId for the layout used to inflate the View in the View tag. */
+        private boolean storeLayoutResId = false;
+
+        /** A FallbackViewCreator used to instantiate a view via reflection when using the create() API. */
+        private FallbackViewCreator reflectiveFallbackViewCreator = null;
+
+        private Builder() { }
+
+        public Builder addInterceptor(Interceptor interceptor) {
+            interceptors.add(interceptor);
+            return this;
+        }
+
+        /**
+         * <p>Turn of the use of Reflection to inject the private factory.
+         * This has operational consequences! Please read and understand before disabling.</p>
+         *
+         * <p> If you disable this you will need to override your {@link android.app.Activity#onCreateView(View, String, android.content.Context, android.util.AttributeSet)}
+         * as this is set as the {@link android.view.LayoutInflater} private factory.</p>
+         * <br>
+         * <b> Use the following code in the Activity if you disable FactoryInjection:</b>
+         * <pre><code>
+         * {@literal @}Override
+         * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+         *   return ViewPumpContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+         * }
+         * </code></pre>
+         *
+         * @param enabled True if private factory inject is allowed; otherwise, false.
+         */
+        public Builder setPrivateFactoryInjectionEnabled(boolean enabled) {
+            this.reflection = enabled;
+            return this;
+        }
+
+        /**
+         * Due to the poor inflation order where custom views are created and never returned inside an
+         * {@code onCreateView(...)} method. We have to create CustomView's at the latest point in the
+         * overrideable injection flow.
+         *
+         * On HoneyComb+ this is inside the {@link android.app.Activity#onCreateView(View, String, android.content.Context, android.util.AttributeSet)}
+         *
+         * We wrap base implementations, so if you LayoutInflater/Factory/Activity creates the
+         * custom view before we get to this point, your view is used. (Such is the case with the
+         * TintEditText etc)
+         *
+         * The problem is, the native methods pass there parents context to the constructor in a really
+         * specific place. We have to mimic this in {@link ViewPumpLayoutInflater#createCustomViewInternal(View, View, String, android.content.Context, android.util.AttributeSet)}
+         * To mimic this we have to use reflection as the Class constructor args are hidden to us.
+         *
+         * We have discussed other means of doing this but this is the only semi-clean way of doing it.
+         * (Without having to do proxy classes etc).
+         *
+         * Calling this will of course speed up inflation by turning off reflection, but not by much,
+         * But if you want ViewPump to inject the correct typeface then you will need to make sure your CustomView's
+         * are created before reaching the LayoutInflater onViewCreated.
+         *
+         * @param enabled True if custom view inflated is allowed; otherwise, false.
+         */
+        public Builder setCustomViewInflationEnabled(boolean enabled) {
+            this.customViewCreation = enabled;
+            return this;
+        }
+
+        public Builder setReflectiveFallbackViewCreator(FallbackViewCreator reflectiveFallbackViewCreator) {
+            this.reflectiveFallbackViewCreator = reflectiveFallbackViewCreator;
+            return this;
+        }
+
+        /**
+         * The LayoutInflater can store the layout resourceId used to inflate a view into the inflated view's tag
+         * where it can be later retrieved by an interceptor.
+         *
+         * @param enabled True if the view should store the resId; otherwise, false.
+         */
+        public Builder setStoreLayoutResId(boolean enabled) {
+            this.storeLayoutResId = enabled;
+            return this;
+        }
+
+        public ViewPump build() {
+            return new ViewPump(this);
+        }
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpActivityFactory.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpActivityFactory.java
new file mode 100644
index 0000000..e982e13
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpActivityFactory.java
@@ -0,0 +1,32 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.View;
+
+interface ViewPumpActivityFactory {
+
+    /**
+     * Used to Wrap the Activity onCreateView method.
+     *
+     * You implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return ViewPumpContextWrapper.get(getBaseContext()).onActivityCreateView(super.onCreateView(parent, name,context, attrs), attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param parent  parent view, can be null.
+     * @param view    result of {@code super.onCreateView(parent, name, context, attrs)}, this might be null, which is fine.
+     * @param name    Name of View we are trying to inflate
+     * @param context current context (normally the Activity's)
+     * @param attrs   see {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}  @return the result from the activities {@code onCreateView()}
+     * @return The view passed in, or null if nothing was passed in.
+     * @see android.view.LayoutInflater.Factory2
+     */
+    @Nullable
+    View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs);
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpContextWrapper.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpContextWrapper.java
new file mode 100644
index 0000000..b7d9983
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpContextWrapper.java
@@ -0,0 +1,94 @@
+package io.github.inflationx.viewpump;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+
+public final class ViewPumpContextWrapper extends ContextWrapper {
+
+    private ViewPumpLayoutInflater mInflater;
+
+    /**
+     * Uses the default configuration from {@link ViewPump}
+     *
+     * Remember if you are defining default in the {@link ViewPump} make sure this
+     * is initialised before the activity is created.
+     *
+     * @param base ContextBase to Wrap.
+     * @return ContextWrapper to pass back to the activity.
+     */
+    public static ContextWrapper wrap(@NonNull Context base) {
+        return new ViewPumpContextWrapper(base);
+    }
+
+    /**
+     * You only need to call this <b>IF</b> you disable
+     * {@link ViewPump.Builder#setPrivateFactoryInjectionEnabled(boolean)}
+     * This will need to be called from the
+     * {@link Activity#onCreateView(View, String, Context, AttributeSet)}
+     * method to enable view font injection if the view is created inside the activity onCreateView.
+     *
+     * You would implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return ViewPumpContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @param parent   Parent view from onCreateView
+     * @param view     The View Created inside onCreateView or from super.onCreateView
+     * @param name     The View name from onCreateView
+     * @param context  The context from onCreateView
+     * @param attr     The AttributeSet from onCreateView
+     * @return The same view passed in, or null if null passed in.
+     */
+    @Nullable
+    public static View onActivityCreateView(Activity activity, View parent, View view, String name, Context context, AttributeSet attr) {
+        return get(activity).onActivityCreateView(parent, view, name, context, attr);
+    }
+
+    /**
+     * Get the ViewPump Activity Fragment Instance to allow callbacks for when views are created.
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @return Interface allowing you to call onActivityViewCreated
+     */
+    static ViewPumpActivityFactory get(@NonNull Activity activity) {
+        if (!(activity.getLayoutInflater() instanceof ViewPumpLayoutInflater)) {
+            throw new RuntimeException("This activity does not wrap the Base Context! See ViewPumpContextWrapper.wrap(Context)");
+        }
+        return (ViewPumpActivityFactory) activity.getLayoutInflater();
+    }
+
+    /**
+     * Uses the default configuration from {@link ViewPump}
+     *
+     * Remember if you are defining default in the
+     * {@link ViewPump} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap
+     */
+    private ViewPumpContextWrapper(Context base) {
+        super(base);
+    }
+
+    @Override
+    public Object getSystemService(String name) {
+        if (LAYOUT_INFLATER_SERVICE.equals(name)) {
+            if (mInflater == null) {
+                mInflater = new ViewPumpLayoutInflater(LayoutInflater.from(getBaseContext()), this, false);
+            }
+            return mInflater;
+        }
+        return super.getSystemService(name);
+    }
+}
diff --git a/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpLayoutInflater.java b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpLayoutInflater.java
new file mode 100644
index 0000000..1e29a1b
--- /dev/null
+++ b/viewpump/src/main/java/io/github/inflationx/viewpump/ViewPumpLayoutInflater.java
@@ -0,0 +1,425 @@
+package io.github.inflationx.viewpump;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+class ViewPumpLayoutInflater extends LayoutInflater implements ViewPumpActivityFactory {
+
+    private static final String[] sClassPrefixList = {
+            "android.widget.",
+            "android.webkit."
+    };
+
+    private FallbackViewCreator nameAndAttrsViewCreator;
+    private FallbackViewCreator parentAndNameAndAttrsViewCreator;
+
+    // Reflection Hax
+    private boolean mSetPrivateFactory = false;
+    private Field mConstructorArgs = null;
+
+    private boolean mStoreLayoutResId = false;
+
+    protected ViewPumpLayoutInflater(Context context) {
+        super(context);
+        mStoreLayoutResId = ViewPump.get().isStoreLayoutResId();
+        nameAndAttrsViewCreator = new NameAndAttrsViewCreator(this);
+        parentAndNameAndAttrsViewCreator = new ParentAndNameAndAttrsViewCreator(this);
+        setUpLayoutFactories(false);
+    }
+
+    protected ViewPumpLayoutInflater(LayoutInflater original, Context newContext, final boolean cloned) {
+        super(original, newContext);
+        mStoreLayoutResId = ViewPump.get().isStoreLayoutResId();
+        nameAndAttrsViewCreator = new NameAndAttrsViewCreator(this);
+        parentAndNameAndAttrsViewCreator = new ParentAndNameAndAttrsViewCreator(this);
+        setUpLayoutFactories(cloned);
+    }
+
+    @Override
+    public LayoutInflater cloneInContext(Context newContext) {
+        return new ViewPumpLayoutInflater(this, newContext, true);
+    }
+
+    // ===
+    // Wrapping goodies
+    // ===
+
+
+    @Override
+    public View inflate(int resource, @Nullable ViewGroup root, boolean attachToRoot) {
+        View view = super.inflate(resource, root, attachToRoot);
+        if (view != null && mStoreLayoutResId) {
+            view.setTag(R.id.viewpump_layout_res, resource);
+        }
+        return view;
+    }
+
+    @Override
+    public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
+        setPrivateFactoryInternal();
+        return super.inflate(parser, root, attachToRoot);
+    }
+
+    /**
+     * We don't want to unnecessary create/set our factories if there are none there. We try to be
+     * as lazy as possible.
+     */
+    private void setUpLayoutFactories(boolean cloned) {
+        if (cloned) return;
+        // If we are HC+ we get and set Factory2 otherwise we just wrap Factory1
+        if (getFactory2() != null && !(getFactory2() instanceof WrapperFactory2)) {
+            // Sets both Factory/Factory2
+            setFactory2(getFactory2());
+        }
+        // We can do this as setFactory2 is used for both methods.
+        if (getFactory() != null && !(getFactory() instanceof WrapperFactory)) {
+            setFactory(getFactory());
+        }
+    }
+
+    @Override
+    public void setFactory(Factory factory) {
+        // Only set our factory and wrap calls to the Factory trying to be set!
+        if (!(factory instanceof WrapperFactory)) {
+            super.setFactory(new WrapperFactory(factory));
+        } else {
+            super.setFactory(factory);
+        }
+    }
+
+    @Override
+    public void setFactory2(Factory2 factory2) {
+        // Only set our factory and wrap calls to the Factory2 trying to be set!
+        if (!(factory2 instanceof WrapperFactory2)) {
+//            LayoutInflaterCompat.setFactory(this, new WrapperFactory2(factory2, mViewPumpFactory));
+            super.setFactory2(new WrapperFactory2(factory2));
+        } else {
+            super.setFactory2(factory2);
+        }
+    }
+
+    private void setPrivateFactoryInternal() {
+        // Already tried to set the factory.
+        if (mSetPrivateFactory) return;
+        // Reflection (Or Old Device) skip.
+        if (!ViewPump.get().isReflection()) return;
+        // Skip if not attached to an activity.
+        if (!(getContext() instanceof Factory2)) {
+            mSetPrivateFactory = true;
+            return;
+        }
+
+        // TODO: we need to get this and wrap it if something has already set this
+        final Method setPrivateFactoryMethod = ReflectionUtils.getMethod(LayoutInflater.class, "setPrivateFactory");
+
+        if (setPrivateFactoryMethod != null) {
+            ReflectionUtils.invokeMethod(this,
+                    setPrivateFactoryMethod,
+                    new PrivateWrapperFactory2((Factory2) getContext(), this));
+        }
+        mSetPrivateFactory = true;
+    }
+
+    // ===
+    // LayoutInflater ViewCreators
+    // Works in order of inflation
+    // ===
+
+    /**
+     * The Activity onCreateView (PrivateFactory) is the third port of call for LayoutInflation.
+     * We opted to manual injection over aggressive reflection, this should be less fragile.
+     */
+    @Override
+    public View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs) {
+        return ViewPump.get().inflate(InflateRequest.builder()
+                .name(name)
+                .context(context)
+                .attrs(attrs)
+                .parent(parent)
+                .fallbackViewCreator(new ActivityViewCreator(this, view))
+                .build()).view();
+    }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     */
+    @Override
+    protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException {
+        return ViewPump.get().inflate(InflateRequest.builder()
+                .name(name)
+                .context(getContext())
+                .attrs(attrs)
+                .parent(parent)
+                .fallbackViewCreator(parentAndNameAndAttrsViewCreator)
+                .build()).view();
+    }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     * Basically if this method doesn't inflate the View nothing probably will.
+     */
+    @Override
+    protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
+        return ViewPump.get().inflate(InflateRequest.builder()
+                .name(name)
+                .context(getContext())
+                .attrs(attrs)
+                .fallbackViewCreator(nameAndAttrsViewCreator)
+                .build()).view();
+    }
+
+    /**
+     * Nasty method to inflate custom layouts that haven't been handled else where. If this fails it
+     * will fall back through to the PhoneLayoutInflater method of inflating custom views where
+     * ViewPump will NOT have a hook into.
+     *
+     * @param parent      parent view
+     * @param view        view if it has been inflated by this point, if this is not null this method
+     *                    just returns this value.
+     * @param name        name of the thing to inflate.
+     * @param viewContext Context to inflate by if parent is null
+     * @param attrs       Attr for this view which we can steal fontPath from too.
+     * @return view or the View we inflate in here.
+     */
+    private View createCustomViewInternal(View parent, View view, String name, Context viewContext, AttributeSet attrs) {
+        // I by no means advise anyone to do this normally, but Google have locked down access to
+        // the createView() method, so we never get a callback with attributes at the end of the
+        // createViewFromTag chain (which would solve all this unnecessary rubbish).
+        // We at the very least try to optimise this as much as possible.
+        // We only call for customViews (As they are the ones that never go through onCreateView(...)).
+        // We also maintain the Field reference and make it accessible which will make a pretty
+        // significant difference to performance on Android 4.0+.
+
+        // If CustomViewCreation is off skip this.
+        if (!ViewPump.get().isCustomViewCreation()) return view;
+        if (view == null && name.indexOf('.') > -1) {
+            if (mConstructorArgs == null)
+                mConstructorArgs = ReflectionUtils.getField(LayoutInflater.class, "mConstructorArgs");
+
+            final Object[] mConstructorArgsArr = (Object[]) ReflectionUtils.getValue(mConstructorArgs, this);
+            final Object lastContext = mConstructorArgsArr[0];
+            // The LayoutInflater actually finds out the correct context to use. We just need to set
+            // it on the mConstructor for the internal method.
+            // Set the constructor ars up for the createView, not sure why we can't pass these in.
+            mConstructorArgsArr[0] = viewContext;
+            ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            try {
+                view = createView(name, null, attrs);
+            } catch (ClassNotFoundException ignored) {
+            } finally {
+                mConstructorArgsArr[0] = lastContext;
+                ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            }
+        }
+        return view;
+    }
+
+    private View superOnCreateView(View parent, String name, AttributeSet attrs) {
+        try {
+            return super.onCreateView(parent, name, attrs);
+        } catch (ClassNotFoundException e) {
+            return null;
+        }
+    }
+
+    private View superOnCreateView(String name, AttributeSet attrs) {
+        try {
+            return super.onCreateView(name, attrs);
+        } catch (ClassNotFoundException e) {
+            return null;
+        }
+    }
+
+    // ===
+    // View creators
+    // ===
+
+    private static class ActivityViewCreator implements FallbackViewCreator {
+        private final ViewPumpLayoutInflater inflater;
+        private final View view;
+
+        public ActivityViewCreator(ViewPumpLayoutInflater inflater, View view) {
+            this.inflater = inflater;
+            this.view = view;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return inflater.createCustomViewInternal(parent, view, name, context, attrs);
+        }
+    }
+
+    private static class ParentAndNameAndAttrsViewCreator implements FallbackViewCreator {
+        private final ViewPumpLayoutInflater inflater;
+
+        public ParentAndNameAndAttrsViewCreator(ViewPumpLayoutInflater inflater) {
+            this.inflater = inflater;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return inflater.superOnCreateView(parent, name, attrs);
+        }
+    }
+
+    private static class NameAndAttrsViewCreator implements FallbackViewCreator {
+        private final ViewPumpLayoutInflater inflater;
+
+        public NameAndAttrsViewCreator(ViewPumpLayoutInflater inflater) {
+            this.inflater = inflater;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            // This mimics the {@code PhoneLayoutInflater} in the way it tries to inflate the base
+            // classes, if this fails its pretty certain the app will fail at this point.
+            View view = null;
+            for (String prefix : sClassPrefixList) {
+                try {
+                    view = inflater.createView(name, prefix, attrs);
+                    if (view != null) {
+                        break;
+                    }
+                } catch (ClassNotFoundException | Resources.NotFoundException ignored) {
+                }
+            }
+            // In this case we want to let the base class take a crack
+            // at it.
+            if (view == null) view = inflater.superOnCreateView(name, attrs);
+            return view;
+        }
+    }
+
+    // ===
+    // Wrapper Factories
+    // ===
+
+    /**
+     * Factory 1 is the first port of call for LayoutInflation
+     */
+    private static class WrapperFactory implements Factory {
+
+        private final FallbackViewCreator mViewCreator;
+
+        public WrapperFactory(Factory factory) {
+            mViewCreator = new WrapperFactoryViewCreator(factory);
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            return ViewPump.get().inflate(InflateRequest.builder()
+                    .name(name)
+                    .context(context)
+                    .attrs(attrs)
+                    .fallbackViewCreator(mViewCreator)
+                    .build()).view();
+        }
+    }
+
+    private static class WrapperFactoryViewCreator implements FallbackViewCreator {
+        protected final Factory mFactory;
+
+        public WrapperFactoryViewCreator(Factory factory) {
+            this.mFactory = factory;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mFactory.onCreateView(name, context, attrs);
+        }
+    }
+
+    /**
+     * Factory 2 is the second port of call for LayoutInflation
+     */
+    private static class WrapperFactory2 implements Factory2 {
+        protected final Factory2 mFactory2;
+        private final WrapperFactory2ViewCreator mViewCreator;
+
+        public WrapperFactory2(Factory2 factory2) {
+            mFactory2 = factory2;
+            mViewCreator = new WrapperFactory2ViewCreator(factory2);
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            return onCreateView(null, name, context, attrs);
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return ViewPump.get().inflate(InflateRequest.builder()
+                    .name(name)
+                    .context(context)
+                    .attrs(attrs)
+                    .parent(parent)
+                    .fallbackViewCreator(mViewCreator)
+                    .build()).view();
+        }
+    }
+
+    private static class WrapperFactory2ViewCreator implements FallbackViewCreator {
+        protected final Factory2 mFactory2;
+
+        public WrapperFactory2ViewCreator(Factory2 factory2) {
+            this.mFactory2 = factory2;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mFactory2.onCreateView(parent, name, context, attrs);
+        }
+    }
+
+    /**
+     * Private factory is step three for Activity Inflation, this is what is attached to the Activity
+     */
+    private static class PrivateWrapperFactory2 extends WrapperFactory2 {
+
+        private final PrivateWrapperFactory2ViewCreator mViewCreator;
+
+        public PrivateWrapperFactory2(Factory2 factory2, ViewPumpLayoutInflater inflater) {
+            super(factory2);
+            mViewCreator = new PrivateWrapperFactory2ViewCreator(factory2, inflater);
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return ViewPump.get().inflate(InflateRequest.builder()
+                    .name(name)
+                    .context(context)
+                    .attrs(attrs)
+                    .parent(parent)
+                    .fallbackViewCreator(mViewCreator)
+                    .build()).view();
+        }
+    }
+
+    private static class PrivateWrapperFactory2ViewCreator extends WrapperFactory2ViewCreator implements FallbackViewCreator {
+        private final ViewPumpLayoutInflater mInflater;
+
+        public PrivateWrapperFactory2ViewCreator(Factory2 factory2, ViewPumpLayoutInflater mInflater) {
+            super(factory2);
+            this.mInflater = mInflater;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mInflater.createCustomViewInternal(parent,
+                    mFactory2.onCreateView(parent, name, context, attrs), name, context, attrs);
+        }
+    }
+
+}
diff --git a/viewpump/src/main/res/values/ids.xml b/viewpump/src/main/res/values/ids.xml
new file mode 100644
index 0000000..5e688bb
--- /dev/null
+++ b/viewpump/src/main/res/values/ids.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <item name="viewpump_tag_id" type="id"/>
+    <item name="viewpump_layout_res" type="id"/>
+</resources>
diff --git a/viewpump/src/test/java/io/github/inflationx/viewpump/ExampleUnitTest.java b/viewpump/src/test/java/io/github/inflationx/viewpump/ExampleUnitTest.java
new file mode 100644
index 0000000..9d7fffe
--- /dev/null
+++ b/viewpump/src/test/java/io/github/inflationx/viewpump/ExampleUnitTest.java
@@ -0,0 +1,17 @@
+package io.github.inflationx.viewpump;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
