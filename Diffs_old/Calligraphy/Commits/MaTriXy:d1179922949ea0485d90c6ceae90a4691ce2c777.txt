diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4347ff5..f88c3a1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,21 @@
 #Changelog
 
+#2.0.0 (WIP)
+**Breaking changes**
+This is a massive rewrite of the interception model. Look at `CalligraphyLayoutInflater` and
+`CalligraphyConfig` for more information on options and changes.
+
+- **BREAKING CHANGE** This is an API change to Calligraphy config.
+ Changed CalligraphyConfig to a builder pattern, use `CalligraphyConfig.Builder().build()`;
+
+Notable changes:
+- Removed jar binary, We build an @aar due to the way we tag `View`s.
+- Intercept View creation at each stage.
+- Defer view creation to native components (Except CustomViews).
+- Inject `setPrivateFactory` on the `Activity`.
+- We wrap Factory not disturbing underlying factory and layout inflater invocation.
+- Better support for `cloneInContext()` which the compat library uses heavily.
+
 #1.2.0 (20/10/2014)
 - Fixes issues with `appcompat-v7:21+` (uses underlying `Toolbar` impl).
 - Lollipop support.
diff --git a/CalligraphySample/build.gradle b/CalligraphySample/build.gradle
index 2de24bf..5f4cb68 100644
--- a/CalligraphySample/build.gradle
+++ b/CalligraphySample/build.gradle
@@ -3,14 +3,14 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.13.3'
+        classpath 'com.android.tools.build:gradle:1.0.0'
     }
 }
 apply plugin: 'com.android.application'
 
 android {
     compileSdkVersion 21
-    buildToolsVersion "21.0.0"
+    buildToolsVersion "21.1.1"
 
     defaultConfig {
         minSdkVersion 7
@@ -20,7 +20,8 @@ android {
     }
     buildTypes {
         release {
-            runProguard false
+
+            minifyEnabled false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
         }
     }
@@ -28,8 +29,8 @@ android {
 
 dependencies {
     compile project(':calligraphy')
-    compile 'com.android.support:support-v4:21.0.0'
-    compile 'com.android.support:appcompat-v7:21.0.0'
+    compile 'com.android.support:support-v4:21.0.2'
+    compile 'com.android.support:appcompat-v7:21.0.2'
 
     compile 'com.jakewharton:butterknife:5.1.2'
 }
diff --git a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
index c471dfb..fe221e7 100644
--- a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
+++ b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
@@ -13,6 +13,10 @@
     @Override
     public void onCreate() {
         super.onCreate();
-        CalligraphyConfig.initDefault("fonts/Roboto-ThinItalic.ttf", R.attr.fontPath);
+        CalligraphyConfig.initDefault(new CalligraphyConfig.Builder()
+                        .setDefaultFontPath("fonts/Roboto-ThinItalic.ttf")
+                        .setFontAttrId(R.attr.fontPath)
+                        .build()
+        );
     }
 }
diff --git a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
index 060d39a..667302b 100644
--- a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
+++ b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
@@ -30,9 +30,18 @@ public void run() {
         }, 1000);
     }
 
+    /*
+        Uncomment if you disable PrivateFactory injection. See CalligraphyConfig#disablePrivateFactoryInjection()
+     */
+//    @Override
+//    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+//    public View onCreateView(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs) {
+//        return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+//    }
+
     @Override
     protected void attachBaseContext(Context newBase) {
-        super.attachBaseContext(new CalligraphyContextWrapper(newBase));
+        super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase));
     }
 
 }
diff --git a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/PlaceholderFragment.java b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/PlaceholderFragment.java
index 9aadd8e..bca705f 100644
--- a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/PlaceholderFragment.java
+++ b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/PlaceholderFragment.java
@@ -23,7 +23,7 @@ public static Fragment getInstance() {
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle state) {
-        return getActivity().getLayoutInflater().inflate(R.layout.fragment_main, container, false);
+        return inflater.inflate(R.layout.fragment_main, container, false);
     }
 
     @Override
diff --git a/README.md b/README.md
index 2b58ba6..d8d9e15 100644
--- a/README.md
+++ b/README.md
@@ -23,7 +23,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle st
 
 ### Dependency
 
-[Download from Maven Central (.jar)](http://search.maven.org/remotecontent?filepath=uk/co/chrisjenx/calligraphy/1.2.0/calligraphy-1.2.0.jar)
+[Download from Maven Central (.aar)](http://search.maven.org/remotecontent?filepath=uk/co/chrisjenx/calligraphy/2.0.0/calligraphy-2.0.0.aar)
 
 __OR__
 
@@ -31,7 +31,7 @@ Include the dependency:
 
 ```groovy
 dependencies {
-    compile 'uk.co.chrisjenx:calligraphy:1.2.0'
+    compile 'uk.co.chrisjenx:calligraphy:2.0.0'
 }
 ```
 ### Fonts
@@ -40,32 +40,30 @@ Add your custom fonts to `assets/fonts/` all font definitions are relative to th
 
 ### Custom Attribute
 
-We don't package an `R.attr` with Calligraphy to keep it a Jar. So you will need to add your own Attr.
+We ship with `R.attr.fontPath`.
 
-The most common one is: `res/values/attrs.xml`
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <attr name="fontPath" format="string"/>
-</resources>
-```
+This can be used in such a way: `<TextView fontPath="fonts/MyFont.ttf"/>` Please note the missing
+namespace, this IS intention.
 
 ### Configuration
 
-Define your default font using `CalligraphyConfig`, in your `Application` class, unfortunately 
-`Activity#onCreate(Bundle)` is called _after_ `Activity#attachBaseContext(Context)` so the config 
-needs to be defined before that.
+Define your default font using `CalligraphyConfig`, in your `Application` class.
+Unfortunately `Activity#onCreate(Bundle)` is called _after_ `Activity#attachBaseContext(Context)` so
+the config needs to be defined before that.
 
 ```java
 protected void onCreate() {
     super.onCreate();
-    CalligraphyConfig.initDefault("fonts/Roboto-Regular.ttf", R.attr.fontPath);
+    CalligraphyConfig.initDefault(new CalligraphyConfig.Builder()
+                            .setDefaultFontPath("fonts/Roboto-RobotoRegular.ttf")
+                            .setFontAttrId(R.attr.fontPath)
+                            .build()
+            );
     //....
 }
 ```
-_Note: You don't need to define `CalligraphyConfig` anymore (1.0.0+) but the library will apply
-no default font. I recommend defining at least a default font or attribute._
+_Note: You don't need to define `CalligraphyConfig` but the library will apply
+no default font and use `R.id.fontPath`._
 
 ### Inject into Context
 
@@ -93,6 +91,9 @@ _You're good to go!_
     fontPath="fonts/Roboto-Bold.ttf"/>
 ```
 
+_Note: Popular IDE's (Android Studio, IntelliJ) will likely mark this as an error despite being correct. You may want to add `tools:ignore="MissingPrefix"` to either the View itself or its parent ViewGroup to avoid this. You'll need to add the tools namespace to have access to this "ignore" attribute. `xmlns:tools="
+http://schemas.android.com/tools"`. See https://code.google.com/p/android/issues/detail?id=65176._
+
 ### Custom font in TextAppearance
 
 
@@ -156,18 +157,16 @@ The `CalligraphyFactory` looks for the font in a pretty specific order, for the
 We originally did, but it conflicted with users wanting to actually use that attribute, you now 
 have to define a custom attribute.
 
-### Why not ship with custom attribute?
-
-No resources means that the library can compile down to a `jar` instead of an `aar`, as I know allot
-of users are still not using Gradle yet.
+### Why no jar?
 
-As of 1.0+ you *have* to define a custom attribute.
+We needed to ship a custom ID with Calligraphy to improve the Font Injection flow. This
+unfortunately means that is has to be an `aar`. But you're using Gradle now anyway right?
 
 ### Multiple Typeface's per TextView / Spannables
 
 It is possible to use multiple Typefaces inside a `TextView`, this isn't new concept to Android.
 
-But this could be achieved using something like the following code.
+This _could_ be achieved using something like the following code.
 
 ```java
 SpannableStringBuilder builder = new SpannableStringBuilder();
@@ -188,6 +187,7 @@ Of course this is just an example. Your mileage may vary.
 - [@Smuldr](https://github.com/Smuldr)
 - [@Codebutler](https://github.com/codebutler)
 - [@loganj](https://github.com/loganj)
+- [@dlew](https://github.com/dlew)
 
 #Note
 
diff --git a/build.gradle b/build.gradle
index 3c5aa73..92de3c3 100644
--- a/build.gradle
+++ b/build.gradle
@@ -10,5 +10,5 @@ allprojects {
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.1'
+    gradleVersion = '2.2'
 }
diff --git a/calligraphy/build.gradle b/calligraphy/build.gradle
index 0911132..fc1ab48 100644
--- a/calligraphy/build.gradle
+++ b/calligraphy/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.13.3'
+        classpath 'com.android.tools.build:gradle:1.0.0'
     }
 }
 apply plugin: 'com.android.library'
@@ -14,7 +14,7 @@ repositories {
 
 android {
     compileSdkVersion 21
-    buildToolsVersion "21.0.0"
+    buildToolsVersion "21.1.1"
 
     defaultConfig {
         minSdkVersion 7
@@ -25,28 +25,13 @@ android {
 
     buildTypes {
         release {
-            runProguard false
+            minifyEnabled false
         }
     }
 }
 
 dependencies {
-    provided 'com.android.support:appcompat-v7:21.0.0'
-}
-
-//
-// Attaches a Jar task to the archive artifact. Makes sure we upload a Jar file to maven.
-//
-android.libraryVariants.all { variant ->
-    def name = variant.buildType.name
-
-    // Only attach a jar for non-debug build types.
-    if (!name.equals("DEBUG")) {
-        def task = project.tasks.create "jar${name.capitalize()}", Jar
-        task.dependsOn variant.javaCompile
-        task.from variant.javaCompile.destinationDir
-        artifacts.add('archives', task);
-    }
+    provided 'com.android.support:appcompat-v7:21.0.2'
 }
 
 apply from: '../gradle/deploy.gradle'
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
new file mode 100644
index 0000000..e0214eb
--- /dev/null
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
@@ -0,0 +1,34 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
+/**
+ * Created by chris on 09/11/14.
+ * For Calligraphy.
+ */
+interface CalligraphyActivityFactory {
+
+    /**
+     * Used to Wrap the Activity onCreateView method.
+     *
+     * You implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return CalligraphyContextWrapper.get(getBaseContext()).onActivityCreateView(super.onCreateView(parent, name, context, attrs), attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param parent  parent view, can be null.
+     * @param view    result of {@code super.onCreateView(parent, name, context, attrs)}, this might be null, which is fine.
+     * @param name    Name of View we are trying to inflate
+     * @param context current context (normally the Activity's)
+     * @param attrs   see {@link android.view.LayoutInflater.Factory2#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}  @return the result from the activities {@code onCreateView()}
+     * @return The view passed in, or null if nothing was passed in.
+     * @see android.view.LayoutInflater.Factory2
+     */
+    View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs);
+}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
index da6ff3d..9dd34aa 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
@@ -1,5 +1,6 @@
 package uk.co.chrisjenx.calligraphy;
 
+import android.os.Build;
 import android.text.TextUtils;
 
 /**
@@ -8,74 +9,61 @@
  */
 public class CalligraphyConfig {
 
-    private static CalligraphyConfig mInstance;
+    private static CalligraphyConfig sInstance;
 
     /**
-     * Init the Calligraphy Config file. Each time you call this you set a new default. Of course setting this multiple
-     * times during runtime could have undesired effects.
+     * Set the default Calligraphy Config
      *
-     * @param defaultFontAssetPath a path to a font file in the assets folder, e.g. "fonts/roboto-light.ttf",
-     *                             passing null will default to the device font-family.
+     * @param calligraphyConfig the config build using the builder.
+     * @see uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder
      */
-    public static void initDefault(String defaultFontAssetPath) {
-        mInstance = new CalligraphyConfig(defaultFontAssetPath);
+    public static void initDefault(CalligraphyConfig calligraphyConfig) {
+        sInstance = calligraphyConfig;
     }
 
     /**
-     * Init only the custom attribute to lookup.
-     *
-     * @param defaultAttributeId the custom attribute to look for.
-     * @see #initDefault(String, int)
+     * The current Calligraphy Config.
+     * If not set it will create a default config.
      */
-    public static void initDefault(int defaultAttributeId) {
-        mInstance = new CalligraphyConfig(defaultAttributeId);
+    public static CalligraphyConfig get() {
+        if (sInstance == null)
+            sInstance = new CalligraphyConfig(new Builder());
+        return sInstance;
     }
 
     /**
-     * Define the default font and the custom attribute to lookup globally.
-     *
-     * @param defaultFontAssetPath path to a font file in the assets folder, e.g. "fonts/Roboto-light.ttf",
-     * @param defaultAttributeId   the custom attribute to look for.
-     * @see #initDefault(String)
-     * @see #initDefault(int)
+     * Is a default font set?
      */
-    public static void initDefault(String defaultFontAssetPath, int defaultAttributeId) {
-        mInstance = new CalligraphyConfig(defaultFontAssetPath, defaultAttributeId);
-    }
-
-    static CalligraphyConfig get() {
-        if (mInstance == null)
-            mInstance = new CalligraphyConfig();
-        return mInstance;
-    }
-
-
-    private final String mFontPath;
     private final boolean mIsFontSet;
+    /**
+     * The default Font Path if nothing else is setup.
+     */
+    private final String mFontPath;
+    /**
+     * Default Font Path Attr Id to lookup
+     */
     private final int mAttrId;
-
-    private CalligraphyConfig() {
-        this(null, -1);
-    }
-
-    private CalligraphyConfig(int attrId) {
-        this(null, attrId);
-    }
-
-    private CalligraphyConfig(String defaultFontAssetPath) {
-        this(defaultFontAssetPath, -1);
-    }
-
-    private CalligraphyConfig(String defaultFontAssetPath, int attrId) {
-        this.mFontPath = defaultFontAssetPath;
-        mIsFontSet = !TextUtils.isEmpty(defaultFontAssetPath);
-        mAttrId = attrId != -1 ? attrId : -1;
+    /**
+     * Use Reflection to inject the private factory.
+     */
+    private final boolean mReflection;
+    /**
+     * Use Reflection to intercept CustomView inflation with the correct Context.
+     */
+    private final boolean mCustomViewCreation;
+
+    protected CalligraphyConfig(Builder builder) {
+        mIsFontSet = builder.isFontSet;
+        mFontPath = builder.fontAssetPath;
+        mAttrId = builder.attrId;
+        mReflection = builder.reflection;
+        mCustomViewCreation = builder.customViewCreation;
     }
 
     /**
      * @return mFontPath for text views might be null
      */
-    String getFontPath() {
+    public String getFontPath() {
         return mFontPath;
     }
 
@@ -86,10 +74,122 @@ boolean isFontSet() {
         return mIsFontSet;
     }
 
+    public boolean isReflection() {
+        return mReflection;
+    }
+
+    public boolean isCustomViewCreation() {
+        return mCustomViewCreation;
+    }
+
     /**
      * @return the custom attrId to look for, -1 if not set.
      */
     public int getAttrId() {
         return mAttrId;
     }
+
+    public static class Builder {
+        /**
+         * Default AttrID if not set.
+         */
+        public static final int INVALID_ATTR_ID = -1;
+        /**
+         * Use Reflection to inject the private factory. Doesn't exist pre HC. so defaults to false.
+         */
+        private boolean reflection = Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
+        /**
+         * Use Reflection to intercept CustomView inflation with the correct Context.
+         */
+        private boolean customViewCreation = true;
+        /**
+         * The fontAttrId to look up the font path from.
+         */
+        private int attrId = R.attr.fontPath;
+        /**
+         * Has the user set the default font path.
+         */
+        private boolean isFontSet = false;
+        /**
+         * The default fontPath
+         */
+        private String fontAssetPath = null;
+
+        /**
+         * This defaults to R.attr.fontPath. So only override if you want to use your own attrId.
+         *
+         * @param fontAssetAttrId the custom attribute to look for fonts in assets.
+         * @return this builder.
+         */
+        public Builder setFontAttrId(int fontAssetAttrId) {
+            this.attrId = fontAssetAttrId != INVALID_ATTR_ID ? fontAssetAttrId : INVALID_ATTR_ID;
+            return this;
+        }
+
+        /**
+         * Set the default font if you don't define one else where in your styles.
+         *
+         * @param defaultFontAssetPath a path to a font file in the assets folder, e.g. "fonts/Roboto-light.ttf",
+         *                             passing null will default to the device font-family.
+         * @return this builder.
+         */
+        public Builder setDefaultFontPath(String defaultFontAssetPath) {
+            this.isFontSet = !TextUtils.isEmpty(defaultFontAssetPath);
+            this.fontAssetPath = defaultFontAssetPath;
+            return this;
+        }
+
+        /**
+         * <p>Turn of the use of Reflection to inject the private factory.
+         * This has operational consequences! Please read and understand before disabling.
+         * <b>This is already disabled on pre Honeycomb devices. (API 11)</b></p>
+         *
+         * <p> If you disable this you will need to override your {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * as this is set as the {@link android.view.LayoutInflater} private factory.</p>
+         * <br>
+         * <b> Use the following code in the Activity if you disable FactoryInjection:</b>
+         * <pre><code>
+         * {@literal @}Override
+         * {@literal @}TargetApi(Build.VERSION_CODES.HONEYCOMB)
+         * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+         *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+         * }
+         * </code></pre>
+         */
+        public void disablePrivateFactoryInjection() {
+            this.reflection = false;
+        }
+
+        /**
+         * Due to the poor inflation order where custom views are created and never returned inside an
+         * {@code onCreateView(...)} method. We have to create CustomView's at the latest point in the
+         * overrideable injection flow.
+         *
+         * On HoneyComb+ this is inside the {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * Pre HoneyComb this is in the {@link android.view.LayoutInflater.Factory#onCreateView(String, android.util.AttributeSet)}
+         *
+         * We wrap base implementations, so if you LayoutInflater/Factory/Activity creates the
+         * custom view before we get to this point, your view is used. (Such is the case with the
+         * TintEditText etc)
+         *
+         * The problem is, the native methods pass there parents context to the constructor in a really
+         * specific place. We have to mimic this in {@link uk.co.chrisjenx.calligraphy.CalligraphyLayoutInflater#createCustomViewInternal(android.view.View, android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * To mimic this we have to use reflection as the Class constructor args are hidden to us.
+         *
+         * We have discussed other means of doing this but this is the only semi-clean way of doing it.
+         * (Without having to do proxy classes etc).
+         *
+         * Calling this will of course speed up inflation by turning off reflection, but not by much,
+         * But if you want Calligraphy to inject the correct typeface then you will need to make sure your CustomView's
+         * are created before reaching the LayoutInflater onViewCreated.
+         */
+        public void disableCustomViewInflation() {
+            this.customViewCreation = false;
+        }
+
+        public CalligraphyConfig build() {
+            this.isFontSet = !TextUtils.isEmpty(fontAssetPath);
+            return new CalligraphyConfig(this);
+        }
+    }
 }
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
index f9f5bec..4ad58dd 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
@@ -1,8 +1,11 @@
 package uk.co.chrisjenx.calligraphy;
 
+import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
+import android.util.AttributeSet;
 import android.view.LayoutInflater;
+import android.view.View;
 
 /**
  * Created by chris on 19/12/2013
@@ -10,10 +13,65 @@
  */
 public class CalligraphyContextWrapper extends ContextWrapper {
 
-    private LayoutInflater mInflater;
+    private CalligraphyLayoutInflater mInflater;
 
     private final int mAttributeId;
 
+    /**
+     * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
+     *
+     * Remember if you are defining default in the
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap.
+     * @return ContextWrapper to pass back to the activity.
+     */
+    public static ContextWrapper wrap(Context base) {
+        return new CalligraphyContextWrapper(base);
+    }
+
+    /**
+     * You only need to call this <b>IF</b> you call
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder#disablePrivateFactoryInjection()}
+     * This will need to be called from the
+     * {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+     * method to enable view font injection if the view is created inside the activity onCreateView.
+     *
+     * You would implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @param parent   Parent view from onCreateView
+     * @param view     The View Created inside onCreateView or from super.onCreateView
+     * @param name     The View name from onCreateView
+     * @param context  The context from onCreateView
+     * @param attr     The AttributeSet from onCreateView
+     * @return The same view passed in, or null if null passed in.
+     */
+    public static View onActivityCreateView(Activity activity, View parent, View view, String name, Context context, AttributeSet attr) {
+        return get(activity).onActivityCreateView(parent, view, name, context, attr);
+    }
+
+    /**
+     * Get the Calligraphy Activity Fragment Instance to allow callbacks for when views are created.
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @return Interface allowing you to call onActivityViewCreated
+     */
+    static CalligraphyActivityFactory get(Activity activity) {
+        if (!(activity.getLayoutInflater() instanceof CalligraphyLayoutInflater)) {
+            throw new RuntimeException("This activity does not wrap the Base Context! See CalligraphyContextWrapper.wrap(Context)");
+        }
+        return (CalligraphyActivityFactory) activity.getLayoutInflater();
+    }
+
     /**
      * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
      *
@@ -23,7 +81,7 @@
      *
      * @param base ContextBase to Wrap
      */
-    public CalligraphyContextWrapper(Context base) {
+    CalligraphyContextWrapper(Context base) {
         super(base);
         mAttributeId = CalligraphyConfig.get().getAttrId();
     }
@@ -38,7 +96,9 @@ public CalligraphyContextWrapper(Context base) {
      *
      * @param base        ContextBase to Wrap
      * @param attributeId Attribute to lookup.
+     * @deprecated use {@link #wrap(android.content.Context)}
      */
+    @Deprecated
     public CalligraphyContextWrapper(Context base, int attributeId) {
         super(base);
         mAttributeId = attributeId;
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
index 6e512ba..42b2a0d 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
@@ -4,7 +4,6 @@
 import android.content.Context;
 import android.text.TextUtils;
 import android.util.AttributeSet;
-import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
@@ -20,11 +19,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
-class CalligraphyFactory implements LayoutInflater.Factory {
-    private static final String[] sClassPrefixList = {
-            "android.widget.",
-            "android.webkit."
-    };
+class CalligraphyFactory {
+
     private static final String ACTION_BAR_TITLE = "action_bar_title";
     private static final String ACTION_BAR_SUBTITLE = "action_bar_subtitle";
     private static final Map<Class<? extends TextView>, Integer> sStyles
@@ -115,63 +111,30 @@ protected static boolean matchesResourceIdName(View view, String matches) {
         return resourceEntryName.equalsIgnoreCase(matches);
     }
 
-
-    private final LayoutInflater.Factory factory;
     private final int mAttributeId;
 
-    public CalligraphyFactory(LayoutInflater.Factory factory, int attributeId) {
-        this.factory = factory;
+    public CalligraphyFactory(int attributeId) {
         this.mAttributeId = attributeId;
     }
 
-    @Override
-    public View onCreateView(String name, Context context, AttributeSet attrs) {
-        View view = null;
-
-        if (context instanceof LayoutInflater.Factory) {
-            view = ((LayoutInflater.Factory) context).onCreateView(name, context, attrs);
-        }
-
-        if (factory != null && view == null) {
-            view = factory.onCreateView(name, context, attrs);
-        }
-
-        if (view == null) {
-            view = createViewOrFailQuietly(name, context, attrs);
-        }
+    /**
+     * Handle the created view
+     *
+     * @param view    nullable.
+     * @param context shouldn't be null.
+     * @param attrs   shouldn't be null.
+     * @return null if null is passed in.
+     */
 
-        if (view != null) {
-            onViewCreated(view, name, context, attrs);
+    public View onViewCreated(View view, Context context, AttributeSet attrs) {
+        if (view != null && view.getTag(R.id.calligraphy_tag_id) != Boolean.TRUE) {
+            onViewCreatedInternal(view, context, attrs);
+            view.setTag(R.id.calligraphy_tag_id, Boolean.TRUE);
         }
-
         return view;
     }
 
-    protected View createViewOrFailQuietly(String name, Context context, AttributeSet attrs) {
-        if (name.contains(".")) {
-            return createViewOrFailQuietly(name, null, context, attrs);
-        }
-
-        for (final String prefix : sClassPrefixList) {
-            final View view = createViewOrFailQuietly(name, prefix, context, attrs);
-            if (view != null) {
-                return view;
-            }
-        }
-
-        return null;
-    }
-
-    protected View createViewOrFailQuietly(String name, String prefix, Context context, AttributeSet attrs) {
-        try {
-            return LayoutInflater.from(context).createView(name, prefix, attrs);
-        } catch (Exception ignore) {
-            ignore.printStackTrace();
-            return null;
-        }
-    }
-
-    protected void onViewCreated(View view, String name, final Context context, AttributeSet attrs) {
+    void onViewCreatedInternal(View view, final Context context, AttributeSet attrs) {
         if (view instanceof TextView) {
             // Fast path the setting of TextView's font, means if we do some delayed setting of font,
             // which has already been set by use we skip this TextView (mainly for inflating custom,
@@ -204,7 +167,6 @@ protected void onViewCreated(View view, String name, final Context context, Attr
                     textViewFont = CalligraphyUtils.pullFontPathFromTheme(context, styleForTextView[0], mAttributeId);
             }
 
-
             // Still need to defer the Native action bar, appcompat-v7:21+ uses the Toolbar underneath. But won't match these anyway.
             final boolean deferred = matchesResourceIdName(view, ACTION_BAR_TITLE) || matchesResourceIdName(view, ACTION_BAR_SUBTITLE);
 
@@ -222,7 +184,7 @@ public void onGlobalLayout() {
                     if (parent.getChildCount() <= 0) return;
                     // Process children, defer draw as it has set the typeface.
                     for (int i = 0; i < parent.getChildCount(); i++) {
-                        onViewCreated(parent.getChildAt(i), null, context, null);
+                        onViewCreated(parent.getChildAt(i), context, null);
                     }
                 }
             });
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
index e8bdbd0..e277071 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
@@ -1,37 +1,306 @@
 package uk.co.chrisjenx.calligraphy;
 
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Build;
+import android.util.AttributeSet;
 import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 
 /**
  * Created by chris on 19/12/2013
  * Project: Calligraphy
  */
-class CalligraphyLayoutInflater extends LayoutInflater {
+class CalligraphyLayoutInflater extends LayoutInflater implements CalligraphyActivityFactory {
+
+    private static final String[] sClassPrefixList = {
+            "android.widget.",
+            "android.webkit."
+    };
 
     private final int mAttributeId;
+    private final CalligraphyFactory mCalligraphyFactory;
+    // Reflection Hax
+    private boolean mSetPrivateFactory = false;
+    private Field mConstructorArgs = null;
 
     protected CalligraphyLayoutInflater(Context context, int attributeId) {
         super(context);
         mAttributeId = attributeId;
-        setUpLayoutFactory();
+        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        setUpLayoutFactories();
     }
 
     protected CalligraphyLayoutInflater(LayoutInflater original, Context newContext, int attributeId) {
         super(original, newContext);
         mAttributeId = attributeId;
-        setUpLayoutFactory();
+        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        setUpLayoutFactories();
     }
 
-    private void setUpLayoutFactory() {
-        // Don't try to set factory over the top of the current child one.
-        if (!(getFactory() instanceof CalligraphyFactory)) {
-            setFactory(new CalligraphyFactory(getFactory(), mAttributeId));
+    @Override
+    public LayoutInflater cloneInContext(Context newContext) {
+        return new CalligraphyLayoutInflater(this, newContext, mAttributeId);
+    }
+
+    // ===
+    // Wrapping goodies
+    // ===
+
+
+    @Override
+    public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
+        setPrivateFactoryInternal();
+        return super.inflate(parser, root, attachToRoot);
+    }
+
+    /**
+     * We don't want to unnecessary create/set our factories if there are none there. We try to be
+     * as lazy as possible.
+     */
+    private void setUpLayoutFactories() {
+        // If we are HC+ we get and set Factory2 otherwise we just wrap Factory1
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            if (getFactory2() != null && !(getFactory2() instanceof WrapperFactory2)) {
+                // Sets both Factory/Factory2
+                setFactory2(getFactory2());
+            }
+        }
+        // We can do this as setFactory2 is used for both methods.
+        if (getFactory() != null && !(getFactory() instanceof WrapperFactory)) {
+            setFactory(getFactory());
         }
     }
 
     @Override
-    public LayoutInflater cloneInContext(Context newContext) {
-        return new CalligraphyLayoutInflater(this, newContext, mAttributeId);
+    public void setFactory(Factory factory) {
+        // Only set our factory and wrap calls to the Factory trying to be set!
+        if (!(factory instanceof WrapperFactory)) {
+            super.setFactory(new WrapperFactory(factory, this, mCalligraphyFactory));
+        } else {
+            super.setFactory(factory);
+        }
+    }
+
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public void setFactory2(Factory2 factory2) {
+        // Only set our factory and wrap calls to the Factory2 trying to be set!
+        if (!(factory2 instanceof WrapperFactory2)) {
+            super.setFactory2(new WrapperFactory2(factory2, mCalligraphyFactory));
+        } else {
+            super.setFactory2(factory2);
+        }
+    }
+
+    private void setPrivateFactoryInternal() {
+        // Already tried to set the factory.
+        if (mSetPrivateFactory) return;
+        // Reflection (Or Old Device) skip.
+        if (!CalligraphyConfig.get().isReflection()) return;
+        // Skip if not attached to an activity.
+        if (!(getContext() instanceof Factory2)) {
+            mSetPrivateFactory = true;
+            return;
+        }
+
+        final Method setPrivateFactoryMethod = ReflectionUtils
+                .getMethod(LayoutInflater.class, "setPrivateFactory");
+
+        if (setPrivateFactoryMethod != null) {
+            ReflectionUtils.invokeMethod(this,
+                    setPrivateFactoryMethod,
+                    new PrivateWrapperFactory2((Factory2) getContext(), this, mCalligraphyFactory));
+        }
+        mSetPrivateFactory = true;
+    }
+
+    // ===
+    // LayoutInflater ViewCreators
+    // Works in order of inflation
+    // ===
+
+    /**
+     * The Activity onCreateView (PrivateFactory) is the third port of call for LayoutInflation.
+     * We opted to manual injection over aggressive reflection, this should be less fragile.
+     */
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs) {
+        return mCalligraphyFactory.onViewCreated(createCustomViewInternal(parent, view, name, context, attrs), context, attrs);
+    }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     */
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException {
+        return mCalligraphyFactory.onViewCreated(super.onCreateView(parent, name, attrs),
+                getContext(), attrs);
     }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     * Basically if this method doesn't inflate the View nothing probably will.
+     */
+    @Override
+    protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
+        // This mimics the {@code PhoneLayoutInflater} in the way it tries to inflate the base
+        // classes, if this fails its pretty certain the app will fail at this point.
+        View view = null;
+        for (String prefix : sClassPrefixList) {
+            try {
+                view = createView(name, prefix, attrs);
+            } catch (ClassNotFoundException e) {
+            }
+        }
+        // In this case we want to let the base class take a crack
+        // at it.
+        if (view == null) view = super.onCreateView(name, attrs);
+
+        return mCalligraphyFactory.onViewCreated(view, view.getContext(), attrs);
+    }
+
+    /**
+     * Nasty method to inflate custom layouts that haven't been handled else where. If this fails it
+     * will fall back through to the PhoneLayoutInflater method of inflating custom views where
+     * Calligraphy will NOT have a hook into.
+     *
+     * @param parent  parent view
+     * @param view    view if it has been inflated by this point, if this is not null this method
+     *                just returns this value.
+     * @param name    name of the thing to inflate.
+     * @param context Context to inflate by if parent is null
+     * @param attrs   Attr for this view which we can steal fontPath from too.
+     * @return view or the View we inflate in here.
+     */
+    private View createCustomViewInternal(View parent, View view, String name, Context context, AttributeSet attrs) {
+        // I by no means advise anyone to do this normally, but Google have locked down access to
+        // the createView() method, so we never get a callback with attributes at the end of the
+        // createViewFromTag chain (which would solve all this unnecessary rubbish).
+        // We at the very least try to optimise this as much as possible.
+        // We only call for customViews (As they are the ones that never go through onCreateView(...)).
+        // We also maintain the Field reference and make it accessible which will make a pretty
+        // significant difference to performance on Android 4.0+.
+
+        // If CustomViewCreation is off skip this.
+        if (!CalligraphyConfig.get().isCustomViewCreation()) return view;
+        if (view == null && name.indexOf('.') > -1) {
+            if (mConstructorArgs == null)
+                mConstructorArgs = ReflectionUtils.getField(LayoutInflater.class, "mConstructorArgs");
+
+            final Object[] mConstructorArgsArr = (Object[]) ReflectionUtils.getValue(mConstructorArgs, this);
+            final Object lastContext = mConstructorArgsArr[0];
+            mConstructorArgsArr[0] = parent != null ? parent.getContext() : context;
+            ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            try {
+                view = createView(name, null, attrs);
+            } catch (ClassNotFoundException ignored) {
+            } finally {
+                mConstructorArgsArr[0] = lastContext;
+                ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            }
+        }
+        return view;
+    }
+
+    // ===
+    // Wrapper Factories for Pre/Post HC
+    // ===
+
+    /**
+     * Factory 1 is the first port of call for LayoutInflation
+     */
+    private static class WrapperFactory implements Factory {
+
+        private final Factory mFactory;
+        private final CalligraphyLayoutInflater mInflater;
+        private final CalligraphyFactory mCalligraphyFactory;
+
+        public WrapperFactory(Factory factory, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+            mFactory = factory;
+            mInflater = inflater;
+            mCalligraphyFactory = calligraphyFactory;
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+                return mCalligraphyFactory.onViewCreated(
+                        mInflater.createCustomViewInternal(
+                                null, mFactory.onCreateView(name, context, attrs), name, context, attrs
+                        ),
+                        context, attrs
+                );
+            }
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory.onCreateView(name, context, attrs),
+                    context, attrs
+            );
+        }
+    }
+
+    /**
+     * Factory 2 is the second port of call for LayoutInflation
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private static class WrapperFactory2 implements Factory2 {
+        protected final Factory2 mFactory2;
+        protected final CalligraphyFactory mCalligraphyFactory;
+
+        public WrapperFactory2(Factory2 factory2, CalligraphyFactory calligraphyFactory) {
+            mFactory2 = factory2;
+            mCalligraphyFactory = calligraphyFactory;
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory2.onCreateView(name, context, attrs),
+                    context, attrs);
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory2.onCreateView(parent, name, context, attrs),
+                    context, attrs);
+        }
+    }
+
+    /**
+     * Private factory is step three for Activity Inflation, this is what is attached to the
+     * Activity on HC+ devices.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private static class PrivateWrapperFactory2 extends WrapperFactory2 {
+
+        private final CalligraphyLayoutInflater mInflater;
+
+        public PrivateWrapperFactory2(Factory2 factory2, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+            super(factory2, calligraphyFactory);
+            mInflater = inflater;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mInflater.createCustomViewInternal(parent,
+                            mFactory2.onCreateView(parent, name, context, attrs),
+                            name, context, attrs
+                    ),
+                    context, attrs
+            );
+        }
+    }
+
 }
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
new file mode 100644
index 0000000..e19e37d
--- /dev/null
+++ b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
@@ -0,0 +1,57 @@
+package uk.co.chrisjenx.calligraphy;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Created by chris on 17/12/14.
+ * For Calligraphy.
+ */
+class ReflectionUtils {
+
+    static Field getField(Class clazz, String fieldName) {
+        try {
+            final Field f = clazz.getDeclaredField(fieldName);
+            f.setAccessible(true);
+            return f;
+        } catch (NoSuchFieldException ignored) {
+        }
+        return null;
+    }
+
+    static Object getValue(Field field, Object obj) {
+        try {
+            return field.get(obj);
+        } catch (IllegalAccessException ignored) {
+        }
+        return null;
+    }
+
+    static void setValue(Field field, Object obj, Object value) {
+        try {
+            field.set(obj, value);
+        } catch (IllegalAccessException e) {
+        }
+    }
+
+    static Method getMethod(Class clazz, String methodName) {
+        final Method[] methods = clazz.getMethods();
+        for (Method method : methods) {
+            if (method.getName().equals(methodName)) {
+                method.setAccessible(true);
+                return method;
+            }
+        }
+        return null;
+    }
+
+    static void invokeMethod(Object object, Method method, Object... args) {
+        try {
+            if (method == null) return;
+            method.invoke(object, args);
+        } catch (IllegalAccessException | InvocationTargetException ignored) {
+            ignored.printStackTrace();
+        }
+    }
+}
diff --git a/CalligraphySample/src/main/res/values/attrs.xml b/calligraphy/src/main/res/values/attrs.xml
similarity index 100%
rename from CalligraphySample/src/main/res/values/attrs.xml
rename to calligraphy/src/main/res/values/attrs.xml
diff --git a/calligraphy/src/main/res/values/ids.xml b/calligraphy/src/main/res/values/ids.xml
new file mode 100644
index 0000000..0a3cb38
--- /dev/null
+++ b/calligraphy/src/main/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <item name="calligraphy_tag_id" type="id"/>
+</resources>
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 654c402..0e5c8a9 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -18,8 +18,8 @@
 # org.gradle.parallel=true
 
 GROUP=uk.co.chrisjenx
-VERSION_NAME=1.2.0
-VERSION_CODE=13
+VERSION_NAME=2.0.0
+VERSION_CODE=15
 
 POM_PACKAGING=jar
 POM_URL=https://github.com/chrisjenx/Calligraphy
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 701bda9..589f0c3 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat Oct 18 23:57:44 BST 2014
+#Thu Nov 27 12:20:57 GMT 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
