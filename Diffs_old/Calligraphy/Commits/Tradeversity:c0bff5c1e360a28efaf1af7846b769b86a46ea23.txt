diff --git a/CalligraphySample/build.gradle b/CalligraphySample/build.gradle
index 6cec900..85d701e 100644
--- a/CalligraphySample/build.gradle
+++ b/CalligraphySample/build.gradle
@@ -23,7 +23,7 @@ android {
 }
 
 dependencies {
-    compile project(':calligraphy')
+    compile project(':colorography')
     compile "com.android.support:support-v4:${supportLibraryVersion}"
     compile "com.android.support:appcompat-v7:${supportLibraryVersion}"
 
diff --git a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
index 826a408..a461f19 100644
--- a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
+++ b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/CalligraphyApplication.java
@@ -2,7 +2,7 @@
 
 import android.app.Application;
 
-import uk.co.chrisjenx.calligraphy.CalligraphyConfig;
+import com.ftinc.colorography.ColorographyConfig;
 
 /**
  * Created by chris on 06/05/2014.
@@ -13,7 +13,7 @@
     @Override
     public void onCreate() {
         super.onCreate();
-        CalligraphyConfig.initDefault(new CalligraphyConfig.Builder()
+        ColorographyConfig.initDefault(new ColorographyConfig.Builder()
                 .setDefaultFontPath("fonts/Roboto-ThinItalic.ttf")
                 .setFontAttrId(R.attr.fontPath)
                 .addCustomViewWithSetTypeface(CustomViewWithTypefaceSupport.class)
diff --git a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
index 7131d30..c4edb9f 100644
--- a/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
+++ b/CalligraphySample/src/main/java/uk/co/chrisjenx/calligraphy/sample/MainActivity.java
@@ -7,7 +7,7 @@
 import android.support.v7.app.AppCompatActivity;
 import android.support.v7.widget.Toolbar;
 
-import uk.co.chrisjenx.calligraphy.CalligraphyContextWrapper;
+import com.ftinc.colorography.ColorographyContextWrapper;
 
 import static butterknife.ButterKnife.findById;
 
@@ -62,7 +62,7 @@ public void run() {
 
     @Override
     protected void attachBaseContext(Context newBase) {
-        super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase));
+        super.attachBaseContext(ColorographyContextWrapper.wrap(newBase));
     }
 
 }
diff --git a/build.gradle b/build.gradle
index a8a043c..f7e2c6a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,32 +1,37 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 buildscript {
-  repositories {
-    jcenter()
-  }
-  dependencies {
-    classpath 'com.android.tools.build:gradle:2.3.2'
-  }
+    repositories {
+        jcenter()
+        google()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:3.0.0-alpha5'
+    }
 }
 
 allprojects {
-  repositories {
-    jcenter()
-  }
-  // Is Release Build?
-  version = getProperty('VERSION_NAME');
+    repositories {
+        jcenter()
+        google()
+    }
 
-  ext {
-    isReleaseVersion = has("release")
-    versionCodeInt = getProperty('VERSION_CODE').toInteger()
-    supportLibraryVersion = '25.3.1'
-    buildToolsVersion = '25.0.3'
-    compileSdkVersion = 25
-    minSdkVersion = 9
-    targetSdkVersion = 25
-  }
+    ext {
+        isReleaseVersion = has("release")
+        versionCodeInt = getProperty('VERSION_CODE').toInteger()
+        supportLibraryVersion = '25.4.0'
+        buildToolsVersion = '25.0.3'
+        compileSdkVersion = 25
+        minSdkVersion = 17
+        targetSdkVersion = 25
+    }
+}
+
+subprojects {
+    group = GROUP
+    version = VERSION_NAME
 }
 
 task wrapper(type: Wrapper) {
-  gradleVersion = '3.5'
-  distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-bin.zip"
+    gradleVersion = '3.5'
+    distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-bin.zip"
 }
diff --git a/calligraphy/consumer-proguard-rules.txt b/calligraphy/consumer-proguard-rules.txt
deleted file mode 100644
index 10691cb..0000000
--- a/calligraphy/consumer-proguard-rules.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Developer/android-sdk-osx/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
--keep class uk.co.chrisjenx.calligraphy.* { *; }
--keep class uk.co.chrisjenx.calligraphy.*$* { *; }
-
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
deleted file mode 100644
index 2fb8f63..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
+++ /dev/null
@@ -1,320 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.os.Build;
-import android.text.TextUtils;
-import android.view.View;
-import android.widget.AutoCompleteTextView;
-import android.widget.Button;
-import android.widget.CheckBox;
-import android.widget.EditText;
-import android.widget.MultiAutoCompleteTextView;
-import android.widget.RadioButton;
-import android.widget.TextView;
-import android.widget.ToggleButton;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Created by chris on 20/12/2013
- * Project: Calligraphy
- */
-public class CalligraphyConfig {
-
-    /**
-     * The default styles for the factory to lookup. The builder builds an extended immutable
-     * map of this with any additional custom styles.
-     */
-    private static final Map<Class<? extends TextView>, Integer> DEFAULT_STYLES = new HashMap<>();
-
-    static {
-        {
-            DEFAULT_STYLES.put(TextView.class, android.R.attr.textViewStyle);
-            DEFAULT_STYLES.put(Button.class, android.R.attr.buttonStyle);
-            DEFAULT_STYLES.put(EditText.class, android.R.attr.editTextStyle);
-            DEFAULT_STYLES.put(AutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
-            DEFAULT_STYLES.put(MultiAutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
-            DEFAULT_STYLES.put(CheckBox.class, android.R.attr.checkboxStyle);
-            DEFAULT_STYLES.put(RadioButton.class, android.R.attr.radioButtonStyle);
-            DEFAULT_STYLES.put(ToggleButton.class, android.R.attr.buttonStyleToggle);
-            if (CalligraphyUtils.canAddV7AppCompatViews()) {
-                addAppCompatViews();
-            }
-        }
-    }
-
-    /**
-     * AppCompat will inflate special versions of views for Material tinting etc,
-     * this adds those classes to the style lookup map
-     */
-    private static void addAppCompatViews() {
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatTextView.class, android.R.attr.textViewStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatButton.class, android.R.attr.buttonStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatEditText.class, android.R.attr.editTextStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatAutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatMultiAutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatCheckBox.class, android.R.attr.checkboxStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatRadioButton.class, android.R.attr.radioButtonStyle);
-        DEFAULT_STYLES.put(android.support.v7.widget.AppCompatCheckedTextView.class, android.R.attr.checkedTextViewStyle);
-    }
-
-    private static CalligraphyConfig sInstance;
-
-    /**
-     * Set the default Calligraphy Config
-     *
-     * @param calligraphyConfig the config build using the builder.
-     * @see uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder
-     */
-    public static void initDefault(CalligraphyConfig calligraphyConfig) {
-        sInstance = calligraphyConfig;
-    }
-
-    /**
-     * The current Calligraphy Config.
-     * If not set it will create a default config.
-     */
-    public static CalligraphyConfig get() {
-        if (sInstance == null)
-            sInstance = new CalligraphyConfig(new Builder());
-        return sInstance;
-    }
-
-    /**
-     * Is a default font set?
-     */
-    private final boolean mIsFontSet;
-    /**
-     * The default Font Path if nothing else is setup.
-     */
-    private final String mFontPath;
-    /**
-     * Default Font Path Attr Id to lookup
-     */
-    private final int mAttrId;
-    /**
-     * Use Reflection to inject the private factory.
-     */
-    private final boolean mReflection;
-    /**
-     * Use Reflection to intercept CustomView inflation with the correct Context.
-     */
-    private final boolean mCustomViewCreation;
-    /**
-     * Use Reflection to try to set typeface for custom views if they has setTypeface method
-     */
-    private final boolean mCustomViewTypefaceSupport;
-    /**
-     * Class Styles. Build from DEFAULT_STYLES and the builder.
-     */
-    private final Map<Class<? extends TextView>, Integer> mClassStyleAttributeMap;
-    /**
-     * Collection of custom non-{@code TextView}'s registered for applying typeface during inflation
-     * @see uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder#addCustomViewWithSetTypeface(Class)
-     */
-    private final Set<Class<?>> hasTypefaceViews;
-
-    protected CalligraphyConfig(Builder builder) {
-        mIsFontSet = builder.isFontSet;
-        mFontPath = builder.fontAssetPath;
-        mAttrId = builder.attrId;
-        mReflection = builder.reflection;
-        mCustomViewCreation = builder.customViewCreation;
-        mCustomViewTypefaceSupport = builder.customViewTypefaceSupport;
-        final Map<Class<? extends TextView>, Integer> tempMap = new HashMap<>(DEFAULT_STYLES);
-        tempMap.putAll(builder.mStyleClassMap);
-        mClassStyleAttributeMap = Collections.unmodifiableMap(tempMap);
-        hasTypefaceViews = Collections.unmodifiableSet(builder.mHasTypefaceClasses);
-    }
-
-    /**
-     * @return mFontPath for text views might be null
-     */
-    public String getFontPath() {
-        return mFontPath;
-    }
-
-    /**
-     * @return true if set, false if null|empty
-     */
-    boolean isFontSet() {
-        return mIsFontSet;
-    }
-
-    public boolean isReflection() {
-        return mReflection;
-    }
-
-    public boolean isCustomViewCreation() {
-        return mCustomViewCreation;
-    }
-
-    public boolean isCustomViewTypefaceSupport() {
-        return mCustomViewTypefaceSupport;
-    }
-
-    public boolean isCustomViewHasTypeface(View view) {
-        return hasTypefaceViews.contains(view.getClass());
-    }
-
-    /* default */ Map<Class<? extends TextView>, Integer> getClassStyles() {
-        return mClassStyleAttributeMap;
-    }
-
-    /**
-     * @return the custom attrId to look for, -1 if not set.
-     */
-    public int getAttrId() {
-        return mAttrId;
-    }
-
-    public static class Builder {
-        /**
-         * Default AttrID if not set.
-         */
-        public static final int INVALID_ATTR_ID = -1;
-        /**
-         * Use Reflection to inject the private factory. Doesn't exist pre HC. so defaults to false.
-         */
-        private boolean reflection = Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
-        /**
-         * Use Reflection to intercept CustomView inflation with the correct Context.
-         */
-        private boolean customViewCreation = true;
-        /**
-         * Use Reflection during view creation to try change typeface via setTypeface method if it exists
-         */
-        private boolean customViewTypefaceSupport = false;
-        /**
-         * The fontAttrId to look up the font path from.
-         */
-        private int attrId = R.attr.fontPath;
-        /**
-         * Has the user set the default font path.
-         */
-        private boolean isFontSet = false;
-        /**
-         * The default fontPath
-         */
-        private String fontAssetPath = null;
-        /**
-         * Additional Class Styles. Can be empty.
-         */
-        private Map<Class<? extends TextView>, Integer> mStyleClassMap = new HashMap<>();
-
-        private Set<Class<?>> mHasTypefaceClasses = new HashSet<>();
-
-        /**
-         * This defaults to R.attr.fontPath. So only override if you want to use your own attrId.
-         *
-         * @param fontAssetAttrId the custom attribute to look for fonts in assets.
-         * @return this builder.
-         */
-        public Builder setFontAttrId(int fontAssetAttrId) {
-            this.attrId = fontAssetAttrId;
-            return this;
-        }
-
-        /**
-         * Set the default font if you don't define one else where in your styles.
-         *
-         * @param defaultFontAssetPath a path to a font file in the assets folder, e.g. "fonts/Roboto-light.ttf",
-         *                             passing null will default to the device font-family.
-         * @return this builder.
-         */
-        public Builder setDefaultFontPath(String defaultFontAssetPath) {
-            this.isFontSet = !TextUtils.isEmpty(defaultFontAssetPath);
-            this.fontAssetPath = defaultFontAssetPath;
-            return this;
-        }
-
-        /**
-         * <p>Turn of the use of Reflection to inject the private factory.
-         * This has operational consequences! Please read and understand before disabling.
-         * <b>This is already disabled on pre Honeycomb devices. (API 11)</b></p>
-         *
-         * <p> If you disable this you will need to override your {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
-         * as this is set as the {@link android.view.LayoutInflater} private factory.</p>
-         * <br>
-         * <b> Use the following code in the Activity if you disable FactoryInjection:</b>
-         * <pre><code>
-         * {@literal @}Override
-         * {@literal @}TargetApi(Build.VERSION_CODES.HONEYCOMB)
-         * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
-         *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
-         * }
-         * </code></pre>
-         */
-        public Builder disablePrivateFactoryInjection() {
-            this.reflection = false;
-            return this;
-        }
-
-        /**
-         * Due to the poor inflation order where custom views are created and never returned inside an
-         * {@code onCreateView(...)} method. We have to create CustomView's at the latest point in the
-         * overrideable injection flow.
-         *
-         * On HoneyComb+ this is inside the {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
-         * Pre HoneyComb this is in the {@link android.view.LayoutInflater.Factory#onCreateView(String, android.util.AttributeSet)}
-         *
-         * We wrap base implementations, so if you LayoutInflater/Factory/Activity creates the
-         * custom view before we get to this point, your view is used. (Such is the case with the
-         * TintEditText etc)
-         *
-         * The problem is, the native methods pass there parents context to the constructor in a really
-         * specific place. We have to mimic this in {@link uk.co.chrisjenx.calligraphy.CalligraphyLayoutInflater#createCustomViewInternal(android.view.View, android.view.View, String, android.content.Context, android.util.AttributeSet)}
-         * To mimic this we have to use reflection as the Class constructor args are hidden to us.
-         *
-         * We have discussed other means of doing this but this is the only semi-clean way of doing it.
-         * (Without having to do proxy classes etc).
-         *
-         * Calling this will of course speed up inflation by turning off reflection, but not by much,
-         * But if you want Calligraphy to inject the correct typeface then you will need to make sure your CustomView's
-         * are created before reaching the LayoutInflater onViewCreated.
-         */
-        public Builder disableCustomViewInflation() {
-            this.customViewCreation = false;
-            return this;
-        }
-
-        /**
-         * Add a custom style to get looked up. If you use a custom class that has a parent style
-         * which is not part of the default android styles you will need to add it here.
-         *
-         * The Calligraphy inflater is unaware of custom styles in your custom classes. We use
-         * the class type to look up the style attribute in the theme resources.
-         *
-         * So if you had a {@code MyTextField.class} which looked up it's default style as
-         * {@code R.attr.textFieldStyle} you would add those here.
-         *
-         * {@code builder.addCustomStyle(MyTextField.class,R.attr.textFieldStyle}
-         *
-         * @param styleClass             the class that related to the parent styleResource. null is ignored.
-         * @param styleResourceAttribute e.g. {@code R.attr.textFieldStyle}, 0 is ignored.
-         * @return this builder.
-         */
-        public Builder addCustomStyle(final Class<? extends TextView> styleClass, final int styleResourceAttribute) {
-            if (styleClass == null || styleResourceAttribute == 0) return this;
-            mStyleClassMap.put(styleClass, styleResourceAttribute);
-            return this;
-        }
-
-        /**
-         * Register custom non-{@code TextView}'s which implement {@code setTypeface} so they can have the Typeface applied during inflation.
-         */
-        public Builder addCustomViewWithSetTypeface(Class<?> clazz) {
-            customViewTypefaceSupport = true;
-            mHasTypefaceClasses.add(clazz);
-            return this;
-        }
-
-        public CalligraphyConfig build() {
-            this.isFontSet = !TextUtils.isEmpty(fontAssetPath);
-            return new CalligraphyConfig(this);
-        }
-    }
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
deleted file mode 100644
index 8650208..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.util.AttributeSet;
-import android.view.LayoutInflater;
-import android.view.View;
-
-/**
- * Created by chris on 19/12/2013
- * Project: Calligraphy
- */
-public class CalligraphyContextWrapper extends ContextWrapper {
-
-    private CalligraphyLayoutInflater mInflater;
-
-    private final int mAttributeId;
-
-    /**
-     * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
-     *
-     * Remember if you are defining default in the
-     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
-     * the activity is created.
-     *
-     * @param base ContextBase to Wrap.
-     * @return ContextWrapper to pass back to the activity.
-     */
-    public static ContextWrapper wrap(Context base) {
-        return new CalligraphyContextWrapper(base);
-    }
-
-    /**
-     * You only need to call this <b>IF</b> you call
-     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder#disablePrivateFactoryInjection()}
-     * This will need to be called from the
-     * {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
-     * method to enable view font injection if the view is created inside the activity onCreateView.
-     *
-     * You would implement this method like so in you base activity.
-     * <pre>
-     * {@code
-     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
-     *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
-     * }
-     * }
-     * </pre>
-     *
-     * @param activity The activity the original that the ContextWrapper was attached too.
-     * @param parent   Parent view from onCreateView
-     * @param view     The View Created inside onCreateView or from super.onCreateView
-     * @param name     The View name from onCreateView
-     * @param context  The context from onCreateView
-     * @param attr     The AttributeSet from onCreateView
-     * @return The same view passed in, or null if null passed in.
-     */
-    public static View onActivityCreateView(Activity activity, View parent, View view, String name, Context context, AttributeSet attr) {
-        return get(activity).onActivityCreateView(parent, view, name, context, attr);
-    }
-
-    /**
-     * Get the Calligraphy Activity Fragment Instance to allow callbacks for when views are created.
-     *
-     * @param activity The activity the original that the ContextWrapper was attached too.
-     * @return Interface allowing you to call onActivityViewCreated
-     */
-    static CalligraphyActivityFactory get(Activity activity) {
-        if (!(activity.getLayoutInflater() instanceof CalligraphyLayoutInflater)) {
-            throw new RuntimeException("This activity does not wrap the Base Context! See CalligraphyContextWrapper.wrap(Context)");
-        }
-        return (CalligraphyActivityFactory) activity.getLayoutInflater();
-    }
-
-    /**
-     * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
-     *
-     * Remember if you are defining default in the
-     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
-     * the activity is created.
-     *
-     * @param base ContextBase to Wrap
-     */
-    CalligraphyContextWrapper(Context base) {
-        super(base);
-        mAttributeId = CalligraphyConfig.get().getAttrId();
-    }
-
-    /**
-     * Override the default AttributeId, this will always take the custom attribute defined here
-     * and ignore the one set in {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}.
-     *
-     * Remember if you are defining default in the
-     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
-     * the activity is created.
-     *
-     * @param base        ContextBase to Wrap
-     * @param attributeId Attribute to lookup.
-     * @deprecated use {@link #wrap(android.content.Context)}
-     */
-    @Deprecated
-    public CalligraphyContextWrapper(Context base, int attributeId) {
-        super(base);
-        mAttributeId = attributeId;
-    }
-
-    @Override
-    public Object getSystemService(String name) {
-        if (LAYOUT_INFLATER_SERVICE.equals(name)) {
-            if (mInflater == null) {
-                mInflater = new CalligraphyLayoutInflater(LayoutInflater.from(getBaseContext()), this, mAttributeId, false);
-            }
-            return mInflater;
-        }
-        return super.getSystemService(name);
-    }
-
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
deleted file mode 100644
index 572763b..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
+++ /dev/null
@@ -1,221 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.graphics.Typeface;
-import android.support.v7.widget.Toolbar;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.TextView;
-
-import java.lang.reflect.Method;
-
-class CalligraphyFactory {
-
-    private static final String ACTION_BAR_TITLE = "action_bar_title";
-    private static final String ACTION_BAR_SUBTITLE = "action_bar_subtitle";
-
-    /**
-     * Some styles are in sub styles, such as actionBarTextStyle etc..
-     *
-     * @param view view to check.
-     * @return 2 element array, default to -1 unless a style has been found.
-     */
-    protected static int[] getStyleForTextView(TextView view) {
-        final int[] styleIds = new int[]{-1, -1};
-        // Try to find the specific actionbar styles
-        if (isActionBarTitle(view)) {
-            styleIds[0] = android.R.attr.actionBarStyle;
-            styleIds[1] = android.R.attr.titleTextStyle;
-        } else if (isActionBarSubTitle(view)) {
-            styleIds[0] = android.R.attr.actionBarStyle;
-            styleIds[1] = android.R.attr.subtitleTextStyle;
-        }
-        if (styleIds[0] == -1) {
-            // Use TextAppearance as default style
-            styleIds[0] = CalligraphyConfig.get().getClassStyles().containsKey(view.getClass())
-                    ? CalligraphyConfig.get().getClassStyles().get(view.getClass())
-                    : android.R.attr.textAppearance;
-        }
-        return styleIds;
-    }
-
-    /**
-     * An even dirtier way to see if the TextView is part of the ActionBar
-     *
-     * @param view TextView to check is Title
-     * @return true if it is.
-     */
-    @SuppressLint("NewApi")
-    protected static boolean isActionBarTitle(TextView view) {
-        if (matchesResourceIdName(view, ACTION_BAR_TITLE)) return true;
-        if (parentIsToolbarV7(view)) {
-            final android.support.v7.widget.Toolbar parent = (android.support.v7.widget.Toolbar) view.getParent();
-            return TextUtils.equals(parent.getTitle(), view.getText());
-        }
-        return false;
-    }
-
-    /**
-     * An even dirtier way to see if the TextView is part of the ActionBar
-     *
-     * @param view TextView to check is Title
-     * @return true if it is.
-     */
-    @SuppressLint("NewApi")
-    protected static boolean isActionBarSubTitle(TextView view) {
-        if (matchesResourceIdName(view, ACTION_BAR_SUBTITLE)) return true;
-        if (parentIsToolbarV7(view)) {
-            final android.support.v7.widget.Toolbar parent = (android.support.v7.widget.Toolbar) view.getParent();
-            return TextUtils.equals(parent.getSubtitle(), view.getText());
-        }
-        return false;
-    }
-
-    protected static boolean parentIsToolbarV7(View view) {
-        return CalligraphyUtils.canCheckForV7Toolbar() && view.getParent() != null && (view.getParent() instanceof android.support.v7.widget.Toolbar);
-    }
-
-    /**
-     * Use to match a view against a potential view id. Such as ActionBar title etc.
-     *
-     * @param view    not null view you want to see has resource matching name.
-     * @param matches not null resource name to match against. Its not case sensitive.
-     * @return true if matches false otherwise.
-     */
-    protected static boolean matchesResourceIdName(View view, String matches) {
-        if (view.getId() == View.NO_ID) return false;
-        final String resourceEntryName = view.getResources().getResourceEntryName(view.getId());
-        return resourceEntryName.equalsIgnoreCase(matches);
-    }
-
-    private final int[] mAttributeId;
-
-    public CalligraphyFactory(int attributeId) {
-        this.mAttributeId = new int[]{attributeId};
-    }
-
-    /**
-     * Handle the created view
-     *
-     * @param view    nullable.
-     * @param context shouldn't be null.
-     * @param attrs   shouldn't be null.
-     * @return null if null is passed in.
-     */
-
-    public View onViewCreated(View view, Context context, AttributeSet attrs) {
-        if (view != null && view.getTag(R.id.calligraphy_tag_id) != Boolean.TRUE) {
-            onViewCreatedInternal(view, context, attrs);
-            view.setTag(R.id.calligraphy_tag_id, Boolean.TRUE);
-        }
-        return view;
-    }
-
-    void onViewCreatedInternal(View view, final Context context, AttributeSet attrs) {
-        if (view instanceof TextView) {
-            // Fast path the setting of TextView's font, means if we do some delayed setting of font,
-            // which has already been set by use we skip this TextView (mainly for inflating custom,
-            // TextView's inside the Toolbar/ActionBar).
-            if (TypefaceUtils.isLoaded(((TextView) view).getTypeface())) {
-                return;
-            }
-            // Try to get typeface attribute value
-            // Since we're not using namespace it's a little bit tricky
-
-            // Check xml attrs, style attrs and text appearance for font path
-            String textViewFont = resolveFontPath(context, attrs);
-
-            // Try theme attributes
-            if (TextUtils.isEmpty(textViewFont)) {
-                final int[] styleForTextView = getStyleForTextView((TextView) view);
-                if (styleForTextView[1] != -1)
-                    textViewFont = CalligraphyUtils.pullFontPathFromTheme(context, styleForTextView[0], styleForTextView[1], mAttributeId);
-                else
-                    textViewFont = CalligraphyUtils.pullFontPathFromTheme(context, styleForTextView[0], mAttributeId);
-            }
-
-            // Still need to defer the Native action bar, appcompat-v7:21+ uses the Toolbar underneath. But won't match these anyway.
-            final boolean deferred = matchesResourceIdName(view, ACTION_BAR_TITLE) || matchesResourceIdName(view, ACTION_BAR_SUBTITLE);
-
-            CalligraphyUtils.applyFontToTextView(context, (TextView) view, CalligraphyConfig.get(), textViewFont, deferred);
-        }
-
-        // AppCompat API21+ The ActionBar doesn't inflate default Title/SubTitle, we need to scan the
-        // Toolbar(Which underlies the ActionBar) for its children.
-        if (CalligraphyUtils.canCheckForV7Toolbar() && view instanceof android.support.v7.widget.Toolbar) {
-            applyFontToToolbar((Toolbar) view);
-        }
-
-        // Try to set typeface for custom views using interface method or via reflection if available
-        if (view instanceof HasTypeface) {
-            Typeface typeface = getDefaultTypeface(context, resolveFontPath(context, attrs));
-            if (typeface != null) {
-                ((HasTypeface) view).setTypeface(typeface);
-            }
-        } else if (CalligraphyConfig.get().isCustomViewTypefaceSupport() && CalligraphyConfig.get().isCustomViewHasTypeface(view)) {
-            final Method setTypeface = ReflectionUtils.getMethod(view.getClass(), "setTypeface");
-            String fontPath = resolveFontPath(context, attrs);
-            Typeface typeface = getDefaultTypeface(context, fontPath);
-            if (setTypeface != null && typeface != null) {
-                ReflectionUtils.invokeMethod(view, setTypeface, typeface);
-            }
-        }
-
-    }
-
-    private Typeface getDefaultTypeface(Context context, String fontPath) {
-        if (TextUtils.isEmpty(fontPath)) {
-            fontPath = CalligraphyConfig.get().getFontPath();
-        }
-        if (!TextUtils.isEmpty(fontPath)) {
-            return TypefaceUtils.load(context.getAssets(), fontPath);
-        }
-        return null;
-    }
-
-    /**
-     * Resolving font path from xml attrs, style attrs or text appearance
-     */
-    private String resolveFontPath(Context context, AttributeSet attrs) {
-        // Try view xml attributes
-        String textViewFont = CalligraphyUtils.pullFontPathFromView(context, attrs, mAttributeId);
-
-        // Try view style attributes
-        if (TextUtils.isEmpty(textViewFont)) {
-            textViewFont = CalligraphyUtils.pullFontPathFromStyle(context, attrs, mAttributeId);
-        }
-
-        // Try View TextAppearance
-        if (TextUtils.isEmpty(textViewFont)) {
-            textViewFont = CalligraphyUtils.pullFontPathFromTextAppearance(context, attrs, mAttributeId);
-        }
-
-        return textViewFont;
-    }
-
-    /**
-     * Will forceably set text on the views then remove ones that didn't have copy.
-     *
-     * @param view toolbar view.
-     */
-    private void applyFontToToolbar(final Toolbar view) {
-        final CharSequence previousTitle = view.getTitle();
-        final CharSequence previousSubtitle = view.getSubtitle();
-        // The toolbar inflates both the title and the subtitle views lazily but luckily they do it
-        // synchronously when you set a title and a subtitle programmatically.
-        // So we set a title and a subtitle to something, then get the views, then revert.
-        view.setTitle(" ");
-        view.setSubtitle(" ");
-
-        // Iterate through the children to run post inflation on them
-        final int childCount = view.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            onViewCreated(view.getChildAt(i), view.getContext(), null);
-        }
-        // Remove views from view if they didn't have copy set.
-        view.setTitle(previousTitle);
-        view.setSubtitle(previousSubtitle);
-    }
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java
deleted file mode 100644
index debdd3e..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.graphics.Paint;
-import android.graphics.Typeface;
-import android.text.TextPaint;
-import android.text.style.MetricAffectingSpan;
-
-public class CalligraphyTypefaceSpan extends MetricAffectingSpan {
-    private final Typeface typeface;
-
-    public CalligraphyTypefaceSpan(final Typeface typeface) {
-        if (typeface == null) {
-            throw new IllegalArgumentException("typeface is null");
-        }
-        
-        this.typeface = typeface;
-    }
-
-    @Override
-    public void updateDrawState(final TextPaint drawState) {
-        apply(drawState);
-    }
-
-    @Override
-    public void updateMeasureState(final TextPaint paint) {
-        apply(paint);
-    }
-
-    private void apply(final Paint paint) {
-        final Typeface oldTypeface = paint.getTypeface();
-        final int oldStyle = oldTypeface != null ? oldTypeface.getStyle() : 0;
-        final int fakeStyle = oldStyle & ~typeface.getStyle();
-
-        if ((fakeStyle & Typeface.BOLD) != 0) {
-            paint.setFakeBoldText(true);
-        }
-
-        if ((fakeStyle & Typeface.ITALIC) != 0) {
-            paint.setTextSkewX(-0.25f);
-        }
-
-        paint.setTypeface(typeface);
-    }
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java
deleted file mode 100644
index ab71cd9..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java
+++ /dev/null
@@ -1,355 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.content.Context;
-import android.content.res.AssetManager;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Paint;
-import android.graphics.Typeface;
-import android.text.Editable;
-import android.text.Spannable;
-import android.text.SpannableString;
-import android.text.Spanned;
-import android.text.TextUtils;
-import android.text.TextWatcher;
-import android.util.AttributeSet;
-import android.util.TypedValue;
-import android.widget.TextView;
-
-/**
- * Created by chris on 20/12/2013
- * Project: Calligraphy
- */
-public final class CalligraphyUtils {
-
-    public static final int[] ANDROID_ATTR_TEXT_APPEARANCE = new int[]{android.R.attr.textAppearance};
-
-    /**
-     * Applies a custom typeface span to the text.
-     *
-     * @param s        text to apply it too.
-     * @param typeface typeface to apply.
-     * @return Either the passed in Object or new Spannable with the typeface span applied.
-     */
-    public static CharSequence applyTypefaceSpan(CharSequence s, Typeface typeface) {
-        if (s != null && s.length() > 0) {
-            if (!(s instanceof Spannable)) {
-                s = new SpannableString(s);
-            }
-            ((Spannable) s).setSpan(TypefaceUtils.getSpan(typeface), 0, s.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-        }
-        return s;
-    }
-
-    /**
-     * Applies a Typeface to a TextView.
-     * Defaults to false for deferring, if you are having issues with the textview keeping
-     * the custom Typeface, use
-     * {@link #applyFontToTextView(android.widget.TextView, android.graphics.Typeface, boolean)}
-     *
-     * @param textView Not null, TextView or child of.
-     * @param typeface Not null, Typeface to apply to the TextView.
-     * @return true if applied otherwise false.
-     * @see #applyFontToTextView(android.widget.TextView, android.graphics.Typeface, boolean)
-     */
-    public static boolean applyFontToTextView(final TextView textView, final Typeface typeface) {
-        return applyFontToTextView(textView, typeface, false);
-    }
-
-    /**
-     * Applies a Typeface to a TextView, if deferred,its recommend you don't call this multiple
-     * times, as this adds a TextWatcher.
-     *
-     * Deferring should really only be used on tricky views which get Typeface set by the system at
-     * weird times.
-     *
-     * @param textView Not null, TextView or child of.
-     * @param typeface Not null, Typeface to apply to the TextView.
-     * @param deferred If true we use Typefaces and TextChange listener to make sure font is always
-     *                 applied, but this sometimes conflicts with other
-     *                 {@link android.text.Spannable}'s.
-     * @return true if applied otherwise false.
-     * @see #applyFontToTextView(android.widget.TextView, android.graphics.Typeface)
-     */
-    public static boolean applyFontToTextView(final TextView textView, final Typeface typeface, boolean deferred) {
-        if (textView == null || typeface == null) return false;
-        textView.setPaintFlags(textView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
-        textView.setTypeface(typeface);
-        if (deferred) {
-            textView.setText(applyTypefaceSpan(textView.getText(), typeface), TextView.BufferType.SPANNABLE);
-            textView.addTextChangedListener(new TextWatcher() {
-                @Override
-                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-                }
-
-                @Override
-                public void onTextChanged(CharSequence s, int start, int before, int count) {
-                }
-
-                @Override
-                public void afterTextChanged(Editable s) {
-                    applyTypefaceSpan(s, typeface);
-                }
-            });
-        }
-        return true;
-    }
-
-    /**
-     * Useful for manually fonts to a TextView. Will not default back to font
-     * set in {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
-     *
-     * @param context  Context
-     * @param textView Not null, TextView to apply to.
-     * @param filePath if null/empty will do nothing.
-     * @return true if fonts been applied
-     */
-    public static boolean applyFontToTextView(final Context context, final TextView textView, final String filePath) {
-        return applyFontToTextView(context, textView, filePath, false);
-    }
-
-    static boolean applyFontToTextView(final Context context, final TextView textView, final String filePath, boolean deferred) {
-        if (textView == null || context == null) return false;
-        final AssetManager assetManager = context.getAssets();
-        final Typeface typeface = TypefaceUtils.load(assetManager, filePath);
-        return applyFontToTextView(textView, typeface, deferred);
-    }
-
-    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config) {
-        applyFontToTextView(context, textView, config, false);
-    }
-
-    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, boolean deferred) {
-        if (context == null || textView == null || config == null) return;
-        if (!config.isFontSet()) return;
-        applyFontToTextView(context, textView, config.getFontPath(), deferred);
-    }
-
-    /**
-     * Applies font to TextView. Will fall back to the default one if not set.
-     *
-     * @param context      context
-     * @param textView     textView to apply to.
-     * @param config       Default Config
-     * @param textViewFont nullable, will use Default Config if null or fails to find the
-     *                     defined font.
-     */
-    public static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, final String textViewFont) {
-        applyFontToTextView(context, textView, config, textViewFont, false);
-    }
-
-    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, final String textViewFont, boolean deferred) {
-        if (context == null || textView == null || config == null) return;
-        if (!TextUtils.isEmpty(textViewFont) && applyFontToTextView(context, textView, textViewFont, deferred)) {
-            return;
-        }
-        applyFontToTextView(context, textView, config, deferred);
-    }
-
-    /**
-     * Tries to pull the Custom Attribute directly from the TextView.
-     *
-     * @param context     Activity Context
-     * @param attrs       View Attributes
-     * @param attributeId if -1 returns null.
-     * @return null if attribute is not defined or added to View
-     */
-    static String pullFontPathFromView(Context context, AttributeSet attrs, int[] attributeId) {
-        if (attributeId == null || attrs == null)
-            return null;
-
-        final String attributeName;
-        try {
-            attributeName = context.getResources().getResourceEntryName(attributeId[0]);
-        } catch (Resources.NotFoundException e) {
-            // invalid attribute ID
-            return null;
-        }
-
-        final int stringResourceId = attrs.getAttributeResourceValue(null, attributeName, -1);
-        return stringResourceId > 0
-                ? context.getString(stringResourceId)
-                : attrs.getAttributeValue(null, attributeName);
-    }
-
-    /**
-     * Tries to pull the Font Path from the View Style as this is the next decendent after being
-     * defined in the View's xml.
-     *
-     * @param context     Activity Activity Context
-     * @param attrs       View Attributes
-     * @param attributeId if -1 returns null.
-     * @return null if attribute is not defined or found in the Style
-     */
-    static String pullFontPathFromStyle(Context context, AttributeSet attrs, int[] attributeId) {
-        if (attributeId == null || attrs == null)
-            return null;
-        final TypedArray typedArray = context.obtainStyledAttributes(attrs, attributeId);
-        if (typedArray != null) {
-            try {
-                // First defined attribute
-                String fontFromAttribute = typedArray.getString(0);
-                if (!TextUtils.isEmpty(fontFromAttribute)) {
-                    return fontFromAttribute;
-                }
-            } catch (Exception ignore) {
-                // Failed for some reason.
-            } finally {
-                typedArray.recycle();
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Tries to pull the Font Path from the Text Appearance.
-     *
-     * @param context     Activity Context
-     * @param attrs       View Attributes
-     * @param attributeId if -1 returns null.
-     * @return returns null if attribute is not defined or if no TextAppearance is found.
-     */
-    static String pullFontPathFromTextAppearance(final Context context, AttributeSet attrs, int[] attributeId) {
-        if (attributeId == null || attrs == null) {
-            return null;
-        }
-
-        int textAppearanceId = -1;
-        final TypedArray typedArrayAttr = context.obtainStyledAttributes(attrs, ANDROID_ATTR_TEXT_APPEARANCE);
-        if (typedArrayAttr != null) {
-            try {
-                textAppearanceId = typedArrayAttr.getResourceId(0, -1);
-            } catch (Exception ignored) {
-                // Failed for some reason
-                return null;
-            } finally {
-                typedArrayAttr.recycle();
-            }
-        }
-
-        final TypedArray textAppearanceAttrs = context.obtainStyledAttributes(textAppearanceId, attributeId);
-        if (textAppearanceAttrs != null) {
-            try {
-                return textAppearanceAttrs.getString(0);
-            } catch (Exception ignore) {
-                // Failed for some reason.
-                return null;
-            } finally {
-                textAppearanceAttrs.recycle();
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Last but not least, try to pull the Font Path from the Theme, which is defined.
-     *
-     * @param context     Activity Context
-     * @param styleAttrId Theme style id
-     * @param attributeId if -1 returns null.
-     * @return null if no theme or attribute defined.
-     */
-    static String pullFontPathFromTheme(Context context, int styleAttrId, int[] attributeId) {
-        if (styleAttrId == -1 || attributeId == null)
-            return null;
-
-        final Resources.Theme theme = context.getTheme();
-        final TypedValue value = new TypedValue();
-
-        theme.resolveAttribute(styleAttrId, value, true);
-        final TypedArray typedArray = theme.obtainStyledAttributes(value.resourceId, attributeId);
-        try {
-            String font = typedArray.getString(0);
-            return font;
-        } catch (Exception ignore) {
-            // Failed for some reason.
-            return null;
-        } finally {
-            typedArray.recycle();
-        }
-    }
-
-    /**
-     * Last but not least, try to pull the Font Path from the Theme, which is defined.
-     *
-     * @param context        Activity Context
-     * @param styleAttrId    Theme style id
-     * @param subStyleAttrId the sub style from the theme to look up after the first style
-     * @param attributeId    if -1 returns null.
-     * @return null if no theme or attribute defined.
-     */
-    static String pullFontPathFromTheme(Context context, int styleAttrId, int subStyleAttrId, int[] attributeId) {
-        if (styleAttrId == -1 || attributeId == null)
-            return null;
-
-        final Resources.Theme theme = context.getTheme();
-        final TypedValue value = new TypedValue();
-
-        theme.resolveAttribute(styleAttrId, value, true);
-        int subStyleResId = -1;
-        final TypedArray parentTypedArray = theme.obtainStyledAttributes(value.resourceId, new int[]{subStyleAttrId});
-        try {
-            subStyleResId = parentTypedArray.getResourceId(0, -1);
-        } catch (Exception ignore) {
-            // Failed for some reason.
-            return null;
-        } finally {
-            parentTypedArray.recycle();
-        }
-
-        if (subStyleResId == -1) return null;
-        final TypedArray subTypedArray = context.obtainStyledAttributes(subStyleResId, attributeId);
-        if (subTypedArray != null) {
-            try {
-                return subTypedArray.getString(0);
-            } catch (Exception ignore) {
-                // Failed for some reason.
-                return null;
-            } finally {
-                subTypedArray.recycle();
-            }
-        }
-        return null;
-    }
-
-    private static Boolean sToolbarCheck = null;
-    private static Boolean sAppCompatViewCheck = null;
-
-    /**
-     * See if the user has added appcompat-v7, this is done at runtime, so we only check once.
-     *
-     * @return true if the v7.Toolbar is on the classpath
-     */
-    static boolean canCheckForV7Toolbar() {
-        if (sToolbarCheck == null) {
-            try {
-                Class.forName("android.support.v7.widget.Toolbar");
-                sToolbarCheck = Boolean.TRUE;
-            } catch (ClassNotFoundException e) {
-                sToolbarCheck = Boolean.FALSE;
-            }
-        }
-        return sToolbarCheck;
-    }
-
-    /**
-     * See if the user has added appcompat-v7 with AppCompatViews
-     *
-     * @return true if AppcompatTextView is on the classpath
-     */
-    static boolean canAddV7AppCompatViews() {
-        if (sAppCompatViewCheck == null) {
-            try {
-                Class.forName("android.support.v7.widget.AppCompatTextView");
-                sAppCompatViewCheck = Boolean.TRUE;
-            } catch (ClassNotFoundException e) {
-                sAppCompatViewCheck = Boolean.FALSE;
-            }
-        }
-        return sAppCompatViewCheck;
-    }
-
-    private CalligraphyUtils() {
-    }
-
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/HasTypeface.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/HasTypeface.java
deleted file mode 100644
index 48950f9..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/HasTypeface.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.graphics.Typeface;
-
-/**
- * There are two ways to set typeface for custom views:
- * <ul>
- *     <li>Implementing this interface. You should only implements {@link #setTypeface(Typeface)} method.</li>
- *     <li>Or via reflection. If custom view already has setTypeface method you can
- *     register it during Calligraphy configuration
- *     {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder#addCustomViewWithSetTypeface(Class)}</li>
- * </ul>
- * First way is faster but encourage more effort from the developer to implements interface. Second one
- * requires less effort but works slowly cause reflection calls.
- *
- * @author Dmitriy Tarasov
- */
-public interface HasTypeface {
-
-    void setTypeface(Typeface typeface);
-
-}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/TypefaceUtils.java b/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/TypefaceUtils.java
deleted file mode 100644
index 8ad3a8c..0000000
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/TypefaceUtils.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package uk.co.chrisjenx.calligraphy;
-
-import android.content.res.AssetManager;
-import android.graphics.Typeface;
-import android.util.Log;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A helper loading {@link android.graphics.Typeface} avoiding the leak of the font when loaded
- * by multiple calls to {@link android.graphics.Typeface#createFromAsset(android.content.res.AssetManager, String)}
- * on pre-ICS versions.
- * <p>
- * More details can be found here https://code.google.com/p/android/issues/detail?id=9904
- * <p>
- * Created by Chris Jenkins on 04/09/13.
- */
-public final class TypefaceUtils {
-
-    private static final Map<String, Typeface> sCachedFonts = new HashMap<String, Typeface>();
-    private static final Map<Typeface, CalligraphyTypefaceSpan> sCachedSpans = new HashMap<Typeface, CalligraphyTypefaceSpan>();
-
-    /**
-     * A helper loading a custom font.
-     *
-     * @param assetManager App's asset manager.
-     * @param filePath     The path of the file.
-     * @return Return {@link android.graphics.Typeface} or null if the path is invalid.
-     */
-    public static Typeface load(final AssetManager assetManager, final String filePath) {
-        synchronized (sCachedFonts) {
-            try {
-                if (!sCachedFonts.containsKey(filePath)) {
-                    final Typeface typeface = Typeface.createFromAsset(assetManager, filePath);
-                    sCachedFonts.put(filePath, typeface);
-                    return typeface;
-                }
-            } catch (Exception e) {
-                Log.w("Calligraphy", "Can't create asset from " + filePath + ". Make sure you have passed in the correct path and file name.", e);
-                sCachedFonts.put(filePath, null);
-                return null;
-            }
-            return sCachedFonts.get(filePath);
-        }
-    }
-
-    /**
-     * A helper loading custom spans so we don't have to keep creating hundreds of spans.
-     *
-     * @param typeface not null typeface
-     * @return will return null of typeface passed in is null.
-     */
-    public static CalligraphyTypefaceSpan getSpan(final Typeface typeface) {
-        if (typeface == null) return null;
-        synchronized (sCachedSpans) {
-            if (!sCachedSpans.containsKey(typeface)) {
-                final CalligraphyTypefaceSpan span = new CalligraphyTypefaceSpan(typeface);
-                sCachedSpans.put(typeface, span);
-                return span;
-            }
-            return sCachedSpans.get(typeface);
-        }
-    }
-
-    /**
-     * Is the passed in typeface one of ours?
-     *
-     * @param typeface nullable, the typeface to check if ours.
-     * @return true if we have loaded it false otherwise.
-     */
-    public static boolean isLoaded(Typeface typeface) {
-        return typeface != null && sCachedFonts.containsValue(typeface);
-    }
-
-    private TypefaceUtils() {
-    }
-}
diff --git a/calligraphy/src/main/res/values/attrs.xml b/calligraphy/src/main/res/values/attrs.xml
deleted file mode 100644
index 02c6672..0000000
--- a/calligraphy/src/main/res/values/attrs.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <attr name="fontPath" format="string"/>
-</resources>
\ No newline at end of file
diff --git a/calligraphy/.gitignore b/colorography/.gitignore
similarity index 100%
rename from calligraphy/.gitignore
rename to colorography/.gitignore
diff --git a/calligraphy/build.gradle b/colorography/build.gradle
similarity index 70%
rename from calligraphy/build.gradle
rename to colorography/build.gradle
index 54e17a0..0aa8d2f 100644
--- a/calligraphy/build.gradle
+++ b/colorography/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.library'
-apply from: rootProject.file('gradle/deploy.gradle')
 
 android {
     compileSdkVersion project.compileSdkVersion
@@ -23,4 +22,9 @@ android {
 
 dependencies {
     compile "com.android.support:appcompat-v7:${supportLibraryVersion}"
+    compile "com.android.support:design:${supportLibraryVersion}"
+    compile "com.android.support:cardview-v7:${supportLibraryVersion}"
 }
+
+//apply from: rootProject.file('gradle/deploy.gradle')
+apply from: 'https://raw.github.com/chrisbanes/gradle-mvn-push/master/gradle-mvn-push.gradle'
diff --git a/colorography/consumer-proguard-rules.txt b/colorography/consumer-proguard-rules.txt
new file mode 100644
index 0000000..3577cbf
--- /dev/null
+++ b/colorography/consumer-proguard-rules.txt
@@ -0,0 +1,3 @@
+-keep class com.ftinc.colorography.* { *; }
+-keep class com.ftinc.colorography.*$* { *; }
+
diff --git a/calligraphy/gradle.properties b/colorography/gradle.properties
similarity index 55%
rename from calligraphy/gradle.properties
rename to colorography/gradle.properties
index 9e72cf6..3857360 100644
--- a/calligraphy/gradle.properties
+++ b/colorography/gradle.properties
@@ -1,6 +1,6 @@
 # SubProject Library Gradle Properties
 # See parent properties for global properties
 
-POM_NAME=Calligraphy
-POM_ARTIFACT_ID=calligraphy
+POM_NAME=Colorography
+POM_ARTIFACT_ID=colorography
 POM_PACKAGING=aar
\ No newline at end of file
diff --git a/calligraphy/src/main/AndroidManifest.xml b/colorography/src/main/AndroidManifest.xml
similarity index 70%
rename from calligraphy/src/main/AndroidManifest.xml
rename to colorography/src/main/AndroidManifest.xml
index 921769e..61d8c73 100644
--- a/calligraphy/src/main/AndroidManifest.xml
+++ b/colorography/src/main/AndroidManifest.xml
@@ -1,4 +1,4 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="uk.co.chrisjenx.calligraphy">
+    package="com.ftinc.colorography">
     <application />
 </manifest>
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyActivityFactory.java
similarity index 94%
rename from calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
rename to colorography/src/main/java/com/ftinc/colorography/ColorographyActivityFactory.java
index e0214eb..821a941 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyActivityFactory.java
@@ -1,4 +1,4 @@
-package uk.co.chrisjenx.calligraphy;
+package com.ftinc.colorography;
 
 import android.content.Context;
 import android.util.AttributeSet;
@@ -8,7 +8,7 @@
  * Created by chris on 09/11/14.
  * For Calligraphy.
  */
-interface CalligraphyActivityFactory {
+interface ColorographyActivityFactory {
 
     /**
      * Used to Wrap the Activity onCreateView method.
diff --git a/colorography/src/main/java/com/ftinc/colorography/ColorographyConfig.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyConfig.java
new file mode 100644
index 0000000..d4f0bf9
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyConfig.java
@@ -0,0 +1,145 @@
+package com.ftinc.colorography;
+
+import android.widget.TextView;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * Created by chris on 20/12/2013
+ * Project: Calligraphy
+ */
+public class ColorographyConfig {
+
+
+    private static ColorographyConfig sInstance;
+
+    /**
+     * Set the default Calligraphy Config
+     *
+     * @param calligraphyConfig the config build using the builder.
+     * @see ColorographyConfig.Builder
+     */
+    public static void initDefault(ColorographyConfig calligraphyConfig) {
+        sInstance = calligraphyConfig;
+    }
+
+    /**
+     * The current Calligraphy Config.
+     * If not set it will create a default config.
+     */
+    public static ColorographyConfig get() {
+        if (sInstance == null)
+            sInstance = new ColorographyConfig(new Builder());
+        return sInstance;
+    }
+
+    /**
+     * Default Font Path Attr Id to lookup
+     */
+    private final int mAttrId;
+
+    /**
+     * Use Reflection to intercept CustomView inflation with the correct Context.
+     */
+    private final boolean mCustomViewCreation;
+
+
+    protected ColorographyConfig(Builder builder) {
+        mAttrId = builder.attrId;
+        mCustomViewCreation = builder.customViewCreation;
+    }
+
+
+    public boolean isCustomViewCreation() {
+        return mCustomViewCreation;
+    }
+
+
+    /**
+     * @return the custom attrId to look for, -1 if not set.
+     */
+    public int getAttrId() {
+        return mAttrId;
+    }
+
+
+    public static class Builder {
+        public static final int INVALID_ATTR_ID = -1;
+        private boolean customViewCreation = true;
+        private int attrId = R.attr.fontPath;
+
+        private Map<Class<? extends TextView>, Integer> mStyleClassMap = new HashMap<>();
+        private Set<Class<?>> mHasTypefaceClasses = new HashSet<>();
+
+        /**
+         * This defaults to R.attr.fontPath. So only override if you want to use your own attrId.
+         *
+         * @param themeColorAttrId the custom attribute to look for color theming and the default color
+         * @return this builder.
+         */
+        public Builder setThemeColorAttrId(int themeColorAttrId) {
+            this.attrId = themeColorAttrId;
+            return this;
+        }
+
+
+        /**
+         * Due to the poor inflation order where custom views are created and never returned inside an
+         * {@code onCreateView(...)} method. We have to create CustomView's at the latest point in the
+         * overrideable injection flow.
+         *
+         * On HoneyComb+ this is inside the {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * Pre HoneyComb this is in the {@link android.view.LayoutInflater.Factory#onCreateView(String, android.util.AttributeSet)}
+         *
+         * We wrap base implementations, so if you LayoutInflater/Factory/Activity creates the
+         * custom view before we get to this point, your view is used. (Such is the case with the
+         * TintEditText etc)
+         *
+         * The problem is, the native methods pass there parents context to the constructor in a really
+         * specific place. We have to mimic this in {@link ColorographyLayoutInflater#createCustomViewInternal(android.view.View, android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * To mimic this we have to use reflection as the Class constructor args are hidden to us.
+         *
+         * We have discussed other means of doing this but this is the only semi-clean way of doing it.
+         * (Without having to do proxy classes etc).
+         *
+         * Calling this will of course speed up inflation by turning off reflection, but not by much,
+         * But if you want Calligraphy to inject the correct typeface then you will need to make sure your CustomView's
+         * are created before reaching the LayoutInflater onViewCreated.
+         */
+        public Builder disableCustomViewInflation() {
+            this.customViewCreation = false;
+            return this;
+        }
+
+        /**
+         * Add a custom style to get looked up. If you use a custom class that has a parent style
+         * which is not part of the default android styles you will need to add it here.
+         *
+         * The Calligraphy inflater is unaware of custom styles in your custom classes. We use
+         * the class type to look up the style attribute in the theme resources.
+         *
+         * So if you had a {@code MyTextField.class} which looked up it's default style as
+         * {@code R.attr.textFieldStyle} you would add those here.
+         *
+         * {@code builder.addCustomStyle(MyTextField.class,R.attr.textFieldStyle}
+         *
+         * @param styleClass             the class that related to the parent styleResource. null is ignored.
+         * @param styleResourceAttribute e.g. {@code R.attr.textFieldStyle}, 0 is ignored.
+         * @return this builder.
+         */
+        public Builder addCustomStyle(final Class<? extends TextView> styleClass, final int styleResourceAttribute) {
+            if (styleClass == null || styleResourceAttribute == 0) return this;
+            mStyleClassMap.put(styleClass, styleResourceAttribute);
+            return this;
+        }
+
+
+        public ColorographyConfig build() {
+            return new ColorographyConfig(this);
+        }
+    }
+}
diff --git a/colorography/src/main/java/com/ftinc/colorography/ColorographyContextWrapper.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyContextWrapper.java
new file mode 100644
index 0000000..dbdc23b
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyContextWrapper.java
@@ -0,0 +1,93 @@
+package com.ftinc.colorography;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+
+/**
+ * Created by chris on 19/12/2013
+ * Project: Calligraphy
+ */
+public class ColorographyContextWrapper extends ContextWrapper {
+
+    private ColorographyLayoutInflater mInflater;
+
+    private final int mAttributeId;
+    private final ThemeColorProvider mThemeColorProvider;
+
+    /**
+     * Uses the default configuration from {@link ColorographyConfig}
+     *
+     * Remember if you are defining default in the
+     * {@link ColorographyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap.
+     * @return ContextWrapper to pass back to the activity.
+     */
+    public static ContextWrapper wrap(Context base, ThemeColorProvider colorProvider) {
+        return new ColorographyContextWrapper(base, colorProvider);
+    }
+
+
+    /**
+     * Get the Calligraphy Activity Fragment Instance to allow callbacks for when views are created.
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @return Interface allowing you to call onActivityViewCreated
+     */
+    static ColorographyActivityFactory get(Activity activity) {
+        if (!(activity.getLayoutInflater() instanceof ColorographyLayoutInflater)) {
+            throw new RuntimeException("This activity does not wrap the Base Context! See CalligraphyContextWrapper.wrap(Context)");
+        }
+        return (ColorographyActivityFactory) activity.getLayoutInflater();
+    }
+
+    /**
+     * Uses the default configuration from {@link ColorographyConfig}
+     *
+     * Remember if you are defining default in the
+     * {@link ColorographyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap
+     */
+    ColorographyContextWrapper(Context base, ThemeColorProvider colorProvider) {
+        super(base);
+        mAttributeId = ColorographyConfig.get().getAttrId();
+        mThemeColorProvider = colorProvider;
+    }
+
+    /**
+     * Override the default AttributeId, this will always take the custom attribute defined here
+     * and ignore the one set in {@link ColorographyConfig}.
+     *
+     * Remember if you are defining default in the
+     * {@link ColorographyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base        ContextBase to Wrap
+     * @param attributeId Attribute to lookup.
+     */
+    public ColorographyContextWrapper(Context base, int attributeId, ThemeColorProvider colorProvider) {
+        super(base);
+        mAttributeId = attributeId;
+        mThemeColorProvider = colorProvider;
+    }
+
+
+    @Override
+    public Object getSystemService(String name) {
+        if (LAYOUT_INFLATER_SERVICE.equals(name)) {
+            if (mInflater == null) {
+                mInflater = new ColorographyLayoutInflater(LayoutInflater.from(getBaseContext()), this, mAttributeId, mThemeColorProvider.getThemeColor(), false);
+            }
+            return mInflater;
+        }
+        return super.getSystemService(name);
+    }
+
+}
diff --git a/colorography/src/main/java/com/ftinc/colorography/ColorographyFactory.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyFactory.java
new file mode 100644
index 0000000..0e98e08
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyFactory.java
@@ -0,0 +1,385 @@
+package com.ftinc.colorography;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.graphics.Color;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.ColorInt;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.design.widget.CollapsingToolbarLayout;
+import android.support.design.widget.FloatingActionButton;
+import android.support.v4.content.ContextCompat;
+import android.support.v4.graphics.ColorUtils;
+import android.support.v4.graphics.drawable.DrawableCompat;
+import android.support.v4.view.ViewCompat;
+import android.support.v7.widget.AppCompatButton;
+import android.support.v7.widget.AppCompatCheckBox;
+import android.support.v7.widget.AppCompatEditText;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.SwitchCompat;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import java.lang.reflect.Field;
+
+
+class ColorographyFactory {
+
+    private static final ThreadLocal<TypedValue> TL_TYPED_VALUE = new ThreadLocal<>();
+    static final int[] DISABLED_STATE_SET = new int[]{-android.R.attr.state_enabled};
+    static final int[] FOCUSED_STATE_SET = new int[]{android.R.attr.state_focused};
+    static final int[] PRESSED_STATE_SET = new int[]{android.R.attr.state_pressed};
+    static final int[] CHECKED_STATE_SET = new int[]{android.R.attr.state_checked};
+    static final int[] UNPRESSED_UNFOCUSED_STATE_SET = new int[]{-android.R.attr.state_focused,-android.R.attr.state_pressed};
+    static final int[] EMPTY_STATE_SET = new int[0];
+    private static final int[] TEMP_ARRAY = new int[1];
+
+    /**
+     * Use to match a view against a potential view id. Such as ActionBar title etc.
+     *
+     * @param view    not null view you want to see has resource matching name.
+     * @param matches not null resource name to match against. Its not case sensitive.
+     * @return true if matches false otherwise.
+     */
+    protected static boolean matchesResourceIdName(View view, String matches) {
+        if (view.getId() == View.NO_ID) return false;
+        final String resourceEntryName = view.getResources().getResourceEntryName(view.getId());
+        return resourceEntryName.equalsIgnoreCase(matches);
+    }
+
+    private final int[] mAttributeId;
+    private final int mThemeColor;
+
+
+    public ColorographyFactory(int attributeId, int themeColor) {
+        this.mAttributeId = new int[]{attributeId};
+        this.mThemeColor = themeColor;
+    }
+
+
+    public View onViewCreated(View view, Context context, AttributeSet attrs) {
+        if (view != null && view.getTag(R.id.calligraphy_tag_id) != Boolean.TRUE) {
+            onViewCreatedInternal(view, context, attrs);
+            view.setTag(R.id.calligraphy_tag_id, Boolean.TRUE);
+        }
+        return view;
+    }
+
+
+    void onViewCreatedInternal(View view, final Context context, AttributeSet attrs) {
+        int defaultColor = resolveDefaultColor(context, attrs);
+        if (defaultColor != -1) {
+            int themeColor = mThemeColor == -1 ? defaultColor : mThemeColor;
+            if (view instanceof FloatingActionButton) {
+                FloatingActionButton fab = (FloatingActionButton) view;
+                fab.setBackgroundTintList(ColorStateList.valueOf(themeColor));
+            }
+            else if (view instanceof CollapsingToolbarLayout) {
+                CollapsingToolbarLayout ctl = (CollapsingToolbarLayout) view;
+                ctl.setContentScrimColor(themeColor);
+            }
+            else if (view instanceof AppCompatButton) {
+                AppCompatButton button = (AppCompatButton) view;
+                ColorStateList originalTintList = ViewCompat.getBackgroundTintList(button);
+                ColorStateList csl = createButtonColorStateList(context, themeColor, originalTintList);
+                ViewCompat.setBackgroundTintList(button, csl);
+            }
+            else if (view instanceof AppCompatEditText) {
+                AppCompatEditText editText = (AppCompatEditText) view;
+                ColorStateList csl = createEditTextColorStateList(context, themeColor);
+                ViewCompat.setBackgroundTintList(editText, csl);
+                editText.setHighlightColor(themeColor);
+                setCursorColor(editText, themeColor);
+            }
+            else if (view instanceof AppCompatCheckBox) {
+                AppCompatCheckBox checkBox = (AppCompatCheckBox) view;
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                    checkBox.setButtonTintList(createCheckboxColorStateList(context, themeColor));
+                }
+                else {
+                    checkBox.setSupportButtonTintList(createCheckboxColorStateList(context, themeColor));
+                }
+            }
+            else if (view instanceof SwitchCompat) {
+                SwitchCompat sw = (SwitchCompat) view;
+                sw.setThumbTintList(createSwitchThumbColorStateList(context, themeColor));
+                sw.setTrackTintList(createSwitchTrackColorStateList(context, themeColor));
+            }
+            else if (view instanceof TextView) {
+                TextView textView = (TextView) view;
+                textView.setTextColor(themeColor);
+                Drawable[] drawables = textView.getCompoundDrawablesRelative();
+                for (int i = 0; i < drawables.length; i++) {
+                    tintDrawable(drawables[i], themeColor);
+                }
+                textView.setCompoundDrawablesRelativeWithIntrinsicBounds(drawables[0], drawables[1], drawables[2], drawables[3]);
+            }
+            else if (view instanceof CardView) {
+                CardView cardView = (CardView) view;
+                cardView.setCardBackgroundColor(themeColor);
+            }
+            else if (view instanceof ProgressBar) {
+                ProgressBar progressBar = (ProgressBar) view;
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                    progressBar.setIndeterminateTintList(ColorStateList.valueOf(themeColor));
+                }
+                else {
+                    progressBar.getIndeterminateDrawable().setColorFilter(themeColor, PorterDuff.Mode.SRC_ATOP);
+                }
+            }
+            else {
+                view.setBackgroundColor(themeColor);
+            }
+        }
+    }
+
+
+    private ColorStateList createCheckboxColorStateList(@NonNull final Context context,
+                                                        @ColorInt final int baseColor) {
+        final int[][] states = new int[3][];
+        final int[] colors = new int[3];
+        int i = 0;
+
+        final int colorSwitchThumbNormal = getThemeAttrColor(context, R.attr.colorControlNormal);
+        final int disabledColor = getDisabledThemeAttrColor(context, R.attr.colorButtonNormal);
+
+        states[i] = DISABLED_STATE_SET;
+        colors[i] = disabledColor;
+        i++;
+
+        states[i] = CHECKED_STATE_SET;
+        colors[i] = baseColor;
+        i++;
+
+        states[i] = EMPTY_STATE_SET;
+        colors[i] = colorSwitchThumbNormal;
+        i++;
+
+        return new ColorStateList(states, colors);
+    }
+
+
+    private ColorStateList createSwitchThumbColorStateList(@NonNull final Context context,
+                                                           @ColorInt final int baseColor) {
+        final int[][] states = new int[3][];
+        final int[] colors = new int[3];
+        int i = 0;
+
+        final int colorSwitchThumbNormal = getThemeAttrColor(context, R.attr.colorSwitchThumbNormal);
+        final int disabledColor = getDisabledThemeAttrColor(context, R.attr.colorButtonNormal);
+
+        states[i] = DISABLED_STATE_SET;
+        colors[i] = disabledColor;
+        i++;
+
+        states[i] = CHECKED_STATE_SET;
+        colors[i] = baseColor;
+        i++;
+
+        states[i] = EMPTY_STATE_SET;
+        colors[i] = colorSwitchThumbNormal;
+        i++;
+
+        return new ColorStateList(states, colors);
+    }
+
+
+    private ColorStateList createSwitchTrackColorStateList(@NonNull final Context context,
+                                                           @ColorInt final int baseColor) {
+        final int[][] states = new int[3][];
+        final int[] colors = new int[3];
+        int i = 0;
+
+        final int foregroundColor = getThemeAttrColor(context, android.R.attr.colorForeground);
+        final int disabledColor = ColorUtils.setAlphaComponent(foregroundColor , (int)(.1f * 255));
+        final int checkedColor = ColorUtils.setAlphaComponent(baseColor, (int)(.3f * 255));
+        final int emptyColor = ColorUtils.setAlphaComponent(foregroundColor, (int)(.3f * 255));
+
+        states[i] = DISABLED_STATE_SET;
+        colors[i] = disabledColor;
+        i++;
+
+        states[i] = CHECKED_STATE_SET;
+        colors[i] = checkedColor;
+        i++;
+
+        states[i] = EMPTY_STATE_SET;
+        colors[i] = emptyColor;
+        i++;
+
+        return new ColorStateList(states, colors);
+    }
+
+
+    private ColorStateList createEditTextColorStateList(@NonNull final Context context,
+                                                        @ColorInt final int baseColor) {
+        final int[][] states = new int[3][];
+        final int[] colors = new int[3];
+        int i = 0;
+
+        final int colorControlNormal = getThemeAttrColor(context, R.attr.colorControlNormal);
+        final int disabledColor = getDisabledThemeAttrColor(context, R.attr.colorButtonNormal);
+
+        states[i] = DISABLED_STATE_SET;
+        colors[i] = disabledColor;
+        i++;
+
+        states[i] = UNPRESSED_UNFOCUSED_STATE_SET;
+        colors[i] = colorControlNormal;
+        i++;
+
+        states[i] = EMPTY_STATE_SET;
+        colors[i] = baseColor;
+        i++;
+
+        return new ColorStateList(states, colors);
+    }
+
+
+    private ColorStateList createButtonColorStateList(@NonNull final Context context,
+                                                      @ColorInt final int baseColor,
+                                                      @Nullable final ColorStateList tint) {
+        final int[][] states = new int[4][];
+        final int[] colors = new int[4];
+        int i = 0;
+
+        final int colorControlHighlight = getThemeAttrColor(context, R.attr.colorControlHighlight);
+        final int disabledColor = getDisabledThemeAttrColor(context, R.attr.colorButtonNormal);
+
+        // Disabled state
+        states[i] = DISABLED_STATE_SET;
+        colors[i] = tint == null ? disabledColor : tint.getColorForState(states[i], 0);
+        i++;
+
+        states[i] = PRESSED_STATE_SET;
+        colors[i] = ColorUtils.compositeColors(colorControlHighlight,
+                tint == null ? baseColor : tint.getColorForState(states[i], 0));
+        i++;
+
+        states[i] = FOCUSED_STATE_SET;
+        colors[i] = ColorUtils.compositeColors(colorControlHighlight,
+                tint == null ? baseColor : tint.getColorForState(states[i], 0));
+        i++;
+
+        // Default enabled state
+        states[i] = EMPTY_STATE_SET;
+        colors[i] = tint == null ? baseColor : tint.getColorForState(states[i], 0);
+        i++;
+
+        return new ColorStateList(states, colors);
+    }
+
+
+    public static int getThemeAttrColor(Context context, int attr) {
+        TEMP_ARRAY[0] = attr;
+        TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, null, TEMP_ARRAY);
+        try {
+            return a.getColor(0, 0);
+        } finally {
+            a.recycle();
+        }
+    }
+
+
+    public static float getThemeAttrAlpha(Context context, int attr) {
+        TEMP_ARRAY[0] = attr;
+        TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, null, TEMP_ARRAY);
+        try {
+            return a.getFloat(0, 1f);
+        } finally {
+            a.recycle();
+        }
+    }
+
+
+    public static ColorStateList getThemeAttrColorStateList(Context context, int attr) {
+        TEMP_ARRAY[0] = attr;
+        TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, null, TEMP_ARRAY);
+        try {
+            return a.getColorStateList(0);
+        } finally {
+            a.recycle();
+        }
+    }
+
+
+    public static int getDisabledThemeAttrColor(Context context, int attr) {
+        final ColorStateList csl = getThemeAttrColorStateList(context, attr);
+        if (csl != null && csl.isStateful()) {
+            // If the CSL is stateful, we'll assume it has a disabled state and use it
+            return csl.getColorForState(DISABLED_STATE_SET, csl.getDefaultColor());
+        } else {
+            // Else, we'll generate the color using disabledAlpha from the theme
+
+            final TypedValue tv = getTypedValue();
+            // Now retrieve the disabledAlpha value from the theme
+            context.getTheme().resolveAttribute(android.R.attr.disabledAlpha, tv, true);
+            final float disabledAlpha = tv.getFloat();
+
+            return getThemeAttrColor(context, attr, disabledAlpha);
+        }
+    }
+
+
+    private static TypedValue getTypedValue() {
+        TypedValue typedValue = TL_TYPED_VALUE.get();
+        if (typedValue == null) {
+            typedValue = new TypedValue();
+            TL_TYPED_VALUE.set(typedValue);
+        }
+        return typedValue;
+    }
+
+
+    static int getThemeAttrColor(Context context, int attr, float alpha) {
+        final int color = getThemeAttrColor(context, attr);
+        final int originalAlpha = Color.alpha(color);
+        return ColorUtils.setAlphaComponent(color, Math.round(originalAlpha * alpha));
+    }
+
+
+    @ColorInt
+    private int resolveDefaultColor(Context context, AttributeSet attrs) {
+        return ColorographyUtils.pullDefaultColorFromView(context, attrs, mAttributeId);
+    }
+
+    private static void setCursorColor(EditText view, @ColorInt int color) {
+        try {
+            // Get the cursor resource id
+            Field field = TextView.class.getDeclaredField("mCursorDrawableRes");
+            field.setAccessible(true);
+            int drawableResId = field.getInt(view);
+
+            // Get the editor
+            field = TextView.class.getDeclaredField("mEditor");
+            field.setAccessible(true);
+            Object editor = field.get(view);
+
+            // Get the drawable and set a color filter
+            Drawable drawable = ContextCompat.getDrawable(view.getContext(), drawableResId);
+            drawable.setColorFilter(color, PorterDuff.Mode.SRC_IN);
+            Drawable[] drawables = {drawable, drawable};
+
+            // Set the drawables
+            field = editor.getClass().getDeclaredField("mCursorDrawable");
+            field.setAccessible(true);
+            field.set(editor, drawables);
+        } catch (Exception ignored) {
+        }
+    }
+
+
+    private static void tintDrawable(@Nullable Drawable drawable, @ColorInt int color) {
+        if (drawable != null) {
+            drawable = DrawableCompat.wrap(drawable);
+            DrawableCompat.setTint(drawable, color);
+        }
+    }
+}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyLayoutInflater.java
similarity index 81%
rename from calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
rename to colorography/src/main/java/com/ftinc/colorography/ColorographyLayoutInflater.java
index 6f9cfc1..001ee30 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyLayoutInflater.java
@@ -1,4 +1,4 @@
-package uk.co.chrisjenx.calligraphy;
+package com.ftinc.colorography;
 
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -17,36 +17,43 @@
  * Created by chris on 19/12/2013
  * Project: Calligraphy
  */
-class CalligraphyLayoutInflater extends LayoutInflater implements CalligraphyActivityFactory {
+class ColorographyLayoutInflater extends LayoutInflater implements ColorographyActivityFactory {
 
     private static final String[] sClassPrefixList = {
             "android.widget.",
             "android.webkit."
     };
 
+
     private final int mAttributeId;
-    private final CalligraphyFactory mCalligraphyFactory;
+    private final int mThemeColor;
+    private final ColorographyFactory mCalligraphyFactory;
     // Reflection Hax
     private boolean mSetPrivateFactory = false;
     private Field mConstructorArgs = null;
 
-    protected CalligraphyLayoutInflater(Context context, int attributeId) {
+
+    protected ColorographyLayoutInflater(Context context, int attributeId, int themeColor) {
         super(context);
         mAttributeId = attributeId;
-        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        mThemeColor = themeColor;
+        mCalligraphyFactory = new ColorographyFactory(attributeId, themeColor);
         setUpLayoutFactories(false);
     }
 
-    protected CalligraphyLayoutInflater(LayoutInflater original, Context newContext, int attributeId, final boolean cloned) {
+
+    protected ColorographyLayoutInflater(LayoutInflater original, Context newContext, int attributeId, int themeColor, final boolean cloned) {
         super(original, newContext);
         mAttributeId = attributeId;
-        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        mThemeColor = themeColor;
+        mCalligraphyFactory = new ColorographyFactory(attributeId, themeColor);
         setUpLayoutFactories(cloned);
     }
 
+
     @Override
     public LayoutInflater cloneInContext(Context newContext) {
-        return new CalligraphyLayoutInflater(this, newContext, mAttributeId, true);
+        return new ColorographyLayoutInflater(this, newContext, mAttributeId, mThemeColor, true);
     }
 
     // ===
@@ -66,16 +73,11 @@ public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)
      */
     private void setUpLayoutFactories(boolean cloned) {
         if (cloned) return;
+
         // If we are HC+ we get and set Factory2 otherwise we just wrap Factory1
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            if (getFactory2() != null && !(getFactory2() instanceof WrapperFactory2)) {
-                // Sets both Factory/Factory2
-                setFactory2(getFactory2());
-            }
-        }
-        // We can do this as setFactory2 is used for both methods.
-        if (getFactory() != null && !(getFactory() instanceof WrapperFactory)) {
-            setFactory(getFactory());
+        if (getFactory2() != null && !(getFactory2() instanceof WrapperFactory2)) {
+            // Sets both Factory/Factory2
+            setFactory2(getFactory2());
         }
     }
 
@@ -83,7 +85,7 @@ private void setUpLayoutFactories(boolean cloned) {
     public void setFactory(Factory factory) {
         // Only set our factory and wrap calls to the Factory trying to be set!
         if (!(factory instanceof WrapperFactory)) {
-            super.setFactory(new WrapperFactory(factory, this, mCalligraphyFactory));
+            super.setFactory(new WrapperFactory(factory, mCalligraphyFactory));
         } else {
             super.setFactory(factory);
         }
@@ -104,8 +106,7 @@ public void setFactory2(Factory2 factory2) {
     private void setPrivateFactoryInternal() {
         // Already tried to set the factory.
         if (mSetPrivateFactory) return;
-        // Reflection (Or Old Device) skip.
-        if (!CalligraphyConfig.get().isReflection()) return;
+
         // Skip if not attached to an activity.
         if (!(getContext() instanceof Factory2)) {
             mSetPrivateFactory = true;
@@ -195,7 +196,7 @@ private View createCustomViewInternal(View parent, View view, String name, Conte
         // significant difference to performance on Android 4.0+.
 
         // If CustomViewCreation is off skip this.
-        if (!CalligraphyConfig.get().isCustomViewCreation()) return view;
+        if (!ColorographyConfig.get().isCustomViewCreation()) return view;
         if (view == null && name.indexOf('.') > -1) {
             if (mConstructorArgs == null)
                 mConstructorArgs = ReflectionUtils.getField(LayoutInflater.class, "mConstructorArgs");
@@ -228,25 +229,15 @@ private View createCustomViewInternal(View parent, View view, String name, Conte
     private static class WrapperFactory implements Factory {
 
         private final Factory mFactory;
-        private final CalligraphyLayoutInflater mInflater;
-        private final CalligraphyFactory mCalligraphyFactory;
+        private final ColorographyFactory mCalligraphyFactory;
 
-        public WrapperFactory(Factory factory, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+        public WrapperFactory(Factory factory, ColorographyFactory calligraphyFactory) {
             mFactory = factory;
-            mInflater = inflater;
             mCalligraphyFactory = calligraphyFactory;
         }
 
         @Override
         public View onCreateView(String name, Context context, AttributeSet attrs) {
-            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
-                return mCalligraphyFactory.onViewCreated(
-                        mInflater.createCustomViewInternal(
-                                null, mFactory.onCreateView(name, context, attrs), name, context, attrs
-                        ),
-                        context, attrs
-                );
-            }
             return mCalligraphyFactory.onViewCreated(
                     mFactory.onCreateView(name, context, attrs),
                     context, attrs
@@ -260,9 +251,9 @@ public View onCreateView(String name, Context context, AttributeSet attrs) {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     private static class WrapperFactory2 implements Factory2 {
         protected final Factory2 mFactory2;
-        protected final CalligraphyFactory mCalligraphyFactory;
+        protected final ColorographyFactory mCalligraphyFactory;
 
-        public WrapperFactory2(Factory2 factory2, CalligraphyFactory calligraphyFactory) {
+        public WrapperFactory2(Factory2 factory2, ColorographyFactory calligraphyFactory) {
             mFactory2 = factory2;
             mCalligraphyFactory = calligraphyFactory;
         }
@@ -289,9 +280,9 @@ public View onCreateView(View parent, String name, Context context, AttributeSet
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     private static class PrivateWrapperFactory2 extends WrapperFactory2 {
 
-        private final CalligraphyLayoutInflater mInflater;
+        private final ColorographyLayoutInflater mInflater;
 
-        public PrivateWrapperFactory2(Factory2 factory2, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+        public PrivateWrapperFactory2(Factory2 factory2, ColorographyLayoutInflater inflater, ColorographyFactory calligraphyFactory) {
             super(factory2, calligraphyFactory);
             mInflater = inflater;
         }
diff --git a/colorography/src/main/java/com/ftinc/colorography/ColorographyUtils.java b/colorography/src/main/java/com/ftinc/colorography/ColorographyUtils.java
new file mode 100644
index 0000000..c569cf2
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/ColorographyUtils.java
@@ -0,0 +1,48 @@
+package com.ftinc.colorography;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.support.v4.content.ContextCompat;
+import android.text.Editable;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.widget.TextView;
+
+/**
+ * Created by chris on 20/12/2013
+ * Project: Calligraphy
+ * Modified by drew.heaver on 07/06/2017
+ */
+public final class ColorographyUtils {
+
+    private ColorographyUtils() {
+    }
+
+
+    static int pullDefaultColorFromView(Context context, AttributeSet attrs, int[] attributeId) {
+        if (attributeId == null || attrs == null)
+            return -1;
+
+        final String attributeName;
+        try {
+            attributeName = context.getResources().getResourceEntryName(attributeId[0]);
+        } catch (Resources.NotFoundException e) {
+            // invalid attribute ID
+            return -1;
+        }
+
+        final int colorResourceId = attrs.getAttributeResourceValue(null, attributeName, -1);
+        return colorResourceId > 0
+                ? ContextCompat.getColor(context, colorResourceId)
+                : attrs.getAttributeIntValue(null, attributeName, -1);
+    }
+}
diff --git a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java b/colorography/src/main/java/com/ftinc/colorography/ReflectionUtils.java
similarity index 97%
rename from calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
rename to colorography/src/main/java/com/ftinc/colorography/ReflectionUtils.java
index 99c0d86..6bd6b59 100644
--- a/calligraphy/src/main/java/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
+++ b/colorography/src/main/java/com/ftinc/colorography/ReflectionUtils.java
@@ -1,4 +1,4 @@
-package uk.co.chrisjenx.calligraphy;
+package com.ftinc.colorography;
 
 import android.util.Log;
 
diff --git a/colorography/src/main/java/com/ftinc/colorography/ThemeColorProvider.java b/colorography/src/main/java/com/ftinc/colorography/ThemeColorProvider.java
new file mode 100644
index 0000000..a630a8c
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/ThemeColorProvider.java
@@ -0,0 +1,11 @@
+package com.ftinc.colorography;
+
+
+import android.support.annotation.ColorInt;
+
+
+public interface ThemeColorProvider {
+
+    @ColorInt
+    int getThemeColor();
+}
diff --git a/colorography/src/main/java/com/ftinc/colorography/TintTypedArray.java b/colorography/src/main/java/com/ftinc/colorography/TintTypedArray.java
new file mode 100644
index 0000000..509b063
--- /dev/null
+++ b/colorography/src/main/java/com/ftinc/colorography/TintTypedArray.java
@@ -0,0 +1,192 @@
+package com.ftinc.colorography;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.v4.content.ContextCompat;
+import android.support.v7.content.res.AppCompatResources;
+import android.support.v7.widget.AppCompatDrawableManager;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+
+public class TintTypedArray {
+
+    private final Context mContext;
+    private final TypedArray mWrapped;
+
+    private TypedValue mTypedValue;
+
+    public static TintTypedArray obtainStyledAttributes(Context context, AttributeSet set,
+            int[] attrs) {
+        return new TintTypedArray(context, context.obtainStyledAttributes(set, attrs));
+    }
+
+    public static TintTypedArray obtainStyledAttributes(Context context, AttributeSet set,
+            int[] attrs, int defStyleAttr, int defStyleRes) {
+        return new TintTypedArray(context,
+                context.obtainStyledAttributes(set, attrs, defStyleAttr, defStyleRes));
+    }
+
+    public static TintTypedArray obtainStyledAttributes(Context context, int resid, int[] attrs) {
+        return new TintTypedArray(context, context.obtainStyledAttributes(resid, attrs));
+    }
+
+    private TintTypedArray(Context context, TypedArray array) {
+        mContext = context;
+        mWrapped = array;
+    }
+
+    public Drawable getDrawable(int index) {
+        if (mWrapped.hasValue(index)) {
+            final int resourceId = mWrapped.getResourceId(index, 0);
+            if (resourceId != 0) {
+                return AppCompatResources.getDrawable(mContext, resourceId);
+            }
+        }
+        return mWrapped.getDrawable(index);
+    }
+
+    public Drawable getDrawableIfKnown(int index) {
+        if (mWrapped.hasValue(index)) {
+            final int resourceId = mWrapped.getResourceId(index, 0);
+            if (resourceId != 0) {
+                return ContextCompat.getDrawable(mContext, resourceId);
+            }
+        }
+        return null;
+    }
+
+    public int length() {
+        return mWrapped.length();
+    }
+
+    public int getIndexCount() {
+        return mWrapped.getIndexCount();
+    }
+
+    public int getIndex(int at) {
+        return mWrapped.getIndex(at);
+    }
+
+    public Resources getResources() {
+        return mWrapped.getResources();
+    }
+
+    public CharSequence getText(int index) {
+        return mWrapped.getText(index);
+    }
+
+    public String getString(int index) {
+        return mWrapped.getString(index);
+    }
+
+    public String getNonResourceString(int index) {
+        return mWrapped.getNonResourceString(index);
+    }
+
+    public boolean getBoolean(int index, boolean defValue) {
+        return mWrapped.getBoolean(index, defValue);
+    }
+
+    public int getInt(int index, int defValue) {
+        return mWrapped.getInt(index, defValue);
+    }
+
+    public float getFloat(int index, float defValue) {
+        return mWrapped.getFloat(index, defValue);
+    }
+
+    public int getColor(int index, int defValue) {
+        return mWrapped.getColor(index, defValue);
+    }
+
+    public ColorStateList getColorStateList(int index) {
+        if (mWrapped.hasValue(index)) {
+            final int resourceId = mWrapped.getResourceId(index, 0);
+            if (resourceId != 0) {
+                final ColorStateList value =
+                        AppCompatResources.getColorStateList(mContext, resourceId);
+                if (value != null) {
+                    return value;
+                }
+            }
+        }
+        return mWrapped.getColorStateList(index);
+    }
+
+    public int getInteger(int index, int defValue) {
+        return mWrapped.getInteger(index, defValue);
+    }
+
+    public float getDimension(int index, float defValue) {
+        return mWrapped.getDimension(index, defValue);
+    }
+
+    public int getDimensionPixelOffset(int index, int defValue) {
+        return mWrapped.getDimensionPixelOffset(index, defValue);
+    }
+
+    public int getDimensionPixelSize(int index, int defValue) {
+        return mWrapped.getDimensionPixelSize(index, defValue);
+    }
+
+    public int getLayoutDimension(int index, String name) {
+        return mWrapped.getLayoutDimension(index, name);
+    }
+
+    public int getLayoutDimension(int index, int defValue) {
+        return mWrapped.getLayoutDimension(index, defValue);
+    }
+
+    public float getFraction(int index, int base, int pbase, float defValue) {
+        return mWrapped.getFraction(index, base, pbase, defValue);
+    }
+
+    public int getResourceId(int index, int defValue) {
+        return mWrapped.getResourceId(index, defValue);
+    }
+
+    public CharSequence[] getTextArray(int index) {
+        return mWrapped.getTextArray(index);
+    }
+
+    public boolean getValue(int index, TypedValue outValue) {
+        return mWrapped.getValue(index, outValue);
+    }
+
+    public int getType(int index) {
+        if (Build.VERSION.SDK_INT >= 21) {
+            return mWrapped.getType(index);
+        } else {
+            if (mTypedValue == null) {
+                mTypedValue = new TypedValue();
+            }
+            mWrapped.getValue(index, mTypedValue);
+            return mTypedValue.type;
+        }
+    }
+
+    public boolean hasValue(int index) {
+        return mWrapped.hasValue(index);
+    }
+
+    public TypedValue peekValue(int index) {
+        return mWrapped.peekValue(index);
+    }
+
+    public String getPositionDescription() {
+        return mWrapped.getPositionDescription();
+    }
+
+    public void recycle() {
+        mWrapped.recycle();
+    }
+
+    public int getChangingConfigurations() {
+        return mWrapped.getChangingConfigurations();
+    }
+
+}
\ No newline at end of file
diff --git a/colorography/src/main/res/values/attrs.xml b/colorography/src/main/res/values/attrs.xml
new file mode 100644
index 0000000..7bbb685
--- /dev/null
+++ b/colorography/src/main/res/values/attrs.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <attr name="fontPath" format="string" />
+    <attr name="themeColor" format="color|reference" />
+</resources>
\ No newline at end of file
diff --git a/calligraphy/src/main/res/values/ids.xml b/colorography/src/main/res/values/ids.xml
similarity index 100%
rename from calligraphy/src/main/res/values/ids.xml
rename to colorography/src/main/res/values/ids.xml
diff --git a/calligraphy/src/main/res/values/public.xml b/colorography/src/main/res/values/public.xml
similarity index 70%
rename from calligraphy/src/main/res/values/public.xml
rename to colorography/src/main/res/values/public.xml
index e6e37e3..30be1ea 100644
--- a/calligraphy/src/main/res/values/public.xml
+++ b/colorography/src/main/res/values/public.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <public name="fontPath" type="attr"/>
+    <public name="themeColor" type="attr"/>
 </resources>
diff --git a/gradle.properties b/gradle.properties
index 9e680c3..14b5513 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -17,9 +17,9 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-GROUP=uk.co.chrisjenx
-VERSION_NAME=2.3.0
-VERSION_CODE=24
+GROUP=com.52inc
+VERSION_NAME=3.0.0-SNAPSHOT
+VERSION_CODE=25
 
 POM_PACKAGING=aar
 POM_URL=https://github.com/chrisjenx/Calligraphy
@@ -30,6 +30,6 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:chrisjenx/Calligraphy.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=chrisjenx
-POM_DEVELOPER_NAME=Christopher Jenkins
-POM_DEVELOPER_EMAIL=chris.mark.jenkins@gmail.com
+POM_DEVELOPER_ID=r0adkll
+POM_DEVELOPER_NAME=Drew Heavner
+POM_DEVELOPER_EMAIL=drew@52inc.com
\ No newline at end of file
diff --git a/gradle/deploy.gradle b/gradle/deploy.gradle
index b64068b..536e842 100644
--- a/gradle/deploy.gradle
+++ b/gradle/deploy.gradle
@@ -18,7 +18,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 def isReleaseBuild() {
-    project.ext.isReleaseVersion
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def getReleaseRepositoryUrl() {
@@ -30,18 +30,17 @@ def getSnapshotRepositoryUrl() {
 }
 
 def getRepositoryUsername() {
-    return hasProperty('sonatypeUsername') ? sonatypeUsername : ""
+    return hasProperty('sonatypeUsername') ? NEXUS_USERNAME : ""
 }
 
 def getRepositoryPassword() {
-    return hasProperty('sonatypePassword') ? sonatypePassword : ""
+    return hasProperty('sonatypePassword') ? NEXUS_PASSWORD : ""
 }
 
 // Debug Build or Release?
 if (isReleaseBuild()) {
     println "RELEASE BUILD $version"
 } else {
-    version += "-SNAPSHOT"
     println "DEBUG BUILD $version"
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 3a1478b..1153250 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Jan 21 23:48:10 PST 2016
+#Wed Jul 05 12:02:55 EDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.5-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-milestone-1-all.zip
diff --git a/settings.gradle b/settings.gradle
index 182c95d..1c54560 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1 +1 @@
-include ':calligraphy', ':CalligraphySample'
+include ':colorography', ':CalligraphySample'
