diff --git a/calligraphy/src/main/project.properties b/calligraphy/src/main/project.properties
new file mode 100644
index 0000000..229c8b7
--- /dev/null
+++ b/calligraphy/src/main/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-21
+android.library=true
+android.library.reference.1=../../../../appcompat_v7
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
new file mode 100644
index 0000000..e0214eb
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyActivityFactory.java
@@ -0,0 +1,34 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
+/**
+ * Created by chris on 09/11/14.
+ * For Calligraphy.
+ */
+interface CalligraphyActivityFactory {
+
+    /**
+     * Used to Wrap the Activity onCreateView method.
+     *
+     * You implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return CalligraphyContextWrapper.get(getBaseContext()).onActivityCreateView(super.onCreateView(parent, name, context, attrs), attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param parent  parent view, can be null.
+     * @param view    result of {@code super.onCreateView(parent, name, context, attrs)}, this might be null, which is fine.
+     * @param name    Name of View we are trying to inflate
+     * @param context current context (normally the Activity's)
+     * @param attrs   see {@link android.view.LayoutInflater.Factory2#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}  @return the result from the activities {@code onCreateView()}
+     * @return The view passed in, or null if nothing was passed in.
+     * @see android.view.LayoutInflater.Factory2
+     */
+    View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs);
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
new file mode 100644
index 0000000..c22148a
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyConfig.java
@@ -0,0 +1,265 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.os.Build;
+import android.text.TextUtils;
+import android.widget.AutoCompleteTextView;
+import android.widget.Button;
+import android.widget.CheckBox;
+import android.widget.EditText;
+import android.widget.MultiAutoCompleteTextView;
+import android.widget.RadioButton;
+import android.widget.TextView;
+import android.widget.ToggleButton;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by chris on 20/12/2013
+ * Project: Calligraphy
+ */
+public class CalligraphyConfig {
+
+    /**
+     * The default styles for the factory to lookup. The builder builds an extended immutable
+     * map of this with any additional custom styles.
+     */
+    private static final Map<Class<? extends TextView>, Integer> DEFAULT_STYLES = new HashMap<>();
+
+    static {
+        {
+            DEFAULT_STYLES.put(TextView.class, android.R.attr.textViewStyle);
+            DEFAULT_STYLES.put(Button.class, android.R.attr.buttonStyle);
+            DEFAULT_STYLES.put(EditText.class, android.R.attr.editTextStyle);
+            DEFAULT_STYLES.put(AutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
+            DEFAULT_STYLES.put(MultiAutoCompleteTextView.class, android.R.attr.autoCompleteTextViewStyle);
+            DEFAULT_STYLES.put(CheckBox.class, android.R.attr.checkboxStyle);
+            DEFAULT_STYLES.put(RadioButton.class, android.R.attr.radioButtonStyle);
+            DEFAULT_STYLES.put(ToggleButton.class, android.R.attr.buttonStyleToggle);
+        }
+    }
+
+    private static CalligraphyConfig sInstance;
+
+    /**
+     * Set the default Calligraphy Config
+     *
+     * @param calligraphyConfig the config build using the builder.
+     * @see uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder
+     */
+    public static void initDefault(CalligraphyConfig calligraphyConfig) {
+        sInstance = calligraphyConfig;
+    }
+
+    /**
+     * The current Calligraphy Config.
+     * If not set it will create a default config.
+     */
+    public static CalligraphyConfig get() {
+        if (sInstance == null)
+            sInstance = new CalligraphyConfig(new Builder());
+        return sInstance;
+    }
+
+    /**
+     * Is a default font set?
+     */
+    private final boolean mIsFontSet;
+    /**
+     * The default Font Path if nothing else is setup.
+     */
+    private final String mFontPath;
+    /**
+     * Default Font Path Attr Id to lookup
+     */
+    private final int mAttrId;
+    /**
+     * Use Reflection to inject the private factory.
+     */
+    private final boolean mReflection;
+    /**
+     * Use Reflection to intercept CustomView inflation with the correct Context.
+     */
+    private final boolean mCustomViewCreation;
+    /**
+     * Class Styles. Build from DEFAULT_STYLES and the builder.
+     */
+    private final Map<Class<? extends TextView>, Integer> mClassStyleAttributeMap;
+
+    protected CalligraphyConfig(Builder builder) {
+        mIsFontSet = builder.isFontSet;
+        mFontPath = builder.fontAssetPath;
+        mAttrId = builder.attrId;
+        mReflection = builder.reflection;
+        mCustomViewCreation = builder.customViewCreation;
+        final Map<Class<? extends TextView>, Integer> tempMap = new HashMap<>(DEFAULT_STYLES);
+        tempMap.putAll(builder.mStyleClassMap);
+        mClassStyleAttributeMap = Collections.unmodifiableMap(tempMap);
+    }
+
+    /**
+     * @return mFontPath for text views might be null
+     */
+    public String getFontPath() {
+        return mFontPath;
+    }
+
+    /**
+     * @return true if set, false if null|empty
+     */
+    boolean isFontSet() {
+        return mIsFontSet;
+    }
+
+    public boolean isReflection() {
+        return mReflection;
+    }
+
+    public boolean isCustomViewCreation() {
+        return mCustomViewCreation;
+    }
+
+    /* default */ Map<Class<? extends TextView>, Integer> getClassStyles() {
+        return mClassStyleAttributeMap;
+    }
+
+    /**
+     * @return the custom attrId to look for, -1 if not set.
+     */
+    public int getAttrId() {
+        return mAttrId;
+    }
+
+    public static class Builder {
+        /**
+         * Default AttrID if not set.
+         */
+        public static final int INVALID_ATTR_ID = -1;
+        /**
+         * Use Reflection to inject the private factory. Doesn't exist pre HC. so defaults to false.
+         */
+        private boolean reflection = Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
+        /**
+         * Use Reflection to intercept CustomView inflation with the correct Context.
+         */
+        private boolean customViewCreation = true;
+        /**
+         * The fontAttrId to look up the font path from.
+         */
+        private int attrId = R.attr.fontPath;
+        /**
+         * Has the user set the default font path.
+         */
+        private boolean isFontSet = false;
+        /**
+         * The default fontPath
+         */
+        private String fontAssetPath = null;
+        /**
+         * Additional Class Styles. Can be empty.
+         */
+        private Map<Class<? extends TextView>, Integer> mStyleClassMap = new HashMap<>();
+
+        /**
+         * This defaults to R.attr.fontPath. So only override if you want to use your own attrId.
+         *
+         * @param fontAssetAttrId the custom attribute to look for fonts in assets.
+         * @return this builder.
+         */
+        public Builder setFontAttrId(int fontAssetAttrId) {
+            this.attrId = fontAssetAttrId != INVALID_ATTR_ID ? fontAssetAttrId : INVALID_ATTR_ID;
+            return this;
+        }
+
+        /**
+         * Set the default font if you don't define one else where in your styles.
+         *
+         * @param defaultFontAssetPath a path to a font file in the assets folder, e.g. "fonts/Roboto-light.ttf",
+         *                             passing null will default to the device font-family.
+         * @return this builder.
+         */
+        public Builder setDefaultFontPath(String defaultFontAssetPath) {
+            this.isFontSet = !TextUtils.isEmpty(defaultFontAssetPath);
+            this.fontAssetPath = defaultFontAssetPath;
+            return this;
+        }
+
+        /**
+         * <p>Turn of the use of Reflection to inject the private factory.
+         * This has operational consequences! Please read and understand before disabling.
+         * <b>This is already disabled on pre Honeycomb devices. (API 11)</b></p>
+         *
+         * <p> If you disable this you will need to override your {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * as this is set as the {@link android.view.LayoutInflater} private factory.</p>
+         * <br>
+         * <b> Use the following code in the Activity if you disable FactoryInjection:</b>
+         * <pre><code>
+         * {@literal @}Override
+         * {@literal @}TargetApi(Build.VERSION_CODES.HONEYCOMB)
+         * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+         *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+         * }
+         * </code></pre>
+         */
+        public Builder disablePrivateFactoryInjection() {
+            this.reflection = false;
+            return this;
+        }
+
+        /**
+         * Due to the poor inflation order where custom views are created and never returned inside an
+         * {@code onCreateView(...)} method. We have to create CustomView's at the latest point in the
+         * overrideable injection flow.
+         *
+         * On HoneyComb+ this is inside the {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * Pre HoneyComb this is in the {@link android.view.LayoutInflater.Factory#onCreateView(String, android.util.AttributeSet)}
+         *
+         * We wrap base implementations, so if you LayoutInflater/Factory/Activity creates the
+         * custom view before we get to this point, your view is used. (Such is the case with the
+         * TintEditText etc)
+         *
+         * The problem is, the native methods pass there parents context to the constructor in a really
+         * specific place. We have to mimic this in {@link uk.co.chrisjenx.calligraphy.CalligraphyLayoutInflater#createCustomViewInternal(android.view.View, android.view.View, String, android.content.Context, android.util.AttributeSet)}
+         * To mimic this we have to use reflection as the Class constructor args are hidden to us.
+         *
+         * We have discussed other means of doing this but this is the only semi-clean way of doing it.
+         * (Without having to do proxy classes etc).
+         *
+         * Calling this will of course speed up inflation by turning off reflection, but not by much,
+         * But if you want Calligraphy to inject the correct typeface then you will need to make sure your CustomView's
+         * are created before reaching the LayoutInflater onViewCreated.
+         */
+        public Builder disableCustomViewInflation() {
+            this.customViewCreation = false;
+            return this;
+        }
+
+        /**
+         * Add a custom style to get looked up. If you use a custom class that has a parent style
+         * which is not part of the default android styles you will need to add it here.
+         *
+         * The Calligraphy inflater is unaware of custom styles in your custom classes. We use
+         * the class type to look up the style attribute in the theme resources.
+         *
+         * So if you had a {@code MyTextField.class} which looked up it's default style as
+         * {@code R.attr.textFieldStyle} you would add those here.
+         *
+         * {@code builder.addCustomStyle(MyTextField.class,R.attr.textFieldStyle}
+         *
+         * @param styleClass             the class that related to the parent styleResource. null is ignored.
+         * @param styleResourceAttribute e.g. {@code R.attr.textFieldStyle}, 0 is ignored.
+         * @return this builder.
+         */
+        public Builder addCustomStyle(final Class<? extends TextView> styleClass, final int styleResourceAttribute) {
+            if (styleClass == null || styleResourceAttribute == 0) return this;
+            mStyleClassMap.put(styleClass, styleResourceAttribute);
+            return this;
+        }
+
+        public CalligraphyConfig build() {
+            this.isFontSet = !TextUtils.isEmpty(fontAssetPath);
+            return new CalligraphyConfig(this);
+        }
+    }
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
new file mode 100644
index 0000000..8650208
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyContextWrapper.java
@@ -0,0 +1,118 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+
+/**
+ * Created by chris on 19/12/2013
+ * Project: Calligraphy
+ */
+public class CalligraphyContextWrapper extends ContextWrapper {
+
+    private CalligraphyLayoutInflater mInflater;
+
+    private final int mAttributeId;
+
+    /**
+     * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
+     *
+     * Remember if you are defining default in the
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap.
+     * @return ContextWrapper to pass back to the activity.
+     */
+    public static ContextWrapper wrap(Context base) {
+        return new CalligraphyContextWrapper(base);
+    }
+
+    /**
+     * You only need to call this <b>IF</b> you call
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig.Builder#disablePrivateFactoryInjection()}
+     * This will need to be called from the
+     * {@link android.app.Activity#onCreateView(android.view.View, String, android.content.Context, android.util.AttributeSet)}
+     * method to enable view font injection if the view is created inside the activity onCreateView.
+     *
+     * You would implement this method like so in you base activity.
+     * <pre>
+     * {@code
+     * public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+     *   return CalligraphyContextWrapper.onActivityCreateView(this, parent, super.onCreateView(parent, name, context, attrs), name, context, attrs);
+     * }
+     * }
+     * </pre>
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @param parent   Parent view from onCreateView
+     * @param view     The View Created inside onCreateView or from super.onCreateView
+     * @param name     The View name from onCreateView
+     * @param context  The context from onCreateView
+     * @param attr     The AttributeSet from onCreateView
+     * @return The same view passed in, or null if null passed in.
+     */
+    public static View onActivityCreateView(Activity activity, View parent, View view, String name, Context context, AttributeSet attr) {
+        return get(activity).onActivityCreateView(parent, view, name, context, attr);
+    }
+
+    /**
+     * Get the Calligraphy Activity Fragment Instance to allow callbacks for when views are created.
+     *
+     * @param activity The activity the original that the ContextWrapper was attached too.
+     * @return Interface allowing you to call onActivityViewCreated
+     */
+    static CalligraphyActivityFactory get(Activity activity) {
+        if (!(activity.getLayoutInflater() instanceof CalligraphyLayoutInflater)) {
+            throw new RuntimeException("This activity does not wrap the Base Context! See CalligraphyContextWrapper.wrap(Context)");
+        }
+        return (CalligraphyActivityFactory) activity.getLayoutInflater();
+    }
+
+    /**
+     * Uses the default configuration from {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
+     *
+     * Remember if you are defining default in the
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base ContextBase to Wrap
+     */
+    CalligraphyContextWrapper(Context base) {
+        super(base);
+        mAttributeId = CalligraphyConfig.get().getAttrId();
+    }
+
+    /**
+     * Override the default AttributeId, this will always take the custom attribute defined here
+     * and ignore the one set in {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}.
+     *
+     * Remember if you are defining default in the
+     * {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig} make sure this is initialised before
+     * the activity is created.
+     *
+     * @param base        ContextBase to Wrap
+     * @param attributeId Attribute to lookup.
+     * @deprecated use {@link #wrap(android.content.Context)}
+     */
+    @Deprecated
+    public CalligraphyContextWrapper(Context base, int attributeId) {
+        super(base);
+        mAttributeId = attributeId;
+    }
+
+    @Override
+    public Object getSystemService(String name) {
+        if (LAYOUT_INFLATER_SERVICE.equals(name)) {
+            if (mInflater == null) {
+                mInflater = new CalligraphyLayoutInflater(LayoutInflater.from(getBaseContext()), this, mAttributeId, false);
+            }
+            return mInflater;
+        }
+        return super.getSystemService(name);
+    }
+
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
new file mode 100644
index 0000000..29a0718
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyFactory.java
@@ -0,0 +1,185 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.widget.TextView;
+import android.widget.Toolbar;
+
+class CalligraphyFactory {
+
+    private static final String ACTION_BAR_TITLE = "action_bar_title";
+    private static final String ACTION_BAR_SUBTITLE = "action_bar_subtitle";
+
+    /**
+     * Some styles are in sub styles, such as actionBarTextStyle etc..
+     *
+     * @param view view to check.
+     * @return 2 element array, default to -1 unless a style has been found.
+     */
+    protected static int[] getStyleForTextView(TextView view) {
+        final int[] styleIds = new int[]{-1, -1};
+        // Try to find the specific actionbar styles
+        if (isActionBarTitle(view)) {
+            styleIds[0] = android.R.attr.actionBarStyle;
+            styleIds[1] = android.R.attr.titleTextStyle;
+        } else if (isActionBarSubTitle(view)) {
+            styleIds[0] = android.R.attr.actionBarStyle;
+            styleIds[1] = android.R.attr.subtitleTextStyle;
+        }
+        if (styleIds[0] == -1) {
+            // Use TextAppearance as default style
+            styleIds[0] = CalligraphyConfig.get().getClassStyles().containsKey(view.getClass())
+                    ? CalligraphyConfig.get().getClassStyles().get(view.getClass())
+                    : android.R.attr.textAppearance;
+        }
+        return styleIds;
+    }
+
+    /**
+     * An even dirtier way to see if the TextView is part of the ActionBar
+     *
+     * @param view TextView to check is Title
+     * @return true if it is.
+     */
+    @SuppressLint("NewApi")
+    protected static boolean isActionBarTitle(TextView view) {
+        if (matchesResourceIdName(view, ACTION_BAR_TITLE)) return true;
+        if (parentIsToolbarV7(view)) {
+            final Toolbar parent = (Toolbar) view.getParent();
+            return TextUtils.equals(parent.getTitle(), view.getText());
+        }
+        return false;
+    }
+
+    /**
+     * An even dirtier way to see if the TextView is part of the ActionBar
+     *
+     * @param view TextView to check is Title
+     * @return true if it is.
+     */
+    @SuppressLint("NewApi")
+    protected static boolean isActionBarSubTitle(TextView view) {
+        if (matchesResourceIdName(view, ACTION_BAR_SUBTITLE)) return true;
+        if (parentIsToolbarV7(view)) {
+            final Toolbar parent = (Toolbar) view.getParent();
+            return TextUtils.equals(parent.getSubtitle(), view.getText());
+        }
+        return false;
+    }
+
+    protected static boolean parentIsToolbarV7(View view) {
+        return CalligraphyUtils.canCheckForV7Toolbar() && view.getParent() != null && (view.getParent() instanceof Toolbar);
+    }
+
+    /**
+     * Use to match a view against a potential view id. Such as ActionBar title etc.
+     *
+     * @param view    not null view you want to see has resource matching name.
+     * @param matches not null resource name to match against. Its not case sensitive.
+     * @return true if matches false otherwise.
+     */
+    protected static boolean matchesResourceIdName(View view, String matches) {
+        if (view.getId() == View.NO_ID) return false;
+        final String resourceEntryName = view.getResources().getResourceEntryName(view.getId());
+        return resourceEntryName.equalsIgnoreCase(matches);
+    }
+
+    private final int mAttributeId;
+
+    public CalligraphyFactory(int attributeId) {
+        this.mAttributeId = attributeId;
+    }
+
+    /**
+     * Handle the created view
+     *
+     * @param view    nullable.
+     * @param context shouldn't be null.
+     * @param attrs   shouldn't be null.
+     * @return null if null is passed in.
+     */
+
+    public View onViewCreated(View view, Context context, AttributeSet attrs) {
+        if (view != null && view.getTag(R.id.calligraphy_tag_id) != Boolean.TRUE) {
+            onViewCreatedInternal(view, context, attrs);
+            view.setTag(R.id.calligraphy_tag_id, Boolean.TRUE);
+        }
+        return view;
+    }
+
+    void onViewCreatedInternal(View view, final Context context, AttributeSet attrs) {
+        if (view instanceof TextView) {
+            // Fast path the setting of TextView's font, means if we do some delayed setting of font,
+            // which has already been set by use we skip this TextView (mainly for inflating custom,
+            // TextView's inside the Toolbar/ActionBar).
+            if (TypefaceUtils.isLoaded(((TextView) view).getTypeface())) {
+                return;
+            }
+            // Try to get typeface attribute value
+            // Since we're not using namespace it's a little bit tricky
+
+            // Try view xml attributes
+            String textViewFont = CalligraphyUtils.pullFontPathFromView(context, attrs, mAttributeId);
+
+            // Try view style attributes
+            if (TextUtils.isEmpty(textViewFont)) {
+                textViewFont = CalligraphyUtils.pullFontPathFromStyle(context, attrs, mAttributeId);
+            }
+
+            // Try View TextAppearance
+            if (TextUtils.isEmpty(textViewFont)) {
+                textViewFont = CalligraphyUtils.pullFontPathFromTextAppearance(context, attrs, mAttributeId);
+            }
+
+            // Try theme attributes
+            if (TextUtils.isEmpty(textViewFont)) {
+                final int[] styleForTextView = getStyleForTextView((TextView) view);
+                if (styleForTextView[1] != -1)
+                    textViewFont = CalligraphyUtils.pullFontPathFromTheme(context, styleForTextView[0], styleForTextView[1], mAttributeId);
+                else
+                    textViewFont = CalligraphyUtils.pullFontPathFromTheme(context, styleForTextView[0], mAttributeId);
+            }
+
+            // Still need to defer the Native action bar, appcompat-v7:21+ uses the Toolbar underneath. But won't match these anyway.
+            final boolean deferred = matchesResourceIdName(view, ACTION_BAR_TITLE) || matchesResourceIdName(view, ACTION_BAR_SUBTITLE);
+
+            CalligraphyUtils.applyFontToTextView(context, (TextView) view, CalligraphyConfig.get(), textViewFont, deferred);
+        }
+
+        // AppCompat API21+ The ActionBar doesn't inflate default Title/SubTitle, we need to scan the
+        // Toolbar(Which underlies the ActionBar) for its children.
+        if (CalligraphyUtils.canCheckForV7Toolbar() && view instanceof Toolbar) {
+            final ViewGroup parent = (ViewGroup) view;
+            parent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+                @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+                @Override
+                public void onGlobalLayout() {
+                    int childCount = parent.getChildCount();
+                    if (childCount != 0) {
+                        // Process children, defer draw as it has set the typeface.
+                        for (int i = 0; i < childCount; i++) {
+                            onViewCreated(parent.getChildAt(i), context, null);
+                        }
+                    }
+
+                    // Our dark deed is done
+                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                        //noinspection deprecation
+                        parent.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                    } else {
+                        parent.getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                    }
+                }
+            });
+        }
+    }
+
+
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
new file mode 100644
index 0000000..6f9cfc1
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyLayoutInflater.java
@@ -0,0 +1,311 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+/**
+ * Created by chris on 19/12/2013
+ * Project: Calligraphy
+ */
+class CalligraphyLayoutInflater extends LayoutInflater implements CalligraphyActivityFactory {
+
+    private static final String[] sClassPrefixList = {
+            "android.widget.",
+            "android.webkit."
+    };
+
+    private final int mAttributeId;
+    private final CalligraphyFactory mCalligraphyFactory;
+    // Reflection Hax
+    private boolean mSetPrivateFactory = false;
+    private Field mConstructorArgs = null;
+
+    protected CalligraphyLayoutInflater(Context context, int attributeId) {
+        super(context);
+        mAttributeId = attributeId;
+        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        setUpLayoutFactories(false);
+    }
+
+    protected CalligraphyLayoutInflater(LayoutInflater original, Context newContext, int attributeId, final boolean cloned) {
+        super(original, newContext);
+        mAttributeId = attributeId;
+        mCalligraphyFactory = new CalligraphyFactory(attributeId);
+        setUpLayoutFactories(cloned);
+    }
+
+    @Override
+    public LayoutInflater cloneInContext(Context newContext) {
+        return new CalligraphyLayoutInflater(this, newContext, mAttributeId, true);
+    }
+
+    // ===
+    // Wrapping goodies
+    // ===
+
+
+    @Override
+    public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
+        setPrivateFactoryInternal();
+        return super.inflate(parser, root, attachToRoot);
+    }
+
+    /**
+     * We don't want to unnecessary create/set our factories if there are none there. We try to be
+     * as lazy as possible.
+     */
+    private void setUpLayoutFactories(boolean cloned) {
+        if (cloned) return;
+        // If we are HC+ we get and set Factory2 otherwise we just wrap Factory1
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            if (getFactory2() != null && !(getFactory2() instanceof WrapperFactory2)) {
+                // Sets both Factory/Factory2
+                setFactory2(getFactory2());
+            }
+        }
+        // We can do this as setFactory2 is used for both methods.
+        if (getFactory() != null && !(getFactory() instanceof WrapperFactory)) {
+            setFactory(getFactory());
+        }
+    }
+
+    @Override
+    public void setFactory(Factory factory) {
+        // Only set our factory and wrap calls to the Factory trying to be set!
+        if (!(factory instanceof WrapperFactory)) {
+            super.setFactory(new WrapperFactory(factory, this, mCalligraphyFactory));
+        } else {
+            super.setFactory(factory);
+        }
+    }
+
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public void setFactory2(Factory2 factory2) {
+        // Only set our factory and wrap calls to the Factory2 trying to be set!
+        if (!(factory2 instanceof WrapperFactory2)) {
+//            LayoutInflaterCompat.setFactory(this, new WrapperFactory2(factory2, mCalligraphyFactory));
+            super.setFactory2(new WrapperFactory2(factory2, mCalligraphyFactory));
+        } else {
+            super.setFactory2(factory2);
+        }
+    }
+
+    private void setPrivateFactoryInternal() {
+        // Already tried to set the factory.
+        if (mSetPrivateFactory) return;
+        // Reflection (Or Old Device) skip.
+        if (!CalligraphyConfig.get().isReflection()) return;
+        // Skip if not attached to an activity.
+        if (!(getContext() instanceof Factory2)) {
+            mSetPrivateFactory = true;
+            return;
+        }
+
+        final Method setPrivateFactoryMethod = ReflectionUtils
+                .getMethod(LayoutInflater.class, "setPrivateFactory");
+
+        if (setPrivateFactoryMethod != null) {
+            ReflectionUtils.invokeMethod(this,
+                    setPrivateFactoryMethod,
+                    new PrivateWrapperFactory2((Factory2) getContext(), this, mCalligraphyFactory));
+        }
+        mSetPrivateFactory = true;
+    }
+
+    // ===
+    // LayoutInflater ViewCreators
+    // Works in order of inflation
+    // ===
+
+    /**
+     * The Activity onCreateView (PrivateFactory) is the third port of call for LayoutInflation.
+     * We opted to manual injection over aggressive reflection, this should be less fragile.
+     */
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public View onActivityCreateView(View parent, View view, String name, Context context, AttributeSet attrs) {
+        return mCalligraphyFactory.onViewCreated(createCustomViewInternal(parent, view, name, context, attrs), context, attrs);
+    }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     */
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException {
+        return mCalligraphyFactory.onViewCreated(super.onCreateView(parent, name, attrs),
+                getContext(), attrs);
+    }
+
+    /**
+     * The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.
+     * BUT only for none CustomViews.
+     * Basically if this method doesn't inflate the View nothing probably will.
+     */
+    @Override
+    protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
+        // This mimics the {@code PhoneLayoutInflater} in the way it tries to inflate the base
+        // classes, if this fails its pretty certain the app will fail at this point.
+        View view = null;
+        for (String prefix : sClassPrefixList) {
+            try {
+                view = createView(name, prefix, attrs);
+            } catch (ClassNotFoundException ignored) {
+            }
+        }
+        // In this case we want to let the base class take a crack
+        // at it.
+        if (view == null) view = super.onCreateView(name, attrs);
+
+        return mCalligraphyFactory.onViewCreated(view, view.getContext(), attrs);
+    }
+
+    /**
+     * Nasty method to inflate custom layouts that haven't been handled else where. If this fails it
+     * will fall back through to the PhoneLayoutInflater method of inflating custom views where
+     * Calligraphy will NOT have a hook into.
+     *
+     * @param parent      parent view
+     * @param view        view if it has been inflated by this point, if this is not null this method
+     *                    just returns this value.
+     * @param name        name of the thing to inflate.
+     * @param viewContext Context to inflate by if parent is null
+     * @param attrs       Attr for this view which we can steal fontPath from too.
+     * @return view or the View we inflate in here.
+     */
+    private View createCustomViewInternal(View parent, View view, String name, Context viewContext, AttributeSet attrs) {
+        // I by no means advise anyone to do this normally, but Google have locked down access to
+        // the createView() method, so we never get a callback with attributes at the end of the
+        // createViewFromTag chain (which would solve all this unnecessary rubbish).
+        // We at the very least try to optimise this as much as possible.
+        // We only call for customViews (As they are the ones that never go through onCreateView(...)).
+        // We also maintain the Field reference and make it accessible which will make a pretty
+        // significant difference to performance on Android 4.0+.
+
+        // If CustomViewCreation is off skip this.
+        if (!CalligraphyConfig.get().isCustomViewCreation()) return view;
+        if (view == null && name.indexOf('.') > -1) {
+            if (mConstructorArgs == null)
+                mConstructorArgs = ReflectionUtils.getField(LayoutInflater.class, "mConstructorArgs");
+
+            final Object[] mConstructorArgsArr = (Object[]) ReflectionUtils.getValue(mConstructorArgs, this);
+            final Object lastContext = mConstructorArgsArr[0];
+            // The LayoutInflater actually finds out the correct context to use. We just need to set
+            // it on the mConstructor for the internal method.
+            // Set the constructor ars up for the createView, not sure why we can't pass these in.
+            mConstructorArgsArr[0] = viewContext;
+            ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            try {
+                view = createView(name, null, attrs);
+            } catch (ClassNotFoundException ignored) {
+            } finally {
+                mConstructorArgsArr[0] = lastContext;
+                ReflectionUtils.setValue(mConstructorArgs, this, mConstructorArgsArr);
+            }
+        }
+        return view;
+    }
+
+    // ===
+    // Wrapper Factories for Pre/Post HC
+    // ===
+
+    /**
+     * Factory 1 is the first port of call for LayoutInflation
+     */
+    private static class WrapperFactory implements Factory {
+
+        private final Factory mFactory;
+        private final CalligraphyLayoutInflater mInflater;
+        private final CalligraphyFactory mCalligraphyFactory;
+
+        public WrapperFactory(Factory factory, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+            mFactory = factory;
+            mInflater = inflater;
+            mCalligraphyFactory = calligraphyFactory;
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+                return mCalligraphyFactory.onViewCreated(
+                        mInflater.createCustomViewInternal(
+                                null, mFactory.onCreateView(name, context, attrs), name, context, attrs
+                        ),
+                        context, attrs
+                );
+            }
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory.onCreateView(name, context, attrs),
+                    context, attrs
+            );
+        }
+    }
+
+    /**
+     * Factory 2 is the second port of call for LayoutInflation
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private static class WrapperFactory2 implements Factory2 {
+        protected final Factory2 mFactory2;
+        protected final CalligraphyFactory mCalligraphyFactory;
+
+        public WrapperFactory2(Factory2 factory2, CalligraphyFactory calligraphyFactory) {
+            mFactory2 = factory2;
+            mCalligraphyFactory = calligraphyFactory;
+        }
+
+        @Override
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory2.onCreateView(name, context, attrs),
+                    context, attrs);
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mFactory2.onCreateView(parent, name, context, attrs),
+                    context, attrs);
+        }
+    }
+
+    /**
+     * Private factory is step three for Activity Inflation, this is what is attached to the
+     * Activity on HC+ devices.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private static class PrivateWrapperFactory2 extends WrapperFactory2 {
+
+        private final CalligraphyLayoutInflater mInflater;
+
+        public PrivateWrapperFactory2(Factory2 factory2, CalligraphyLayoutInflater inflater, CalligraphyFactory calligraphyFactory) {
+            super(factory2, calligraphyFactory);
+            mInflater = inflater;
+        }
+
+        @Override
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            return mCalligraphyFactory.onViewCreated(
+                    mInflater.createCustomViewInternal(parent,
+                            mFactory2.onCreateView(parent, name, context, attrs),
+                            name, context, attrs
+                    ),
+                    context, attrs
+            );
+        }
+    }
+
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java
new file mode 100644
index 0000000..debdd3e
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyTypefaceSpan.java
@@ -0,0 +1,44 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.text.TextPaint;
+import android.text.style.MetricAffectingSpan;
+
+public class CalligraphyTypefaceSpan extends MetricAffectingSpan {
+    private final Typeface typeface;
+
+    public CalligraphyTypefaceSpan(final Typeface typeface) {
+        if (typeface == null) {
+            throw new IllegalArgumentException("typeface is null");
+        }
+        
+        this.typeface = typeface;
+    }
+
+    @Override
+    public void updateDrawState(final TextPaint drawState) {
+        apply(drawState);
+    }
+
+    @Override
+    public void updateMeasureState(final TextPaint paint) {
+        apply(paint);
+    }
+
+    private void apply(final Paint paint) {
+        final Typeface oldTypeface = paint.getTypeface();
+        final int oldStyle = oldTypeface != null ? oldTypeface.getStyle() : 0;
+        final int fakeStyle = oldStyle & ~typeface.getStyle();
+
+        if ((fakeStyle & Typeface.BOLD) != 0) {
+            paint.setFakeBoldText(true);
+        }
+
+        if ((fakeStyle & Typeface.ITALIC) != 0) {
+            paint.setTextSkewX(-0.25f);
+        }
+
+        paint.setTypeface(typeface);
+    }
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java
new file mode 100644
index 0000000..11737bf
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/CalligraphyUtils.java
@@ -0,0 +1,335 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.text.Editable;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.widget.TextView;
+
+/**
+ * Created by chris on 20/12/2013
+ * Project: Calligraphy
+ */
+public final class CalligraphyUtils {
+
+    /**
+     * Applies a custom typeface span to the text.
+     *
+     * @param s        text to apply it too.
+     * @param typeface typeface to apply.
+     * @return Either the passed in Object or new Spannable with the typeface span applied.
+     */
+    public static CharSequence applyTypefaceSpan(CharSequence s, Typeface typeface) {
+        if (s != null && s.length() > 0) {
+            if (!(s instanceof Spannable)) {
+                s = new SpannableString(s);
+            }
+            ((Spannable) s).setSpan(TypefaceUtils.getSpan(typeface), 0, s.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+        return s;
+    }
+
+    /**
+     * Applies a Typeface to a TextView.
+     * Defaults to false for deferring, if you are having issues with the textview keeping
+     * the custom Typeface, use
+     * {@link #applyFontToTextView(android.widget.TextView, android.graphics.Typeface, boolean)}
+     *
+     * @param textView Not null, TextView or child of.
+     * @param typeface Not null, Typeface to apply to the TextView.
+     * @return true if applied otherwise false.
+     * @see #applyFontToTextView(android.widget.TextView, android.graphics.Typeface, boolean)
+     */
+    public static boolean applyFontToTextView(final TextView textView, final Typeface typeface) {
+        return applyFontToTextView(textView, typeface, false);
+    }
+
+    /**
+     * Applies a Typeface to a TextView, if deferred,its recommend you don't call this multiple
+     * times, as this adds a TextWatcher.
+     *
+     * Deferring should really only be used on tricky views which get Typeface set by the system at
+     * weird times.
+     *
+     * @param textView Not null, TextView or child of.
+     * @param typeface Not null, Typeface to apply to the TextView.
+     * @param deferred If true we use Typefaces and TextChange listener to make sure font is always
+     *                 applied, but this sometimes conflicts with other
+     *                 {@link android.text.Spannable}'s.
+     * @return true if applied otherwise false.
+     * @see #applyFontToTextView(android.widget.TextView, android.graphics.Typeface)
+     */
+    public static boolean applyFontToTextView(final TextView textView, final Typeface typeface, boolean deferred) {
+        if (textView == null || typeface == null) return false;
+        textView.setPaintFlags(textView.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG);
+        textView.setTypeface(typeface);
+        if (deferred) {
+            textView.setText(applyTypefaceSpan(textView.getText(), typeface), TextView.BufferType.SPANNABLE);
+            textView.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    applyTypefaceSpan(s, typeface);
+                }
+            });
+        }
+        return true;
+    }
+
+    /**
+     * Useful for manually fonts to a TextView. Will not default back to font
+     * set in {@link uk.co.chrisjenx.calligraphy.CalligraphyConfig}
+     *
+     * @param context  Context
+     * @param textView Not null, TextView to apply to.
+     * @param filePath if null/empty will do nothing.
+     * @return true if fonts been applied
+     */
+    public static boolean applyFontToTextView(final Context context, final TextView textView, final String filePath) {
+        return applyFontToTextView(context, textView, filePath, false);
+    }
+
+    static boolean applyFontToTextView(final Context context, final TextView textView, final String filePath, boolean deferred) {
+        if (textView == null || context == null) return false;
+        final AssetManager assetManager = context.getAssets();
+        final Typeface typeface = TypefaceUtils.load(assetManager, filePath);
+        return applyFontToTextView(textView, typeface, deferred);
+    }
+
+    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config) {
+        applyFontToTextView(context, textView, config, false);
+    }
+
+    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, boolean deferred) {
+        if (context == null || textView == null || config == null) return;
+        if (!config.isFontSet()) return;
+        applyFontToTextView(context, textView, config.getFontPath(), deferred);
+    }
+
+    /**
+     * Applies font to TextView. Will fall back to the default one if not set.
+     *
+     * @param context      context
+     * @param textView     textView to apply to.
+     * @param config       Default Config
+     * @param textViewFont nullable, will use Default Config if null or fails to find the
+     *                     defined font.
+     */
+    public static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, final String textViewFont) {
+        applyFontToTextView(context, textView, config, textViewFont, false);
+    }
+
+    static void applyFontToTextView(final Context context, final TextView textView, final CalligraphyConfig config, final String textViewFont, boolean deferred) {
+        if (context == null || textView == null || config == null) return;
+        if (!TextUtils.isEmpty(textViewFont) && applyFontToTextView(context, textView, textViewFont, deferred)) {
+            return;
+        }
+        applyFontToTextView(context, textView, config, deferred);
+    }
+
+    /**
+     * Tries to pull the Custom Attribute directly from the TextView.
+     *
+     * @param context     Activity Context
+     * @param attrs       View Attributes
+     * @param attributeId if -1 returns null.
+     * @return null if attribute is not defined or added to View
+     */
+    static String pullFontPathFromView(Context context, AttributeSet attrs, int attributeId) {
+        if (attributeId == -1 || attrs == null)
+            return null;
+
+        final String attributeName;
+        try {
+            attributeName = context.getResources().getResourceEntryName(attributeId);
+        } catch (Resources.NotFoundException e) {
+            // invalid attribute ID
+            return null;
+        }
+
+        final int stringResourceId = attrs.getAttributeResourceValue(null, attributeName, -1);
+        return stringResourceId > 0
+                ? context.getString(stringResourceId)
+                : attrs.getAttributeValue(null, attributeName);
+    }
+
+    /**
+     * Tries to pull the Font Path from the View Style as this is the next decendent after being
+     * defined in the View's xml.
+     *
+     * @param context     Activity Activity Context
+     * @param attrs       View Attributes
+     * @param attributeId if -1 returns null.
+     * @return null if attribute is not defined or found in the Style
+     */
+    static String pullFontPathFromStyle(Context context, AttributeSet attrs, int attributeId) {
+        if (attributeId == -1 || attrs == null)
+            return null;
+        final TypedArray typedArray = context.obtainStyledAttributes(attrs, new int[]{attributeId});
+        if (typedArray != null) {
+            try {
+                // First defined attribute
+                String fontFromAttribute = typedArray.getString(0);
+                if (!TextUtils.isEmpty(fontFromAttribute)) {
+                    return fontFromAttribute;
+                }
+            } catch (Exception ignore) {
+                // Failed for some reason.
+            } finally {
+                typedArray.recycle();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Tries to pull the Font Path from the Text Appearance.
+     *
+     * @param context     Activity Context
+     * @param attrs       View Attributes
+     * @param attributeId if -1 returns null.
+     * @return returns null if attribute is not defined or if no TextAppearance is found.
+     */
+    static String pullFontPathFromTextAppearance(final Context context, AttributeSet attrs, int attributeId) {
+        if (attributeId == -1 || attrs == null) {
+            return null;
+        }
+
+        int textAppearanceId = -1;
+        final TypedArray typedArrayAttr = context.obtainStyledAttributes(attrs, new int[]{android.R.attr.textAppearance});
+        if (typedArrayAttr != null) {
+            try {
+                textAppearanceId = typedArrayAttr.getResourceId(0, -1);
+            } catch (Exception ignored) {
+                // Failed for some reason
+                return null;
+            } finally {
+                typedArrayAttr.recycle();
+            }
+        }
+
+        final TypedArray textAppearanceAttrs = context.obtainStyledAttributes(textAppearanceId, new int[]{attributeId});
+        if (textAppearanceAttrs != null) {
+            try {
+                return textAppearanceAttrs.getString(0);
+            } catch (Exception ignore) {
+                // Failed for some reason.
+                return null;
+            } finally {
+                textAppearanceAttrs.recycle();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Last but not least, try to pull the Font Path from the Theme, which is defined.
+     *
+     * @param context     Activity Context
+     * @param styleAttrId Theme style id
+     * @param attributeId if -1 returns null.
+     * @return null if no theme or attribute defined.
+     */
+    static String pullFontPathFromTheme(Context context, int styleAttrId, int attributeId) {
+        if (styleAttrId == -1 || attributeId == -1)
+            return null;
+
+        final Resources.Theme theme = context.getTheme();
+        final TypedValue value = new TypedValue();
+
+        theme.resolveAttribute(styleAttrId, value, true);
+        final TypedArray typedArray = theme.obtainStyledAttributes(value.resourceId, new int[]{attributeId});
+        try {
+            String font = typedArray.getString(0);
+            return font;
+        } catch (Exception ignore) {
+            // Failed for some reason.
+            return null;
+        } finally {
+            typedArray.recycle();
+        }
+    }
+
+    /**
+     * Last but not least, try to pull the Font Path from the Theme, which is defined.
+     *
+     * @param context        Activity Context
+     * @param styleAttrId    Theme style id
+     * @param subStyleAttrId the sub style from the theme to look up after the first style
+     * @param attributeId    if -1 returns null.
+     * @return null if no theme or attribute defined.
+     */
+    static String pullFontPathFromTheme(Context context, int styleAttrId, int subStyleAttrId, int attributeId) {
+        if (styleAttrId == -1 || attributeId == -1)
+            return null;
+
+        final Resources.Theme theme = context.getTheme();
+        final TypedValue value = new TypedValue();
+
+        theme.resolveAttribute(styleAttrId, value, true);
+        int subStyleResId = -1;
+        final TypedArray parentTypedArray = theme.obtainStyledAttributes(value.resourceId, new int[]{subStyleAttrId});
+        try {
+            subStyleResId = parentTypedArray.getResourceId(0, -1);
+        } catch (Exception ignore) {
+            // Failed for some reason.
+            return null;
+        } finally {
+            parentTypedArray.recycle();
+        }
+
+        if (subStyleResId == -1) return null;
+        final TypedArray subTypedArray = context.obtainStyledAttributes(subStyleResId, new int[]{attributeId});
+        if (subTypedArray != null) {
+            try {
+                return subTypedArray.getString(0);
+            } catch (Exception ignore) {
+                // Failed for some reason.
+                return null;
+            } finally {
+                subTypedArray.recycle();
+            }
+        }
+        return null;
+    }
+
+    private static Boolean sToolbarCheck = null;
+
+    /**
+     * See if the user has added appcompat-v7, this is done at runtime, so we only check once.
+     *
+     * @return true if the v7.Toolbar is on the classpath
+     */
+    static boolean canCheckForV7Toolbar() {
+        if (sToolbarCheck == null) {
+            try {
+                Class.forName("android.support.v7.widget.Toolbar");
+                sToolbarCheck = Boolean.TRUE;
+            } catch (ClassNotFoundException e) {
+                sToolbarCheck = Boolean.FALSE;
+            }
+        }
+        return sToolbarCheck;
+    }
+
+    private CalligraphyUtils() {
+    }
+
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/ReflectionUtils.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
new file mode 100644
index 0000000..923a20d
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/ReflectionUtils.java
@@ -0,0 +1,57 @@
+package uk.co.chrisjenx.calligraphy;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Created by chris on 17/12/14.
+ * For Calligraphy.
+ */
+class ReflectionUtils {
+
+    static Field getField(Class clazz, String fieldName) {
+        try {
+            final Field f = clazz.getDeclaredField(fieldName);
+            f.setAccessible(true);
+            return f;
+        } catch (NoSuchFieldException ignored) {
+        }
+        return null;
+    }
+
+    static Object getValue(Field field, Object obj) {
+        try {
+            return field.get(obj);
+        } catch (IllegalAccessException ignored) {
+        }
+        return null;
+    }
+
+    static void setValue(Field field, Object obj, Object value) {
+        try {
+            field.set(obj, value);
+        } catch (IllegalAccessException ignored) {
+        }
+    }
+
+    static Method getMethod(Class clazz, String methodName) {
+        final Method[] methods = clazz.getMethods();
+        for (Method method : methods) {
+            if (method.getName().equals(methodName)) {
+                method.setAccessible(true);
+                return method;
+            }
+        }
+        return null;
+    }
+
+    static void invokeMethod(Object object, Method method, Object... args) {
+        try {
+            if (method == null) return;
+            method.invoke(object, args);
+        } catch (IllegalAccessException | InvocationTargetException ignored) {
+            ignored.printStackTrace();
+        }
+    }
+}
diff --git a/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/TypefaceUtils.java b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/TypefaceUtils.java
new file mode 100644
index 0000000..8ad3a8c
--- /dev/null
+++ b/calligraphy/src/main/src/uk/co/chrisjenx/calligraphy/TypefaceUtils.java
@@ -0,0 +1,78 @@
+package uk.co.chrisjenx.calligraphy;
+
+import android.content.res.AssetManager;
+import android.graphics.Typeface;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A helper loading {@link android.graphics.Typeface} avoiding the leak of the font when loaded
+ * by multiple calls to {@link android.graphics.Typeface#createFromAsset(android.content.res.AssetManager, String)}
+ * on pre-ICS versions.
+ * <p>
+ * More details can be found here https://code.google.com/p/android/issues/detail?id=9904
+ * <p>
+ * Created by Chris Jenkins on 04/09/13.
+ */
+public final class TypefaceUtils {
+
+    private static final Map<String, Typeface> sCachedFonts = new HashMap<String, Typeface>();
+    private static final Map<Typeface, CalligraphyTypefaceSpan> sCachedSpans = new HashMap<Typeface, CalligraphyTypefaceSpan>();
+
+    /**
+     * A helper loading a custom font.
+     *
+     * @param assetManager App's asset manager.
+     * @param filePath     The path of the file.
+     * @return Return {@link android.graphics.Typeface} or null if the path is invalid.
+     */
+    public static Typeface load(final AssetManager assetManager, final String filePath) {
+        synchronized (sCachedFonts) {
+            try {
+                if (!sCachedFonts.containsKey(filePath)) {
+                    final Typeface typeface = Typeface.createFromAsset(assetManager, filePath);
+                    sCachedFonts.put(filePath, typeface);
+                    return typeface;
+                }
+            } catch (Exception e) {
+                Log.w("Calligraphy", "Can't create asset from " + filePath + ". Make sure you have passed in the correct path and file name.", e);
+                sCachedFonts.put(filePath, null);
+                return null;
+            }
+            return sCachedFonts.get(filePath);
+        }
+    }
+
+    /**
+     * A helper loading custom spans so we don't have to keep creating hundreds of spans.
+     *
+     * @param typeface not null typeface
+     * @return will return null of typeface passed in is null.
+     */
+    public static CalligraphyTypefaceSpan getSpan(final Typeface typeface) {
+        if (typeface == null) return null;
+        synchronized (sCachedSpans) {
+            if (!sCachedSpans.containsKey(typeface)) {
+                final CalligraphyTypefaceSpan span = new CalligraphyTypefaceSpan(typeface);
+                sCachedSpans.put(typeface, span);
+                return span;
+            }
+            return sCachedSpans.get(typeface);
+        }
+    }
+
+    /**
+     * Is the passed in typeface one of ours?
+     *
+     * @param typeface nullable, the typeface to check if ours.
+     * @return true if we have loaded it false otherwise.
+     */
+    public static boolean isLoaded(Typeface typeface) {
+        return typeface != null && sCachedFonts.containsValue(typeface);
+    }
+
+    private TypefaceUtils() {
+    }
+}
