diff --git a/src/main/java/org/acra/ACRA.java b/src/main/java/org/acra/ACRA.java
index 1ba6838e..58349570 100644
--- a/src/main/java/org/acra/ACRA.java
+++ b/src/main/java/org/acra/ACRA.java
@@ -17,7 +17,6 @@
 
 import org.acra.annotation.ReportsCrashes;
 import org.acra.log.ACRALog;
-import org.acra.log.HollowLog;
 import org.acra.log.AndroidLogDelegate;
 
 import android.app.Application;
@@ -40,329 +39,361 @@
  */
 public class ACRA {
 
-    public static final boolean DEV_LOGGING = false; // Should be false for
-                                                     // release.
-    public static final String LOG_TAG = ACRA.class.getSimpleName();
-    
-    public static ACRALog log = new AndroidLogDelegate();
-
-    /**
-     * The key of the application default SharedPreference where you can put a
-     * 'true' Boolean value to disable ACRA.
-     */
-    public static final String PREF_DISABLE_ACRA = "acra.disable";
-
-    /**
-     * Alternatively, you can use this key if you prefer your users to have the
-     * checkbox ticked to enable crash reports. If both acra.disable and
-     * acra.enable are set, the value of acra.disable takes over the other.
-     */
-    public static final String PREF_ENABLE_ACRA = "acra.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to disable sending
-     * content of logcat/dropbox. System logs collection is also dependent of
-     * the READ_LOGS permission.
-     */
-    public static final String PREF_ENABLE_SYSTEM_LOGS = "acra.syslog.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to disable sending his
-     * device id. Device ID collection is also dependent of the READ_PHONE_STATE
-     * permission.
-     */
-    public static final String PREF_ENABLE_DEVICE_ID = "acra.deviceid.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to always include his
-     * email address.
-     */
-    public static final String PREF_USER_EMAIL_ADDRESS = "acra.user.email";
-
-    /**
-     * The key of the SharedPreference allowing the user to automatically accept
-     * sending reports.
-     */
-    public static final String PREF_ALWAYS_ACCEPT = "acra.alwaysaccept";
-
-    /**
-     * The version number of the application the last time ACRA was started.
-     * This is used to determine whether unsent reports should be discarded
-     * because they are old and out of date.
-     */
-    public static final String PREF_LAST_VERSION_NR = "acra.lastVersionNr";
-
-    private static Application mApplication;
-
-    // Accessible via ACRA#getErrorReporter().
-    private static ErrorReporter errorReporterSingleton;
-
-    // NB don't convert to a local field because then it could be garbage
-    // collected and then we would have no PreferenceListener.
-    private static OnSharedPreferenceChangeListener mPrefListener;
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     * 
-     * @param app   Your Application class.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app) {
-        final ReportsCrashes reportsCrashes = app.getClass().getAnnotation(ReportsCrashes.class);
-        if (reportsCrashes == null) {
-            log.e(LOG_TAG,
-                    "ACRA#init called but no ReportsCrashes annotation on Application " + app.getPackageName());
-            return;
-        }
-        init(app, new ACRAConfiguration(reportsCrashes));
-    }
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     *
-     * @param app       Your Application class.
-     * @param config    ACRAConfiguration to manually set up ACRA configuration.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app, ACRAConfiguration config) {
-        init(app, config, true);
-    }
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     *
-     * @param app       Your Application class.
-     * @param config    ACRAConfiguration to manually set up ACRA configuration.
-     * @param checkReportsOnApplicationStart    Whether to invoke
-     *     ErrorReporter.checkReportsOnApplicationStart(). Apps which adjust the
-     *     ReportSenders should set this to false and call
-     *     checkReportsOnApplicationStart() themselves to prevent a potential
-     *     race with the SendWorker and list of ReportSenders.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app, ACRAConfiguration config, boolean checkReportsOnApplicationStart){
-
-        if (mApplication != null) {
-            log.w(LOG_TAG, "ACRA#init called more than once. Won't do anything more.");
-            return;
-        }
-        mApplication = app;
-        
-        if (config == null) {
-            log.e(LOG_TAG, "ACRA#init called but no ACRAConfiguration provided");
-            return;
-        }
-        setConfig(config);
-
-        final SharedPreferences prefs = getACRASharedPreferences();
-
-        try {
-            checkCrashResources(config);
-
-            log.d(LOG_TAG, "ACRA is enabled for " + mApplication.getPackageName() + ", initializing...");
-
-            // Initialize ErrorReporter with all required data
-            final boolean enableAcra = !shouldDisableACRA(prefs);
-            final ErrorReporter errorReporter = new ErrorReporter(mApplication, prefs, enableAcra);
-
-            // Append ReportSenders.
-            errorReporter.setDefaultReportSenders();
-
-            errorReporterSingleton = errorReporter;
-
-            // Check for pending reports
-            if (checkReportsOnApplicationStart) {
-                errorReporter.checkReportsOnApplicationStart();
-            }
-
-        } catch (ACRAConfigurationException e) {
-            log.w(LOG_TAG, "Error : ", e);
-        }
-
-        // We HAVE to keep a reference otherwise the listener could be garbage
-        // collected:
-        // http://stackoverflow.com/questions/2542938/sharedpreferences-onsharedpreferencechangelistener-not-being-called-consistently/3104265#3104265
-        mPrefListener = new OnSharedPreferenceChangeListener() {
-
-            @Override
-            public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
-                if (PREF_DISABLE_ACRA.equals(key) || PREF_ENABLE_ACRA.equals(key)) {
-                    final boolean enableAcra = !shouldDisableACRA(sharedPreferences);
-                    getErrorReporter().setEnabled(enableAcra);
-                }
-            }
-        };
-
-        // This listener has to be set after initAcra is called to avoid a
-        // NPE in ErrorReporter.disable() because
-        // the context could be null at this moment.
-        prefs.registerOnSharedPreferenceChangeListener(mPrefListener);
-    }
-
-    /**
-     * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
-     */
-    public static ErrorReporter getErrorReporter() {
-        if (errorReporterSingleton == null) {
-            throw new IllegalStateException("Cannot access ErrorReporter before ACRA#init");
-        }
-        return errorReporterSingleton;
-    }
-
-    
-
-    /**
-     * Check if the application default shared preferences contains true for the
-     * key "acra.disable", do not activate ACRA. Also checks the alternative
-     * opposite setting "acra.enable" if "acra.disable" is not found.
-     * 
-     * @param prefs
-     *            SharedPreferences to check to see whether ACRA should be
-     *            disabled.
-     * @return true if prefs indicate that ACRA should be disabled.
-     */
-    private static boolean shouldDisableACRA(SharedPreferences prefs) {
-        boolean disableAcra = false;
-        try {
-            final boolean enableAcra = prefs.getBoolean(PREF_ENABLE_ACRA, true);
-            disableAcra = prefs.getBoolean(PREF_DISABLE_ACRA, !enableAcra);
-        } catch (Exception e) {
-            // In case of a ClassCastException
-        }
-        return disableAcra;
-    }
-
-    /**
-     * Checks that mandatory configuration items have been provided.
-     * 
-     * @throws ACRAConfigurationException
-     *             if required values are missing.
-     */
-    static void checkCrashResources(ReportsCrashes conf) throws ACRAConfigurationException {
-        switch (conf.mode()) {
-        case TOAST:
-            if (conf.resToastText() == 0) {
-                throw new ACRAConfigurationException(
-                        "TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case NOTIFICATION:
-            if (conf.resNotifTickerText() == 0 || conf.resNotifTitle() == 0 || conf.resNotifText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
-            }
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case DIALOG:
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
+	private static ACRAConfiguration configProxy;
+	public static final boolean DEV_LOGGING = false; // Should be false for
+
+	// Accessible via ACRA#getErrorReporter().
+	private static ErrorReporter errorReporterSingleton;
+
+	public static ACRALog log = new AndroidLogDelegate();
+
+	// release.
+	public static final String LOG_TAG = ACRA.class.getSimpleName();
+
+	private static Application mApplication;
+
+	// NB don't convert to a local field because then it could be garbage
+	// collected and then we would have no PreferenceListener.
+	private static OnSharedPreferenceChangeListener mPrefListener;
+
+	/**
+	 * The key of the SharedPreference allowing the user to automatically accept
+	 * sending reports.
+	 */
+	public static final String PREF_ALWAYS_ACCEPT = "acra.alwaysaccept";
+
+	/**
+	 * The key of the application default SharedPreference where you can put a
+	 * 'true' Boolean value to disable ACRA.
+	 */
+	public static final String PREF_DISABLE_ACRA = "acra.disable";
+
+	/**
+	 * Alternatively, you can use this key if you prefer your users to have the
+	 * checkbox ticked to enable crash reports. If both acra.disable and
+	 * acra.enable are set, the value of acra.disable takes over the other.
+	 */
+	public static final String PREF_ENABLE_ACRA = "acra.enable";
+
+	/**
+	 * The key of the SharedPreference allowing the user to disable sending his
+	 * device id. Device ID collection is also dependent of the READ_PHONE_STATE
+	 * permission.
+	 */
+	public static final String PREF_ENABLE_DEVICE_ID = "acra.deviceid.enable";
+
+	/**
+	 * The key of the SharedPreference allowing the user to disable sending
+	 * content of logcat/dropbox. System logs collection is also dependent of
+	 * the READ_LOGS permission.
+	 */
+	public static final String PREF_ENABLE_SYSTEM_LOGS = "acra.syslog.enable";
+
+	/**
+	 * The version number of the application the last time ACRA was started.
+	 * This is used to determine whether unsent reports should be discarded
+	 * because they are old and out of date.
+	 */
+	public static final String PREF_LAST_VERSION_NR = "acra.lastVersionNr";
+
+	/**
+	 * The key of the SharedPreference allowing the user to always include his
+	 * email address.
+	 */
+	public static final String PREF_USER_EMAIL_ADDRESS = "acra.user.email";
+
+	/**
+	 * Checks that mandatory configuration items have been provided.
+	 * 
+	 * @throws ACRAConfigurationException
+	 *             if required values are missing.
+	 */
+	static void checkCrashResources(ReportsCrashes conf)
+			throws ACRAConfigurationException {
+		switch (conf.mode()) {
+		case TOAST:
+			if (conf.resToastText() == 0) {
+				throw new ACRAConfigurationException(
+						"TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
+			}
+			break;
+		case NOTIFICATION:
+			if (conf.resNotifTickerText() == 0 || conf.resNotifTitle() == 0
+					|| conf.resNotifText() == 0) {
+				throw new ACRAConfigurationException(
+						"NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
+			}
+			if (CrashReportDialog.class.equals(conf.reportDialogClass())
+					&& conf.resDialogText() == 0) {
+				throw new ACRAConfigurationException(
+						"NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+			}
+			break;
+		case DIALOG:
+			if (CrashReportDialog.class.equals(conf.reportDialogClass())
+					&& conf.resDialogText() == 0) {
+				throw new ACRAConfigurationException(
+						"DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+			}
+			break;
+		case DIALOG_EMAIL:
+			if (CrashReportDialog.class.equals(conf.reportDialogClass())
+					&& conf.mailTo().trim().length() == 0
+					&& conf.resDialogText() == 0) {
+				throw new ACRAConfigurationException(
+						"DIALOG_EMAIL mode: using the (default) CrashReportDialog requires you to define the mailTo and resDialogText parameter in your application @ReportsCrashes() annotation.");
+			}
+			break;
 		default:
 			break;
-        }
-    }
-
-    /**
-     * Retrieves the {@link SharedPreferences} instance where user adjustable
-     * settings for ACRA are stored. Default are the Application default
-     * SharedPreferences, but you can provide another SharedPreferences name
-     * with {@link ReportsCrashes#sharedPreferencesName()}.
-     * 
-     * @return The Shared Preferences where ACRA will retrieve its user
-     *         adjustable setting.
-     */
-    public static SharedPreferences getACRASharedPreferences() {
-        ReportsCrashes conf = getConfig();
-        if (!"".equals(conf.sharedPreferencesName())) {
-            return mApplication.getSharedPreferences(conf.sharedPreferencesName(), conf.sharedPreferencesMode());
-        } else {
-            return PreferenceManager.getDefaultSharedPreferences(mApplication);
-        }
-    }
-
-    /**
-     * Provides the current ACRA configuration.
-     * 
-     * @return Current ACRA {@link ReportsCrashes} configuration instance.
-     */
-    public static ACRAConfiguration getConfig() {
-        if (configProxy == null) {
-            if (mApplication == null) {
-                log.w(LOG_TAG,
-                        "Calling ACRA.getConfig() before ACRA.init() gives you an empty configuration instance. You might prefer calling ACRA.getNewDefaultConfig(Application) to get an instance with default values taken from a @ReportsCrashes annotation.");
-            }
-            configProxy = getNewDefaultConfig(mApplication);
-        }
-        return configProxy;
-    }
-
-    /**
-     * Sets the whole ACRA configuration.
-     * 
-     * @param conf
-     *            ACRAConfiguration to use as a proxy for config info.
-     */
-    public static void setConfig(ACRAConfiguration conf) {
-        configProxy = conf;
-    }
-
-    /**
-     * @param app       Your Application class.
-     * @return new {@link ACRAConfiguration} instance with values initialized
-     *         from the {@link ReportsCrashes} annotation.
-     */
-    public static ACRAConfiguration getNewDefaultConfig(Application app) {
-        if(app != null) {
-            return new ACRAConfiguration(app.getClass().getAnnotation(ReportsCrashes.class));
-        } else {
-            return new ACRAConfiguration(null);
-        }
-    }
-
-    private static ACRAConfiguration configProxy;
-
-    /**
-     * Returns true if the application is debuggable.
-     * 
-     * @return true if the application is debuggable.
-     */
-    static boolean isDebuggable() {
-        PackageManager pm = mApplication.getPackageManager();
-        try {
-            return ((pm.getApplicationInfo(mApplication.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0);
-        } catch (NameNotFoundException e) {
-            return false;
-        }
-    }
-    
-    static Application getApplication() {
-        return mApplication;
-    }
-
-    public static void setLog(ACRALog log) {
-        if (log == null) {
-            throw new NullPointerException("ACRALog cannot be null");
-        }
-        ACRA.log = log;
-    }
+		}
+	}
+
+	/**
+	 * Retrieves the {@link SharedPreferences} instance where user adjustable
+	 * settings for ACRA are stored. Default are the Application default
+	 * SharedPreferences, but you can provide another SharedPreferences name
+	 * with {@link ReportsCrashes#sharedPreferencesName()}.
+	 * 
+	 * @return The Shared Preferences where ACRA will retrieve its user
+	 *         adjustable setting.
+	 */
+	public static SharedPreferences getACRASharedPreferences() {
+		ReportsCrashes conf = getConfig();
+		if (!"".equals(conf.sharedPreferencesName())) {
+			return mApplication.getSharedPreferences(
+					conf.sharedPreferencesName(), conf.sharedPreferencesMode());
+		} else {
+			return PreferenceManager.getDefaultSharedPreferences(mApplication);
+		}
+	}
+
+	static Application getApplication() {
+		return mApplication;
+	}
+
+	/**
+	 * Provides the current ACRA configuration.
+	 * 
+	 * @return Current ACRA {@link ReportsCrashes} configuration instance.
+	 */
+	public static ACRAConfiguration getConfig() {
+		if (configProxy == null) {
+			if (mApplication == null) {
+				log.w(LOG_TAG,
+						"Calling ACRA.getConfig() before ACRA.init() gives you an empty configuration instance. You might prefer calling ACRA.getNewDefaultConfig(Application) to get an instance with default values taken from a @ReportsCrashes annotation.");
+			}
+			configProxy = getNewDefaultConfig(mApplication);
+		}
+		return configProxy;
+	}
+
+	/**
+	 * @return the current instance of ErrorReporter.
+	 * @throws IllegalStateException
+	 *             if {@link ACRA#init(android.app.Application)} has not yet
+	 *             been called.
+	 */
+	public static ErrorReporter getErrorReporter() {
+		if (errorReporterSingleton == null) {
+			throw new IllegalStateException(
+					"Cannot access ErrorReporter before ACRA#init");
+		}
+		return errorReporterSingleton;
+	}
+
+	/**
+	 * @param app
+	 *            Your Application class.
+	 * @return new {@link ACRAConfiguration} instance with values initialized
+	 *         from the {@link ReportsCrashes} annotation.
+	 */
+	public static ACRAConfiguration getNewDefaultConfig(Application app) {
+		if (app != null) {
+			return new ACRAConfiguration(app.getClass().getAnnotation(
+					ReportsCrashes.class));
+		} else {
+			return new ACRAConfiguration(null);
+		}
+	}
+
+	/**
+	 * <p>
+	 * Initialize ACRA for a given Application. The call to this method should
+	 * be placed as soon as possible in the {@link Application#onCreate()}
+	 * method.
+	 * </p>
+	 * 
+	 * @param app
+	 *            Your Application class.
+	 * @throws IllegalStateException
+	 *             if it is called more than once.
+	 */
+	public static void init(Application app) {
+		final ReportsCrashes reportsCrashes = app.getClass().getAnnotation(
+				ReportsCrashes.class);
+		if (reportsCrashes == null) {
+			log.e(LOG_TAG,
+					"ACRA#init called but no ReportsCrashes annotation on Application "
+							+ app.getPackageName());
+			return;
+		}
+		init(app, new ACRAConfiguration(reportsCrashes));
+	}
+
+	/**
+	 * <p>
+	 * Initialize ACRA for a given Application. The call to this method should
+	 * be placed as soon as possible in the {@link Application#onCreate()}
+	 * method.
+	 * </p>
+	 *
+	 * @param app
+	 *            Your Application class.
+	 * @param config
+	 *            ACRAConfiguration to manually set up ACRA configuration.
+	 * @throws IllegalStateException
+	 *             if it is called more than once.
+	 */
+	public static void init(Application app, ACRAConfiguration config) {
+		init(app, config, true);
+	}
+
+	/**
+	 * <p>
+	 * Initialize ACRA for a given Application. The call to this method should
+	 * be placed as soon as possible in the {@link Application#onCreate()}
+	 * method.
+	 * </p>
+	 *
+	 * @param app
+	 *            Your Application class.
+	 * @param config
+	 *            ACRAConfiguration to manually set up ACRA configuration.
+	 * @param checkReportsOnApplicationStart
+	 *            Whether to invoke
+	 *            ErrorReporter.checkReportsOnApplicationStart(). Apps which
+	 *            adjust the ReportSenders should set this to false and call
+	 *            checkReportsOnApplicationStart() themselves to prevent a
+	 *            potential race with the SendWorker and list of ReportSenders.
+	 * @throws IllegalStateException
+	 *             if it is called more than once.
+	 */
+	public static void init(Application app, ACRAConfiguration config,
+			boolean checkReportsOnApplicationStart) {
+
+		if (mApplication != null) {
+			log.w(LOG_TAG,
+					"ACRA#init called more than once. Won't do anything more.");
+			return;
+		}
+		mApplication = app;
+
+		if (config == null) {
+			log.e(LOG_TAG, "ACRA#init called but no ACRAConfiguration provided");
+			return;
+		}
+		setConfig(config);
+
+		final SharedPreferences prefs = getACRASharedPreferences();
+
+		try {
+			checkCrashResources(config);
+
+			log.d(LOG_TAG,
+					"ACRA is enabled for " + mApplication.getPackageName()
+							+ ", initializing...");
+
+			// Initialize ErrorReporter with all required data
+			final boolean enableAcra = !shouldDisableACRA(prefs);
+			final ErrorReporter errorReporter = new ErrorReporter(mApplication,
+					prefs, enableAcra);
+
+			// Append ReportSenders.
+			errorReporter.setDefaultReportSenders();
+
+			errorReporterSingleton = errorReporter;
+
+			// Check for pending reports
+			if (checkReportsOnApplicationStart) {
+				errorReporter.checkReportsOnApplicationStart();
+			}
+
+		} catch (ACRAConfigurationException e) {
+			log.w(LOG_TAG, "Error : ", e);
+		}
+
+		// We HAVE to keep a reference otherwise the listener could be garbage
+		// collected:
+		// http://stackoverflow.com/questions/2542938/sharedpreferences-onsharedpreferencechangelistener-not-being-called-consistently/3104265#3104265
+		mPrefListener = new OnSharedPreferenceChangeListener() {
+
+			@Override
+			public void onSharedPreferenceChanged(
+					SharedPreferences sharedPreferences, String key) {
+				if (PREF_DISABLE_ACRA.equals(key)
+						|| PREF_ENABLE_ACRA.equals(key)) {
+					final boolean enableAcra = !shouldDisableACRA(sharedPreferences);
+					getErrorReporter().setEnabled(enableAcra);
+				}
+			}
+		};
+
+		// This listener has to be set after initAcra is called to avoid a
+		// NPE in ErrorReporter.disable() because
+		// the context could be null at this moment.
+		prefs.registerOnSharedPreferenceChangeListener(mPrefListener);
+	}
+
+	/**
+	 * Returns true if the application is debuggable.
+	 * 
+	 * @return true if the application is debuggable.
+	 */
+	static boolean isDebuggable() {
+		PackageManager pm = mApplication.getPackageManager();
+		try {
+			return ((pm.getApplicationInfo(mApplication.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0);
+		} catch (NameNotFoundException e) {
+			return false;
+		}
+	}
+
+	/**
+	 * Sets the whole ACRA configuration.
+	 * 
+	 * @param conf
+	 *            ACRAConfiguration to use as a proxy for config info.
+	 */
+	public static void setConfig(ACRAConfiguration conf) {
+		configProxy = conf;
+	}
+
+	public static void setLog(ACRALog log) {
+		if (log == null) {
+			throw new NullPointerException("ACRALog cannot be null");
+		}
+		ACRA.log = log;
+	}
+
+	/**
+	 * Check if the application default shared preferences contains true for the
+	 * key "acra.disable", do not activate ACRA. Also checks the alternative
+	 * opposite setting "acra.enable" if "acra.disable" is not found.
+	 * 
+	 * @param prefs
+	 *            SharedPreferences to check to see whether ACRA should be
+	 *            disabled.
+	 * @return true if prefs indicate that ACRA should be disabled.
+	 */
+	private static boolean shouldDisableACRA(SharedPreferences prefs) {
+		boolean disableAcra = false;
+		try {
+			final boolean enableAcra = prefs.getBoolean(PREF_ENABLE_ACRA, true);
+			disableAcra = prefs.getBoolean(PREF_DISABLE_ACRA, !enableAcra);
+		} catch (Exception e) {
+			// In case of a ClassCastException
+		}
+		return disableAcra;
+	}
 }
diff --git a/src/main/java/org/acra/ACRAConfigurationException.java b/src/main/java/org/acra/ACRAConfigurationException.java
index 55a27f3b..43c46b77 100644
--- a/src/main/java/org/acra/ACRAConfigurationException.java
+++ b/src/main/java/org/acra/ACRAConfigurationException.java
@@ -22,9 +22,9 @@
  */
 public class ACRAConfigurationException extends Exception {
 
-    private static final long serialVersionUID = -7355339673505996110L;
+	private static final long serialVersionUID = -7355339673505996110L;
 
-    public ACRAConfigurationException(String msg) {
-        super(msg);
-    }
+	public ACRAConfigurationException(String msg) {
+		super(msg);
+	}
 }
diff --git a/src/main/java/org/acra/ACRAConstants.java b/src/main/java/org/acra/ACRAConstants.java
index d34f3acf..3516e59f 100644
--- a/src/main/java/org/acra/ACRAConstants.java
+++ b/src/main/java/org/acra/ACRAConstants.java
@@ -15,10 +15,40 @@
  */
 package org.acra;
 
+import static org.acra.ReportField.ANDROID_VERSION;
+import static org.acra.ReportField.APP_VERSION_CODE;
+import static org.acra.ReportField.APP_VERSION_NAME;
+import static org.acra.ReportField.AVAILABLE_MEM_SIZE;
+import static org.acra.ReportField.BRAND;
+import static org.acra.ReportField.BUILD;
+import static org.acra.ReportField.BUILD_CONFIG;
+import static org.acra.ReportField.CRASH_CONFIGURATION;
+import static org.acra.ReportField.CUSTOM_DATA;
+import static org.acra.ReportField.DEVICE_FEATURES;
+import static org.acra.ReportField.DISPLAY;
+import static org.acra.ReportField.DUMPSYS_MEMINFO;
+import static org.acra.ReportField.ENVIRONMENT;
+import static org.acra.ReportField.FILE_PATH;
+import static org.acra.ReportField.INITIAL_CONFIGURATION;
+import static org.acra.ReportField.INSTALLATION_ID;
+import static org.acra.ReportField.IS_SILENT;
+import static org.acra.ReportField.LOGCAT;
+import static org.acra.ReportField.PACKAGE_NAME;
+import static org.acra.ReportField.PHONE_MODEL;
+import static org.acra.ReportField.PRODUCT;
+import static org.acra.ReportField.REPORT_ID;
+import static org.acra.ReportField.SETTINGS_GLOBAL;
+import static org.acra.ReportField.SETTINGS_SECURE;
+import static org.acra.ReportField.SETTINGS_SYSTEM;
+import static org.acra.ReportField.SHARED_PREFERENCES;
+import static org.acra.ReportField.STACK_TRACE;
+import static org.acra.ReportField.TOTAL_MEM_SIZE;
+import static org.acra.ReportField.USER_APP_START_DATE;
+import static org.acra.ReportField.USER_COMMENT;
+import static org.acra.ReportField.USER_CRASH_DATE;
+import static org.acra.ReportField.USER_EMAIL;
 import android.content.Context;
 
-import static org.acra.ReportField.*;
-
 /**
  * Responsible for collating those constants shared among the ACRA components.
  * 
@@ -27,128 +57,134 @@
  */
 public final class ACRAConstants {
 
-    public static final String REPORTFILE_EXTENSION = ".stacktrace";
-
-    /**
-     * Suffix to be added to report files when they have been approved by the
-     * user in NOTIFICATION mode
-     */
-    static final String APPROVED_SUFFIX = "-approved";
-    /**
-     * This key is used to store the silent state of a report sent by
-     * handleSilentException().
-     */
-    static final String SILENT_SUFFIX = "-" + IS_SILENT;
-    /**
-     * This is the number of previously stored reports that we send in
-     * {@link SendWorker#checkAndSendReports(android.content.Context, boolean)}.
-     * The number of reports is limited to avoid ANR on application start.
-     */
-    static final int MAX_SEND_REPORTS = 5;
-
-    /**
-     * Used in the intent starting CrashReportDialog to provide the name of the
-     * latest generated report file in order to be able to associate the user
-     * comment.
-     */
-    public static final String EXTRA_REPORT_FILE_NAME = "REPORT_FILE_NAME";
-    /**
-     * Used in the intent starting CrashReportDialog to provide the Exception that caused the crash.
-     *
-     * This can be used by any BaseCrashReportDialog subclass to custom the dialog.
-     */
-    public static final String EXTRA_REPORT_EXCEPTION = "REPORT_EXCEPTION";
+	public static final String REPORTFILE_EXTENSION = ".stacktrace";
 
-    /**
-     * Set this extra to true to force the deletion of reports by the
-     * {@link CrashReportDialog} activity.
-     */
-    protected static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
-    /**
-     * This is the identifier (value = 666) use for the status bar notification
-     * issued when crashes occur.
-     */
-    static final int NOTIF_CRASH_ID = 666;
-    /**
-     * Number of milliseconds to wait after displaying a toast.
-     */
-    static final int TOAST_WAIT_DURATION = 2000;
+	/**
+	 * Suffix to be added to report files when they have been approved by the
+	 * user in NOTIFICATION mode
+	 */
+	static final String APPROVED_SUFFIX = "-approved";
+	/**
+	 * This key is used to store the silent state of a report sent by
+	 * handleSilentException().
+	 */
+	static final String SILENT_SUFFIX = "-" + IS_SILENT;
+	/**
+	 * This is the number of previously stored reports that we send in
+	 * {@link SendWorker#checkAndSendReports(android.content.Context, boolean)}.
+	 * The number of reports is limited to avoid ANR on application start.
+	 */
+	static final int MAX_SEND_REPORTS = 5;
 
-    /**
-     * A special String value to allow the usage of a pseudo-null default value
-     * in annotation parameters.
-     */
-    public static final String NULL_VALUE = "ACRA-NULL-STRING";
+	/**
+	 * Used in the intent starting CrashReportDialog to provide the name of the
+	 * latest generated report file in order to be able to associate the user
+	 * comment.
+	 */
+	public static final String EXTRA_REPORT_FILE_NAME = "REPORT_FILE_NAME";
+	/**
+	 * Used in the intent starting CrashReportDialog to provide the Exception
+	 * that caused the crash.
+	 *
+	 * This can be used by any BaseCrashReportDialog subclass to custom the
+	 * dialog.
+	 */
+	public static final String EXTRA_REPORT_EXCEPTION = "REPORT_EXCEPTION";
 
-    public static final boolean DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST = false;
+	/**
+	 * Set this extra to true to force the deletion of reports by the
+	 * {@link CrashReportDialog} activity.
+	 */
+	protected static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
+	/**
+	 * This is the identifier (value = 666) use for the status bar notification
+	 * issued when crashes occur.
+	 */
+	static final int NOTIF_CRASH_ID = 666;
+	/**
+	 * Number of milliseconds to wait after displaying a toast.
+	 */
+	static final int TOAST_WAIT_DURATION = 2000;
 
-    public static final int DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES = 3;
+	/**
+	 * A special String value to allow the usage of a pseudo-null default value
+	 * in annotation parameters.
+	 */
+	public static final String NULL_VALUE = "ACRA-NULL-STRING";
 
-    public static final int DEFAULT_SOCKET_TIMEOUT = 5000;
+	public static final boolean DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST = false;
 
-    public static final int DEFAULT_CONNECTION_TIMEOUT = 3000;
+	public static final int DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES = 3;
 
-    public static final boolean DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START = true;
+	public static final int DEFAULT_SOCKET_TIMEOUT = 5000;
 
-    public static final boolean DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START = true;
+	public static final int DEFAULT_CONNECTION_TIMEOUT = 3000;
 
-    public static final int DEFAULT_DROPBOX_COLLECTION_MINUTES = 5;
+	public static final boolean DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START = true;
 
-    public static final boolean DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS = false;
+	public static final boolean DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START = true;
 
-    public static final int DEFAULT_SHARED_PREFERENCES_MODE = Context.MODE_PRIVATE;
+	public static final int DEFAULT_DROPBOX_COLLECTION_MINUTES = 5;
 
-    public static final int DEFAULT_NOTIFICATION_ICON = android.R.drawable.stat_notify_error;
+	public static final boolean DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS = false;
 
-    public static final int DEFAULT_DIALOG_ICON = android.R.drawable.ic_dialog_alert;
+	public static final int DEFAULT_SHARED_PREFERENCES_MODE = Context.MODE_PRIVATE;
 
-    public static final int DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT = android.R.string.ok;
+	public static final int DEFAULT_NOTIFICATION_ICON = android.R.drawable.stat_notify_error;
 
-    public static final int DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT = android.R.string.cancel;
+	public static final int DEFAULT_DIALOG_ICON = android.R.drawable.ic_dialog_alert;
 
-    public static final int DEFAULT_RES_VALUE = 0;
+	public static final int DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT = android.R.string.ok;
 
-    public static final String DEFAULT_STRING_VALUE = "";
+	public static final int DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT = android.R.string.cancel;
 
-    public static final int DEFAULT_LOGCAT_LINES = 100;
+	public static final int DEFAULT_RES_VALUE = 0;
 
-    public static final int DEFAULT_BUFFER_SIZE_IN_BYTES = 8192;
+	public static final String DEFAULT_STRING_VALUE = "";
 
-    public static final boolean DEFAULT_LOGCAT_FILTER_BY_PID = false;
+	public static final int DEFAULT_LOGCAT_LINES = 100;
 
-    public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
+	public static final int DEFAULT_BUFFER_SIZE_IN_BYTES = 8192;
 
-    public static final boolean DEFAULT_SEND_REPORTS_AT_SHUTDOWN = true;
+	public static final boolean DEFAULT_LOGCAT_FILTER_BY_PID = false;
 
-    public static final String DEFAULT_APPLICATION_LOGFILE = DEFAULT_STRING_VALUE;
+	public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
 
-    public static final int DEFAULT_APPLICATION_LOGFILE_LINES = DEFAULT_LOGCAT_LINES;
+	public static final boolean DEFAULT_SEND_REPORTS_AT_SHUTDOWN = true;
 
-    public static final boolean DEFAULT_DISABLE_SSL_CERT_VALIDATION = false;
+	public static final String DEFAULT_APPLICATION_LOGFILE = DEFAULT_STRING_VALUE;
 
-    public static final String DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS = "org.acra.util.DefaultHttpsSocketFactoryFactory";
+	public static final int DEFAULT_APPLICATION_LOGFILE_LINES = DEFAULT_LOGCAT_LINES;
 
-    /**
-     * Default list of {@link ReportField}s to be sent in email reports. You can
-     * set your own list with
-     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
-     * 
-     * @see org.acra.annotation.ReportsCrashes#mailTo()
-     */
-    public final static ReportField[] DEFAULT_MAIL_REPORT_FIELDS = { USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME,
-            BRAND, PHONE_MODEL, CUSTOM_DATA, STACK_TRACE };
+	public static final boolean DEFAULT_DISABLE_SSL_CERT_VALIDATION = false;
+
+	public static final String DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS = "org.acra.util.DefaultHttpsSocketFactoryFactory";
+
+	/**
+	 * Default list of {@link ReportField}s to be sent in email reports. You can
+	 * set your own list with
+	 * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
+	 * 
+	 * @see org.acra.annotation.ReportsCrashes#mailTo()
+	 */
+	public final static ReportField[] DEFAULT_MAIL_REPORT_FIELDS = {
+			USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME, BRAND,
+			PHONE_MODEL, CUSTOM_DATA, STACK_TRACE };
 
-    /**
-     * Default list of {@link ReportField}s to be sent in reports. You can set
-     * your own list with
-     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
-     */
-    public static final ReportField[] DEFAULT_REPORT_FIELDS = { REPORT_ID, APP_VERSION_CODE, APP_VERSION_NAME,
-            PACKAGE_NAME, FILE_PATH, PHONE_MODEL, BRAND, PRODUCT, ANDROID_VERSION, BUILD, TOTAL_MEM_SIZE,
-            AVAILABLE_MEM_SIZE, BUILD_CONFIG, CUSTOM_DATA, IS_SILENT, STACK_TRACE, INITIAL_CONFIGURATION, CRASH_CONFIGURATION,
-            DISPLAY, USER_COMMENT, USER_EMAIL, USER_APP_START_DATE, USER_CRASH_DATE, DUMPSYS_MEMINFO, LOGCAT,
-            INSTALLATION_ID, DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES, SETTINGS_SYSTEM, SETTINGS_SECURE,
-            SETTINGS_GLOBAL };
+	/**
+	 * Default list of {@link ReportField}s to be sent in reports. You can set
+	 * your own list with
+	 * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
+	 */
+	public static final ReportField[] DEFAULT_REPORT_FIELDS = { REPORT_ID,
+			APP_VERSION_CODE, APP_VERSION_NAME, PACKAGE_NAME, FILE_PATH,
+			PHONE_MODEL, BRAND, PRODUCT, ANDROID_VERSION, BUILD,
+			TOTAL_MEM_SIZE, AVAILABLE_MEM_SIZE, BUILD_CONFIG, CUSTOM_DATA,
+			IS_SILENT, STACK_TRACE, INITIAL_CONFIGURATION, CRASH_CONFIGURATION,
+			DISPLAY, USER_COMMENT, USER_EMAIL, USER_APP_START_DATE,
+			USER_CRASH_DATE, DUMPSYS_MEMINFO, LOGCAT, INSTALLATION_ID,
+			DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES, SETTINGS_SYSTEM,
+			SETTINGS_SECURE, SETTINGS_GLOBAL };
 
-    public static final String DATE_TIME_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ";
+	public static final String DATE_TIME_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ";
 }
diff --git a/src/main/java/org/acra/BaseCrashReportDialog.java b/src/main/java/org/acra/BaseCrashReportDialog.java
index bc024dbc..c3ae2829 100644
--- a/src/main/java/org/acra/BaseCrashReportDialog.java
+++ b/src/main/java/org/acra/BaseCrashReportDialog.java
@@ -1,90 +1,100 @@
 package org.acra;
 
-import android.app.Activity;
-import android.os.Bundle;
-import android.widget.Toast;
-import org.acra.collector.CrashReportData;
-import org.acra.util.ToastSender;
-
-import java.io.IOException;
-
 import static org.acra.ACRA.LOG_TAG;
 import static org.acra.ReportField.USER_COMMENT;
 import static org.acra.ReportField.USER_EMAIL;
 
+import java.io.IOException;
+
+import org.acra.collector.CrashReportData;
+import org.acra.util.ToastSender;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.widget.Toast;
+
 /**
  * Activity which implements the base functionality for a CrashReportDialog
- * Activities which extend from this class can override onCreate() to create a custom view,
- * but they must call super.onCreate() at the beginning of the method.
+ * Activities which extend from this class can override onCreate() to create a
+ * custom view, but they must call super.onCreate() at the beginning of the
+ * method.
  *
- * The methods sendCrash(comment, usrEmail) and cancelReports() can be used to send or cancel
- * sending of reports respectively.
+ * The methods sendCrash(comment, usrEmail) and cancelReports() can be used to
+ * send or cancel sending of reports respectively.
  *
  * This Activity will be instantiated with 2 arguments:
  * <ol>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_FILE_NAME}</li>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_FILE_NAME}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
  * </ol>
  */
 public abstract class BaseCrashReportDialog extends Activity {
 
-    private String mReportFileName;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ACRA.log.d(LOG_TAG, "CrashReportDialog extras=" + getIntent().getExtras());
+	private String mReportFileName;
 
-        final boolean forceCancel = getIntent().getBooleanExtra(ACRAConstants.EXTRA_FORCE_CANCEL, false);
-        if (forceCancel) {
-            ACRA.log.d(LOG_TAG, "Forced reports deletion.");
-            cancelReports();
-            finish();
-            return;
-        }
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
 
-        mReportFileName = getIntent().getStringExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME);
-        ACRA.log.d(LOG_TAG, "Opening CrashReportDialog for " + mReportFileName);
-        if (mReportFileName == null) {
-            finish();
-        }
-    }
+		ACRA.log.d(LOG_TAG, "CrashReportDialog extras="
+				+ getIntent().getExtras());
 
+		final boolean forceCancel = getIntent().getBooleanExtra(
+				ACRAConstants.EXTRA_FORCE_CANCEL, false);
+		if (forceCancel) {
+			ACRA.log.d(LOG_TAG, "Forced reports deletion.");
+			cancelReports();
+			finish();
+			return;
+		}
 
-    /**
-     * Cancel any pending crash reports
-     */
-    protected void cancelReports() {
-        ACRA.getErrorReporter().deletePendingNonApprovedReports(false);
-    }
+		mReportFileName = getIntent().getStringExtra(
+				ACRAConstants.EXTRA_REPORT_FILE_NAME);
+		ACRA.log.d(LOG_TAG, "Opening CrashReportDialog for " + mReportFileName);
+		if (mReportFileName == null) {
+			finish();
+		}
+	}
 
+	/**
+	 * Cancel any pending crash reports
+	 */
+	protected void cancelReports() {
+		ACRA.getErrorReporter().deletePendingNonApprovedReports(false);
+	}
 
-    /**
-     * Send crash report given user's comment and email address. If none should be empty strings
-     * @param comment       Comment (may be null) provided by the user.
-     * @param userEmail     Email address (may be null) provided by the client.
-     */
-    protected void sendCrash(String comment, String userEmail) {
-        final CrashReportPersister persister = new CrashReportPersister(getApplicationContext());
-        try {
-            ACRA.log.d(LOG_TAG, "Add user comment to " + mReportFileName);
-            final CrashReportData crashData = persister.load(mReportFileName);
-            crashData.put(USER_COMMENT, comment == null ? "" : comment);
-            crashData.put(USER_EMAIL, userEmail == null ? "" : userEmail);
-            persister.store(crashData, mReportFileName);
-        } catch (IOException e) {
-            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
-        }
+	/**
+	 * Send crash report given user's comment and email address. If none should
+	 * be empty strings
+	 * 
+	 * @param comment
+	 *            Comment (may be null) provided by the user.
+	 * @param userEmail
+	 *            Email address (may be null) provided by the client.
+	 */
+	protected void sendCrash(String comment, String userEmail) {
+		final CrashReportPersister persister = new CrashReportPersister(
+				getApplicationContext());
+		try {
+			ACRA.log.d(LOG_TAG, "Add user comment to " + mReportFileName);
+			final CrashReportData crashData = persister.load(mReportFileName);
+			crashData.put(USER_COMMENT, comment == null ? "" : comment);
+			crashData.put(USER_EMAIL, userEmail == null ? "" : userEmail);
+			persister.store(crashData, mReportFileName);
+		} catch (IOException e) {
+			ACRA.log.w(LOG_TAG, "User comment not added: ", e);
+		}
 
-        // Start the report sending task
-        ACRA.log.v(LOG_TAG, "About to start SenderWorker from CrashReportDialog");
-        ACRA.getErrorReporter().startSendingReports(false, true);
+		// Start the report sending task
+		ACRA.log.v(LOG_TAG,
+				"About to start SenderWorker from CrashReportDialog");
+		ACRA.getErrorReporter().startSendingReports(false, true);
 
-        // Optional Toast to thank the user
-        final int toastId = ACRA.getConfig().resDialogOkToast();
-        if (toastId != 0) {
-            ToastSender.sendToast(getApplicationContext(), toastId, Toast.LENGTH_LONG);
-        }
-    }
+		// Optional Toast to thank the user
+		final int toastId = ACRA.getConfig().resDialogOkToast();
+		if (toastId != 0) {
+			ToastSender.sendToast(getApplicationContext(), toastId,
+					Toast.LENGTH_LONG);
+		}
+	}
 }
diff --git a/src/main/java/org/acra/CrashReportDialog.java b/src/main/java/org/acra/CrashReportDialog.java
index 92a3ca42..14cee694 100644
--- a/src/main/java/org/acra/CrashReportDialog.java
+++ b/src/main/java/org/acra/CrashReportDialog.java
@@ -1,170 +1,352 @@
+/**
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *	@edited by Sumeet Gehi
+ */
 package org.acra;
 
-import android.app.AlertDialog;
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.USER_COMMENT;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.acra.collector.CrashReportData;
+import org.acra.sender.ReportSenderException;
+
+import android.annotation.TargetApi;
+import android.content.Context;
 import android.content.DialogInterface;
+import android.content.Intent;
 import android.content.SharedPreferences;
+import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.app.AppCompatDialog;
 import android.text.InputType;
+import android.util.Log;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 import android.widget.EditText;
 import android.widget.LinearLayout;
 import android.widget.ScrollView;
 import android.widget.TextView;
-
+import android.widget.Toast;
 
 /**
  * This is the dialog Activity used by ACRA to get authorization from the user
  * to send reports. Requires android:launchMode="singleInstance" in your
  * AndroidManifest to work properly.
+ * 
+ * and add mailTo parameter in Application class for Email with dialog prompt
+ * mode
+ * 
+ * @author Sumeet Gehi
  **/
-public class CrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener, DialogInterface.OnDismissListener {
-
-    private static final String STATE_EMAIL = "email";
-    private static final String STATE_COMMENT = "comment";
-    private EditText userCommentView;
-    private EditText userEmailView;
-
-    AlertDialog mDialog;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
-        final int titleResourceId = ACRA.getConfig().resDialogTitle();
-        if (titleResourceId != 0) {
-            dialogBuilder.setTitle(titleResourceId);
-        }
-        final int iconResourceId = ACRA.getConfig().resDialogIcon();
-        if (iconResourceId != 0) {
-            dialogBuilder.setIcon(iconResourceId);
-        }
-        dialogBuilder.setView(buildCustomView(savedInstanceState));
-        dialogBuilder.setPositiveButton(getText(ACRA.getConfig().resDialogPositiveButtonText()), CrashReportDialog.this);
-        dialogBuilder.setNegativeButton(getText(ACRA.getConfig().resDialogNegativeButtonText()), CrashReportDialog.this);
-
-        mDialog = dialogBuilder.create();
-        mDialog.setCanceledOnTouchOutside(false);
-        mDialog.setOnDismissListener(this);
-        mDialog.show();
-    }
-
-    protected View buildCustomView(Bundle savedInstanceState) {
-        final LinearLayout root = new LinearLayout(this);
-        root.setOrientation(LinearLayout.VERTICAL);
-        root.setPadding(10, 10, 10, 10);
-        root.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
-        root.setFocusable(true);
-        root.setFocusableInTouchMode(true);
-
-        final ScrollView scroll = new ScrollView(this);
-        root.addView(scroll, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1.0f));
-        final LinearLayout scrollable = new LinearLayout(this);
-        scrollable.setOrientation(LinearLayout.VERTICAL);
-        scroll.addView(scrollable);
-
-        final TextView text = new TextView(this);
-        final int dialogTextId = ACRA.getConfig().resDialogText();
-        if (dialogTextId != 0) {
-            text.setText(getText(dialogTextId));
-        }
-        scrollable.addView(text);
-
-        // Add an optional prompt for user comments
-        final int commentPromptId = ACRA.getConfig().resDialogCommentPrompt();
-        if (commentPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(commentPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,
-                    LayoutParams.WRAP_CONTENT));
-
-            userCommentView = new EditText(this);
-            userCommentView.setLines(2);
-            if (savedInstanceState != null) {
-                String savedValue = savedInstanceState.getString(STATE_COMMENT);
-                if (savedValue != null) {
-                    userCommentView.setText(savedValue);
-                }
-            }
-            scrollable.addView(userCommentView);
-        }
-
-        // Add an optional user email field
-        final int emailPromptId = ACRA.getConfig().resDialogEmailPrompt();
-        if (emailPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(emailPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label);
-
-            userEmailView = new EditText(this);
-            userEmailView.setSingleLine();
-            userEmailView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
-
-            String savedValue = null;
-            if (savedInstanceState != null) {
-                savedValue = savedInstanceState.getString(STATE_EMAIL);
-            }
-            if (savedValue != null) {
-                userEmailView.setText(savedValue);
-            } else {
-                final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-                userEmailView.setText(prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, ""));
-            }
-            scrollable.addView(userEmailView);
-        }
-
-        return root;
-    }
-
-    @Override
-    public void onClick(DialogInterface dialog, int which) {
-        if (which == DialogInterface.BUTTON_POSITIVE) {
-            // Retrieve user comment
-            final String comment = userCommentView != null ? userCommentView.getText().toString() : "";
-
-            // Store the user email
-            final String userEmail;
-            final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-            if (userEmailView != null) {
-                userEmail = userEmailView.getText().toString();
-                final SharedPreferences.Editor prefEditor = prefs.edit();
-                prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS, userEmail);
-                prefEditor.commit();
-            } else {
-                userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "");
-            }
-            sendCrash(comment, userEmail);
-        } else {
-            cancelReports();
-        }
-
-        finish();
-    }
-
-
-    @Override
-    public void onDismiss(DialogInterface dialog) {
-        finish();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (userCommentView != null && userCommentView.getText() != null) {
-            outState.putString(STATE_COMMENT, userCommentView.getText().toString());
-        }
-        if (userEmailView != null && userEmailView.getText() != null) {
-            outState.putString(STATE_EMAIL, userEmailView.getText().toString());
-        }
-    }
+public class CrashReportDialog extends BaseCrashReportDialog implements
+		DialogInterface.OnClickListener, DialogInterface.OnDismissListener {
+
+	private static final String STATE_EMAIL = "email";
+	private static final String STATE_COMMENT = "comment";
+	private EditText userCommentView;
+	private EditText userEmailView;
+
+	AppCompatDialog mDialog;
+	ReportingInteractionMode mode;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+
+		mode = ACRA.getConfig().mode();
+		final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
+		final int titleResourceId = ACRA.getConfig().resDialogTitle();
+		if (titleResourceId != 0) {
+			dialogBuilder.setTitle(titleResourceId);
+		}
+		final int iconResourceId = ACRA.getConfig().resDialogIcon();
+		if (iconResourceId != 0) {
+			dialogBuilder.setIcon(iconResourceId);
+		}
+		dialogBuilder.setView(buildCustomView(savedInstanceState));
+		dialogBuilder.setPositiveButton(getText(ACRA.getConfig()
+				.resDialogPositiveButtonText()), CrashReportDialog.this);
+		dialogBuilder.setNegativeButton(getText(ACRA.getConfig()
+				.resDialogNegativeButtonText()), CrashReportDialog.this);
+
+		mDialog = dialogBuilder.create();
+		mDialog.setCanceledOnTouchOutside(false);
+		mDialog.setOnDismissListener(this);
+		mDialog.show();
+	}
+
+	protected View buildCustomView(Bundle savedInstanceState) {
+		final LinearLayout root = new LinearLayout(this);
+		root.setOrientation(LinearLayout.VERTICAL);
+		root.setPadding(10, 10, 10, 10);
+		root.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,
+				LayoutParams.WRAP_CONTENT));
+		root.setFocusable(true);
+		root.setFocusableInTouchMode(true);
+
+		final ScrollView scroll = new ScrollView(this);
+		root.addView(scroll, new LinearLayout.LayoutParams(
+				LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1.0f));
+		final LinearLayout scrollable = new LinearLayout(this);
+		scrollable.setOrientation(LinearLayout.VERTICAL);
+		scroll.addView(scrollable);
+
+		final TextView text = new TextView(this);
+		final int dialogTextId = ACRA.getConfig().resDialogText();
+		if (dialogTextId != 0) {
+			text.setText(getText(dialogTextId));
+		}
+		scrollable.addView(text);
+
+		// Add an optional prompt for user comments
+		final int commentPromptId = ACRA.getConfig().resDialogCommentPrompt();
+		if (commentPromptId != 0) {
+			final TextView label = new TextView(this);
+			label.setText(getText(commentPromptId));
+
+			label.setPadding(label.getPaddingLeft(), 10,
+					label.getPaddingRight(), label.getPaddingBottom());
+			scrollable.addView(label, new LinearLayout.LayoutParams(
+					LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
+
+			userCommentView = new EditText(this);
+			userCommentView.setLines(2);
+			if (savedInstanceState != null) {
+				String savedValue = savedInstanceState.getString(STATE_COMMENT);
+				if (savedValue != null) {
+					userCommentView.setText(savedValue);
+				}
+			}
+			scrollable.addView(userCommentView);
+		}
+
+		// Add an optional user email field
+		final int emailPromptId = ACRA.getConfig().resDialogEmailPrompt();
+		if (emailPromptId != 0) {
+			final TextView label = new TextView(this);
+			label.setText(getText(emailPromptId));
+
+			label.setPadding(label.getPaddingLeft(), 10,
+					label.getPaddingRight(), label.getPaddingBottom());
+			scrollable.addView(label);
+
+			userEmailView = new EditText(this);
+			userEmailView.setSingleLine();
+			userEmailView.setInputType(InputType.TYPE_CLASS_TEXT
+					| InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+
+			String savedValue = null;
+			if (savedInstanceState != null) {
+				savedValue = savedInstanceState.getString(STATE_EMAIL);
+			}
+			if (savedValue != null) {
+				userEmailView.setText(savedValue);
+			} else {
+				final SharedPreferences prefs = ACRA.getACRASharedPreferences();
+				userEmailView.setText(prefs.getString(
+						ACRA.PREF_USER_EMAIL_ADDRESS, ""));
+			}
+			scrollable.addView(userEmailView);
+		}
+
+		return root;
+	}
+
+	@Override
+	public void onClick(DialogInterface dialog, int which) {
+		if (which == DialogInterface.BUTTON_POSITIVE) {
+			if (mode == ReportingInteractionMode.DIALOG_EMAIL) {
+
+				final String comment = userCommentView != null ? userCommentView
+						.getText().toString() : "";
+				final String email = userEmailView != null ? userEmailView
+						.getText().toString() : "";
+				try {
+					sendEmail(
+							CrashReportDialog.this,
+							getCrashReport(CrashReportDialog.this, comment,
+									email));
+				} catch (ReportSenderException e) {
+					Log.e("crashDialog", "sending failed");
+					e.printStackTrace();
+				}
+				if (ACRA.getConfig().resDialogOkToast() != 0)
+					Toast.makeText(getBaseContext(),
+							ACRA.getConfig().resDialogOkToast(), 0).show();
+
+				mDialog.dismiss();
+			} else {
+				// Retrieve user comment
+				final String comment = userCommentView != null ? userCommentView
+						.getText().toString() : "";
+
+				// Store the user email
+				final String userEmail;
+				final SharedPreferences prefs = ACRA.getACRASharedPreferences();
+				if (userEmailView != null) {
+					userEmail = userEmailView.getText().toString();
+					final SharedPreferences.Editor prefEditor = prefs.edit();
+					prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS,
+							userEmail);
+					prefEditor.commit();
+				} else {
+					userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS,
+							"");
+				}
+				sendCrash(comment, userEmail);
+			}
+		} else {
+			cancelReports();
+		}
+
+		finish();
+	}
+
+	@Override
+	public void onDismiss(DialogInterface dialog) {
+		finish();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
+	 */
+	@Override
+	protected void onSaveInstanceState(Bundle outState) {
+		super.onSaveInstanceState(outState);
+		if (userCommentView != null && userCommentView.getText() != null) {
+			outState.putString(STATE_COMMENT, userCommentView.getText()
+					.toString());
+		}
+		if (userEmailView != null && userEmailView.getText() != null) {
+			outState.putString(STATE_EMAIL, userEmailView.getText().toString());
+		}
+	}
+
+	/**
+	 * show dialog when error occurred and send email
+	 * 
+	 * @author Sumit
+	 */
+	@TargetApi(Build.VERSION_CODES.GINGERBREAD)
+	protected void sendEmail(Context context, final CrashReportData errorContent)
+			throws ReportSenderException {
+		final String subject = "Crash Report for (" + context.getPackageName()
+				+ ")";
+		String body = getLogCat(errorContent);
+		if (body == null || body.isEmpty())
+			body = "crash report empty";
+		final Intent emailIntent = new Intent(
+				android.content.Intent.ACTION_SENDTO);
+		emailIntent.setData(Uri.fromParts("mailto", ACRA.getConfig().mailTo(),
+				null));
+		emailIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+		emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
+		emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, body);
+		context.startActivity(emailIntent);
+
+	}
+
+	/**
+	 * show dialog when error occurred and send email
+	 * 
+	 * @author Sumit
+	 */
+	private String getLogCat(CrashReportData errorContent) {
+		ReportField[] fields = ACRA.getConfig().customReportContent();
+		if (fields.length == 0) {
+			fields = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
+		}
+
+		final StringBuilder builder = new StringBuilder();
+		for (ReportField field : fields) {
+			builder.append(field.toString()).append("=");
+			builder.append(errorContent.get(field));
+			builder.append('\n');
+		}
+		return builder.toString();
+	}
+
+	/**
+	 * get crash report
+	 *
+	 * @author Sumit
+	 */
+	private CrashReportData getCrashReport(Context context, String userComment,
+			String userEmail) {
+		Log.d(LOG_TAG, "#checkAndSendReports - start");
+		final CrashReportFinder reportFinder = new CrashReportFinder(context);
+		final String[] reportFiles = reportFinder.getCrashReportFiles();
+		CrashReportData crashReport = null;
+		Arrays.sort(reportFiles);
+
+		int reportsSentCount = 0;
+
+		for (String curFileName : reportFiles) {
+
+			if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
+				break;
+				// send only a few reports to avoid overloading the network
+			}
+
+			Log.i(LOG_TAG, "Sending file " + curFileName);
+			try {
+				final CrashReportPersister persister = new CrashReportPersister(
+						context);
+				crashReport = persister.load(curFileName);
+				crashReport.put(USER_COMMENT, userComment == null ? ""
+						: userComment);
+				crashReport.put(ReportField.USER_EMAIL, userEmail == null ? ""
+						: userEmail);
+				// crashReport.put(USER_EMAIL, userEmail == null ? "" :
+				// userEmail);
+				// persister.store(crashReport, curFileName);
+				// sendCrashReport(previousCrashReport);
+				deleteFile(context, curFileName);
+			} catch (RuntimeException e) {
+				Log.e(ACRA.LOG_TAG, "Failed to send crash reports for "
+						+ curFileName, e);
+				deleteFile(context, curFileName);
+				break; // Something really unexpected happened
+			} catch (IOException e) {
+				Log.e(ACRA.LOG_TAG, "Failed to load crash report for "
+						+ curFileName, e);
+				deleteFile(context, curFileName);
+				break;
+			}
+			reportsSentCount++;
+		}
+		Log.d("Acra Report", "#checkAndSendReports - finish");
+		return crashReport;
+	}
+
+	/**
+	 * delete log files that are in data/data/pkg/data/files to save
+	 * memory/cache memory
+	 *
+	 * @author Sumit
+	 */
+	private boolean deleteFile(Context context, String fileName) {
+		return context.deleteFile(fileName);
+	}
+
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/CrashReportFileNameParser.java b/src/main/java/org/acra/CrashReportFileNameParser.java
index 609906d0..89ce3747 100644
--- a/src/main/java/org/acra/CrashReportFileNameParser.java
+++ b/src/main/java/org/acra/CrashReportFileNameParser.java
@@ -16,37 +16,45 @@
 package org.acra;
 
 /**
- * Responsible for determining the state of a Crash Report based on its file name.
+ * Responsible for determining the state of a Crash Report based on its file
+ * name.
  * <p/>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 final class CrashReportFileNameParser {
 
-    /**
-     * Guess that a report is silent from its file name.
-     *
-     * @param reportFileName    Name of the report to check whether it should be sent silently.
-     * @return True if the report has been declared explicitly silent using {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    public boolean isSilent(String reportFileName) {
-        return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
-    }
+	/**
+	 * Guess that a report is silent from its file name.
+	 *
+	 * @param reportFileName
+	 *            Name of the report to check whether it should be sent
+	 *            silently.
+	 * @return True if the report has been declared explicitly silent using
+	 *         {@link ErrorReporter#handleSilentException(Throwable)}.
+	 */
+	public boolean isSilent(String reportFileName) {
+		return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
+	}
 
-    /**
-     * Returns true if the report is considered as approved.
-     * <p>
-          This includes:
-     * </p>
-     * <ul>
-     * <li>Reports which were pending when the user agreed to send a report in the NOTIFICATION mode Dialog.</li>
-     * <li>Explicit silent reports</li>
-     * </ul>
-     *
-     * @param reportFileName    Name of report to check whether it is approved to be sent.
-     * @return True if a report can be sent.
-     */
-    public boolean isApproved(String reportFileName) {
-        return isSilent(reportFileName) || reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
-    }
+	/**
+	 * Returns true if the report is considered as approved.
+	 * <p>
+	 * This includes:
+	 * </p>
+	 * <ul>
+	 * <li>Reports which were pending when the user agreed to send a report in
+	 * the NOTIFICATION mode Dialog.</li>
+	 * <li>Explicit silent reports</li>
+	 * </ul>
+	 *
+	 * @param reportFileName
+	 *            Name of report to check whether it is approved to be sent.
+	 * @return True if a report can be sent.
+	 */
+	public boolean isApproved(String reportFileName) {
+		return isSilent(reportFileName)
+				|| reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
+	}
 }
diff --git a/src/main/java/org/acra/CrashReportFinder.java b/src/main/java/org/acra/CrashReportFinder.java
index 118fb7e0..844f3acf 100644
--- a/src/main/java/org/acra/CrashReportFinder.java
+++ b/src/main/java/org/acra/CrashReportFinder.java
@@ -25,43 +25,48 @@
 /**
  * Responsible for retrieving the location of Crash Report files.
  * <p/>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 final class CrashReportFinder {
 
-    private final Context context;
+	private final Context context;
 
-    public CrashReportFinder(Context context) {
-        this.context = context;
-    }
+	public CrashReportFinder(Context context) {
+		this.context = context;
+	}
 
-    /**
-     * Returns an array containing the names of pending crash report files.
-     *
-     * @return an array containing the names of pending crash report files.
-     */
-    public String[] getCrashReportFiles() {
-        if (context == null) {
-            ACRA.log.e(LOG_TAG, "Trying to get ACRA reports but ACRA is not initialized.");
-            return new String[0];
-        }
+	/**
+	 * Returns an array containing the names of pending crash report files.
+	 *
+	 * @return an array containing the names of pending crash report files.
+	 */
+	public String[] getCrashReportFiles() {
+		if (context == null) {
+			ACRA.log.e(LOG_TAG,
+					"Trying to get ACRA reports but ACRA is not initialized.");
+			return new String[0];
+		}
 
-        final File dir = context.getFilesDir();
-        if (dir == null) {
-            ACRA.log.w(LOG_TAG, "Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
-            return new String[0];
-        }
+		final File dir = context.getFilesDir();
+		if (dir == null) {
+			ACRA.log.w(
+					LOG_TAG,
+					"Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
+			return new String[0];
+		}
 
-        ACRA.log.d(LOG_TAG, "Looking for error files in " + dir.getAbsolutePath());
+		ACRA.log.d(LOG_TAG,
+				"Looking for error files in " + dir.getAbsolutePath());
 
-        // Filter for ".stacktrace" files
-        final FilenameFilter filter = new FilenameFilter() {
-            public boolean accept(File dir, String name) {
-                return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
-            }
-        };
-        final String[] result = dir.list(filter);
-        return (result == null) ? new String[0] : result;
-    }
+		// Filter for ".stacktrace" files
+		final FilenameFilter filter = new FilenameFilter() {
+			public boolean accept(File dir, String name) {
+				return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
+			}
+		};
+		final String[] result = dir.list(filter);
+		return (result == null) ? new String[0] : result;
+	}
 }
diff --git a/src/main/java/org/acra/CrashReportPersister.java b/src/main/java/org/acra/CrashReportPersister.java
index 8f94084b..04b8f63d 100644
--- a/src/main/java/org/acra/CrashReportPersister.java
+++ b/src/main/java/org/acra/CrashReportPersister.java
@@ -19,11 +19,6 @@
 
 package org.acra;
 
-import android.content.Context;
-
-import org.acra.collector.CollectorUtil;
-import org.acra.collector.CrashReportData;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.FileInputStream;
@@ -34,345 +29,375 @@
 import java.io.Reader;
 import java.util.Map;
 
+import org.acra.collector.CollectorUtil;
+import org.acra.collector.CrashReportData;
+
+import android.content.Context;
+
 /**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link java.util.Properties} adapted to extend an
- * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
- * amounts of android time in the generation of a date comment when storing to
- * file.
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as
+ * keys. This is basically the source of {@link java.util.Properties} adapted to
+ * extend an EnumMap instead of Hashtable and with a few tweaks to avoid losing
+ * crazy amounts of android time in the generation of a date comment when
+ * storing to file.
  */
 final class CrashReportPersister {
 
-    private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;
-    private static final String LINE_SEPARATOR = "\n";
+	private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3,
+			KEY_DONE = 4, IGNORE = 5;
+	private static final String LINE_SEPARATOR = "\n";
+
+	private final Context context;
 
-    private final Context context;
+	CrashReportPersister(Context context) {
+		this.context = context;
+	}
 
-    CrashReportPersister(Context context) {
-        this.context = context;
-    }
+	/**
+	 * Loads properties from the specified {@code InputStream}. The encoding is
+	 * ISO8859-1.
+	 *
+	 * @param fileName
+	 *            Name of the report file from which to load the CrashData.
+	 * @return CrashReportData read from the supplied InputStream.
+	 * @throws java.io.IOException
+	 *             if error occurs during reading from the {@code InputStream}.
+	 */
+	public CrashReportData load(String fileName) throws IOException {
 
-    /**
-     * Loads properties from the specified {@code InputStream}. The encoding is
-     * ISO8859-1.
-     *
-     * @param fileName  Name of the report file from which to load the CrashData.
-     * @return CrashReportData read from the supplied InputStream.
-     * @throws java.io.IOException if error occurs during reading from the {@code InputStream}.
-     */
-    public CrashReportData load(String fileName) throws IOException {
+		final FileInputStream in = context.openFileInput(fileName);
+		if (in == null) {
+			throw new IllegalArgumentException(
+					"Invalid crash report fileName : " + fileName);
+		}
 
-        final FileInputStream in = context.openFileInput(fileName);
-        if (in == null) {
-            throw new IllegalArgumentException("Invalid crash report fileName : " + fileName);
-        }
+		try {
+			final BufferedInputStream bis = new BufferedInputStream(in,
+					ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+			bis.mark(Integer.MAX_VALUE);
+			final boolean isEbcdic = isEbcdic(bis);
+			bis.reset();
 
-        try {
-            final BufferedInputStream bis = new BufferedInputStream(in, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-            bis.mark(Integer.MAX_VALUE);
-            final boolean isEbcdic = isEbcdic(bis);
-            bis.reset();
+			if (!isEbcdic) {
+				return load(new InputStreamReader(bis, "ISO8859-1")); //$NON-NLS-1$
+			} else {
+				return load(new InputStreamReader(bis)); //$NON-NLS-1$
+			}
+		} finally {
+			in.close();
+		}
+	}
 
-            if (!isEbcdic) {
-                return load(new InputStreamReader(bis, "ISO8859-1")); //$NON-NLS-1$
-            } else {
-                return load(new InputStreamReader(bis)); //$NON-NLS-1$
-            }
-        } finally {
-            in.close();
-        }
-    }
+	/**
+	 * Stores the mappings in this Properties to the specified OutputStream,
+	 * putting the specified comment at the beginning. The output from this
+	 * method is suitable for being read by the load() method.
+	 *
+	 * @param crashData
+	 *            CrashReportData to save.
+	 * @param fileName
+	 *            Name of the file to which to store the CrashReportData.
+	 * @throws java.io.IOException
+	 *             if the CrashReportData could not be written to the
+	 *             OutputStream.
+	 */
+	public void store(CrashReportData crashData, String fileName)
+			throws IOException {
 
-    /**
-     * Stores the mappings in this Properties to the specified OutputStream,
-     * putting the specified comment at the beginning. The output from this
-     * method is suitable for being read by the load() method.
-     *
-     * @param crashData    CrashReportData to save.
-     * @param fileName      Name of the file to which to store the CrashReportData.
-     * @throws java.io.IOException if the CrashReportData could not be written to the OutputStream.
-     */
-    public void store(CrashReportData crashData, String fileName) throws IOException {
+		final OutputStream out = context.openFileOutput(fileName,
+				Context.MODE_PRIVATE);
+		try {
+			final StringBuilder buffer = new StringBuilder(200);
+			final OutputStreamWriter writer = new OutputStreamWriter(out,
+					"ISO8859_1"); //$NON-NLS-1$
 
-        final OutputStream out = context.openFileOutput(fileName, Context.MODE_PRIVATE);
-        try {
-            final StringBuilder buffer = new StringBuilder(200);
-            final OutputStreamWriter writer = new OutputStreamWriter(out, "ISO8859_1"); //$NON-NLS-1$
+			for (final Map.Entry<ReportField, String> entry : crashData
+					.entrySet()) {
+				final String key = entry.getKey().toString();
+				dumpString(buffer, key, true);
+				buffer.append('=');
+				dumpString(buffer, entry.getValue(), false);
+				buffer.append(LINE_SEPARATOR);
+				writer.write(buffer.toString());
+				buffer.setLength(0);
+			}
+			writer.flush();
+		} finally {
+			out.close();
+		}
+	}
 
-            for (final Map.Entry<ReportField, String> entry : crashData.entrySet()) {
-                final String key = entry.getKey().toString();
-                dumpString(buffer, key, true);
-                buffer.append('=');
-                dumpString(buffer, entry.getValue(), false);
-                buffer.append(LINE_SEPARATOR);
-                writer.write(buffer.toString());
-                buffer.setLength(0);
-            }
-            writer.flush();
-        } finally {
-            out.close();
-        }
-    }
+	private boolean isEbcdic(BufferedInputStream in) throws IOException {
+		byte b;
+		while ((b = (byte) in.read()) != -1) {
+			if (b == 0x23 || b == 0x0a || b == 0x3d) {// ascii: newline/#/=
+				return false;
+			}
+			if (b == 0x15) {// EBCDIC newline
+				return true;
+			}
+		}
+		// we found no ascii newline, '#', neither '=', relative safe to
+		// consider it
+		// as non-ascii, the only exception will be a single line with only
+		// key(no value and '=')
+		// in this case, it should be no harm to read it in default charset
+		return false;
+	}
 
-    private boolean isEbcdic(BufferedInputStream in) throws IOException {
-        byte b;
-        while ((b = (byte) in.read()) != -1) {
-            if (b == 0x23 || b == 0x0a || b == 0x3d) {// ascii: newline/#/=
-                return false;
-            }
-            if (b == 0x15) {// EBCDIC newline
-                return true;
-            }
-        }
-        // we found no ascii newline, '#', neither '=', relative safe to
-        // consider it
-        // as non-ascii, the only exception will be a single line with only
-        // key(no value and '=')
-        // in this case, it should be no harm to read it in default charset
-        return false;
-    }
+	/**
+	 * Loads properties from the specified InputStream. The properties are of
+	 * the form <code>key=value</code>, one property per line. It may be not
+	 * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
+	 * according to the following rules:
+	 * <ul>
+	 * <li>Empty lines are ignored.</li>
+	 * <li>Lines starting with either a "#" or a "!" are comment lines and are
+	 * ignored.</li>
+	 * <li>A backslash at the end of the line escapes the following newline
+	 * character ("\r", "\n", "\r\n"). If there's a whitespace after the
+	 * backslash it will just escape that whitespace instead of concatenating
+	 * the lines. This does not apply to comment lines.</li>
+	 * <li>A property line consists of the key, the space between the key and
+	 * the value, and the value. The key goes up to the first whitespace, "=" or
+	 * ":" that is not escaped. The space between the key and the value contains
+	 * either one whitespace, one "=" or one ":" and any number of additional
+	 * whitespaces before and after that character. The value starts with the
+	 * first character after the space between the key and the value.</li>
+	 * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
+	 * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
+	 * </ul>
+	 *
+	 * @param reader
+	 *            Reader from which to read the properties of this
+	 *            CrashReportData.
+	 * @return CrashReportData read from the supplied Reader.
+	 * @throws java.io.IOException
+	 *             if the properties could not be read.
+	 * @since 1.6
+	 */
+	private synchronized CrashReportData load(Reader reader) throws IOException {
+		int mode = NONE, unicode = 0, count = 0;
+		char nextChar, buf[] = new char[40];
+		int offset = 0, keyLength = -1, intVal;
+		boolean firstChar = true;
 
-    /**
-     * Loads properties from the specified InputStream. The properties are of
-     * the form <code>key=value</code>, one property per line. It may be not
-     * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
-     * according to the following rules:
-     * <ul>
-     * <li>Empty lines are ignored.</li>
-     * <li>Lines starting with either a "#" or a "!" are comment lines and are
-     * ignored.</li>
-     * <li>A backslash at the end of the line escapes the following newline
-     * character ("\r", "\n", "\r\n"). If there's a whitespace after the
-     * backslash it will just escape that whitespace instead of concatenating
-     * the lines. This does not apply to comment lines.</li>
-     * <li>A property line consists of the key, the space between the key and
-     * the value, and the value. The key goes up to the first whitespace, "=" or
-     * ":" that is not escaped. The space between the key and the value contains
-     * either one whitespace, one "=" or one ":" and any number of additional
-     * whitespaces before and after that character. The value starts with the
-     * first character after the space between the key and the value.</li>
-     * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
-     * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
-     * </ul>
-     *
-     * @param reader    Reader from which to read the properties of this CrashReportData.
-     * @return CrashReportData read from the supplied Reader.
-     * @throws java.io.IOException if the properties could not be read.
-     * @since 1.6
-     */
-    private synchronized CrashReportData load(Reader reader) throws IOException {
-        int mode = NONE, unicode = 0, count = 0;
-        char nextChar, buf[] = new char[40];
-        int offset = 0, keyLength = -1, intVal;
-        boolean firstChar = true;
+		final CrashReportData crashData = new CrashReportData();
+		final BufferedReader br = new BufferedReader(reader,
+				ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
 
-        final CrashReportData crashData = new CrashReportData();
-        final BufferedReader br = new BufferedReader(reader, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+		while (true) {
+			intVal = br.read();
+			if (intVal == -1) {
+				break;
+			}
+			nextChar = (char) intVal;
 
-        while (true) {
-            intVal = br.read();
-            if (intVal == -1) {
-                break;
-            }
-            nextChar = (char) intVal;
+			if (offset == buf.length) {
+				final char[] newBuf = new char[buf.length * 2];
+				System.arraycopy(buf, 0, newBuf, 0, offset);
+				buf = newBuf;
+			}
+			if (mode == UNICODE) {
+				final int digit = Character.digit(nextChar, 16);
+				if (digit >= 0) {
+					unicode = (unicode << 4) + digit;
+					if (++count < 4) {
+						continue;
+					}
+				} else if (count <= 4) {
+					// luni.09=Invalid Unicode sequence: illegal character
+					throw new IllegalArgumentException("luni.09");
+				}
+				mode = NONE;
+				buf[offset++] = (char) unicode;
+				if (nextChar != '\n' && nextChar != '\u0085') {
+					continue;
+				}
+			}
+			if (mode == SLASH) {
+				mode = NONE;
+				switch (nextChar) {
+				case '\r':
+					mode = CONTINUE; // Look for a following \n
+					continue;
+				case '\u0085':
+				case '\n':
+					mode = IGNORE; // Ignore whitespace on the next line
+					continue;
+				case 'b':
+					nextChar = '\b';
+					break;
+				case 'f':
+					nextChar = '\f';
+					break;
+				case 'n':
+					nextChar = '\n';
+					break;
+				case 'r':
+					nextChar = '\r';
+					break;
+				case 't':
+					nextChar = '\t';
+					break;
+				case 'u':
+					mode = UNICODE;
+					unicode = count = 0;
+					continue;
+				}
+			} else {
+				switch (nextChar) {
+				case '#':
+				case '!':
+					if (firstChar) {
+						while (true) {
+							intVal = br.read();
+							if (intVal == -1) {
+								break;
+							}
+							nextChar = (char) intVal; // & 0xff
+														// not
+														// required
+							if (nextChar == '\r' || nextChar == '\n'
+									|| nextChar == '\u0085') {
+								break;
+							}
+						}
+						continue;
+					}
+					break;
+				case '\n':
+					if (mode == CONTINUE) { // Part of a \r\n sequence
+						mode = IGNORE; // Ignore whitespace on the next line
+						continue;
+					}
+					// fall into the next case
+				case '\u0085':
+				case '\r':
+					mode = NONE;
+					firstChar = true;
+					if (offset > 0 || (offset == 0 && keyLength == 0)) {
+						if (keyLength == -1) {
+							keyLength = offset;
+						}
+						final String temp = new String(buf, 0, offset);
+						crashData.put(
+								Enum.valueOf(ReportField.class,
+										temp.substring(0, keyLength)),
+								temp.substring(keyLength));
+					}
+					keyLength = -1;
+					offset = 0;
+					continue;
+				case '\\':
+					if (mode == KEY_DONE) {
+						keyLength = offset;
+					}
+					mode = SLASH;
+					continue;
+				case ':':
+				case '=':
+					if (keyLength == -1) { // if parsing the key
+						mode = NONE;
+						keyLength = offset;
+						continue;
+					}
+					break;
+				}
+				if (Character.isWhitespace(nextChar)) {
+					if (mode == CONTINUE) {
+						mode = IGNORE;
+					}
+					// if key length == 0 or value length == 0
+					if (offset == 0 || offset == keyLength || mode == IGNORE) {
+						continue;
+					}
+					if (keyLength == -1) { // if parsing the key
+						mode = KEY_DONE;
+						continue;
+					}
+				}
+				if (mode == IGNORE || mode == CONTINUE) {
+					mode = NONE;
+				}
+			}
+			firstChar = false;
+			if (mode == KEY_DONE) {
+				keyLength = offset;
+				mode = NONE;
+			}
+			buf[offset++] = nextChar;
+		}
+		if (mode == UNICODE && count <= 4) {
+			// luni.08=Invalid Unicode sequence: expected format \\uxxxx
+			throw new IllegalArgumentException("luni.08");
+		}
+		if (keyLength == -1 && offset > 0) {
+			keyLength = offset;
+		}
+		if (keyLength >= 0) {
+			final String temp = new String(buf, 0, offset);
+			final ReportField key = Enum.valueOf(ReportField.class,
+					temp.substring(0, keyLength));
+			String value = temp.substring(keyLength);
+			if (mode == SLASH) {
+				value += "\u0000";
+			}
+			crashData.put(key, value);
+		}
 
-            if (offset == buf.length) {
-                final char[] newBuf = new char[buf.length * 2];
-                System.arraycopy(buf, 0, newBuf, 0, offset);
-                buf = newBuf;
-            }
-            if (mode == UNICODE) {
-                final int digit = Character.digit(nextChar, 16);
-                if (digit >= 0) {
-                    unicode = (unicode << 4) + digit;
-                    if (++count < 4) {
-                        continue;
-                    }
-                } else if (count <= 4) {
-                    // luni.09=Invalid Unicode sequence: illegal character
-                    throw new IllegalArgumentException("luni.09");
-                }
-                mode = NONE;
-                buf[offset++] = (char) unicode;
-                if (nextChar != '\n' && nextChar != '\u0085') {
-                    continue;
-                }
-            }
-            if (mode == SLASH) {
-                mode = NONE;
-                switch (nextChar) {
-                case '\r':
-                    mode = CONTINUE; // Look for a following \n
-                    continue;
-                case '\u0085':
-                case '\n':
-                    mode = IGNORE; // Ignore whitespace on the next line
-                    continue;
-                case 'b':
-                    nextChar = '\b';
-                    break;
-                case 'f':
-                    nextChar = '\f';
-                    break;
-                case 'n':
-                    nextChar = '\n';
-                    break;
-                case 'r':
-                    nextChar = '\r';
-                    break;
-                case 't':
-                    nextChar = '\t';
-                    break;
-                case 'u':
-                    mode = UNICODE;
-                    unicode = count = 0;
-                    continue;
-                }
-            } else {
-                switch (nextChar) {
-                case '#':
-                case '!':
-                    if (firstChar) {
-                        while (true) {
-                            intVal = br.read();
-                            if (intVal == -1) {
-                                break;
-                            }
-                            nextChar = (char) intVal; // & 0xff
-                                                      // not
-                                                      // required
-                            if (nextChar == '\r' || nextChar == '\n' || nextChar == '\u0085') {
-                                break;
-                            }
-                        }
-                        continue;
-                    }
-                    break;
-                case '\n':
-                    if (mode == CONTINUE) { // Part of a \r\n sequence
-                        mode = IGNORE; // Ignore whitespace on the next line
-                        continue;
-                    }
-                    // fall into the next case
-                case '\u0085':
-                case '\r':
-                    mode = NONE;
-                    firstChar = true;
-                    if (offset > 0 || (offset == 0 && keyLength == 0)) {
-                        if (keyLength == -1) {
-                            keyLength = offset;
-                        }
-                        final String temp = new String(buf, 0, offset);
-                        crashData.put(Enum.valueOf(ReportField.class, temp.substring(0, keyLength)), temp.substring(keyLength));
-                    }
-                    keyLength = -1;
-                    offset = 0;
-                    continue;
-                case '\\':
-                    if (mode == KEY_DONE) {
-                        keyLength = offset;
-                    }
-                    mode = SLASH;
-                    continue;
-                case ':':
-                case '=':
-                    if (keyLength == -1) { // if parsing the key
-                        mode = NONE;
-                        keyLength = offset;
-                        continue;
-                    }
-                    break;
-                }
-                if (Character.isWhitespace(nextChar)) {
-                    if (mode == CONTINUE) {
-                        mode = IGNORE;
-                    }
-                    // if key length == 0 or value length == 0
-                    if (offset == 0 || offset == keyLength || mode == IGNORE) {
-                        continue;
-                    }
-                    if (keyLength == -1) { // if parsing the key
-                        mode = KEY_DONE;
-                        continue;
-                    }
-                }
-                if (mode == IGNORE || mode == CONTINUE) {
-                    mode = NONE;
-                }
-            }
-            firstChar = false;
-            if (mode == KEY_DONE) {
-                keyLength = offset;
-                mode = NONE;
-            }
-            buf[offset++] = nextChar;
-        }
-        if (mode == UNICODE && count <= 4) {
-            // luni.08=Invalid Unicode sequence: expected format \\uxxxx
-            throw new IllegalArgumentException("luni.08");
-        }
-        if (keyLength == -1 && offset > 0) {
-            keyLength = offset;
-        }
-        if (keyLength >= 0) {
-            final String temp = new String(buf, 0, offset);
-            final ReportField key = Enum.valueOf(ReportField.class, temp.substring(0, keyLength));
-            String value = temp.substring(keyLength);
-            if (mode == SLASH) {
-                value += "\u0000";
-            }
-            crashData.put(key, value);
-        }
-        
-        CollectorUtil.safeClose(reader);
+		CollectorUtil.safeClose(reader);
 
-        return crashData;
-    }
+		return crashData;
+	}
 
-    /**
-     * Constructs a new {@code Properties} object.
-     *
-     * @param buffer    StringBuilder to populate with the supplied property.
-     * @param string    String to append to the buffer.
-     * @param key       Whether the String is a key value or not.
-     */
-    private void dumpString(StringBuilder buffer, String string, boolean key) {
-        int i = 0;
-        if (!key && i < string.length() && string.charAt(i) == ' ') {
-            buffer.append("\\ "); //$NON-NLS-1$
-            i++;
-        }
+	/**
+	 * Constructs a new {@code Properties} object.
+	 *
+	 * @param buffer
+	 *            StringBuilder to populate with the supplied property.
+	 * @param string
+	 *            String to append to the buffer.
+	 * @param key
+	 *            Whether the String is a key value or not.
+	 */
+	private void dumpString(StringBuilder buffer, String string, boolean key) {
+		int i = 0;
+		if (!key && i < string.length() && string.charAt(i) == ' ') {
+			buffer.append("\\ "); //$NON-NLS-1$
+			i++;
+		}
 
-        for (; i < string.length(); i++) {
-            char ch = string.charAt(i);
-            switch (ch) {
-            case '\t':
-                buffer.append("\\t"); //$NON-NLS-1$
-                break;
-            case '\n':
-                buffer.append("\\n"); //$NON-NLS-1$
-                break;
-            case '\f':
-                buffer.append("\\f"); //$NON-NLS-1$
-                break;
-            case '\r':
-                buffer.append("\\r"); //$NON-NLS-1$
-                break;
-            default:
-                if ("\\#!=:".indexOf(ch) >= 0 || (key && ch == ' ')) {
-                    buffer.append('\\');
-                }
-                if (ch >= ' ' && ch <= '~') {
-                    buffer.append(ch);
-                } else {
-                    final String hex = Integer.toHexString(ch);
-                    buffer.append("\\u"); //$NON-NLS-1$
-                    for (int j = 0; j < 4 - hex.length(); j++) {
-                        buffer.append("0"); //$NON-NLS-1$
-                    }
-                    buffer.append(hex);
-                }
-            }
-        }
-    }
+		for (; i < string.length(); i++) {
+			char ch = string.charAt(i);
+			switch (ch) {
+			case '\t':
+				buffer.append("\\t"); //$NON-NLS-1$
+				break;
+			case '\n':
+				buffer.append("\\n"); //$NON-NLS-1$
+				break;
+			case '\f':
+				buffer.append("\\f"); //$NON-NLS-1$
+				break;
+			case '\r':
+				buffer.append("\\r"); //$NON-NLS-1$
+				break;
+			default:
+				if ("\\#!=:".indexOf(ch) >= 0 || (key && ch == ' ')) {
+					buffer.append('\\');
+				}
+				if (ch >= ' ' && ch <= '~') {
+					buffer.append(ch);
+				} else {
+					final String hex = Integer.toHexString(ch);
+					buffer.append("\\u"); //$NON-NLS-1$
+					for (int j = 0; j < 4 - hex.length(); j++) {
+						buffer.append("0"); //$NON-NLS-1$
+					}
+					buffer.append(hex);
+				}
+			}
+		}
+	}
 }
diff --git a/src/main/java/org/acra/ErrorReporter.java b/src/main/java/org/acra/ErrorReporter.java
index 47b8c15c..dbd62c72 100644
--- a/src/main/java/org/acra/ErrorReporter.java
+++ b/src/main/java/org/acra/ErrorReporter.java
@@ -15,6 +15,31 @@
  */
 package org.acra;
 
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.IS_SILENT;
+
+import java.io.File;
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.acra.annotation.ReportsCrashes;
+import org.acra.collector.Compatibility;
+import org.acra.collector.ConfigurationCollector;
+import org.acra.collector.CrashReportData;
+import org.acra.collector.CrashReportDataFactory;
+import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat;
+import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ApplicationHelper;
+import org.acra.sender.EmailIntentSender;
+import org.acra.sender.HttpSender;
+import org.acra.sender.ReportSender;
+import org.acra.util.PackageManagerWrapper;
+import org.acra.util.ToastSender;
+
 import android.Manifest.permission;
 import android.app.Activity;
 import android.app.Application;
@@ -29,30 +54,6 @@
 import android.os.Looper;
 import android.text.format.Time;
 import android.widget.Toast;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.collector.Compatibility;
-import org.acra.collector.ConfigurationCollector;
-import org.acra.collector.CrashReportData;
-import org.acra.collector.CrashReportDataFactory;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ApplicationHelper;
-import org.acra.sender.EmailIntentSender;
-import org.acra.sender.HttpSender;
-import org.acra.sender.ReportSender;
-import org.acra.util.PackageManagerWrapper;
-import org.acra.util.ToastSender;
-
-import java.io.File;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.IS_SILENT;
 
 /**
  * <p>
@@ -80,1066 +81,1171 @@
  */
 public class ErrorReporter implements Thread.UncaughtExceptionHandler {
 
-    private boolean enabled = false;
-
-    private final Application mContext;
-    private final SharedPreferences prefs;
-
-    /**
-     * Contains the active {@link ReportSender}s.
-     */
-    private final List<ReportSender> mReportSenders = new ArrayList<ReportSender>();
-
-    private final CrashReportDataFactory crashReportDataFactory;
-
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-
-    // A reference to the system's previous default UncaughtExceptionHandler
-    // kept in order to execute the default exception handling after sending the
-    // report.
-    private final Thread.UncaughtExceptionHandler mDfltExceptionHandler;
-
-    private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(null);
-
-    /**
-     * This is used to wait for the crash toast to end it's display duration
-     * before killing the Application.
-     */
-    private boolean toastWaitEnded = true;
-
-    private static final ExceptionHandlerInitializer NULL_EXCEPTION_HANDLER_INITIALIZER = new ExceptionHandlerInitializer() {
-        @Override
-        public void initializeExceptionHandler(ErrorReporter reporter) {
-        }
-    };
-
-    private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = NULL_EXCEPTION_HANDLER_INITIALIZER;
-
-    /**
-     * Used to create a new (non-cached) PendingIntent each time a new crash occurs.
-     */
-    private static int mNotificationCounter = 0;
-
-    /**
-     * Can only be constructed from within this class.
-     *
-     * @param context
-     *            Context for the application in which ACRA is running.
-     * @param prefs
-     *            SharedPreferences used by ACRA.
-     * @param enabled
-     *            Whether this ErrorReporter should capture Exceptions and
-     *            forward their reports.
-     */
-    ErrorReporter(Application context, SharedPreferences prefs, boolean enabled) {
-
-        this.mContext = context;
-        this.prefs = prefs;
-        this.enabled = enabled;
-
-        // Store the initial Configuration state.
-        // This is expensive to gather, so only do so if we plan to report it.
-        final String initialConfiguration;
-        if (ACRA.getConfig().getReportFields().contains(ReportField.INITIAL_CONFIGURATION)) {
-            initialConfiguration = ConfigurationCollector.collectConfiguration(mContext);
-        } else {
-            initialConfiguration = null;
-        }
-
-        // Sets the application start date.
-        // This will be included in the reports, will be helpful compared to
-        // user_crash date.
-        final Time appStartDate = new Time();
-        appStartDate.setToNow();
-
-        if (Compatibility.getAPILevel() >= 14) { // ActivityLifecycleCallback
-            // only available for API14+
-            ApplicationHelper.registerActivityLifecycleCallbacks(context, new ActivityLifecycleCallbacksCompat() {
-                @Override
-                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityCreated " + activity.getClass());
-                    if (!(activity instanceof BaseCrashReportDialog)) {
-                        // Ignore CrashReportDialog because we want the last
-                        // application Activity that was started so that we can
-                        // explicitly kill it off.
-                        lastActivityCreated = new WeakReference<Activity>(activity);
-                    }
-                }
-
-                @Override
-                public void onActivityStarted(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityStarted " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityResumed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityResumed " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityPaused(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityPaused " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityStopped(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityStopped " + activity.getClass());
-                }
-
-                @Override
-                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(LOG_TAG, "onActivitySaveInstanceState " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityDestroyed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(LOG_TAG, "onActivityDestroyed " + activity.getClass());
-                }
-            });
-        }
-
-        crashReportDataFactory = new CrashReportDataFactory(mContext, prefs, appStartDate, initialConfiguration);
-
-        // If mDfltExceptionHandler is not null, initialization is already done.
-        // Don't do it twice to avoid losing the original handler.
-        mDfltExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-        Thread.setDefaultUncaughtExceptionHandler(this);
-    }
-
-    /**
-     * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
-     * @deprecated since 4.3.0 Use {@link org.acra.ACRA#getErrorReporter()}
-     *             instead.
-     */
-    @Deprecated
-    public static ErrorReporter getInstance() {
-        return ACRA.getErrorReporter();
-    }
-
-    /**
-     * Deprecated. Use {@link #putCustomData(String, String)}.
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     */
-    @Deprecated
-    @SuppressWarnings("unused")
-    public void addCustomData(String key, String value) {
-        crashReportDataFactory.putCustomData(key, value);
-    }
-
-    /**
-     * <p>
-     * Use this method to provide the ErrorReporter with data of your running
-     * application. You should call this at several key places in your code the
-     * same way as you would output important debug data in a log file. Only the
-     * latest value is kept for each key (no history of the values is sent in
-     * the report).
-     * </p>
-     * <p>
-     * The key/value pairs will be stored in the GoogleDoc spreadsheet in the
-     * "custom" column, as a text containing a 'key = value' pair on each line.
-     * </p>
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     * @return The previous value for this key if there was one, or null.
-     * @see #removeCustomData(String)
-     * @see #getCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String putCustomData(String key, String value) {
-        return crashReportDataFactory.putCustomData(key, value);
-    }
-
-    /**
-     * <p>
-     * Use this method to perform additional initialization before the
-     * ErrorReporter handles a throwable. This can be used, for example, to put
-     * custom data using {@link #putCustomData(String, String)}, which is not
-     * available immediately after startup. It can be, for example, last 20
-     * requests or something else. The call is thread safe.
-     * </p>
-     * <p>
-     * {@link ExceptionHandlerInitializer#initializeExceptionHandler(ErrorReporter)}
-     * will be executed on the main thread in case of uncaught exception and on
-     * the caller thread of {@link #handleSilentException(Throwable)} or
-     * {@link #handleException(Throwable)}.
-     * </p>
-     * <p>
-     * Example. Add to the {@link Application#onCreate()}:
-     * </p>
-     * 
-     * <pre>
-     * ACRA.getErrorReporter().setExceptionHandlerInitializer(new ExceptionHandlerInitializer() {
-     *     <code>@Override</code> public void initializeExceptionHandler(ErrorReporter reporter) {
-     *         reporter.putCustomData("CUSTOM_ACCUMULATED_DATA_TAG", someAccumulatedData.toString);
-     *     }
-     * });
-     * </pre>
-     * 
-     * @param initializer   The initializer. Can be <code>null</code>.
-     */
-    public void setExceptionHandlerInitializer(ExceptionHandlerInitializer initializer) {
-        exceptionHandlerInitializer = (initializer != null) ? initializer : NULL_EXCEPTION_HANDLER_INITIALIZER;
-    }
-
-    /**
-     * Removes a key/value pair from your reports custom data field.
-     *
-     * @param key
-     *            The key of the data to be removed.
-     * @return The value for this key before removal.
-     * @see #putCustomData(String, String)
-     * @see #getCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String removeCustomData(String key) {
-        return crashReportDataFactory.removeCustomData(key);
-    }
-
-    /**
-     * Removes all key/value pairs from your reports custom data field.
-     */
-    @SuppressWarnings("unused")
-    public void clearCustomData() {
-        crashReportDataFactory.clearCustomData();
-    }
-
-    /**
-     * Gets the current value for a key in your reports custom data field.
-     *
-     * @param key
-     *            The key of the data to be retrieved.
-     * @return The value for this key.
-     * @see #putCustomData(String, String)
-     * @see #removeCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String getCustomData(String key) {
-        return crashReportDataFactory.getCustomData(key);
-    }
-
-    /**
-     * Add a {@link ReportSender} to the list of active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} to be added.
-     */
-    public void addReportSender(ReportSender sender) {
-        mReportSenders.add(sender);
-    }
-
-    /**
-     * Remove a specific instance of {@link ReportSender} from the list of
-     * active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} instance to be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSender(ReportSender sender) {
-        mReportSenders.remove(sender);
-    }
-
-    /**
-     * Remove all {@link ReportSender} instances from a specific class.
-     *
-     * @param senderClass
-     *            ReportSender class whose instances should be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSenders(Class<?> senderClass) {
-        if (ReportSender.class.isAssignableFrom(senderClass)) {
-            for (ReportSender sender : mReportSenders) {
-                if (senderClass.isInstance(sender)) {
-                    mReportSenders.remove(sender);
-                }
-            }
-        }
-    }
-
-    /**
-     * Clears the list of active {@link ReportSender}s. You should then call
-     * {@link #addReportSender(ReportSender)} or ACRA will not send any report
-     * anymore.
-     */
-    public void removeAllReportSenders() {
-        mReportSenders.clear();
-    }
-
-    /**
-     * Removes all previously set {@link ReportSender}s and set the given one as
-     * the new {@link ReportSender}.
-     *
-     * @param sender
-     *            ReportSender to set as the sole sender for this ErrorReporter.
-     */
-    public void setReportSender(ReportSender sender) {
-        removeAllReportSenders();
-        addReportSender(sender);
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see
-     * java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang
-     * .Thread, java.lang.Throwable)
-     */
-    @Override
-    public void uncaughtException(Thread t, Throwable e) {
-        try {
-            // If we're not enabled then just pass the Exception on to any
-            // defaultExceptionHandler.
-            if (!enabled) {
-                if (mDfltExceptionHandler != null) {
-                    ACRA.log.e(LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - forwarding uncaught Exception on to default ExceptionHandler");
-                    mDfltExceptionHandler.uncaughtException(t, e);
-                } else {
-                    ACRA.log.e(LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - no default ExceptionHandler");
-                    ACRA.log.e(LOG_TAG,
-                          "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-                }
-                return;
-            }
-
-            ACRA.log.e(LOG_TAG,
-                  "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-            ACRA.log.d(LOG_TAG, "Building report");
-
-            // Generate and send crash report
-            reportBuilder()
-                .uncaughtExceptionThread(t)
-                .exception(e)
-                .endsApplication()
-                .send();
-        } catch (Throwable fatality) {
-            // ACRA failed. Prevent any recursive call to
-            // ACRA.uncaughtException(), let the native reporter do its job.
-            if (mDfltExceptionHandler != null) {
-                mDfltExceptionHandler.uncaughtException(t, e);
-            }
-        }
-    }
-
-    /**
-     * End the application.
-     */
-    private void endApplication(Thread uncaughtExceptionThread, Throwable th) {
-        // TODO It would be better to create an explicit config attribute #letDefaultHandlerEndApplication
-        // as the intent is clearer and would allows you to switch it off for SILENT.
-        final boolean letDefaultHandlerEndApplication = (
-             ACRA.getConfig().mode() == ReportingInteractionMode.SILENT ||
-            (ACRA.getConfig().mode() == ReportingInteractionMode.TOAST && ACRA.getConfig().forceCloseDialogAfterToast())
-        );
-
-        final boolean handlingUncaughtException = uncaughtExceptionThread != null;
-        if (handlingUncaughtException && letDefaultHandlerEndApplication && (mDfltExceptionHandler != null)) {
-            // Let the system default handler do it's job and display the force close dialog.
-            ACRA.log.d(LOG_TAG, "Handing Exception on to default ExceptionHandler");
-            mDfltExceptionHandler.uncaughtException(uncaughtExceptionThread, th);
-        } else {
-            // If ACRA handles user notifications with a Toast or a Notification
-            // the Force Close dialog is one more notification to the user...
-            // We choose to close the process ourselves using the same actions.
-            ACRA.log.e(LOG_TAG, mContext.getPackageName() + " fatal error : " + th.getMessage(), th);
-
-            // Trying to solve
-            // https://github.com/ACRA/acra/issues/42#issuecomment-12134144
-            // Determine the current/last Activity that was started and close
-            // it. Activity#finish (and maybe it's parent too).
-            final Activity lastActivity = lastActivityCreated.get();
-            if (lastActivity != null) {
-                ACRA.log.i(LOG_TAG, "Finishing the last Activity prior to killing the Process");
-                lastActivity.finish();
-                ACRA.log.i(LOG_TAG, "Finished " + lastActivity.getClass());
-                lastActivityCreated.clear();
-            }
-
-            android.os.Process.killProcess(android.os.Process.myPid());
-            System.exit(10);
-        }
-    }
-
-    /**
-     * Send a report for this {@link Throwable} silently (forces the use of
-     * {@link ReportingInteractionMode#SILENT} for this report, whatever is the
-     * mode set for the application. Very useful for tracking difficult defects.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     */
-    public void handleSilentException(Throwable e) {
-        // Mark this report as silent.
-        if (enabled) {
-            reportBuilder()
-                .exception(e)
-                .forceSilent()
-                .send();
-            ACRA.log.d(LOG_TAG, "ACRA sent Silent report.");
-            return;
-        }
-
-        ACRA.log.d(LOG_TAG, "ACRA is disabled. Silent report not sent.");
-    }
-
-    /**
-     * Enable or disable this ErrorReporter. By default it is enabled.
-     *
-     * @param enabled
-     *            Whether this ErrorReporter should capture Exceptions and
-     *            forward them as crash reports.
-     */
-    public void setEnabled(boolean enabled) {
-        ACRA.log.i(LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled") + " for " + mContext.getPackageName());
-        this.enabled = enabled;
-    }
-
-    /**
-     * Starts a Thread to start sending outstanding error reports.
-     *
-     * @param onlySendSilentReports
-     *            If true then only send silent reports.
-     * @param approveReportsFirst
-     *            If true then approve unapproved reports first.
-     * @return SendWorker that will be sending the report.s
-     */
-    SendWorker startSendingReports(boolean onlySendSilentReports, boolean approveReportsFirst) {
-        final SendWorker worker = new SendWorker(mContext, mReportSenders, onlySendSilentReports, approveReportsFirst);
-        worker.start();
-        return worker;
-    }
-
-    /**
-     * Delete all report files stored.
-     */
-    void deletePendingReports() {
-        deletePendingReports(true, true, 0);
-    }
-
-    /**
-     * This method looks for pending reports and does the action required
-     * depending on the interaction mode set.
-     */
-    public void checkReportsOnApplicationStart() {
-
-        if (ACRA.getConfig().deleteOldUnsentReportsOnApplicationStart()) {
-            // Delete any old unsent reports if this is a newer version of the app
-            // than when we last started.
-            final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR, 0);
-            final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(mContext);
-            final PackageInfo packageInfo = packageManagerWrapper.getPackageInfo();
-            if (packageInfo != null) {
-                final boolean newVersion = packageInfo.versionCode > lastVersionNr;
-                if (newVersion) {
-                    deletePendingReports();
-                }
-                final SharedPreferences.Editor prefsEditor = prefs.edit();
-                prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR, packageInfo.versionCode);
-                prefsEditor.commit();
-            }
-        }
-
-        ReportingInteractionMode reportingInteractionMode = ACRA.getConfig().mode();
-
-        if ((reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && ACRA.getConfig().deleteUnapprovedReportsOnApplicationStart()) {
-            // NOTIFICATION or DIALOG mode, and there are unapproved reports to
-            // send (latest notification/dialog has been ignored: neither
-            // accepted
-            // nor refused). The application developer has decided that
-            // these reports should not be renotified ==> destroy them all but
-            // one.
-            deletePendingNonApprovedReports(true);
-        }
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        String[] filesList = reportFinder.getCrashReportFiles();
-
-        if (filesList != null && filesList.length > 0) {
-            // Immediately send reports for SILENT and TOAST modes.
-            // Immediately send reports in NOTIFICATION mode only if they are
-            // all silent or approved.
-            // If there is still one unapproved report in NOTIFICATION mode,
-            // notify it.
-            // If there are unapproved reports in DIALOG mode, show the dialog
-
-
-            final boolean onlySilentOrApprovedReports = containsOnlySilentOrApprovedReports(filesList);
-
-            if (reportingInteractionMode == ReportingInteractionMode.SILENT
-                || reportingInteractionMode == ReportingInteractionMode.TOAST
-                || (onlySilentOrApprovedReports && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG))) {
-
-                if (reportingInteractionMode == ReportingInteractionMode.TOAST && !onlySilentOrApprovedReports) {
-                    // Display the Toast in TOAST mode only if there are
-                    // non-silent reports.
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                }
-
-                ACRA.log.v(LOG_TAG, "About to start ReportSenderWorker from #checkReportOnApplicationStart");
-                startSendingReports(false, false);
-            }
-
-        }
-    }
-
-    /**
-     * Delete all pending non approved reports.
-     *
-     * @param keepOne
-     *            If you need to keep the latest report, set this to true.
-     */
-    void deletePendingNonApprovedReports(boolean keepOne) {
-        // In NOTIFICATION AND DIALOG mode, we have to keep the latest report
-        // which
-        // has been written before killing the app.
-        final int nbReportsToKeep = keepOne ? 1 : 0;
-        deletePendingReports(false, true, nbReportsToKeep);
-    }
-
-    /**
-     * Send a report for a {@link Throwable} with the reporting interaction mode
-     * configured by the developer.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     * @param endApplication
-     *            Set this to true if you want the application to be ended after
-     *            sending the report.
-     */
-    @SuppressWarnings("unused")
-    public void handleException(Throwable e, boolean endApplication) {
-        final ReportBuilder builder = reportBuilder()
-            .exception(e);
-        if (endApplication) {
-            builder.endsApplication();
-        }
-        builder.send();
-    }
-
-    /**
-     * Send a report for a {@link Throwable} with the reporting interaction mode
-     * configured by the developer, the application is then killed and restarted
-     * by the system.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     */
-    @SuppressWarnings("unused")
-    public void handleException(Throwable e) {
-        reportBuilder()
-            .exception(e)
-            .send();
-    }
-
-    /**
-     * Creates a new crash report builder
-     *
-     * @return the newly created {@code ReportBuilder}
-     */
-    public ReportBuilder reportBuilder() {
-        return new ReportBuilder();
-    }
-
-    /**
-     * Helps manage
-     */
-    private static class TimeHelper {
-
-        private Long initialTimeMillis;
-
-        public void setInitialTimeMillis(long initialTimeMillis) {
-            this.initialTimeMillis = initialTimeMillis;
-        }
-
-        /**
-         * @return 0 if the initial time has yet to be set otherwise returns the difference between now and the initial time.
-         */
-        public long getElapsedTime() {
-            return (initialTimeMillis == null) ? 0 : System.currentTimeMillis() - initialTimeMillis;
-        }
-    }
-
-    /**
-     * Try to send a report, if an error occurs stores a report file for a later
-     * attempt.
-     *
-     * @param reportBuilder The report builder used to assemble the report
-     */
-    private void report(final ReportBuilder reportBuilder) {
-
-        if (!enabled) {
-            return;
-        }
-
-        try {
-            exceptionHandlerInitializer.initializeExceptionHandler(this);
-        } catch (Exception exceptionInRunnable) {
-            ACRA.log.d(LOG_TAG, "Failed to initlize " + exceptionHandlerInitializer + " from #handleException");
-        }
-
-        boolean sendOnlySilentReports = false;
-        ReportingInteractionMode reportingInteractionMode;
-        if (!reportBuilder.mForceSilent) {
-            // No interaction mode defined, we assume it has been set during
-            // ACRA.initACRA()
-            reportingInteractionMode = ACRA.getConfig().mode();
-        } else {
-            reportingInteractionMode = ReportingInteractionMode.SILENT;
-
-            // An interaction mode has been provided. If ACRA has been
-            // initialized with a non SILENT mode and this mode is overridden
-            // with SILENT, then we have to send only reports which have been
-            // explicitly declared as silent via handleSilentException().
-            if (ACRA.getConfig().mode() != ReportingInteractionMode.SILENT) {
-                sendOnlySilentReports = true;
-            }
-        }
-
-        final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
-            || (ACRA.getConfig().resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
-
-        final TimeHelper sentToastTimeMillis = new TimeHelper();
-        if (shouldDisplayToast) {
-            new Thread() {
-
-                /*
-                 * (non-Javadoc)
-                 *
-                 * @see java.lang.Thread#run()
-                 */
-                @Override
-                public void run() {
-                    Looper.prepare();
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                    sentToastTimeMillis.setInitialTimeMillis(System.currentTimeMillis());
-                    Looper.loop();
-                }
-
-            }.start();
-
-            // We will wait a few seconds at the end of the method to be sure
-            // that the Toast can be read by the user.
-        }
-
-        final CrashReportData crashReportData = crashReportDataFactory.createCrashData(reportBuilder.mMessage,
-                                                                                       reportBuilder.mException, reportBuilder.mCustomData,
-                                                                                       reportBuilder.mForceSilent, reportBuilder.mUncaughtExceptionThread);
-
-        // Always write the report file
-
-        final String reportFileName = getReportFileName(crashReportData);
-        saveCrashReportFile(reportFileName, crashReportData);
-
-        if (reportBuilder.mEndsApplication && !ACRA.getConfig().sendReportsAtShutdown()) {
-            endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-        }
-
-        SendWorker sender = null;
-
-        if (reportingInteractionMode == ReportingInteractionMode.SILENT
-            || reportingInteractionMode == ReportingInteractionMode.TOAST
-            || prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
-
-            // Approve and then send reports now
-            ACRA.log.d(LOG_TAG, "About to start ReportSenderWorker from #handleException");
-            sender = startSendingReports(sendOnlySilentReports, true);
-            if ((reportingInteractionMode == ReportingInteractionMode.SILENT) && !reportBuilder.mEndsApplication) {
-                // Report is being sent silently and the application is not ending.
-                // So no need to wait around for the sender to complete.
-                return;
-            }
-
-        } else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
-            ACRA.log.d(LOG_TAG, "Creating Notification.");
-            createNotification(reportFileName, reportBuilder);
-        }
-
-        toastWaitEnded = true;
-        if (shouldDisplayToast) {
-            // A toast is being displayed, we have to wait for its end before doing anything else.
-            // The toastWaitEnded flag will be checked before any other operation.
-            toastWaitEnded = false;
-            new Thread() {
-
-                @Override
-                public void run() {
-                    ACRA.log.d(LOG_TAG, "Waiting for " + ACRAConstants.TOAST_WAIT_DURATION
-                        + " millis from " + sentToastTimeMillis.initialTimeMillis
-                        + " currentMillis=" + System.currentTimeMillis());
-                    while (sentToastTimeMillis.getElapsedTime() < ACRAConstants.TOAST_WAIT_DURATION) {
-                        try {
-                            // Wait a bit to let the user read the toast
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            ACRA.log.d(LOG_TAG, "Interrupted while waiting for Toast to end.", e1);
-                        }
-                    }
-                    toastWaitEnded = true;
-                }
-            }.start();
-        }
-
-        // Start an AsyncTask waiting for the end of the sender.
-        // Once sent, call endApplication() if reportBuilder.mEndApplication
-        final SendWorker worker = sender;
-        final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
-
-        new Thread() {
-
-            @Override
-            public void run() {
-                // We have to wait for the toast display to be completed.
-                ACRA.log.d(LOG_TAG, "Waiting for Toast");
-                while (!toastWaitEnded) {
-                    try {
-                        Thread.sleep(100);
-                    } catch (InterruptedException e1) {
-                        ACRA.log.d(LOG_TAG, "Error : ", e1);
-                    }
-                }
-                ACRA.log.d(LOG_TAG, "Finished waiting for Toast");
-
-                // We have to wait for the worker job to be completed.
-                if (worker != null) {
-                    ACRA.log.d(LOG_TAG, "Waiting for Worker");
-                    while (worker.isAlive()) {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            ACRA.log.d(LOG_TAG, "Error : ", e1);
-                        }
-                    }
-                    ACRA.log.d(LOG_TAG, "Finished waiting for Worker");
-                }
-
-                if (showDirectDialog) {
-                    // Create a new activity task with the confirmation dialog.
-                    // This new task will be persisted on application restart
-                    // right after its death.
-                    ACRA.log.d(LOG_TAG, "Creating CrashReportDialog for " + reportFileName);
-                    final Intent dialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    mContext.startActivity(dialogIntent);
-                }
-
-                ACRA.log.d(LOG_TAG, "Wait for Toast + worker ended. Kill Application ? " + reportBuilder.mEndsApplication);
-
-                if (reportBuilder.mEndsApplication) {
-                    endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-                }
-            }
-        }.start();
-    }
-
-    /**
-     * Creates an Intent that can be used to create and show a CrashReportDialog.
-     *
-     * @param reportFileName    Name of the error report to display in the crash report dialog.
-     * @param reportBuilder     ReportBuilder containing the details of the crash.
-     */
-    private Intent createCrashReportDialogIntent(String reportFileName, ReportBuilder reportBuilder) {
-        ACRA.log.d(LOG_TAG, "Creating DialogIntent for " + reportFileName + " exception=" + reportBuilder.mException);
-        final Intent dialogIntent = new Intent(mContext, ACRA.getConfig().reportDialogClass());
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME, reportFileName);
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION, reportBuilder.mException);
-        return dialogIntent;
-    }
-
-
-    /**
-     * Creates a status bar notification.
-     *
-     * The action triggered when the notification is selected is to start the
-     * {@link CrashReportDialog} Activity.
-     *
-     * @param reportFileName Name of the report file to send.
-     */
-    private void createNotification(String reportFileName, ReportBuilder reportBuilder) {
-
-        final NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        final ReportsCrashes conf = ACRA.getConfig();
-
-        // Default notification icon is the warning symbol
-        final int icon = conf.resNotifIcon();
-
-        final CharSequence tickerText = mContext.getText(conf.resNotifTickerText());
-        final long when = System.currentTimeMillis();
-        final Notification notification = new Notification(icon, tickerText, when);
-
-        final CharSequence contentTitle = mContext.getText(conf.resNotifTitle());
-        final CharSequence contentText = mContext.getText(conf.resNotifText());
-
-        ACRA.log.d(LOG_TAG, "Creating Notification for " + reportFileName);
-        final Intent crashReportDialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        final PendingIntent contentIntent = PendingIntent.getActivity(mContext, mNotificationCounter++, crashReportDialogIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-
-        notification.setLatestEventInfo(mContext, contentTitle, contentText, contentIntent);
-        notification.flags = notification.flags | Notification.FLAG_AUTO_CANCEL;
-
-        // The deleteIntent is invoked when the user swipes away the Notification.
-        // In this case we invoke the CrashReportDialog with EXTRA_FORCE_CANCEL==true
-        // which will cause BaseCrashReportDialog to clear the crash report and finish itself.
-        final Intent deleteIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
-        notification.deleteIntent = PendingIntent.getActivity(mContext, -1, deleteIntent, 0);
-
-        // Send new notification
-        notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
-    }
-
-    private String getReportFileName(CrashReportData crashData) {
-        final Time now = new Time();
-        now.setToNow();
-        final long timestamp = now.toMillis(false);
-        final String isSilent = crashData.getProperty(IS_SILENT);
-        return "" + timestamp + (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
-            + ACRAConstants.REPORTFILE_EXTENSION;
-    }
-
-    /**
-     * When a report can't be sent, it is saved here in a file in the root of
-     * the application private directory.
-     *
-     * @param fileName
-     *            In a few rare cases, we write the report again with additional
-     *            data (user comment for example). In such cases, you can
-     *            provide the already existing file name here to overwrite the
-     *            report file. If null, a new file report will be generated
-     * @param crashData
-     *            Can be used to save an alternative (or previously generated)
-     *            report data. Used to store again a report with the addition of
-     *            user comment. If null, the default current crash data are
-     *            used.
-     */
-    private void saveCrashReportFile(String fileName, CrashReportData crashData) {
-        try {
-            ACRA.log.d(LOG_TAG, "Writing crash report file " + fileName + ".");
-            final CrashReportPersister persister = new CrashReportPersister(mContext);
-            persister.store(crashData, fileName);
-        } catch (Exception e) {
-            ACRA.log.e(LOG_TAG, "An error occurred while writing the report file...", e);
-        }
-    }
-
-    /**
-     * Delete pending reports.
-     *
-     * @param deleteApprovedReports
-     *            Set to true to delete approved and silent reports.
-     * @param deleteNonApprovedReports
-     *            Set to true to delete non approved/silent reports.
-     * @param nbOfLatestToKeep
-     *            Number of pending reports to retain.
-     */
-    private void deletePendingReports(boolean deleteApprovedReports, boolean deleteNonApprovedReports,
-                                      int nbOfLatestToKeep) {
-        // TODO Check logic and instances where nbOfLatestToKeep = X, because
-        // that might stop us from deleting any reports.
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        final String[] filesList = reportFinder.getCrashReportFiles();
-        Arrays.sort(filesList);
-        for (int iFile = 0; iFile < filesList.length - nbOfLatestToKeep; iFile++) {
-            final String fileName = filesList[iFile];
-            final boolean isReportApproved = fileNameParser.isApproved(fileName);
-            if ((isReportApproved && deleteApprovedReports) || (!isReportApproved && deleteNonApprovedReports)) {
-                final File fileToDelete = new File(mContext.getFilesDir(), fileName);
-                ACRA.log.d(LOG_TAG, "Deleting file " + fileName);
-                if (!fileToDelete.delete()) {
-                    ACRA.log.e(LOG_TAG, "Could not delete report : " + fileToDelete);
-                }
-            }
-        }
-    }
-
-    /**
-     * Checks if an array of reports files names contains only silent or
-     * approved reports.
-     *
-     * @param reportFileNames
-     *            Array of report locations to check.
-     * @return True if there are only silent or approved reports. False if there
-     *         is at least one non-approved report.
-     */
-    private boolean containsOnlySilentOrApprovedReports(String[] reportFileNames) {
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Sets relevant ReportSenders to the ErrorReporter, replacing any
-     * previously set ReportSender.
-     */
-    public void setDefaultReportSenders() {
-        ReportsCrashes conf = ACRA.getConfig();
-        Application mApplication = ACRA.getApplication();
-        removeAllReportSenders();
-
-        // Try to send by mail. If a mailTo address is provided, do not add
-        // other senders.
-        if (!"".equals(conf.mailTo())) {
-            ACRA.log.w(LOG_TAG, mApplication.getPackageName() + " reports will be sent by email (if accepted by user).");
-            setReportSender(new EmailIntentSender(mApplication));
-            return;
-        }
-
-        final PackageManagerWrapper pm = new PackageManagerWrapper(mApplication);
-        if (!pm.hasPermission(permission.INTERNET)) {
-            // NB If the PackageManager has died then this will erroneously log
-            // the error that the App doesn't have Internet (even though it
-            // does).
-            // I think that is a small price to pay to ensure that ACRA doesn't
-            // crash if the PackageManager has died.
-            ACRA.log.e(LOG_TAG,
-                  mApplication.getPackageName()
-                      + " should be granted permission "
-                      + permission.INTERNET
-                      + " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @ReportsCrashes(mailTo=\"your.account@domain.com\"");
-            return;
-        }
-
-        // If formUri is set, instantiate a sender for a generic HTTP POST form
-        // with default mapping.
-        if (conf.formUri() != null && !"".equals(conf.formUri())) {
-            setReportSender(new HttpSender(ACRA.getConfig().httpMethod(), ACRA.getConfig().reportType(), null));
-        }
-    }
-
-    /**
-     * Fluent API used to assemble the different options used for a crash report
-     */
-    public final class ReportBuilder {
-
-        private String mMessage;
-        private Thread mUncaughtExceptionThread;
-        private Throwable mException;
-        private Map<String, String> mCustomData;
-
-        private boolean mForceSilent = false;
-        private boolean mEndsApplication = false;
-
-        /**
-         * Set the error message to be reported.
-         *
-         * @param msg the error message
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder message(String msg) {
-            mMessage = msg;
-            return this;
-        }
-
-        /**
-         * Sets the Thread on which an uncaught Exception occurred.
-         *
-         * @param thread    Thread on which an uncaught Exception occurred.
-         * @return the updated {@code ReportBuilder}
-         */
-        private ReportBuilder uncaughtExceptionThread(Thread thread) {
-            mUncaughtExceptionThread = thread;
-            return this;
-        }
-
-        /**
-         * Set the stack trace to be reported
-         *
-         * @param e The exception that should be associated with this report
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder exception(Throwable e) {
-            mException = e;
-            return this;
-        }
-
-        private void initCustomData() {
-            if (mCustomData ==  null)
-                mCustomData = new HashMap<String, String>();
-        }
-
-        /**
-         * Sets additional values to be added to {@code CUSTOM_DATA}. Values
-         * specified here take precedence over globally specified custom data.
-         *
-         * @param customData a map of custom key-values to be attached to the report
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(Map<String, String> customData) {
-            initCustomData();
-            mCustomData.putAll(customData);
-            return this;
-        }
-
-        /**
-         * Sets an additional value to be added to {@code CUSTOM_DATA}. The value
-         * specified here takes precedence over globally specified custom data.
-         *
-         * @param key the key identifying the custom data
-         * @param value the value for the custom data entry
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(String key, String value) {
-            initCustomData();
-            mCustomData.put(key, value);
-            return this;
-        }
-
-        /**
-         * Forces the report to be sent silently, ignoring the default interaction mode set in the config
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder forceSilent() {
-            mForceSilent = true;
-            return this;
-        }
-
-        /**
-         * Ends the application after sending the crash report
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder endsApplication() {
-            mEndsApplication = true;
-            return this;
-        }
-
-        /**
-         * Assembles and sends the crash report
-         */
-        public void send() {
-            if (mMessage == null && mException == null) {
-                mMessage = "Report requested by developer";
-            }
-            report(this);
-        }
-    }
+	private boolean enabled = false;
+
+	private final Application mContext;
+	private final SharedPreferences prefs;
+
+	/**
+	 * Contains the active {@link ReportSender}s.
+	 */
+	private final List<ReportSender> mReportSenders = new ArrayList<ReportSender>();
+
+	private final CrashReportDataFactory crashReportDataFactory;
+
+	private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+
+	// A reference to the system's previous default UncaughtExceptionHandler
+	// kept in order to execute the default exception handling after sending the
+	// report.
+	private final Thread.UncaughtExceptionHandler mDfltExceptionHandler;
+
+	private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(
+			null);
+
+	/**
+	 * This is used to wait for the crash toast to end it's display duration
+	 * before killing the Application.
+	 */
+	private boolean toastWaitEnded = true;
+
+	private static final ExceptionHandlerInitializer NULL_EXCEPTION_HANDLER_INITIALIZER = new ExceptionHandlerInitializer() {
+		@Override
+		public void initializeExceptionHandler(ErrorReporter reporter) {
+		}
+	};
+
+	private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = NULL_EXCEPTION_HANDLER_INITIALIZER;
+
+	/**
+	 * Used to create a new (non-cached) PendingIntent each time a new crash
+	 * occurs.
+	 */
+	private static int mNotificationCounter = 0;
+
+	/**
+	 * Can only be constructed from within this class.
+	 *
+	 * @param context
+	 *            Context for the application in which ACRA is running.
+	 * @param prefs
+	 *            SharedPreferences used by ACRA.
+	 * @param enabled
+	 *            Whether this ErrorReporter should capture Exceptions and
+	 *            forward their reports.
+	 */
+	ErrorReporter(Application context, SharedPreferences prefs, boolean enabled) {
+
+		this.mContext = context;
+		this.prefs = prefs;
+		this.enabled = enabled;
+
+		// Store the initial Configuration state.
+		// This is expensive to gather, so only do so if we plan to report it.
+		final String initialConfiguration;
+		if (ACRA.getConfig().getReportFields()
+				.contains(ReportField.INITIAL_CONFIGURATION)) {
+			initialConfiguration = ConfigurationCollector
+					.collectConfiguration(mContext);
+		} else {
+			initialConfiguration = null;
+		}
+
+		// Sets the application start date.
+		// This will be included in the reports, will be helpful compared to
+		// user_crash date.
+		final Time appStartDate = new Time();
+		appStartDate.setToNow();
+
+		if (Compatibility.getAPILevel() >= 14) { // ActivityLifecycleCallback
+			// only available for API14+
+			ApplicationHelper.registerActivityLifecycleCallbacks(context,
+					new ActivityLifecycleCallbacksCompat() {
+						@Override
+						public void onActivityCreated(Activity activity,
+								Bundle savedInstanceState) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.d(LOG_TAG, "onActivityCreated "
+										+ activity.getClass());
+							if (!(activity instanceof BaseCrashReportDialog)) {
+								// Ignore CrashReportDialog because we want the
+								// last
+								// application Activity that was started so that
+								// we can
+								// explicitly kill it off.
+								lastActivityCreated = new WeakReference<Activity>(
+										activity);
+							}
+						}
+
+						@Override
+						public void onActivityStarted(Activity activity) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.d(LOG_TAG, "onActivityStarted "
+										+ activity.getClass());
+						}
+
+						@Override
+						public void onActivityResumed(Activity activity) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.d(LOG_TAG, "onActivityResumed "
+										+ activity.getClass());
+						}
+
+						@Override
+						public void onActivityPaused(Activity activity) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.d(LOG_TAG, "onActivityPaused "
+										+ activity.getClass());
+						}
+
+						@Override
+						public void onActivityStopped(Activity activity) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.d(LOG_TAG, "onActivityStopped "
+										+ activity.getClass());
+						}
+
+						@Override
+						public void onActivitySaveInstanceState(
+								Activity activity, Bundle outState) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.i(LOG_TAG,
+										"onActivitySaveInstanceState "
+												+ activity.getClass());
+						}
+
+						@Override
+						public void onActivityDestroyed(Activity activity) {
+							if (ACRA.DEV_LOGGING)
+								ACRA.log.i(LOG_TAG, "onActivityDestroyed "
+										+ activity.getClass());
+						}
+					});
+		}
+
+		crashReportDataFactory = new CrashReportDataFactory(mContext, prefs,
+				appStartDate, initialConfiguration);
+
+		// If mDfltExceptionHandler is not null, initialization is already done.
+		// Don't do it twice to avoid losing the original handler.
+		mDfltExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+		Thread.setDefaultUncaughtExceptionHandler(this);
+	}
+
+	/**
+	 * @return the current instance of ErrorReporter.
+	 * @throws IllegalStateException
+	 *             if {@link ACRA#init(android.app.Application)} has not yet
+	 *             been called.
+	 * @deprecated since 4.3.0 Use {@link org.acra.ACRA#getErrorReporter()}
+	 *             instead.
+	 */
+	@Deprecated
+	public static ErrorReporter getInstance() {
+		return ACRA.getErrorReporter();
+	}
+
+	/**
+	 * Deprecated. Use {@link #putCustomData(String, String)}.
+	 *
+	 * @param key
+	 *            A key for your custom data.
+	 * @param value
+	 *            The value associated to your key.
+	 */
+	@Deprecated
+	@SuppressWarnings("unused")
+	public void addCustomData(String key, String value) {
+		crashReportDataFactory.putCustomData(key, value);
+	}
+
+	/**
+	 * <p>
+	 * Use this method to provide the ErrorReporter with data of your running
+	 * application. You should call this at several key places in your code the
+	 * same way as you would output important debug data in a log file. Only the
+	 * latest value is kept for each key (no history of the values is sent in
+	 * the report).
+	 * </p>
+	 * <p>
+	 * The key/value pairs will be stored in the GoogleDoc spreadsheet in the
+	 * "custom" column, as a text containing a 'key = value' pair on each line.
+	 * </p>
+	 *
+	 * @param key
+	 *            A key for your custom data.
+	 * @param value
+	 *            The value associated to your key.
+	 * @return The previous value for this key if there was one, or null.
+	 * @see #removeCustomData(String)
+	 * @see #getCustomData(String)
+	 */
+	@SuppressWarnings("unused")
+	public String putCustomData(String key, String value) {
+		return crashReportDataFactory.putCustomData(key, value);
+	}
+
+	/**
+	 * <p>
+	 * Use this method to perform additional initialization before the
+	 * ErrorReporter handles a throwable. This can be used, for example, to put
+	 * custom data using {@link #putCustomData(String, String)}, which is not
+	 * available immediately after startup. It can be, for example, last 20
+	 * requests or something else. The call is thread safe.
+	 * </p>
+	 * <p>
+	 * {@link ExceptionHandlerInitializer#initializeExceptionHandler(ErrorReporter)}
+	 * will be executed on the main thread in case of uncaught exception and on
+	 * the caller thread of {@link #handleSilentException(Throwable)} or
+	 * {@link #handleException(Throwable)}.
+	 * </p>
+	 * <p>
+	 * Example. Add to the {@link Application#onCreate()}:
+	 * </p>
+	 * 
+	 * <pre>
+	 * ACRA.getErrorReporter().setExceptionHandlerInitializer(new ExceptionHandlerInitializer() {
+	 *     <code>@Override</code> public void initializeExceptionHandler(ErrorReporter reporter) {
+	 *         reporter.putCustomData("CUSTOM_ACCUMULATED_DATA_TAG", someAccumulatedData.toString);
+	 *     }
+	 * });
+	 * </pre>
+	 * 
+	 * @param initializer
+	 *            The initializer. Can be <code>null</code>.
+	 */
+	public void setExceptionHandlerInitializer(
+			ExceptionHandlerInitializer initializer) {
+		exceptionHandlerInitializer = (initializer != null) ? initializer
+				: NULL_EXCEPTION_HANDLER_INITIALIZER;
+	}
+
+	/**
+	 * Removes a key/value pair from your reports custom data field.
+	 *
+	 * @param key
+	 *            The key of the data to be removed.
+	 * @return The value for this key before removal.
+	 * @see #putCustomData(String, String)
+	 * @see #getCustomData(String)
+	 */
+	@SuppressWarnings("unused")
+	public String removeCustomData(String key) {
+		return crashReportDataFactory.removeCustomData(key);
+	}
+
+	/**
+	 * Removes all key/value pairs from your reports custom data field.
+	 */
+	@SuppressWarnings("unused")
+	public void clearCustomData() {
+		crashReportDataFactory.clearCustomData();
+	}
+
+	/**
+	 * Gets the current value for a key in your reports custom data field.
+	 *
+	 * @param key
+	 *            The key of the data to be retrieved.
+	 * @return The value for this key.
+	 * @see #putCustomData(String, String)
+	 * @see #removeCustomData(String)
+	 */
+	@SuppressWarnings("unused")
+	public String getCustomData(String key) {
+		return crashReportDataFactory.getCustomData(key);
+	}
+
+	/**
+	 * Add a {@link ReportSender} to the list of active {@link ReportSender}s.
+	 *
+	 * @param sender
+	 *            The {@link ReportSender} to be added.
+	 */
+	public void addReportSender(ReportSender sender) {
+		mReportSenders.add(sender);
+	}
+
+	/**
+	 * Remove a specific instance of {@link ReportSender} from the list of
+	 * active {@link ReportSender}s.
+	 *
+	 * @param sender
+	 *            The {@link ReportSender} instance to be removed.
+	 */
+	@SuppressWarnings("unused")
+	public void removeReportSender(ReportSender sender) {
+		mReportSenders.remove(sender);
+	}
+
+	/**
+	 * Remove all {@link ReportSender} instances from a specific class.
+	 *
+	 * @param senderClass
+	 *            ReportSender class whose instances should be removed.
+	 */
+	@SuppressWarnings("unused")
+	public void removeReportSenders(Class<?> senderClass) {
+		if (ReportSender.class.isAssignableFrom(senderClass)) {
+			for (ReportSender sender : mReportSenders) {
+				if (senderClass.isInstance(sender)) {
+					mReportSenders.remove(sender);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Clears the list of active {@link ReportSender}s. You should then call
+	 * {@link #addReportSender(ReportSender)} or ACRA will not send any report
+	 * anymore.
+	 */
+	public void removeAllReportSenders() {
+		mReportSenders.clear();
+	}
+
+	/**
+	 * Removes all previously set {@link ReportSender}s and set the given one as
+	 * the new {@link ReportSender}.
+	 *
+	 * @param sender
+	 *            ReportSender to set as the sole sender for this ErrorReporter.
+	 */
+	public void setReportSender(ReportSender sender) {
+		removeAllReportSenders();
+		addReportSender(sender);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang
+	 * .Thread, java.lang.Throwable)
+	 */
+	@Override
+	public void uncaughtException(Thread t, Throwable e) {
+		try {
+			// If we're not enabled then just pass the Exception on to any
+			// defaultExceptionHandler.
+			if (!enabled) {
+				if (mDfltExceptionHandler != null) {
+					ACRA.log.e(
+							LOG_TAG,
+							"ACRA is disabled for "
+									+ mContext.getPackageName()
+									+ " - forwarding uncaught Exception on to default ExceptionHandler");
+					mDfltExceptionHandler.uncaughtException(t, e);
+				} else {
+					ACRA.log.e(LOG_TAG,
+							"ACRA is disabled for " + mContext.getPackageName()
+									+ " - no default ExceptionHandler");
+					ACRA.log.e(LOG_TAG,
+							"ACRA caught a " + e.getClass().getSimpleName()
+									+ " for " + mContext.getPackageName(), e);
+				}
+				return;
+			}
+
+			ACRA.log.e(LOG_TAG, "ACRA caught a " + e.getClass().getSimpleName()
+					+ " for " + mContext.getPackageName(), e);
+			ACRA.log.d(LOG_TAG, "Building report");
+
+			// Generate and send crash report
+			reportBuilder().uncaughtExceptionThread(t).exception(e)
+					.endsApplication().send();
+		} catch (Throwable fatality) {
+			// ACRA failed. Prevent any recursive call to
+			// ACRA.uncaughtException(), let the native reporter do its job.
+			if (mDfltExceptionHandler != null) {
+				mDfltExceptionHandler.uncaughtException(t, e);
+			}
+		}
+	}
+
+	/**
+	 * End the application.
+	 */
+	private void endApplication(Thread uncaughtExceptionThread, Throwable th) {
+		// TODO It would be better to create an explicit config attribute
+		// #letDefaultHandlerEndApplication
+		// as the intent is clearer and would allows you to switch it off for
+		// SILENT.
+		final boolean letDefaultHandlerEndApplication = (ACRA.getConfig()
+				.mode() == ReportingInteractionMode.SILENT || (ACRA.getConfig()
+				.mode() == ReportingInteractionMode.TOAST && ACRA.getConfig()
+				.forceCloseDialogAfterToast()));
+
+		final boolean handlingUncaughtException = uncaughtExceptionThread != null;
+		if (handlingUncaughtException && letDefaultHandlerEndApplication
+				&& (mDfltExceptionHandler != null)) {
+			// Let the system default handler do it's job and display the force
+			// close dialog.
+			ACRA.log.d(LOG_TAG,
+					"Handing Exception on to default ExceptionHandler");
+			mDfltExceptionHandler
+					.uncaughtException(uncaughtExceptionThread, th);
+		} else {
+			// If ACRA handles user notifications with a Toast or a Notification
+			// the Force Close dialog is one more notification to the user...
+			// We choose to close the process ourselves using the same actions.
+			ACRA.log.e(LOG_TAG, mContext.getPackageName() + " fatal error : "
+					+ th.getMessage(), th);
+
+			// Trying to solve
+			// https://github.com/ACRA/acra/issues/42#issuecomment-12134144
+			// Determine the current/last Activity that was started and close
+			// it. Activity#finish (and maybe it's parent too).
+			final Activity lastActivity = lastActivityCreated.get();
+			if (lastActivity != null) {
+				ACRA.log.i(LOG_TAG,
+						"Finishing the last Activity prior to killing the Process");
+				lastActivity.finish();
+				ACRA.log.i(LOG_TAG, "Finished " + lastActivity.getClass());
+				lastActivityCreated.clear();
+			}
+
+			android.os.Process.killProcess(android.os.Process.myPid());
+			System.exit(10);
+		}
+	}
+
+	/**
+	 * Send a report for this {@link Throwable} silently (forces the use of
+	 * {@link ReportingInteractionMode#SILENT} for this report, whatever is the
+	 * mode set for the application. Very useful for tracking difficult defects.
+	 *
+	 * @param e
+	 *            The {@link Throwable} to be reported. If null the report will
+	 *            contain a new Exception("Report requested by developer").
+	 */
+	public void handleSilentException(Throwable e) {
+		// Mark this report as silent.
+		if (enabled) {
+			reportBuilder().exception(e).forceSilent().send();
+			ACRA.log.d(LOG_TAG, "ACRA sent Silent report.");
+			return;
+		}
+
+		ACRA.log.d(LOG_TAG, "ACRA is disabled. Silent report not sent.");
+	}
+
+	/**
+	 * Enable or disable this ErrorReporter. By default it is enabled.
+	 *
+	 * @param enabled
+	 *            Whether this ErrorReporter should capture Exceptions and
+	 *            forward them as crash reports.
+	 */
+	public void setEnabled(boolean enabled) {
+		ACRA.log.i(LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled")
+				+ " for " + mContext.getPackageName());
+		this.enabled = enabled;
+	}
+
+	/**
+	 * Starts a Thread to start sending outstanding error reports.
+	 *
+	 * @param onlySendSilentReports
+	 *            If true then only send silent reports.
+	 * @param approveReportsFirst
+	 *            If true then approve unapproved reports first.
+	 * @return SendWorker that will be sending the report.s
+	 */
+	SendWorker startSendingReports(boolean onlySendSilentReports,
+			boolean approveReportsFirst) {
+		final SendWorker worker = new SendWorker(mContext, mReportSenders,
+				onlySendSilentReports, approveReportsFirst);
+		worker.start();
+		return worker;
+	}
+
+	/**
+	 * Delete all report files stored.
+	 */
+	void deletePendingReports() {
+		deletePendingReports(true, true, 0);
+	}
+
+	/**
+	 * This method looks for pending reports and does the action required
+	 * depending on the interaction mode set.
+	 */
+	public void checkReportsOnApplicationStart() {
+
+		if (ACRA.getConfig().deleteOldUnsentReportsOnApplicationStart()) {
+			// Delete any old unsent reports if this is a newer version of the
+			// app
+			// than when we last started.
+			final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR,
+					0);
+			final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(
+					mContext);
+			final PackageInfo packageInfo = packageManagerWrapper
+					.getPackageInfo();
+			if (packageInfo != null) {
+				final boolean newVersion = packageInfo.versionCode > lastVersionNr;
+				if (newVersion) {
+					deletePendingReports();
+				}
+				final SharedPreferences.Editor prefsEditor = prefs.edit();
+				prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR,
+						packageInfo.versionCode);
+				prefsEditor.commit();
+			}
+		}
+
+		ReportingInteractionMode reportingInteractionMode = ACRA.getConfig()
+				.mode();
+
+		if ((reportingInteractionMode == ReportingInteractionMode.NOTIFICATION
+				|| reportingInteractionMode == ReportingInteractionMode.DIALOG || reportingInteractionMode == ReportingInteractionMode.DIALOG_EMAIL)
+				&& ACRA.getConfig().deleteUnapprovedReportsOnApplicationStart()) {
+			// NOTIFICATION or DIALOG mode, and there are unapproved reports to
+			// send (latest notification/dialog has been ignored: neither
+			// accepted
+			// nor refused). The application developer has decided that
+			// these reports should not be renotified ==> destroy them all but
+			// one.
+			deletePendingNonApprovedReports(true);
+		}
+
+		final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
+		String[] filesList = reportFinder.getCrashReportFiles();
+
+		if (filesList != null && filesList.length > 0) {
+			// Immediately send reports for SILENT and TOAST modes.
+			// Immediately send reports in NOTIFICATION mode only if they are
+			// all silent or approved.
+			// If there is still one unapproved report in NOTIFICATION mode,
+			// notify it.
+			// If there are unapproved reports in DIALOG mode, show the dialog
+
+			final boolean onlySilentOrApprovedReports = containsOnlySilentOrApprovedReports(filesList);
+
+			if (reportingInteractionMode == ReportingInteractionMode.SILENT
+					|| reportingInteractionMode == ReportingInteractionMode.TOAST
+					|| (onlySilentOrApprovedReports && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION
+							|| reportingInteractionMode == ReportingInteractionMode.DIALOG || reportingInteractionMode == ReportingInteractionMode.DIALOG_EMAIL))) {
+
+				if (reportingInteractionMode == ReportingInteractionMode.TOAST
+						&& !onlySilentOrApprovedReports) {
+					// Display the Toast in TOAST mode only if there are
+					// non-silent reports.
+					ToastSender.sendToast(mContext, ACRA.getConfig()
+							.resToastText(), Toast.LENGTH_LONG);
+				}
+
+				ACRA.log.v(LOG_TAG,
+						"About to start ReportSenderWorker from #checkReportOnApplicationStart");
+				startSendingReports(false, false);
+			}
+
+		}
+	}
+
+	/**
+	 * Delete all pending non approved reports.
+	 *
+	 * @param keepOne
+	 *            If you need to keep the latest report, set this to true.
+	 */
+	void deletePendingNonApprovedReports(boolean keepOne) {
+		// In NOTIFICATION AND DIALOG mode, we have to keep the latest report
+		// which
+		// has been written before killing the app.
+		final int nbReportsToKeep = keepOne ? 1 : 0;
+		deletePendingReports(false, true, nbReportsToKeep);
+	}
+
+	/**
+	 * Send a report for a {@link Throwable} with the reporting interaction mode
+	 * configured by the developer.
+	 *
+	 * @param e
+	 *            The {@link Throwable} to be reported. If null the report will
+	 *            contain a new Exception("Report requested by developer").
+	 * @param endApplication
+	 *            Set this to true if you want the application to be ended after
+	 *            sending the report.
+	 */
+	@SuppressWarnings("unused")
+	public void handleException(Throwable e, boolean endApplication) {
+		final ReportBuilder builder = reportBuilder().exception(e);
+		if (endApplication) {
+			builder.endsApplication();
+		}
+		builder.send();
+	}
+
+	/**
+	 * Send a report for a {@link Throwable} with the reporting interaction mode
+	 * configured by the developer, the application is then killed and restarted
+	 * by the system.
+	 *
+	 * @param e
+	 *            The {@link Throwable} to be reported. If null the report will
+	 *            contain a new Exception("Report requested by developer").
+	 */
+	@SuppressWarnings("unused")
+	public void handleException(Throwable e) {
+		reportBuilder().exception(e).send();
+	}
+
+	/**
+	 * Creates a new crash report builder
+	 *
+	 * @return the newly created {@code ReportBuilder}
+	 */
+	public ReportBuilder reportBuilder() {
+		return new ReportBuilder();
+	}
+
+	/**
+	 * Helps manage
+	 */
+	private static class TimeHelper {
+
+		private Long initialTimeMillis;
+
+		public void setInitialTimeMillis(long initialTimeMillis) {
+			this.initialTimeMillis = initialTimeMillis;
+		}
+
+		/**
+		 * @return 0 if the initial time has yet to be set otherwise returns the
+		 *         difference between now and the initial time.
+		 */
+		public long getElapsedTime() {
+			return (initialTimeMillis == null) ? 0 : System.currentTimeMillis()
+					- initialTimeMillis;
+		}
+	}
+
+	/**
+	 * Try to send a report, if an error occurs stores a report file for a later
+	 * attempt.
+	 *
+	 * @param reportBuilder
+	 *            The report builder used to assemble the report
+	 */
+	private void report(final ReportBuilder reportBuilder) {
+
+		if (!enabled) {
+			return;
+		}
+
+		try {
+			exceptionHandlerInitializer.initializeExceptionHandler(this);
+		} catch (Exception exceptionInRunnable) {
+			ACRA.log.d(LOG_TAG, "Failed to initlize "
+					+ exceptionHandlerInitializer + " from #handleException");
+		}
+
+		boolean sendOnlySilentReports = false;
+		ReportingInteractionMode reportingInteractionMode;
+		if (!reportBuilder.mForceSilent) {
+			// No interaction mode defined, we assume it has been set during
+			// ACRA.initACRA()
+			reportingInteractionMode = ACRA.getConfig().mode();
+		} else {
+			reportingInteractionMode = ReportingInteractionMode.SILENT;
+
+			// An interaction mode has been provided. If ACRA has been
+			// initialized with a non SILENT mode and this mode is overridden
+			// with SILENT, then we have to send only reports which have been
+			// explicitly declared as silent via handleSilentException().
+			if (ACRA.getConfig().mode() != ReportingInteractionMode.SILENT) {
+				sendOnlySilentReports = true;
+			}
+		}
+
+		final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
+				|| (ACRA.getConfig().resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
+
+		final TimeHelper sentToastTimeMillis = new TimeHelper();
+		if (shouldDisplayToast) {
+			new Thread() {
+
+				/*
+				 * (non-Javadoc)
+				 * 
+				 * @see java.lang.Thread#run()
+				 */
+				@Override
+				public void run() {
+					Looper.prepare();
+					ToastSender.sendToast(mContext, ACRA.getConfig()
+							.resToastText(), Toast.LENGTH_LONG);
+					sentToastTimeMillis.setInitialTimeMillis(System
+							.currentTimeMillis());
+					Looper.loop();
+				}
+
+			}.start();
+
+			// We will wait a few seconds at the end of the method to be sure
+			// that the Toast can be read by the user.
+		}
+
+		final CrashReportData crashReportData = crashReportDataFactory
+				.createCrashData(reportBuilder.mMessage,
+						reportBuilder.mException, reportBuilder.mCustomData,
+						reportBuilder.mForceSilent,
+						reportBuilder.mUncaughtExceptionThread);
+
+		// Always write the report file
+
+		final String reportFileName = getReportFileName(crashReportData);
+		saveCrashReportFile(reportFileName, crashReportData);
+
+		if (reportBuilder.mEndsApplication
+				&& !ACRA.getConfig().sendReportsAtShutdown()) {
+			endApplication(reportBuilder.mUncaughtExceptionThread,
+					reportBuilder.mException);
+		}
+
+		SendWorker sender = null;
+
+		if (reportingInteractionMode == ReportingInteractionMode.SILENT
+				|| reportingInteractionMode == ReportingInteractionMode.TOAST
+				|| prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
+
+			// Approve and then send reports now
+			ACRA.log.d(LOG_TAG,
+					"About to start ReportSenderWorker from #handleException");
+			sender = startSendingReports(sendOnlySilentReports, true);
+			if ((reportingInteractionMode == ReportingInteractionMode.SILENT)
+					&& !reportBuilder.mEndsApplication) {
+				// Report is being sent silently and the application is not
+				// ending.
+				// So no need to wait around for the sender to complete.
+				return;
+			}
+
+		} else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
+			ACRA.log.d(LOG_TAG, "Creating Notification.");
+			createNotification(reportFileName, reportBuilder);
+		}
+
+		toastWaitEnded = true;
+		if (shouldDisplayToast) {
+			// A toast is being displayed, we have to wait for its end before
+			// doing anything else.
+			// The toastWaitEnded flag will be checked before any other
+			// operation.
+			toastWaitEnded = false;
+			new Thread() {
+
+				@Override
+				public void run() {
+					ACRA.log.d(LOG_TAG, "Waiting for "
+							+ ACRAConstants.TOAST_WAIT_DURATION
+							+ " millis from "
+							+ sentToastTimeMillis.initialTimeMillis
+							+ " currentMillis=" + System.currentTimeMillis());
+					while (sentToastTimeMillis.getElapsedTime() < ACRAConstants.TOAST_WAIT_DURATION) {
+						try {
+							// Wait a bit to let the user read the toast
+							Thread.sleep(100);
+						} catch (InterruptedException e1) {
+							ACRA.log.d(
+									LOG_TAG,
+									"Interrupted while waiting for Toast to end.",
+									e1);
+						}
+					}
+					toastWaitEnded = true;
+				}
+			}.start();
+		}
+
+		// Start an AsyncTask waiting for the end of the sender.
+		// Once sent, call endApplication() if reportBuilder.mEndApplication
+		final SendWorker worker = sender;
+		final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG || reportingInteractionMode == ReportingInteractionMode.DIALOG_EMAIL)
+				&& !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
+
+		new Thread() {
+
+			@Override
+			public void run() {
+				// We have to wait for the toast display to be completed.
+				ACRA.log.d(LOG_TAG, "Waiting for Toast");
+				while (!toastWaitEnded) {
+					try {
+						Thread.sleep(100);
+					} catch (InterruptedException e1) {
+						ACRA.log.d(LOG_TAG, "Error : ", e1);
+					}
+				}
+				ACRA.log.d(LOG_TAG, "Finished waiting for Toast");
+
+				// We have to wait for the worker job to be completed.
+				if (worker != null) {
+					ACRA.log.d(LOG_TAG, "Waiting for Worker");
+					while (worker.isAlive()) {
+						try {
+							Thread.sleep(100);
+						} catch (InterruptedException e1) {
+							ACRA.log.d(LOG_TAG, "Error : ", e1);
+						}
+					}
+					ACRA.log.d(LOG_TAG, "Finished waiting for Worker");
+				}
+
+				if (showDirectDialog) {
+					// Create a new activity task with the confirmation dialog.
+					// This new task will be persisted on application restart
+					// right after its death.
+					ACRA.log.d(LOG_TAG, "Creating CrashReportDialog for "
+							+ reportFileName);
+					final Intent dialogIntent = createCrashReportDialogIntent(
+							reportFileName, reportBuilder);
+					dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+					mContext.startActivity(dialogIntent);
+				}
+
+				ACRA.log.d(LOG_TAG,
+						"Wait for Toast + worker ended. Kill Application ? "
+								+ reportBuilder.mEndsApplication);
+
+				if (reportBuilder.mEndsApplication) {
+					endApplication(reportBuilder.mUncaughtExceptionThread,
+							reportBuilder.mException);
+				}
+			}
+		}.start();
+	}
+
+	/**
+	 * Creates an Intent that can be used to create and show a
+	 * CrashReportDialog.
+	 *
+	 * @param reportFileName
+	 *            Name of the error report to display in the crash report
+	 *            dialog.
+	 * @param reportBuilder
+	 *            ReportBuilder containing the details of the crash.
+	 */
+	private Intent createCrashReportDialogIntent(String reportFileName,
+			ReportBuilder reportBuilder) {
+		ACRA.log.d(LOG_TAG, "Creating DialogIntent for " + reportFileName
+				+ " exception=" + reportBuilder.mException);
+		final Intent dialogIntent = new Intent(mContext, ACRA.getConfig()
+				.reportDialogClass());
+		dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME,
+				reportFileName);
+		dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION,
+				reportBuilder.mException);
+		return dialogIntent;
+	}
+
+	/**
+	 * Creates a status bar notification.
+	 *
+	 * The action triggered when the notification is selected is to start the
+	 * {@link CrashReportDialog} Activity.
+	 *
+	 * @param reportFileName
+	 *            Name of the report file to send.
+	 */
+	private void createNotification(String reportFileName,
+			ReportBuilder reportBuilder) {
+
+		final NotificationManager notificationManager = (NotificationManager) mContext
+				.getSystemService(Context.NOTIFICATION_SERVICE);
+
+		final ReportsCrashes conf = ACRA.getConfig();
+
+		// Default notification icon is the warning symbol
+		final int icon = conf.resNotifIcon();
+
+		final CharSequence tickerText = mContext.getText(conf
+				.resNotifTickerText());
+		final long when = System.currentTimeMillis();
+		final Notification notification = new Notification(icon, tickerText,
+				when);
+
+		final CharSequence contentTitle = mContext
+				.getText(conf.resNotifTitle());
+		final CharSequence contentText = mContext.getText(conf.resNotifText());
+
+		ACRA.log.d(LOG_TAG, "Creating Notification for " + reportFileName);
+		final Intent crashReportDialogIntent = createCrashReportDialogIntent(
+				reportFileName, reportBuilder);
+		final PendingIntent contentIntent = PendingIntent.getActivity(mContext,
+				mNotificationCounter++, crashReportDialogIntent,
+				PendingIntent.FLAG_UPDATE_CURRENT);
+
+		notification.setLatestEventInfo(mContext, contentTitle, contentText,
+				contentIntent);
+		notification.flags = notification.flags | Notification.FLAG_AUTO_CANCEL;
+
+		// The deleteIntent is invoked when the user swipes away the
+		// Notification.
+		// In this case we invoke the CrashReportDialog with
+		// EXTRA_FORCE_CANCEL==true
+		// which will cause BaseCrashReportDialog to clear the crash report and
+		// finish itself.
+		final Intent deleteIntent = createCrashReportDialogIntent(
+				reportFileName, reportBuilder);
+		deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
+		notification.deleteIntent = PendingIntent.getActivity(mContext, -1,
+				deleteIntent, 0);
+
+		// Send new notification
+		notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
+	}
+
+	private String getReportFileName(CrashReportData crashData) {
+		final Time now = new Time();
+		now.setToNow();
+		final long timestamp = now.toMillis(false);
+		final String isSilent = crashData.getProperty(IS_SILENT);
+		return "" + timestamp
+				+ (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
+				+ ACRAConstants.REPORTFILE_EXTENSION;
+	}
+
+	/**
+	 * When a report can't be sent, it is saved here in a file in the root of
+	 * the application private directory.
+	 *
+	 * @param fileName
+	 *            In a few rare cases, we write the report again with additional
+	 *            data (user comment for example). In such cases, you can
+	 *            provide the already existing file name here to overwrite the
+	 *            report file. If null, a new file report will be generated
+	 * @param crashData
+	 *            Can be used to save an alternative (or previously generated)
+	 *            report data. Used to store again a report with the addition of
+	 *            user comment. If null, the default current crash data are
+	 *            used.
+	 */
+	private void saveCrashReportFile(String fileName, CrashReportData crashData) {
+		try {
+			ACRA.log.d(LOG_TAG, "Writing crash report file " + fileName + ".");
+			final CrashReportPersister persister = new CrashReportPersister(
+					mContext);
+			persister.store(crashData, fileName);
+		} catch (Exception e) {
+			ACRA.log.e(LOG_TAG,
+					"An error occurred while writing the report file...", e);
+		}
+	}
+
+	/**
+	 * Delete pending reports.
+	 *
+	 * @param deleteApprovedReports
+	 *            Set to true to delete approved and silent reports.
+	 * @param deleteNonApprovedReports
+	 *            Set to true to delete non approved/silent reports.
+	 * @param nbOfLatestToKeep
+	 *            Number of pending reports to retain.
+	 */
+	private void deletePendingReports(boolean deleteApprovedReports,
+			boolean deleteNonApprovedReports, int nbOfLatestToKeep) {
+		// TODO Check logic and instances where nbOfLatestToKeep = X, because
+		// that might stop us from deleting any reports.
+		final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
+		final String[] filesList = reportFinder.getCrashReportFiles();
+		Arrays.sort(filesList);
+		for (int iFile = 0; iFile < filesList.length - nbOfLatestToKeep; iFile++) {
+			final String fileName = filesList[iFile];
+			final boolean isReportApproved = fileNameParser
+					.isApproved(fileName);
+			if ((isReportApproved && deleteApprovedReports)
+					|| (!isReportApproved && deleteNonApprovedReports)) {
+				final File fileToDelete = new File(mContext.getFilesDir(),
+						fileName);
+				ACRA.log.d(LOG_TAG, "Deleting file " + fileName);
+				if (!fileToDelete.delete()) {
+					ACRA.log.e(LOG_TAG, "Could not delete report : "
+							+ fileToDelete);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Checks if an array of reports files names contains only silent or
+	 * approved reports.
+	 *
+	 * @param reportFileNames
+	 *            Array of report locations to check.
+	 * @return True if there are only silent or approved reports. False if there
+	 *         is at least one non-approved report.
+	 */
+	private boolean containsOnlySilentOrApprovedReports(String[] reportFileNames) {
+		for (String reportFileName : reportFileNames) {
+			if (!fileNameParser.isApproved(reportFileName)) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * Sets relevant ReportSenders to the ErrorReporter, replacing any
+	 * previously set ReportSender.
+	 */
+	public void setDefaultReportSenders() {
+		ReportsCrashes conf = ACRA.getConfig();
+		Application mApplication = ACRA.getApplication();
+		removeAllReportSenders();
+
+		// Try to send by mail. If a mailTo address is provided, do not add
+		// other senders.
+		if (!"".equals(conf.mailTo())) {
+			ACRA.log.w(LOG_TAG, mApplication.getPackageName()
+					+ " reports will be sent by email (if accepted by user).");
+			setReportSender(new EmailIntentSender(mApplication));
+			return;
+		}
+
+		final PackageManagerWrapper pm = new PackageManagerWrapper(mApplication);
+		if (!pm.hasPermission(permission.INTERNET)) {
+			// NB If the PackageManager has died then this will erroneously log
+			// the error that the App doesn't have Internet (even though it
+			// does).
+			// I think that is a small price to pay to ensure that ACRA doesn't
+			// crash if the PackageManager has died.
+			ACRA.log.e(
+					LOG_TAG,
+					mApplication.getPackageName()
+							+ " should be granted permission "
+							+ permission.INTERNET
+							+ " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @ReportsCrashes(mailTo=\"your.account@domain.com\"");
+			return;
+		}
+
+		// If formUri is set, instantiate a sender for a generic HTTP POST form
+		// with default mapping.
+		if (conf.formUri() != null && !"".equals(conf.formUri())) {
+			setReportSender(new HttpSender(ACRA.getConfig().httpMethod(), ACRA
+					.getConfig().reportType(), null));
+		}
+	}
+
+	/**
+	 * Fluent API used to assemble the different options used for a crash report
+	 */
+	public final class ReportBuilder {
+
+		private String mMessage;
+		private Thread mUncaughtExceptionThread;
+		private Throwable mException;
+		private Map<String, String> mCustomData;
+
+		private boolean mForceSilent = false;
+		private boolean mEndsApplication = false;
+
+		/**
+		 * Set the error message to be reported.
+		 *
+		 * @param msg
+		 *            the error message
+		 * @return the updated {@code ReportBuilder}
+		 */
+		public ReportBuilder message(String msg) {
+			mMessage = msg;
+			return this;
+		}
+
+		/**
+		 * Sets the Thread on which an uncaught Exception occurred.
+		 *
+		 * @param thread
+		 *            Thread on which an uncaught Exception occurred.
+		 * @return the updated {@code ReportBuilder}
+		 */
+		private ReportBuilder uncaughtExceptionThread(Thread thread) {
+			mUncaughtExceptionThread = thread;
+			return this;
+		}
+
+		/**
+		 * Set the stack trace to be reported
+		 *
+		 * @param e
+		 *            The exception that should be associated with this report
+		 * @return the updated {@code ReportBuilder}
+		 */
+		public ReportBuilder exception(Throwable e) {
+			mException = e;
+			return this;
+		}
+
+		private void initCustomData() {
+			if (mCustomData == null)
+				mCustomData = new HashMap<String, String>();
+		}
+
+		/**
+		 * Sets additional values to be added to {@code CUSTOM_DATA}. Values
+		 * specified here take precedence over globally specified custom data.
+		 *
+		 * @param customData
+		 *            a map of custom key-values to be attached to the report
+		 * @return the updated {@code ReportBuilder}
+		 */
+		@SuppressWarnings("unused")
+		public ReportBuilder customData(Map<String, String> customData) {
+			initCustomData();
+			mCustomData.putAll(customData);
+			return this;
+		}
+
+		/**
+		 * Sets an additional value to be added to {@code CUSTOM_DATA}. The
+		 * value specified here takes precedence over globally specified custom
+		 * data.
+		 *
+		 * @param key
+		 *            the key identifying the custom data
+		 * @param value
+		 *            the value for the custom data entry
+		 * @return the updated {@code ReportBuilder}
+		 */
+		@SuppressWarnings("unused")
+		public ReportBuilder customData(String key, String value) {
+			initCustomData();
+			mCustomData.put(key, value);
+			return this;
+		}
+
+		/**
+		 * Forces the report to be sent silently, ignoring the default
+		 * interaction mode set in the config
+		 *
+		 * @return the updated {@code ReportBuilder}
+		 */
+		public ReportBuilder forceSilent() {
+			mForceSilent = true;
+			return this;
+		}
+
+		/**
+		 * Ends the application after sending the crash report
+		 *
+		 * @return the updated {@code ReportBuilder}
+		 */
+		public ReportBuilder endsApplication() {
+			mEndsApplication = true;
+			return this;
+		}
+
+		/**
+		 * Assembles and sends the crash report
+		 */
+		public void send() {
+			if (mMessage == null && mException == null) {
+				mMessage = "Report requested by developer";
+			}
+			report(this);
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/ExceptionHandlerInitializer.java b/src/main/java/org/acra/ExceptionHandlerInitializer.java
index fc532bb9..c9127f0a 100644
--- a/src/main/java/org/acra/ExceptionHandlerInitializer.java
+++ b/src/main/java/org/acra/ExceptionHandlerInitializer.java
@@ -9,10 +9,11 @@
  * @see ErrorReporter#setExceptionHandlerInitializer(ExceptionHandlerInitializer)
  */
 public interface ExceptionHandlerInitializer {
-    /**
-     * Called before {@link ErrorReporter} handles the Exception.
-     * 
-     * @param reporter The {@link ErrorReporter} that will handle the exception
-     */
-    void initializeExceptionHandler(ErrorReporter reporter);
+	/**
+	 * Called before {@link ErrorReporter} handles the Exception.
+	 * 
+	 * @param reporter
+	 *            The {@link ErrorReporter} that will handle the exception
+	 */
+	void initializeExceptionHandler(ErrorReporter reporter);
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/ReportField.java b/src/main/java/org/acra/ReportField.java
index 3815b11b..6d4ddc28 100644
--- a/src/main/java/org/acra/ReportField.java
+++ b/src/main/java/org/acra/ReportField.java
@@ -26,277 +26,278 @@
  * 
  */
 public enum ReportField {
-    /**
-     * Report Identifier
-     */
-    REPORT_ID,
-    /**
-     * Application version code. This is the incremental integer version code
-     * used to differentiate versions on the android market.
-     * 
-     * @see android.content.pm.PackageInfo#versionCode
-     */
-    APP_VERSION_CODE,
-    /**
-     * Application version name.
-     * 
-     * @see android.content.pm.PackageInfo#versionName
-     */
-    APP_VERSION_NAME,
-    /**
-     * Application package name.
-     * 
-     * @see android.content.Context#getPackageName()
-     */
-    PACKAGE_NAME,
-    /**
-     * Base path of the application's private file folder.
-     * 
-     * @see android.content.Context#getFilesDir()
-     */
-    FILE_PATH,
-    /**
-     * Device model name.
-     * 
-     * @see android.os.Build#MODEL
-     */
-    PHONE_MODEL,
-    /**
-     * Device android version name.
-     * 
-     * @see android.os.Build.VERSION#RELEASE
-     */
-    ANDROID_VERSION,
-    /**
-     * Android Build details.
-     * 
-     * @see android.os.Build
-     */
-    BUILD {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Device brand (manufacturer or carrier).
-     * 
-     * @see android.os.Build#BRAND
-     */
-    BRAND,
-    /**
-     * Device overall product code.
-     * 
-     * @see android.os.Build#PRODUCT
-     */
-    PRODUCT,
-    /**
-     * Estimation of the total device memory size based on filesystem stats.
-     */
-    TOTAL_MEM_SIZE,
-    /**
-     * Estimation of the available device memory size based on filesystem stats.
-     */
-    AVAILABLE_MEM_SIZE,
-    /**
-     * Contains key = value pairs defined by the application developer during
-     * the application build.
-     */
-    BUILD_CONFIG {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Contains key = value pairs defined by the application developer during
-     * the application execution.
-     */
-    CUSTOM_DATA {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * The Holy Stack Trace.
-     */
-    STACK_TRACE,
-    /**
-     * A hash of the stack trace, taking only method names into account.<br>
-     * Line numbers are stripped out before computing the hash. This can help you
-     * uniquely identify stack traces.
-     */
-    STACK_TRACE_HASH,
-    /**
-     * {@link Configuration} fields state on the application start.
-     * 
-     * @see Configuration
-     */
-    INITIAL_CONFIGURATION {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * {@link Configuration} fields state on the application crash.
-     * 
-     * @see Configuration
-     */
-    CRASH_CONFIGURATION {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Device display specifications.
-     * 
-     * @see android.view.WindowManager#getDefaultDisplay()
-     */
-    DISPLAY {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Comment added by the user in the CrashReportDialog displayed in
-     * {@link ReportingInteractionMode#NOTIFICATION} mode.
-     */
-    USER_COMMENT,
-    /**
-     * User date on application start.
-     */
-    USER_APP_START_DATE,
-    /**
-     * User date immediately after the crash occurred.
-     */
-    USER_CRASH_DATE,
-    /**
-     * Memory state details for the application process.
-     */
-    DUMPSYS_MEMINFO,
-    /**
-     * Content of the android.os.DropBoxManager (introduced in API level 8).
-     * Requires READ_LOGS permission.
-     */
-    DROPBOX,
-    /**
-     * Logcat default extract. Requires READ_LOGS permission.
-     */
-    LOGCAT,
-    /**
-     * Logcat eventslog extract. Requires READ_LOGS permission.
-     */
-    EVENTSLOG,
-    /**
-     * Logcat radio extract. Requires READ_LOGS permission.
-     */
-    RADIOLOG,
-    /**
-     * True if the report has been explicitly sent silently by the developer.
-     */
-    IS_SILENT,
-    /**
-     * Device unique ID (IMEI). Requires READ_PHONE_STATE permission.
-     */
-    DEVICE_ID,
-    /**
-     * Installation unique ID. This identifier allow you to track a specific
-     * user application installation without using any personal data.
-     */
-    INSTALLATION_ID,
-    /**
-     * User email address. Can be provided by the user in the
-     * {@link ACRA#PREF_USER_EMAIL_ADDRESS} SharedPreference.
-     */
-    USER_EMAIL,
-    /**
-     * Features declared as available on this device by the system.
-     */
-    DEVICE_FEATURES {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * External storage state and standard directories.
-     */
-    ENVIRONMENT {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * System settings.
-     */
-    SETTINGS_SYSTEM {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Secure settings (applications can't modify them).
-     */
-    SETTINGS_SECURE {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Global settings, introduced in Android 4.2 (API level 17) to centralize settings for multiple users.
-     */
-    SETTINGS_GLOBAL {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * SharedPreferences contents
-     */
-    SHARED_PREFERENCES {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Content of your own application log file. To be configured with
-     * {@link ReportsCrashes#applicationLogFile()} to define the path/name of
-     * the log file and {@link ReportsCrashes#applicationLogFileLines()} to set
-     * the number of lines you want to be retrieved.
-     */
-    APPLICATION_LOG,
-    /**
-     * Since Android API Level 16 (Android 4.1 - Jelly Beans), retrieve the list
-     * of supported Media codecs and their capabilities (color format, profile
-     * and level).
-     */
-    MEDIA_CODEC_LIST,
-    /**
-     * Retrieves details of the failing thread (id, name, group name).
-     */
-    THREAD_DETAILS,
-    /**
-     * Retrieves the user IP address(es).
-     */
-    USER_IP;
+	/**
+	 * Report Identifier
+	 */
+	REPORT_ID,
+	/**
+	 * Application version code. This is the incremental integer version code
+	 * used to differentiate versions on the android market.
+	 * 
+	 * @see android.content.pm.PackageInfo#versionCode
+	 */
+	APP_VERSION_CODE,
+	/**
+	 * Application version name.
+	 * 
+	 * @see android.content.pm.PackageInfo#versionName
+	 */
+	APP_VERSION_NAME,
+	/**
+	 * Application package name.
+	 * 
+	 * @see android.content.Context#getPackageName()
+	 */
+	PACKAGE_NAME,
+	/**
+	 * Base path of the application's private file folder.
+	 * 
+	 * @see android.content.Context#getFilesDir()
+	 */
+	FILE_PATH,
+	/**
+	 * Device model name.
+	 * 
+	 * @see android.os.Build#MODEL
+	 */
+	PHONE_MODEL,
+	/**
+	 * Device android version name.
+	 * 
+	 * @see android.os.Build.VERSION#RELEASE
+	 */
+	ANDROID_VERSION,
+	/**
+	 * Android Build details.
+	 * 
+	 * @see android.os.Build
+	 */
+	BUILD {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Device brand (manufacturer or carrier).
+	 * 
+	 * @see android.os.Build#BRAND
+	 */
+	BRAND,
+	/**
+	 * Device overall product code.
+	 * 
+	 * @see android.os.Build#PRODUCT
+	 */
+	PRODUCT,
+	/**
+	 * Estimation of the total device memory size based on filesystem stats.
+	 */
+	TOTAL_MEM_SIZE,
+	/**
+	 * Estimation of the available device memory size based on filesystem stats.
+	 */
+	AVAILABLE_MEM_SIZE,
+	/**
+	 * Contains key = value pairs defined by the application developer during
+	 * the application build.
+	 */
+	BUILD_CONFIG {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Contains key = value pairs defined by the application developer during
+	 * the application execution.
+	 */
+	CUSTOM_DATA {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * The Holy Stack Trace.
+	 */
+	STACK_TRACE,
+	/**
+	 * A hash of the stack trace, taking only method names into account.<br>
+	 * Line numbers are stripped out before computing the hash. This can help
+	 * you uniquely identify stack traces.
+	 */
+	STACK_TRACE_HASH,
+	/**
+	 * {@link Configuration} fields state on the application start.
+	 * 
+	 * @see Configuration
+	 */
+	INITIAL_CONFIGURATION {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * {@link Configuration} fields state on the application crash.
+	 * 
+	 * @see Configuration
+	 */
+	CRASH_CONFIGURATION {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Device display specifications.
+	 * 
+	 * @see android.view.WindowManager#getDefaultDisplay()
+	 */
+	DISPLAY {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Comment added by the user in the CrashReportDialog displayed in
+	 * {@link ReportingInteractionMode#NOTIFICATION} mode.
+	 */
+	USER_COMMENT,
+	/**
+	 * User date on application start.
+	 */
+	USER_APP_START_DATE,
+	/**
+	 * User date immediately after the crash occurred.
+	 */
+	USER_CRASH_DATE,
+	/**
+	 * Memory state details for the application process.
+	 */
+	DUMPSYS_MEMINFO,
+	/**
+	 * Content of the android.os.DropBoxManager (introduced in API level 8).
+	 * Requires READ_LOGS permission.
+	 */
+	DROPBOX,
+	/**
+	 * Logcat default extract. Requires READ_LOGS permission.
+	 */
+	LOGCAT,
+	/**
+	 * Logcat eventslog extract. Requires READ_LOGS permission.
+	 */
+	EVENTSLOG,
+	/**
+	 * Logcat radio extract. Requires READ_LOGS permission.
+	 */
+	RADIOLOG,
+	/**
+	 * True if the report has been explicitly sent silently by the developer.
+	 */
+	IS_SILENT,
+	/**
+	 * Device unique ID (IMEI). Requires READ_PHONE_STATE permission.
+	 */
+	DEVICE_ID,
+	/**
+	 * Installation unique ID. This identifier allow you to track a specific
+	 * user application installation without using any personal data.
+	 */
+	INSTALLATION_ID,
+	/**
+	 * User email address. Can be provided by the user in the
+	 * {@link ACRA#PREF_USER_EMAIL_ADDRESS} SharedPreference.
+	 */
+	USER_EMAIL,
+	/**
+	 * Features declared as available on this device by the system.
+	 */
+	DEVICE_FEATURES {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * External storage state and standard directories.
+	 */
+	ENVIRONMENT {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * System settings.
+	 */
+	SETTINGS_SYSTEM {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Secure settings (applications can't modify them).
+	 */
+	SETTINGS_SECURE {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Global settings, introduced in Android 4.2 (API level 17) to centralize
+	 * settings for multiple users.
+	 */
+	SETTINGS_GLOBAL {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * SharedPreferences contents
+	 */
+	SHARED_PREFERENCES {
+		@Override
+		public boolean containsKeyValuePairs() {
+			return true;
+		}
+	},
+	/**
+	 * Content of your own application log file. To be configured with
+	 * {@link ReportsCrashes#applicationLogFile()} to define the path/name of
+	 * the log file and {@link ReportsCrashes#applicationLogFileLines()} to set
+	 * the number of lines you want to be retrieved.
+	 */
+	APPLICATION_LOG,
+	/**
+	 * Since Android API Level 16 (Android 4.1 - Jelly Beans), retrieve the list
+	 * of supported Media codecs and their capabilities (color format, profile
+	 * and level).
+	 */
+	MEDIA_CODEC_LIST,
+	/**
+	 * Retrieves details of the failing thread (id, name, group name).
+	 */
+	THREAD_DETAILS,
+	/**
+	 * Retrieves the user IP address(es).
+	 */
+	USER_IP;
 
-    /**
-     * Whether this field is a collection of key/value pairs.
-     * 
-     * @return true if the field contains a string with a key/value pair on each
-     *         line, key and value separated by an equal sugn
-     * 
-     */
-    public boolean containsKeyValuePairs() {
-        return false;
-    }
+	/**
+	 * Whether this field is a collection of key/value pairs.
+	 * 
+	 * @return true if the field contains a string with a key/value pair on each
+	 *         line, key and value separated by an equal sugn
+	 * 
+	 */
+	public boolean containsKeyValuePairs() {
+		return false;
+	}
 }
diff --git a/src/main/java/org/acra/ReportingInteractionMode.java b/src/main/java/org/acra/ReportingInteractionMode.java
index 0c84aecd..803a5fd8 100644
--- a/src/main/java/org/acra/ReportingInteractionMode.java
+++ b/src/main/java/org/acra/ReportingInteractionMode.java
@@ -28,26 +28,35 @@
  * </ul>
  */
 public enum ReportingInteractionMode {
-    /**
-     * No interaction, reports are sent silently and a "Force close" dialog
-     * terminates the app.
-     */
-    SILENT,
-    /**
-     * A status bar notification is triggered when the application crashes, the
-     * Force close dialog is not displayed. When the user selects the
-     * notification, a dialog is displayed asking him if he is ok to send a
-     * report.
-     */
-    NOTIFICATION,
-    /**
-     * A simple Toast is triggered when the application crashes, the Force close
-     * dialog is not displayed.
-     */
-    TOAST,
-    /**
-     * Direct dialog: a report confirmation dialog is displayed right after the crash.
-     * Will replace {@link #NOTIFICATION} mode.
-     */
-    DIALOG
+	/**
+	 * No interaction, reports are sent silently and a "Force close" dialog
+	 * terminates the app.
+	 */
+	SILENT,
+	/**
+	 * A status bar notification is triggered when the application crashes, the
+	 * Force close dialog is not displayed. When the user selects the
+	 * notification, a dialog is displayed asking him if he is ok to send a
+	 * report.
+	 */
+	NOTIFICATION,
+	/**
+	 * A simple Toast is triggered when the application crashes, the Force close
+	 * dialog is not displayed.
+	 */
+	TOAST,
+	/**
+	 * Direct dialog: a report confirmation dialog is displayed right after the
+	 * crash. Will replace {@link #NOTIFICATION} mode.
+	 */
+	DIALOG,
+	/**
+	 * Direct dialog: a report confirmation dialog is displayed right after the
+	 * crash. and when user click on ok it will open default email client and
+	 * parse crash data Will replace {@link #NOTIFICATION} mode.
+	 * 
+	 * @Required resDialogTitle , resDialogText , mailTo @parameters in
+	 *           Apllication class
+	 */
+	DIALOG_EMAIL
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/SendWorker.java b/src/main/java/org/acra/SendWorker.java
index 239e6547..5df9a4ec 100644
--- a/src/main/java/org/acra/SendWorker.java
+++ b/src/main/java/org/acra/SendWorker.java
@@ -35,169 +35,185 @@
  */
 final class SendWorker extends Thread {
 
-    private final Context context;
-    private final boolean sendOnlySilentReports;
-    private final boolean approvePendingReports;
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-    private final List<ReportSender> reportSenders;
-
-    /**
-     * Creates a new {@link SendWorker} to try sending pending reports.
-     * 
-     * @param context
-     *            ApplicationContext in which the reports are being sent.
-     * @param reportSenders
-     *            List of ReportSender to use to send the crash reports.
-     * @param sendOnlySilentReports
-     *            If set to true, will send only reports which have been
-     *            explicitly declared as silent by the application developer.
-     * @param approvePendingReports
-     *            if this endWorker should approve pending reports before
-     *            sending any reports.
-     */
-    public SendWorker(Context context, List<ReportSender> reportSenders, boolean sendOnlySilentReports,
-            boolean approvePendingReports) {
-        this.context = context;
-        this.reportSenders = reportSenders;
-        this.sendOnlySilentReports = sendOnlySilentReports;
-        this.approvePendingReports = approvePendingReports;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.lang.Thread#run()
-     */
-    @Override
-    public void run() {
-        if (approvePendingReports) {
-            approvePendingReports();
-        }
-        checkAndSendReports(context, sendOnlySilentReports);
-    }
-
-    /**
-     * Flag all pending reports as "approved" by the user. These reports can be
-     * sent.
-     */
-    private void approvePendingReports() {
-        ACRA.log.d(LOG_TAG, "Mark all pending reports as approved.");
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFileNames = reportFinder.getCrashReportFiles();
-
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                final File reportFile = new File(context.getFilesDir(), reportFileName);
-
-                // TODO look into how this could cause a file to go from
-                // -approved.stacktrace to -approved-approved.stacktrace
-                final String newName = reportFileName.replace(ACRAConstants.REPORTFILE_EXTENSION,
-                        ACRAConstants.APPROVED_SUFFIX + ACRAConstants.REPORTFILE_EXTENSION);
-
-                // TODO Look into whether rename is atomic. Is there a better
-                // option?
-                final File newFile = new File(context.getFilesDir(), newName);
-                if (!reportFile.renameTo(newFile)) {
-                    ACRA.log.e(LOG_TAG, "Could not rename approved report from " + reportFile + " to " + newFile);
-                }
-            }
-        }
-    }
-
-    /**
-     * Send pending reports.
-     * 
-     * @param context
-     *            The application context.
-     * @param sendOnlySilentReports
-     *            Send only reports explicitly declared as SILENT by the
-     *            developer (sent via
-     *            {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    private void checkAndSendReports(Context context, boolean sendOnlySilentReports) {
-        ACRA.log.d(LOG_TAG, "#checkAndSendReports - start");
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFiles = reportFinder.getCrashReportFiles();
-        Arrays.sort(reportFiles);
-
-        int reportsSentCount = 0;
-
-        for (String curFileName : reportFiles) {
-            if (sendOnlySilentReports && !fileNameParser.isSilent(curFileName)) {
-                continue;
-            }
-
-            if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
-                break; // send only a few reports to avoid overloading the
-                       // network
-            }
-
-            ACRA.log.i(LOG_TAG, "Sending file " + curFileName);
-            try {
-                final CrashReportPersister persister = new CrashReportPersister(context);
-                final CrashReportData previousCrashReport = persister.load(curFileName);
-                sendCrashReport(previousCrashReport);
-                deleteFile(context, curFileName);
-            } catch (RuntimeException e) {
-                ACRA.log.e(LOG_TAG, "Failed to send crash reports for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something really unexpected happened. Don't try to
-                       // send any more reports now.
-            } catch (IOException e) {
-                ACRA.log.e(LOG_TAG, "Failed to load crash report for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something unexpected happened when reading the crash
-                       // report. Don't try to send any more reports now.
-            } catch (ReportSenderException e) {
-                ACRA.log.e(LOG_TAG, "Failed to send crash report for " + curFileName, e);
-                // An issue occurred while sending this report but we can still try to
-                // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS
-                // so there's not much to fear about overloading a failing server.
-            }
-            reportsSentCount++;
-        }
-        ACRA.log.d(LOG_TAG, "#checkAndSendReports - finish");
-    }
-
-    /**
-     * Sends the report with all configured ReportSenders. If at least one
-     * sender completed its job, the report is considered as sent and will not
-     * be sent again for failing senders.
-     * 
-     * @param errorContent
-     *            Crash data.
-     * @throws ReportSenderException
-     *             if unable to send the crash report.
-     */
-    private void sendCrashReport(CrashReportData errorContent) throws ReportSenderException {
-        if (!ACRA.isDebuggable() || ACRA.getConfig().sendReportsInDevMode()) {
-            boolean sentAtLeastOnce = false;
-            for (ReportSender sender : reportSenders) {
-                try {
-                    sender.send(context, errorContent);
-                    // If at least one sender worked, don't re-send the report
-                    // later.
-                    sentAtLeastOnce = true;
-                } catch (ReportSenderException e) {
-                    if (!sentAtLeastOnce) {
-                        throw e; // Don't log here because we aren't dealing
-                                 // with the Exception here.
-                    } else {
-                        ACRA.log.w(LOG_TAG,
-                                "ReportSender of class "
-                                        + sender.getClass().getName()
-                                        + " failed but other senders completed their task. ACRA will not send this report again.");
-                    }
-                }
-            }
-        }
-    }
-
-    private void deleteFile(Context context, String fileName) {
-        final boolean deleted = context.deleteFile(fileName);
-        if (!deleted) {
-            ACRA.log.w(LOG_TAG, "Could not delete error report : " + fileName);
-        }
-    }
+	private final Context context;
+	private final boolean sendOnlySilentReports;
+	private final boolean approvePendingReports;
+	private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+	private final List<ReportSender> reportSenders;
+
+	/**
+	 * Creates a new {@link SendWorker} to try sending pending reports.
+	 * 
+	 * @param context
+	 *            ApplicationContext in which the reports are being sent.
+	 * @param reportSenders
+	 *            List of ReportSender to use to send the crash reports.
+	 * @param sendOnlySilentReports
+	 *            If set to true, will send only reports which have been
+	 *            explicitly declared as silent by the application developer.
+	 * @param approvePendingReports
+	 *            if this endWorker should approve pending reports before
+	 *            sending any reports.
+	 */
+	public SendWorker(Context context, List<ReportSender> reportSenders,
+			boolean sendOnlySilentReports, boolean approvePendingReports) {
+		this.context = context;
+		this.reportSenders = reportSenders;
+		this.sendOnlySilentReports = sendOnlySilentReports;
+		this.approvePendingReports = approvePendingReports;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.lang.Thread#run()
+	 */
+	@Override
+	public void run() {
+		if (approvePendingReports) {
+			approvePendingReports();
+		}
+		checkAndSendReports(context, sendOnlySilentReports);
+	}
+
+	/**
+	 * Flag all pending reports as "approved" by the user. These reports can be
+	 * sent.
+	 */
+	private void approvePendingReports() {
+		ACRA.log.d(LOG_TAG, "Mark all pending reports as approved.");
+
+		final CrashReportFinder reportFinder = new CrashReportFinder(context);
+		final String[] reportFileNames = reportFinder.getCrashReportFiles();
+
+		for (String reportFileName : reportFileNames) {
+			if (!fileNameParser.isApproved(reportFileName)) {
+				final File reportFile = new File(context.getFilesDir(),
+						reportFileName);
+
+				// TODO look into how this could cause a file to go from
+				// -approved.stacktrace to -approved-approved.stacktrace
+				final String newName = reportFileName.replace(
+						ACRAConstants.REPORTFILE_EXTENSION,
+						ACRAConstants.APPROVED_SUFFIX
+								+ ACRAConstants.REPORTFILE_EXTENSION);
+
+				// TODO Look into whether rename is atomic. Is there a better
+				// option?
+				final File newFile = new File(context.getFilesDir(), newName);
+				if (!reportFile.renameTo(newFile)) {
+					ACRA.log.e(LOG_TAG,
+							"Could not rename approved report from "
+									+ reportFile + " to " + newFile);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Send pending reports.
+	 * 
+	 * @param context
+	 *            The application context.
+	 * @param sendOnlySilentReports
+	 *            Send only reports explicitly declared as SILENT by the
+	 *            developer (sent via
+	 *            {@link ErrorReporter#handleSilentException(Throwable)}.
+	 */
+	private void checkAndSendReports(Context context,
+			boolean sendOnlySilentReports) {
+		ACRA.log.d(LOG_TAG, "#checkAndSendReports - start");
+		final CrashReportFinder reportFinder = new CrashReportFinder(context);
+		final String[] reportFiles = reportFinder.getCrashReportFiles();
+		Arrays.sort(reportFiles);
+
+		int reportsSentCount = 0;
+
+		for (String curFileName : reportFiles) {
+			if (sendOnlySilentReports && !fileNameParser.isSilent(curFileName)) {
+				continue;
+			}
+
+			if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
+				break; // send only a few reports to avoid overloading the
+						// network
+			}
+
+			ACRA.log.i(LOG_TAG, "Sending file " + curFileName);
+			try {
+				final CrashReportPersister persister = new CrashReportPersister(
+						context);
+				final CrashReportData previousCrashReport = persister
+						.load(curFileName);
+				sendCrashReport(previousCrashReport);
+				deleteFile(context, curFileName);
+			} catch (RuntimeException e) {
+				ACRA.log.e(LOG_TAG, "Failed to send crash reports for "
+						+ curFileName, e);
+				deleteFile(context, curFileName);
+				break; // Something really unexpected happened. Don't try to
+						// send any more reports now.
+			} catch (IOException e) {
+				ACRA.log.e(LOG_TAG, "Failed to load crash report for "
+						+ curFileName, e);
+				deleteFile(context, curFileName);
+				break; // Something unexpected happened when reading the crash
+						// report. Don't try to send any more reports now.
+			} catch (ReportSenderException e) {
+				ACRA.log.e(LOG_TAG, "Failed to send crash report for "
+						+ curFileName, e);
+				// An issue occurred while sending this report but we can still
+				// try to
+				// send other reports. Report sending is limited by
+				// ACRAConstants.MAX_SEND_REPORTS
+				// so there's not much to fear about overloading a failing
+				// server.
+			}
+			reportsSentCount++;
+		}
+		ACRA.log.d(LOG_TAG, "#checkAndSendReports - finish");
+	}
+
+	/**
+	 * Sends the report with all configured ReportSenders. If at least one
+	 * sender completed its job, the report is considered as sent and will not
+	 * be sent again for failing senders.
+	 * 
+	 * @param errorContent
+	 *            Crash data.
+	 * @throws ReportSenderException
+	 *             if unable to send the crash report.
+	 */
+	private void sendCrashReport(CrashReportData errorContent)
+			throws ReportSenderException {
+		if (!ACRA.isDebuggable() || ACRA.getConfig().sendReportsInDevMode()) {
+			boolean sentAtLeastOnce = false;
+			for (ReportSender sender : reportSenders) {
+				try {
+					sender.send(context, errorContent);
+					// If at least one sender worked, don't re-send the report
+					// later.
+					sentAtLeastOnce = true;
+				} catch (ReportSenderException e) {
+					if (!sentAtLeastOnce) {
+						throw e; // Don't log here because we aren't dealing
+									// with the Exception here.
+					} else {
+						ACRA.log.w(
+								LOG_TAG,
+								"ReportSender of class "
+										+ sender.getClass().getName()
+										+ " failed but other senders completed their task. ACRA will not send this report again.");
+					}
+				}
+			}
+		}
+	}
+
+	private void deleteFile(Context context, String fileName) {
+		final boolean deleted = context.deleteFile(fileName);
+		if (!deleted) {
+			ACRA.log.w(LOG_TAG, "Could not delete error report : " + fileName);
+		}
+	}
 }
diff --git a/src/main/java/org/acra/annotation/ReportsCrashes.java b/src/main/java/org/acra/annotation/ReportsCrashes.java
index d4683609..866da7f4 100644
--- a/src/main/java/org/acra/annotation/ReportsCrashes.java
+++ b/src/main/java/org/acra/annotation/ReportsCrashes.java
@@ -38,8 +38,8 @@
 /**
  * Provide configuration elements to the
  * {@link ACRA#init(android.app.Application)} method. The only mandatory
- * configuration item is the {@link #formUri()} parameter which is the Uri
- * to the server that will receive your reports.
+ * configuration item is the {@link #formUri()} parameter which is the Uri to
+ * the server that will receive your reports.
  * 
  * @author Kevin Gaudin
  * 
@@ -50,516 +50,519 @@
 @Inherited
 public @interface ReportsCrashes {
 
-    /**
-     * The Uri of your own server-side script that will receive reports. This is
-     * to use if you don't want to send reports to Google Docs but to your own,
-     * self-hosted script.
-     * 
-     * @return URI of a custom server to which to post reports.
-     */
-    String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * <p>
-     * The interaction mode you want to implement. Default is
-     * {@link ReportingInteractionMode#SILENT} which does not require any
-     * resources configuration.
-     * </p>
-     * <p>
-     * Other modes have resources requirements:
-     * </p>
-     * <ul>
-     * <li>{@link ReportingInteractionMode#TOAST} requires
-     * {@link #resToastText()} to be provided to define the text that you want
-     * to be displayed to the user when a report is being sent.</li>
-     * <li>{@link ReportingInteractionMode#NOTIFICATION} requires
-     * {@link #resNotifTickerText()}, {@link #resNotifTitle()},
-     * {@link #resNotifText()}, {@link #resDialogText()}.</li>
-     * <li>{@link ReportingInteractionMode#DIALOG} requires
-     * {@link #resDialogText()}.</li>
-     * </ul>
-     * <p>
-     * Default is {@link ReportingInteractionMode#SILENT}
-     * </p>
-     * 
-     * @return the interaction mode that you want ACRA to implement.
-     */
-    ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
-
-    /**
-     * @return Resource id for the label of positive button in the crash dialog.
-     *         If not provided, defaults to 'OK'.
-     */
-    int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
-
-    /**
-     * @return Resource id for the label of negative button in the crash dialog.
-     *         If not provided, defaults to 'cancel'.
-     */
-    int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
-
-    /**
-     * @return Resource id for the user comment input label in the crash dialog.
-     *         If not provided, disables the input field.
-     */
-    int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the user email address input label in the crash
-     *         dialog. If not provided, disables the input field.
-     */
-    int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the icon in the crash dialog. Default value is
-     *         the system alert icon.
-     */
-    int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
-
-    /**
-     * @return Resource id for the Toast text triggered when the user accepts to
-     *         send a report in the crash dialog.
-     */
-    int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the text in the crash dialog.
-     */
-    int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the title in the crash dialog.
-     */
-    int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the icon in the status bar notification. Default
-     *         is the system error notification icon.
-     */
-    int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
-
-    /**
-     * @return Resource id for the text in the status bar notification.
-     */
-    int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the ticker text in the status bar notification.
-     */
-    int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the title in the status bar notification.
-     */
-    int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * Resource id for the Toast text triggered when the application crashes if
-     * the {@link ReportingInteractionMode#TOAST} mode is used. Can also be used
-     * in {@link ReportingInteractionMode#NOTIFICATION} and
-     * {@link ReportingInteractionMode#DIALOG} modes to display a Toast message
-     * while the report is being created, before the dialog/notification
-     * appears. This allows the user to know what is happening just before the
-     * application is terminated.
-     * 
-     * @return Resource id for the Toast text triggered when the application
-     *         crashes.
-     */
-    int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Name of the SharedPreferences that will host ACRA settings you
-     *         can make accessible to your users through a preferences screen:
-     *         <ul>
-     *         <li>
-     *         {@link ACRA#PREF_DISABLE_ACRA} or {@link ACRA#PREF_ENABLE_ACRA}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ALWAYS_ACCEPT}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ENABLE_DEVICE_ID}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ENABLE_SYSTEM_LOGS}</li>
-     *         </ul>
-     *         preference. Default is to use the application default
-     *         SharedPreferences, as retrieved with
-     *         {@link PreferenceManager#getDefaultSharedPreferences(Context)}.
-     */
-    String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * If using a custom {@link ReportsCrashes#sharedPreferencesName()}, pass
-     * here the mode that you need for the SharedPreference file creation:
-     * {@link Context#MODE_PRIVATE}, {@link Context#MODE_WORLD_READABLE} or
-     * {@link Context#MODE_WORLD_WRITEABLE}. Default is
-     * {@link Context#MODE_PRIVATE}.
-     * 
-     * @return Mode to use with the SharedPreference creation.
-     * @see Context#getSharedPreferences(String, int)
-     */
-    int sharedPreferencesMode() default ACRAConstants.DEFAULT_SHARED_PREFERENCES_MODE;
-
-    /**
-     * If enabled, DropBox events collection will include system tags:
-     * <ul>
-     * <li>system_app_anr</li>
-     * <li>system_app_wtf</li>
-     * <li>system_app_crash</li>
-     * <li>system_server_anr</li>
-     * <li>system_server_wtf</li>
-     * <li>system_server_crash</li>
-     * <li>BATTERY_DISCHARGE_INFO</li>
-     * <li>SYSTEM_RECOVERY_LOG</li>
-     * <li>SYSTEM_BOOT</li>
-     * <li>SYSTEM_LAST_KMSG</li>
-     * <li>APANIC_CONSOLE</li>
-     * <li>APANIC_THREADS</li>
-     * <li>SYSTEM_RESTART</li>
-     * <li>SYSTEM_TOMBSTONE</li>
-     * <li>data_app_strictmode</li>
-     * </ul>
-     * 
-     * @return True if system tags are to be included as part of DropBox events.
-     */
-    boolean includeDropBoxSystemTags() default ACRAConstants.DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
-
-    /**
-     * @return Array of tags that you want to be fetched when collecting DropBox
-     *         entries.
-     */
-    String[] additionalDropBoxTags() default {};
-
-    /**
-     * @return Number of minutes to look back when collecting events from
-     *         DropBoxManager.
-     */
-    int dropboxCollectionMinutes() default ACRAConstants.DEFAULT_DROPBOX_COLLECTION_MINUTES;
-
-    /**
-     * <p>
-     * Arguments to be passed to the logcat command line. Default is { "-t",
-     * "100", "-v", "time" } for:
-     * </p>
-     * 
-     * <pre>
-     * logcat -t 100 -v time
-     * </pre>
-     * 
-     * <p>
-     * Do not include -b arguments for buffer selection, include
-     * {@link ReportField#EVENTSLOG} and {@link ReportField#RADIOLOG} in
-     * {@link ReportsCrashes#customReportContent()} to activate alternative
-     * logcat buffers reporting. They will use the same other arguments as those
-     * provided here.
-     * </p>
-     * 
-     * <p>
-     * See <a href=
-     * "http://developer.android.com/intl/fr/guide/developing/tools/adb.html#logcatoptions"
-     * >Listing of logcat Command Options</a>.
-     * </p>
-     * 
-     * @return Array of arguments to supply if retrieving the log as part of the
-     *         report.
-     */
-    String[] logcatArguments() default { "-t", "" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time" };
-
-    /**
-     * When using the {@link #formUri()} parameter to send reports to a custom
-     * server-side script, you can set here and in
-     * {@link #formUriBasicAuthPassword()} the credentials for a BASIC HTTP
-     * authentication.
-     * 
-     * @return Login to use when posting reports to a custom server.
-     */
-    String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
-
-    /**
-     * When using the {@link #formUri()} parameter to send reports to a custom
-     * server-side script, you can set here and in
-     * {@link #formUriBasicAuthLogin()} the credentials for a BASIC HTTP
-     * authentication.
-     * 
-     * @return Password to use when posting reports to a custom server.
-     */
-    String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
-
-    /**
-     * <p>
-     * Redefines the list of {@link ReportField}s collected and sent in your
-     * reports. If you modify this list, you have to create a new Google Drive
-     * Spreadsheet &amp; Form which will be based on these fields as column headers.
-     * </p>
-     * <p>
-     * The fields order is significant. You can also use this property to modify
-     * fields order in your reports.
-     * </p>
-     * <p>
-     * The default list is the following, except if you send reports by mail
-     * using {@link #mailTo()}.
-     * </p>
-     * <ul>
-     * <li>
-     * {@link ReportField#REPORT_ID}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_CODE}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_NAME}</li>
-     * <li>
-     * {@link ReportField#PACKAGE_NAME}</li>
-     * <li>
-     * {@link ReportField#FILE_PATH}</li>
-     * <li>
-     * {@link ReportField#PHONE_MODEL}</li>
-     * <li>
-     * {@link ReportField#BRAND}</li>
-     * <li>
-     * {@link ReportField#PRODUCT}</li>
-     * <li>
-     * {@link ReportField#ANDROID_VERSION}</li>
-     * <li>
-     * {@link ReportField#BUILD}</li>
-     * <li>
-     * {@link ReportField#TOTAL_MEM_SIZE}</li>
-     * <li>
-     * {@link ReportField#AVAILABLE_MEM_SIZE}</li>
-     * <li>
-     * {@link ReportField#CUSTOM_DATA}</li>
-     * <li>
-     * {@link ReportField#IS_SILENT}</li>
-     * <li>
-     * {@link ReportField#STACK_TRACE}</li>
-     * <li>
-     * {@link ReportField#INITIAL_CONFIGURATION}</li>
-     * <li>
-     * {@link ReportField#CRASH_CONFIGURATION}</li>
-     * <li>
-     * {@link ReportField#DISPLAY}</li>
-     * <li>
-     * {@link ReportField#USER_COMMENT}</li>
-     * <li>
-     * {@link ReportField#USER_EMAIL}</li>
-     * <li>
-     * {@link ReportField#USER_APP_START_DATE}</li>
-     * <li>
-     * {@link ReportField#USER_CRASH_DATE}</li>
-     * <li>
-     * {@link ReportField#DUMPSYS_MEMINFO}</li>
-     * <li>
-     * {@link ReportField#LOGCAT}</li>
-     * <li>
-     * {@link ReportField#INSTALLATION_ID}</li>
-     * <li>
-     * {@link ReportField#DEVICE_FEATURES}</li>
-     * <li>
-     * {@link ReportField#ENVIRONMENT}</li>
-     * <li>
-     * {@link ReportField#SHARED_PREFERENCES}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_SYSTEM}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_SECURE}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_GLOBAL}</li>
-     * </ul>
-     * 
-     * @return ReportField Array listing the fields to be included in the
-     *         report.
-     */
-    ReportField[] customReportContent() default {};
-
-    /**
-     * <p>
-     * Add your crash reports mailbox here if you want to send reports via
-     * email. This allows to get rid of the INTERNET permission. Reports content
-     * can be customized with {@link #customReportContent()} . Default fields
-     * are:
-     * </p>
-     * <ul>
-     * <li>
-     * {@link ReportField#USER_COMMENT}</li>
-     * <li>
-     * {@link ReportField#ANDROID_VERSION}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_NAME}</li>
-     * <li>
-     * {@link ReportField#BRAND}</li>
-     * <li>
-     * {@link ReportField#PHONE_MODEL}</li>
-     * <li>
-     * {@link ReportField#CUSTOM_DATA}</li>
-     * <li>
-     * {@link ReportField#STACK_TRACE}</li>
-     * </ul>
-     * 
-     * @return email address to which to send reports.
-     */
-    String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * Controls whether unapproved reports are deleted on application start or
-     * not. Default is true. This is a change from versions of ACRA before 3.2
-     * as in {@link ReportingInteractionMode#NOTIFICATION} mode reports were
-     * previously kept until the user explicitly opens the Notification dialog
-     * AND choose to send or discard the report. Until then, on application
-     * restart, ACRA was issuing a new crash notification for previous reports
-     * pending for approval. This could be misunderstood by the user with a new
-     * crash, resulting in bad appreciation of the application.
-     * 
-     * @return true if ACRA should delete unapproved reports on application
-     *         start.
-     */
-    boolean deleteUnapprovedReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
-
-    /**
-     * This property can be used to determine whether old (out of date) reports
-     * should be sent or not. By default they are discarded.
-     * 
-     * @return true if ACRA should delete any unsent reports on startup if the
-     *         application has been updated since the last time the application
-     *         was started.
-     */
-    boolean deleteOldUnsentReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
-
-    /**
-     * @return Value in milliseconds for timeout attempting to connect to a
-     *         network (default 3000ms).
-     */
-    int connectionTimeout() default ACRAConstants.DEFAULT_CONNECTION_TIMEOUT;
-
-    /**
-     * If the request is retried due to timeout, the socketTimeout will double
-     * before retrying the request.
-     * 
-     * @return Value in milliseconds for timeout receiving a response to a
-     *         network request (default 5000ms).
-     * @see #maxNumberOfRequestRetries()
-     */
-    int socketTimeout() default ACRAConstants.DEFAULT_SOCKET_TIMEOUT;
-
-    /**
-     * @return Maximum number of times a network request will be retried when
-     *         receiving the response times out (default 3).
-     * @see #socketTimeout()
-     */
-    int maxNumberOfRequestRetries() default ACRAConstants.DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
-
-    /**
-     * In {@link ReportingInteractionMode#TOAST} mode, set this to true if you
-     * prefer displaying the native Force Close dialog after the Toast.
-     * 
-     * @return true if the Force Close dialog has to be displayed.
-     */
-    boolean forceCloseDialogAfterToast() default ACRAConstants.DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
-
-    /**
-     * Add here your {@link SharedPreferences} identifier Strings if you use
-     * others than your application's default. They will be added to the
-     * {@link ReportField#SHARED_PREFERENCES} field.
-     * 
-     * @return String Array containing the names of the additional preferences.
-     */
-    String[] additionalSharedPreferences() default {};
-
-    /**
-     * Set this to true if you want to include only logcat lines related to your
-     * Application process.
-     * 
-     * @return true if you want to filter logcat with your process id.
-     */
-    boolean logcatFilterByPid() default ACRAConstants.DEFAULT_LOGCAT_FILTER_BY_PID;
-
-    /**
-     * Set this to false if you want to disable sending reports in development
-     * mode. Only signed application packages will send reports. Default value
-     * is true.
-     * 
-     * @return false if reports should not be sent.
-     */
-    boolean sendReportsInDevMode() default ACRAConstants.DEFAULT_SEND_REPORTS_IN_DEV_MODE;
-
-    /**
-     * Set this to false if you want to disable sending reports at the time the
-     * exception is caught. In this case, reports will not be sent until the
-     * application is restarted.
-     *
-     * @return false if reports should not be sent.
-     */
-    boolean sendReportsAtShutdown() default ACRAConstants.DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
-
-    /**
-     * Provide here regex patterns to be evaluated on each SharedPreference key
-     * to exclude KV pairs from the collected SharedPreferences. This allows you
-     * to exclude sensitive user data like passwords to be collected.
-     * 
-     * @return an array of regex patterns, every matching key is not collected.
-     */
-    String[] excludeMatchingSharedPreferencesKeys() default {};
-
-    /**
-     * Provide here regex patterns to be evaluated on each Settings.System,
-     * Settings.Secure and Settings.Global key to exclude KV pairs from the
-     * collected SharedPreferences. This allows you to exclude sensitive data to
-     * be collected.
-     * 
-     * @return an array of regex patterns, every matching key is not collected.
-     */
-    String[] excludeMatchingSettingsKeys() default {};
-
-    /**
-     * The default value will be a BuildConfig class residing in the same package as the Application class.
-     *
-     * @return BuildConfig class from which to read any BuildConfig attributes.
-     */
-    Class buildConfigClass() default Object.class;
-
-    /**
-     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
-     * path/name of your application log file. If the string does not contain
-     * any path separator, the file is assumed as being in
-     * {@link Context#getFilesDir()}.
-     * 
-     * @return a String containing the path/name of your application log file.
-     *         If the string does not containt any path separator, the file is
-     *         assumed as being in {@link Context#getFilesDir()}.
-     */
-    String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
-
-    /**
-     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
-     * number of latest lines of your application log file to be collected.
-     * Default value is 100.
-     * 
-     * @return number of lines to collect.
-     */
-    int applicationLogFileLines() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE_LINES;
-
-    /**
-     * <p>
-     * Set this to true if you need to post reports to your own server using an
-     * SSL connection with a self-signed certificate.
-     * </p>
-     * 
-     * @return True if SSL certificates validation has to be ignored when
-     *         posting reports.
-     */
-    boolean disableSSLCertValidation() default ACRAConstants.DEFAULT_DISABLE_SSL_CERT_VALIDATION;
-
-    String httpsSocketFactoryFactoryClass() default ACRAConstants.DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS;
-
-    /**
-     * @return Class for the CrashReportDialog used when sending intent.
-     *  If not provided, defaults to CrashReportDialog.class
-     */
-    Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
-
-    /**
-     * <p>
-     * The {@link Method} to be used when posting with {@link #formUri()}.
-     * </p>
-     *
-     * @return HTTP method used when posting reports.
-     */
-    Method httpMethod() default Method.POST;
-
-    Type reportType() default Type.FORM;
+	/**
+	 * The Uri of your own server-side script that will receive reports. This is
+	 * to use if you don't want to send reports to Google Docs but to your own,
+	 * self-hosted script.
+	 * 
+	 * @return URI of a custom server to which to post reports.
+	 */
+	String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+	/**
+	 * <p>
+	 * The interaction mode you want to implement. Default is
+	 * {@link ReportingInteractionMode#SILENT} which does not require any
+	 * resources configuration.
+	 * </p>
+	 * <p>
+	 * Other modes have resources requirements:
+	 * </p>
+	 * <ul>
+	 * <li>{@link ReportingInteractionMode#TOAST} requires
+	 * {@link #resToastText()} to be provided to define the text that you want
+	 * to be displayed to the user when a report is being sent.</li>
+	 * <li>{@link ReportingInteractionMode#NOTIFICATION} requires
+	 * {@link #resNotifTickerText()}, {@link #resNotifTitle()},
+	 * {@link #resNotifText()}, {@link #resDialogText()}.</li>
+	 * <li>{@link ReportingInteractionMode#DIALOG} requires
+	 * {@link #resDialogText()}.</li>
+	 * </ul>
+	 * <p>
+	 * Default is {@link ReportingInteractionMode#SILENT}
+	 * </p>
+	 * 
+	 * @return the interaction mode that you want ACRA to implement.
+	 */
+	ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
+
+	/**
+	 * @return Resource id for the label of positive button in the crash dialog.
+	 *         If not provided, defaults to 'OK'.
+	 */
+	int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
+
+	/**
+	 * @return Resource id for the label of negative button in the crash dialog.
+	 *         If not provided, defaults to 'cancel'.
+	 */
+	int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
+
+	/**
+	 * @return Resource id for the user comment input label in the crash dialog.
+	 *         If not provided, disables the input field.
+	 */
+	int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the user email address input label in the crash
+	 *         dialog. If not provided, disables the input field.
+	 */
+	int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the icon in the crash dialog. Default value is
+	 *         the system alert icon.
+	 */
+	int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
+
+	/**
+	 * @return Resource id for the Toast text triggered when the user accepts to
+	 *         send a report in the crash dialog.
+	 */
+	int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the text in the crash dialog.
+	 */
+	int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the title in the crash dialog.
+	 */
+	int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the icon in the status bar notification. Default
+	 *         is the system error notification icon.
+	 */
+	int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
+
+	/**
+	 * @return Resource id for the text in the status bar notification.
+	 */
+	int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the ticker text in the status bar notification.
+	 */
+	int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Resource id for the title in the status bar notification.
+	 */
+	int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * Resource id for the Toast text triggered when the application crashes if
+	 * the {@link ReportingInteractionMode#TOAST} mode is used. Can also be used
+	 * in {@link ReportingInteractionMode#NOTIFICATION} and
+	 * {@link ReportingInteractionMode#DIALOG} modes to display a Toast message
+	 * while the report is being created, before the dialog/notification
+	 * appears. This allows the user to know what is happening just before the
+	 * application is terminated.
+	 * 
+	 * @return Resource id for the Toast text triggered when the application
+	 *         crashes.
+	 */
+	int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+	/**
+	 * @return Name of the SharedPreferences that will host ACRA settings you
+	 *         can make accessible to your users through a preferences screen:
+	 *         <ul>
+	 *         <li>
+	 *         {@link ACRA#PREF_DISABLE_ACRA} or {@link ACRA#PREF_ENABLE_ACRA}</li>
+	 *         <li>
+	 *         {@link ACRA#PREF_ALWAYS_ACCEPT}</li>
+	 *         <li>
+	 *         {@link ACRA#PREF_ENABLE_DEVICE_ID}</li>
+	 *         <li>
+	 *         {@link ACRA#PREF_ENABLE_SYSTEM_LOGS}</li>
+	 *         </ul>
+	 *         preference. Default is to use the application default
+	 *         SharedPreferences, as retrieved with
+	 *         {@link PreferenceManager#getDefaultSharedPreferences(Context)}.
+	 */
+	String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+	/**
+	 * If using a custom {@link ReportsCrashes#sharedPreferencesName()}, pass
+	 * here the mode that you need for the SharedPreference file creation:
+	 * {@link Context#MODE_PRIVATE}, {@link Context#MODE_WORLD_READABLE} or
+	 * {@link Context#MODE_WORLD_WRITEABLE}. Default is
+	 * {@link Context#MODE_PRIVATE}.
+	 * 
+	 * @return Mode to use with the SharedPreference creation.
+	 * @see Context#getSharedPreferences(String, int)
+	 */
+	int sharedPreferencesMode() default ACRAConstants.DEFAULT_SHARED_PREFERENCES_MODE;
+
+	/**
+	 * If enabled, DropBox events collection will include system tags:
+	 * <ul>
+	 * <li>system_app_anr</li>
+	 * <li>system_app_wtf</li>
+	 * <li>system_app_crash</li>
+	 * <li>system_server_anr</li>
+	 * <li>system_server_wtf</li>
+	 * <li>system_server_crash</li>
+	 * <li>BATTERY_DISCHARGE_INFO</li>
+	 * <li>SYSTEM_RECOVERY_LOG</li>
+	 * <li>SYSTEM_BOOT</li>
+	 * <li>SYSTEM_LAST_KMSG</li>
+	 * <li>APANIC_CONSOLE</li>
+	 * <li>APANIC_THREADS</li>
+	 * <li>SYSTEM_RESTART</li>
+	 * <li>SYSTEM_TOMBSTONE</li>
+	 * <li>data_app_strictmode</li>
+	 * </ul>
+	 * 
+	 * @return True if system tags are to be included as part of DropBox events.
+	 */
+	boolean includeDropBoxSystemTags() default ACRAConstants.DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
+
+	/**
+	 * @return Array of tags that you want to be fetched when collecting DropBox
+	 *         entries.
+	 */
+	String[] additionalDropBoxTags() default {};
+
+	/**
+	 * @return Number of minutes to look back when collecting events from
+	 *         DropBoxManager.
+	 */
+	int dropboxCollectionMinutes() default ACRAConstants.DEFAULT_DROPBOX_COLLECTION_MINUTES;
+
+	/**
+	 * <p>
+	 * Arguments to be passed to the logcat command line. Default is { "-t",
+	 * "100", "-v", "time" } for:
+	 * </p>
+	 * 
+	 * <pre>
+	 * logcat -t 100 -v time
+	 * </pre>
+	 * 
+	 * <p>
+	 * Do not include -b arguments for buffer selection, include
+	 * {@link ReportField#EVENTSLOG} and {@link ReportField#RADIOLOG} in
+	 * {@link ReportsCrashes#customReportContent()} to activate alternative
+	 * logcat buffers reporting. They will use the same other arguments as those
+	 * provided here.
+	 * </p>
+	 * 
+	 * <p>
+	 * See <a href=
+	 * "http://developer.android.com/intl/fr/guide/developing/tools/adb.html#logcatoptions"
+	 * >Listing of logcat Command Options</a>.
+	 * </p>
+	 * 
+	 * @return Array of arguments to supply if retrieving the log as part of the
+	 *         report.
+	 */
+	String[] logcatArguments() default { "-t",
+			"" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time" };
+
+	/**
+	 * When using the {@link #formUri()} parameter to send reports to a custom
+	 * server-side script, you can set here and in
+	 * {@link #formUriBasicAuthPassword()} the credentials for a BASIC HTTP
+	 * authentication.
+	 * 
+	 * @return Login to use when posting reports to a custom server.
+	 */
+	String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
+
+	/**
+	 * When using the {@link #formUri()} parameter to send reports to a custom
+	 * server-side script, you can set here and in
+	 * {@link #formUriBasicAuthLogin()} the credentials for a BASIC HTTP
+	 * authentication.
+	 * 
+	 * @return Password to use when posting reports to a custom server.
+	 */
+	String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
+
+	/**
+	 * <p>
+	 * Redefines the list of {@link ReportField}s collected and sent in your
+	 * reports. If you modify this list, you have to create a new Google Drive
+	 * Spreadsheet &amp; Form which will be based on these fields as column
+	 * headers.
+	 * </p>
+	 * <p>
+	 * The fields order is significant. You can also use this property to modify
+	 * fields order in your reports.
+	 * </p>
+	 * <p>
+	 * The default list is the following, except if you send reports by mail
+	 * using {@link #mailTo()}.
+	 * </p>
+	 * <ul>
+	 * <li>
+	 * {@link ReportField#REPORT_ID}</li>
+	 * <li>
+	 * {@link ReportField#APP_VERSION_CODE}</li>
+	 * <li>
+	 * {@link ReportField#APP_VERSION_NAME}</li>
+	 * <li>
+	 * {@link ReportField#PACKAGE_NAME}</li>
+	 * <li>
+	 * {@link ReportField#FILE_PATH}</li>
+	 * <li>
+	 * {@link ReportField#PHONE_MODEL}</li>
+	 * <li>
+	 * {@link ReportField#BRAND}</li>
+	 * <li>
+	 * {@link ReportField#PRODUCT}</li>
+	 * <li>
+	 * {@link ReportField#ANDROID_VERSION}</li>
+	 * <li>
+	 * {@link ReportField#BUILD}</li>
+	 * <li>
+	 * {@link ReportField#TOTAL_MEM_SIZE}</li>
+	 * <li>
+	 * {@link ReportField#AVAILABLE_MEM_SIZE}</li>
+	 * <li>
+	 * {@link ReportField#CUSTOM_DATA}</li>
+	 * <li>
+	 * {@link ReportField#IS_SILENT}</li>
+	 * <li>
+	 * {@link ReportField#STACK_TRACE}</li>
+	 * <li>
+	 * {@link ReportField#INITIAL_CONFIGURATION}</li>
+	 * <li>
+	 * {@link ReportField#CRASH_CONFIGURATION}</li>
+	 * <li>
+	 * {@link ReportField#DISPLAY}</li>
+	 * <li>
+	 * {@link ReportField#USER_COMMENT}</li>
+	 * <li>
+	 * {@link ReportField#USER_EMAIL}</li>
+	 * <li>
+	 * {@link ReportField#USER_APP_START_DATE}</li>
+	 * <li>
+	 * {@link ReportField#USER_CRASH_DATE}</li>
+	 * <li>
+	 * {@link ReportField#DUMPSYS_MEMINFO}</li>
+	 * <li>
+	 * {@link ReportField#LOGCAT}</li>
+	 * <li>
+	 * {@link ReportField#INSTALLATION_ID}</li>
+	 * <li>
+	 * {@link ReportField#DEVICE_FEATURES}</li>
+	 * <li>
+	 * {@link ReportField#ENVIRONMENT}</li>
+	 * <li>
+	 * {@link ReportField#SHARED_PREFERENCES}</li>
+	 * <li>
+	 * {@link ReportField#SETTINGS_SYSTEM}</li>
+	 * <li>
+	 * {@link ReportField#SETTINGS_SECURE}</li>
+	 * <li>
+	 * {@link ReportField#SETTINGS_GLOBAL}</li>
+	 * </ul>
+	 * 
+	 * @return ReportField Array listing the fields to be included in the
+	 *         report.
+	 */
+	ReportField[] customReportContent() default {};
+
+	/**
+	 * <p>
+	 * Add your crash reports mailbox here if you want to send reports via
+	 * email. This allows to get rid of the INTERNET permission. Reports content
+	 * can be customized with {@link #customReportContent()} . Default fields
+	 * are:
+	 * </p>
+	 * <ul>
+	 * <li>
+	 * {@link ReportField#USER_COMMENT}</li>
+	 * <li>
+	 * {@link ReportField#ANDROID_VERSION}</li>
+	 * <li>
+	 * {@link ReportField#APP_VERSION_NAME}</li>
+	 * <li>
+	 * {@link ReportField#BRAND}</li>
+	 * <li>
+	 * {@link ReportField#PHONE_MODEL}</li>
+	 * <li>
+	 * {@link ReportField#CUSTOM_DATA}</li>
+	 * <li>
+	 * {@link ReportField#STACK_TRACE}</li>
+	 * </ul>
+	 * 
+	 * @return email address to which to send reports.
+	 */
+	String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+	/**
+	 * Controls whether unapproved reports are deleted on application start or
+	 * not. Default is true. This is a change from versions of ACRA before 3.2
+	 * as in {@link ReportingInteractionMode#NOTIFICATION} mode reports were
+	 * previously kept until the user explicitly opens the Notification dialog
+	 * AND choose to send or discard the report. Until then, on application
+	 * restart, ACRA was issuing a new crash notification for previous reports
+	 * pending for approval. This could be misunderstood by the user with a new
+	 * crash, resulting in bad appreciation of the application.
+	 * 
+	 * @return true if ACRA should delete unapproved reports on application
+	 *         start.
+	 */
+	boolean deleteUnapprovedReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
+
+	/**
+	 * This property can be used to determine whether old (out of date) reports
+	 * should be sent or not. By default they are discarded.
+	 * 
+	 * @return true if ACRA should delete any unsent reports on startup if the
+	 *         application has been updated since the last time the application
+	 *         was started.
+	 */
+	boolean deleteOldUnsentReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
+
+	/**
+	 * @return Value in milliseconds for timeout attempting to connect to a
+	 *         network (default 3000ms).
+	 */
+	int connectionTimeout() default ACRAConstants.DEFAULT_CONNECTION_TIMEOUT;
+
+	/**
+	 * If the request is retried due to timeout, the socketTimeout will double
+	 * before retrying the request.
+	 * 
+	 * @return Value in milliseconds for timeout receiving a response to a
+	 *         network request (default 5000ms).
+	 * @see #maxNumberOfRequestRetries()
+	 */
+	int socketTimeout() default ACRAConstants.DEFAULT_SOCKET_TIMEOUT;
+
+	/**
+	 * @return Maximum number of times a network request will be retried when
+	 *         receiving the response times out (default 3).
+	 * @see #socketTimeout()
+	 */
+	int maxNumberOfRequestRetries() default ACRAConstants.DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
+
+	/**
+	 * In {@link ReportingInteractionMode#TOAST} mode, set this to true if you
+	 * prefer displaying the native Force Close dialog after the Toast.
+	 * 
+	 * @return true if the Force Close dialog has to be displayed.
+	 */
+	boolean forceCloseDialogAfterToast() default ACRAConstants.DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
+
+	/**
+	 * Add here your {@link SharedPreferences} identifier Strings if you use
+	 * others than your application's default. They will be added to the
+	 * {@link ReportField#SHARED_PREFERENCES} field.
+	 * 
+	 * @return String Array containing the names of the additional preferences.
+	 */
+	String[] additionalSharedPreferences() default {};
+
+	/**
+	 * Set this to true if you want to include only logcat lines related to your
+	 * Application process.
+	 * 
+	 * @return true if you want to filter logcat with your process id.
+	 */
+	boolean logcatFilterByPid() default ACRAConstants.DEFAULT_LOGCAT_FILTER_BY_PID;
+
+	/**
+	 * Set this to false if you want to disable sending reports in development
+	 * mode. Only signed application packages will send reports. Default value
+	 * is true.
+	 * 
+	 * @return false if reports should not be sent.
+	 */
+	boolean sendReportsInDevMode() default ACRAConstants.DEFAULT_SEND_REPORTS_IN_DEV_MODE;
+
+	/**
+	 * Set this to false if you want to disable sending reports at the time the
+	 * exception is caught. In this case, reports will not be sent until the
+	 * application is restarted.
+	 *
+	 * @return false if reports should not be sent.
+	 */
+	boolean sendReportsAtShutdown() default ACRAConstants.DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
+
+	/**
+	 * Provide here regex patterns to be evaluated on each SharedPreference key
+	 * to exclude KV pairs from the collected SharedPreferences. This allows you
+	 * to exclude sensitive user data like passwords to be collected.
+	 * 
+	 * @return an array of regex patterns, every matching key is not collected.
+	 */
+	String[] excludeMatchingSharedPreferencesKeys() default {};
+
+	/**
+	 * Provide here regex patterns to be evaluated on each Settings.System,
+	 * Settings.Secure and Settings.Global key to exclude KV pairs from the
+	 * collected SharedPreferences. This allows you to exclude sensitive data to
+	 * be collected.
+	 * 
+	 * @return an array of regex patterns, every matching key is not collected.
+	 */
+	String[] excludeMatchingSettingsKeys() default {};
+
+	/**
+	 * The default value will be a BuildConfig class residing in the same
+	 * package as the Application class.
+	 *
+	 * @return BuildConfig class from which to read any BuildConfig attributes.
+	 */
+	Class buildConfigClass() default Object.class;
+
+	/**
+	 * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
+	 * path/name of your application log file. If the string does not contain
+	 * any path separator, the file is assumed as being in
+	 * {@link Context#getFilesDir()}.
+	 * 
+	 * @return a String containing the path/name of your application log file.
+	 *         If the string does not containt any path separator, the file is
+	 *         assumed as being in {@link Context#getFilesDir()}.
+	 */
+	String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
+
+	/**
+	 * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
+	 * number of latest lines of your application log file to be collected.
+	 * Default value is 100.
+	 * 
+	 * @return number of lines to collect.
+	 */
+	int applicationLogFileLines() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE_LINES;
+
+	/**
+	 * <p>
+	 * Set this to true if you need to post reports to your own server using an
+	 * SSL connection with a self-signed certificate.
+	 * </p>
+	 * 
+	 * @return True if SSL certificates validation has to be ignored when
+	 *         posting reports.
+	 */
+	boolean disableSSLCertValidation() default ACRAConstants.DEFAULT_DISABLE_SSL_CERT_VALIDATION;
+
+	String httpsSocketFactoryFactoryClass() default ACRAConstants.DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS;
+
+	/**
+	 * @return Class for the CrashReportDialog used when sending intent. If not
+	 *         provided, defaults to CrashReportDialog.class
+	 */
+	Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
+
+	/**
+	 * <p>
+	 * The {@link Method} to be used when posting with {@link #formUri()}.
+	 * </p>
+	 *
+	 * @return HTTP method used when posting reports.
+	 */
+	Method httpMethod() default Method.POST;
+
+	Type reportType() default Type.FORM;
 }
diff --git a/src/main/java/org/acra/collector/CollectorUtil.java b/src/main/java/org/acra/collector/CollectorUtil.java
index fa0f8b5b..166a115c 100644
--- a/src/main/java/org/acra/collector/CollectorUtil.java
+++ b/src/main/java/org/acra/collector/CollectorUtil.java
@@ -5,18 +5,21 @@
 
 public final class CollectorUtil {
 
-    /**
-     * Closes a Reader.
-     *
-     * @param reader    Reader to close. If reader is null then method just returns.
-     */
-    public static void safeClose(Reader reader) {
-    	if (reader == null) return;
-    	
-        try {
-            reader.close();
-        } catch (IOException e) {
-            // We made out best effort to release this resource. Nothing more we can do.
-        }
-    }
+	/**
+	 * Closes a Reader.
+	 *
+	 * @param reader
+	 *            Reader to close. If reader is null then method just returns.
+	 */
+	public static void safeClose(Reader reader) {
+		if (reader == null)
+			return;
+
+		try {
+			reader.close();
+		} catch (IOException e) {
+			// We made out best effort to release this resource. Nothing more we
+			// can do.
+		}
+	}
 }
diff --git a/src/main/java/org/acra/collector/Compatibility.java b/src/main/java/org/acra/collector/Compatibility.java
index 32ac14fb..e1b73e37 100644
--- a/src/main/java/org/acra/collector/Compatibility.java
+++ b/src/main/java/org/acra/collector/Compatibility.java
@@ -15,11 +15,11 @@
  */
 package org.acra.collector;
 
+import java.lang.reflect.Field;
+
 import android.content.Context;
 import android.os.Build;
 
-import java.lang.reflect.Field;
-
 /**
  * Utility class containing methods enabling backward compatibility.
  * 
@@ -28,42 +28,45 @@
  */
 public final class Compatibility {
 
-    /**
-     * Retrieves Android SDK API level using the best possible method.
-     * 
-     * @return The Android SDK API int level.
-     */
-    public static int getAPILevel() {
-        int apiLevel;
-        try {
-            // This field has been added in Android 1.6
-            final Field SDK_INT = Build.VERSION.class.getField("SDK_INT");
-            apiLevel = SDK_INT.getInt(null);
-        } catch (SecurityException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (NoSuchFieldException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalArgumentException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalAccessException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        }
+	/**
+	 * Retrieves Android SDK API level using the best possible method.
+	 * 
+	 * @return The Android SDK API int level.
+	 */
+	public static int getAPILevel() {
+		int apiLevel;
+		try {
+			// This field has been added in Android 1.6
+			final Field SDK_INT = Build.VERSION.class.getField("SDK_INT");
+			apiLevel = SDK_INT.getInt(null);
+		} catch (SecurityException e) {
+			apiLevel = Integer.parseInt(Build.VERSION.SDK);
+		} catch (NoSuchFieldException e) {
+			apiLevel = Integer.parseInt(Build.VERSION.SDK);
+		} catch (IllegalArgumentException e) {
+			apiLevel = Integer.parseInt(Build.VERSION.SDK);
+		} catch (IllegalAccessException e) {
+			apiLevel = Integer.parseInt(Build.VERSION.SDK);
+		}
 
-        return apiLevel;
-    }
+		return apiLevel;
+	}
 
-    /**
-     * Retrieve the DropBoxManager service name using reflection API.
-     *
-     * @return Name of the DropBox service regardless of Android version.
-     * @throws NoSuchFieldException if the field DROPBOX_SERVICE doesn't exist.
-     * @throws IllegalAccessException if the DROPBOX_SERVICE field is inaccessible.
-     */
-    public static String getDropBoxServiceName() throws NoSuchFieldException, IllegalAccessException {
-        final Field serviceName = Context.class.getField("DROPBOX_SERVICE");
-        if (serviceName != null) {
-            return (String) serviceName.get(null);
-        }
-        return null;
-    }
+	/**
+	 * Retrieve the DropBoxManager service name using reflection API.
+	 *
+	 * @return Name of the DropBox service regardless of Android version.
+	 * @throws NoSuchFieldException
+	 *             if the field DROPBOX_SERVICE doesn't exist.
+	 * @throws IllegalAccessException
+	 *             if the DROPBOX_SERVICE field is inaccessible.
+	 */
+	public static String getDropBoxServiceName() throws NoSuchFieldException,
+			IllegalAccessException {
+		final Field serviceName = Context.class.getField("DROPBOX_SERVICE");
+		if (serviceName != null) {
+			return (String) serviceName.get(null);
+		}
+		return null;
+	}
 }
diff --git a/src/main/java/org/acra/collector/ConfigurationCollector.java b/src/main/java/org/acra/collector/ConfigurationCollector.java
index 07d03f65..02a643a7 100644
--- a/src/main/java/org/acra/collector/ConfigurationCollector.java
+++ b/src/main/java/org/acra/collector/ConfigurationCollector.java
@@ -40,194 +40,208 @@
  */
 public final class ConfigurationCollector {
 
-    private static final String SUFFIX_MASK = "_MASK";
-    private static final String FIELD_SCREENLAYOUT = "screenLayout";
-    private static final String FIELD_UIMODE = "uiMode";
-    private static final String FIELD_MNC = "mnc";
-    private static final String FIELD_MCC = "mcc";
-    private static final String PREFIX_UI_MODE = "UI_MODE_";
-    private static final String PREFIX_TOUCHSCREEN = "TOUCHSCREEN_";
-    private static final String PREFIX_SCREENLAYOUT = "SCREENLAYOUT_";
-    private static final String PREFIX_ORIENTATION = "ORIENTATION_";
-    private static final String PREFIX_NAVIGATIONHIDDEN = "NAVIGATIONHIDDEN_";
-    private static final String PREFIX_NAVIGATION = "NAVIGATION_";
-    private static final String PREFIX_KEYBOARDHIDDEN = "KEYBOARDHIDDEN_";
-    private static final String PREFIX_KEYBOARD = "KEYBOARD_";
-    private static final String PREFIX_HARDKEYBOARDHIDDEN = "HARDKEYBOARDHIDDEN_";
-
-    private final HashMap<String, SparseArray<String>> mValueArrays = new HashMap<String, SparseArray<String>>();
-
-    private ConfigurationCollector() {
-
-        final SparseArray<String> hardKeyboardHiddenValues = new SparseArray<String>();
-        final SparseArray<String> keyboardValues = new SparseArray<String>();
-        final SparseArray<String> keyboardHiddenValues = new SparseArray<String>();
-        final SparseArray<String> navigationValues = new SparseArray<String>();
-        final SparseArray<String> navigationHiddenValues = new SparseArray<String>();
-        final SparseArray<String> orientationValues = new SparseArray<String>();
-        final SparseArray<String> screenLayoutValues = new SparseArray<String>();
-        final SparseArray<String> touchScreenValues = new SparseArray<String>();
-        final SparseArray<String> uiModeValues = new SparseArray<String>();
-
-        for (final Field f : Configuration.class.getFields()) {
-            if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
-                final String fieldName = f.getName();
-                try {
-                    if (fieldName.startsWith(PREFIX_HARDKEYBOARDHIDDEN)) {
-                        hardKeyboardHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_KEYBOARD)) {
-                        keyboardValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_KEYBOARDHIDDEN)) {
-                        keyboardHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_NAVIGATION)) {
-                        navigationValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_NAVIGATIONHIDDEN)) {
-                        navigationHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_ORIENTATION)) {
-                        orientationValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_SCREENLAYOUT)) {
-                        screenLayoutValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_TOUCHSCREEN)) {
-                        touchScreenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_UI_MODE)) {
-                        uiModeValues.put(f.getInt(null), fieldName);
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
-                }
-            }
-        }
-
-        mValueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, hardKeyboardHiddenValues);
-        mValueArrays.put(PREFIX_KEYBOARD, keyboardValues);
-        mValueArrays.put(PREFIX_KEYBOARDHIDDEN, keyboardHiddenValues);
-        mValueArrays.put(PREFIX_NAVIGATION, navigationValues);
-        mValueArrays.put(PREFIX_NAVIGATIONHIDDEN, navigationHiddenValues);
-        mValueArrays.put(PREFIX_ORIENTATION, orientationValues);
-        mValueArrays.put(PREFIX_SCREENLAYOUT, screenLayoutValues);
-        mValueArrays.put(PREFIX_TOUCHSCREEN, touchScreenValues);
-        mValueArrays.put(PREFIX_UI_MODE, uiModeValues);
-    }
-
-    /**
-     * Use this method to generate a human readable String listing all values
-     * from the provided Configuration instance.
-     * 
-     * @param conf
-     *            The Configuration to be described.
-     * @return A String describing all the fields of the given Configuration,
-     *         with values replaced by constant names.
-     */
-    private String toString(Configuration conf) {
-        final StringBuilder result = new StringBuilder();
-        for (final Field f : conf.getClass().getFields()) {
-            try {
-                if (!Modifier.isStatic(f.getModifiers())) {
-                    final String fieldName = f.getName();
-                    result.append(fieldName).append('=');
-                    if (f.getType().equals(int.class)) {
-                        result.append(getFieldValueName(conf, f));
-                    } else if(f.get(conf) != null){
-                        result.append(f.get(conf).toString());
-                    }
-                    result.append('\n');
-                }
-            } catch (IllegalArgumentException e) {
-                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            } catch (IllegalAccessException e) {
-                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            }
-        }
-        return result.toString();
-    }
-
-    /**
-     * Retrieve the name of the constant defined in the {@link Configuration}
-     * class which defines the value of a field in a {@link Configuration}
-     * instance.
-     * 
-     * @param conf
-     *            The instance of {@link Configuration} where the value is
-     *            stored.
-     * @param f
-     *            The {@link Field} to be inspected in the {@link Configuration}
-     *            instance.
-     * @return The value of the field f in instance conf translated to its
-     *         constant name.
-     * @throws IllegalAccessException if the supplied field is inaccessible.
-     */
-    private String getFieldValueName(Configuration conf, Field f) throws IllegalAccessException {
-        final String fieldName = f.getName();
-        if (fieldName.equals(FIELD_MCC) || fieldName.equals(FIELD_MNC)) {
-            return Integer.toString(f.getInt(conf));
-        } else if (fieldName.equals(FIELD_UIMODE)) {
-            return activeFlags(mValueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
-        } else if (fieldName.equals(FIELD_SCREENLAYOUT)) {
-            return activeFlags(mValueArrays.get(PREFIX_SCREENLAYOUT), f.getInt(conf));
-        } else {
-            final SparseArray<String> values = mValueArrays.get(fieldName.toUpperCase() + '_');
-            if (values == null) {
-                // Unknown field, return the raw int as String
-                return Integer.toString(f.getInt(conf));
-            }
-
-            final String value = values.get(f.getInt(conf));
-            if (value == null) {
-                // Unknown value, return the raw int as String
-                return Integer.toString(f.getInt(conf));
-            }
-            return value;
-        }
-    }
-
-    /**
-     * Some fields contain multiple value types which can be isolated by
-     * applying a bitmask. That method returns the concatenation of active
-     * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
-     * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
-     */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
-        final StringBuilder result = new StringBuilder();
-
-        // Look for masks, apply it an retrieve the masked value
-        for (int i = 0; i < valueNames.size(); i++) {
-            final int maskValue = valueNames.keyAt(i);
-            if (valueNames.get(maskValue).endsWith(SUFFIX_MASK)) {
-                final int value = bitfield & maskValue;
-                if (value > 0) {
-                    if (result.length() > 0) {
-                        result.append('+');
-                    }
-                    result.append(valueNames.get(value));
-                }
-            }
-        }
-        return result.toString();
-    }
-    
-    /**
-     * Returns the current Configuration for this application.
-     *
-     * @param context   Context for the application being reported.
-     * @return A String representation of the current configuration for the application.
-     */
-    public static String collectConfiguration(Context context) {
-        try {
-            final ConfigurationCollector collector = new ConfigurationCollector();
-            final Configuration crashConf = context.getResources().getConfiguration();
-            return collector.toString(crashConf);
-        } catch (RuntimeException e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve CrashConfiguration for : " + context.getPackageName(), e);
-            return "Couldn't retrieve crash config";
-        }
-    }
+	private static final String SUFFIX_MASK = "_MASK";
+	private static final String FIELD_SCREENLAYOUT = "screenLayout";
+	private static final String FIELD_UIMODE = "uiMode";
+	private static final String FIELD_MNC = "mnc";
+	private static final String FIELD_MCC = "mcc";
+	private static final String PREFIX_UI_MODE = "UI_MODE_";
+	private static final String PREFIX_TOUCHSCREEN = "TOUCHSCREEN_";
+	private static final String PREFIX_SCREENLAYOUT = "SCREENLAYOUT_";
+	private static final String PREFIX_ORIENTATION = "ORIENTATION_";
+	private static final String PREFIX_NAVIGATIONHIDDEN = "NAVIGATIONHIDDEN_";
+	private static final String PREFIX_NAVIGATION = "NAVIGATION_";
+	private static final String PREFIX_KEYBOARDHIDDEN = "KEYBOARDHIDDEN_";
+	private static final String PREFIX_KEYBOARD = "KEYBOARD_";
+	private static final String PREFIX_HARDKEYBOARDHIDDEN = "HARDKEYBOARDHIDDEN_";
+
+	private final HashMap<String, SparseArray<String>> mValueArrays = new HashMap<String, SparseArray<String>>();
+
+	private ConfigurationCollector() {
+
+		final SparseArray<String> hardKeyboardHiddenValues = new SparseArray<String>();
+		final SparseArray<String> keyboardValues = new SparseArray<String>();
+		final SparseArray<String> keyboardHiddenValues = new SparseArray<String>();
+		final SparseArray<String> navigationValues = new SparseArray<String>();
+		final SparseArray<String> navigationHiddenValues = new SparseArray<String>();
+		final SparseArray<String> orientationValues = new SparseArray<String>();
+		final SparseArray<String> screenLayoutValues = new SparseArray<String>();
+		final SparseArray<String> touchScreenValues = new SparseArray<String>();
+		final SparseArray<String> uiModeValues = new SparseArray<String>();
+
+		for (final Field f : Configuration.class.getFields()) {
+			if (Modifier.isStatic(f.getModifiers())
+					&& Modifier.isFinal(f.getModifiers())) {
+				final String fieldName = f.getName();
+				try {
+					if (fieldName.startsWith(PREFIX_HARDKEYBOARDHIDDEN)) {
+						hardKeyboardHiddenValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_KEYBOARD)) {
+						keyboardValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_KEYBOARDHIDDEN)) {
+						keyboardHiddenValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_NAVIGATION)) {
+						navigationValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_NAVIGATIONHIDDEN)) {
+						navigationHiddenValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_ORIENTATION)) {
+						orientationValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_SCREENLAYOUT)) {
+						screenLayoutValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_TOUCHSCREEN)) {
+						touchScreenValues.put(f.getInt(null), fieldName);
+					} else if (fieldName.startsWith(PREFIX_UI_MODE)) {
+						uiModeValues.put(f.getInt(null), fieldName);
+					}
+				} catch (IllegalArgumentException e) {
+					ACRA.log.w(LOG_TAG,
+							"Error while inspecting device configuration: ", e);
+				} catch (IllegalAccessException e) {
+					ACRA.log.w(LOG_TAG,
+							"Error while inspecting device configuration: ", e);
+				}
+			}
+		}
+
+		mValueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, hardKeyboardHiddenValues);
+		mValueArrays.put(PREFIX_KEYBOARD, keyboardValues);
+		mValueArrays.put(PREFIX_KEYBOARDHIDDEN, keyboardHiddenValues);
+		mValueArrays.put(PREFIX_NAVIGATION, navigationValues);
+		mValueArrays.put(PREFIX_NAVIGATIONHIDDEN, navigationHiddenValues);
+		mValueArrays.put(PREFIX_ORIENTATION, orientationValues);
+		mValueArrays.put(PREFIX_SCREENLAYOUT, screenLayoutValues);
+		mValueArrays.put(PREFIX_TOUCHSCREEN, touchScreenValues);
+		mValueArrays.put(PREFIX_UI_MODE, uiModeValues);
+	}
+
+	/**
+	 * Use this method to generate a human readable String listing all values
+	 * from the provided Configuration instance.
+	 * 
+	 * @param conf
+	 *            The Configuration to be described.
+	 * @return A String describing all the fields of the given Configuration,
+	 *         with values replaced by constant names.
+	 */
+	private String toString(Configuration conf) {
+		final StringBuilder result = new StringBuilder();
+		for (final Field f : conf.getClass().getFields()) {
+			try {
+				if (!Modifier.isStatic(f.getModifiers())) {
+					final String fieldName = f.getName();
+					result.append(fieldName).append('=');
+					if (f.getType().equals(int.class)) {
+						result.append(getFieldValueName(conf, f));
+					} else if (f.get(conf) != null) {
+						result.append(f.get(conf).toString());
+					}
+					result.append('\n');
+				}
+			} catch (IllegalArgumentException e) {
+				ACRA.log.e(LOG_TAG,
+						"Error while inspecting device configuration: ", e);
+			} catch (IllegalAccessException e) {
+				ACRA.log.e(LOG_TAG,
+						"Error while inspecting device configuration: ", e);
+			}
+		}
+		return result.toString();
+	}
+
+	/**
+	 * Retrieve the name of the constant defined in the {@link Configuration}
+	 * class which defines the value of a field in a {@link Configuration}
+	 * instance.
+	 * 
+	 * @param conf
+	 *            The instance of {@link Configuration} where the value is
+	 *            stored.
+	 * @param f
+	 *            The {@link Field} to be inspected in the {@link Configuration}
+	 *            instance.
+	 * @return The value of the field f in instance conf translated to its
+	 *         constant name.
+	 * @throws IllegalAccessException
+	 *             if the supplied field is inaccessible.
+	 */
+	private String getFieldValueName(Configuration conf, Field f)
+			throws IllegalAccessException {
+		final String fieldName = f.getName();
+		if (fieldName.equals(FIELD_MCC) || fieldName.equals(FIELD_MNC)) {
+			return Integer.toString(f.getInt(conf));
+		} else if (fieldName.equals(FIELD_UIMODE)) {
+			return activeFlags(mValueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
+		} else if (fieldName.equals(FIELD_SCREENLAYOUT)) {
+			return activeFlags(mValueArrays.get(PREFIX_SCREENLAYOUT),
+					f.getInt(conf));
+		} else {
+			final SparseArray<String> values = mValueArrays.get(fieldName
+					.toUpperCase() + '_');
+			if (values == null) {
+				// Unknown field, return the raw int as String
+				return Integer.toString(f.getInt(conf));
+			}
+
+			final String value = values.get(f.getInt(conf));
+			if (value == null) {
+				// Unknown value, return the raw int as String
+				return Integer.toString(f.getInt(conf));
+			}
+			return value;
+		}
+	}
+
+	/**
+	 * Some fields contain multiple value types which can be isolated by
+	 * applying a bitmask. That method returns the concatenation of active
+	 * values.
+	 * 
+	 * @param valueNames
+	 *            The array containing the different values and names for this
+	 *            field. Must contain mask values too.
+	 * @param bitfield
+	 *            The bitfield to inspect.
+	 * @return The names of the different values contained in the bitfield,
+	 *         separated by '+'.
+	 */
+	private static String activeFlags(SparseArray<String> valueNames,
+			int bitfield) {
+		final StringBuilder result = new StringBuilder();
+
+		// Look for masks, apply it an retrieve the masked value
+		for (int i = 0; i < valueNames.size(); i++) {
+			final int maskValue = valueNames.keyAt(i);
+			if (valueNames.get(maskValue).endsWith(SUFFIX_MASK)) {
+				final int value = bitfield & maskValue;
+				if (value > 0) {
+					if (result.length() > 0) {
+						result.append('+');
+					}
+					result.append(valueNames.get(value));
+				}
+			}
+		}
+		return result.toString();
+	}
+
+	/**
+	 * Returns the current Configuration for this application.
+	 *
+	 * @param context
+	 *            Context for the application being reported.
+	 * @return A String representation of the current configuration for the
+	 *         application.
+	 */
+	public static String collectConfiguration(Context context) {
+		try {
+			final ConfigurationCollector collector = new ConfigurationCollector();
+			final Configuration crashConf = context.getResources()
+					.getConfiguration();
+			return collector.toString(crashConf);
+		} catch (RuntimeException e) {
+			ACRA.log.w(LOG_TAG, "Couldn't retrieve CrashConfiguration for : "
+					+ context.getPackageName(), e);
+			return "Couldn't retrieve crash config";
+		}
+	}
 }
diff --git a/src/main/java/org/acra/collector/CrashReportData.java b/src/main/java/org/acra/collector/CrashReportData.java
index 60aae535..1139074f 100644
--- a/src/main/java/org/acra/collector/CrashReportData.java
+++ b/src/main/java/org/acra/collector/CrashReportData.java
@@ -25,34 +25,35 @@
 import org.json.JSONObject;
 
 /**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link Properties} adapted to extend an
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as
+ * keys. This is basically the source of {@link Properties} adapted to extend an
  * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
  * amounts of android time in the generation of a date comment when storing to
  * file.
  */
 public final class CrashReportData extends EnumMap<ReportField, String> {
 
-    private static final long serialVersionUID = 4112578634029874840L;
-
-    /**
-     * Constructs a new {@code Properties} object.
-     */
-    public CrashReportData() {
-        super(ReportField.class);
-    }
-
-    /**
-     * Returns the property with the specified name.
-     * 
-     * @param key the name of the property to find.
-     * @return the named property value, or {@code null} if it can't be found.
-     */
-    public String getProperty(ReportField key) {
-        return super.get(key);
-    }
-
-    public JSONObject toJSON() throws JSONReportException {
-        return JSONReportBuilder.buildJSONReport(this);
-    }
+	private static final long serialVersionUID = 4112578634029874840L;
+
+	/**
+	 * Constructs a new {@code Properties} object.
+	 */
+	public CrashReportData() {
+		super(ReportField.class);
+	}
+
+	/**
+	 * Returns the property with the specified name.
+	 * 
+	 * @param key
+	 *            the name of the property to find.
+	 * @return the named property value, or {@code null} if it can't be found.
+	 */
+	public String getProperty(ReportField key) {
+		return super.get(key);
+	}
+
+	public JSONObject toJSON() throws JSONReportException {
+		return JSONReportBuilder.buildJSONReport(this);
+	}
 }
diff --git a/src/main/java/org/acra/collector/CrashReportDataFactory.java b/src/main/java/org/acra/collector/CrashReportDataFactory.java
index 0122f575..7b2af2e1 100644
--- a/src/main/java/org/acra/collector/CrashReportDataFactory.java
+++ b/src/main/java/org/acra/collector/CrashReportDataFactory.java
@@ -17,7 +17,45 @@
 package org.acra.collector;
 
 import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.*;
+import static org.acra.ReportField.ANDROID_VERSION;
+import static org.acra.ReportField.APPLICATION_LOG;
+import static org.acra.ReportField.APP_VERSION_CODE;
+import static org.acra.ReportField.APP_VERSION_NAME;
+import static org.acra.ReportField.AVAILABLE_MEM_SIZE;
+import static org.acra.ReportField.BRAND;
+import static org.acra.ReportField.BUILD;
+import static org.acra.ReportField.BUILD_CONFIG;
+import static org.acra.ReportField.CRASH_CONFIGURATION;
+import static org.acra.ReportField.CUSTOM_DATA;
+import static org.acra.ReportField.DEVICE_FEATURES;
+import static org.acra.ReportField.DEVICE_ID;
+import static org.acra.ReportField.DISPLAY;
+import static org.acra.ReportField.DROPBOX;
+import static org.acra.ReportField.DUMPSYS_MEMINFO;
+import static org.acra.ReportField.ENVIRONMENT;
+import static org.acra.ReportField.EVENTSLOG;
+import static org.acra.ReportField.FILE_PATH;
+import static org.acra.ReportField.INITIAL_CONFIGURATION;
+import static org.acra.ReportField.INSTALLATION_ID;
+import static org.acra.ReportField.IS_SILENT;
+import static org.acra.ReportField.LOGCAT;
+import static org.acra.ReportField.MEDIA_CODEC_LIST;
+import static org.acra.ReportField.PACKAGE_NAME;
+import static org.acra.ReportField.PHONE_MODEL;
+import static org.acra.ReportField.PRODUCT;
+import static org.acra.ReportField.RADIOLOG;
+import static org.acra.ReportField.REPORT_ID;
+import static org.acra.ReportField.SETTINGS_GLOBAL;
+import static org.acra.ReportField.SETTINGS_SECURE;
+import static org.acra.ReportField.SETTINGS_SYSTEM;
+import static org.acra.ReportField.SHARED_PREFERENCES;
+import static org.acra.ReportField.STACK_TRACE;
+import static org.acra.ReportField.STACK_TRACE_HASH;
+import static org.acra.ReportField.THREAD_DETAILS;
+import static org.acra.ReportField.TOTAL_MEM_SIZE;
+import static org.acra.ReportField.USER_CRASH_DATE;
+import static org.acra.ReportField.USER_EMAIL;
+import static org.acra.ReportField.USER_IP;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -53,394 +91,459 @@
  */
 public final class CrashReportDataFactory {
 
-    private final Context context;
-    private final SharedPreferences prefs;
-    private final Map<String, String> customParameters = new LinkedHashMap<String, String>();
-    private final Time appStartDate;
-    private final String initialConfiguration;
-
-    public CrashReportDataFactory(Context context, SharedPreferences prefs, Time appStartDate,
-                                  String initialConfiguration) {
-        this.context = context;
-        this.prefs = prefs;
-        this.appStartDate = appStartDate;
-        this.initialConfiguration = initialConfiguration;
-    }
-
-    /**
-     * <p>
-     * Adds a custom key and value to be reported with the generated
-     * CashReportData.
-     * </p>
-     * <p>
-     * The key/value pairs will be stored in the "custom" column, as a text
-     * containing one 'key = value' pair on each line.
-     * </p>
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     * @return The previous value for this key if there was one, or null.
-     */
-    public String putCustomData(String key, String value) {
-        return customParameters.put(key, value);
-    }
-
-    /**
-     * Removes a key/value pair from the custom data field.
-     *
-     * @param key
-     *            The key of the data to be removed.
-     * @return The value for this key before removal.
-     */
-    public String removeCustomData(String key) {
-        return customParameters.remove(key);
-    }
-
-    /**
-     * Removes all key/value pairs from the custom data field.
-     */
-    public void clearCustomData() {
-        customParameters.clear();
-    }
-
-    /**
-     * Gets the current value for a key in the custom data field.
-     *
-     * @param key
-     *            The key of the data to be retrieved.
-     * @return The value for this key.
-     */
-    public String getCustomData(String key) {
-        return customParameters.get(key);
-    }
-
-    /**
-     * Collects crash data.
-     *
-     * @param msg
-     *            A message to be associated with the crash report.
-     * @param th
-     *            Throwable that caused the crash.
-     * @param customData
-     *            Custom key/value pairs to be associated with the crash report.
-     * @param isSilentReport
-     *            Whether to report this report as being sent silently.
-     * @param brokenThread  Thread on which the error occurred.
-     * @return CrashReportData representing the current state of the application
-     *         at the instant of the Exception.
-     */
-    public CrashReportData createCrashData(String msg, Throwable th, Map<String, String> customData, boolean isSilentReport, Thread brokenThread) {
-        final CrashReportData crashReportData = new CrashReportData();
-        try {
-            final List<ReportField> crashReportFields = ACRA.getConfig().getReportFields();
-
-            // Make every entry here bullet proof and move any slightly dodgy
-            // ones to the end.
-            // This ensures that we collect as much info as possible before
-            // something crashes the collection process.
-
-            crashReportData.put(STACK_TRACE, getStackTrace(msg, th));
-            crashReportData.put(ReportField.USER_APP_START_DATE, ReportUtils.getTimeString(appStartDate));
-
-            if (isSilentReport) {
-                crashReportData.put(IS_SILENT, "true");
-            }
-
-            // StackTrace hash
-            if (crashReportFields.contains(STACK_TRACE_HASH)) {
-                crashReportData.put(ReportField.STACK_TRACE_HASH, getStackTraceHash(th));
-            }
-
-            // Generate report uuid
-            if (crashReportFields.contains(REPORT_ID)) {
-                crashReportData.put(ReportField.REPORT_ID, UUID.randomUUID().toString());
-            }
-
-            // Installation unique ID
-            if (crashReportFields.contains(INSTALLATION_ID)) {
-                crashReportData.put(INSTALLATION_ID, Installation.id(context));
-            }
-
-            // Device Configuration when crashing
-            if (crashReportFields.contains(INITIAL_CONFIGURATION)) {
-                crashReportData.put(INITIAL_CONFIGURATION, initialConfiguration);
-            }
-            if (crashReportFields.contains(CRASH_CONFIGURATION)) {
-                crashReportData.put(CRASH_CONFIGURATION, ConfigurationCollector.collectConfiguration(context));
-            }
-
-            // Collect meminfo
-            if (!(th instanceof OutOfMemoryError) && crashReportFields.contains(DUMPSYS_MEMINFO)) {
-                crashReportData.put(DUMPSYS_MEMINFO, DumpSysCollector.collectMemInfo());
-            }
-
-            // Application Package name
-            if (crashReportFields.contains(PACKAGE_NAME)) {
-                crashReportData.put(PACKAGE_NAME, context.getPackageName());
-            }
-
-            // Android OS Build details
-            if (crashReportFields.contains(BUILD)) {
-                crashReportData.put(BUILD, ReflectionCollector.collectConstants(android.os.Build.class) + ReflectionCollector.collectConstants(android.os.Build.VERSION.class, "VERSION"));
-            }
-
-            // Device model
-            if (crashReportFields.contains(PHONE_MODEL)) {
-                crashReportData.put(PHONE_MODEL, android.os.Build.MODEL);
-            }
-            // Android version
-            if (crashReportFields.contains(ANDROID_VERSION)) {
-                crashReportData.put(ANDROID_VERSION, android.os.Build.VERSION.RELEASE);
-            }
-
-            // Device Brand (manufacturer)
-            if (crashReportFields.contains(BRAND)) {
-                crashReportData.put(BRAND, android.os.Build.BRAND);
-            }
-            if (crashReportFields.contains(PRODUCT)) {
-                crashReportData.put(PRODUCT, android.os.Build.PRODUCT);
-            }
-
-            // Device Memory
-            if (crashReportFields.contains(TOTAL_MEM_SIZE)) {
-                crashReportData.put(TOTAL_MEM_SIZE, Long.toString(ReportUtils.getTotalInternalMemorySize()));
-            }
-            if (crashReportFields.contains(AVAILABLE_MEM_SIZE)) {
-                crashReportData.put(AVAILABLE_MEM_SIZE, Long.toString(ReportUtils.getAvailableInternalMemorySize()));
-            }
-
-            // Application file path
-            if (crashReportFields.contains(FILE_PATH)) {
-                crashReportData.put(FILE_PATH, ReportUtils.getApplicationFilePath(context));
-            }
-
-            // Main display details
-            if (crashReportFields.contains(DISPLAY)) {
-                crashReportData.put(DISPLAY, DisplayManagerCollector.collectDisplays(context));
-            }
-
-            // User crash date with local timezone
-            if (crashReportFields.contains(USER_CRASH_DATE)) {
-                final Time curDate = new Time();
-                curDate.setToNow();
-                crashReportData.put(USER_CRASH_DATE, ReportUtils.getTimeString(curDate));
-            }
-
-            // Add custom info, they are all stored in a single field
-            if (crashReportFields.contains(CUSTOM_DATA)) {
-                crashReportData.put(CUSTOM_DATA, createCustomInfoString(customData));
-            }
-
-            if (crashReportFields.contains(BUILD_CONFIG)) {
-                try {
-                    final Class buildConfigClass = getBuildConfigClass();
-                    crashReportData.put(BUILD_CONFIG, ReflectionCollector.collectConstants(buildConfigClass));
-                } catch (ClassNotFoundException e) {
-                    // We have already logged this when we had the name of the class that wasn't found.
-                }
-            }
-
-            // Add user email address, if set in the app's preferences
-            if (crashReportFields.contains(USER_EMAIL)) {
-                crashReportData.put(USER_EMAIL, prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "N/A"));
-            }
-
-            // Device features
-            if (crashReportFields.contains(DEVICE_FEATURES)) {
-                crashReportData.put(DEVICE_FEATURES, DeviceFeaturesCollector.getFeatures(context));
-            }
-
-            // Environment (External storage state)
-            if (crashReportFields.contains(ENVIRONMENT)) {
-                crashReportData.put(ENVIRONMENT, ReflectionCollector.collectStaticGettersResults(Environment.class));
-            }
-
-            // System settings
-            if (crashReportFields.contains(SETTINGS_SYSTEM)) {
-                crashReportData.put(SETTINGS_SYSTEM, SettingsCollector.collectSystemSettings(context));
-            }
-
-            // Secure settings
-            if (crashReportFields.contains(SETTINGS_SECURE)) {
-                crashReportData.put(SETTINGS_SECURE, SettingsCollector.collectSecureSettings(context));
-            }
-
-            // Global settings
-            if (crashReportFields.contains(SETTINGS_GLOBAL)) {
-                crashReportData.put(SETTINGS_GLOBAL, SettingsCollector.collectGlobalSettings(context));
-            }
-
-            // SharedPreferences
-            if (crashReportFields.contains(SHARED_PREFERENCES)) {
-                crashReportData.put(SHARED_PREFERENCES, SharedPreferencesCollector.collect(context));
-            }
-
-            // Now get all the crash data that relies on the PackageManager
-            // (which may or may not be here).
-            final PackageManagerWrapper pm = new PackageManagerWrapper(context);
-
-            final PackageInfo pi = pm.getPackageInfo();
-            if (pi != null) {
-                // Application Version
-                if (crashReportFields.contains(APP_VERSION_CODE)) {
-                    crashReportData.put(APP_VERSION_CODE, Integer.toString(pi.versionCode));
-                }
-                if (crashReportFields.contains(APP_VERSION_NAME)) {
-                    crashReportData.put(APP_VERSION_NAME, pi.versionName != null ? pi.versionName : "not set");
-                }
-            } else {
-                // Could not retrieve package info...
-                crashReportData.put(APP_VERSION_NAME, "Package info unavailable");
-            }
-
-            // Retrieve UDID(IMEI) if permission is available
-            if (crashReportFields.contains(DEVICE_ID) && prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
-                && pm.hasPermission(Manifest.permission.READ_PHONE_STATE)) {
-                final String deviceId = ReportUtils.getDeviceId(context);
-                if (deviceId != null) {
-                    crashReportData.put(DEVICE_ID, deviceId);
-                }
-            }
-
-            // Collect DropBox and logcat
-            // Before JellyBean, this required the READ_LOGS permission
-            // Since JellyBean, READ_LOGS is not granted to third-party apps anymore for security reasons.
-            // Though, we can call logcat without any permission and still get traces related to our app.
-            final boolean hasReadLogsPermission = pm.hasPermission(Manifest.permission.READ_LOGS) || (Compatibility.getAPILevel() >= 16);
-            if (prefs.getBoolean(ACRA.PREF_ENABLE_SYSTEM_LOGS, true) && hasReadLogsPermission) {
-                ACRA.log.i(LOG_TAG, "READ_LOGS granted! ACRA can include LogCat and DropBox data.");
-                if (crashReportFields.contains(LOGCAT)) {
-                    crashReportData.put(LOGCAT, LogCatCollector.collectLogCat(null));
-                }
-                if (crashReportFields.contains(EVENTSLOG)) {
-                    crashReportData.put(EVENTSLOG, LogCatCollector.collectLogCat("events"));
-                }
-                if (crashReportFields.contains(RADIOLOG)) {
-                    crashReportData.put(RADIOLOG, LogCatCollector.collectLogCat("radio"));
-                }
-                if (crashReportFields.contains(DROPBOX)) {
-                    crashReportData.put(DROPBOX,
-                                        DropBoxCollector.read(context, ACRA.getConfig().additionalDropBoxTags()));
-                }
-            } else {
-                ACRA.log.i(LOG_TAG, "READ_LOGS not allowed. ACRA will not include LogCat and DropBox data.");
-            }
-
-            // Application specific log file
-            if (crashReportFields.contains(APPLICATION_LOG)) {
-                try {
-                    final String logFile = LogFileCollector.collectLogFile(context,
-                                                                           ACRA.getConfig().applicationLogFile(),
-                                                                           ACRA.getConfig().applicationLogFileLines());
-                    crashReportData.put(APPLICATION_LOG, logFile);
-                } catch (IOException e) {
-                    ACRA.log.e(LOG_TAG, "Error while reading application log file " + ACRA.getConfig().applicationLogFile(), e);
-                }
-            }
-
-            // Media Codecs list
-            if (crashReportFields.contains(MEDIA_CODEC_LIST)) {
-                crashReportData.put(MEDIA_CODEC_LIST, MediaCodecListCollector.collecMediaCodecList());
-            }
-
-            // Failing thread details
-            if (crashReportFields.contains(THREAD_DETAILS)) {
-                crashReportData.put(THREAD_DETAILS, ThreadCollector.collect(brokenThread));
-            }
-
-            // IP addresses
-            if (crashReportFields.contains(USER_IP)) {
-                crashReportData.put(USER_IP, ReportUtils.getLocalIpAddress());
-            }
-
-        } catch (RuntimeException e) {
-            ACRA.log.e(LOG_TAG, "Error while retrieving crash data", e);
-        }
-
-        return crashReportData;
-    }
-
-    /**
-     * Generates the string which is posted in the single custom data field in
-     * the GoogleDocs Form.
-     *
-     * @return A string with a 'key = value' pair on each line.
-     */
-    private String createCustomInfoString(Map<String, String> reportCustomData) {
-        Map<String, String> params = customParameters;
-
-        if (reportCustomData != null) {
-            params = new HashMap<String, String>(params);
-            params.putAll(reportCustomData);
-        }
-
-        final StringBuilder customInfo = new StringBuilder();
-        for (final String currentKey : params.keySet()) {
-            String currentVal = params.get(currentKey);
-            customInfo.append(currentKey);
-            customInfo.append(" = ");
-            // We need to escape new lines in values or they are transformed into new
-            // custom fields. => let's replace all '\n' with "\\n"
-            if(currentVal != null) {
-                currentVal = currentVal.replaceAll("\n", "\\\\n");
-            }
-            customInfo.append(currentVal);
-            customInfo.append("\n");
-        }
-        return customInfo.toString();
-    }
-
-    private String getStackTrace(String msg, Throwable th) {
-        final Writer result = new StringWriter();
-        final PrintWriter printWriter = new PrintWriter(result);
-
-        if (msg != null && !msg.isEmpty())
-            printWriter.println(msg);
-
-        // If the exception was thrown in a background thread inside
-        // AsyncTask, then the actual exception can be found with getCause
-        Throwable cause = th;
-        while (cause != null) {
-            cause.printStackTrace(printWriter);
-            cause = cause.getCause();
-        }
-        final String stacktraceAsString = result.toString();
-        printWriter.close();
-
-        return stacktraceAsString;
-    }
-
-    private String getStackTraceHash(Throwable th) {
-        final StringBuilder res = new StringBuilder();
-        Throwable cause = th;
-        while (cause != null) {
-            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
-            for (final StackTraceElement e : stackTraceElements) {
-                res.append(e.getClassName());
-                res.append(e.getMethodName());
-            }
-            cause = cause.getCause();
-        }
-
-        return Integer.toHexString(res.toString().hashCode());
-    }
-
-    private Class<?> getBuildConfigClass() throws ClassNotFoundException {
-        final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
-        if ((configuredBuildConfig != null) && !configuredBuildConfig.equals(Object.class)) {
-            // If set via annotations or programatically then it will have a real value,
-            // otherwise it will be Object.class (annotation default) or null (explicit programmatic).
-            return configuredBuildConfig;
-        }
-
-        final String className = context.getClass().getPackage().getName() + ".BuildConfig";
-        try {
-            return Class.forName(className);
-        } catch (ClassNotFoundException e) {
-            ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
-            throw e;
-        }
-    }
+	private final Context context;
+	private final SharedPreferences prefs;
+	private final Map<String, String> customParameters = new LinkedHashMap<String, String>();
+	private final Time appStartDate;
+	private final String initialConfiguration;
+
+	public CrashReportDataFactory(Context context, SharedPreferences prefs,
+			Time appStartDate, String initialConfiguration) {
+		this.context = context;
+		this.prefs = prefs;
+		this.appStartDate = appStartDate;
+		this.initialConfiguration = initialConfiguration;
+	}
+
+	/**
+	 * <p>
+	 * Adds a custom key and value to be reported with the generated
+	 * CashReportData.
+	 * </p>
+	 * <p>
+	 * The key/value pairs will be stored in the "custom" column, as a text
+	 * containing one 'key = value' pair on each line.
+	 * </p>
+	 *
+	 * @param key
+	 *            A key for your custom data.
+	 * @param value
+	 *            The value associated to your key.
+	 * @return The previous value for this key if there was one, or null.
+	 */
+	public String putCustomData(String key, String value) {
+		return customParameters.put(key, value);
+	}
+
+	/**
+	 * Removes a key/value pair from the custom data field.
+	 *
+	 * @param key
+	 *            The key of the data to be removed.
+	 * @return The value for this key before removal.
+	 */
+	public String removeCustomData(String key) {
+		return customParameters.remove(key);
+	}
+
+	/**
+	 * Removes all key/value pairs from the custom data field.
+	 */
+	public void clearCustomData() {
+		customParameters.clear();
+	}
+
+	/**
+	 * Gets the current value for a key in the custom data field.
+	 *
+	 * @param key
+	 *            The key of the data to be retrieved.
+	 * @return The value for this key.
+	 */
+	public String getCustomData(String key) {
+		return customParameters.get(key);
+	}
+
+	/**
+	 * Collects crash data.
+	 *
+	 * @param msg
+	 *            A message to be associated with the crash report.
+	 * @param th
+	 *            Throwable that caused the crash.
+	 * @param customData
+	 *            Custom key/value pairs to be associated with the crash report.
+	 * @param isSilentReport
+	 *            Whether to report this report as being sent silently.
+	 * @param brokenThread
+	 *            Thread on which the error occurred.
+	 * @return CrashReportData representing the current state of the application
+	 *         at the instant of the Exception.
+	 */
+	public CrashReportData createCrashData(String msg, Throwable th,
+			Map<String, String> customData, boolean isSilentReport,
+			Thread brokenThread) {
+		final CrashReportData crashReportData = new CrashReportData();
+		try {
+			final List<ReportField> crashReportFields = ACRA.getConfig()
+					.getReportFields();
+
+			// Make every entry here bullet proof and move any slightly dodgy
+			// ones to the end.
+			// This ensures that we collect as much info as possible before
+			// something crashes the collection process.
+
+			crashReportData.put(STACK_TRACE, getStackTrace(msg, th));
+			crashReportData.put(ReportField.USER_APP_START_DATE,
+					ReportUtils.getTimeString(appStartDate));
+
+			if (isSilentReport) {
+				crashReportData.put(IS_SILENT, "true");
+			}
+
+			// StackTrace hash
+			if (crashReportFields.contains(STACK_TRACE_HASH)) {
+				crashReportData.put(ReportField.STACK_TRACE_HASH,
+						getStackTraceHash(th));
+			}
+
+			// Generate report uuid
+			if (crashReportFields.contains(REPORT_ID)) {
+				crashReportData.put(ReportField.REPORT_ID, UUID.randomUUID()
+						.toString());
+			}
+
+			// Installation unique ID
+			if (crashReportFields.contains(INSTALLATION_ID)) {
+				crashReportData.put(INSTALLATION_ID, Installation.id(context));
+			}
+
+			// Device Configuration when crashing
+			if (crashReportFields.contains(INITIAL_CONFIGURATION)) {
+				crashReportData
+						.put(INITIAL_CONFIGURATION, initialConfiguration);
+			}
+			if (crashReportFields.contains(CRASH_CONFIGURATION)) {
+				crashReportData.put(CRASH_CONFIGURATION,
+						ConfigurationCollector.collectConfiguration(context));
+			}
+
+			// Collect meminfo
+			if (!(th instanceof OutOfMemoryError)
+					&& crashReportFields.contains(DUMPSYS_MEMINFO)) {
+				crashReportData.put(DUMPSYS_MEMINFO,
+						DumpSysCollector.collectMemInfo());
+			}
+
+			// Application Package name
+			if (crashReportFields.contains(PACKAGE_NAME)) {
+				crashReportData.put(PACKAGE_NAME, context.getPackageName());
+			}
+
+			// Android OS Build details
+			if (crashReportFields.contains(BUILD)) {
+				crashReportData.put(
+						BUILD,
+						ReflectionCollector
+								.collectConstants(android.os.Build.class)
+								+ ReflectionCollector.collectConstants(
+										android.os.Build.VERSION.class,
+										"VERSION"));
+			}
+
+			// Device model
+			if (crashReportFields.contains(PHONE_MODEL)) {
+				crashReportData.put(PHONE_MODEL, android.os.Build.MODEL);
+			}
+			// Android version
+			if (crashReportFields.contains(ANDROID_VERSION)) {
+				crashReportData.put(ANDROID_VERSION,
+						android.os.Build.VERSION.RELEASE);
+			}
+
+			// Device Brand (manufacturer)
+			if (crashReportFields.contains(BRAND)) {
+				crashReportData.put(BRAND, android.os.Build.BRAND);
+			}
+			if (crashReportFields.contains(PRODUCT)) {
+				crashReportData.put(PRODUCT, android.os.Build.PRODUCT);
+			}
+
+			// Device Memory
+			if (crashReportFields.contains(TOTAL_MEM_SIZE)) {
+				crashReportData
+						.put(TOTAL_MEM_SIZE, Long.toString(ReportUtils
+								.getTotalInternalMemorySize()));
+			}
+			if (crashReportFields.contains(AVAILABLE_MEM_SIZE)) {
+				crashReportData
+						.put(AVAILABLE_MEM_SIZE, Long.toString(ReportUtils
+								.getAvailableInternalMemorySize()));
+			}
+
+			// Application file path
+			if (crashReportFields.contains(FILE_PATH)) {
+				crashReportData.put(FILE_PATH,
+						ReportUtils.getApplicationFilePath(context));
+			}
+
+			// Main display details
+			if (crashReportFields.contains(DISPLAY)) {
+				crashReportData.put(DISPLAY,
+						DisplayManagerCollector.collectDisplays(context));
+			}
+
+			// User crash date with local timezone
+			if (crashReportFields.contains(USER_CRASH_DATE)) {
+				final Time curDate = new Time();
+				curDate.setToNow();
+				crashReportData.put(USER_CRASH_DATE,
+						ReportUtils.getTimeString(curDate));
+			}
+
+			// Add custom info, they are all stored in a single field
+			if (crashReportFields.contains(CUSTOM_DATA)) {
+				crashReportData.put(CUSTOM_DATA,
+						createCustomInfoString(customData));
+			}
+
+			if (crashReportFields.contains(BUILD_CONFIG)) {
+				try {
+					final Class buildConfigClass = getBuildConfigClass();
+					crashReportData.put(BUILD_CONFIG, ReflectionCollector
+							.collectConstants(buildConfigClass));
+				} catch (ClassNotFoundException e) {
+					// We have already logged this when we had the name of the
+					// class that wasn't found.
+				}
+			}
+
+			// Add user email address, if set in the app's preferences
+			if (crashReportFields.contains(USER_EMAIL)) {
+				crashReportData.put(USER_EMAIL,
+						prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "N/A"));
+			}
+
+			// Device features
+			if (crashReportFields.contains(DEVICE_FEATURES)) {
+				crashReportData.put(DEVICE_FEATURES,
+						DeviceFeaturesCollector.getFeatures(context));
+			}
+
+			// Environment (External storage state)
+			if (crashReportFields.contains(ENVIRONMENT)) {
+				crashReportData.put(ENVIRONMENT, ReflectionCollector
+						.collectStaticGettersResults(Environment.class));
+			}
+
+			// System settings
+			if (crashReportFields.contains(SETTINGS_SYSTEM)) {
+				crashReportData.put(SETTINGS_SYSTEM,
+						SettingsCollector.collectSystemSettings(context));
+			}
+
+			// Secure settings
+			if (crashReportFields.contains(SETTINGS_SECURE)) {
+				crashReportData.put(SETTINGS_SECURE,
+						SettingsCollector.collectSecureSettings(context));
+			}
+
+			// Global settings
+			if (crashReportFields.contains(SETTINGS_GLOBAL)) {
+				crashReportData.put(SETTINGS_GLOBAL,
+						SettingsCollector.collectGlobalSettings(context));
+			}
+
+			// SharedPreferences
+			if (crashReportFields.contains(SHARED_PREFERENCES)) {
+				crashReportData.put(SHARED_PREFERENCES,
+						SharedPreferencesCollector.collect(context));
+			}
+
+			// Now get all the crash data that relies on the PackageManager
+			// (which may or may not be here).
+			final PackageManagerWrapper pm = new PackageManagerWrapper(context);
+
+			final PackageInfo pi = pm.getPackageInfo();
+			if (pi != null) {
+				// Application Version
+				if (crashReportFields.contains(APP_VERSION_CODE)) {
+					crashReportData.put(APP_VERSION_CODE,
+							Integer.toString(pi.versionCode));
+				}
+				if (crashReportFields.contains(APP_VERSION_NAME)) {
+					crashReportData
+							.put(APP_VERSION_NAME,
+									pi.versionName != null ? pi.versionName
+											: "not set");
+				}
+			} else {
+				// Could not retrieve package info...
+				crashReportData.put(APP_VERSION_NAME,
+						"Package info unavailable");
+			}
+
+			// Retrieve UDID(IMEI) if permission is available
+			if (crashReportFields.contains(DEVICE_ID)
+					&& prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
+					&& pm.hasPermission(Manifest.permission.READ_PHONE_STATE)) {
+				final String deviceId = ReportUtils.getDeviceId(context);
+				if (deviceId != null) {
+					crashReportData.put(DEVICE_ID, deviceId);
+				}
+			}
+
+			// Collect DropBox and logcat
+			// Before JellyBean, this required the READ_LOGS permission
+			// Since JellyBean, READ_LOGS is not granted to third-party apps
+			// anymore for security reasons.
+			// Though, we can call logcat without any permission and still get
+			// traces related to our app.
+			final boolean hasReadLogsPermission = pm
+					.hasPermission(Manifest.permission.READ_LOGS)
+					|| (Compatibility.getAPILevel() >= 16);
+			if (prefs.getBoolean(ACRA.PREF_ENABLE_SYSTEM_LOGS, true)
+					&& hasReadLogsPermission) {
+				ACRA.log.i(LOG_TAG,
+						"READ_LOGS granted! ACRA can include LogCat and DropBox data.");
+				if (crashReportFields.contains(LOGCAT)) {
+					crashReportData.put(LOGCAT,
+							LogCatCollector.collectLogCat(null));
+				}
+				if (crashReportFields.contains(EVENTSLOG)) {
+					crashReportData.put(EVENTSLOG,
+							LogCatCollector.collectLogCat("events"));
+				}
+				if (crashReportFields.contains(RADIOLOG)) {
+					crashReportData.put(RADIOLOG,
+							LogCatCollector.collectLogCat("radio"));
+				}
+				if (crashReportFields.contains(DROPBOX)) {
+					crashReportData.put(DROPBOX, DropBoxCollector.read(context,
+							ACRA.getConfig().additionalDropBoxTags()));
+				}
+			} else {
+				ACRA.log.i(LOG_TAG,
+						"READ_LOGS not allowed. ACRA will not include LogCat and DropBox data.");
+			}
+
+			// Application specific log file
+			if (crashReportFields.contains(APPLICATION_LOG)) {
+				try {
+					final String logFile = LogFileCollector.collectLogFile(
+							context, ACRA.getConfig().applicationLogFile(),
+							ACRA.getConfig().applicationLogFileLines());
+					crashReportData.put(APPLICATION_LOG, logFile);
+				} catch (IOException e) {
+					ACRA.log.e(LOG_TAG,
+							"Error while reading application log file "
+									+ ACRA.getConfig().applicationLogFile(), e);
+				}
+			}
+
+			// Media Codecs list
+			if (crashReportFields.contains(MEDIA_CODEC_LIST)) {
+				crashReportData.put(MEDIA_CODEC_LIST,
+						MediaCodecListCollector.collecMediaCodecList());
+			}
+
+			// Failing thread details
+			if (crashReportFields.contains(THREAD_DETAILS)) {
+				crashReportData.put(THREAD_DETAILS,
+						ThreadCollector.collect(brokenThread));
+			}
+
+			// IP addresses
+			if (crashReportFields.contains(USER_IP)) {
+				crashReportData.put(USER_IP, ReportUtils.getLocalIpAddress());
+			}
+
+		} catch (RuntimeException e) {
+			ACRA.log.e(LOG_TAG, "Error while retrieving crash data", e);
+		}
+
+		return crashReportData;
+	}
+
+	/**
+	 * Generates the string which is posted in the single custom data field in
+	 * the GoogleDocs Form.
+	 *
+	 * @return A string with a 'key = value' pair on each line.
+	 */
+	private String createCustomInfoString(Map<String, String> reportCustomData) {
+		Map<String, String> params = customParameters;
+
+		if (reportCustomData != null) {
+			params = new HashMap<String, String>(params);
+			params.putAll(reportCustomData);
+		}
+
+		final StringBuilder customInfo = new StringBuilder();
+		for (final String currentKey : params.keySet()) {
+			String currentVal = params.get(currentKey);
+			customInfo.append(currentKey);
+			customInfo.append(" = ");
+			// We need to escape new lines in values or they are transformed
+			// into new
+			// custom fields. => let's replace all '\n' with "\\n"
+			if (currentVal != null) {
+				currentVal = currentVal.replaceAll("\n", "\\\\n");
+			}
+			customInfo.append(currentVal);
+			customInfo.append("\n");
+		}
+		return customInfo.toString();
+	}
+
+	private String getStackTrace(String msg, Throwable th) {
+		final Writer result = new StringWriter();
+		final PrintWriter printWriter = new PrintWriter(result);
+
+		if (msg != null && !msg.isEmpty())
+			printWriter.println(msg);
+
+		// If the exception was thrown in a background thread inside
+		// AsyncTask, then the actual exception can be found with getCause
+		Throwable cause = th;
+		while (cause != null) {
+			cause.printStackTrace(printWriter);
+			cause = cause.getCause();
+		}
+		final String stacktraceAsString = result.toString();
+		printWriter.close();
+
+		return stacktraceAsString;
+	}
+
+	private String getStackTraceHash(Throwable th) {
+		final StringBuilder res = new StringBuilder();
+		Throwable cause = th;
+		while (cause != null) {
+			final StackTraceElement[] stackTraceElements = cause
+					.getStackTrace();
+			for (final StackTraceElement e : stackTraceElements) {
+				res.append(e.getClassName());
+				res.append(e.getMethodName());
+			}
+			cause = cause.getCause();
+		}
+
+		return Integer.toHexString(res.toString().hashCode());
+	}
+
+	private Class<?> getBuildConfigClass() throws ClassNotFoundException {
+		final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
+		if ((configuredBuildConfig != null)
+				&& !configuredBuildConfig.equals(Object.class)) {
+			// If set via annotations or programatically then it will have a
+			// real value,
+			// otherwise it will be Object.class (annotation default) or null
+			// (explicit programmatic).
+			return configuredBuildConfig;
+		}
+
+		final String className = context.getClass().getPackage().getName()
+				+ ".BuildConfig";
+		try {
+			return Class.forName(className);
+		} catch (ClassNotFoundException e) {
+			ACRA.log.e(
+					LOG_TAG,
+					"Not adding buildConfig to log. Class Not found : "
+							+ className
+							+ ". Please configure 'buildConfigClass' in your ACRA config");
+			throw e;
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java b/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
index 821e92fd..774b97e4 100644
--- a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
+++ b/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
@@ -19,48 +19,57 @@
 
 import java.lang.reflect.Method;
 
+import org.acra.ACRA;
+
 import android.content.Context;
 import android.content.pm.PackageManager;
 
-import org.acra.ACRA;
-
 /**
- * Features declared as available on the device. Available only with API level > 5.
+ * Features declared as available on the device. Available only with API level >
+ * 5.
  * 
  * @author Kevin Gaudin
  * 
  */
 final class DeviceFeaturesCollector {
 
-    public static String getFeatures(Context ctx) {
+	public static String getFeatures(Context ctx) {
 
-        if (Compatibility.getAPILevel() < 5) {
-            return "Data available only with API Level >= 5";
-        }
+		if (Compatibility.getAPILevel() < 5) {
+			return "Data available only with API Level >= 5";
+		}
 
-        final StringBuilder result = new StringBuilder();
-        try {
-            final PackageManager pm = ctx.getPackageManager();
-            final Method getSystemAvailableFeatures = PackageManager.class.getMethod("getSystemAvailableFeatures", (Class[]) null);
-            final Object[] features = (Object[]) getSystemAvailableFeatures.invoke(pm);
-            for (final Object feature : features) {
-                final String featureName = (String) feature.getClass().getField("name").get(feature);
-                if(featureName != null) {
-                    result.append(featureName);
-                } else {
-                    final Method getGlEsVersion = feature.getClass().getMethod("getGlEsVersion", (Class[]) null);
-                    final String glEsVersion = (String) getGlEsVersion.invoke(feature);
-                    result.append("glEsVersion = ");
-                    result.append(glEsVersion);
-                }
-                result.append("\n");
-            }
-        } catch (Throwable e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceFeatures for " + ctx.getPackageName(), e);
-            result.append("Could not retrieve data: ");
-            result.append(e.getMessage());
-        }
+		final StringBuilder result = new StringBuilder();
+		try {
+			final PackageManager pm = ctx.getPackageManager();
+			final Method getSystemAvailableFeatures = PackageManager.class
+					.getMethod("getSystemAvailableFeatures", (Class[]) null);
+			final Object[] features = (Object[]) getSystemAvailableFeatures
+					.invoke(pm);
+			for (final Object feature : features) {
+				final String featureName = (String) feature.getClass()
+						.getField("name").get(feature);
+				if (featureName != null) {
+					result.append(featureName);
+				} else {
+					final Method getGlEsVersion = feature.getClass().getMethod(
+							"getGlEsVersion", (Class[]) null);
+					final String glEsVersion = (String) getGlEsVersion
+							.invoke(feature);
+					result.append("glEsVersion = ");
+					result.append(glEsVersion);
+				}
+				result.append("\n");
+			}
+		} catch (Throwable e) {
+			ACRA.log.w(
+					LOG_TAG,
+					"Couldn't retrieve DeviceFeatures for "
+							+ ctx.getPackageName(), e);
+			result.append("Could not retrieve data: ");
+			result.append(e.getMessage());
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 }
diff --git a/src/main/java/org/acra/collector/DisplayManagerCollector.java b/src/main/java/org/acra/collector/DisplayManagerCollector.java
index d0dc39db..3cc61623 100644
--- a/src/main/java/org/acra/collector/DisplayManagerCollector.java
+++ b/src/main/java/org/acra/collector/DisplayManagerCollector.java
@@ -1,5 +1,7 @@
 package org.acra.collector;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -15,285 +17,316 @@
 import android.view.Surface;
 import android.view.WindowManager;
 
-import static org.acra.ACRA.LOG_TAG;
-
 final class DisplayManagerCollector {
 
-    final static SparseArray<String> mFlagsNames = new SparseArray<String>();
-    final static SparseArray<String> mDensities = new SparseArray<String>();
+	final static SparseArray<String> mFlagsNames = new SparseArray<String>();
+	final static SparseArray<String> mDensities = new SparseArray<String>();
 
-    public static String collectDisplays(Context ctx) {
-        Display[] displays = null;
-        final StringBuilder result = new StringBuilder();
+	public static String collectDisplays(Context ctx) {
+		Display[] displays = null;
+		final StringBuilder result = new StringBuilder();
 
-        if (Compatibility.getAPILevel() < 17) {
-            // Before Android 4.2, there was a single display available from the
-            // window manager
-            final WindowManager windowManager = (WindowManager) ctx
-                    .getSystemService(android.content.Context.WINDOW_SERVICE);
-            displays = new Display[1];
-            displays[0] = windowManager.getDefaultDisplay();
-        } else {
-            // Since Android 4.2, we can fetch multiple displays with the
-            // DisplayManager.
-            try {
-                Object displayManager = ctx.getSystemService((String) (ctx.getClass().getField("DISPLAY_SERVICE")
-                        .get(null)));
-                Method getDisplays = displayManager.getClass().getMethod("getDisplays");
-                displays = (Display[]) getDisplays.invoke(displayManager);
-            } catch (IllegalArgumentException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (SecurityException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (IllegalAccessException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchFieldException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchMethodException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (InvocationTargetException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            }
-        }
+		if (Compatibility.getAPILevel() < 17) {
+			// Before Android 4.2, there was a single display available from the
+			// window manager
+			final WindowManager windowManager = (WindowManager) ctx
+					.getSystemService(android.content.Context.WINDOW_SERVICE);
+			displays = new Display[1];
+			displays[0] = windowManager.getDefaultDisplay();
+		} else {
+			// Since Android 4.2, we can fetch multiple displays with the
+			// DisplayManager.
+			try {
+				Object displayManager = ctx.getSystemService((String) (ctx
+						.getClass().getField("DISPLAY_SERVICE").get(null)));
+				Method getDisplays = displayManager.getClass().getMethod(
+						"getDisplays");
+				displays = (Display[]) getDisplays.invoke(displayManager);
+			} catch (IllegalArgumentException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			} catch (SecurityException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			} catch (IllegalAccessException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			} catch (NoSuchFieldException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			} catch (NoSuchMethodException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			} catch (InvocationTargetException e) {
+				ACRA.log.w(LOG_TAG,
+						"Error while collecting DisplayManager data: ", e);
+			}
+		}
 
-        for (Display display : displays) {
-            result.append(collectDisplayData(display));
-        }
+		for (Display display : displays) {
+			result.append(collectDisplayData(display));
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    private static Object collectDisplayData(Display display) {
-        final DisplayMetrics metrics = new DisplayMetrics();
-        display.getMetrics(metrics);
+	private static Object collectDisplayData(Display display) {
+		final DisplayMetrics metrics = new DisplayMetrics();
+		display.getMetrics(metrics);
 
-        final StringBuilder result = new StringBuilder();
+		final StringBuilder result = new StringBuilder();
 
-        result.append(collectCurrentSizeRange(display));
-        result.append(collectFlags(display));
-        result.append(display.getDisplayId()).append(".height=").append(display.getHeight()).append('\n');
-        result.append(collectMetrics(display, "getMetrics"));
-        result.append(collectName(display));
-        result.append(display.getDisplayId()).append(".orientation=").append(display.getOrientation()).append('\n');
-        result.append(display.getDisplayId()).append(".pixelFormat=").append(display.getPixelFormat()).append('\n');
-        result.append(collectMetrics(display, "getRealMetrics"));
-        result.append(collectSize(display, "getRealSize"));
-        result.append(collectRectSize(display));
-        result.append(display.getDisplayId()).append(".refreshRate=").append(display.getRefreshRate()).append('\n');
-        result.append(collectRotation(display));
-        result.append(collectSize(display, "getSize"));
-        result.append(display.getDisplayId()).append(".width=").append(display.getWidth()).append('\n');
-        result.append(collectIsValid(display));
+		result.append(collectCurrentSizeRange(display));
+		result.append(collectFlags(display));
+		result.append(display.getDisplayId()).append(".height=")
+				.append(display.getHeight()).append('\n');
+		result.append(collectMetrics(display, "getMetrics"));
+		result.append(collectName(display));
+		result.append(display.getDisplayId()).append(".orientation=")
+				.append(display.getOrientation()).append('\n');
+		result.append(display.getDisplayId()).append(".pixelFormat=")
+				.append(display.getPixelFormat()).append('\n');
+		result.append(collectMetrics(display, "getRealMetrics"));
+		result.append(collectSize(display, "getRealSize"));
+		result.append(collectRectSize(display));
+		result.append(display.getDisplayId()).append(".refreshRate=")
+				.append(display.getRefreshRate()).append('\n');
+		result.append(collectRotation(display));
+		result.append(collectSize(display, "getSize"));
+		result.append(display.getDisplayId()).append(".width=")
+				.append(display.getWidth()).append('\n');
+		result.append(collectIsValid(display));
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    private static Object collectIsValid(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method isValid = display.getClass().getMethod("isValid");
-            Boolean value = (Boolean) isValid.invoke(display);
-            result.append(display.getDisplayId()).append(".isValid=").append(value).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+	private static Object collectIsValid(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method isValid = display.getClass().getMethod("isValid");
+			Boolean value = (Boolean) isValid.invoke(display);
+			result.append(display.getDisplayId()).append(".isValid=")
+					.append(value).append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static Object collectRotation(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRotation = display.getClass().getMethod("getRotation");
-            int rotation = (Integer) getRotation.invoke(display);
-            result.append(display.getDisplayId()).append(".rotation=");
-            switch (rotation) {
-            case Surface.ROTATION_0:
-                result.append("ROTATION_0");
-                break;
-            case Surface.ROTATION_90:
-                result.append("ROTATION_90");
-                break;
-            case Surface.ROTATION_180:
-                result.append("ROTATION_180");
-                break;
-            case Surface.ROTATION_270:
-                result.append("ROTATION_270");
-                break;
-            default:
-                result.append(rotation);
-                break;
-            }
-            result.append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+	private static Object collectRotation(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getRotation = display.getClass().getMethod("getRotation");
+			int rotation = (Integer) getRotation.invoke(display);
+			result.append(display.getDisplayId()).append(".rotation=");
+			switch (rotation) {
+			case Surface.ROTATION_0:
+				result.append("ROTATION_0");
+				break;
+			case Surface.ROTATION_90:
+				result.append("ROTATION_90");
+				break;
+			case Surface.ROTATION_180:
+				result.append("ROTATION_180");
+				break;
+			case Surface.ROTATION_270:
+				result.append("ROTATION_270");
+				break;
+			default:
+				result.append(rotation);
+				break;
+			}
+			result.append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static Object collectRectSize(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRectSize = display.getClass().getMethod("getRectSize", Rect.class);
-            Rect size = new Rect();
-            getRectSize.invoke(display, size);
-            result.append(display.getDisplayId()).append(".rectSize=[").append(size.top).append(',').append(size.left)
-                    .append(',').append(size.width()).append(',').append(size.height()).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+	private static Object collectRectSize(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getRectSize = display.getClass().getMethod("getRectSize",
+					Rect.class);
+			Rect size = new Rect();
+			getRectSize.invoke(display, size);
+			result.append(display.getDisplayId()).append(".rectSize=[")
+					.append(size.top).append(',').append(size.left).append(',')
+					.append(size.width()).append(',').append(size.height())
+					.append(']').append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static Object collectSize(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRealSize = display.getClass().getMethod(methodName, Point.class);
-            Point size = new Point();
-            getRealSize.invoke(display, size);
-            result.append(display.getDisplayId()).append('.').append(methodName).append("=[").append(size.x)
-                    .append(',').append(size.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+	private static Object collectSize(Display display, String methodName) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getRealSize = display.getClass().getMethod(methodName,
+					Point.class);
+			Point size = new Point();
+			getRealSize.invoke(display, size);
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append("=[").append(size.x).append(',')
+					.append(size.y).append(']').append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static String collectCurrentSizeRange(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getCurrentSizeRange = display.getClass().getMethod("getCurrentSizeRange", Point.class, Point.class);
-            Point smallest = new Point(), largest = new Point();
-            getCurrentSizeRange.invoke(display, smallest, largest);
-            result.append(display.getDisplayId()).append(".currentSizeRange.smallest=[").append(smallest.x).append(',')
-                    .append(smallest.y).append(']').append('\n');
-            result.append(display.getDisplayId()).append(".currentSizeRange.largest=[").append(largest.x).append(',')
-                    .append(largest.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+	private static String collectCurrentSizeRange(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getCurrentSizeRange = display.getClass().getMethod(
+					"getCurrentSizeRange", Point.class, Point.class);
+			Point smallest = new Point(), largest = new Point();
+			getCurrentSizeRange.invoke(display, smallest, largest);
+			result.append(display.getDisplayId())
+					.append(".currentSizeRange.smallest=[").append(smallest.x)
+					.append(',').append(smallest.y).append(']').append('\n');
+			result.append(display.getDisplayId())
+					.append(".currentSizeRange.largest=[").append(largest.x)
+					.append(',').append(largest.y).append(']').append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static String collectFlags(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getFlags = display.getClass().getMethod("getFlags");
-            int flags = (Integer) getFlags.invoke(display);
+	private static String collectFlags(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getFlags = display.getClass().getMethod("getFlags");
+			int flags = (Integer) getFlags.invoke(display);
 
-            for (Field field : display.getClass().getFields()) {
-                if (field.getName().startsWith("FLAG_")) {
-                    mFlagsNames.put(field.getInt(null), field.getName());
-                }
-            }
+			for (Field field : display.getClass().getFields()) {
+				if (field.getName().startsWith("FLAG_")) {
+					mFlagsNames.put(field.getInt(null), field.getName());
+				}
+			}
 
-            result.append(display.getDisplayId()).append(".flags=").append(activeFlags(mFlagsNames, flags))
-                    .append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+			result.append(display.getDisplayId()).append(".flags=")
+					.append(activeFlags(mFlagsNames, flags)).append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static String collectName(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getName = display.getClass().getMethod("getName");
-            String name = (String) getName.invoke(display);
+	private static String collectName(Display display) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getName = display.getClass().getMethod("getName");
+			String name = (String) getName.invoke(display);
 
-            result.append(display.getDisplayId()).append(".name=").append(name).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
+			result.append(display.getDisplayId()).append(".name=").append(name)
+					.append('\n');
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		}
+		return result.toString();
+	}
 
-    private static Object collectMetrics(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getMetrics = display.getClass().getMethod(methodName);
-            DisplayMetrics metrics = (DisplayMetrics) getMetrics.invoke(display);
+	private static Object collectMetrics(Display display, String methodName) {
+		StringBuilder result = new StringBuilder();
+		try {
+			Method getMetrics = display.getClass().getMethod(methodName);
+			DisplayMetrics metrics = (DisplayMetrics) getMetrics
+					.invoke(display);
 
-            for (Field field : DisplayMetrics.class.getFields()) {
-                if (field.getType().equals(Integer.class) && field.getName().startsWith("DENSITY_")
-                        && !field.getName().equals("DENSITY_DEFAULT")) {
-                    mDensities.put(field.getInt(null), field.getName());
-                }
-            }
+			for (Field field : DisplayMetrics.class.getFields()) {
+				if (field.getType().equals(Integer.class)
+						&& field.getName().startsWith("DENSITY_")
+						&& !field.getName().equals("DENSITY_DEFAULT")) {
+					mDensities.put(field.getInt(null), field.getName());
+				}
+			}
 
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".density=")
-                    .append(metrics.density).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".densityDpi=")
-                    .append(metrics.getClass().getField("densityDpi")).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append("scaledDensity=x")
-                    .append(metrics.scaledDensity).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".widthPixels=")
-                    .append(metrics.widthPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".heightPixels=")
-                    .append(metrics.heightPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".xdpi=").append(metrics.xdpi)
-                    .append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".ydpi=").append(metrics.ydpi)
-                    .append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".density=")
+					.append(metrics.density).append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".densityDpi=")
+					.append(metrics.getClass().getField("densityDpi"))
+					.append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append("scaledDensity=x")
+					.append(metrics.scaledDensity).append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".widthPixels=")
+					.append(metrics.widthPixels).append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".heightPixels=")
+					.append(metrics.heightPixels).append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".xdpi=").append(metrics.xdpi)
+					.append('\n');
+			result.append(display.getDisplayId()).append('.')
+					.append(methodName).append(".ydpi=").append(metrics.ydpi)
+					.append('\n');
 
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        } catch (NoSuchFieldException e) {
-        }
-        return result.toString();
-    }
+		} catch (SecurityException e) {
+		} catch (NoSuchMethodException e) {
+		} catch (IllegalArgumentException e) {
+		} catch (IllegalAccessException e) {
+		} catch (InvocationTargetException e) {
+		} catch (NoSuchFieldException e) {
+		}
+		return result.toString();
+	}
 
-    /**
-     * Some fields contain multiple value types which can be isolated by
-     * applying a bitmask. That method returns the concatenation of active
-     * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
-     * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
-     */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
-        final StringBuilder result = new StringBuilder();
+	/**
+	 * Some fields contain multiple value types which can be isolated by
+	 * applying a bitmask. That method returns the concatenation of active
+	 * values.
+	 * 
+	 * @param valueNames
+	 *            The array containing the different values and names for this
+	 *            field. Must contain mask values too.
+	 * @param bitfield
+	 *            The bitfield to inspect.
+	 * @return The names of the different values contained in the bitfield,
+	 *         separated by '+'.
+	 */
+	private static String activeFlags(SparseArray<String> valueNames,
+			int bitfield) {
+		final StringBuilder result = new StringBuilder();
 
-        // Look for masks, apply it an retrieve the masked value
-        for (int i = 0; i < valueNames.size(); i++) {
-            final int maskValue = valueNames.keyAt(i);
-            final int value = bitfield & maskValue;
-            if (value > 0) {
-                if (result.length() > 0) {
-                    result.append('+');
-                }
-                result.append(valueNames.get(value));
-            }
-        }
-        return result.toString();
-    }
+		// Look for masks, apply it an retrieve the masked value
+		for (int i = 0; i < valueNames.size(); i++) {
+			final int maskValue = valueNames.keyAt(i);
+			final int value = bitfield & maskValue;
+			if (value > 0) {
+				if (result.length() > 0) {
+					result.append('+');
+				}
+				result.append(valueNames.get(value));
+			}
+		}
+		return result.toString();
+	}
 
 }
diff --git a/src/main/java/org/acra/collector/DropBoxCollector.java b/src/main/java/org/acra/collector/DropBoxCollector.java
index a2673d12..656206d2 100644
--- a/src/main/java/org/acra/collector/DropBoxCollector.java
+++ b/src/main/java/org/acra/collector/DropBoxCollector.java
@@ -15,6 +15,8 @@
  */
 package org.acra.collector;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -26,8 +28,6 @@
 import android.content.Context;
 import android.text.format.Time;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * Collects data from the DropBoxManager introduced with Android API Level 8. A
  * set of DropBox tags have been identified in the Android source code. , we
@@ -40,97 +40,106 @@
  */
 final class DropBoxCollector {
 
-    private static final String[] SYSTEM_TAGS = { "system_app_anr", "system_app_wtf", "system_app_crash",
-            "system_server_anr", "system_server_wtf", "system_server_crash", "BATTERY_DISCHARGE_INFO",
-            "SYSTEM_RECOVERY_LOG", "SYSTEM_BOOT", "SYSTEM_LAST_KMSG", "APANIC_CONSOLE", "APANIC_THREADS",
-            "SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode" };
-
-    private static final String NO_RESULT = "N/A";
-
-    /**
-     * Read latest messages contained in the DropBox for system related tags and
-     * optional developer-set tags.
-     * 
-     * @param context
-     *            The application context.
-     * @param additionalTags
-     *            An array of tags provided by the application developer.
-     * @return A readable formatted String listing messages retrieved.
-     */
-    public static String read(Context context, String[] additionalTags) {
-        try {
-            // Use reflection API to allow compilation with API Level 5.
-            final String serviceName = Compatibility.getDropBoxServiceName();
-            if (serviceName == null) {
-                return NO_RESULT;
-            }
-
-            final Object dropbox = context.getSystemService(serviceName);
-            final Method getNextEntry = dropbox.getClass().getMethod("getNextEntry", String.class, long.class);
-            if (getNextEntry == null) {
-                return "";
-            }
-
-            final Time timer = new Time();
-            timer.setToNow();
-            timer.minute -= ACRA.getConfig().dropboxCollectionMinutes();
-            timer.normalize(false);
-            final long time = timer.toMillis(false);
-
-            final List<String> tags = new ArrayList<String>();
-            if (ACRA.getConfig().includeDropBoxSystemTags()) {
-                tags.addAll(Arrays.asList(SYSTEM_TAGS));
-            }
-            if (additionalTags != null && additionalTags.length > 0) {
-                tags.addAll(Arrays.asList(additionalTags));
-            }
-
-            if (tags.isEmpty()) {
-                return "No tag configured for collection.";
-            }
-
-            final StringBuilder dropboxContent = new StringBuilder();
-            for (String tag : tags) {
-                dropboxContent.append("Tag: ").append(tag).append('\n');
-                Object entry = getNextEntry.invoke(dropbox, tag, time);
-                if (entry == null) {
-                    dropboxContent.append("Nothing.").append('\n');
-                    continue;
-                }
-
-                final Method getText = entry.getClass().getMethod("getText", int.class);
-                final Method getTimeMillis = entry.getClass().getMethod("getTimeMillis", (Class[]) null);
-                final Method close = entry.getClass().getMethod("close", (Class[]) null);
-                while (entry != null) {
-                    final long msec = (Long) getTimeMillis.invoke(entry, (Object[]) null);
-                    timer.set(msec);
-                    dropboxContent.append("@").append(timer.format2445()).append('\n');
-                    final String text = (String) getText.invoke(entry, 500);
-                    if (text != null) {
-                        dropboxContent.append("Text: ").append(text).append('\n');
-                    } else {
-                        dropboxContent.append("Not Text!").append('\n');
-                    }
-                    close.invoke(entry, (Object[]) null);
-                    entry = getNextEntry.invoke(dropbox, tag, msec);
-                }
-            }
-            return dropboxContent.toString();
-
-        } catch (SecurityException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchMethodException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalArgumentException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalAccessException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (InvocationTargetException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchFieldException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        }
-
-        return NO_RESULT;
-    }
+	private static final String[] SYSTEM_TAGS = { "system_app_anr",
+			"system_app_wtf", "system_app_crash", "system_server_anr",
+			"system_server_wtf", "system_server_crash",
+			"BATTERY_DISCHARGE_INFO", "SYSTEM_RECOVERY_LOG", "SYSTEM_BOOT",
+			"SYSTEM_LAST_KMSG", "APANIC_CONSOLE", "APANIC_THREADS",
+			"SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode" };
+
+	private static final String NO_RESULT = "N/A";
+
+	/**
+	 * Read latest messages contained in the DropBox for system related tags and
+	 * optional developer-set tags.
+	 * 
+	 * @param context
+	 *            The application context.
+	 * @param additionalTags
+	 *            An array of tags provided by the application developer.
+	 * @return A readable formatted String listing messages retrieved.
+	 */
+	public static String read(Context context, String[] additionalTags) {
+		try {
+			// Use reflection API to allow compilation with API Level 5.
+			final String serviceName = Compatibility.getDropBoxServiceName();
+			if (serviceName == null) {
+				return NO_RESULT;
+			}
+
+			final Object dropbox = context.getSystemService(serviceName);
+			final Method getNextEntry = dropbox.getClass().getMethod(
+					"getNextEntry", String.class, long.class);
+			if (getNextEntry == null) {
+				return "";
+			}
+
+			final Time timer = new Time();
+			timer.setToNow();
+			timer.minute -= ACRA.getConfig().dropboxCollectionMinutes();
+			timer.normalize(false);
+			final long time = timer.toMillis(false);
+
+			final List<String> tags = new ArrayList<String>();
+			if (ACRA.getConfig().includeDropBoxSystemTags()) {
+				tags.addAll(Arrays.asList(SYSTEM_TAGS));
+			}
+			if (additionalTags != null && additionalTags.length > 0) {
+				tags.addAll(Arrays.asList(additionalTags));
+			}
+
+			if (tags.isEmpty()) {
+				return "No tag configured for collection.";
+			}
+
+			final StringBuilder dropboxContent = new StringBuilder();
+			for (String tag : tags) {
+				dropboxContent.append("Tag: ").append(tag).append('\n');
+				Object entry = getNextEntry.invoke(dropbox, tag, time);
+				if (entry == null) {
+					dropboxContent.append("Nothing.").append('\n');
+					continue;
+				}
+
+				final Method getText = entry.getClass().getMethod("getText",
+						int.class);
+				final Method getTimeMillis = entry.getClass().getMethod(
+						"getTimeMillis", (Class[]) null);
+				final Method close = entry.getClass().getMethod("close",
+						(Class[]) null);
+				while (entry != null) {
+					final long msec = (Long) getTimeMillis.invoke(entry,
+							(Object[]) null);
+					timer.set(msec);
+					dropboxContent.append("@").append(timer.format2445())
+							.append('\n');
+					final String text = (String) getText.invoke(entry, 500);
+					if (text != null) {
+						dropboxContent.append("Text: ").append(text)
+								.append('\n');
+					} else {
+						dropboxContent.append("Not Text!").append('\n');
+					}
+					close.invoke(entry, (Object[]) null);
+					entry = getNextEntry.invoke(dropbox, tag, msec);
+				}
+			}
+			return dropboxContent.toString();
+
+		} catch (SecurityException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		} catch (NoSuchMethodException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		} catch (IllegalArgumentException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		} catch (IllegalAccessException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		} catch (InvocationTargetException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		} catch (NoSuchFieldException e) {
+			ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
+		}
+
+		return NO_RESULT;
+	}
 }
diff --git a/src/main/java/org/acra/collector/DumpSysCollector.java b/src/main/java/org/acra/collector/DumpSysCollector.java
index a6afd86e..62e880c9 100644
--- a/src/main/java/org/acra/collector/DumpSysCollector.java
+++ b/src/main/java/org/acra/collector/DumpSysCollector.java
@@ -15,8 +15,7 @@
  */
 package org.acra.collector;
 
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
+import static org.acra.ACRA.LOG_TAG;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -24,7 +23,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.acra.ACRA.LOG_TAG;
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
 
 /**
  * Collects results of the <code>dumpsys</code> command.
@@ -34,40 +34,44 @@
  */
 final class DumpSysCollector {
 
-    /**
-     * Collect results of the <code>dumpsys meminfo</code> command restricted to
-     * this application process.
-     * 
-     * @return The execution result.
-     */
-    public static String collectMemInfo() {
+	/**
+	 * Collect results of the <code>dumpsys meminfo</code> command restricted to
+	 * this application process.
+	 * 
+	 * @return The execution result.
+	 */
+	public static String collectMemInfo() {
 
-        final StringBuilder meminfo = new StringBuilder();
+		final StringBuilder meminfo = new StringBuilder();
 		BufferedReader bufferedReader = null;
-        try {
-            final List<String> commandLine = new ArrayList<String>();
-            commandLine.add("dumpsys");
-            commandLine.add("meminfo");
-            commandLine.add(Integer.toString(android.os.Process.myPid()));
+		try {
+			final List<String> commandLine = new ArrayList<String>();
+			commandLine.add("dumpsys");
+			commandLine.add("meminfo");
+			commandLine.add(Integer.toString(android.os.Process.myPid()));
 
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+			final Process process = Runtime.getRuntime().exec(
+					commandLine.toArray(new String[commandLine.size()]));
+			bufferedReader = new BufferedReader(new InputStreamReader(
+					process.getInputStream()),
+					ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
 
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                meminfo.append(line);
-                meminfo.append("\n");
-            }
+			while (true) {
+				final String line = bufferedReader.readLine();
+				if (line == null) {
+					break;
+				}
+				meminfo.append(line);
+				meminfo.append("\n");
+			}
 
-        } catch (IOException e) {
-            ACRA.log.e(LOG_TAG, "DumpSysCollector.meminfo could not retrieve data", e);
+		} catch (IOException e) {
+			ACRA.log.e(LOG_TAG,
+					"DumpSysCollector.meminfo could not retrieve data", e);
 		}
 
-        CollectorUtil.safeClose(bufferedReader);
+		CollectorUtil.safeClose(bufferedReader);
 
-        return meminfo.toString();
-    }
+		return meminfo.toString();
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/LogCatCollector.java b/src/main/java/org/acra/collector/LogCatCollector.java
index 9334d3cb..e032f6a6 100644
--- a/src/main/java/org/acra/collector/LogCatCollector.java
+++ b/src/main/java/org/acra/collector/LogCatCollector.java
@@ -31,7 +31,6 @@
 import org.acra.annotation.ReportsCrashes;
 import org.acra.util.BoundedLinkedList;
 
-
 /**
  * Executes logcat commands and collects it's output.
  * 
@@ -40,98 +39,103 @@
  */
 class LogCatCollector {
 
-    /**
-     * Default number of latest lines kept from the logcat output.
-     */
-    private static final int DEFAULT_TAIL_COUNT = 100;
-
-    /**
-     * Executes the logcat command with arguments taken from
-     * {@link ReportsCrashes#logcatArguments()}
-     * 
-     * @param bufferName
-     *            The name of the buffer to be read: "main" (default), "radio"
-     *            or "events".
-     * @return A {@link String} containing the latest lines of the output.
-     *         Default is 100 lines, use "-t", "300" in
-     *         {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
-     *         You should be aware that increasing this value causes a longer
-     *         report generation time and a bigger footprint on the device data
-     *         plan consumption.
-     */
-    public static String collectLogCat(String bufferName) {
-        final int myPid = android.os.Process.myPid();
-        String myPidStr = null;
-        if (ACRA.getConfig().logcatFilterByPid() && myPid > 0) {
-            myPidStr = Integer.toString(myPid) +"):";
-        }
-
-        final List<String> commandLine = new ArrayList<String>();
-        commandLine.add("logcat");
-        if (bufferName != null) {
-            commandLine.add("-b");
-            commandLine.add(bufferName);
-        }
-
-        // "-t n" argument has been introduced in FroYo (API level 8). For
-        // devices with lower API level, we will have to emulate its job.
-        final int tailCount;
-        final List<String> logcatArgumentsList = new ArrayList<String>(
-                Arrays.asList(ACRA.getConfig().logcatArguments()));
-
-        final int tailIndex = logcatArgumentsList.indexOf("-t");
-        if (tailIndex > -1 && tailIndex < logcatArgumentsList.size()) {
-            tailCount = Integer.parseInt(logcatArgumentsList.get(tailIndex + 1));
-            if (Compatibility.getAPILevel() < 8) {
-                logcatArgumentsList.remove(tailIndex + 1);
-                logcatArgumentsList.remove(tailIndex);
-                logcatArgumentsList.add("-d");
-            }
-        } else {
-            tailCount = -1;
-        }
-
-        final LinkedList<String> logcatBuf = new BoundedLinkedList<String>(tailCount > 0 ? tailCount
-                : DEFAULT_TAIL_COUNT);
-        commandLine.addAll(logcatArgumentsList);
-        
-        BufferedReader bufferedReader = null;
-
-        try {
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-            ACRA.log.d(LOG_TAG, "Retrieving logcat output...");
-
-            // Dump stderr to null
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        InputStream stderr = process.getErrorStream();
-                        byte[] dummy = new byte[ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES];
-                        while (stderr.read(dummy) >= 0)
-                            ;
-                    } catch (IOException e) {
-                    }
-                }
-            }).start();
-
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                if (myPidStr == null || line.contains(myPidStr)) {
-                    logcatBuf.add(line + "\n");
-                }
-            }
-
-        } catch (IOException e) {
-            ACRA.log.e(LOG_TAG, "LogCatCollector.collectLogCat could not retrieve data.", e);
-        } finally {
-            CollectorUtil.safeClose(bufferedReader);
-        }
-
-        return logcatBuf.toString();
-    }
+	/**
+	 * Default number of latest lines kept from the logcat output.
+	 */
+	private static final int DEFAULT_TAIL_COUNT = 100;
+
+	/**
+	 * Executes the logcat command with arguments taken from
+	 * {@link ReportsCrashes#logcatArguments()}
+	 * 
+	 * @param bufferName
+	 *            The name of the buffer to be read: "main" (default), "radio"
+	 *            or "events".
+	 * @return A {@link String} containing the latest lines of the output.
+	 *         Default is 100 lines, use "-t", "300" in
+	 *         {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
+	 *         You should be aware that increasing this value causes a longer
+	 *         report generation time and a bigger footprint on the device data
+	 *         plan consumption.
+	 */
+	public static String collectLogCat(String bufferName) {
+		final int myPid = android.os.Process.myPid();
+		String myPidStr = null;
+		if (ACRA.getConfig().logcatFilterByPid() && myPid > 0) {
+			myPidStr = Integer.toString(myPid) + "):";
+		}
+
+		final List<String> commandLine = new ArrayList<String>();
+		commandLine.add("logcat");
+		if (bufferName != null) {
+			commandLine.add("-b");
+			commandLine.add(bufferName);
+		}
+
+		// "-t n" argument has been introduced in FroYo (API level 8). For
+		// devices with lower API level, we will have to emulate its job.
+		final int tailCount;
+		final List<String> logcatArgumentsList = new ArrayList<String>(
+				Arrays.asList(ACRA.getConfig().logcatArguments()));
+
+		final int tailIndex = logcatArgumentsList.indexOf("-t");
+		if (tailIndex > -1 && tailIndex < logcatArgumentsList.size()) {
+			tailCount = Integer
+					.parseInt(logcatArgumentsList.get(tailIndex + 1));
+			if (Compatibility.getAPILevel() < 8) {
+				logcatArgumentsList.remove(tailIndex + 1);
+				logcatArgumentsList.remove(tailIndex);
+				logcatArgumentsList.add("-d");
+			}
+		} else {
+			tailCount = -1;
+		}
+
+		final LinkedList<String> logcatBuf = new BoundedLinkedList<String>(
+				tailCount > 0 ? tailCount : DEFAULT_TAIL_COUNT);
+		commandLine.addAll(logcatArgumentsList);
+
+		BufferedReader bufferedReader = null;
+
+		try {
+			final Process process = Runtime.getRuntime().exec(
+					commandLine.toArray(new String[commandLine.size()]));
+			bufferedReader = new BufferedReader(new InputStreamReader(
+					process.getInputStream()),
+					ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+
+			ACRA.log.d(LOG_TAG, "Retrieving logcat output...");
+
+			// Dump stderr to null
+			new Thread(new Runnable() {
+				public void run() {
+					try {
+						InputStream stderr = process.getErrorStream();
+						byte[] dummy = new byte[ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES];
+						while (stderr.read(dummy) >= 0)
+							;
+					} catch (IOException e) {
+					}
+				}
+			}).start();
+
+			while (true) {
+				final String line = bufferedReader.readLine();
+				if (line == null) {
+					break;
+				}
+				if (myPidStr == null || line.contains(myPidStr)) {
+					logcatBuf.add(line + "\n");
+				}
+			}
+
+		} catch (IOException e) {
+			ACRA.log.e(LOG_TAG,
+					"LogCatCollector.collectLogCat could not retrieve data.", e);
+		} finally {
+			CollectorUtil.safeClose(bufferedReader);
+		}
+
+		return logcatBuf.toString();
+	}
 }
diff --git a/src/main/java/org/acra/collector/LogFileCollector.java b/src/main/java/org/acra/collector/LogFileCollector.java
index c3311365..d655b131 100644
--- a/src/main/java/org/acra/collector/LogFileCollector.java
+++ b/src/main/java/org/acra/collector/LogFileCollector.java
@@ -35,40 +35,44 @@
  */
 class LogFileCollector {
 
-    /**
-     * Private constructor to prevent instantiation.
-     */
-    private LogFileCollector() {
-    };
+	/**
+	 * Private constructor to prevent instantiation.
+	 */
+	private LogFileCollector() {
+	};
 
-    /**
-     * Reads the last lines of a custom log file. The file name is assumed as
-     * located in the {@link Application#getFilesDir()} directory if it does not
-     * contain any path separator.
-     * 
-     * @param context
-     * @param fileName
-     * @param numberOfLines
-     * @return
-     * @throws IOException
-     */
-    public static String collectLogFile(Context context, String fileName, int numberOfLines) throws IOException {
-        final BoundedLinkedList<String> resultBuffer = new BoundedLinkedList<String>(numberOfLines);
-        final BufferedReader reader;
-        if (fileName.contains("/")) {
-            reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)), 1024);
-        } else {
-            reader = new BufferedReader(new InputStreamReader(context.openFileInput(fileName)), 1024);
-        }
-        try {
-            String line = reader.readLine();
-            while (line != null) {
-                resultBuffer.add(line + "\n");
-                line = reader.readLine();
-            }
-        } finally {
-            CollectorUtil.safeClose(reader);
-        }
-        return resultBuffer.toString();
-    }
+	/**
+	 * Reads the last lines of a custom log file. The file name is assumed as
+	 * located in the {@link Application#getFilesDir()} directory if it does not
+	 * contain any path separator.
+	 * 
+	 * @param context
+	 * @param fileName
+	 * @param numberOfLines
+	 * @return
+	 * @throws IOException
+	 */
+	public static String collectLogFile(Context context, String fileName,
+			int numberOfLines) throws IOException {
+		final BoundedLinkedList<String> resultBuffer = new BoundedLinkedList<String>(
+				numberOfLines);
+		final BufferedReader reader;
+		if (fileName.contains("/")) {
+			reader = new BufferedReader(new InputStreamReader(
+					new FileInputStream(fileName)), 1024);
+		} else {
+			reader = new BufferedReader(new InputStreamReader(
+					context.openFileInput(fileName)), 1024);
+		}
+		try {
+			String line = reader.readLine();
+			while (line != null) {
+				resultBuffer.add(line + "\n");
+				line = reader.readLine();
+			}
+		} finally {
+			CollectorUtil.safeClose(reader);
+		}
+		return resultBuffer.toString();
+	}
 }
diff --git a/src/main/java/org/acra/collector/MediaCodecListCollector.java b/src/main/java/org/acra/collector/MediaCodecListCollector.java
index 4ca24819..d0aa5585 100644
--- a/src/main/java/org/acra/collector/MediaCodecListCollector.java
+++ b/src/main/java/org/acra/collector/MediaCodecListCollector.java
@@ -32,250 +32,278 @@
  * 
  */
 public class MediaCodecListCollector {
-    private enum CodecType {
-        AVC, H263, MPEG4, AAC
+	private enum CodecType {
+		AVC, H263, MPEG4, AAC
 
-    }
+	}
 
-    private static final String COLOR_FORMAT_PREFIX = "COLOR_";
-    private static final String[] MPEG4_TYPES = { "mp4", "mpeg4", "MP4", "MPEG4" };
-    private static final String[] AVC_TYPES = { "avc", "h264", "AVC", "H264" };
-    private static final String[] H263_TYPES = { "h263", "H263" };
-    private static final String[] AAC_TYPES = { "aac", "AAC" };
+	private static final String COLOR_FORMAT_PREFIX = "COLOR_";
+	private static final String[] MPEG4_TYPES = { "mp4", "mpeg4", "MP4",
+			"MPEG4" };
+	private static final String[] AVC_TYPES = { "avc", "h264", "AVC", "H264" };
+	private static final String[] H263_TYPES = { "h263", "H263" };
+	private static final String[] AAC_TYPES = { "aac", "AAC" };
 
-    private static Class<?> mediaCodecListClass = null;
-    private static Method getCodecInfoAtMethod = null;
-    private static Class<?> mediaCodecInfoClass = null;
-    private static Method getNameMethod = null;
-    private static Method isEncoderMethod = null;
-    private static Method getSupportedTypesMethod = null;
-    private static Method getCapabilitiesForTypeMethod = null;
-    private static Class<?> codecCapabilitiesClass = null;
-    private static Field colorFormatsField = null;
-    private static Field profileLevelsField = null;
-    private static Field profileField = null;
-    private static Field levelField = null;
-    private static SparseArray<String> mColorFormatValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCLevelValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mH263LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mH263ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mAACProfileValues = new SparseArray<String>();
+	private static Class<?> mediaCodecListClass = null;
+	private static Method getCodecInfoAtMethod = null;
+	private static Class<?> mediaCodecInfoClass = null;
+	private static Method getNameMethod = null;
+	private static Method isEncoderMethod = null;
+	private static Method getSupportedTypesMethod = null;
+	private static Method getCapabilitiesForTypeMethod = null;
+	private static Class<?> codecCapabilitiesClass = null;
+	private static Field colorFormatsField = null;
+	private static Field profileLevelsField = null;
+	private static Field profileField = null;
+	private static Field levelField = null;
+	private static SparseArray<String> mColorFormatValues = new SparseArray<String>();
+	private static SparseArray<String> mAVCLevelValues = new SparseArray<String>();
+	private static SparseArray<String> mAVCProfileValues = new SparseArray<String>();
+	private static SparseArray<String> mH263LevelValues = new SparseArray<String>();
+	private static SparseArray<String> mH263ProfileValues = new SparseArray<String>();
+	private static SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
+	private static SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
+	private static SparseArray<String> mAACProfileValues = new SparseArray<String>();
 
-    // static init where nearly all reflection inspection is done.
-    static {
-        try {
-            mediaCodecListClass = Class.forName("android.media.MediaCodecList");
-            // Get methods to retrieve media codec info
-            getCodecInfoAtMethod = mediaCodecListClass.getMethod("getCodecInfoAt", int.class);
-            mediaCodecInfoClass = Class.forName("android.media.MediaCodecInfo");
-            getNameMethod = mediaCodecInfoClass.getMethod("getName");
-            isEncoderMethod = mediaCodecInfoClass.getMethod("isEncoder");
-            getSupportedTypesMethod = mediaCodecInfoClass.getMethod("getSupportedTypes");
-            getCapabilitiesForTypeMethod = mediaCodecInfoClass.getMethod("getCapabilitiesForType", String.class);
-            codecCapabilitiesClass = Class.forName("android.media.MediaCodecInfo$CodecCapabilities");
-            colorFormatsField = codecCapabilitiesClass.getField("colorFormats");
-            profileLevelsField = codecCapabilitiesClass.getField("profileLevels");
+	// static init where nearly all reflection inspection is done.
+	static {
+		try {
+			mediaCodecListClass = Class.forName("android.media.MediaCodecList");
+			// Get methods to retrieve media codec info
+			getCodecInfoAtMethod = mediaCodecListClass.getMethod(
+					"getCodecInfoAt", int.class);
+			mediaCodecInfoClass = Class.forName("android.media.MediaCodecInfo");
+			getNameMethod = mediaCodecInfoClass.getMethod("getName");
+			isEncoderMethod = mediaCodecInfoClass.getMethod("isEncoder");
+			getSupportedTypesMethod = mediaCodecInfoClass
+					.getMethod("getSupportedTypes");
+			getCapabilitiesForTypeMethod = mediaCodecInfoClass.getMethod(
+					"getCapabilitiesForType", String.class);
+			codecCapabilitiesClass = Class
+					.forName("android.media.MediaCodecInfo$CodecCapabilities");
+			colorFormatsField = codecCapabilitiesClass.getField("colorFormats");
+			profileLevelsField = codecCapabilitiesClass
+					.getField("profileLevels");
 
-            // Retrieve list of possible Color Format
-            for (Field f : codecCapabilitiesClass.getFields()) {
-                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())
-                        && f.getName().startsWith(COLOR_FORMAT_PREFIX)) {
-                    mColorFormatValues.put(f.getInt(null), f.getName());
-                }
-            }
+			// Retrieve list of possible Color Format
+			for (Field f : codecCapabilitiesClass.getFields()) {
+				if (Modifier.isStatic(f.getModifiers())
+						&& Modifier.isFinal(f.getModifiers())
+						&& f.getName().startsWith(COLOR_FORMAT_PREFIX)) {
+					mColorFormatValues.put(f.getInt(null), f.getName());
+				}
+			}
 
-            // Retrieve lists of possible codecs profiles and levels
-            Class<?> codecProfileLevelClass = Class.forName("android.media.MediaCodecInfo$CodecProfileLevel");
-            for (Field f : codecProfileLevelClass.getFields()) {
-                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
-                    if (f.getName().startsWith("AVCLevel")) {
-                        mAVCLevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("AVCProfile")) {
-                        mAVCProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("H263Level")) {
-                        mH263LevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("H263Profile")) {
-                        mH263ProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("MPEG4Level")) {
-                        mMPEG4LevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("MPEG4Profile")) {
-                        mMPEG4ProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("AAC")) {
-                        mAACProfileValues.put(f.getInt(null), f.getName());
-                    }
-                }
-            }
+			// Retrieve lists of possible codecs profiles and levels
+			Class<?> codecProfileLevelClass = Class
+					.forName("android.media.MediaCodecInfo$CodecProfileLevel");
+			for (Field f : codecProfileLevelClass.getFields()) {
+				if (Modifier.isStatic(f.getModifiers())
+						&& Modifier.isFinal(f.getModifiers())) {
+					if (f.getName().startsWith("AVCLevel")) {
+						mAVCLevelValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("AVCProfile")) {
+						mAVCProfileValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("H263Level")) {
+						mH263LevelValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("H263Profile")) {
+						mH263ProfileValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("MPEG4Level")) {
+						mMPEG4LevelValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("MPEG4Profile")) {
+						mMPEG4ProfileValues.put(f.getInt(null), f.getName());
+					} else if (f.getName().startsWith("AAC")) {
+						mAACProfileValues.put(f.getInt(null), f.getName());
+					}
+				}
+			}
 
-            profileField = codecProfileLevelClass.getField("profile");
-            levelField = codecProfileLevelClass.getField("level");
+			profileField = codecProfileLevelClass.getField("profile");
+			levelField = codecProfileLevelClass.getField("level");
 
-        } catch (ClassNotFoundException e) {
-            // NOOP
-        } catch (NoSuchMethodException e) {
-            // NOOP
-        } catch (IllegalArgumentException e) {
-            // NOOP
-        } catch (IllegalAccessException e) {
-            // NOOP
-        } catch (SecurityException e) {
-            // NOOP
-        } catch (NoSuchFieldException e) {
-            // NOOP
-        }
+		} catch (ClassNotFoundException e) {
+			// NOOP
+		} catch (NoSuchMethodException e) {
+			// NOOP
+		} catch (IllegalArgumentException e) {
+			// NOOP
+		} catch (IllegalAccessException e) {
+			// NOOP
+		} catch (SecurityException e) {
+			// NOOP
+		} catch (NoSuchFieldException e) {
+			// NOOP
+		}
 
-    }
+	}
 
-    /**
-     * Builds a String describing the list of available codecs on the device
-     * with their capabilities (supported Color Formats, Codec Profiles et
-     * Levels).
-     * 
-     * @return The media codecs information
-     */
-    public static String collecMediaCodecList() {
-        StringBuilder result = new StringBuilder();
-        if (mediaCodecListClass != null && mediaCodecInfoClass != null) {
-            try {
-                // Retrieve list of available media codecs
-                int codecCount = (Integer) (mediaCodecListClass.getMethod("getCodecCount").invoke(null));
+	/**
+	 * Builds a String describing the list of available codecs on the device
+	 * with their capabilities (supported Color Formats, Codec Profiles et
+	 * Levels).
+	 * 
+	 * @return The media codecs information
+	 */
+	public static String collecMediaCodecList() {
+		StringBuilder result = new StringBuilder();
+		if (mediaCodecListClass != null && mediaCodecInfoClass != null) {
+			try {
+				// Retrieve list of available media codecs
+				int codecCount = (Integer) (mediaCodecListClass
+						.getMethod("getCodecCount").invoke(null));
 
-                // Go through each available media codec
-                Object codecInfo = null;
-                for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
-                    result.append("\n");
-                    codecInfo = getCodecInfoAtMethod.invoke(null, codecIdx);
-                    result.append(codecIdx).append(": ").append(getNameMethod.invoke(codecInfo)).append("\n");
-                    result.append("isEncoder: ").append(isEncoderMethod.invoke(codecInfo)).append("\n");
-                    String[] supportedTypes = (String[]) getSupportedTypesMethod.invoke(codecInfo);
-                    result.append("Supported types: ").append(Arrays.toString(supportedTypes)).append("\n");
-                    for (String type : supportedTypes) {
-                        result.append(collectCapabilitiesForType(codecInfo, type));
-                    }
-                    result.append("\n");
-                }
-            } catch (NoSuchMethodException e) {
-                // NOOP
-            } catch (IllegalAccessException e) {
-                // NOOP
-            } catch (InvocationTargetException e) {
-                // NOOP
-            }
-        }
-        return result.toString();
-    }
+				// Go through each available media codec
+				Object codecInfo = null;
+				for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
+					result.append("\n");
+					codecInfo = getCodecInfoAtMethod.invoke(null, codecIdx);
+					result.append(codecIdx).append(": ")
+							.append(getNameMethod.invoke(codecInfo))
+							.append("\n");
+					result.append("isEncoder: ")
+							.append(isEncoderMethod.invoke(codecInfo))
+							.append("\n");
+					String[] supportedTypes = (String[]) getSupportedTypesMethod
+							.invoke(codecInfo);
+					result.append("Supported types: ")
+							.append(Arrays.toString(supportedTypes))
+							.append("\n");
+					for (String type : supportedTypes) {
+						result.append(collectCapabilitiesForType(codecInfo,
+								type));
+					}
+					result.append("\n");
+				}
+			} catch (NoSuchMethodException e) {
+				// NOOP
+			} catch (IllegalAccessException e) {
+				// NOOP
+			} catch (InvocationTargetException e) {
+				// NOOP
+			}
+		}
+		return result.toString();
+	}
 
-    /**
-     * Retrieve capabilities (ColorFormats and CodecProfileLevels) for a
-     * specific codec type.
-     * 
-     * @param codecInfo
-     * @param type
-     * @return A string describing the color formats and codec profile levels
-     *         available for a specific codec type.
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
-     */
-    private static String collectCapabilitiesForType(Object codecInfo, String type) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        StringBuilder result = new StringBuilder();
+	/**
+	 * Retrieve capabilities (ColorFormats and CodecProfileLevels) for a
+	 * specific codec type.
+	 * 
+	 * @param codecInfo
+	 * @param type
+	 * @return A string describing the color formats and codec profile levels
+	 *         available for a specific codec type.
+	 * @throws IllegalArgumentException
+	 * @throws IllegalAccessException
+	 * @throws InvocationTargetException
+	 */
+	private static String collectCapabilitiesForType(Object codecInfo,
+			String type) throws IllegalArgumentException,
+			IllegalAccessException, InvocationTargetException {
+		StringBuilder result = new StringBuilder();
 
-        Object codecCapabilities = getCapabilitiesForTypeMethod.invoke(codecInfo, type);
+		Object codecCapabilities = getCapabilitiesForTypeMethod.invoke(
+				codecInfo, type);
 
-        // Color Formats
-        int[] colorFormats = (int[]) colorFormatsField.get(codecCapabilities);
-        if (colorFormats.length > 0) {
-            result.append(type).append(" color formats:");
-            for (int i = 0; i < colorFormats.length; i++) {
-                result.append(mColorFormatValues.get(colorFormats[i]));
-                if (i < colorFormats.length - 1) {
-                    result.append(',');
-                }
-            }
-            result.append("\n");
-        }
+		// Color Formats
+		int[] colorFormats = (int[]) colorFormatsField.get(codecCapabilities);
+		if (colorFormats.length > 0) {
+			result.append(type).append(" color formats:");
+			for (int i = 0; i < colorFormats.length; i++) {
+				result.append(mColorFormatValues.get(colorFormats[i]));
+				if (i < colorFormats.length - 1) {
+					result.append(',');
+				}
+			}
+			result.append("\n");
+		}
 
-        // Profile Levels
-        Object[] codecProfileLevels = (Object[]) profileLevelsField.get(codecCapabilities);
-        if (codecProfileLevels.length > 0) {
-            result.append(type).append(" profile levels:");
-            for (int i = 0; i < codecProfileLevels.length; i++) {
+		// Profile Levels
+		Object[] codecProfileLevels = (Object[]) profileLevelsField
+				.get(codecCapabilities);
+		if (codecProfileLevels.length > 0) {
+			result.append(type).append(" profile levels:");
+			for (int i = 0; i < codecProfileLevels.length; i++) {
 
-                CodecType codecType = identifyCodecType(codecInfo);
-                int profileValue = profileField.getInt(codecProfileLevels[i]);
-                int levelValue = levelField.getInt(codecProfileLevels[i]);
+				CodecType codecType = identifyCodecType(codecInfo);
+				int profileValue = profileField.getInt(codecProfileLevels[i]);
+				int levelValue = levelField.getInt(codecProfileLevels[i]);
 
-                if (codecType == null) {
-                    // Unknown codec
-                    result.append(profileValue).append('-').append(levelValue);
-                }
+				if (codecType == null) {
+					// Unknown codec
+					result.append(profileValue).append('-').append(levelValue);
+				}
 
-                switch (codecType) {
-                case AVC:
-                    result.append(profileValue).append(mAVCProfileValues.get(profileValue)).append('-')
-                            .append(mAVCLevelValues.get(levelValue));
-                    break;
-                case H263:
-                    result.append(mH263ProfileValues.get(profileValue)).append('-')
-                            .append(mH263LevelValues.get(levelValue));
-                    break;
-                case MPEG4:
-                    result.append(mMPEG4ProfileValues.get(profileValue)).append('-')
-                            .append(mMPEG4LevelValues.get(levelValue));
-                    break;
-                case AAC:
-                    result.append(mAACProfileValues.get(profileValue));
-                    break;
-                default:
-                    break;
-                }
+				switch (codecType) {
+				case AVC:
+					result.append(profileValue)
+							.append(mAVCProfileValues.get(profileValue))
+							.append('-')
+							.append(mAVCLevelValues.get(levelValue));
+					break;
+				case H263:
+					result.append(mH263ProfileValues.get(profileValue))
+							.append('-')
+							.append(mH263LevelValues.get(levelValue));
+					break;
+				case MPEG4:
+					result.append(mMPEG4ProfileValues.get(profileValue))
+							.append('-')
+							.append(mMPEG4LevelValues.get(levelValue));
+					break;
+				case AAC:
+					result.append(mAACProfileValues.get(profileValue));
+					break;
+				default:
+					break;
+				}
 
-                if (i < codecProfileLevels.length - 1) {
-                    result.append(',');
-                }
+				if (i < codecProfileLevels.length - 1) {
+					result.append(',');
+				}
 
-            }
-            result.append("\n");
-        }
-        return result.append("\n").toString();
-    }
+			}
+			result.append("\n");
+		}
+		return result.append("\n").toString();
+	}
 
-    /**
-     * Looks for keywords in the codec name to identify its nature ({@link CodecType}).
-     * @param codecInfo
-     * @return
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
-     */
-    private static CodecType identifyCodecType(Object codecInfo) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
+	/**
+	 * Looks for keywords in the codec name to identify its nature (
+	 * {@link CodecType}).
+	 * 
+	 * @param codecInfo
+	 * @return
+	 * @throws IllegalArgumentException
+	 * @throws IllegalAccessException
+	 * @throws InvocationTargetException
+	 */
+	private static CodecType identifyCodecType(Object codecInfo)
+			throws IllegalArgumentException, IllegalAccessException,
+			InvocationTargetException {
 
-        String name = (String) getNameMethod.invoke(codecInfo);
-        for (String token : AVC_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.AVC;
-            }
-        }
-        for (String token : H263_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.H263;
-            }
-        }
-        for (String token : MPEG4_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.MPEG4;
-            }
-        }
-        for (String token : AAC_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.AAC;
-            }
-        }
+		String name = (String) getNameMethod.invoke(codecInfo);
+		for (String token : AVC_TYPES) {
+			if (name.contains(token)) {
+				return CodecType.AVC;
+			}
+		}
+		for (String token : H263_TYPES) {
+			if (name.contains(token)) {
+				return CodecType.H263;
+			}
+		}
+		for (String token : MPEG4_TYPES) {
+			if (name.contains(token)) {
+				return CodecType.MPEG4;
+			}
+		}
+		for (String token : AAC_TYPES) {
+			if (name.contains(token)) {
+				return CodecType.AAC;
+			}
+		}
 
-        return null;
-    }
+		return null;
+	}
 }
diff --git a/src/main/java/org/acra/collector/ReflectionCollector.java b/src/main/java/org/acra/collector/ReflectionCollector.java
index 47a2a917..934cf84a 100644
--- a/src/main/java/org/acra/collector/ReflectionCollector.java
+++ b/src/main/java/org/acra/collector/ReflectionCollector.java
@@ -24,83 +24,87 @@
 /**
  * Tools to retrieve key/value pairs from static fields and getters of any
  * class. Reflection API usage allows to retrieve data without having to
- * implement a class for each android version of each interesting class.
- * It can also help find hidden properties.
+ * implement a class for each android version of each interesting class. It can
+ * also help find hidden properties.
  * 
  * @author Kevin Gaudin
  * 
  */
 final class ReflectionCollector {
 
-    /**
-     * Retrieves key/value pairs from static fields of a class.
-     *
-     * @param someClass the class to be inspected.
-     * 
-     * @return A human readable string with a key=value pair on each line.
-     */
-    public static String collectConstants(Class<?> someClass, String prefix) {
+	/**
+	 * Retrieves key/value pairs from static fields of a class.
+	 *
+	 * @param someClass
+	 *            the class to be inspected.
+	 * 
+	 * @return A human readable string with a key=value pair on each line.
+	 */
+	public static String collectConstants(Class<?> someClass, String prefix) {
 
-        final StringBuilder result = new StringBuilder();
+		final StringBuilder result = new StringBuilder();
 
-        final Field[] fields = someClass.getFields();
-        for (final Field field : fields) {
-            if (prefix != null && prefix.length() > 0) {
-                result.append(prefix).append('.');
-            }
-            result.append(field.getName()).append("=");
-            try {
-                final Object value = field.get(null);
-                if (value != null) {
-                    if (field.getType().isArray()) {
-                        result.append(Arrays.toString((Object[]) value));
-                    } else {
-                        result.append(value.toString());
-                    }
-                }
-            } catch (IllegalArgumentException e) {
-                result.append("N/A");
-            } catch (IllegalAccessException e) {
-                result.append("N/A");
-            }
-            result.append("\n");
-        }
+		final Field[] fields = someClass.getFields();
+		for (final Field field : fields) {
+			if (prefix != null && prefix.length() > 0) {
+				result.append(prefix).append('.');
+			}
+			result.append(field.getName()).append("=");
+			try {
+				final Object value = field.get(null);
+				if (value != null) {
+					if (field.getType().isArray()) {
+						result.append(Arrays.toString((Object[]) value));
+					} else {
+						result.append(value.toString());
+					}
+				}
+			} catch (IllegalArgumentException e) {
+				result.append("N/A");
+			} catch (IllegalAccessException e) {
+				result.append("N/A");
+			}
+			result.append("\n");
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    /**
-     * Retrieves key/value pairs from static getters of a class (get*() or is*()).
-     *
-     * @param someClass the class to be inspected.
-     * @return A human readable string with a key=value pair on each line.
-     */
-    public static String collectStaticGettersResults(Class<?> someClass) {
-        final StringBuilder result = new StringBuilder();
-        final Method[] methods = someClass.getMethods();
-        for (final Method method : methods) {
-            if (method.getParameterTypes().length == 0
-                    && (method.getName().startsWith("get") || method.getName().startsWith("is"))
-                    && !method.getName().equals("getClass")) {
-                try {
-                    result.append(method.getName());
-                    result.append('=');
-                    result.append(method.invoke(null, (Object[]) null));
-                    result.append("\n");
-                } catch (IllegalArgumentException e) {
-                    // NOOP
-                } catch (IllegalAccessException e) {
-                    // NOOP
-                } catch (InvocationTargetException e) {
-                    // NOOP
-                }
-            }
-        }
+	/**
+	 * Retrieves key/value pairs from static getters of a class (get*() or
+	 * is*()).
+	 *
+	 * @param someClass
+	 *            the class to be inspected.
+	 * @return A human readable string with a key=value pair on each line.
+	 */
+	public static String collectStaticGettersResults(Class<?> someClass) {
+		final StringBuilder result = new StringBuilder();
+		final Method[] methods = someClass.getMethods();
+		for (final Method method : methods) {
+			if (method.getParameterTypes().length == 0
+					&& (method.getName().startsWith("get") || method.getName()
+							.startsWith("is"))
+					&& !method.getName().equals("getClass")) {
+				try {
+					result.append(method.getName());
+					result.append('=');
+					result.append(method.invoke(null, (Object[]) null));
+					result.append("\n");
+				} catch (IllegalArgumentException e) {
+					// NOOP
+				} catch (IllegalAccessException e) {
+					// NOOP
+				} catch (InvocationTargetException e) {
+					// NOOP
+				}
+			}
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    public static String collectConstants(Class<?> someClass) {
-        return collectConstants(someClass, "");
-    }
+	public static String collectConstants(Class<?> someClass) {
+		return collectConstants(someClass, "");
+	}
 }
diff --git a/src/main/java/org/acra/collector/SettingsCollector.java b/src/main/java/org/acra/collector/SettingsCollector.java
index 0df5e3ce..24095969 100644
--- a/src/main/java/org/acra/collector/SettingsCollector.java
+++ b/src/main/java/org/acra/collector/SettingsCollector.java
@@ -16,6 +16,8 @@
 
 package org.acra.collector;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -28,8 +30,6 @@
 import android.provider.Settings.Secure;
 import android.provider.Settings.System;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * Helper to collect data from {@link System} and {@link Secure} Settings
  * classes.
@@ -39,123 +39,134 @@
  */
 final class SettingsCollector {
 
-    /**
-     * Collect data from {@link android.provider.Settings.System}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectSystemSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.System.class.getFields();
-        for (final Field key : keys) {
-            // Avoid retrieving deprecated fields... it is useless, has an
-            // impact on perfs, and the system writes many warnings in the
-            // logcat.
-            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class) {
-                try {
-                    final Object value = Settings.System.getString(ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                }
-            }
-        }
+	/**
+	 * Collect data from {@link android.provider.Settings.System}. This
+	 * collector uses reflection to be sure to always get the most accurate data
+	 * whatever Android API level it runs on.
+	 * 
+	 * @param ctx
+	 *            Application context.
+	 * @return A human readable String containing one key=value pair per line.
+	 */
+	public static String collectSystemSettings(Context ctx) {
+		final StringBuilder result = new StringBuilder();
+		final Field[] keys = Settings.System.class.getFields();
+		for (final Field key : keys) {
+			// Avoid retrieving deprecated fields... it is useless, has an
+			// impact on perfs, and the system writes many warnings in the
+			// logcat.
+			if (!key.isAnnotationPresent(Deprecated.class)
+					&& key.getType() == String.class) {
+				try {
+					final Object value = Settings.System.getString(
+							ctx.getContentResolver(), (String) key.get(null));
+					if (value != null) {
+						result.append(key.getName()).append("=").append(value)
+								.append("\n");
+					}
+				} catch (IllegalArgumentException e) {
+					ACRA.log.w(LOG_TAG, "Error : ", e);
+				} catch (IllegalAccessException e) {
+					ACRA.log.w(LOG_TAG, "Error : ", e);
+				}
+			}
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    /**
-     * Collect data from {@link android.provider.Settings.Secure}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectSecureSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.Secure.class.getFields();
-        for (final Field key : keys) {
-            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
-                try {
-                    final Object value = Settings.Secure.getString(ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                }
-            }
-        }
+	/**
+	 * Collect data from {@link android.provider.Settings.Secure}. This
+	 * collector uses reflection to be sure to always get the most accurate data
+	 * whatever Android API level it runs on.
+	 * 
+	 * @param ctx
+	 *            Application context.
+	 * @return A human readable String containing one key=value pair per line.
+	 */
+	public static String collectSecureSettings(Context ctx) {
+		final StringBuilder result = new StringBuilder();
+		final Field[] keys = Settings.Secure.class.getFields();
+		for (final Field key : keys) {
+			if (!key.isAnnotationPresent(Deprecated.class)
+					&& key.getType() == String.class && isAuthorized(key)) {
+				try {
+					final Object value = Settings.Secure.getString(
+							ctx.getContentResolver(), (String) key.get(null));
+					if (value != null) {
+						result.append(key.getName()).append("=").append(value)
+								.append("\n");
+					}
+				} catch (IllegalArgumentException e) {
+					ACRA.log.w(LOG_TAG, "Error : ", e);
+				} catch (IllegalAccessException e) {
+					ACRA.log.w(LOG_TAG, "Error : ", e);
+				}
+			}
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    /**
-     * Collect data from {@link android.provider.Settings.Global}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectGlobalSettings(Context ctx) {
-        if (Compatibility.getAPILevel() < 17) {
-            return "";
-        }
+	/**
+	 * Collect data from {@link android.provider.Settings.Global}. This
+	 * collector uses reflection to be sure to always get the most accurate data
+	 * whatever Android API level it runs on.
+	 * 
+	 * @param ctx
+	 *            Application context.
+	 * @return A human readable String containing one key=value pair per line.
+	 */
+	public static String collectGlobalSettings(Context ctx) {
+		if (Compatibility.getAPILevel() < 17) {
+			return "";
+		}
 
-        final StringBuilder result = new StringBuilder();
-        try {
-            final Class<?> globalClass = Class.forName("android.provider.Settings$Global");
-            final Field[] keys = globalClass.getFields();
-            final Method getString = globalClass.getMethod("getString", ContentResolver.class, String.class);
-            for (final Field key : keys) {
-                if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
-                    final Object value = getString.invoke(null, ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                }
-            }
-        } catch (IllegalArgumentException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (IllegalAccessException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (ClassNotFoundException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (SecurityException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (NoSuchMethodException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (InvocationTargetException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        }
+		final StringBuilder result = new StringBuilder();
+		try {
+			final Class<?> globalClass = Class
+					.forName("android.provider.Settings$Global");
+			final Field[] keys = globalClass.getFields();
+			final Method getString = globalClass.getMethod("getString",
+					ContentResolver.class, String.class);
+			for (final Field key : keys) {
+				if (!key.isAnnotationPresent(Deprecated.class)
+						&& key.getType() == String.class && isAuthorized(key)) {
+					final Object value = getString.invoke(null,
+							ctx.getContentResolver(), (String) key.get(null));
+					if (value != null) {
+						result.append(key.getName()).append("=").append(value)
+								.append("\n");
+					}
+				}
+			}
+		} catch (IllegalArgumentException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		} catch (IllegalAccessException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		} catch (ClassNotFoundException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		} catch (SecurityException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		} catch (NoSuchMethodException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		} catch (InvocationTargetException e) {
+			ACRA.log.w(LOG_TAG, "Error : ", e);
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    private static boolean isAuthorized(Field key) {
-        if (key == null || key.getName().startsWith("WIFI_AP")) {
-            return false;
-        }
-        for (String regex : ACRA.getConfig().excludeMatchingSettingsKeys()) {
-            if(key.getName().matches(regex)) {
-               return false; 
-            }
-        }
-        return true;
-    }
+	private static boolean isAuthorized(Field key) {
+		if (key == null || key.getName().startsWith("WIFI_AP")) {
+			return false;
+		}
+		for (String regex : ACRA.getConfig().excludeMatchingSettingsKeys()) {
+			if (key.getName().matches(regex)) {
+				return false;
+			}
+		}
+		return true;
+	}
 
 }
diff --git a/src/main/java/org/acra/collector/SharedPreferencesCollector.java b/src/main/java/org/acra/collector/SharedPreferencesCollector.java
index d4ef0f7b..d0188430 100644
--- a/src/main/java/org/acra/collector/SharedPreferencesCollector.java
+++ b/src/main/java/org/acra/collector/SharedPreferencesCollector.java
@@ -15,6 +15,8 @@
  */
 package org.acra.collector;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.util.Map;
 import java.util.TreeMap;
 
@@ -25,8 +27,6 @@
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * Collects the content (key/value pairs) of SharedPreferences, from the
  * application default preferences or any other preferences asked by the
@@ -34,78 +34,88 @@
  */
 final class SharedPreferencesCollector {
 
-    /**
-     * Collects all key/value pairs in SharedPreferences and writes them in a
-     * result String. The application default SharedPreferences are always
-     * collected, and the developer can provide additional SharedPreferences
-     * names in the {@link ReportsCrashes#additionalSharedPreferences()}
-     * configuration item.
-     * 
-     * 
-     * 
-     * @param context
-     *            the application context.
-     * @return A readable formatted String containing all key/value pairs.
-     */
-    public static String collect(Context context) {
-        final StringBuilder result = new StringBuilder();
+	/**
+	 * Collects all key/value pairs in SharedPreferences and writes them in a
+	 * result String. The application default SharedPreferences are always
+	 * collected, and the developer can provide additional SharedPreferences
+	 * names in the {@link ReportsCrashes#additionalSharedPreferences()}
+	 * configuration item.
+	 * 
+	 * 
+	 * 
+	 * @param context
+	 *            the application context.
+	 * @return A readable formatted String containing all key/value pairs.
+	 */
+	public static String collect(Context context) {
+		final StringBuilder result = new StringBuilder();
 
-        // Include the default SharedPreferences
-        final Map<String, SharedPreferences> sharedPrefs = new TreeMap<String, SharedPreferences>();
-        sharedPrefs.put("default", PreferenceManager.getDefaultSharedPreferences(context));
+		// Include the default SharedPreferences
+		final Map<String, SharedPreferences> sharedPrefs = new TreeMap<String, SharedPreferences>();
+		sharedPrefs.put("default",
+				PreferenceManager.getDefaultSharedPreferences(context));
 
-        // Add in any additional SharedPreferences
-        final String[] sharedPrefIds = ACRA.getConfig().additionalSharedPreferences();
-        if (sharedPrefIds != null) {
-            for (final String sharedPrefId : sharedPrefIds) {
-                sharedPrefs.put(sharedPrefId, context.getSharedPreferences(sharedPrefId, Context.MODE_PRIVATE));
-            }
-        }
+		// Add in any additional SharedPreferences
+		final String[] sharedPrefIds = ACRA.getConfig()
+				.additionalSharedPreferences();
+		if (sharedPrefIds != null) {
+			for (final String sharedPrefId : sharedPrefIds) {
+				sharedPrefs.put(sharedPrefId, context.getSharedPreferences(
+						sharedPrefId, Context.MODE_PRIVATE));
+			}
+		}
 
-        // Iterate over all included preference files and add the preferences from each.
-        for (Map.Entry<String, SharedPreferences> entry : sharedPrefs.entrySet()) {
-            final String sharedPrefId = entry.getKey();
-            final SharedPreferences prefs = entry.getValue();
+		// Iterate over all included preference files and add the preferences
+		// from each.
+		for (Map.Entry<String, SharedPreferences> entry : sharedPrefs
+				.entrySet()) {
+			final String sharedPrefId = entry.getKey();
+			final SharedPreferences prefs = entry.getValue();
 
-            final Map<String, ?> prefEntries = prefs.getAll();
+			final Map<String, ?> prefEntries = prefs.getAll();
 
-            // Show that we have no preferences saved for that preference file.
-            if (prefEntries.isEmpty()) {
-                result.append(sharedPrefId).append('=').append("empty\n");
-                continue;
-            }
+			// Show that we have no preferences saved for that preference file.
+			if (prefEntries.isEmpty()) {
+				result.append(sharedPrefId).append('=').append("empty\n");
+				continue;
+			}
 
-            // Add all non-filtered preferences from that preference file.
-            for (final String key : prefEntries.keySet()) {
-                if (filteredKey(key)) {
-                    ACRA.log.d(LOG_TAG, "Filtered out sharedPreference=" + sharedPrefId + "  key=" + key + " due to filtering rule");
-                } else {
-                    final Object prefValue = prefEntries.get(key);
-                    result.append(sharedPrefId).append('.').append(key).append('=');
-                    result.append(prefValue == null ? "null" : prefValue.toString());
-                    result.append("\n");
-                }
-            }
-            result.append('\n');
-        }
+			// Add all non-filtered preferences from that preference file.
+			for (final String key : prefEntries.keySet()) {
+				if (filteredKey(key)) {
+					ACRA.log.d(LOG_TAG, "Filtered out sharedPreference="
+							+ sharedPrefId + "  key=" + key
+							+ " due to filtering rule");
+				} else {
+					final Object prefValue = prefEntries.get(key);
+					result.append(sharedPrefId).append('.').append(key)
+							.append('=');
+					result.append(prefValue == null ? "null" : prefValue
+							.toString());
+					result.append("\n");
+				}
+			}
+			result.append('\n');
+		}
 
-        return result.toString();
-    }
+		return result.toString();
+	}
 
-    /**
-     * Checks if the key matches one of the patterns provided by the developer
-     * to exclude some preferences from reports.
-     * 
-     * @param key
-     *            the name of the preference to be checked
-     * @return true if the key has to be excluded from reports.
-     */
-    private static boolean filteredKey(String key) {
-        for (String regex : ACRA.getConfig().excludeMatchingSharedPreferencesKeys()) {
-            if(key.matches(regex)) {
-               return true; 
-            }
-        }
-        return false;
-    }
+	/**
+	 * Checks if the key matches one of the patterns provided by the developer
+	 * to exclude some preferences from reports.
+	 * 
+	 * @param key
+	 *            the name of the preference to be checked
+	 * @return true if the key has to be excluded from reports.
+	 */
+	private static boolean filteredKey(String key) {
+		for (String regex : ACRA.getConfig()
+				.excludeMatchingSharedPreferencesKeys()) {
+			if (key.matches(regex)) {
+				return true;
+			}
+		}
+		return false;
+	}
 }
diff --git a/src/main/java/org/acra/collector/ThreadCollector.java b/src/main/java/org/acra/collector/ThreadCollector.java
index 64e78dc7..1442bcf5 100644
--- a/src/main/java/org/acra/collector/ThreadCollector.java
+++ b/src/main/java/org/acra/collector/ThreadCollector.java
@@ -24,26 +24,30 @@
  */
 public class ThreadCollector {
 
-    /**
-     * Convenience method that collects some data identifying a Thread, usually the Thread which
-     * crashed and returns a string containing the thread's id, name, priority and group name.
-     * 
-     * @param t the thread
-     * @return a string representation of the string including the id, name and priority of the thread.
-     */
-    public static String collect(Thread t) {
-        StringBuilder result = new StringBuilder();
-        if (t != null) {
+	/**
+	 * Convenience method that collects some data identifying a Thread, usually
+	 * the Thread which crashed and returns a string containing the thread's id,
+	 * name, priority and group name.
+	 * 
+	 * @param t
+	 *            the thread
+	 * @return a string representation of the string including the id, name and
+	 *         priority of the thread.
+	 */
+	public static String collect(Thread t) {
+		StringBuilder result = new StringBuilder();
+		if (t != null) {
 
-            result.append("id=").append(t.getId()).append("\n");
-            result.append("name=").append(t.getName()).append("\n");
-            result.append("priority=").append(t.getPriority()).append("\n");
-            if (t.getThreadGroup() != null) {
-                result.append("groupName=").append(t.getThreadGroup().getName()).append("\n");
-            }
-        } else {
-            result.append("No broken thread, this might be a silent exception.");
-        }
-        return result.toString();
-    }
+			result.append("id=").append(t.getId()).append("\n");
+			result.append("name=").append(t.getName()).append("\n");
+			result.append("priority=").append(t.getPriority()).append("\n");
+			if (t.getThreadGroup() != null) {
+				result.append("groupName=")
+						.append(t.getThreadGroup().getName()).append("\n");
+			}
+		} else {
+			result.append("No broken thread, this might be a silent exception.");
+		}
+		return result.toString();
+	}
 }
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
index cb0762fa..12131f0d 100644
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
+++ b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
@@ -28,29 +28,38 @@
 import android.os.Bundle;
 
 /**
- * This adapter class provides empty implementations of the methods from {@link ActivityLifecycleCallbacksCompat}.
- * Any custom listener that cares only about a subset of the methods of this listener can simply subclass this
+ * This adapter class provides empty implementations of the methods from
+ * {@link ActivityLifecycleCallbacksCompat}. Any custom listener that cares only
+ * about a subset of the methods of this listener can simply subclass this
  * adapter class instead of implementing the interface directly.
  */
-public class ActivityLifecycleCallbacksAdapter implements ActivityLifecycleCallbacksCompat {
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {}
+public class ActivityLifecycleCallbacksAdapter implements
+		ActivityLifecycleCallbacksCompat {
+	@Override
+	public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+	}
 
-    @Override
-    public void onActivityStarted(Activity activity) {}
+	@Override
+	public void onActivityStarted(Activity activity) {
+	}
 
-    @Override
-    public void onActivityResumed(Activity activity) {}
+	@Override
+	public void onActivityResumed(Activity activity) {
+	}
 
-    @Override
-    public void onActivityPaused(Activity activity) {}
+	@Override
+	public void onActivityPaused(Activity activity) {
+	}
 
-    @Override
-    public void onActivityStopped(Activity activity) {}
+	@Override
+	public void onActivityStopped(Activity activity) {
+	}
 
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
+	@Override
+	public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
+	}
 
-    @Override
-    public void onActivityDestroyed(Activity activity) {}
+	@Override
+	public void onActivityDestroyed(Activity activity) {
+	}
 }
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
index 0d7f0df8..bc89ae73 100644
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
+++ b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
@@ -31,21 +31,23 @@
 
 /**
  * Equivalent of {@link ActivityLifecycleCallbacks} to be used with
- * {@link ApplicationHelper#registerActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)} and
- * {@link ApplicationHelper#unregisterActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)}.
+ * {@link ApplicationHelper#registerActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)}
+ * and
+ * {@link ApplicationHelper#unregisterActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)}
+ * .
  */
 public interface ActivityLifecycleCallbacksCompat {
-    void onActivityCreated(Activity activity, Bundle savedInstanceState);
+	void onActivityCreated(Activity activity, Bundle savedInstanceState);
 
-    void onActivityStarted(Activity activity);
+	void onActivityStarted(Activity activity);
 
-    void onActivityResumed(Activity activity);
+	void onActivityResumed(Activity activity);
 
-    void onActivityPaused(Activity activity);
+	void onActivityPaused(Activity activity);
 
-    void onActivityStopped(Activity activity);
+	void onActivityStopped(Activity activity);
 
-    void onActivitySaveInstanceState(Activity activity, Bundle outState);
+	void onActivitySaveInstanceState(Activity activity, Bundle outState);
 
-    void onActivityDestroyed(Activity activity);
+	void onActivityDestroyed(Activity activity);
 }
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
index da249637..08a9e833 100644
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
+++ b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
@@ -27,70 +27,72 @@
 import android.app.Application.ActivityLifecycleCallbacks;
 import android.os.Bundle;
 
-import java.util.concurrent.Callable;
-
 /**
- * Wraps an {@link ActivityLifecycleCallbacksCompat} into an {@link ActivityLifecycleCallbacks}.
+ * Wraps an {@link ActivityLifecycleCallbacksCompat} into an
+ * {@link ActivityLifecycleCallbacks}.
  */
-/* package */class ActivityLifecycleCallbacksWrapper implements ActivityLifecycleCallbacks {
-    private org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat mCallback;
+/* package */class ActivityLifecycleCallbacksWrapper implements
+		ActivityLifecycleCallbacks {
+	private org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat mCallback;
 
-    public ActivityLifecycleCallbacksWrapper(org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat callback) {
-        mCallback = callback;
-    }
+	public ActivityLifecycleCallbacksWrapper(
+			org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat callback) {
+		mCallback = callback;
+	}
 
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        mCallback.onActivityCreated(activity, savedInstanceState);
-    }
+	@Override
+	public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+		mCallback.onActivityCreated(activity, savedInstanceState);
+	}
 
-    @Override
-    public void onActivityStarted(Activity activity) {
-        mCallback.onActivityStarted(activity);
-    }
+	@Override
+	public void onActivityStarted(Activity activity) {
+		mCallback.onActivityStarted(activity);
+	}
 
-    @Override
-    public void onActivityResumed(Activity activity) {
-        mCallback.onActivityResumed(activity);
-    }
+	@Override
+	public void onActivityResumed(Activity activity) {
+		mCallback.onActivityResumed(activity);
+	}
 
-    @Override
-    public void onActivityPaused(Activity activity) {
-        mCallback.onActivityPaused(activity);
-    }
+	@Override
+	public void onActivityPaused(Activity activity) {
+		mCallback.onActivityPaused(activity);
+	}
 
-    @Override
-    public void onActivityStopped(Activity activity) {
-        mCallback.onActivityStopped(activity);
-    }
+	@Override
+	public void onActivityStopped(Activity activity) {
+		mCallback.onActivityStopped(activity);
+	}
 
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        mCallback.onActivitySaveInstanceState(activity, outState);
-    }
+	@Override
+	public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
+		mCallback.onActivitySaveInstanceState(activity, outState);
+	}
 
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        mCallback.onActivityDestroyed(activity);
-    }
+	@Override
+	public void onActivityDestroyed(Activity activity) {
+		mCallback.onActivityDestroyed(activity);
+	}
 
-    /**
-     * Compare the current wrapped callback with another object wrapped callback
-     */
-    @Override
-    public boolean equals(Object object) {
-        if( !(object instanceof ActivityLifecycleCallbacksWrapper) )
-            return false;
-        ActivityLifecycleCallbacksWrapper that = ( ActivityLifecycleCallbacksWrapper )object;
-        return null == mCallback ? null == that.mCallback : mCallback.equals( that.mCallback );
-    }
+	/**
+	 * Compare the current wrapped callback with another object wrapped callback
+	 */
+	@Override
+	public boolean equals(Object object) {
+		if (!(object instanceof ActivityLifecycleCallbacksWrapper))
+			return false;
+		ActivityLifecycleCallbacksWrapper that = (ActivityLifecycleCallbacksWrapper) object;
+		return null == mCallback ? null == that.mCallback : mCallback
+				.equals(that.mCallback);
+	}
 
-    /**
-     *
-     * return wrapped callback object hashCode
-     */
-    @Override
-    public int hashCode() {
-        return null != mCallback ? mCallback.hashCode() : 0;
-    }
+	/**
+	 *
+	 * return wrapped callback object hashCode
+	 */
+	@Override
+	public int hashCode() {
+		return null != mCallback ? mCallback.hashCode() : 0;
+	}
 }
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
index 3c147c69..764600fa 100644
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
+++ b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
@@ -30,67 +30,86 @@
 import android.os.Build;
 
 /**
- * Helper for accessing {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} introduced in API level 14 in a
- * backwards compatible fashion.<br>
- * When running on API level 14 or above, the framework's implementations of these methods will be used.
+ * Helper for accessing
+ * {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}
+ * and
+ * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}
+ * introduced in API level 14 in a backwards compatible fashion.<br>
+ * When running on API level 14 or above, the framework's implementations of
+ * these methods will be used.
  */
 public class ApplicationHelper {
-    public static final boolean PRE_ICS = Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH;
+	public static final boolean PRE_ICS = Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 
-    /*
-     * Register.
-     */
+	/*
+	 * Register.
+	 */
 
-    /**
-     * Registers a callback to be called following the life cycle of the application's {@link Activity activities}.
-     * 
-     * @param application The application with which to register the callback.
-     * @param callback The callback to register.
-     */
-    public static void registerActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        if (PRE_ICS) {
-            preIcsRegisterActivityLifecycleCallbacks(callback);
-        } else {
-            postIcsRegisterActivityLifecycleCallbacks(application, callback);
-        }
-    }
+	/**
+	 * Registers a callback to be called following the life cycle of the
+	 * application's {@link Activity activities}.
+	 * 
+	 * @param application
+	 *            The application with which to register the callback.
+	 * @param callback
+	 *            The callback to register.
+	 */
+	public static void registerActivityLifecycleCallbacks(
+			Application application, ActivityLifecycleCallbacksCompat callback) {
+		if (PRE_ICS) {
+			preIcsRegisterActivityLifecycleCallbacks(callback);
+		} else {
+			postIcsRegisterActivityLifecycleCallbacks(application, callback);
+		}
+	}
 
-    private static void preIcsRegisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        MainLifecycleDispatcher.get().registerActivityLifecycleCallbacks(callback);
-    }
+	private static void preIcsRegisterActivityLifecycleCallbacks(
+			ActivityLifecycleCallbacksCompat callback) {
+		MainLifecycleDispatcher.get().registerActivityLifecycleCallbacks(
+				callback);
+	}
 
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    private static void postIcsRegisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
+	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+	private static void postIcsRegisterActivityLifecycleCallbacks(
+			Application application, ActivityLifecycleCallbacksCompat callback) {
+		application
+				.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(
+						callback));
+	}
 
+	/*
+	 * Unregister.
+	 */
 
-    /*
-     * Unregister.
-     */
+	/**
+	 * Unregisters a previously registered callback.
+	 * 
+	 * @param application
+	 *            The application with which to unregister the callback.
+	 * @param callback
+	 *            The callback to unregister.
+	 */
+	public void unregisterActivityLifecycleCallbacks(Application application,
+			ActivityLifecycleCallbacksCompat callback) {
+		if (PRE_ICS) {
+			preIcsUnregisterActivityLifecycleCallbacks(callback);
+		} else {
+			postIcsUnregisterActivityLifecycleCallbacks(application, callback);
+		}
+	}
 
-    /**
-     * Unregisters a previously registered callback.
-     * 
-     * @param application The application with which to unregister the callback.
-     * @param callback The callback to unregister.
-     */
-    public void unregisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        if (PRE_ICS) {
-            preIcsUnregisterActivityLifecycleCallbacks(callback);
-        } else {
-            postIcsUnregisterActivityLifecycleCallbacks(application, callback);
-        }
-    }
+	private static void preIcsUnregisterActivityLifecycleCallbacks(
+			ActivityLifecycleCallbacksCompat callback) {
+		MainLifecycleDispatcher.get().unregisterActivityLifecycleCallbacks(
+				callback);
+	}
 
-    private static void preIcsUnregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        MainLifecycleDispatcher.get().unregisterActivityLifecycleCallbacks(callback);
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    private static void postIcsUnregisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.unregisterActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
+	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+	private static void postIcsUnregisterActivityLifecycleCallbacks(
+			Application application, ActivityLifecycleCallbacksCompat callback) {
+		application
+				.unregisterActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(
+						callback));
+	}
 
 }
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
index de1bb1ed..774021f7 100644
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
+++ b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
@@ -32,111 +32,126 @@
 import android.os.Bundle;
 
 /**
- * Keeps a list of {@link ActivityLifecycleCallbacksCompat}s that will be called following the life cycle of the application's {@link Activity activities}.
- * This class is used when the app is running on an older platform version that does not support
- * {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}.
+ * Keeps a list of {@link ActivityLifecycleCallbacksCompat}s that will be called
+ * following the life cycle of the application's {@link Activity activities}.
+ * This class is used when the app is running on an older platform version that
+ * does not support
+ * {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}
+ * and
+ * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}
+ * .
  */
-public class MainLifecycleDispatcher implements ActivityLifecycleCallbacksCompat {
-    private static final MainLifecycleDispatcher INSTANCE = new MainLifecycleDispatcher();
-
-    public static MainLifecycleDispatcher get() {
-        return INSTANCE;
-    }
-
-    private MainLifecycleDispatcher() {}
-
-    private ArrayList<ActivityLifecycleCallbacksCompat> mActivityLifecycleCallbacks = new ArrayList<ActivityLifecycleCallbacksCompat>();
-
-    /* package */void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.add(callback);
-        }
-    }
-
-    /* package */void unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.remove(callback);
-        }
-    }
-
-    private Object[] collectActivityLifecycleCallbacks() {
-        Object[] callbacks = null;
-        synchronized (mActivityLifecycleCallbacks) {
-            if (mActivityLifecycleCallbacks.size() > 0) {
-                callbacks = mActivityLifecycleCallbacks.toArray();
-            }
-        }
-        return callbacks;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityCreated(activity, savedInstanceState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStarted(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityResumed(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityPaused(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStopped(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivitySaveInstanceState(activity, outState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityDestroyed(activity);
-            }
-        }
-    }
+public class MainLifecycleDispatcher implements
+		ActivityLifecycleCallbacksCompat {
+	private static final MainLifecycleDispatcher INSTANCE = new MainLifecycleDispatcher();
+
+	public static MainLifecycleDispatcher get() {
+		return INSTANCE;
+	}
+
+	private MainLifecycleDispatcher() {
+	}
+
+	private ArrayList<ActivityLifecycleCallbacksCompat> mActivityLifecycleCallbacks = new ArrayList<ActivityLifecycleCallbacksCompat>();
+
+	/* package */void registerActivityLifecycleCallbacks(
+			ActivityLifecycleCallbacksCompat callback) {
+		synchronized (mActivityLifecycleCallbacks) {
+			mActivityLifecycleCallbacks.add(callback);
+		}
+	}
+
+	/* package */void unregisterActivityLifecycleCallbacks(
+			ActivityLifecycleCallbacksCompat callback) {
+		synchronized (mActivityLifecycleCallbacks) {
+			mActivityLifecycleCallbacks.remove(callback);
+		}
+	}
+
+	private Object[] collectActivityLifecycleCallbacks() {
+		Object[] callbacks = null;
+		synchronized (mActivityLifecycleCallbacks) {
+			if (mActivityLifecycleCallbacks.size() > 0) {
+				callbacks = mActivityLifecycleCallbacks.toArray();
+			}
+		}
+		return callbacks;
+	}
+
+	@Override
+	public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityCreated(activity, savedInstanceState);
+			}
+		}
+	}
+
+	@Override
+	public void onActivityStarted(Activity activity) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityStarted(activity);
+			}
+		}
+	}
+
+	@Override
+	public void onActivityResumed(Activity activity) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityResumed(activity);
+			}
+		}
+	}
+
+	@Override
+	public void onActivityPaused(Activity activity) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityPaused(activity);
+			}
+		}
+	}
+
+	@Override
+	public void onActivityStopped(Activity activity) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityStopped(activity);
+			}
+		}
+	}
+
+	@Override
+	public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivitySaveInstanceState(activity, outState);
+			}
+		}
+	}
+
+	@Override
+	public void onActivityDestroyed(Activity activity) {
+		Object[] callbacks = collectActivityLifecycleCallbacks();
+		if (callbacks != null) {
+			for (Object callback : callbacks) {
+				((ActivityLifecycleCallbacksCompat) callback)
+						.onActivityDestroyed(activity);
+			}
+		}
+	}
 }
diff --git a/src/main/java/org/acra/log/ACRALog.java b/src/main/java/org/acra/log/ACRALog.java
index 482b4aba..1a781dbc 100644
--- a/src/main/java/org/acra/log/ACRALog.java
+++ b/src/main/java/org/acra/log/ACRALog.java
@@ -1,27 +1,47 @@
 package org.acra.log;
 
 /**
- * Responsible for providing ACRA classes with a platform neutral way of logging.
+ * Responsible for providing ACRA classes with a platform neutral way of
+ * logging.
  * <p>
- *     One reason for using this mechanism is to allow ACRA classes to use a logging system,
- *     but be able to execute in a test environment outside of an Android JVM.
+ * One reason for using this mechanism is to allow ACRA classes to use a logging
+ * system, but be able to execute in a test environment outside of an Android
+ * JVM.
  * </p>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 public interface ACRALog {
-    public int v(java.lang.String tag, java.lang.String msg);
-    public int v(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int d(java.lang.String tag, java.lang.String msg);
-    public int d(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int i(java.lang.String tag, java.lang.String msg);
-    public int i(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int w(java.lang.String tag, java.lang.String msg);
-    public int w(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(java.lang.String tag, java.lang.Throwable tr);
-    public int e(java.lang.String tag, java.lang.String msg);
-    public int e(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public java.lang.String getStackTraceString(java.lang.Throwable tr);
-    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
+	public int v(java.lang.String tag, java.lang.String msg);
+
+	public int v(java.lang.String tag, java.lang.String msg,
+			java.lang.Throwable tr);
+
+	public int d(java.lang.String tag, java.lang.String msg);
+
+	public int d(java.lang.String tag, java.lang.String msg,
+			java.lang.Throwable tr);
+
+	public int i(java.lang.String tag, java.lang.String msg);
+
+	public int i(java.lang.String tag, java.lang.String msg,
+			java.lang.Throwable tr);
+
+	public int w(java.lang.String tag, java.lang.String msg);
+
+	public int w(java.lang.String tag, java.lang.String msg,
+			java.lang.Throwable tr);
+
+	// public native boolean isLoggable(java.lang.String tag, int level);
+	public int w(java.lang.String tag, java.lang.Throwable tr);
+
+	public int e(java.lang.String tag, java.lang.String msg);
+
+	public int e(java.lang.String tag, java.lang.String msg,
+			java.lang.Throwable tr);
+
+	public java.lang.String getStackTraceString(java.lang.Throwable tr);
+	// public native int println(int priority, java.lang.String tag,
+	// java.lang.String msg);
 }
diff --git a/src/main/java/org/acra/log/AndroidLogDelegate.java b/src/main/java/org/acra/log/AndroidLogDelegate.java
index bd2a366c..696eae21 100644
--- a/src/main/java/org/acra/log/AndroidLogDelegate.java
+++ b/src/main/java/org/acra/log/AndroidLogDelegate.java
@@ -1,51 +1,63 @@
 package org.acra.log;
 
-
 import android.util.Log;
 
 /**
  * Responsible for delegating calls to the Android logging system.
  * <p/>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class AndroidLogDelegate implements ACRALog {
-    public int v(String tag, String msg) {
-        return Log.v(tag, msg);
-    }
-    public int v(String tag, String msg, Throwable tr) {
-        return Log.v(tag, msg, tr);
-    }
-    public int d(String tag, String msg) {
-        return Log.d(tag, msg);
-    }
-    public int d(String tag, String msg, Throwable tr) {
-        return Log.d(tag, msg, tr);
-    }
-    public int i(String tag, String msg) {
-        return Log.i(tag, msg);
-    }
-    public int i(String tag, String msg, Throwable tr) {
-        return Log.i(tag, msg, tr);
-    }
-    public int w(String tag, String msg) {
-        return Log.w(tag, msg);
-    }
-    public int w(String tag, String msg, Throwable tr) {
-        return Log.w(tag, msg, tr);
-    }
-    //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(String tag, Throwable tr) {
-        return Log.w(tag, tr);
-    }
-    public int e(String tag, String msg) {
-        return Log.e(tag, msg);
-    }
-    public int e(String tag, String msg, Throwable tr) {
-        return Log.e(tag, msg, tr);
-    }
-    public String getStackTraceString(Throwable tr) {
-        return Log.getStackTraceString(tr);
-    }
-    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
+	public int v(String tag, String msg) {
+		return Log.v(tag, msg);
+	}
+
+	public int v(String tag, String msg, Throwable tr) {
+		return Log.v(tag, msg, tr);
+	}
+
+	public int d(String tag, String msg) {
+		return Log.d(tag, msg);
+	}
+
+	public int d(String tag, String msg, Throwable tr) {
+		return Log.d(tag, msg, tr);
+	}
+
+	public int i(String tag, String msg) {
+		return Log.i(tag, msg);
+	}
+
+	public int i(String tag, String msg, Throwable tr) {
+		return Log.i(tag, msg, tr);
+	}
+
+	public int w(String tag, String msg) {
+		return Log.w(tag, msg);
+	}
+
+	public int w(String tag, String msg, Throwable tr) {
+		return Log.w(tag, msg, tr);
+	}
+
+	// public native boolean isLoggable(java.lang.String tag, int level);
+	public int w(String tag, Throwable tr) {
+		return Log.w(tag, tr);
+	}
+
+	public int e(String tag, String msg) {
+		return Log.e(tag, msg);
+	}
+
+	public int e(String tag, String msg, Throwable tr) {
+		return Log.e(tag, msg, tr);
+	}
+
+	public String getStackTraceString(Throwable tr) {
+		return Log.getStackTraceString(tr);
+	}
+	// public native int println(int priority, java.lang.String tag,
+	// java.lang.String msg);
 }
diff --git a/src/main/java/org/acra/log/HollowLog.java b/src/main/java/org/acra/log/HollowLog.java
index d5a93f50..f6d875c6 100644
--- a/src/main/java/org/acra/log/HollowLog.java
+++ b/src/main/java/org/acra/log/HollowLog.java
@@ -4,63 +4,63 @@
  * Stub implementation of {@link org.acra.log.ACRALog}, quenches all logging.
  */
 public class HollowLog implements ACRALog {
-    @Override
-    public int v(String tag, String msg) {
-        return 0;
-    }
+	@Override
+	public int v(String tag, String msg) {
+		return 0;
+	}
 
-    @Override
-    public int v(String tag, String msg, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int v(String tag, String msg, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public int d(String tag, String msg) {
-        return 0;
-    }
+	@Override
+	public int d(String tag, String msg) {
+		return 0;
+	}
 
-    @Override
-    public int d(String tag, String msg, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int d(String tag, String msg, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public int i(String tag, String msg) {
-        return 0;
-    }
+	@Override
+	public int i(String tag, String msg) {
+		return 0;
+	}
 
-    @Override
-    public int i(String tag, String msg, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int i(String tag, String msg, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public int w(String tag, String msg) {
-        return 0;
-    }
+	@Override
+	public int w(String tag, String msg) {
+		return 0;
+	}
 
-    @Override
-    public int w(String tag, String msg, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int w(String tag, String msg, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public int w(String tag, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int w(String tag, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public int e(String tag, String msg) {
-        return 0;
-    }
+	@Override
+	public int e(String tag, String msg) {
+		return 0;
+	}
 
-    @Override
-    public int e(String tag, String msg, Throwable tr) {
-        return 0;
-    }
+	@Override
+	public int e(String tag, String msg, Throwable tr) {
+		return 0;
+	}
 
-    @Override
-    public String getStackTraceString(Throwable tr) {
-        return null;
-    }
+	@Override
+	public String getStackTraceString(Throwable tr) {
+		return null;
+	}
 }
diff --git a/src/main/java/org/acra/sender/EmailIntentSender.java b/src/main/java/org/acra/sender/EmailIntentSender.java
index 78cb165c..63a2f923 100644
--- a/src/main/java/org/acra/sender/EmailIntentSender.java
+++ b/src/main/java/org/acra/sender/EmailIntentSender.java
@@ -17,9 +17,9 @@
 
 import org.acra.ACRA;
 import org.acra.ACRAConstants;
-import org.acra.collector.CrashReportData;
 import org.acra.ReportField;
 import org.acra.annotation.ReportsCrashes;
+import org.acra.collector.CrashReportData;
 
 import android.content.Context;
 import android.content.Intent;
@@ -28,43 +28,46 @@
 /**
  * Send reports through an email intent. The user will be asked to chose his
  * preferred email client. Included report fields can be defined using
- * {@link org.acra.annotation.ReportsCrashes#customReportContent()}. Crash receiving mailbox has to be
- * defined with {@link ReportsCrashes#mailTo()}.
+ * {@link org.acra.annotation.ReportsCrashes#customReportContent()}. Crash
+ * receiving mailbox has to be defined with {@link ReportsCrashes#mailTo()}.
  */
 public class EmailIntentSender implements ReportSender {
 
-    private final Context mContext;
+	private final Context mContext;
 
-    public EmailIntentSender(Context ctx) {
-        mContext = ctx;
-    }
+	public EmailIntentSender(Context ctx) {
+		mContext = ctx;
+	}
 
-    @Override
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException {
+	@Override
+	public void send(Context context, CrashReportData errorContent)
+			throws ReportSenderException {
 
-        final String subject = mContext.getPackageName() + " Crash Report";
-        final String body = buildBody(errorContent);
+		final String subject = mContext.getPackageName() + " Crash Report";
+		final String body = buildBody(errorContent);
 
-        final Intent emailIntent = new Intent(android.content.Intent.ACTION_SENDTO);
-        emailIntent.setData(Uri.fromParts("mailto", ACRA.getConfig().mailTo(), null));
-        emailIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
-        emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, body);
-        mContext.startActivity(emailIntent);
-    }
+		final Intent emailIntent = new Intent(
+				android.content.Intent.ACTION_SENDTO);
+		emailIntent.setData(Uri.fromParts("mailto", ACRA.getConfig().mailTo(),
+				null));
+		emailIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+		emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
+		emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, body);
+		mContext.startActivity(emailIntent);
+	}
 
-    private String buildBody(CrashReportData errorContent) {
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if(fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
-        }
+	private String buildBody(CrashReportData errorContent) {
+		ReportField[] fields = ACRA.getConfig().customReportContent();
+		if (fields.length == 0) {
+			fields = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
+		}
 
-        final StringBuilder builder = new StringBuilder();
-        for (ReportField field : fields) {
-            builder.append(field.toString()).append("=");
-            builder.append(errorContent.get(field));
-            builder.append('\n');
-        }
-        return builder.toString();
-    }
+		final StringBuilder builder = new StringBuilder();
+		for (ReportField field : fields) {
+			builder.append(field.toString()).append("=");
+			builder.append(errorContent.get(field));
+			builder.append('\n');
+		}
+		return builder.toString();
+	}
 }
diff --git a/src/main/java/org/acra/sender/HttpSender.java b/src/main/java/org/acra/sender/HttpSender.java
index 0579ccf0..95ff1800 100644
--- a/src/main/java/org/acra/sender/HttpSender.java
+++ b/src/main/java/org/acra/sender/HttpSender.java
@@ -22,7 +22,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import android.content.Context;
 import org.acra.ACRA;
 import org.acra.ACRAConfiguration;
 import org.acra.ACRAConstants;
@@ -32,6 +31,7 @@
 import org.acra.util.HttpRequest;
 import org.acra.util.JSONReportBuilder.JSONReportException;
 
+import android.content.Context;
 import android.net.Uri;
 
 /**
@@ -72,205 +72,221 @@
  */
 public class HttpSender implements ReportSender {
 
-    /**
-     * Available HTTP methods to send data. Only POST and PUT are currently
-     * supported.
-     */
-    public enum Method {
-        POST, PUT
-    }
+	/**
+	 * Available HTTP methods to send data. Only POST and PUT are currently
+	 * supported.
+	 */
+	public enum Method {
+		POST, PUT
+	}
+
+	/**
+	 * Type of report data encoding, currently supports Html Form encoding and
+	 * JSON.
+	 */
+	public enum Type {
+		/**
+		 * Send data as a www form encoded list of key/values.
+		 * 
+		 * @see <a
+		 *      href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">Form
+		 *      content types</a>
+		 */
+		FORM {
+			@Override
+			public String getContentType() {
+				return "application/x-www-form-urlencoded";
+			}
+		},
+		/**
+		 * Send data as a structured JSON tree.
+		 */
+		JSON {
+			@Override
+			public String getContentType() {
+				return "application/json";
+			}
+		};
 
-    /**
-     * Type of report data encoding, currently supports Html Form encoding and
-     * JSON.
-     */
-    public enum Type {
-        /**
-         * Send data as a www form encoded list of key/values.
-         * @see <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">Form content types</a>
-         */
-        FORM {
-            @Override
-            public String getContentType() {
-                return "application/x-www-form-urlencoded";
-            }
-        },
-        /**
-         * Send data as a structured JSON tree.
-         */
-        JSON {
-            @Override
-            public String getContentType() {
-                return "application/json";
-            }
-        };
+		public abstract String getContentType();
+	}
 
-        public abstract String getContentType();
-    }
+	private final Uri mFormUri;
+	private final Map<ReportField, String> mMapping;
+	private final Method mMethod;
+	private final Type mType;
+	private String mUsername;
+	private String mPassword;
 
-    private final Uri mFormUri;
-    private final Map<ReportField, String> mMapping;
-    private final Method mMethod;
-    private final Type mType;
-    private String mUsername;
-    private String mPassword;
+	/**
+	 * <p>
+	 * Create a new HttpSender instance with its destination taken from
+	 * {@link ACRA#getConfig()} dynamically. Configuration changes to the
+	 * formUri are applied automatically.
+	 * </p>
+	 * 
+	 * @param method
+	 *            HTTP {@link Method} to be used to send data. Currently only
+	 *            {@link Method#POST} and {@link Method#PUT} are available. If
+	 *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
+	 *            is appended to the formUri to be compliant with RESTful APIs.
+	 * 
+	 * @param type
+	 *            {@link Type} of encoding used to send the report body.
+	 *            {@link Type#FORM} is a simple Key/Value pairs list as defined
+	 *            by the application/x-www-form-urlencoded mime type.
+	 * 
+	 * @param mapping
+	 *            Applies only to {@link Method#POST} method parameter. If null,
+	 *            POST parameters will be named with {@link ReportField} values
+	 *            converted to String with .toString(). If not null, POST
+	 *            parameters will be named with the result of
+	 *            mapping.get(ReportField.SOME_FIELD);
+	 */
+	public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
+		mMethod = method;
+		mFormUri = null;
+		mMapping = mapping;
+		mType = type;
+		mUsername = null;
+		mPassword = null;
+	}
 
-    /**
-     * <p>
-     * Create a new HttpSender instance with its destination taken from
-     * {@link ACRA#getConfig()} dynamically. Configuration changes to the
-     * formUri are applied automatically.
-     * </p>
-     * 
-     * @param method
-     *            HTTP {@link Method} to be used to send data. Currently only
-     *            {@link Method#POST} and {@link Method#PUT} are available. If
-     *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
-     *            is appended to the formUri to be compliant with RESTful APIs.
-     * 
-     * @param type
-     *            {@link Type} of encoding used to send the report body.
-     *            {@link Type#FORM} is a simple Key/Value pairs list as defined
-     *            by the application/x-www-form-urlencoded mime type.
-     * 
-     * @param mapping
-     *            Applies only to {@link Method#POST} method parameter. If null,
-     *            POST parameters will be named with {@link ReportField} values
-     *            converted to String with .toString(). If not null, POST
-     *            parameters will be named with the result of
-     *            mapping.get(ReportField.SOME_FIELD);
-     */
-    public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
-        mMethod = method;
-        mFormUri = null;
-        mMapping = mapping;
-        mType = type;
-        mUsername = null;
-        mPassword = null;
-    }
+	/**
+	 * <p>
+	 * Create a new HttpPostSender instance with a fixed destination provided as
+	 * a parameter. Configuration changes to the formUri are not applied.
+	 * </p>
+	 * 
+	 * @param method
+	 *            HTTP {@link Method} to be used to send data. Currently only
+	 *            {@link Method#POST} and {@link Method#PUT} are available. If
+	 *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
+	 *            is appended to the formUri to be compliant with RESTful APIs.
+	 * 
+	 * @param type
+	 *            {@link Type} of encoding used to send the report body.
+	 *            {@link Type#FORM} is a simple Key/Value pairs list as defined
+	 *            by the application/x-www-form-urlencoded mime type.
+	 * @param formUri
+	 *            The URL of your server-side crash report collection script.
+	 * @param mapping
+	 *            Applies only to {@link Method#POST} method parameter. If null,
+	 *            POST parameters will be named with {@link ReportField} values
+	 *            converted to String with .toString(). If not null, POST
+	 *            parameters will be named with the result of
+	 *            mapping.get(ReportField.SOME_FIELD);
+	 */
+	public HttpSender(Method method, Type type, String formUri,
+			Map<ReportField, String> mapping) {
+		mMethod = method;
+		mFormUri = Uri.parse(formUri);
+		mMapping = mapping;
+		mType = type;
+		mUsername = null;
+		mPassword = null;
+	}
 
-    /**
-     * <p>
-     * Create a new HttpPostSender instance with a fixed destination provided as
-     * a parameter. Configuration changes to the formUri are not applied.
-     * </p>
-     * 
-     * @param method
-     *            HTTP {@link Method} to be used to send data. Currently only
-     *            {@link Method#POST} and {@link Method#PUT} are available. If
-     *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
-     *            is appended to the formUri to be compliant with RESTful APIs.
-     * 
-     * @param type
-     *            {@link Type} of encoding used to send the report body.
-     *            {@link Type#FORM} is a simple Key/Value pairs list as defined
-     *            by the application/x-www-form-urlencoded mime type.
-     * @param formUri
-     *            The URL of your server-side crash report collection script.
-     * @param mapping
-     *            Applies only to {@link Method#POST} method parameter. If null,
-     *            POST parameters will be named with {@link ReportField} values
-     *            converted to String with .toString(). If not null, POST
-     *            parameters will be named with the result of
-     *            mapping.get(ReportField.SOME_FIELD);
-     */
-    public HttpSender(Method method, Type type, String formUri, Map<ReportField, String> mapping) {
-        mMethod = method;
-        mFormUri = Uri.parse(formUri);
-        mMapping = mapping;
-        mType = type;
-        mUsername = null;
-        mPassword = null;        
-    }
-    
-    /**
-     * <p>
-     * Set credentials for this HttpSender that override (if present) the ones
-     * set globally.
-     * </p>
-     * 
-     * @param username
-     *            The username to set for HTTP Basic Auth.
-     * @param password
-     *            The password to set for HTTP Basic Auth.
-     */
-    @SuppressWarnings( "unused" )
-    public void setBasicAuth(String username, String password) {
-        mUsername = username;
-        mPassword = password;
-    }    
+	/**
+	 * <p>
+	 * Set credentials for this HttpSender that override (if present) the ones
+	 * set globally.
+	 * </p>
+	 * 
+	 * @param username
+	 *            The username to set for HTTP Basic Auth.
+	 * @param password
+	 *            The password to set for HTTP Basic Auth.
+	 */
+	@SuppressWarnings("unused")
+	public void setBasicAuth(String username, String password) {
+		mUsername = username;
+		mPassword = password;
+	}
 
-    @Override
-    public void send(Context context, CrashReportData report) throws ReportSenderException {
+	@Override
+	public void send(Context context, CrashReportData report)
+			throws ReportSenderException {
 
-        try {
-            URL reportUrl = mFormUri == null ? new URL(ACRA.getConfig().formUri()) : new URL(mFormUri.toString());
-            ACRA.log.d(LOG_TAG, "Connect to " + reportUrl.toString());
+		try {
+			URL reportUrl = mFormUri == null ? new URL(ACRA.getConfig()
+					.formUri()) : new URL(mFormUri.toString());
+			ACRA.log.d(LOG_TAG, "Connect to " + reportUrl.toString());
 
-            final String login = mUsername != null ? mUsername : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthLogin()) ? null : ACRA
-                    .getConfig().formUriBasicAuthLogin();
-            final String password = mPassword != null ? mPassword : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthPassword()) ? null : ACRA
-                    .getConfig().formUriBasicAuthPassword();
+			final String login = mUsername != null ? mUsername
+					: ACRAConfiguration.isNull(ACRA.getConfig()
+							.formUriBasicAuthLogin()) ? null : ACRA.getConfig()
+							.formUriBasicAuthLogin();
+			final String password = mPassword != null ? mPassword
+					: ACRAConfiguration.isNull(ACRA.getConfig()
+							.formUriBasicAuthPassword()) ? null : ACRA
+							.getConfig().formUriBasicAuthPassword();
 
-            final HttpRequest request = new HttpRequest();
-            request.setConnectionTimeOut(ACRA.getConfig().connectionTimeout());
-            request.setSocketTimeOut(ACRA.getConfig().socketTimeout());
-            request.setMaxNrRetries(ACRA.getConfig().maxNumberOfRequestRetries());
-            request.setLogin(login);
-            request.setPassword(password);
-            request.setHeaders(ACRA.getConfig().getHttpHeaders());
+			final HttpRequest request = new HttpRequest();
+			request.setConnectionTimeOut(ACRA.getConfig().connectionTimeout());
+			request.setSocketTimeOut(ACRA.getConfig().socketTimeout());
+			request.setMaxNrRetries(ACRA.getConfig()
+					.maxNumberOfRequestRetries());
+			request.setLogin(login);
+			request.setPassword(password);
+			request.setHeaders(ACRA.getConfig().getHttpHeaders());
 
-            // Generate report body depending on requested type
-            final String reportAsString;
-            switch (mType) {
-            case JSON:
-                reportAsString = report.toJSON().toString();
-                break;
-            case FORM:
-            default:
-                final Map<String, String> finalReport = remap(report);
-                reportAsString = HttpRequest.getParamsAsFormString(finalReport);
-                break;
+			// Generate report body depending on requested type
+			final String reportAsString;
+			switch (mType) {
+			case JSON:
+				reportAsString = report.toJSON().toString();
+				break;
+			case FORM:
+			default:
+				final Map<String, String> finalReport = remap(report);
+				reportAsString = HttpRequest.getParamsAsFormString(finalReport);
+				break;
 
-            }
+			}
 
-            // Adjust URL depending on method
-            switch (mMethod) {
-            case POST:
-                break;
-            case PUT:
-                reportUrl = new URL(reportUrl.toString() + '/' + report.getProperty(ReportField.REPORT_ID));
-                break;
-            default:
-                throw new UnsupportedOperationException("Unknown method: " + mMethod.name());
-            }
-            request.send(context, reportUrl, mMethod, reportAsString, mType);
+			// Adjust URL depending on method
+			switch (mMethod) {
+			case POST:
+				break;
+			case PUT:
+				reportUrl = new URL(reportUrl.toString() + '/'
+						+ report.getProperty(ReportField.REPORT_ID));
+				break;
+			default:
+				throw new UnsupportedOperationException("Unknown method: "
+						+ mMethod.name());
+			}
+			request.send(context, reportUrl, mMethod, reportAsString, mType);
 
-        } catch (IOException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
-                    + " report via Http " + mMethod.name(), e);
-        } catch (JSONReportException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
-                    + " report via Http " + mMethod.name(), e);
-        }
-    }
+		} catch (IOException e) {
+			throw new ReportSenderException("Error while sending "
+					+ ACRA.getConfig().reportType() + " report via Http "
+					+ mMethod.name(), e);
+		} catch (JSONReportException e) {
+			throw new ReportSenderException("Error while sending "
+					+ ACRA.getConfig().reportType() + " report via Http "
+					+ mMethod.name(), e);
+		}
+	}
 
-    private Map<String, String> remap(Map<ReportField, String> report) {
+	private Map<String, String> remap(Map<ReportField, String> report) {
 
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if (fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_REPORT_FIELDS;
-        }
+		ReportField[] fields = ACRA.getConfig().customReportContent();
+		if (fields.length == 0) {
+			fields = ACRAConstants.DEFAULT_REPORT_FIELDS;
+		}
 
-        final Map<String, String> finalReport = new HashMap<String, String>(report.size());
-        for (ReportField field : fields) {
-            if (mMapping == null || mMapping.get(field) == null) {
-                finalReport.put(field.toString(), report.get(field));
-            } else {
-                finalReport.put(mMapping.get(field), report.get(field));
-            }
-        }
-        return finalReport;
-    }
+		final Map<String, String> finalReport = new HashMap<String, String>(
+				report.size());
+		for (ReportField field : fields) {
+			if (mMapping == null || mMapping.get(field) == null) {
+				finalReport.put(field.toString(), report.get(field));
+			} else {
+				finalReport.put(mMapping.get(field), report.get(field));
+			}
+		}
+		return finalReport;
+	}
 
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/sender/ReportSender.java b/src/main/java/org/acra/sender/ReportSender.java
index 5271019c..4d1ba070 100644
--- a/src/main/java/org/acra/sender/ReportSender.java
+++ b/src/main/java/org/acra/sender/ReportSender.java
@@ -15,36 +15,39 @@
  */
 package org.acra.sender;
 
-import android.content.Context;
 import org.acra.collector.CrashReportData;
 
+import android.content.Context;
+
 /**
  * A simple interface for defining various crash report senders. You can reuse
  * {@link HttpSender} to send reports to your custom server-side report
  * collection script even if you expect (or prefer) specific names for each
- * report field as {@link HttpSender#send(Context, CrashReportData)}
- * can take a {@code Map<ReportField, String>} as an input to convert each field name to
+ * report field as {@link HttpSender#send(Context, CrashReportData)} can take a
+ * {@code Map<ReportField, String>} as an input to convert each field name to
  * your preferred POST parameter name.
  * 
  * @author Kevin Gaudin
  * 
  */
 public interface ReportSender {
-    /**
-     * Send crash report data. You don't have to take care of managing Threads,
-     * just implement what is necessary to handle the data. ACRA will use a
-     * specific Thread (not the UI Thread) to run your sender.
-     *
-     *
-     *
-     * @param context       Android Context in which to send the crash report.
-     * @param errorContent
-     *            Stores key/value pairs for each report field. A report field
-     *            is identified by a {@link org.acra.ReportField} enum value.
-     * @throws ReportSenderException
-     *             If anything goes fatally wrong during the handling of crash
-     *             data, you can (should) throw a {@link ReportSenderException}
-     *             with a custom message.
-     */
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException;
+	/**
+	 * Send crash report data. You don't have to take care of managing Threads,
+	 * just implement what is necessary to handle the data. ACRA will use a
+	 * specific Thread (not the UI Thread) to run your sender.
+	 *
+	 *
+	 *
+	 * @param context
+	 *            Android Context in which to send the crash report.
+	 * @param errorContent
+	 *            Stores key/value pairs for each report field. A report field
+	 *            is identified by a {@link org.acra.ReportField} enum value.
+	 * @throws ReportSenderException
+	 *             If anything goes fatally wrong during the handling of crash
+	 *             data, you can (should) throw a {@link ReportSenderException}
+	 *             with a custom message.
+	 */
+	public void send(Context context, CrashReportData errorContent)
+			throws ReportSenderException;
 }
diff --git a/src/main/java/org/acra/sender/ReportSenderException.java b/src/main/java/org/acra/sender/ReportSenderException.java
index b4c8cf44..aeb728d3 100644
--- a/src/main/java/org/acra/sender/ReportSenderException.java
+++ b/src/main/java/org/acra/sender/ReportSenderException.java
@@ -25,27 +25,27 @@
 @SuppressWarnings("serial")
 public class ReportSenderException extends Exception {
 
-    /**
-     * Creates a new {@link ReportSenderException} instance. You can provide a
-     * detailed message to explain what went wrong.
-     * 
-     * @param detailMessage
-     *            A message to explain the cause of this exception.
-     * @param throwable
-     *            An optional throwable which caused this Exception.
-     */
-    public ReportSenderException(String detailMessage, Throwable throwable) {
-        super(detailMessage, throwable);
-    }
+	/**
+	 * Creates a new {@link ReportSenderException} instance. You can provide a
+	 * detailed message to explain what went wrong.
+	 * 
+	 * @param detailMessage
+	 *            A message to explain the cause of this exception.
+	 * @param throwable
+	 *            An optional throwable which caused this Exception.
+	 */
+	public ReportSenderException(String detailMessage, Throwable throwable) {
+		super(detailMessage, throwable);
+	}
 
-    /**
-     * Creates a new {@link ReportSenderException} instance. You can provide a
-     * detailed message to explain what went wrong.
-     * 
-     * @param detailMessage
-     *            A message to explain the cause of this exception.
-     **/
-    public ReportSenderException(String detailMessage) {
-        super(detailMessage);
-    }
+	/**
+	 * Creates a new {@link ReportSenderException} instance. You can provide a
+	 * detailed message to explain what went wrong.
+	 * 
+	 * @param detailMessage
+	 *            A message to explain the cause of this exception.
+	 **/
+	public ReportSenderException(String detailMessage) {
+		super(detailMessage);
+	}
 }
diff --git a/src/main/java/org/acra/util/BoundedLinkedList.java b/src/main/java/org/acra/util/BoundedLinkedList.java
index fc50ec44..a9a24b30 100644
--- a/src/main/java/org/acra/util/BoundedLinkedList.java
+++ b/src/main/java/org/acra/util/BoundedLinkedList.java
@@ -30,101 +30,101 @@
 @SuppressWarnings("serial")
 public class BoundedLinkedList<E> extends LinkedList<E> {
 
-    private final int maxSize;
+	private final int maxSize;
 
-    public BoundedLinkedList(int maxSize) {
-        this.maxSize = maxSize;
-    }
+	public BoundedLinkedList(int maxSize) {
+		this.maxSize = maxSize;
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(java.lang.Object)
-     */
-    @Override
-    public boolean add(E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        return super.add(object);
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#add(java.lang.Object)
+	 */
+	@Override
+	public boolean add(E object) {
+		if (size() == maxSize) {
+			removeFirst();
+		}
+		return super.add(object);
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(int, java.lang.Object)
-     */
-    @Override
-    public void add(int location, E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        super.add(location, object);
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#add(int, java.lang.Object)
+	 */
+	@Override
+	public void add(int location, E object) {
+		if (size() == maxSize) {
+			removeFirst();
+		}
+		super.add(location, object);
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(java.util.Collection)
-     */
-    @Override
-    public boolean addAll(Collection<? extends E> collection) {
-        final int totalNeededSize = size() + collection.size();
-        final int overhead = totalNeededSize - maxSize;
-        if (overhead > 0) {
-            removeRange(0, overhead);
-        }
-        return super.addAll(collection);
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#addAll(java.util.Collection)
+	 */
+	@Override
+	public boolean addAll(Collection<? extends E> collection) {
+		final int totalNeededSize = size() + collection.size();
+		final int overhead = totalNeededSize - maxSize;
+		if (overhead > 0) {
+			removeRange(0, overhead);
+		}
+		return super.addAll(collection);
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(int, java.util.Collection)
-     */
-    @Override
-    public boolean addAll(int location, Collection<? extends E> collection) {
-        // int totalNeededSize = size() + collection.size();
-        // int overhead = totalNeededSize - maxSize;
-        // if(overhead > 0) {
-        // removeRange(0, overhead);
-        // }
-        // return super.addAll(location, collection);
-        throw new UnsupportedOperationException();
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#addAll(int, java.util.Collection)
+	 */
+	@Override
+	public boolean addAll(int location, Collection<? extends E> collection) {
+		// int totalNeededSize = size() + collection.size();
+		// int overhead = totalNeededSize - maxSize;
+		// if(overhead > 0) {
+		// removeRange(0, overhead);
+		// }
+		// return super.addAll(location, collection);
+		throw new UnsupportedOperationException();
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addFirst(java.lang.Object)
-     */
-    @Override
-    public void addFirst(E object) {
-        // super.addFirst(object);
-        throw new UnsupportedOperationException();
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#addFirst(java.lang.Object)
+	 */
+	@Override
+	public void addFirst(E object) {
+		// super.addFirst(object);
+		throw new UnsupportedOperationException();
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addLast(java.lang.Object)
-     */
-    @Override
-    public void addLast(E object) {
-        add(object);
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.LinkedList#addLast(java.lang.Object)
+	 */
+	@Override
+	public void addLast(E object) {
+		add(object);
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.AbstractCollection#toString()
-     */
-    @Override
-    public String toString() {
-        final StringBuilder result = new StringBuilder();
-        for (E object : this) {
-            result.append(object.toString());
-        }
-        return result.toString();
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see java.util.AbstractCollection#toString()
+	 */
+	@Override
+	public String toString() {
+		final StringBuilder result = new StringBuilder();
+		for (E object : this) {
+			result.append(object.toString());
+		}
+		return result.toString();
+	}
 }
diff --git a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
index c5b69bb3..8fdda4b7 100644
--- a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
+++ b/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
@@ -1,18 +1,19 @@
 package org.acra.util;
 
-import android.content.Context;
 import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.conn.ssl.SSLSocketFactory;
+
+import android.content.Context;
 
 /**
  * Default implementation of a HttpSocketFactoryFactory.
  */
-public final class DefaultHttpsSocketFactoryFactory implements HttpsSocketFactoryFactory {
+public final class DefaultHttpsSocketFactoryFactory implements
+		HttpsSocketFactoryFactory {
 
-    public static final HttpsSocketFactoryFactory INSTANCE = new DefaultHttpsSocketFactoryFactory();
+	public static final HttpsSocketFactoryFactory INSTANCE = new DefaultHttpsSocketFactoryFactory();
 
-    @Override
-    public SocketFactory create(Context context) {
-        return new TlsSniSocketFactory();
-    }
+	@Override
+	public SocketFactory create(Context context) {
+		return new TlsSniSocketFactory();
+	}
 }
diff --git a/src/main/java/org/acra/util/FakeSocketFactory.java b/src/main/java/org/acra/util/FakeSocketFactory.java
index 73b9a5c2..f5f53a34 100644
--- a/src/main/java/org/acra/util/FakeSocketFactory.java
+++ b/src/main/java/org/acra/util/FakeSocketFactory.java
@@ -3,76 +3,86 @@
  */
 package org.acra.util;
 
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.TrustManager;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Socket;
 
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.TrustManager;
+
+import org.apache.http.conn.scheme.LayeredSocketFactory;
+import org.apache.http.conn.scheme.SocketFactory;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+
 public class FakeSocketFactory implements SocketFactory, LayeredSocketFactory {
 
-    private SSLContext sslcontext = null;
-
-    private static SSLContext createEasySSLContext() throws IOException {
-        try {
-            final SSLContext context = SSLContext.getInstance("TLS");
-            context.init(null, new TrustManager[] { new NaiveTrustManager() }, null);
-            return context;
-        } catch (Exception e) {
-            throw new IOException(e.getMessage());
-        }
-    }
-
-    private SSLContext getSSLContext() throws IOException {
-        if (this.sslcontext == null) {
-            this.sslcontext = createEasySSLContext();
-        }
-        return this.sslcontext;
-    }
-
-    @Override
-    public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        final int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
-        final int soTimeout = HttpConnectionParams.getSoTimeout(params);
-
-        final InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
-        final SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());
-
-        if ((localAddress != null) || (localPort > 0)) {
-            // we need to bind explicitly
-            if (localPort < 0) {
-                localPort = 0; // indicates "any"
-            }
-            final InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
-            sslsock.bind(isa);
-        }
-
-        sslsock.connect(remoteAddress, connTimeout);
-        sslsock.setSoTimeout(soTimeout);
-
-        return sslsock;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return getSSLContext().getSocketFactory().createSocket();
-    }
-
-    @Override
-    public boolean isSecure(Socket arg0) throws IllegalArgumentException {
-        return true;
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
-        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
+	private SSLContext sslcontext = null;
+
+	private static SSLContext createEasySSLContext() throws IOException {
+		try {
+			final SSLContext context = SSLContext.getInstance("TLS");
+			context.init(null, new TrustManager[] { new NaiveTrustManager() },
+					null);
+			return context;
+		} catch (Exception e) {
+			throw new IOException(e.getMessage());
+		}
+	}
+
+	private SSLContext getSSLContext() throws IOException {
+		if (this.sslcontext == null) {
+			this.sslcontext = createEasySSLContext();
+		}
+		return this.sslcontext;
+	}
+
+	@Override
+	public Socket connectSocket(Socket sock, String host, int port,
+			InetAddress localAddress, int localPort, HttpParams params)
+			throws IOException {
+		final int connTimeout = HttpConnectionParams
+				.getConnectionTimeout(params);
+		final int soTimeout = HttpConnectionParams.getSoTimeout(params);
+
+		final InetSocketAddress remoteAddress = new InetSocketAddress(host,
+				port);
+		final SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock
+				: createSocket());
+
+		if ((localAddress != null) || (localPort > 0)) {
+			// we need to bind explicitly
+			if (localPort < 0) {
+				localPort = 0; // indicates "any"
+			}
+			final InetSocketAddress isa = new InetSocketAddress(localAddress,
+					localPort);
+			sslsock.bind(isa);
+		}
+
+		sslsock.connect(remoteAddress, connTimeout);
+		sslsock.setSoTimeout(soTimeout);
+
+		return sslsock;
+	}
+
+	@Override
+	public Socket createSocket() throws IOException {
+		return getSSLContext().getSocketFactory().createSocket();
+	}
+
+	@Override
+	public boolean isSecure(Socket arg0) throws IllegalArgumentException {
+		return true;
+	}
+
+	@Override
+	public Socket createSocket(Socket socket, String host, int port,
+			boolean autoClose) throws IOException {
+		return getSSLContext().getSocketFactory().createSocket(socket, host,
+				port, autoClose);
+	}
 
 }
diff --git a/src/main/java/org/acra/util/HttpRequest.java b/src/main/java/org/acra/util/HttpRequest.java
index 20b5133e..ea5e853b 100644
--- a/src/main/java/org/acra/util/HttpRequest.java
+++ b/src/main/java/org/acra/util/HttpRequest.java
@@ -5,6 +5,8 @@
  */
 package org.acra.util;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.SocketTimeoutException;
@@ -16,7 +18,6 @@
 import java.security.UnrecoverableKeyException;
 import java.util.Map;
 
-import android.content.Context;
 import org.acra.ACRA;
 import org.acra.sender.HttpSender.Method;
 import org.acra.sender.HttpSender.Type;
@@ -47,273 +48,331 @@
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.util.EntityUtils;
 
-import static org.acra.ACRA.LOG_TAG;
+import android.content.Context;
 
 public final class HttpRequest {
 
-    private static class SocketTimeOutRetryHandler implements HttpRequestRetryHandler {
-
-        private final HttpParams httpParams;
-        private final int maxNrRetries;
-
-        /**
-         * @param httpParams
-         *            HttpParams that will be used in the HttpRequest.
-         * @param maxNrRetries
-         *            Max number of times to retry Request on failure due to
-         *            SocketTimeOutException.
-         */
-        private SocketTimeOutRetryHandler(HttpParams httpParams, int maxNrRetries) {
-            this.httpParams = httpParams;
-            this.maxNrRetries = maxNrRetries;
-        }
-
-        @Override
-        public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-            if (exception instanceof SocketTimeoutException) {
-                if (executionCount <= maxNrRetries) {
-
-                    if (httpParams != null) {
-                        final int newSocketTimeOut = HttpConnectionParams.getSoTimeout(httpParams) * 2;
-                        HttpConnectionParams.setSoTimeout(httpParams, newSocketTimeOut);
-                        ACRA.log.d(LOG_TAG, "SocketTimeOut - increasing time out to " + newSocketTimeOut
-                                + " millis and trying again");
-                    } else {
-                        ACRA.log.d(LOG_TAG,
-                                "SocketTimeOut - no HttpParams, cannot increase time out. Trying again with current settings");
-                    }
-
-                    return true;
-                }
-
-                ACRA.log.d(LOG_TAG, "SocketTimeOut but exceeded max number of retries : " + maxNrRetries);
-            }
-
-            return false; // To change body of implemented methods use File |
-                          // Settings | File Templates.
-        }
-    }
-
-    private String login;
-    private String password;
-    private int connectionTimeOut = 3000;
-    private int socketTimeOut = 3000;
-    private int maxNrRetries = 3;
-    private Map<String,String> headers;
-    
-    public void setLogin(String login) {
-        this.login = login;
-    }
-
-    public void setPassword(String password) {
-        this.password = password;
-    }
-
-    public void setConnectionTimeOut(int connectionTimeOut) {
-        this.connectionTimeOut = connectionTimeOut;
-    }
-
-    public void setSocketTimeOut(int socketTimeOut) {
-        this.socketTimeOut = socketTimeOut;
-    }
-
-    public void setHeaders(Map<String,String> headers) {
-       this.headers = headers;
-    }
-
-    
-    /**
-     * The default number of retries is 3.
-     * 
-     * @param maxNrRetries
-     *            Max number of times to retry Request on failure due to
-     *            SocketTimeOutException.
-     */
-    public void setMaxNrRetries(int maxNrRetries) {
-        this.maxNrRetries = maxNrRetries;
-    }
-
-    /**
-     * Posts to a URL.
-     * 
-     *
-     * @param context   Android context for which to create the SocketFactory.
-     * @param url       URL to which to post.
-     * @param content   Map of parameters to post to a URL.
-     * @throws IOException if the data cannot be posted.
-     */
-    public void send(Context context, URL url, Method method, String content, Type type) throws IOException {
-
-        final HttpClient httpClient = getHttpClient(context);
-        final HttpEntityEnclosingRequestBase httpRequest = getHttpRequest(url, method, content, type);
-
-        ACRA.log.d(LOG_TAG, "Sending request to " + url);
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(LOG_TAG, "Http " + method.name() + " content : ");
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(LOG_TAG, content);
-
-        HttpResponse response = null;
-        try {
-            response = httpClient.execute(httpRequest, new BasicHttpContext());
-            if (response != null) {
-                final StatusLine statusLine = response.getStatusLine();
-                if (statusLine != null) {
-                    final String statusCode = Integer.toString(response.getStatusLine().getStatusCode());
-    
-                    if (!statusCode.equals("409") // 409 return code means that the
-                                                  // report has been received
-                                                  // already. So we can discard it.
-                            && !statusCode.equals("403") // a 403 error code is an explicit data validation refusal
-                                                         // from the server. The request must not be repeated.
-                                                         // Discard it.
-                            && (statusCode.startsWith("4") || statusCode.startsWith("5"))) {
-                        if (ACRA.DEV_LOGGING) {
-                            ACRA.log.d(LOG_TAG, "Could not send HttpPost : " + httpRequest);
-                            ACRA.log.d(LOG_TAG, "HttpResponse Status : "
-                                    + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                            final String respContent = EntityUtils.toString(response.getEntity());
-                            ACRA.log.d(LOG_TAG,
-                                    "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-                        }
-                        throw new IOException("Host returned error code " + statusCode);
-                    }
-                }
-
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG, "HttpResponse Status : "
-                            + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                final String respContent = EntityUtils.toString(response.getEntity());
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG,
-                            "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-
-            } else {
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG, "HTTP no Response!!");
-            }
-        } finally {
-            if (response != null) {
+	private static class SocketTimeOutRetryHandler implements
+			HttpRequestRetryHandler {
+
+		private final HttpParams httpParams;
+		private final int maxNrRetries;
+
+		/**
+		 * @param httpParams
+		 *            HttpParams that will be used in the HttpRequest.
+		 * @param maxNrRetries
+		 *            Max number of times to retry Request on failure due to
+		 *            SocketTimeOutException.
+		 */
+		private SocketTimeOutRetryHandler(HttpParams httpParams,
+				int maxNrRetries) {
+			this.httpParams = httpParams;
+			this.maxNrRetries = maxNrRetries;
+		}
+
+		@Override
+		public boolean retryRequest(IOException exception, int executionCount,
+				HttpContext context) {
+			if (exception instanceof SocketTimeoutException) {
+				if (executionCount <= maxNrRetries) {
+
+					if (httpParams != null) {
+						final int newSocketTimeOut = HttpConnectionParams
+								.getSoTimeout(httpParams) * 2;
+						HttpConnectionParams.setSoTimeout(httpParams,
+								newSocketTimeOut);
+						ACRA.log.d(LOG_TAG,
+								"SocketTimeOut - increasing time out to "
+										+ newSocketTimeOut
+										+ " millis and trying again");
+					} else {
+						ACRA.log.d(
+								LOG_TAG,
+								"SocketTimeOut - no HttpParams, cannot increase time out. Trying again with current settings");
+					}
+
+					return true;
+				}
+
+				ACRA.log.d(LOG_TAG,
+						"SocketTimeOut but exceeded max number of retries : "
+								+ maxNrRetries);
+			}
+
+			return false; // To change body of implemented methods use File |
+							// Settings | File Templates.
+		}
+	}
+
+	private String login;
+	private String password;
+	private int connectionTimeOut = 3000;
+	private int socketTimeOut = 3000;
+	private int maxNrRetries = 3;
+	private Map<String, String> headers;
+
+	public void setLogin(String login) {
+		this.login = login;
+	}
+
+	public void setPassword(String password) {
+		this.password = password;
+	}
+
+	public void setConnectionTimeOut(int connectionTimeOut) {
+		this.connectionTimeOut = connectionTimeOut;
+	}
+
+	public void setSocketTimeOut(int socketTimeOut) {
+		this.socketTimeOut = socketTimeOut;
+	}
+
+	public void setHeaders(Map<String, String> headers) {
+		this.headers = headers;
+	}
+
+	/**
+	 * The default number of retries is 3.
+	 * 
+	 * @param maxNrRetries
+	 *            Max number of times to retry Request on failure due to
+	 *            SocketTimeOutException.
+	 */
+	public void setMaxNrRetries(int maxNrRetries) {
+		this.maxNrRetries = maxNrRetries;
+	}
+
+	/**
+	 * Posts to a URL.
+	 * 
+	 *
+	 * @param context
+	 *            Android context for which to create the SocketFactory.
+	 * @param url
+	 *            URL to which to post.
+	 * @param content
+	 *            Map of parameters to post to a URL.
+	 * @throws IOException
+	 *             if the data cannot be posted.
+	 */
+	public void send(Context context, URL url, Method method, String content,
+			Type type) throws IOException {
+
+		final HttpClient httpClient = getHttpClient(context);
+		final HttpEntityEnclosingRequestBase httpRequest = getHttpRequest(url,
+				method, content, type);
+
+		ACRA.log.d(LOG_TAG, "Sending request to " + url);
+		if (ACRA.DEV_LOGGING)
+			ACRA.log.d(LOG_TAG, "Http " + method.name() + " content : ");
+		if (ACRA.DEV_LOGGING)
+			ACRA.log.d(LOG_TAG, content);
+
+		HttpResponse response = null;
+		try {
+			response = httpClient.execute(httpRequest, new BasicHttpContext());
+			if (response != null) {
+				final StatusLine statusLine = response.getStatusLine();
+				if (statusLine != null) {
+					final String statusCode = Integer.toString(response
+							.getStatusLine().getStatusCode());
+
+					if (!statusCode.equals("409") // 409 return code means that
+													// the
+													// report has been received
+													// already. So we can
+													// discard it.
+							&& !statusCode.equals("403") // a 403 error code is
+															// an explicit data
+															// validation
+															// refusal
+															// from the server.
+															// The request must
+															// not be repeated.
+															// Discard it.
+							&& (statusCode.startsWith("4") || statusCode
+									.startsWith("5"))) {
+						if (ACRA.DEV_LOGGING) {
+							ACRA.log.d(LOG_TAG, "Could not send HttpPost : "
+									+ httpRequest);
+							ACRA.log.d(
+									LOG_TAG,
+									"HttpResponse Status : "
+											+ (statusLine != null ? statusLine
+													.getStatusCode()
+													: "NoStatusLine#noCode"));
+							final String respContent = EntityUtils
+									.toString(response.getEntity());
+							ACRA.log.d(
+									LOG_TAG,
+									"HttpResponse Content : "
+											+ respContent.substring(0, Math
+													.min(respContent.length(),
+															200)));
+						}
+						throw new IOException("Host returned error code "
+								+ statusCode);
+					}
+				}
+
+				if (ACRA.DEV_LOGGING)
+					ACRA.log.d(LOG_TAG, "HttpResponse Status : "
+							+ (statusLine != null ? statusLine.getStatusCode()
+									: "NoStatusLine#noCode"));
+				final String respContent = EntityUtils.toString(response
+						.getEntity());
+				if (ACRA.DEV_LOGGING)
+					ACRA.log.d(
+							LOG_TAG,
+							"HttpResponse Content : "
+									+ respContent.substring(0,
+											Math.min(respContent.length(), 200)));
+
+			} else {
+				if (ACRA.DEV_LOGGING)
+					ACRA.log.d(LOG_TAG, "HTTP no Response!!");
+			}
+		} finally {
+			if (response != null) {
 				response.getEntity().consumeContent();
 			}
-        }
-    }
-
-    /**
-     * @return HttpClient to use with this HttpRequest.
-     */
-    private HttpClient getHttpClient(Context context) {
-        final HttpParams httpParams = new BasicHttpParams();
-        httpParams.setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.RFC_2109);
-        HttpConnectionParams.setConnectionTimeout(httpParams, connectionTimeOut);
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeOut);
-        HttpConnectionParams.setSocketBufferSize(httpParams, 8192);
-
-        final SchemeRegistry registry = new SchemeRegistry();
-        registry.register(new Scheme("http", new PlainSocketFactory(), 80));
-        if (ACRA.getConfig().disableSSLCertValidation()) {
-            registry.register(new Scheme("https", (new FakeSocketFactory()), 443));
-        } else if (ACRA.getConfig().keyStore() != null) {
-            try {
-                SSLSocketFactory sf = new SSLSocketFactory(ACRA.getConfig().keyStore());
-                sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
-                registry.register(new Scheme("https", sf, 443));
-            } catch (KeyManagementException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (UnrecoverableKeyException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (NoSuchAlgorithmException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (KeyStoreException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            }
-        } else {
-            final HttpsSocketFactoryFactory factory = ACRA.getConfig().getHttpSocketFactoryFactory();
-            final SocketFactory socketFactory = factory.create(context);
-            registry.register(new Scheme("https", socketFactory, 443));
-        }
-
-        final ClientConnectionManager clientConnectionManager = new SingleClientConnManager(httpParams, registry);
-        final DefaultHttpClient httpClient = new DefaultHttpClient(clientConnectionManager, httpParams);
-
-        final HttpRequestRetryHandler retryHandler = new SocketTimeOutRetryHandler(httpParams, maxNrRetries);
-        httpClient.setHttpRequestRetryHandler(retryHandler);
-
-        return httpClient;
-    }
-
-    /**
-     * @return Credentials to use with this HttpRequest or null if no
-     *         credentials were supplied.
-     */
-    private UsernamePasswordCredentials getCredentials() {
-        if (login != null || password != null) {
-            return new UsernamePasswordCredentials(login, password);
-        }
-
-        return null;
-    }
-
-    private HttpEntityEnclosingRequestBase getHttpRequest(URL url, Method method, String content, Type type)
-            throws UnsupportedEncodingException, UnsupportedOperationException {
-
-        final HttpEntityEnclosingRequestBase httpRequest;
-        switch (method) {
-        case POST:
-            httpRequest = new HttpPost(url.toString());
-            break;
-        case PUT:
-            httpRequest = new HttpPut(url.toString());
-            break;
-        default:
-            throw new UnsupportedOperationException("Unknown method: " + method.name());
-        }
-
-        final UsernamePasswordCredentials creds = getCredentials();
-        if (creds != null) {
-            httpRequest.addHeader(BasicScheme.authenticate(creds, "UTF-8", false));
-        }
-        httpRequest.setHeader("User-Agent", "Android");
-        httpRequest
-                .setHeader("Accept",
-                        "text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
-        httpRequest.setHeader("Content-Type", type.getContentType());
-
-        if(headers != null) {
-            for (final String header : headers.keySet()) {
-              final String value = headers.get(header);
-              httpRequest.setHeader(header, value);
-           }
-        }
-        
-        httpRequest.setEntity(new StringEntity(content, "UTF-8"));
-
-        return httpRequest;
-    }
-
-    /**
-     * Converts a Map of parameters into a URL encoded Sting.
-     * 
-     * @param parameters
-     *            Map of parameters to convert.
-     * @return URL encoded String representing the parameters.
-     * @throws UnsupportedEncodingException
-     *             if one of the parameters couldn't be converted to UTF-8.
-     */
-    public static String getParamsAsFormString(Map<?, ?> parameters) throws UnsupportedEncodingException {
-
-        final StringBuilder dataBfr = new StringBuilder();
-        for (final Object key : parameters.keySet()) {
-            if (dataBfr.length() != 0) {
-                dataBfr.append('&');
-            }
-            final Object preliminaryValue = parameters.get(key);
-            final Object value = (preliminaryValue == null) ? "" : preliminaryValue;
-            dataBfr.append(URLEncoder.encode(key.toString(), "UTF-8"));
-            dataBfr.append('=');
-            dataBfr.append(URLEncoder.encode(value.toString(), "UTF-8"));
-        }
-
-        return dataBfr.toString();
-    }
+		}
+	}
+
+	/**
+	 * @return HttpClient to use with this HttpRequest.
+	 */
+	private HttpClient getHttpClient(Context context) {
+		final HttpParams httpParams = new BasicHttpParams();
+		httpParams.setParameter(ClientPNames.COOKIE_POLICY,
+				CookiePolicy.RFC_2109);
+		HttpConnectionParams
+				.setConnectionTimeout(httpParams, connectionTimeOut);
+		HttpConnectionParams.setSoTimeout(httpParams, socketTimeOut);
+		HttpConnectionParams.setSocketBufferSize(httpParams, 8192);
+
+		final SchemeRegistry registry = new SchemeRegistry();
+		registry.register(new Scheme("http", new PlainSocketFactory(), 80));
+		if (ACRA.getConfig().disableSSLCertValidation()) {
+			registry.register(new Scheme("https", (new FakeSocketFactory()),
+					443));
+		} else if (ACRA.getConfig().keyStore() != null) {
+			try {
+				SSLSocketFactory sf = new SSLSocketFactory(ACRA.getConfig()
+						.keyStore());
+				sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+				registry.register(new Scheme("https", sf, 443));
+			} catch (KeyManagementException e) {
+				registry.register(new Scheme("https", SSLSocketFactory
+						.getSocketFactory(), 443));
+			} catch (UnrecoverableKeyException e) {
+				registry.register(new Scheme("https", SSLSocketFactory
+						.getSocketFactory(), 443));
+			} catch (NoSuchAlgorithmException e) {
+				registry.register(new Scheme("https", SSLSocketFactory
+						.getSocketFactory(), 443));
+			} catch (KeyStoreException e) {
+				registry.register(new Scheme("https", SSLSocketFactory
+						.getSocketFactory(), 443));
+			}
+		} else {
+			final HttpsSocketFactoryFactory factory = ACRA.getConfig()
+					.getHttpSocketFactoryFactory();
+			final SocketFactory socketFactory = factory.create(context);
+			registry.register(new Scheme("https", socketFactory, 443));
+		}
+
+		final ClientConnectionManager clientConnectionManager = new SingleClientConnManager(
+				httpParams, registry);
+		final DefaultHttpClient httpClient = new DefaultHttpClient(
+				clientConnectionManager, httpParams);
+
+		final HttpRequestRetryHandler retryHandler = new SocketTimeOutRetryHandler(
+				httpParams, maxNrRetries);
+		httpClient.setHttpRequestRetryHandler(retryHandler);
+
+		return httpClient;
+	}
+
+	/**
+	 * @return Credentials to use with this HttpRequest or null if no
+	 *         credentials were supplied.
+	 */
+	private UsernamePasswordCredentials getCredentials() {
+		if (login != null || password != null) {
+			return new UsernamePasswordCredentials(login, password);
+		}
+
+		return null;
+	}
+
+	private HttpEntityEnclosingRequestBase getHttpRequest(URL url,
+			Method method, String content, Type type)
+			throws UnsupportedEncodingException, UnsupportedOperationException {
+
+		final HttpEntityEnclosingRequestBase httpRequest;
+		switch (method) {
+		case POST:
+			httpRequest = new HttpPost(url.toString());
+			break;
+		case PUT:
+			httpRequest = new HttpPut(url.toString());
+			break;
+		default:
+			throw new UnsupportedOperationException("Unknown method: "
+					+ method.name());
+		}
+
+		final UsernamePasswordCredentials creds = getCredentials();
+		if (creds != null) {
+			httpRequest.addHeader(BasicScheme.authenticate(creds, "UTF-8",
+					false));
+		}
+		httpRequest.setHeader("User-Agent", "Android");
+		httpRequest
+				.setHeader(
+						"Accept",
+						"text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
+		httpRequest.setHeader("Content-Type", type.getContentType());
+
+		if (headers != null) {
+			for (final String header : headers.keySet()) {
+				final String value = headers.get(header);
+				httpRequest.setHeader(header, value);
+			}
+		}
+
+		httpRequest.setEntity(new StringEntity(content, "UTF-8"));
+
+		return httpRequest;
+	}
+
+	/**
+	 * Converts a Map of parameters into a URL encoded Sting.
+	 * 
+	 * @param parameters
+	 *            Map of parameters to convert.
+	 * @return URL encoded String representing the parameters.
+	 * @throws UnsupportedEncodingException
+	 *             if one of the parameters couldn't be converted to UTF-8.
+	 */
+	public static String getParamsAsFormString(Map<?, ?> parameters)
+			throws UnsupportedEncodingException {
+
+		final StringBuilder dataBfr = new StringBuilder();
+		for (final Object key : parameters.keySet()) {
+			if (dataBfr.length() != 0) {
+				dataBfr.append('&');
+			}
+			final Object preliminaryValue = parameters.get(key);
+			final Object value = (preliminaryValue == null) ? ""
+					: preliminaryValue;
+			dataBfr.append(URLEncoder.encode(key.toString(), "UTF-8"));
+			dataBfr.append('=');
+			dataBfr.append(URLEncoder.encode(value.toString(), "UTF-8"));
+		}
+
+		return dataBfr.toString();
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
index 398975d1..347c98d1 100644
--- a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
+++ b/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
@@ -1,16 +1,18 @@
 package org.acra.util;
 
-import android.content.Context;
 import org.apache.http.conn.scheme.SocketFactory;
 
+import android.content.Context;
+
 /**
  * Factory that creates an instance of a Https SocketFactory.
  */
 public interface HttpsSocketFactoryFactory {
 
-    /**
-     * @param context   Android context for which to create the SocketFactory.
-     * @return SocketFactory that was created.
-     */
-    public SocketFactory create(Context context);
+	/**
+	 * @param context
+	 *            Android context for which to create the SocketFactory.
+	 * @return SocketFactory that was created.
+	 */
+	public SocketFactory create(Context context);
 }
diff --git a/src/main/java/org/acra/util/Installation.java b/src/main/java/org/acra/util/Installation.java
index 16921f38..40163b01 100644
--- a/src/main/java/org/acra/util/Installation.java
+++ b/src/main/java/org/acra/util/Installation.java
@@ -4,6 +4,8 @@
  */
 package org.acra.util;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -14,61 +16,65 @@
 
 import android.content.Context;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * <p>
- * Creates a file storing a UUID on the first application start. This UUID can then be used as a identifier of this
- * specific application installation.
+ * Creates a file storing a UUID on the first application start. This UUID can
+ * then be used as a identifier of this specific application installation.
  * </p>
  * 
  * <p>
- * This was taken from <a href="http://android-developers.blogspot.com/2011/03/identifying-app-installations.html"> the
- * android developers blog.</a>
+ * This was taken from <a href=
+ * "http://android-developers.blogspot.com/2011/03/identifying-app-installations.html"
+ * > the android developers blog.</a>
  * </p>
  */
 public class Installation {
 
-    private static String sID;
-    private static final String INSTALLATION = "ACRA-INSTALLATION";
+	private static String sID;
+	private static final String INSTALLATION = "ACRA-INSTALLATION";
 
-    public synchronized static String id(Context context) {
-        if (sID == null) {
-            final File installation = new File(context.getFilesDir(), INSTALLATION);
-            try {
-                if (!installation.exists()) {
-                    writeInstallationFile(installation);
-                }
-                sID = readInstallationFile(installation);
-            } catch (IOException e) {
-                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
-                return "Couldn't retrieve InstallationId";
-            } catch (RuntimeException e) {
-                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
-                return "Couldn't retrieve InstallationId";
-            }
-        }
-        return sID;
-    }
+	public synchronized static String id(Context context) {
+		if (sID == null) {
+			final File installation = new File(context.getFilesDir(),
+					INSTALLATION);
+			try {
+				if (!installation.exists()) {
+					writeInstallationFile(installation);
+				}
+				sID = readInstallationFile(installation);
+			} catch (IOException e) {
+				ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for "
+						+ context.getPackageName(), e);
+				return "Couldn't retrieve InstallationId";
+			} catch (RuntimeException e) {
+				ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for "
+						+ context.getPackageName(), e);
+				return "Couldn't retrieve InstallationId";
+			}
+		}
+		return sID;
+	}
 
-    private static String readInstallationFile(File installation) throws IOException {
-        final RandomAccessFile f = new RandomAccessFile(installation, "r");
-        final byte[] bytes = new byte[(int) f.length()];
-        try {
-            f.readFully(bytes);
-        } finally {
-            f.close();
-        }
-        return new String(bytes);
-    }
+	private static String readInstallationFile(File installation)
+			throws IOException {
+		final RandomAccessFile f = new RandomAccessFile(installation, "r");
+		final byte[] bytes = new byte[(int) f.length()];
+		try {
+			f.readFully(bytes);
+		} finally {
+			f.close();
+		}
+		return new String(bytes);
+	}
 
-    private static void writeInstallationFile(File installation) throws IOException {
-        final FileOutputStream out = new FileOutputStream(installation);
-        try {
-            final String id = UUID.randomUUID().toString();
-            out.write(id.getBytes());
-        } finally {
-            out.close();
-        }
-    }
+	private static void writeInstallationFile(File installation)
+			throws IOException {
+		final FileOutputStream out = new FileOutputStream(installation);
+		try {
+			final String id = UUID.randomUUID().toString();
+			out.write(id.getBytes());
+		} finally {
+			out.close();
+		}
+	}
 }
diff --git a/src/main/java/org/acra/util/JSONReportBuilder.java b/src/main/java/org/acra/util/JSONReportBuilder.java
index d0a19faa..04e5a9fb 100644
--- a/src/main/java/org/acra/util/JSONReportBuilder.java
+++ b/src/main/java/org/acra/util/JSONReportBuilder.java
@@ -1,5 +1,7 @@
 package org.acra.util;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.StringReader;
@@ -16,222 +18,233 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import static org.acra.ACRA.LOG_TAG;
-
 public class JSONReportBuilder {
-    /**
-     * <p>
-     * Create a JSONObject containing the whole report data with the most
-     * detailed possible structure depth. Fields are not just converted to a
-     * single key=value pair. If a value can be decomposed into subobjects, it
-     * is done.
-     * </p>
-     *
-     * <p>
-     * For example, a String containing:
-     *
-     * <pre>
-     * some.key.name1=value1
-     * some.key.name2=value2
-     * some.other=value3
-     * any.other.key=value4
-     * key.without.value5
-     * </pre>
-     *
-     * is converted to
-     *
-     * <pre>
-     * {
-     *   some : {
-     *     key : {
-     *       name1 : "value1",
-     *       name2 : "value2"
-     *     },
-     *     other : "value3"
-     *   },
-     *   any : {
-     *     other : {
-     *       key : "value4"
-     *     }
-     *   }
-     *   key.without.value : true
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param errorContent
-     *            The ACRA report data structure.
-     * @return A JSONObject containing all fields from the report converted to
-     *         JSON.
-     * @throws ReportSenderException
-     * @throws JSONReportException
-     */
-    public static JSONObject buildJSONReport(CrashReportData errorContent) throws JSONReportException {
-        JSONObject jsonReport = new JSONObject();
-        BufferedReader reader = null;
-        for (ReportField key : errorContent.keySet()) {
-            try {
-                // Each ReportField can be identified as a substructure and not
-                // a simple String value.
-                if (key.containsKeyValuePairs()) {
-                    JSONObject subObject = new JSONObject();
-                    String strContent = errorContent.getProperty(key);
-                    reader = new BufferedReader(new StringReader(strContent), 1024);
-                    String line = null;
-                    try {
-                        while ((line = reader.readLine()) != null) {
-                            addJSONFromProperty(subObject, line);
-                        }
-                    } catch (IOException e) {
-                        ACRA.log.e(LOG_TAG, "Error while converting " + key.name() + " to JSON.", e);
-                    }
-                    jsonReport.accumulate(key.name(), subObject);
-                } else {
-                    // This field is a simple String value, store it as it is
-                    jsonReport.accumulate(key.name(), guessType(errorContent.getProperty(key)));
-                }
-            } catch (JSONException e) {
-                throw new JSONReportException("Could not create JSON object for key " + key, e);
-            } finally {
-            	CollectorUtil.safeClose(reader);
-            }
-        }
-        return jsonReport;
-    }
+	/**
+	 * <p>
+	 * Create a JSONObject containing the whole report data with the most
+	 * detailed possible structure depth. Fields are not just converted to a
+	 * single key=value pair. If a value can be decomposed into subobjects, it
+	 * is done.
+	 * </p>
+	 *
+	 * <p>
+	 * For example, a String containing:
+	 *
+	 * <pre>
+	 * some.key.name1=value1
+	 * some.key.name2=value2
+	 * some.other=value3
+	 * any.other.key=value4
+	 * key.without.value5
+	 * </pre>
+	 *
+	 * is converted to
+	 *
+	 * <pre>
+	 * {
+	 *   some : {
+	 *     key : {
+	 *       name1 : "value1",
+	 *       name2 : "value2"
+	 *     },
+	 *     other : "value3"
+	 *   },
+	 *   any : {
+	 *     other : {
+	 *       key : "value4"
+	 *     }
+	 *   }
+	 *   key.without.value : true
+	 * }
+	 * </pre>
+	 *
+	 * </p>
+	 *
+	 * @param errorContent
+	 *            The ACRA report data structure.
+	 * @return A JSONObject containing all fields from the report converted to
+	 *         JSON.
+	 * @throws ReportSenderException
+	 * @throws JSONReportException
+	 */
+	public static JSONObject buildJSONReport(CrashReportData errorContent)
+			throws JSONReportException {
+		JSONObject jsonReport = new JSONObject();
+		BufferedReader reader = null;
+		for (ReportField key : errorContent.keySet()) {
+			try {
+				// Each ReportField can be identified as a substructure and not
+				// a simple String value.
+				if (key.containsKeyValuePairs()) {
+					JSONObject subObject = new JSONObject();
+					String strContent = errorContent.getProperty(key);
+					reader = new BufferedReader(new StringReader(strContent),
+							1024);
+					String line = null;
+					try {
+						while ((line = reader.readLine()) != null) {
+							addJSONFromProperty(subObject, line);
+						}
+					} catch (IOException e) {
+						ACRA.log.e(LOG_TAG,
+								"Error while converting " + key.name()
+										+ " to JSON.", e);
+					}
+					jsonReport.accumulate(key.name(), subObject);
+				} else {
+					// This field is a simple String value, store it as it is
+					jsonReport.accumulate(key.name(),
+							guessType(errorContent.getProperty(key)));
+				}
+			} catch (JSONException e) {
+				throw new JSONReportException(
+						"Could not create JSON object for key " + key, e);
+			} finally {
+				CollectorUtil.safeClose(reader);
+			}
+		}
+		return jsonReport;
+	}
 
-    /**
-     * <p>
-     * Given a String containing key=value pairs on each line, adds a detailed
-     * JSON structure to an existing JSONObject, reusing intermediate subobjects
-     * if available when keys are composed of a succession of subkeys delimited
-     * by dots.
-     * </p>
-     *
-     * <p>
-     * For example, adding the string "metrics.xdpi=160.0" to an object
-     * containing
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * results in
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0", "xdpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param destination
-     *            The JSONObject where the data must be inserted.
-     * @param propertyString
-     *            A string containing "some.key.name=Any value"
-     * @throws JSONException
-     */
-    private static void addJSONFromProperty(JSONObject destination, String propertyString) throws JSONException {
-        int equalsIndex = propertyString.indexOf('=');
-        if (equalsIndex > 0) {
-            JSONObject finalObject = destination;
-            String currentKey = propertyString.substring(0, equalsIndex).trim();
-            String currentValue = propertyString.substring(equalsIndex + 1).trim();
-            Object value = guessType(currentValue);
-            if(value instanceof String) {
-                value = ((String) value).replaceAll("\\\\n","\n");
-            }
-            String[] splitKey = currentKey.split("\\.");
-            if (splitKey.length > 1) {
-                addJSONSubTree(finalObject, splitKey, value);
-            } else {
-                finalObject.accumulate(currentKey, value);
-            }
-        } else {
-            destination.put(propertyString.trim(), true);
-        }
-    }
+	/**
+	 * <p>
+	 * Given a String containing key=value pairs on each line, adds a detailed
+	 * JSON structure to an existing JSONObject, reusing intermediate subobjects
+	 * if available when keys are composed of a succession of subkeys delimited
+	 * by dots.
+	 * </p>
+	 *
+	 * <p>
+	 * For example, adding the string "metrics.xdpi=160.0" to an object
+	 * containing
+	 *
+	 * <pre>
+	 * {
+	 *   "metrics" : { "ydpi" : "160.0"},
+	 *   "width" : "320",
+	 *   "height" : "533"
+	 * }
+	 * </pre>
+	 *
+	 * results in
+	 *
+	 * <pre>
+	 * {
+	 *   "metrics" : { "ydpi" : "160.0", "xdpi" : "160.0"},
+	 *   "width" : "320",
+	 *   "height" : "533"
+	 * }
+	 * </pre>
+	 *
+	 * </p>
+	 *
+	 * @param destination
+	 *            The JSONObject where the data must be inserted.
+	 * @param propertyString
+	 *            A string containing "some.key.name=Any value"
+	 * @throws JSONException
+	 */
+	private static void addJSONFromProperty(JSONObject destination,
+			String propertyString) throws JSONException {
+		int equalsIndex = propertyString.indexOf('=');
+		if (equalsIndex > 0) {
+			JSONObject finalObject = destination;
+			String currentKey = propertyString.substring(0, equalsIndex).trim();
+			String currentValue = propertyString.substring(equalsIndex + 1)
+					.trim();
+			Object value = guessType(currentValue);
+			if (value instanceof String) {
+				value = ((String) value).replaceAll("\\\\n", "\n");
+			}
+			String[] splitKey = currentKey.split("\\.");
+			if (splitKey.length > 1) {
+				addJSONSubTree(finalObject, splitKey, value);
+			} else {
+				finalObject.accumulate(currentKey, value);
+			}
+		} else {
+			destination.put(propertyString.trim(), true);
+		}
+	}
 
-    private static Object guessType(String value) {
-        if (value.equalsIgnoreCase("true"))
-            return true;
-        if (value.equalsIgnoreCase("false"))
-            return false;
+	private static Object guessType(String value) {
+		if (value.equalsIgnoreCase("true"))
+			return true;
+		if (value.equalsIgnoreCase("false"))
+			return false;
 
-        if (value.matches("(?:^|\\s)([1-9](?:\\d*|(?:\\d{0,2})(?:,\\d{3})*)(?:\\.\\d*[1-9])?|0?\\.\\d*[1-9]|0)(?:\\s|$)")) {
-            NumberFormat format = NumberFormat.getInstance(Locale.US);
-            try {
-                Number number = format.parse(value);
-                return number;
-            } catch (ParseException e) {
-                // never mind
-            }
-        }
-        return value;
-    }
+		if (value
+				.matches("(?:^|\\s)([1-9](?:\\d*|(?:\\d{0,2})(?:,\\d{3})*)(?:\\.\\d*[1-9])?|0?\\.\\d*[1-9]|0)(?:\\s|$)")) {
+			NumberFormat format = NumberFormat.getInstance(Locale.US);
+			try {
+				Number number = format.parse(value);
+				return number;
+			} catch (ParseException e) {
+				// never mind
+			}
+		}
+		return value;
+	}
 
-    /**
-     * Deep insert a value inside a JSONObject, reusing existing subobjects when
-     * available or creating them when necessary.
-     *
-     * @param destination
-     *            The JSONObject which receives the additional subitem.
-     * @param keys
-     *            An array containing the path keys leading to where the value
-     *            has to be inserted.
-     * @param value
-     *            The value to be inserted.
-     * @throws JSONException
-     */
-    private static void addJSONSubTree(JSONObject destination, String[] keys, Object value) throws JSONException {
-        for (int i = 0; i < keys.length; i++) {
-            String subKey = keys[i];
-            if (i < keys.length - 1) {
-                JSONObject intermediate = null;
-                if (destination.isNull(subKey)) {
-                    intermediate = new JSONObject();
-                    destination.accumulate(subKey, intermediate);
-                } else {
-                    Object target = destination.get(subKey);
-                    if (target instanceof JSONObject) {
-                        intermediate = destination.getJSONObject(subKey);
-                    } else if (target instanceof JSONArray) {
-                        // Unexpected JSONArray, see issue #186
-                        JSONArray wildCard = destination.getJSONArray(subKey);
-                        for (int j = 0; j < wildCard.length(); j++) {
-                            intermediate = wildCard.optJSONObject(j);
-                            if (intermediate != null) {
-                                // Found the original JSONObject we were looking for
-                                break;
-                            }
-                        }
-                    }
+	/**
+	 * Deep insert a value inside a JSONObject, reusing existing subobjects when
+	 * available or creating them when necessary.
+	 *
+	 * @param destination
+	 *            The JSONObject which receives the additional subitem.
+	 * @param keys
+	 *            An array containing the path keys leading to where the value
+	 *            has to be inserted.
+	 * @param value
+	 *            The value to be inserted.
+	 * @throws JSONException
+	 */
+	private static void addJSONSubTree(JSONObject destination, String[] keys,
+			Object value) throws JSONException {
+		for (int i = 0; i < keys.length; i++) {
+			String subKey = keys[i];
+			if (i < keys.length - 1) {
+				JSONObject intermediate = null;
+				if (destination.isNull(subKey)) {
+					intermediate = new JSONObject();
+					destination.accumulate(subKey, intermediate);
+				} else {
+					Object target = destination.get(subKey);
+					if (target instanceof JSONObject) {
+						intermediate = destination.getJSONObject(subKey);
+					} else if (target instanceof JSONArray) {
+						// Unexpected JSONArray, see issue #186
+						JSONArray wildCard = destination.getJSONArray(subKey);
+						for (int j = 0; j < wildCard.length(); j++) {
+							intermediate = wildCard.optJSONObject(j);
+							if (intermediate != null) {
+								// Found the original JSONObject we were looking
+								// for
+								break;
+							}
+						}
+					}
 
-                    if (intermediate == null) {
-                        ACRA.log.e(LOG_TAG, "Unknown json subtree type, see issue #186");
-                        // We should never get here, but if we do, drop this value to still send the report
-                        return;
-                    }
-                }
-                destination = intermediate;
-            } else {
-                destination.accumulate(subKey, value);
-            }
-        }
-    }
+					if (intermediate == null) {
+						ACRA.log.e(LOG_TAG,
+								"Unknown json subtree type, see issue #186");
+						// We should never get here, but if we do, drop this
+						// value to still send the report
+						return;
+					}
+				}
+				destination = intermediate;
+			} else {
+				destination.accumulate(subKey, value);
+			}
+		}
+	}
 
-    public static class JSONReportException extends Exception {
-        private static final long serialVersionUID = -694684023635442219L;
+	public static class JSONReportException extends Exception {
+		private static final long serialVersionUID = -694684023635442219L;
 
-        public JSONReportException(String message, Throwable e) {
-            super(message, e);
-        }
-    };
+		public JSONReportException(String message, Throwable e) {
+			super(message, e);
+		}
+	};
 }
diff --git a/src/main/java/org/acra/util/NaiveTrustManager.java b/src/main/java/org/acra/util/NaiveTrustManager.java
index 57746ecd..53a8871d 100644
--- a/src/main/java/org/acra/util/NaiveTrustManager.java
+++ b/src/main/java/org/acra/util/NaiveTrustManager.java
@@ -24,37 +24,37 @@
  * Accepts any certificate, ideal for self-signed certificates.
  */
 class NaiveTrustManager implements X509TrustManager {
-    /*
-     * (non-Javadoc)
-     * 
-     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
-     */
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-        return new X509Certificate[0];
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
+	 */
+	@Override
+	public X509Certificate[] getAcceptedIssuers() {
+		return new X509Certificate[0];
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkClientTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkClientTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * javax.net.ssl.X509TrustManager#checkClientTrusted(java.security.cert.
+	 * X509Certificate[], java.lang.String)
+	 */
+	@Override
+	public void checkClientTrusted(X509Certificate[] x509CertificateArray,
+			String string) throws CertificateException {
+	}
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkServerTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkServerTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * javax.net.ssl.X509TrustManager#checkServerTrusted(java.security.cert.
+	 * X509Certificate[], java.lang.String)
+	 */
+	@Override
+	public void checkServerTrusted(X509Certificate[] x509CertificateArray,
+			String string) throws CertificateException {
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/PackageManagerWrapper.java b/src/main/java/org/acra/util/PackageManagerWrapper.java
index cb9ab87c..30b84354 100644
--- a/src/main/java/org/acra/util/PackageManagerWrapper.java
+++ b/src/main/java/org/acra/util/PackageManagerWrapper.java
@@ -2,73 +2,84 @@
 
 import static org.acra.ACRA.LOG_TAG;
 
+import org.acra.ACRA;
+
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 
-import org.acra.ACRA;
-
 /**
- * Responsible for wrapping calls to PackageManager to ensure that they always complete without throwing RuntimeExceptions.
+ * Responsible for wrapping calls to PackageManager to ensure that they always
+ * complete without throwing RuntimeExceptions.
  * <p>
- *     Depending upon the state of the application it is possible that
- *     <ul>
- *         <li>Context has no PackageManager.</li>
- *         <li>PackageManager returned by Context throws RuntimeException("Package manager has died")
- *              because it cannot contact the remote PackageManager service.
- *         </li>
- *     </ul>
- *     I suspect that PackageManager death is caused during app installation.
- *     But we need to make ACRA bullet proof, so it's better to handle the condition safely so that the error report itself doesn't fail.
+ * Depending upon the state of the application it is possible that
+ * <ul>
+ * <li>Context has no PackageManager.</li>
+ * <li>PackageManager returned by Context throws
+ * RuntimeException("Package manager has died") because it cannot contact the
+ * remote PackageManager service.</li>
+ * </ul>
+ * I suspect that PackageManager death is caused during app installation. But we
+ * need to make ACRA bullet proof, so it's better to handle the condition safely
+ * so that the error report itself doesn't fail.
  * </p>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class PackageManagerWrapper {
 
-    private final Context context;
+	private final Context context;
 
-    public PackageManagerWrapper(Context context) {
-        this.context = context;
-    }
+	public PackageManagerWrapper(Context context) {
+		this.context = context;
+	}
 
-    /**
-     * @param permission    Manifest.permission to check whether it has been granted.
-     * @return true if the permission has been granted to the app, false if it hasn't been granted or the PackageManager could not be contacted.
-     */
-    public boolean hasPermission(String permission) {
-        final PackageManager pm = context.getPackageManager();
-        if (pm == null) {
-            return false;
-        }
+	/**
+	 * @param permission
+	 *            Manifest.permission to check whether it has been granted.
+	 * @return true if the permission has been granted to the app, false if it
+	 *         hasn't been granted or the PackageManager could not be contacted.
+	 */
+	public boolean hasPermission(String permission) {
+		final PackageManager pm = context.getPackageManager();
+		if (pm == null) {
+			return false;
+		}
 
-        try {
-            return pm.checkPermission(permission, context.getPackageName()) == PackageManager.PERMISSION_GRANTED;
-        } catch (RuntimeException e) {
-            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
-            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
-            return false;
-        }
-    }
+		try {
+			return pm.checkPermission(permission, context.getPackageName()) == PackageManager.PERMISSION_GRANTED;
+		} catch (RuntimeException e) {
+			// To catch RuntimeException("Package manager has died") that can
+			// occur on some version of Android,
+			// when the remote PackageManager is unavailable. I suspect this
+			// sometimes occurs when the App is being reinstalled.
+			return false;
+		}
+	}
 
-    /**
-     * @return PackageInfo for the current application or null if the PackageManager could not be contacted.
-     */
-    public PackageInfo getPackageInfo() {
-        final PackageManager pm = context.getPackageManager();
-        if (pm == null) {
-            return null;
-        }
+	/**
+	 * @return PackageInfo for the current application or null if the
+	 *         PackageManager could not be contacted.
+	 */
+	public PackageInfo getPackageInfo() {
+		final PackageManager pm = context.getPackageManager();
+		if (pm == null) {
+			return null;
+		}
 
-        try {
-            return pm.getPackageInfo(context.getPackageName(), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            ACRA.log.v(LOG_TAG, "Failed to find PackageInfo for current App : " + context.getPackageName());
-            return null;
-        } catch (RuntimeException e) {
-            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
-            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
-            return null;
-        }
-    }
+		try {
+			return pm.getPackageInfo(context.getPackageName(), 0);
+		} catch (PackageManager.NameNotFoundException e) {
+			ACRA.log.v(LOG_TAG, "Failed to find PackageInfo for current App : "
+					+ context.getPackageName());
+			return null;
+		} catch (RuntimeException e) {
+			// To catch RuntimeException("Package manager has died") that can
+			// occur on some version of Android,
+			// when the remote PackageManager is unavailable. I suspect this
+			// sometimes occurs when the App is being reinstalled.
+			return null;
+		}
+	}
 }
diff --git a/src/main/java/org/acra/util/ReflectionException.java b/src/main/java/org/acra/util/ReflectionException.java
index 16bb0e26..3a514146 100644
--- a/src/main/java/org/acra/util/ReflectionException.java
+++ b/src/main/java/org/acra/util/ReflectionException.java
@@ -3,9 +3,9 @@
 /**
  * Thrown when an error occurs during reflection.
  */
-public final class ReflectionException extends Exception  {
+public final class ReflectionException extends Exception {
 
-    public ReflectionException(String msg, Throwable th) {
-        super(msg, th);
-    }
+	public ReflectionException(String msg, Throwable th) {
+		super(msg, th);
+	}
 }
diff --git a/src/main/java/org/acra/util/ReflectionHelper.java b/src/main/java/org/acra/util/ReflectionHelper.java
index 6463e309..3d1ee0c9 100644
--- a/src/main/java/org/acra/util/ReflectionHelper.java
+++ b/src/main/java/org/acra/util/ReflectionHelper.java
@@ -5,16 +5,19 @@
  */
 public final class ReflectionHelper {
 
-    public Object create(String className) throws ReflectionException {
-        try {
-            final Class clazz = Class.forName(className);
-            return clazz.newInstance();
-        } catch (ClassNotFoundException e) {
-            throw new ReflectionException("Could not find class : " + className, e);
-        } catch (InstantiationException e) {
-            throw new ReflectionException("Could not instantiate class : " + className, e);
-        } catch (IllegalAccessException e) {
-            throw new ReflectionException("Could not access class : " + className, e);
-        }
-    }
+	public Object create(String className) throws ReflectionException {
+		try {
+			final Class clazz = Class.forName(className);
+			return clazz.newInstance();
+		} catch (ClassNotFoundException e) {
+			throw new ReflectionException(
+					"Could not find class : " + className, e);
+		} catch (InstantiationException e) {
+			throw new ReflectionException("Could not instantiate class : "
+					+ className, e);
+		} catch (IllegalAccessException e) {
+			throw new ReflectionException("Could not access class : "
+					+ className, e);
+		}
+	}
 }
diff --git a/src/main/java/org/acra/util/ReportUtils.java b/src/main/java/org/acra/util/ReportUtils.java
index 39684455..b8d385fb 100644
--- a/src/main/java/org/acra/util/ReportUtils.java
+++ b/src/main/java/org/acra/util/ReportUtils.java
@@ -1,5 +1,7 @@
 package org.acra.util;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import java.io.File;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
@@ -18,124 +20,134 @@
 import android.text.format.Time;
 import android.util.SparseArray;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * Responsible for providing base utilities used when constructing the report.
  * <p/>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class ReportUtils {
 
-    /**
-     * Calculates the free memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Number of bytes available.
-     */
-    public static long getAvailableInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long availableBlocks = stat.getAvailableBlocks();
-        return availableBlocks * blockSize;
-    }
+	/**
+	 * Calculates the free memory of the device. This is based on an inspection
+	 * of the filesystem, which in android devices is stored in RAM.
+	 *
+	 * @return Number of bytes available.
+	 */
+	public static long getAvailableInternalMemorySize() {
+		final File path = Environment.getDataDirectory();
+		final StatFs stat = new StatFs(path.getPath());
+		final long blockSize = stat.getBlockSize();
+		final long availableBlocks = stat.getAvailableBlocks();
+		return availableBlocks * blockSize;
+	}
+
+	/**
+	 * Calculates the total memory of the device. This is based on an inspection
+	 * of the filesystem, which in android devices is stored in RAM.
+	 *
+	 * @return Total number of bytes.
+	 */
+	public static long getTotalInternalMemorySize() {
+		final File path = Environment.getDataDirectory();
+		final StatFs stat = new StatFs(path.getPath());
+		final long blockSize = stat.getBlockSize();
+		final long totalBlocks = stat.getBlockCount();
+		return totalBlocks * blockSize;
+	}
 
-    /**
-     * Calculates the total memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Total number of bytes.
-     */
-    public static long getTotalInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long totalBlocks = stat.getBlockCount();
-        return totalBlocks * blockSize;
-    }
+	/**
+	 * Returns the DeviceId according to the TelephonyManager.
+	 *
+	 * @param context
+	 *            Context for the application being reported.
+	 * @return Returns the DeviceId according to the TelephonyManager or null if
+	 *         there is no TelephonyManager.
+	 */
+	public static String getDeviceId(Context context) {
+		try {
+			final TelephonyManager tm = (TelephonyManager) context
+					.getSystemService(Context.TELEPHONY_SERVICE);
+			return tm.getDeviceId();
+		} catch (RuntimeException e) {
+			ACRA.log.w(
+					LOG_TAG,
+					"Couldn't retrieve DeviceId for : "
+							+ context.getPackageName(), e);
+			return null;
+		}
+	}
 
-    /**
-     * Returns the DeviceId according to the TelephonyManager.
-     *
-     * @param context   Context for the application being reported.
-     * @return Returns the DeviceId according to the TelephonyManager or null if there is no TelephonyManager.
-     */
-    public static String getDeviceId(Context context) {
-        try {
-            final TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-            return tm.getDeviceId();
-        } catch (RuntimeException e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceId for : " + context.getPackageName(), e);
-            return null;
-        }
-    }
+	public static String getApplicationFilePath(Context context) {
+		final File filesDir = context.getFilesDir();
+		if (filesDir != null) {
+			return filesDir.getAbsolutePath();
+		}
 
-    public static String getApplicationFilePath(Context context) {
-        final File filesDir = context.getFilesDir();
-        if (filesDir != null) {
-            return filesDir.getAbsolutePath();
-        }
+		ACRA.log.w(LOG_TAG, "Couldn't retrieve ApplicationFilePath for : "
+				+ context.getPackageName());
+		return "Couldn't retrieve ApplicationFilePath";
+	}
 
-        ACRA.log.w(LOG_TAG, "Couldn't retrieve ApplicationFilePath for : " + context.getPackageName());
-        return "Couldn't retrieve ApplicationFilePath";
-    }
-    
-    /**
-     * Utility method used for debugging purposes, writes the content of a SparseArray to a String.
-     * @param sparseArray
-     * @return "{ key1 => value1, key2 => value2, ...}"
-     */
-    public static String sparseArrayToString(SparseArray<?> sparseArray) {
-        StringBuilder result = new StringBuilder();
-        if (sparseArray == null) {
-            return "null";
-        }
+	/**
+	 * Utility method used for debugging purposes, writes the content of a
+	 * SparseArray to a String.
+	 * 
+	 * @param sparseArray
+	 * @return "{ key1 => value1, key2 => value2, ...}"
+	 */
+	public static String sparseArrayToString(SparseArray<?> sparseArray) {
+		StringBuilder result = new StringBuilder();
+		if (sparseArray == null) {
+			return "null";
+		}
 
-        result.append('{');
-        for (int i = 0; i < sparseArray.size(); i++) {
-            result.append(sparseArray.keyAt(i));
-            result.append(" => ");
-            if (sparseArray.valueAt(i) == null) {
-                result.append("null");
-            } else {
-                result.append(sparseArray.valueAt(i).toString());
-            }
-            if(i < sparseArray.size() - 1) {
-                result.append(", ");
-            }
-        }
-        result.append('}');
-        return result.toString();
-    }
+		result.append('{');
+		for (int i = 0; i < sparseArray.size(); i++) {
+			result.append(sparseArray.keyAt(i));
+			result.append(" => ");
+			if (sparseArray.valueAt(i) == null) {
+				result.append("null");
+			} else {
+				result.append(sparseArray.valueAt(i).toString());
+			}
+			if (i < sparseArray.size() - 1) {
+				result.append(", ");
+			}
+		}
+		result.append('}');
+		return result.toString();
+	}
 
-    public static String getLocalIpAddress() {
-        StringBuilder result = new StringBuilder();
-        boolean first = true;
-        try {
-            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
-                NetworkInterface intf = en.nextElement();
-                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
-                    InetAddress inetAddress = enumIpAddr.nextElement();
-                    if (!inetAddress.isLoopbackAddress()) {
-                        if(!first) {
-                            result.append('\n');
-                        }
-                        result.append(inetAddress.getHostAddress().toString());
-                        first = false;
-                    }
-                }
-            }
-        } catch (SocketException ex) {
-            ACRA.log.w(LOG_TAG, ex.toString());
-        }
-        return result.toString();
-    }
+	public static String getLocalIpAddress() {
+		StringBuilder result = new StringBuilder();
+		boolean first = true;
+		try {
+			for (Enumeration<NetworkInterface> en = NetworkInterface
+					.getNetworkInterfaces(); en.hasMoreElements();) {
+				NetworkInterface intf = en.nextElement();
+				for (Enumeration<InetAddress> enumIpAddr = intf
+						.getInetAddresses(); enumIpAddr.hasMoreElements();) {
+					InetAddress inetAddress = enumIpAddr.nextElement();
+					if (!inetAddress.isLoopbackAddress()) {
+						if (!first) {
+							result.append('\n');
+						}
+						result.append(inetAddress.getHostAddress().toString());
+						first = false;
+					}
+				}
+			}
+		} catch (SocketException ex) {
+			ACRA.log.w(LOG_TAG, ex.toString());
+		}
+		return result.toString();
+	}
 
-    public static String getTimeString(Time time)
-    {
-        SimpleDateFormat format = new SimpleDateFormat(ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
-        return format.format(time.toMillis(true));
-    }
+	public static String getTimeString(Time time) {
+		SimpleDateFormat format = new SimpleDateFormat(
+				ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
+		return format.format(time.toMillis(true));
+	}
 }
diff --git a/src/main/java/org/acra/util/TlsSniSocketFactory.java b/src/main/java/org/acra/util/TlsSniSocketFactory.java
index 262d26a4..40bae626 100644
--- a/src/main/java/org/acra/util/TlsSniSocketFactory.java
+++ b/src/main/java/org/acra/util/TlsSniSocketFactory.java
@@ -7,16 +7,6 @@
  */
 package org.acra.util;
 
-import android.annotation.TargetApi;
-import android.net.SSLCertificateSocketFactory;
-import android.os.Build;
-import android.text.TextUtils;
-
-import org.acra.ACRA;
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.ssl.BrowserCompatHostnameVerifier;
-import org.apache.http.params.HttpParams;
-
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.net.InetAddress;
@@ -32,171 +22,212 @@
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 
+import org.acra.ACRA;
+import org.apache.http.conn.scheme.LayeredSocketFactory;
+import org.apache.http.conn.ssl.BrowserCompatHostnameVerifier;
+import org.apache.http.params.HttpParams;
+
+import android.annotation.TargetApi;
+import android.net.SSLCertificateSocketFactory;
+import android.os.Build;
+import android.text.TextUtils;
+
 /**
  * Provides a SSLSocketFactory that is able to use SNI for SSL connections and
  * therefore allows multiple SSL servers on one IP address.<br/>
- *   1) socket = createSocket() is called
- *   2) reasonable encryption settings are applied to socket
- *   3) SNI is set up for socket
- *   4) handshake and certificate/host name verification
+ * 1) socket = createSocket() is called 2) reasonable encryption settings are
+ * applied to socket 3) SNI is set up for socket 4) handshake and
+ * certificate/host name verification
  * <p/>
+ * 
  * @author Philipp Kapfer
  * @since 4.6.0
  */
 public class TlsSniSocketFactory implements LayeredSocketFactory {
 
-    private static final String TAG =  TlsSniSocketFactory.class.getSimpleName();
-    
-    private final static int VERSION_CODES_JELLY_BEAN_MR1 = 17;
-    private final static int VERSION_CODES_LOLLIPOP = 21;
-    
-    private final SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getDefault(0);
-
-    // use BrowserCompatHostnameVerifier to allow IP addresses in the Common Name
-    private final static HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
-
-    private static final List<String> ALLOWED_CIPHERS = Arrays.asList(
-        // allowed secure ciphers according to NIST.SP.800-52r1.pdf Section 3.3.1 (see http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r1.pdf)
-        // TLS 1.2
-        "TLS_RSA_WITH_AES_256_GCM_SHA384",
-        "TLS_RSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256",
-        // maximum interoperability
-        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_RSA_WITH_AES_128_CBC_SHA",
-        // additionally
-        "TLS_RSA_WITH_AES_256_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
-    );
-
-    // Plain TCP/IP (layer below TLS)
-
-    @Override
-    public Socket connectSocket(Socket s, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        return null;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return null;
-    }
-
-    @Override
-    public boolean isSecure(Socket s) throws IllegalArgumentException {
-        return (s instanceof SSLSocket) && s.isConnected();
-    }
-
-
-    // TLS layer
-
-    @Override
-    public Socket createSocket(Socket plainSocket, String host, int port, boolean autoClose) throws IOException {
-        if (autoClose) {
-            // we don't need the plainSocket
-            plainSocket.close();
-        }
-
-        // create and connect SSL socket, but don't do hostname/certificate verification yet
-        final SSLSocket ssl = (SSLSocket) sslSocketFactory.createSocket(InetAddress.getByName(host), port);
-
-        // establish and verify TLS connection
-        establishAndVerify(ssl, host);
-
-        return ssl;
-    }
-    
-    /**
-     * Establishes and verifies a TLS connection to a (TCP-)connected SSLSocket:
-     *   - set TLS parameters like allowed protocols and ciphers
-     *   - set SNI host name
-     *   - verify host name
-     *   - verify certificate
-     * @param socket    unconnected SSLSocket
-     * @param host      host name for SNI
-     * @throws IOException if the connection could not be established.
-     */
-    private void establishAndVerify(SSLSocket socket, String host) throws IOException {
-        setTlsParameters(socket);
-        setSniHostname(socket, host);
-        
-        // TLS handshake, throws an exception for untrusted certificates
-        socket.startHandshake();
-
-        // verify hostname and certificate
-        SSLSession session = socket.getSession();
-        if (!hostnameVerifier.verify(host, session)) {
-            // throw exception for invalid host names
-            throw new SSLPeerUnverifiedException(host);
-        }
-
-        ACRA.log.i(TAG, "Established " + session.getProtocol() + " connection with " + session.getPeerHost() + " using " + session.getCipherSuite());
-    }
-    
-    /**
-     * Prepares a TLS/SSL connection socket by:
-     *   - setting reasonable TLS protocol versions
-     *   - setting reasonable cipher suites (if required)
-     * @param socket   unconnected SSLSocket to prepare
-     */
-    private void setTlsParameters(SSLSocket socket) {
-        // Android 5.0+ (API level21) provides reasonable default settings
-        // but it still allows SSLv3
-        // https://developer.android.com/about/versions/android-5.0-changes.html#ssl
-
-        /* set reasonable protocol versions */
-        // - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android <5.0)
-        // - remove all SSL versions (especially SSLv3) because they're insecure now
-        final List<String> protocols = new LinkedList<String>();
-        for (String protocol : socket.getSupportedProtocols()) {
-            if (!protocol.toUpperCase().contains("SSL")) {
-                protocols.add(protocol);
-            }
-        }
-        ACRA.log.v(TAG, "Setting allowed TLS protocols: " + TextUtils.join(", ", protocols));
-        socket.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));
-
-        /* set reasonable cipher suites */
-        if (Build.VERSION.SDK_INT < VERSION_CODES_LOLLIPOP) {
-            // choose secure cipher suites
-
-            final List<String> availableCiphers = Arrays.asList(socket.getSupportedCipherSuites());
-            
-            // preferred ciphers = allowed Ciphers \ availableCiphers
-            final Set<String> preferredCiphers = new HashSet<String>(ALLOWED_CIPHERS);
-            preferredCiphers.retainAll(availableCiphers);
-            
-            // add enabled ciphers to preferred ciphers
-            // for maximum security, preferred ciphers should *replace* enabled ciphers,
-            // but for the security level of ACRA, disabling of insecure
-            // ciphers should be a server-side task
-            preferredCiphers.addAll(Arrays.asList(socket.getEnabledCipherSuites()));
-            
-            ACRA.log.v(TAG, "Setting allowed TLS ciphers: " + TextUtils.join(", ", preferredCiphers));
-            socket.setEnabledCipherSuites(preferredCiphers.toArray(new String[preferredCiphers.size()]));
-        }
-    }
-    
-    @TargetApi(VERSION_CODES_JELLY_BEAN_MR1)
-    private void setSniHostname(SSLSocket socket, String hostName) {
-        // set SNI host name
-        if (Build.VERSION.SDK_INT >= VERSION_CODES_JELLY_BEAN_MR1) {
-            ACRA.log.d(TAG, "Using documented SNI with host name " + hostName);
-            sslSocketFactory.setHostname(socket, hostName);
-        } else {
-            ACRA.log.d(TAG, "No documented SNI support on Android <4.2, trying reflection method with host name " + hostName);
-            try {
-                final Method setHostnameMethod = socket.getClass().getMethod("setHostname", String.class);
-                setHostnameMethod.invoke(socket, hostName);
-            } catch (Exception e) {
-                ACRA.log.w(TAG, "SNI not usable", e);
-            }
-        }
-    }
+	private static final String TAG = TlsSniSocketFactory.class.getSimpleName();
+
+	private final static int VERSION_CODES_JELLY_BEAN_MR1 = 17;
+	private final static int VERSION_CODES_LOLLIPOP = 21;
+
+	private final SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory
+			.getDefault(0);
+
+	// use BrowserCompatHostnameVerifier to allow IP addresses in the Common
+	// Name
+	private final static HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
+
+	private static final List<String> ALLOWED_CIPHERS = Arrays.asList(
+			// allowed secure ciphers according to NIST.SP.800-52r1.pdf Section
+			// 3.3.1 (see
+			// http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r1.pdf)
+			// TLS 1.2
+			"TLS_RSA_WITH_AES_256_GCM_SHA384",
+			"TLS_RSA_WITH_AES_128_GCM_SHA256",
+			"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
+			"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
+			"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
+			"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
+			"TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256",
+			// maximum interoperability
+			"TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+			"TLS_RSA_WITH_AES_128_CBC_SHA",
+			// additionally
+			"TLS_RSA_WITH_AES_256_CBC_SHA",
+			"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
+			"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
+			"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
+			"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA");
+
+	// Plain TCP/IP (layer below TLS)
+
+	@Override
+	public Socket connectSocket(Socket s, String host, int port,
+			InetAddress localAddress, int localPort, HttpParams params)
+			throws IOException {
+		return null;
+	}
+
+	@Override
+	public Socket createSocket() throws IOException {
+		return null;
+	}
+
+	@Override
+	public boolean isSecure(Socket s) throws IllegalArgumentException {
+		return (s instanceof SSLSocket) && s.isConnected();
+	}
+
+	// TLS layer
+
+	@Override
+	public Socket createSocket(Socket plainSocket, String host, int port,
+			boolean autoClose) throws IOException {
+		if (autoClose) {
+			// we don't need the plainSocket
+			plainSocket.close();
+		}
+
+		// create and connect SSL socket, but don't do hostname/certificate
+		// verification yet
+		final SSLSocket ssl = (SSLSocket) sslSocketFactory.createSocket(
+				InetAddress.getByName(host), port);
+
+		// establish and verify TLS connection
+		establishAndVerify(ssl, host);
+
+		return ssl;
+	}
+
+	/**
+	 * Establishes and verifies a TLS connection to a (TCP-)connected SSLSocket:
+	 * - set TLS parameters like allowed protocols and ciphers - set SNI host
+	 * name - verify host name - verify certificate
+	 * 
+	 * @param socket
+	 *            unconnected SSLSocket
+	 * @param host
+	 *            host name for SNI
+	 * @throws IOException
+	 *             if the connection could not be established.
+	 */
+	private void establishAndVerify(SSLSocket socket, String host)
+			throws IOException {
+		setTlsParameters(socket);
+		setSniHostname(socket, host);
+
+		// TLS handshake, throws an exception for untrusted certificates
+		socket.startHandshake();
+
+		// verify hostname and certificate
+		SSLSession session = socket.getSession();
+		if (!hostnameVerifier.verify(host, session)) {
+			// throw exception for invalid host names
+			throw new SSLPeerUnverifiedException(host);
+		}
+
+		ACRA.log.i(TAG, "Established " + session.getProtocol()
+				+ " connection with " + session.getPeerHost() + " using "
+				+ session.getCipherSuite());
+	}
+
+	/**
+	 * Prepares a TLS/SSL connection socket by: - setting reasonable TLS
+	 * protocol versions - setting reasonable cipher suites (if required)
+	 * 
+	 * @param socket
+	 *            unconnected SSLSocket to prepare
+	 */
+	private void setTlsParameters(SSLSocket socket) {
+		// Android 5.0+ (API level21) provides reasonable default settings
+		// but it still allows SSLv3
+		// https://developer.android.com/about/versions/android-5.0-changes.html#ssl
+
+		/* set reasonable protocol versions */
+		// - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on
+		// Android <5.0)
+		// - remove all SSL versions (especially SSLv3) because they're insecure
+		// now
+		final List<String> protocols = new LinkedList<String>();
+		for (String protocol : socket.getSupportedProtocols()) {
+			if (!protocol.toUpperCase().contains("SSL")) {
+				protocols.add(protocol);
+			}
+		}
+		ACRA.log.v(
+				TAG,
+				"Setting allowed TLS protocols: "
+						+ TextUtils.join(", ", protocols));
+		socket.setEnabledProtocols(protocols.toArray(new String[protocols
+				.size()]));
+
+		/* set reasonable cipher suites */
+		if (Build.VERSION.SDK_INT < VERSION_CODES_LOLLIPOP) {
+			// choose secure cipher suites
+
+			final List<String> availableCiphers = Arrays.asList(socket
+					.getSupportedCipherSuites());
+
+			// preferred ciphers = allowed Ciphers \ availableCiphers
+			final Set<String> preferredCiphers = new HashSet<String>(
+					ALLOWED_CIPHERS);
+			preferredCiphers.retainAll(availableCiphers);
+
+			// add enabled ciphers to preferred ciphers
+			// for maximum security, preferred ciphers should *replace* enabled
+			// ciphers,
+			// but for the security level of ACRA, disabling of insecure
+			// ciphers should be a server-side task
+			preferredCiphers.addAll(Arrays.asList(socket
+					.getEnabledCipherSuites()));
+
+			ACRA.log.v(
+					TAG,
+					"Setting allowed TLS ciphers: "
+							+ TextUtils.join(", ", preferredCiphers));
+			socket.setEnabledCipherSuites(preferredCiphers
+					.toArray(new String[preferredCiphers.size()]));
+		}
+	}
+
+	@TargetApi(VERSION_CODES_JELLY_BEAN_MR1)
+	private void setSniHostname(SSLSocket socket, String hostName) {
+		// set SNI host name
+		if (Build.VERSION.SDK_INT >= VERSION_CODES_JELLY_BEAN_MR1) {
+			ACRA.log.d(TAG, "Using documented SNI with host name " + hostName);
+			sslSocketFactory.setHostname(socket, hostName);
+		} else {
+			ACRA.log.d(
+					TAG,
+					"No documented SNI support on Android <4.2, trying reflection method with host name "
+							+ hostName);
+			try {
+				final Method setHostnameMethod = socket.getClass().getMethod(
+						"setHostname", String.class);
+				setHostnameMethod.invoke(socket, hostName);
+			} catch (Exception e) {
+				ACRA.log.w(TAG, "SNI not usable", e);
+			}
+		}
+	}
 }
diff --git a/src/main/java/org/acra/util/ToastSender.java b/src/main/java/org/acra/util/ToastSender.java
index a8c952ae..3a8008aa 100644
--- a/src/main/java/org/acra/util/ToastSender.java
+++ b/src/main/java/org/acra/util/ToastSender.java
@@ -1,32 +1,38 @@
 package org.acra.util;
 
+import static org.acra.ACRA.LOG_TAG;
+
 import org.acra.ACRA;
 
 import android.content.Context;
 import android.widget.Toast;
 
-import static org.acra.ACRA.LOG_TAG;
-
 /**
  * Responsible for sending Toasts under all circumstances.
  * <p/>
+ * 
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class ToastSender {
 
-    /**
-     * Sends a Toast and ensures that any Exception thrown during sending is handled.
-     *
-     * @param context           Application context.
-     * @param toastResourceId   Id of the resource to send as the Toast message.
-     * @param toastLength       Length of the Toast.
-     */
-    public static void sendToast(Context context, int toastResourceId, int toastLength) {
-        try {
-            Toast.makeText(context, toastResourceId, toastLength).show();
-        } catch (RuntimeException e) {
-            ACRA.log.e(LOG_TAG, "Could not send crash Toast", e);
-        }
-    }
+	/**
+	 * Sends a Toast and ensures that any Exception thrown during sending is
+	 * handled.
+	 *
+	 * @param context
+	 *            Application context.
+	 * @param toastResourceId
+	 *            Id of the resource to send as the Toast message.
+	 * @param toastLength
+	 *            Length of the Toast.
+	 */
+	public static void sendToast(Context context, int toastResourceId,
+			int toastLength) {
+		try {
+			Toast.makeText(context, toastResourceId, toastLength).show();
+		} catch (RuntimeException e) {
+			ACRA.log.e(LOG_TAG, "Could not send crash Toast", e);
+		}
+	}
 }
