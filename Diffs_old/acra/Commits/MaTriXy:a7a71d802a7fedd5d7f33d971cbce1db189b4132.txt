diff --git a/.gitignore b/.gitignore
index 04a2dd73..7b0d30b9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,4 +5,8 @@ target
 pom.xml.releaseBackup
 release.properties
 *.iml
-*.idea/*
+.idea/
+build/
+local.properties
+.gradle
+acratest/
\ No newline at end of file
diff --git a/NOTICE b/NOTICE
index 97bd4cb3..dd203f43 100644
--- a/NOTICE
+++ b/NOTICE
@@ -3,5 +3,3 @@ Copyright (c) 2013 Kevin Gaudin
 http://acra.ch
 
 This product is licensed under the terms of the Apache Software License 2.0. See the LICENSE file for the full license text.
-
-This product includes software (package org.acra.jraf.android.util.activitylifecyclecallbackscompat) developed at JRAF, Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org), ASL 2.0.
diff --git a/README.md b/README.md
index 3a0e3d7d..f0bc8e1b 100644
--- a/README.md
+++ b/README.md
@@ -1,147 +1,46 @@
 [![Click here to lend your support to: ACRA - Application Crash Reports for Android and make a donation at www.pledgie.com !](https://pledgie.com/campaigns/18789.png?skin_name=chrome)](http://www.pledgie.com/campaigns/18789) [![Flattr this project](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=kevingaudin&url=http://acra.ch&title=ACRA%20-%20Application%20Crash%20Reports%20for%20Android&language=&tags=opensource%2Candroid&category=software&description=ACRA%20%28Application%20Crash%20Reports%20for%20Android%29%20is%20an%20open%20source%20android%20library%20for%20developers%2C%20enabling%20their%20apps%20to%20send%20detailed%20reports%20when%20they%20crash.)
 
-Please tell us how you use ACRA
-===============================
-
-In order to focus future developments on what is really important to you, please [take this survey](https://spreadsheets.google.com/viewform?hl=en&formkey=dDV5ek03OS1SOWNlZlBxNkFXbV9kSmc6MQ#gid=0)!
-
-You can view the survey results [here](https://spreadsheets.google.com/spreadsheet/viewanalytics?hl=en&formkey=dDV5ek03OS1SOWNlZlBxNkFXbV9kSmc6MQ).
-
-<a href="https://plus.google.com/118444843928759726538" rel="publisher">Follow ACRA on Google+ for latest news and tips.</a>
-
-[![](https://ssl.gstatic.com/images/icons/gplus-32.png)](https://plus.google.com/118444843928759726538)
-
 What is ACRA ?
 ==============
 
-ACRA is a library enabling Android Application to automatically post their crash reports to a GoogleDoc form. It is targetted to android applications developers to help them get data from their applications when they crash or behave erroneously.
+ACRA is a library enabling Android Application to automatically post their crash reports to a report server. It is targeted to android applications developers to help them get data from their applications when they crash or behave erroneously.
 
-ACRA is used in 2.76% ([See AppBrain/stats](http://www.appbrain.com/stats/libraries/details/acra/acra)) of all apps on Google Play as of Jan 2015. That's over 40M **apps** using ACRA. And since the average US user has 41 apps installed on their phone that means there is a 70% chance that ACRA is running on any phone. That means ACRA is running on over a **billion devices**.
+ACRA is used in 2.68% ([See AppBrain/stats](http://www.appbrain.com/stats/libraries/details/acra/acra)) of all apps on Google Play as of Feb 2016. That's over 53K **apps** using ACRA. And since the average US user has 41 apps installed on their phone that means there is a 70% chance that ACRA is running on any phone. That means ACRA is running on over a **billion devices**.
 
 See [BasicSetup](http://github.com/ACRA/acra/wiki/BasicSetup) for a step-by-step installation and usage guide.
 
 A crash reporting feature for android apps is native since Android 2.2 (FroYo) but only available through the official Android Market (and with limited data). ACRA is a great help for Android developers :
 
   * [developer configurable user interaction](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-User_Interaction): silent reports, Toast notification, status bar notification + dialog or direct dialog
-  * usable with ALL versions of android (compiled with 1.5, not tested on 1.0/1.1 but might work... but who does really care ?) and capable of retrieving data from latest versions through reflection.
+  * usable with ALL versions of Android from 2.2 onwards.
   * more [detailed crash reports](http://github.com/ACRA/acra/wiki/ReportContent) about the device running the app than what is displayed in the Android Market developer console error reports
   * you can [add your own variables content or debug traces](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Adding_your_own_variables_content_or_traces_in_crash_reports) to the reports
   * you can send [error reports even if the application doesn't crash](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Sending_reports_for_caught_exceptions)
-  * works for any application even if not delivered through Google's Android Market => great for devices/regions where the Android Market is not available, beta releases or for enterprise private apps
+  * works for any application even if not delivered through Google PLay => great for devices/regions where the Google Play is not available, beta releases or for enterprise private apps
   * if there is no network coverage, reports are kept and sent on a later application restart
   * can be used with [your own self-hosted report receiver script](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Reports_destination)
-  * google doc reports can be shared with a whole development team. Other benefits from the Google Docs platform are still to be investigated (stats, macros...)
 
-ACRA's notification systems are clean. If a crash occurs, your application does not add user notifications over existing system's crash notifications or reporting features. If you use the Toast, Status bar notification or direct dialog modes, the "force close" dialog is not displayed anymore and devices where the system native reporting feature is enabled do not offer the user to send an additional report.
+ACRA's notification systems are clean. If a crash occurs, your application does not add user notifications over existing system's crash notifications or reporting features. By default, the "force close" dialog is not displayed anymore, to enable it set `alsoReportToAndroidFramework` to `true`.
 
-The user is notified of an error only once, and you might enhance the percieved quality of your application by defining your own texts in the notifications/dialogs.
+The user is notified of an error only once, and you might enhance the perceived quality of your application by defining your own texts in the notifications/dialogs.
 
 Please do not hesitate to open defects/enhancements requests in [the issue tracker](http://github.com/ACRA/acra/issues).
 
-Change Log
-==========
-
-For a complete changelog, please see the [ChangeLog page](http://github.com/ACRA/acra/wiki/ChangeLog) in the Wiki.
-
-ACRA v4.6
-===============================
-
-The summarized changelog is here: https://github.com/ACRA/acra/wiki/ChangeLog
-
-Included in this release (summarized summary):
-- CustomReportDialog using @ReportCrashes#reportDialogClass (NB must extend from BaseCrashReportDialog).
-- many bugfixes
-
-ACRA v4.5 - enabling the future
-===============================
-
-**ACRA 4.5.0 is now the official stable version.**
-
-https://oss.sonatype.org/content/groups/public/ch/acra/acra/4.5.0/acra-4.5.0.zip
-(also available in Maven Central repository)
-
-The summarized changelog is here: https://github.com/ACRA/acra/wiki/ChangeLog
-
-Included in this release (summarized summary):
-- many bugfixes
-- no more exception thrown in ACRA.init() if called twice (widget developers will enjoy it)
-- HttpPostSender is renamed HttpSender and can send PUT and POST requests with data encoded as FORM (same as before) and JSON. The JSON mode enables a fully structured JSON tree to be sent to your backend.
-- Display configuration details can benefit of the newly introduced DisplayManager from Android 4.2
-- CrashReportDialog is now using AlertDialog.Builder to ensure that dialogs are created using the UX guidelines enforced by the android version. (you should remove its theme attribute in your manifest to benefit from the default theme of the device)
-- Ability to set Http Headers with `ACRAConfig.setHttpHeaders()`
-
-The most important part of this release is to enable the usage of Acralyzer (http://github.com/ACRA/acralyzer) which will be the default backend in future release.
-
-Next release will be 5.0 with important changes in mind:
-- no more default support of old Google Forms
-- use JSON as the default report storage and management mode (current implementation transforms flat data into JSON just before sending it)
-
-New ideas about the project are always welcome, you can open feature requests in the Github issue tracker.
-
+Latest version ACRA v4.10.0 - 13-JUN-2017
+===========================================
 
-ACRA v4.4 - enforcing security
-==============================
+**Note: Temporarily moved upload to `com.faendir:acra:4.10.0`, as all team members with repository access are absent**
 
-ACRA has been named in [this report](http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf) as a potential cause of SSL vulnerability for all android apps using it.
-
-The truth is that, in order to let devs use alternative backends over an SSL connection with self-signed certificates, I chose to disable certificate validation in earlier versions of the lib. But this was done only on the scope of ACRA reports senders. Using ACRA did not imply that your app became unsafe for all its SSL communications.
-
-Prior to ACRA v4.4.0, reports content were indeed vulnerable to a man in the middle attack. There "can" be some private data in there, but there are really few by default.
-
-ACRA v4.4.0 has been modified to use SSL certificate validation by default. If you send your reports to your own server via SSL with a self-signed certificate, you have to set the option `disableSSLCertValidation` to `true` (annotation or dynamic config).
-
-ACRA v4.3 is now STABLE
-=======================
-
-After 15 months of great service and more than 11700 downloads, it's time for v4.2.3 to bow out and live a new life among the deprecated releases.
-
-Here's what's new in ACRA 4.3.0:
-
-* cleaned, more stable code base, reducing reports duplicates (thanks to William Ferguson)
-* new experimental and long awaited **direct dialog** interaction mode, _without notifications_ (thanks to Julia Segal)
-* full **runtime configuration API**, required for projects using Android Library Projects since ADT14, and very handy for developers in need of dynamic ACRA configuration.
-* addition of a collector for a custom log file
-* addition of a collector for the details of the broken thread (id, name, groupname)
-* addition of a collector for the new MediaCodecList provided in the Jelly Bean API
-
-A more detailed description of the changes has been introduced in [this Google+ post](https://plus.google.com/b/118444843928759726538/118444843928759726538/posts/cnABXX7bbxV), based on the [ChangeLog](acra/wiki/ChangeLog).
-
-If you upgrade from 4.2.3, be aware that the default list of ReportFields has changed. You would better create a new spreadsheet & form with the help of the doc/CrashReports-Template.csv or use `@ReportsCrashes(customReportContent={...})` to redefine your own list of fields.
-
-Thanks a lot to everyone for testing during these 3 weeks of Beta (with special thanks to Nikolay Elenkov for his feedback on the dynamic configuration API), the 3 successive beta releases have reached 397 downloads on googlecode, not including Maven downloads. There has been very few reports during the Beta, a proof that you can rely on this new version even more than you could rely on the previous.
-
-About Maven. ACRA is now available on Maven Central, with 4.2.3 and 4.3.0 stable releases available on the central repository. Just note these IDs: groupId `ch.acra` artifactId `acra`.
-
-If you think there are missing parts in the documentation, please open an issue. 
-
-_Kevin_
-
-----
-
-ACRA v4.X main new features
-===========================
-
-You can read in the [ChangeLog](http://code.google.com/p/acra/acra/wiki/ChangeLog) that many things have been added since ACRA 3.1. Here is a summary:
-
-  * In addition to standard logcat data, reports can contain eventslog and radioevents data
-  * Reports will contain the result of the "`adb shell dumpsys meminfo <pid>`" command which gives details about your application memory usage right after the crash.
-  * Introduction of an abstraction layer for report senders. This allows to:
-    * use the `formUri` parameter to send reports to your custom server script with POST parameters names not related to Google Forms naming. POST parameters will have easy to understand names.
-    * introduce a new report sending mode: email (see below)
-    * create your own custom report senders. There is now a simple public interface allowing you to code your own class in charge of handling report data. Your sender(s) can be added to default senders or replace them.
-  * Reports can now be sent via email (through an `ACTION_SEND` intent so the user has to choose the email client he wants to use and then send the email containing report fields in the body). The list of report fields included is configurable. This allows to get rid of the `INTERNET` permission in apps where it does not make any sense.
-  * Custom report receiver server scripts can be secured with basic http authentication (login/password can be configured in ACRA)
-  * If the `READ_PHONE_STATE` permission is granted, reports include the Unique Device Identifier (IMEI). This can be really useful for enterprise applications deployment.
+For a complete changelog, please see the [ChangeLog page](http://github.com/ACRA/acra/wiki/ChangeLog) in the Wiki.
 
------
 
 And after that?
 ===============
 
 Now that ACRA is stabilized on the device side (there shouldn't be much more data required...), the effort should be placed on crash data analysis and reports management tools for developers.
 
-You can look at [some contributions](http://github.com/ACRA/acra/wiki/Contribs) that have already been published. Most of them are work in progress, so if you feel like joining the effort, please do!
+You can look at [some contributions](https://github.com/ACRA/acra/wiki/Backends) that have already been published.
 
-[Acralyzer](http://github.com/ACRA/acralyzer) will soon be the official backend for reports storage and analysis. It is a free and open source modern web app, based on a full open stack and using advanced
+[Acralyzer](http://github.com/ACRA/acralyzer) is the official backend for reports storage and analysis. It is a free and open source modern web app, based on a full open stack and using advanced
 technology like CouchDB (JSON document storage with a RESTful API and Map/Reduce querying), AngularJS (one of the most advanced client-side JS frameworks), D3JS (for data visualisation)... If you are interested
 in webapps development, this project can become your playground too ;-)
diff --git a/acra/build.gradle b/acra/build.gradle
new file mode 100644
index 00000000..f2941316
--- /dev/null
+++ b/acra/build.gradle
@@ -0,0 +1,194 @@
+apply plugin: 'com.android.library'
+apply plugin: 'signing'
+apply plugin: 'com.github.dcendents.android-maven'
+apply plugin: 'net.researchgate.release'
+apply plugin: 'com.jfrog.artifactory'
+
+android {
+    compileSdkVersion Integer.parseInt(androidVersion)
+    buildToolsVersion '25.0.2'
+
+    lintOptions {
+        abortOnError false
+    }
+
+    defaultConfig {
+        minSdkVersion 8
+        targetSdkVersion androidVersion
+        versionName version
+        consumerProguardFile proguardFile
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
+    }
+}
+
+dependencies {
+    compile "com.android.support:support-v4:$supportVersion"
+    compile "com.android.support:support-annotations:$supportVersion"
+    annotationProcessor project(':annotationprocessor')
+    provided project(':annotations')
+}
+
+/*
+*   How to oss upload:
+*
+*   Edit or create the file at ~/.gradle/gradle.properties and add
+* signing.keyId=<short ID of your key>
+* signing.password=<passphrase for your key>
+* signing.secretKeyRingFile=<path to your key ring>
+*   Optional, depending on upload destination
+* ossrhUser=<OSSRH user>
+* ossrhPassword=<OSSRH password>
+* artifactoryApiKey=<artifactory key>
+* artifactoryUser=<jfrog artifactory user>
+
+*   Then run for ossrh upload
+* gradlew release
+*
+*   Or for jfrog oss artifactory
+* gradlew artifactoryPublish
+*/
+
+release {
+    failOnUnversionedFiles = false
+    failOnCommitNeeded = true
+    tagTemplate = '$name-$version'
+    git {
+        requireBranch = "master"
+    }
+}
+
+afterReleaseBuild {
+    dependsOn rootProject.closeAndPromoteRepository
+}
+
+rootProject.closeRepository {
+    dependsOn uploadArchives
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    source += files('build/generated/source/aidl/release') + files('build/generated/source/buildConfig/release') + files('build/generated/source/apt/release')
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+afterEvaluate {
+    javadoc.classpath += files(android.libraryVariants.collect { variant ->
+        variant.javaCompile.classpath.files
+    })
+    javadoc.dependsOn generateReleaseSources
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc
+}
+
+artifacts {
+    archives javadocJar, sourcesJar
+}
+
+signing {
+    required { signing.hasProperty('keyId') }
+    sign configurations.archives
+}
+
+ext.createPom = { pom ->
+    pom.project {
+        name 'Application Crash Report for Android'
+        description 'Publishes a report of an Android application crash to an end point.'
+        packaging 'aar'
+        url 'http://acra.ch'
+
+        scm {
+            connection 'scm:git:https://github.com/ACRA/acra.git'
+            developerConnection 'scm:git:git@github.com:ACRA/acra.git'
+            url 'https://github.com/ACRA/acra.git'
+        }
+
+        licenses {
+            license {
+                name 'Apache 2'
+                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                distribution 'repo'
+            }
+        }
+
+        developers {
+            developer {
+                id = 'kevin.gaudin'
+                name = 'Kevin Gaudin'
+            }
+            developer {
+                id = 'william.ferguson'
+                name = 'William Ferguson'
+            }
+            developer {
+                id = 'f43nd1r'
+                name = 'Lukas Morawietz'
+            }
+        }
+    }
+}
+
+install {
+    repositories.mavenInstaller {
+        createPom(pom)
+    }
+}
+
+uploadArchives {
+    repositories {
+        mavenDeployer {
+            beforeDeployment { deployment -> signing.signPom(deployment) }
+            repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
+                authentication(userName: ossrhUser, password: ossrhPassword)
+            }
+            createPom(pom)
+        }
+    }
+}
+
+nexusStaging {
+    username = ossrhUser
+    password = ossrhPassword
+    packageGroup = group
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = version.endsWith('SNAPSHOT') ? 'oss-snapshot-local' : 'oss-release-local'
+            username = artifactoryUser
+            password = artifactoryApiKey
+            maven = true
+        }
+        defaults {
+            publishConfigs('archives')
+            publishPom = true
+            publishIvy = false
+        }
+    }
+    resolve {
+        repository {
+            repoKey = 'jcenter'
+            username = artifactoryUser
+            password = artifactoryApiKey
+        }
+    }
+}
+
+artifactoryPublish {
+    dependsOn javadocJar
+    dependsOn sourcesJar
+    dependsOn install
+}
diff --git a/acra/gradle.properties b/acra/gradle.properties
new file mode 100644
index 00000000..a4171a82
--- /dev/null
+++ b/acra/gradle.properties
@@ -0,0 +1,14 @@
+version=4.10.1-SNAPSHOT
+group=com.faendir
+archivesBaseName=acra
+androidVersion=24
+supportVersion=24.1.1
+proguardFile=src/main/proguard/proguard.cfg
+release.useAutomaticVersion=true
+ossrhUser=
+ossrhPassword=
+signing.keyId=
+signing.password=
+signing.secretKeyRingFile=
+artifactoryApiKey=
+artifactoryUser=
\ No newline at end of file
diff --git a/acra/src/main/AndroidManifest.xml b/acra/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..b94b34d0
--- /dev/null
+++ b/acra/src/main/AndroidManifest.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (c) 2017
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="ch.acra.acra">
+
+    <application>
+        <activity
+            android:name="org.acra.dialog.CrashReportDialog"
+            android:theme="@android:style/Theme.Dialog"
+            android:launchMode="singleInstance"
+            android:excludeFromRecents="true"
+            android:finishOnTaskLaunch="true"
+            android:process=":acra"/>
+
+        <service
+            android:name="org.acra.sender.SenderService"
+            android:exported="false"
+            android:process=":acra" />
+
+        <provider
+            android:authorities="${applicationId}.acra"
+            android:name="org.acra.attachment.AcraContentProvider"
+            android:exported="false"
+            android:process=":acra"
+            android:grantUriPermissions="true"/>
+    </application>
+</manifest>
\ No newline at end of file
diff --git a/src/main/assembly/distribution.xml b/acra/src/main/assembly/distribution.xml
similarity index 93%
rename from src/main/assembly/distribution.xml
rename to acra/src/main/assembly/distribution.xml
index f172fbb2..1ba2d60e 100644
--- a/src/main/assembly/distribution.xml
+++ b/acra/src/main/assembly/distribution.xml
@@ -1,51 +1,51 @@
-<assembly
-	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
-	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
-	<id>acra-distribution</id>
-	<formats>
-		<format>zip</format>
-	</formats>
-	<fileSets>
-		<fileSet>
-			<directory>${project.basedir}</directory>
-			<outputDirectory>/</outputDirectory>
-			<includes>
-				<include>LICENSE</include>
-				<include>NOTICE</include>
-			</includes>
-		</fileSet>
-		<fileSet>
-			<directory>${project.build.directory}</directory>
-			<outputDirectory>build</outputDirectory>
-			<includes>
-				<include>${project.build.finalName}.jar</include>
-			</includes>
-		</fileSet>
-		<fileSet>
-			<directory>${project.build.directory}</directory>
-			<outputDirectory>doc</outputDirectory>
-			<includes>
-				<include>${project.build.finalName}-javadoc.jar</include>
-			</includes>
-		</fileSet>
-		<fileSet>
-			<directory>${project.build.directory}</directory>
-			<outputDirectory>src</outputDirectory>
-			<includes>
-				<include>${project.build.finalName}-sources.jar</include>
-			</includes>
-		</fileSet>
-		<fileSet>
-			<directory>${project.basedir}/doc</directory>
-			<includes>
-				<include>CrashReports-Template.csv</include>
-			</includes>
-			<outputDirectory>doc</outputDirectory>
-		</fileSet>
-		<fileSet>
-			<directory>${project.build.directory}/apidocs</directory>
-			<outputDirectory>doc/html-javadoc</outputDirectory>
-		</fileSet>
-	</fileSets>
-</assembly>
+<assembly
+	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
+	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
+	<id>acra-distribution</id>
+	<formats>
+		<format>zip</format>
+	</formats>
+	<fileSets>
+		<fileSet>
+			<directory>${project.basedir}</directory>
+			<outputDirectory>/</outputDirectory>
+			<includes>
+				<include>LICENSE</include>
+				<include>NOTICE</include>
+			</includes>
+		</fileSet>
+		<fileSet>
+			<directory>${project.build.directory}</directory>
+			<outputDirectory>build</outputDirectory>
+			<includes>
+				<include>${project.build.finalName}.aar</include>
+			</includes>
+		</fileSet>
+		<fileSet>
+			<directory>${project.build.directory}</directory>
+			<outputDirectory>doc</outputDirectory>
+			<includes>
+				<include>${project.build.finalName}-javadoc.jar</include>
+			</includes>
+		</fileSet>
+		<fileSet>
+			<directory>${project.build.directory}</directory>
+			<outputDirectory>src</outputDirectory>
+			<includes>
+				<include>${project.build.finalName}-sources.jar</include>
+			</includes>
+		</fileSet>
+		<fileSet>
+			<directory>${project.basedir}/doc</directory>
+			<includes>
+				<include>CrashReports-Template.csv</include>
+			</includes>
+			<outputDirectory>doc</outputDirectory>
+		</fileSet>
+		<fileSet>
+			<directory>${project.build.directory}/apidocs</directory>
+			<outputDirectory>doc/html-javadoc</outputDirectory>
+		</fileSet>
+	</fileSets>
+</assembly>
diff --git a/src/main/build-config/sun_checks-modified.xml b/acra/src/main/build-config/sun_checks-modified.xml
similarity index 97%
rename from src/main/build-config/sun_checks-modified.xml
rename to acra/src/main/build-config/sun_checks-modified.xml
index c3a6d095..ac9ee293 100644
--- a/src/main/build-config/sun_checks-modified.xml
+++ b/acra/src/main/build-config/sun_checks-modified.xml
@@ -1,189 +1,189 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<!--
-
-  Checkstyle configuration that checks the sun coding conventions from:
-
-    - the Java Language Specification at
-      http://java.sun.com/docs/books/jls/second_edition/html/index.html
-
-    - the Sun Code Conventions at http://java.sun.com/docs/codeconv/
-
-    - the Javadoc guidelines at
-      http://java.sun.com/j2se/javadoc/writingdoccomments/index.html
-
-    - the JDK Api documentation http://java.sun.com/j2se/docs/api/index.html
-
-    - some best practices
-
-  Checkstyle is very configurable. Be sure to read the documentation at
-  http://checkstyle.sf.net (or in your downloaded distribution).
-
-  Most Checks are configurable, be sure to consult the documentation.
-
-  To completely disable a check, just comment it out or delete it from the file.
-
-  Finally, it is worth reading the documentation.
-
--->
-
-<module name="Checker">
-    <!--
-        If you set the basedir property below, then all reported file
-        names will be relative to the specified directory. See
-        http://checkstyle.sourceforge.net/5.x/config.html#Checker
-
-        <property name="basedir" value="${basedir}"/>
-    -->
-
-    <!-- Checks that each Java package has a Javadoc file used for commenting. -->
-    <!-- See http://checkstyle.sf.net/config_javadoc.html#JavadocPackage       -->
-    <module name="JavadocPackage">
-      <property name="allowLegacy" value="true"/>
-    </module>
-
-    <!-- Checks whether files end with a new line.                        -->
-    <!-- See http://checkstyle.sf.net/config_misc.html#NewlineAtEndOfFile -->
-    <module name="NewlineAtEndOfFile"/>
-
-    <!-- Checks that property files contain the same keys.         -->
-    <!-- See http://checkstyle.sf.net/config_misc.html#Translation -->
-    <module name="Translation"/>
-
-    <module name="FileLength"/>
-
-    <!-- Following interprets the header file as regular expressions. -->
-    <!-- <module name="RegexpHeader"/>                                -->
-
-    <module name="FileTabCharacter">
-        <property name="eachLine" value="true"/>
-    </module>
-
-    <module name="RegexpSingleline">
-        <!-- \s matches whitespace character, $ matches end of line. -->
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
-    </module>
-
-    <module name="TreeWalker">
-
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <module name="JavadocMethod"/>
-        <module name="JavadocType"/>
-        <module name="JavadocVariable"/>
-        <module name="JavadocStyle"/>
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <module name="ConstantName"/>
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for Headers                                -->
-        <!-- See http://checkstyle.sf.net/config_header.html   -->
-        <!-- <module name="Header">                            -->
-            <!-- The follow property value demonstrates the ability     -->
-            <!-- to have access to ANT properties. In this case it uses -->
-            <!-- the ${basedir} property to allow Checkstyle to be run  -->
-            <!-- from any directory within a project. See property      -->
-            <!-- expansion,                                             -->
-            <!-- http://checkstyle.sf.net/config.html#properties        -->
-            <!-- <property                                              -->
-            <!--     name="headerFile"                                  -->
-            <!--     value="${basedir}/java.header"/>                   -->
-        <!-- </module> -->
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-		    <property name="max" value="160"/>
-        </module>
-        <module name="MethodLength"/>
-        <module name="ParameterNumber"/>
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <module name="ModifierOrder"/>
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks"/>
-        <module name="EmptyBlock"/>
-        <module name="LeftCurly"/>
-        <module name="NeedBraces"/>
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <module name="AvoidInlineConditionals"/>
-        <module name="DoubleCheckedLocking"/>    <!-- MY FAVOURITE -->
-        <module name="EmptyStatement"/>
-        <module name="EqualsHashCode"/>
-        <module name="HiddenField"/>
-        <module name="IllegalInstantiation"/>
-        <module name="InnerAssignment"/>
-        <module name="MagicNumber"/>
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <module name="DesignForExtension"/>
-        <module name="FinalClass"/>
-        <module name="HideUtilityClassConstructor"/>
-        <module name="InterfaceIsType"/>
-        <module name="VisibilityModifier"/>
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <module name="ArrayTypeStyle"/>
-        <module name="FinalParameters"/>
-        <module name="TodoComment"/>
-        <module name="UpperEll"/>
-
-    </module>
-
-</module>
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<!--
+
+  Checkstyle configuration that checks the sun coding conventions from:
+
+    - the Java Language Specification at
+      http://java.sun.com/docs/books/jls/second_edition/html/index.html
+
+    - the Sun Code Conventions at http://java.sun.com/docs/codeconv/
+
+    - the Javadoc guidelines at
+      http://java.sun.com/j2se/javadoc/writingdoccomments/index.html
+
+    - the JDK Api documentation http://java.sun.com/j2se/docs/api/index.html
+
+    - some best practices
+
+  Checkstyle is very configurable. Be sure to read the documentation at
+  http://checkstyle.sf.net (or in your downloaded distribution).
+
+  Most Checks are configurable, be sure to consult the documentation.
+
+  To completely disable a check, just comment it out or delete it from the file.
+
+  Finally, it is worth reading the documentation.
+
+-->
+
+<module name="Checker">
+    <!--
+        If you set the basedir property below, then all reported file
+        names will be relative to the specified directory. See
+        http://checkstyle.sourceforge.net/5.x/config.html#Checker
+
+        <property name="basedir" value="${basedir}"/>
+    -->
+
+    <!-- Checks that each Java package has a Javadoc file used for commenting. -->
+    <!-- See http://checkstyle.sf.net/config_javadoc.html#JavadocPackage       -->
+    <module name="JavadocPackage">
+      <property name="allowLegacy" value="true"/>
+    </module>
+
+    <!-- Checks whether files end with a new line.                        -->
+    <!-- See http://checkstyle.sf.net/config_misc.html#NewlineAtEndOfFile -->
+    <module name="NewlineAtEndOfFile"/>
+
+    <!-- Checks that property files contain the same keys.         -->
+    <!-- See http://checkstyle.sf.net/config_misc.html#Translation -->
+    <module name="Translation"/>
+
+    <module name="FileLength"/>
+
+    <!-- Following interprets the header file as regular expressions. -->
+    <!-- <module name="RegexpHeader"/>                                -->
+
+    <module name="FileTabCharacter">
+        <property name="eachLine" value="true"/>
+    </module>
+
+    <module name="RegexpSingleline">
+        <!-- \s matches whitespace character, $ matches end of line. -->
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <module name="TreeWalker">
+
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <module name="JavadocMethod"/>
+        <module name="JavadocType"/>
+        <module name="JavadocVariable"/>
+        <module name="JavadocStyle"/>
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <module name="ConstantName"/>
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for Headers                                -->
+        <!-- See http://checkstyle.sf.net/config_header.html   -->
+        <!-- <module name="Header">                            -->
+            <!-- The follow property value demonstrates the ability     -->
+            <!-- to have access to ANT properties. In this case it uses -->
+            <!-- the ${basedir} property to allow Checkstyle to be run  -->
+            <!-- from any directory within a project. See property      -->
+            <!-- expansion,                                             -->
+            <!-- http://checkstyle.sf.net/config.html#properties        -->
+            <!-- <property                                              -->
+            <!--     name="headerFile"                                  -->
+            <!--     value="${basedir}/java.header"/>                   -->
+        <!-- </module> -->
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+		    <property name="max" value="160"/>
+        </module>
+        <module name="MethodLength"/>
+        <module name="ParameterNumber"/>
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <module name="ModifierOrder"/>
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <module name="AvoidNestedBlocks"/>
+        <module name="EmptyBlock"/>
+        <module name="LeftCurly"/>
+        <module name="NeedBraces"/>
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <module name="AvoidInlineConditionals"/>
+        <module name="DoubleCheckedLocking"/>    <!-- MY FAVOURITE -->
+        <module name="EmptyStatement"/>
+        <module name="EqualsHashCode"/>
+        <module name="HiddenField"/>
+        <module name="IllegalInstantiation"/>
+        <module name="InnerAssignment"/>
+        <module name="MagicNumber"/>
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <module name="DesignForExtension"/>
+        <module name="FinalClass"/>
+        <module name="HideUtilityClassConstructor"/>
+        <module name="InterfaceIsType"/>
+        <module name="VisibilityModifier"/>
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <module name="ArrayTypeStyle"/>
+        <module name="FinalParameters"/>
+        <module name="TodoComment"/>
+        <module name="UpperEll"/>
+
+    </module>
+
+</module>
diff --git a/acra/src/main/java/org/acra/ACRA.java b/acra/src/main/java/org/acra/ACRA.java
new file mode 100644
index 00000000..5a53edf8
--- /dev/null
+++ b/acra/src/main/java/org/acra/ACRA.java
@@ -0,0 +1,378 @@
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra;
+
+import android.app.Application;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.annotation.ReportsCrashes;
+import org.acra.config.ACRAConfiguration;
+import org.acra.config.ACRAConfigurationException;
+import org.acra.config.ConfigurationBuilder;
+import org.acra.legacy.LegacyFileHandler;
+import org.acra.log.ACRALog;
+import org.acra.log.AndroidLogDelegate;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.util.ApplicationStartupProcessor;
+import org.acra.util.IOUtils;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+
+/**
+ * Use this class to initialize the crash reporting feature using
+ * {@link #init(Application)} as soon as possible in your {@link Application}
+ * subclass {@link Application#onCreate()} method. Configuration items must have
+ * been set by using {@link ReportsCrashes} above the declaration of your
+ * {@link Application} subclass.
+ *
+ * @author Kevin Gaudin
+ *
+ */
+@SuppressWarnings({"WeakerAccess","unused"})
+public final class ACRA {
+    private ACRA(){}
+
+    public static /*non-final*/ boolean DEV_LOGGING = false; // Should be false for release.
+
+    public static final String LOG_TAG = ACRA.class.getSimpleName();
+
+    @NonNull
+    public static ACRALog log = new AndroidLogDelegate();
+
+    private static final String ACRA_PRIVATE_PROCESS_NAME= ":acra";
+
+    /**
+     * The key of the application default SharedPreference where you can put a
+     * 'true' Boolean value to disable ACRA.
+     */
+    public static final String PREF_DISABLE_ACRA = "acra.disable";
+
+    /**
+     * Alternatively, you can use this key if you prefer your users to have the
+     * checkbox ticked to enable crash reports. If both acra.disable and
+     * acra.enable are set, the value of acra.disable takes over the other.
+     */
+    public static final String PREF_ENABLE_ACRA = "acra.enable";
+
+    /**
+     * The key of the SharedPreference allowing the user to disable sending
+     * content of logcat/dropbox. System logs collection is also dependent of
+     * the READ_LOGS permission.
+     */
+    public static final String PREF_ENABLE_SYSTEM_LOGS = "acra.syslog.enable";
+
+    /**
+     * The key of the SharedPreference allowing the user to disable sending his
+     * device id. Device ID collection is also dependent of the READ_PHONE_STATE
+     * permission.
+     */
+    public static final String PREF_ENABLE_DEVICE_ID = "acra.deviceid.enable";
+
+    /**
+     * The key of the SharedPreference allowing the user to always include his
+     * email address.
+     */
+    public static final String PREF_USER_EMAIL_ADDRESS = "acra.user.email";
+
+    /**
+     * The key of the SharedPreference allowing the user to automatically accept
+     * sending reports.
+     */
+    public static final String PREF_ALWAYS_ACCEPT = "acra.alwaysaccept";
+
+    /**
+     * The version number of the application the last time ACRA was started.
+     * This is used to determine whether unsent reports should be discarded
+     * because they are old and out of date.
+     */
+    public static final String PREF_LAST_VERSION_NR = "acra.lastVersionNr";
+
+    private static Application mApplication;
+    @Nullable
+    private static ACRAConfiguration configProxy;
+
+    // Accessible via ACRA#getErrorReporter().
+    @Nullable
+    private static ErrorReporter errorReporterSingleton;
+
+    // NB don't convert to a local field because then it could be garbage
+    // collected and then we would have no PreferenceListener.
+    private static OnSharedPreferenceChangeListener mPrefListener; // TODO consider moving to ErrorReport so it doesn't need to be a static field.
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Uses the configuration as configured with the @ReportCrashes annotation.
+     * Sends any unsent reports.
+     * </p>
+     *
+     * @param app   Your Application class.
+     * @throws IllegalStateException if it is called more than once.
+     */
+    public static void init(@NonNull Application app) {
+        final ReportsCrashes reportsCrashes = app.getClass().getAnnotation(ReportsCrashes.class);
+        if (reportsCrashes == null) {
+            log.e(LOG_TAG, "ACRA#init(Application) called but no ReportsCrashes annotation on Application " + app.getPackageName());
+            return;
+        }
+        init(app, new ConfigurationBuilder(app));
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Uses the configuration as configured with the @ReportCrashes annotation.
+     * Sends any unsent reports.
+     * </p>
+     *
+     * @param app     Your Application class.
+     * @param builder ConfigurationBuilder to manually set up ACRA configuration.
+     */
+    public static void init(@NonNull Application app, @NonNull ConfigurationBuilder builder) {
+        init(app, builder, true);
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)}  method.
+     * </p>
+     *
+     * @param app                            Your Application class.
+     * @param builder                        ConfigurationBuilder to manually set up ACRA configuration.
+     * @param checkReportsOnApplicationStart Whether to invoke ErrorReporter.checkReportsOnApplicationStart().
+     */
+    public static void init(@NonNull Application app, @NonNull ConfigurationBuilder builder, boolean checkReportsOnApplicationStart) {
+        try {
+            init(app, builder.build(), checkReportsOnApplicationStart);
+        } catch (ACRAConfigurationException e) {
+            log.w(LOG_TAG, "Configuration Error - ACRA not started : " + e.getMessage());
+        }
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Sends any unsent reports.
+     * </p>
+     *
+     * @param app       Your Application class.
+     * @param config    ACRAConfiguration to manually set up ACRA configuration.
+     * @throws IllegalStateException if it is called more than once.
+     */
+    public static void init(@NonNull Application app, @NonNull ACRAConfiguration config) {
+        init(app, config, true);
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application. The call to this method should
+     * be placed as soon as possible in the {@link Application#attachBaseContext(Context)}
+     * method.
+     * </p>
+     *
+     * @param app       Your Application class.
+     * @param config    ACRAConfiguration to manually set up ACRA configuration.
+     * @param checkReportsOnApplicationStart    Whether to invoke ErrorReporter.checkReportsOnApplicationStart().
+     * @throws IllegalStateException if it is called more than once.
+     */
+    public static void init(@NonNull Application app, @NonNull ACRAConfiguration config, boolean checkReportsOnApplicationStart){
+
+        final boolean senderServiceProcess = isACRASenderServiceProcess();
+        if (senderServiceProcess) {
+            if (ACRA.DEV_LOGGING) log.d(LOG_TAG, "Not initialising ACRA to listen for uncaught Exceptions as this is the SendWorker process and we only send reports, we don't capture them to avoid infinite loops");
+        }
+
+        final boolean supportedAndroidVersion = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+        if (!supportedAndroidVersion){
+            // NB We keep initialising so that everything is configured. But ACRA is never enabled below.
+            log.w(LOG_TAG, "ACRA 4.7.0+ requires Froyo or greater. ACRA is disabled and will NOT catch crashes or send messages.");
+        }
+
+        if (mApplication != null) {
+            log.w(LOG_TAG, "ACRA#init called more than once. Won't do anything more.");
+            return;
+        }
+        mApplication = app;
+
+        //noinspection ConstantConditions
+        if (config == null) {
+            log.e(LOG_TAG, "ACRA#init called but no ACRAConfiguration provided");
+            return;
+        }
+        configProxy = config;
+
+        final SharedPreferences prefs = new SharedPreferencesFactory(mApplication, configProxy).create();
+
+        new LegacyFileHandler(app, prefs).updateToCurrentVersionIfNecessary();
+
+        // Initialize ErrorReporter with all required data
+        final boolean enableAcra = supportedAndroidVersion && !shouldDisableACRA(prefs);
+        if (!senderServiceProcess) {
+            // Indicate that ACRA is or is not listening for crashes.
+            log.i(LOG_TAG, "ACRA is " + (enableAcra ? "enabled" : "disabled") + " for " + mApplication.getPackageName() + ", initializing...");
+        }
+        errorReporterSingleton = new ErrorReporter(mApplication, configProxy, prefs, enableAcra, supportedAndroidVersion, !senderServiceProcess);
+
+        // Check for approved reports and send them (if enabled).
+        // NB don't check if senderServiceProcess as it will gather these reports itself.
+        if (checkReportsOnApplicationStart && !senderServiceProcess) {
+            final ApplicationStartupProcessor startupProcessor = new ApplicationStartupProcessor(mApplication,  config);
+            if (config.deleteOldUnsentReportsOnApplicationStart()) {
+                startupProcessor.deleteUnsentReportsFromOldAppVersion();
+            }
+            if (config.deleteUnapprovedReportsOnApplicationStart()) {
+                startupProcessor.deleteAllUnapprovedReportsBarOne();
+            }
+            if (enableAcra) {
+                startupProcessor.sendApprovedReports();
+            }
+        }
+
+        // We HAVE to keep a reference otherwise the listener could be garbage
+        // collected:
+        // http://stackoverflow.com/questions/2542938/sharedpreferences-onsharedpreferencechangelistener-not-being-called-consistently/3104265#3104265
+        mPrefListener = new OnSharedPreferenceChangeListener() {
+
+            @Override
+            public void onSharedPreferenceChanged(@NonNull SharedPreferences sharedPreferences, String key) {
+                if (PREF_DISABLE_ACRA.equals(key) || PREF_ENABLE_ACRA.equals(key)) {
+                    final boolean enableAcra = !shouldDisableACRA(sharedPreferences);
+                    getErrorReporter().setEnabled(enableAcra);
+                }
+            }
+        };
+
+        // This listener has to be set after initAcra is called to avoid a
+        // NPE in ErrorReporter.disable() because
+        // the context could be null at this moment.
+        prefs.registerOnSharedPreferenceChangeListener(mPrefListener);
+    }
+
+    /**
+     * @return true is ACRA has been initialised.
+     */
+    @SuppressWarnings("unused")
+    public static boolean isInitialised() {
+        return configProxy != null;
+    }
+
+    /**
+     * @return true if the current process is the process running the SenderService.
+     *          NB this assumes that your SenderService is configured to used the default ':acra' process.
+     */
+    public static boolean isACRASenderServiceProcess() {
+        final String processName = getCurrentProcessName();
+        if (ACRA.DEV_LOGGING) log.d(LOG_TAG, "ACRA processName='" + processName + '\'');
+        //processName sometimes (or always?) starts with the package name, so we use endsWith instead of equals
+        return processName != null && processName.endsWith(ACRA_PRIVATE_PROCESS_NAME);
+    }
+
+    @Nullable
+    private static String getCurrentProcessName() {
+        try {
+            return IOUtils.streamToString(new FileInputStream("/proc/self/cmdline")).trim();
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * @return the current instance of ErrorReporter.
+     * @throws IllegalStateException if {@link ACRA#init(android.app.Application)} has not yet been called.
+     */
+    @NonNull
+    public static ErrorReporter getErrorReporter() {
+        if (errorReporterSingleton == null) {
+            throw new IllegalStateException("Cannot access ErrorReporter before ACRA#init");
+        }
+        return errorReporterSingleton;
+    }
+
+
+
+    /**
+     * Check if the application default shared preferences contains true for the
+     * key "acra.disable", do not activate ACRA. Also checks the alternative
+     * opposite setting "acra.enable" if "acra.disable" is not found.
+     *
+     * @param prefs
+     *            SharedPreferences to check to see whether ACRA should be
+     *            disabled.
+     * @return true if prefs indicate that ACRA should be disabled.
+     */
+    private static boolean shouldDisableACRA(@NonNull SharedPreferences prefs) {
+        boolean disableAcra = false;
+        try {
+            final boolean enableAcra = prefs.getBoolean(PREF_ENABLE_ACRA, true);
+            disableAcra = prefs.getBoolean(PREF_DISABLE_ACRA, !enableAcra);
+        } catch (Exception e) {
+            // In case of a ClassCastException
+        }
+        return disableAcra;
+    }
+
+    /**
+     * @return The Shared Preferences where ACRA will retrieve its user adjustable setting.
+     * @deprecated since 4.8.0 use {@link SharedPreferencesFactory} instead.
+     */
+    @SuppressWarnings( "unused" )
+    @NonNull
+    public static SharedPreferences getACRASharedPreferences() {
+        if (configProxy == null) {
+            throw new IllegalStateException("Cannot call ACRA.getACRASharedPreferences() before ACRA.init().");
+        }
+        return new SharedPreferencesFactory(mApplication, configProxy).create();
+    }
+
+    /**
+     * Provides the current ACRA configuration.
+     *
+     * @return Current ACRA {@link ReportsCrashes} configuration instance.
+     * @deprecated since 4.8.0 {@link ACRAConfiguration} should be passed into classes instead of retrieved statically.
+     */
+    @NonNull
+    public static ACRAConfiguration getConfig() {
+        if (configProxy == null) {
+            throw new IllegalStateException("Cannot call ACRA.getConfig() before ACRA.init().");
+        }
+        return configProxy;
+    }
+
+    public static void setLog(@NonNull ACRALog log) {
+        //noinspection ConstantConditions (do not rely on annotation alone)
+        if (log == null) {
+            throw new NullPointerException("ACRALog cannot be null");
+        }
+        ACRA.log = log;
+    }
+}
diff --git a/src/main/java/org/acra/ACRAConstants.java b/acra/src/main/java/org/acra/ACRAConstants.java
similarity index 72%
rename from src/main/java/org/acra/ACRAConstants.java
rename to acra/src/main/java/org/acra/ACRAConstants.java
index d34f3acf..07ffa3ff 100644
--- a/src/main/java/org/acra/ACRAConstants.java
+++ b/acra/src/main/java/org/acra/ACRAConstants.java
@@ -1,154 +1,169 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import android.content.Context;
-
-import static org.acra.ReportField.*;
-
-/**
- * Responsible for collating those constants shared among the ACRA components.
- * 
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class ACRAConstants {
-
-    public static final String REPORTFILE_EXTENSION = ".stacktrace";
-
-    /**
-     * Suffix to be added to report files when they have been approved by the
-     * user in NOTIFICATION mode
-     */
-    static final String APPROVED_SUFFIX = "-approved";
-    /**
-     * This key is used to store the silent state of a report sent by
-     * handleSilentException().
-     */
-    static final String SILENT_SUFFIX = "-" + IS_SILENT;
-    /**
-     * This is the number of previously stored reports that we send in
-     * {@link SendWorker#checkAndSendReports(android.content.Context, boolean)}.
-     * The number of reports is limited to avoid ANR on application start.
-     */
-    static final int MAX_SEND_REPORTS = 5;
-
-    /**
-     * Used in the intent starting CrashReportDialog to provide the name of the
-     * latest generated report file in order to be able to associate the user
-     * comment.
-     */
-    public static final String EXTRA_REPORT_FILE_NAME = "REPORT_FILE_NAME";
-    /**
-     * Used in the intent starting CrashReportDialog to provide the Exception that caused the crash.
-     *
-     * This can be used by any BaseCrashReportDialog subclass to custom the dialog.
-     */
-    public static final String EXTRA_REPORT_EXCEPTION = "REPORT_EXCEPTION";
-
-    /**
-     * Set this extra to true to force the deletion of reports by the
-     * {@link CrashReportDialog} activity.
-     */
-    protected static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
-    /**
-     * This is the identifier (value = 666) use for the status bar notification
-     * issued when crashes occur.
-     */
-    static final int NOTIF_CRASH_ID = 666;
-    /**
-     * Number of milliseconds to wait after displaying a toast.
-     */
-    static final int TOAST_WAIT_DURATION = 2000;
-
-    /**
-     * A special String value to allow the usage of a pseudo-null default value
-     * in annotation parameters.
-     */
-    public static final String NULL_VALUE = "ACRA-NULL-STRING";
-
-    public static final boolean DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST = false;
-
-    public static final int DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES = 3;
-
-    public static final int DEFAULT_SOCKET_TIMEOUT = 5000;
-
-    public static final int DEFAULT_CONNECTION_TIMEOUT = 3000;
-
-    public static final boolean DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START = true;
-
-    public static final boolean DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START = true;
-
-    public static final int DEFAULT_DROPBOX_COLLECTION_MINUTES = 5;
-
-    public static final boolean DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS = false;
-
-    public static final int DEFAULT_SHARED_PREFERENCES_MODE = Context.MODE_PRIVATE;
-
-    public static final int DEFAULT_NOTIFICATION_ICON = android.R.drawable.stat_notify_error;
-
-    public static final int DEFAULT_DIALOG_ICON = android.R.drawable.ic_dialog_alert;
-
-    public static final int DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT = android.R.string.ok;
-
-    public static final int DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT = android.R.string.cancel;
-
-    public static final int DEFAULT_RES_VALUE = 0;
-
-    public static final String DEFAULT_STRING_VALUE = "";
-
-    public static final int DEFAULT_LOGCAT_LINES = 100;
-
-    public static final int DEFAULT_BUFFER_SIZE_IN_BYTES = 8192;
-
-    public static final boolean DEFAULT_LOGCAT_FILTER_BY_PID = false;
-
-    public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
-
-    public static final boolean DEFAULT_SEND_REPORTS_AT_SHUTDOWN = true;
-
-    public static final String DEFAULT_APPLICATION_LOGFILE = DEFAULT_STRING_VALUE;
-
-    public static final int DEFAULT_APPLICATION_LOGFILE_LINES = DEFAULT_LOGCAT_LINES;
-
-    public static final boolean DEFAULT_DISABLE_SSL_CERT_VALIDATION = false;
-
-    public static final String DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS = "org.acra.util.DefaultHttpsSocketFactoryFactory";
-
-    /**
-     * Default list of {@link ReportField}s to be sent in email reports. You can
-     * set your own list with
-     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
-     * 
-     * @see org.acra.annotation.ReportsCrashes#mailTo()
-     */
-    public final static ReportField[] DEFAULT_MAIL_REPORT_FIELDS = { USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME,
-            BRAND, PHONE_MODEL, CUSTOM_DATA, STACK_TRACE };
-
-    /**
-     * Default list of {@link ReportField}s to be sent in reports. You can set
-     * your own list with
-     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
-     */
-    public static final ReportField[] DEFAULT_REPORT_FIELDS = { REPORT_ID, APP_VERSION_CODE, APP_VERSION_NAME,
-            PACKAGE_NAME, FILE_PATH, PHONE_MODEL, BRAND, PRODUCT, ANDROID_VERSION, BUILD, TOTAL_MEM_SIZE,
-            AVAILABLE_MEM_SIZE, BUILD_CONFIG, CUSTOM_DATA, IS_SILENT, STACK_TRACE, INITIAL_CONFIGURATION, CRASH_CONFIGURATION,
-            DISPLAY, USER_COMMENT, USER_EMAIL, USER_APP_START_DATE, USER_CRASH_DATE, DUMPSYS_MEMINFO, LOGCAT,
-            INSTALLATION_ID, DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES, SETTINGS_SYSTEM, SETTINGS_SECURE,
-            SETTINGS_GLOBAL };
-
-    public static final String DATE_TIME_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ";
-}
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra;
+
+import android.content.Context;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.StringRes;
+
+import org.acra.dialog.CrashReportDialog;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+
+import static org.acra.ReportField.*;
+
+/**
+ * Responsible for collating those constants shared among the ACRA components.
+ * 
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class ACRAConstants {
+    private ACRAConstants(){}
+
+    public static final String REPORTFILE_EXTENSION = ".stacktrace";
+
+    /**
+     * Suffix to be added to report files when they have been approved by the
+     * user in NOTIFICATION mode
+     */
+    public static final String APPROVED_SUFFIX = "-approved";
+    /**
+     * This key is used to store the silent state of a report sent by
+     * handleSilentException().
+     */
+    public static final String SILENT_SUFFIX = "-" + IS_SILENT;
+    /**
+     * This is the maximum number of previously stored reports that we send
+     * in one batch to avoid overloading the network.
+     */
+    public static final int MAX_SEND_REPORTS = 5;
+
+    /**
+     * Used in the intent starting CrashReportDialog to provide the name of the
+     * latest generated report file in order to be able to associate the user
+     * comment.
+     */
+    public static final String EXTRA_REPORT_FILE = "REPORT_FILE";
+
+    /**
+     * Used in the intent starting CrashReportDialog to provide the Exception that caused the crash.
+     *
+     * This can be used by any BaseCrashReportDialog subclass to custom the dialog.
+     */
+    public static final String EXTRA_REPORT_EXCEPTION = "REPORT_EXCEPTION";
+
+    /**
+     * Used in the intent starting CrashReportDialog to provide the AcraConfig to use when gathering the crash info.
+     *
+     * This can be used by any BaseCrashReportDialog subclass to custom the dialog.
+     */
+    public static final String EXTRA_REPORT_CONFIG = "REPORT_CONFIG";
+
+    /**
+     * Set this extra to true to force the deletion of reports by the {@link CrashReportDialog} activity.
+     */
+    public static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
+    /**
+     * This is the identifier (value = 666) use for the status bar notification issued when crashes occur.
+     */
+    public static final int NOTIF_CRASH_ID = 666;
+    /**
+     * Number of milliseconds to wait after displaying a toast.
+     */
+    public static final int TOAST_WAIT_DURATION = 2000;
+
+    /**
+     * A special String value to allow the usage of a pseudo-null default value
+     * in annotation parameters.
+     */
+    public static final String NULL_VALUE = "ACRA-NULL-STRING";
+
+    public static final boolean DEFAULT_REPORT_TO_ANDROID_FRAMEWORK = false;
+
+    public static final int DEFAULT_SOCKET_TIMEOUT = 20000;
+
+    public static final int DEFAULT_CONNECTION_TIMEOUT = 5000;
+
+    public static final boolean DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START = true;
+
+    public static final boolean DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START = true;
+
+    public static final int DEFAULT_DROPBOX_COLLECTION_MINUTES = 5;
+
+    public static final boolean DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS = false;
+
+    public static final int DEFAULT_SHARED_PREFERENCES_MODE = Context.MODE_PRIVATE;
+
+    @DrawableRes
+    public static final int DEFAULT_NOTIFICATION_ICON = android.R.drawable.stat_notify_error;
+
+    @DrawableRes
+    public static final int DEFAULT_DIALOG_ICON = android.R.drawable.ic_dialog_alert;
+
+    @StringRes
+    public static final int DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT = android.R.string.ok;
+
+    @StringRes
+    public static final int DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT = android.R.string.cancel;
+
+    public static final int DEFAULT_RES_VALUE = 0;
+
+    public static final String DEFAULT_STRING_VALUE = "";
+
+    public static final int DEFAULT_LOGCAT_LINES = 100;
+
+    public static final int DEFAULT_BUFFER_SIZE_IN_BYTES = 8192;
+
+    public static final boolean DEFAULT_LOGCAT_FILTER_BY_PID = false;
+
+    public static final boolean DEFAULT_NON_BLOCKING_READ_FOR_LOGCAT = false;
+
+    public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
+
+    public static final String DEFAULT_APPLICATION_LOGFILE = DEFAULT_STRING_VALUE;
+
+    public static final int DEFAULT_APPLICATION_LOGFILE_LINES = DEFAULT_LOGCAT_LINES;
+
+    /**
+     * Default list of {@link ReportField}s to be sent in email reports. You can
+     * set your own list with
+     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
+     * 
+     * @see org.acra.annotation.ReportsCrashes#mailTo()
+     */
+    public static final ReportField[] DEFAULT_MAIL_REPORT_FIELDS = { USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME,
+            BRAND, PHONE_MODEL, CUSTOM_DATA, STACK_TRACE };
+
+    /**
+     * Default list of {@link ReportField}s to be sent in reports. You can set
+     * your own list with
+     * {@link org.acra.annotation.ReportsCrashes#customReportContent()}.
+     */
+    public static final ReportField[] DEFAULT_REPORT_FIELDS = { REPORT_ID, APP_VERSION_CODE, APP_VERSION_NAME,
+            PACKAGE_NAME, FILE_PATH, PHONE_MODEL, BRAND, PRODUCT, ANDROID_VERSION, BUILD, TOTAL_MEM_SIZE,
+            AVAILABLE_MEM_SIZE, BUILD_CONFIG, CUSTOM_DATA, IS_SILENT, STACK_TRACE, INITIAL_CONFIGURATION, CRASH_CONFIGURATION,
+            DISPLAY, USER_COMMENT, USER_EMAIL, USER_APP_START_DATE, USER_CRASH_DATE, DUMPSYS_MEMINFO, LOGCAT,
+            INSTALLATION_ID, DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES };
+
+    public static final String DATE_TIME_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ";
+
+    public static final String DEFAULT_CERTIFICATE_TYPE = "X.509";
+
+    public static final Element NOT_AVAILABLE = new StringElement("N/A");
+
+    public static final String UTF8 = "UTF-8";
+}
diff --git a/acra/src/main/java/org/acra/CrashReportDialog.java b/acra/src/main/java/org/acra/CrashReportDialog.java
new file mode 100644
index 00000000..ab733636
--- /dev/null
+++ b/acra/src/main/java/org/acra/CrashReportDialog.java
@@ -0,0 +1,21 @@
+package org.acra;
+
+import android.os.Bundle;
+
+import static org.acra.ACRA.LOG_TAG;
+
+
+/**
+ * Old crash report dialog.
+ *
+ * @deprecated since 4.8.0 use {@link org.acra.dialog.CrashReportDialog} instead
+ **/
+@Deprecated
+public final class CrashReportDialog extends org.acra.dialog.CrashReportDialog {
+
+    @Override
+    protected void buildAndShowDialog(Bundle savedInstanceState){
+        ACRA.log.w(LOG_TAG, "org.acra.CrashReportDialog has been deprecated. Please use org.acra.dialog.CrashReportDialog instead");
+        super.buildAndShowDialog(savedInstanceState);
+    }
+}
\ No newline at end of file
diff --git a/acra/src/main/java/org/acra/ErrorReporter.java b/acra/src/main/java/org/acra/ErrorReporter.java
new file mode 100644
index 00000000..2d56f0cb
--- /dev/null
+++ b/acra/src/main/java/org/acra/ErrorReporter.java
@@ -0,0 +1,380 @@
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra;
+
+import android.app.Application;
+import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.LastActivityManager;
+import org.acra.builder.NoOpReportPrimer;
+import org.acra.builder.ReportBuilder;
+import org.acra.builder.ReportExecutor;
+import org.acra.builder.ReportPrimer;
+import org.acra.collector.ConfigurationCollector;
+import org.acra.collector.CrashReportDataFactory;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.util.ApplicationStartupProcessor;
+import org.acra.util.InstanceCreator;
+import org.acra.util.ProcessFinisher;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * <p>
+ * The ErrorReporter is a Singleton object in charge of collecting crash context
+ * data and sending crash reports. It registers itself as the Application's
+ * Thread default {@link UncaughtExceptionHandler}.
+ * </p>
+ * <p>
+ * When a crash occurs, it collects data of the crash context (device, system,
+ * stack trace...) and writes a report file in the application private
+ * directory. This report file is then sent:
+ * </p>
+ * <ul>
+ * <li>immediately if {@link ReportsCrashes#mode()} is set to
+ * {@link ReportingInteractionMode#SILENT} or
+ * {@link ReportingInteractionMode#TOAST},</li>
+ * <li>on application start if in the previous case the transmission could not
+ * technically be made,</li>
+ * <li>when the user accepts to send it if {@link ReportsCrashes#mode()} is set
+ * to {@link ReportingInteractionMode#NOTIFICATION}.</li>
+ * </ul>
+ * <p>
+ * If an error occurs while sending a report, it is kept for later attempts.
+ * </p>
+ */
+public class ErrorReporter implements Thread.UncaughtExceptionHandler {
+
+    private final boolean supportedAndroidVersion;
+
+    private final Application context;
+    @NonNull
+    private final ACRAConfiguration config;
+
+    @NonNull
+    private final CrashReportDataFactory crashReportDataFactory;
+    @NonNull
+    private final ReportExecutor reportExecutor;
+
+    @NonNull
+    private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = new ExceptionHandlerInitializer() {
+        @Override
+        public void initializeExceptionHandler(ErrorReporter reporter) {
+        }
+    };
+
+
+    /**
+     * Can only be constructed from within this class.
+     *
+     * @param context   Context for the application in which ACRA is running.
+     * @param config    AcraConfig to use when reporting and sending errors.
+     * @param prefs     SharedPreferences used by ACRA.
+     * @param enabled   Whether this ErrorReporter should capture Exceptions and forward their reports.
+     * @param listenForUncaughtExceptions   Whether to listen for uncaught Exceptions.
+     */
+    ErrorReporter(@NonNull Application context, @NonNull ACRAConfiguration config, @NonNull SharedPreferences prefs,
+                  boolean enabled, boolean supportedAndroidVersion, boolean listenForUncaughtExceptions) {
+
+        this.context = context;
+        this.config = config;
+        this.supportedAndroidVersion = supportedAndroidVersion;
+
+        // Store the initial Configuration state.
+        // This is expensive to gather, so only do so if we plan to report it.
+        final Element initialConfiguration;
+        if (config.reportContent().contains(ReportField.INITIAL_CONFIGURATION)) {
+            initialConfiguration = ConfigurationCollector.collectConfiguration(this.context);
+        } else {
+            initialConfiguration = ACRAConstants.NOT_AVAILABLE;
+        }
+
+        // Sets the application start date.
+        // This will be included in the reports, will be helpful compared to user_crash date.
+        final Calendar appStartDate = new GregorianCalendar();
+
+        crashReportDataFactory = new CrashReportDataFactory(this.context, config, prefs, appStartDate, initialConfiguration);
+
+        final Thread.UncaughtExceptionHandler defaultExceptionHandler;
+        if (listenForUncaughtExceptions) {
+            defaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+            Thread.setDefaultUncaughtExceptionHandler(this);
+        } else {
+            defaultExceptionHandler = null;
+        }
+
+        final LastActivityManager lastActivityManager = new LastActivityManager(this.context);
+        final InstanceCreator instanceCreator = new InstanceCreator();
+        final ReportPrimer reportPrimer = instanceCreator.create(config.reportPrimerClass(), new NoOpReportPrimer());
+        final ProcessFinisher processFinisher = new ProcessFinisher(context, config, lastActivityManager);
+
+        reportExecutor = new ReportExecutor(context, config, crashReportDataFactory, defaultExceptionHandler, reportPrimer, processFinisher);
+        reportExecutor.setEnabled(enabled);
+    }
+
+    /**
+     * Deprecated. Use {@link #putCustomData(String, String)}.
+     *
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
+     */
+    @Deprecated
+    @SuppressWarnings("unused")
+    public void addCustomData(@NonNull String key, String value) {
+        putCustomData(key, value);
+    }
+
+    /**
+     * <p>
+     * Use this method to provide the ErrorReporter with data of your running
+     * application. You should call this at several key places in your code the
+     * same way as you would output important debug data in a log file. Only the
+     * latest value is kept for each key (no history of the values is sent in
+     * the report).
+     * </p>
+     *
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
+     * @return The previous value for this key if there was one, or null.
+     * @see #removeCustomData(String)
+     * @see #getCustomData(String)
+     */
+    @SuppressWarnings("unused")
+    public String putCustomData(@NonNull String key, String value) {
+        return crashReportDataFactory.putCustomData(key, value);
+    }
+
+    /**
+     * <p>
+     * Use this method to perform additional initialization before the
+     * ErrorReporter handles a throwable. This can be used, for example, to put
+     * custom data using {@link #putCustomData(String, String)}, which is not
+     * available immediately after startup. It can be, for example, last 20
+     * requests or something else. The call is thread safe.
+     * </p>
+     * <p>
+     * {@link ExceptionHandlerInitializer#initializeExceptionHandler(ErrorReporter)}
+     * will be executed on the main thread in case of uncaught exception and on
+     * the caller thread of {@link #handleSilentException(Throwable)} or
+     * {@link #handleException(Throwable)}.
+     * </p>
+     * <p>
+     * Example. Add to the {@link Application#onCreate()}:
+     * </p>
+     *
+     * <pre>
+     * ACRA.getErrorReporter().setExceptionHandlerInitializer(new ExceptionHandlerInitializer() {
+     *     <code>@Override</code> public void initializeExceptionHandler(ErrorReporter reporter) {
+     *         reporter.putCustomData("CUSTOM_ACCUMULATED_DATA_TAG", someAccumulatedData.toString);
+     *     }
+     * });
+     * </pre>
+     *
+     * @param initializer   The initializer. Can be <code>null</code>.
+     * @deprecated since 4.8.0 use {@link ReportPrimer} mechanism instead.
+     */
+    public void setExceptionHandlerInitializer(@Nullable ExceptionHandlerInitializer initializer) {
+        exceptionHandlerInitializer = (initializer != null)
+                ? initializer
+                : new ExceptionHandlerInitializer() {
+                    @Override
+                    public void initializeExceptionHandler(ErrorReporter reporter) {
+                    }
+                };
+    }
+
+    /**
+     * Removes a key/value pair from your reports custom data field.
+     *
+     * @param key   The key of the data to be removed.
+     * @return The value for this key before removal.
+     * @see #putCustomData(String, String)
+     * @see #getCustomData(String)
+     */
+    @SuppressWarnings("unused")
+    public String removeCustomData(@NonNull String key) {
+        return crashReportDataFactory.removeCustomData(key);
+    }
+
+    /**
+     * Removes all key/value pairs from your reports custom data field.
+     */
+    @SuppressWarnings("unused")
+    public void clearCustomData() {
+        crashReportDataFactory.clearCustomData();
+    }
+
+    /**
+     * Gets the current value for a key in your reports custom data field.
+     *
+     * @param key
+     *            The key of the data to be retrieved.
+     * @return The value for this key.
+     * @see #putCustomData(String, String)
+     * @see #removeCustomData(String)
+     */
+    @SuppressWarnings("unused")
+    public String getCustomData(@NonNull String key) {
+        return crashReportDataFactory.getCustomData(key);
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see
+     * java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang
+     * .Thread, java.lang.Throwable)
+     */
+    @Override
+    public void uncaughtException(@Nullable Thread t, @NonNull Throwable e) {
+
+        // If we're not enabled then just pass the Exception on to the defaultExceptionHandler.
+        if (!reportExecutor.isEnabled()) {
+            reportExecutor.handReportToDefaultExceptionHandler(t, e);
+            return;
+        }
+
+        try {
+            ACRA.log.e(LOG_TAG, "ACRA caught a " + e.getClass().getSimpleName() + " for " + context.getPackageName(), e);
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Building report");
+
+            performDeprecatedReportPriming();
+
+            // Generate and send crash report
+            new ReportBuilder()
+                .uncaughtExceptionThread(t)
+                .exception(e)
+                .endApplication()
+                .build(reportExecutor);
+
+        } catch (Throwable fatality) {
+            // ACRA failed. Prevent any recursive call to ACRA.uncaughtException(), let the native reporter do its job.
+            ACRA.log.e(LOG_TAG, "ACRA failed to capture the error - handing off to native error reporter" , fatality);
+            reportExecutor.handReportToDefaultExceptionHandler(t, e);
+        }
+    }
+
+    /**
+     * Mark this report as silent as send it.
+     *
+     * @param e The {@link Throwable} to be reported. If null the report will
+     *          contain a new Exception("Report requested by developer").
+     */
+    @SuppressWarnings("unused")
+    public void handleSilentException(@Nullable Throwable e) {
+        performDeprecatedReportPriming();
+        new ReportBuilder()
+                .exception(e)
+                .sendSilently()
+                .build(reportExecutor);
+    }
+
+    /**
+     * Enable or disable this ErrorReporter. By default it is enabled.
+     *
+     * @param enabled
+     *            Whether this ErrorReporter should capture Exceptions and
+     *            forward them as crash reports.
+     */
+    public void setEnabled(boolean enabled) {
+        if (supportedAndroidVersion) {
+            ACRA.log.i(LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled") + " for " + context.getPackageName());
+            reportExecutor.setEnabled(enabled);
+        } else {
+            ACRA.log.w(LOG_TAG, "ACRA 4.7.0+ requires Froyo or greater. ACRA is disabled and will NOT catch crashes or send messages.");
+        }
+    }
+
+    /**
+     * This method looks for pending reports and does the action required depending on the interaction mode set.
+     *
+     * There is no need to call this method as ACRA will by default check for errors on report start.
+     *
+     * Whether ACRA checks for reports on app start is controlled by {@link ACRA#init(Application, ACRAConfiguration, boolean)},
+     * but the default is that it will.
+     *
+     * @deprecated since 4.8.0 No replacement.
+     */
+    @SuppressWarnings( " unused" )
+    public void checkReportsOnApplicationStart() {
+        final ApplicationStartupProcessor startupProcessor = new ApplicationStartupProcessor(context,  config);
+        if (config.deleteOldUnsentReportsOnApplicationStart()) {
+            startupProcessor.deleteUnsentReportsFromOldAppVersion();
+        }
+        if (config.deleteUnapprovedReportsOnApplicationStart()) {
+            startupProcessor.deleteAllUnapprovedReportsBarOne();
+        }
+        if (reportExecutor.isEnabled()) {
+            startupProcessor.sendApprovedReports();
+        }
+    }
+
+    /**
+     * Send a report for a {@link Throwable} with the reporting interaction mode
+     * configured by the developer.
+     *
+     * @param e
+     *            The {@link Throwable} to be reported. If null the report will
+     *            contain a new Exception("Report requested by developer").
+     * @param endApplication
+     *            Set this to true if you want the application to be ended after
+     *            sending the report.
+     */
+    @SuppressWarnings("unused")
+    public void handleException(@Nullable Throwable e, boolean endApplication) {
+        performDeprecatedReportPriming();
+        final ReportBuilder builder = new ReportBuilder();
+        builder.exception(e);
+        if (endApplication) {
+            builder.endApplication();
+        }
+        builder.build(reportExecutor);
+    }
+
+    /**
+     * Send a report for a {@link Throwable} with the reporting interaction mode
+     * configured by the developer, the application is then killed and restarted
+     * by the system.
+     *
+     * @param e
+     *            The {@link Throwable} to be reported. If null the report will
+     *            contain a new Exception("Report requested by developer").
+     */
+    @SuppressWarnings("unused")
+    public void handleException(@Nullable Throwable e) {
+        handleException(e, false);
+    }
+
+    /**
+     * This method is only here to support the deprecated {@link ExceptionHandlerInitializer} mechanism
+     * for adding additional data to a crash report.
+     */
+    private void performDeprecatedReportPriming() {
+        try {
+            exceptionHandlerInitializer.initializeExceptionHandler(this);
+        } catch (Exception exceptionInRunnable) {
+            ACRA.log.w(LOG_TAG, "Failed to initialize " + exceptionHandlerInitializer + " from #handleException");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/acra/ExceptionHandlerInitializer.java b/acra/src/main/java/org/acra/ExceptionHandlerInitializer.java
similarity index 87%
rename from src/main/java/org/acra/ExceptionHandlerInitializer.java
rename to acra/src/main/java/org/acra/ExceptionHandlerInitializer.java
index fc532bb9..4e48616c 100644
--- a/src/main/java/org/acra/ExceptionHandlerInitializer.java
+++ b/acra/src/main/java/org/acra/ExceptionHandlerInitializer.java
@@ -7,6 +7,7 @@
  * exception is handled.
  * 
  * @see ErrorReporter#setExceptionHandlerInitializer(ExceptionHandlerInitializer)
+ * @deprecated since 4.8.0 use {@link org.acra.builder.ReportPrimer} mechanism instead.
  */
 public interface ExceptionHandlerInitializer {
     /**
diff --git a/src/main/java/org/acra/ReportField.java b/acra/src/main/java/org/acra/ReportField.java
similarity index 95%
rename from src/main/java/org/acra/ReportField.java
rename to acra/src/main/java/org/acra/ReportField.java
index 3815b11b..cb9b1db6 100644
--- a/src/main/java/org/acra/ReportField.java
+++ b/acra/src/main/java/org/acra/ReportField.java
@@ -1,302 +1,302 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import org.acra.annotation.ReportsCrashes;
-
-import android.content.res.Configuration;
-
-/**
- * Specifies all the different fields available in a crash report.
- * 
- * @author Normal
- * 
- */
-public enum ReportField {
-    /**
-     * Report Identifier
-     */
-    REPORT_ID,
-    /**
-     * Application version code. This is the incremental integer version code
-     * used to differentiate versions on the android market.
-     * 
-     * @see android.content.pm.PackageInfo#versionCode
-     */
-    APP_VERSION_CODE,
-    /**
-     * Application version name.
-     * 
-     * @see android.content.pm.PackageInfo#versionName
-     */
-    APP_VERSION_NAME,
-    /**
-     * Application package name.
-     * 
-     * @see android.content.Context#getPackageName()
-     */
-    PACKAGE_NAME,
-    /**
-     * Base path of the application's private file folder.
-     * 
-     * @see android.content.Context#getFilesDir()
-     */
-    FILE_PATH,
-    /**
-     * Device model name.
-     * 
-     * @see android.os.Build#MODEL
-     */
-    PHONE_MODEL,
-    /**
-     * Device android version name.
-     * 
-     * @see android.os.Build.VERSION#RELEASE
-     */
-    ANDROID_VERSION,
-    /**
-     * Android Build details.
-     * 
-     * @see android.os.Build
-     */
-    BUILD {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Device brand (manufacturer or carrier).
-     * 
-     * @see android.os.Build#BRAND
-     */
-    BRAND,
-    /**
-     * Device overall product code.
-     * 
-     * @see android.os.Build#PRODUCT
-     */
-    PRODUCT,
-    /**
-     * Estimation of the total device memory size based on filesystem stats.
-     */
-    TOTAL_MEM_SIZE,
-    /**
-     * Estimation of the available device memory size based on filesystem stats.
-     */
-    AVAILABLE_MEM_SIZE,
-    /**
-     * Contains key = value pairs defined by the application developer during
-     * the application build.
-     */
-    BUILD_CONFIG {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Contains key = value pairs defined by the application developer during
-     * the application execution.
-     */
-    CUSTOM_DATA {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * The Holy Stack Trace.
-     */
-    STACK_TRACE,
-    /**
-     * A hash of the stack trace, taking only method names into account.<br>
-     * Line numbers are stripped out before computing the hash. This can help you
-     * uniquely identify stack traces.
-     */
-    STACK_TRACE_HASH,
-    /**
-     * {@link Configuration} fields state on the application start.
-     * 
-     * @see Configuration
-     */
-    INITIAL_CONFIGURATION {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * {@link Configuration} fields state on the application crash.
-     * 
-     * @see Configuration
-     */
-    CRASH_CONFIGURATION {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Device display specifications.
-     * 
-     * @see android.view.WindowManager#getDefaultDisplay()
-     */
-    DISPLAY {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Comment added by the user in the CrashReportDialog displayed in
-     * {@link ReportingInteractionMode#NOTIFICATION} mode.
-     */
-    USER_COMMENT,
-    /**
-     * User date on application start.
-     */
-    USER_APP_START_DATE,
-    /**
-     * User date immediately after the crash occurred.
-     */
-    USER_CRASH_DATE,
-    /**
-     * Memory state details for the application process.
-     */
-    DUMPSYS_MEMINFO,
-    /**
-     * Content of the android.os.DropBoxManager (introduced in API level 8).
-     * Requires READ_LOGS permission.
-     */
-    DROPBOX,
-    /**
-     * Logcat default extract. Requires READ_LOGS permission.
-     */
-    LOGCAT,
-    /**
-     * Logcat eventslog extract. Requires READ_LOGS permission.
-     */
-    EVENTSLOG,
-    /**
-     * Logcat radio extract. Requires READ_LOGS permission.
-     */
-    RADIOLOG,
-    /**
-     * True if the report has been explicitly sent silently by the developer.
-     */
-    IS_SILENT,
-    /**
-     * Device unique ID (IMEI). Requires READ_PHONE_STATE permission.
-     */
-    DEVICE_ID,
-    /**
-     * Installation unique ID. This identifier allow you to track a specific
-     * user application installation without using any personal data.
-     */
-    INSTALLATION_ID,
-    /**
-     * User email address. Can be provided by the user in the
-     * {@link ACRA#PREF_USER_EMAIL_ADDRESS} SharedPreference.
-     */
-    USER_EMAIL,
-    /**
-     * Features declared as available on this device by the system.
-     */
-    DEVICE_FEATURES {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * External storage state and standard directories.
-     */
-    ENVIRONMENT {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * System settings.
-     */
-    SETTINGS_SYSTEM {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Secure settings (applications can't modify them).
-     */
-    SETTINGS_SECURE {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Global settings, introduced in Android 4.2 (API level 17) to centralize settings for multiple users.
-     */
-    SETTINGS_GLOBAL {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * SharedPreferences contents
-     */
-    SHARED_PREFERENCES {
-        @Override
-        public boolean containsKeyValuePairs() {
-            return true;
-        }
-    },
-    /**
-     * Content of your own application log file. To be configured with
-     * {@link ReportsCrashes#applicationLogFile()} to define the path/name of
-     * the log file and {@link ReportsCrashes#applicationLogFileLines()} to set
-     * the number of lines you want to be retrieved.
-     */
-    APPLICATION_LOG,
-    /**
-     * Since Android API Level 16 (Android 4.1 - Jelly Beans), retrieve the list
-     * of supported Media codecs and their capabilities (color format, profile
-     * and level).
-     */
-    MEDIA_CODEC_LIST,
-    /**
-     * Retrieves details of the failing thread (id, name, group name).
-     */
-    THREAD_DETAILS,
-    /**
-     * Retrieves the user IP address(es).
-     */
-    USER_IP;
-
-    /**
-     * Whether this field is a collection of key/value pairs.
-     * 
-     * @return true if the field contains a string with a key/value pair on each
-     *         line, key and value separated by an equal sugn
-     * 
-     */
-    public boolean containsKeyValuePairs() {
-        return false;
-    }
-}
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra;
+
+import android.content.res.Configuration;
+
+import org.acra.annotation.ReportsCrashes;
+
+/**
+ * Specifies all the different fields available in a crash report.
+ * 
+ * @author Normal
+ * 
+ */
+public enum ReportField {
+    /**
+     * Report Identifier.
+     */
+    REPORT_ID,
+    /**
+     * Application version code. This is the incremental integer version code
+     * used to differentiate versions on the android market.
+     * 
+     * @see android.content.pm.PackageInfo#versionCode
+     */
+    APP_VERSION_CODE,
+    /**
+     * Application version name.
+     * 
+     * @see android.content.pm.PackageInfo#versionName
+     */
+    APP_VERSION_NAME,
+    /**
+     * Application package name.
+     * 
+     * @see android.content.Context#getPackageName()
+     */
+    PACKAGE_NAME,
+    /**
+     * Base path of the application's private file folder.
+     * 
+     * @see android.content.Context#getFilesDir()
+     */
+    FILE_PATH,
+    /**
+     * Device model name.
+     * 
+     * @see android.os.Build#MODEL
+     */
+    PHONE_MODEL,
+    /**
+     * Device android version name.
+     * 
+     * @see android.os.Build.VERSION#RELEASE
+     */
+    ANDROID_VERSION,
+    /**
+     * Android Build details.
+     * 
+     * @see android.os.Build
+     */
+    BUILD {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Device brand (manufacturer or carrier).
+     * 
+     * @see android.os.Build#BRAND
+     */
+    BRAND,
+    /**
+     * Device overall product code.
+     * 
+     * @see android.os.Build#PRODUCT
+     */
+    PRODUCT,
+    /**
+     * Estimation of the total device memory size based on filesystem stats.
+     */
+    TOTAL_MEM_SIZE,
+    /**
+     * Estimation of the available device memory size based on filesystem stats.
+     */
+    AVAILABLE_MEM_SIZE,
+    /**
+     * Contains key = value pairs defined by the application developer during
+     * the application build.
+     */
+    BUILD_CONFIG {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Contains key = value pairs defined by the application developer during
+     * the application execution.
+     */
+    CUSTOM_DATA {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * The Holy Stack Trace.
+     */
+    STACK_TRACE,
+    /**
+     * A hash of the stack trace, taking only method names into account.<br>
+     * Line numbers are stripped out before computing the hash. This can help you
+     * uniquely identify stack traces.
+     */
+    STACK_TRACE_HASH,
+    /**
+     * {@link Configuration} fields state on the application start.
+     * 
+     * @see Configuration
+     */
+    INITIAL_CONFIGURATION {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * {@link Configuration} fields state on the application crash.
+     * 
+     * @see Configuration
+     */
+    CRASH_CONFIGURATION {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Device display specifications.
+     * 
+     * @see android.view.WindowManager#getDefaultDisplay()
+     */
+    DISPLAY {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Comment added by the user in the CrashReportDialog displayed in
+     * {@link ReportingInteractionMode#NOTIFICATION} mode.
+     */
+    USER_COMMENT,
+    /**
+     * User date on application start.
+     */
+    USER_APP_START_DATE,
+    /**
+     * User date immediately after the crash occurred.
+     */
+    USER_CRASH_DATE,
+    /**
+     * Memory state details for the application process.
+     */
+    DUMPSYS_MEMINFO,
+    /**
+     * Content of the android.os.DropBoxManager (introduced in API level 8).
+     * Requires READ_LOGS permission.
+     */
+    DROPBOX,
+    /**
+     * Logcat default extract. Requires READ_LOGS permission.
+     */
+    LOGCAT,
+    /**
+     * Logcat eventslog extract. Requires READ_LOGS permission.
+     */
+    EVENTSLOG,
+    /**
+     * Logcat radio extract. Requires READ_LOGS permission.
+     */
+    RADIOLOG,
+    /**
+     * True if the report has been explicitly sent silently by the developer.
+     */
+    IS_SILENT,
+    /**
+     * Device unique ID (IMEI). Requires READ_PHONE_STATE permission.
+     */
+    DEVICE_ID,
+    /**
+     * Installation unique ID. This identifier allow you to track a specific
+     * user application installation without using any personal data.
+     */
+    INSTALLATION_ID,
+    /**
+     * User email address. Can be provided by the user in the
+     * {@link ACRA#PREF_USER_EMAIL_ADDRESS} SharedPreference.
+     */
+    USER_EMAIL,
+    /**
+     * Features declared as available on this device by the system.
+     */
+    DEVICE_FEATURES {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * External storage state and standard directories.
+     */
+    ENVIRONMENT {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * System settings.
+     */
+    SETTINGS_SYSTEM {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Secure settings (applications can't modify them).
+     */
+    SETTINGS_SECURE {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Global settings, introduced in Android 4.2 (API level 17) to centralize settings for multiple users.
+     */
+    SETTINGS_GLOBAL {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * SharedPreferences contents
+     */
+    SHARED_PREFERENCES {
+        @Override
+        public boolean containsKeyValuePairs() {
+            return true;
+        }
+    },
+    /**
+     * Content of your own application log file. To be configured with
+     * {@link ReportsCrashes#applicationLogFile()} to define the path/name of
+     * the log file and {@link ReportsCrashes#applicationLogFileLines()} to set
+     * the number of lines you want to be retrieved.
+     */
+    APPLICATION_LOG,
+    /**
+     * Since Android API Level 16 (Android 4.1 - Jelly Beans), retrieve the list
+     * of supported Media codecs and their capabilities (color format, profile
+     * and level).
+     */
+    MEDIA_CODEC_LIST,
+    /**
+     * Retrieves details of the failing thread (id, name, group name).
+     */
+    THREAD_DETAILS,
+    /**
+     * Retrieves the user IP address(es).
+     */
+    USER_IP;
+
+    /**
+     * Whether this field is a collection of key/value pairs.
+     * 
+     * @return true if the field contains a string with a key/value pair on each
+     *         line, key and value separated by an equal sign
+     * 
+     */
+    public boolean containsKeyValuePairs() {
+        return false;
+    }
+}
diff --git a/src/main/java/org/acra/ReportingInteractionMode.java b/acra/src/main/java/org/acra/ReportingInteractionMode.java
similarity index 97%
rename from src/main/java/org/acra/ReportingInteractionMode.java
rename to acra/src/main/java/org/acra/ReportingInteractionMode.java
index 0c84aecd..1d553857 100644
--- a/src/main/java/org/acra/ReportingInteractionMode.java
+++ b/acra/src/main/java/org/acra/ReportingInteractionMode.java
@@ -1,53 +1,53 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-/**
- * Defines the different user interaction modes for ACRA.
- * <ul>
- * <li>SILENT: No interaction, reports are sent silently and a "Force close"
- * dialog terminates the app.</li>
- * <li>TOAST: A simple Toast is triggered when the application crashes, the
- * Force close dialog is not displayed.</li>
- * <li>NOTIFICATION: A status bar notification is triggered when the application
- * crashes, the Force close dialog is not displayed. When the user selects the
- * notification, a dialog is displayed asking him if he is ok to send a report</li>
- * </ul>
- */
-public enum ReportingInteractionMode {
-    /**
-     * No interaction, reports are sent silently and a "Force close" dialog
-     * terminates the app.
-     */
-    SILENT,
-    /**
-     * A status bar notification is triggered when the application crashes, the
-     * Force close dialog is not displayed. When the user selects the
-     * notification, a dialog is displayed asking him if he is ok to send a
-     * report.
-     */
-    NOTIFICATION,
-    /**
-     * A simple Toast is triggered when the application crashes, the Force close
-     * dialog is not displayed.
-     */
-    TOAST,
-    /**
-     * Direct dialog: a report confirmation dialog is displayed right after the crash.
-     * Will replace {@link #NOTIFICATION} mode.
-     */
-    DIALOG
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra;
+
+/**
+ * Defines the different user interaction modes for ACRA.
+ * <ul>
+ * <li>SILENT: No interaction, reports are sent silently and a "Force close"
+ * dialog terminates the app.</li>
+ * <li>TOAST: A simple Toast is triggered when the application crashes, the
+ * Force close dialog is not displayed.</li>
+ * <li>NOTIFICATION: A status bar notification is triggered when the application
+ * crashes, the Force close dialog is not displayed. When the user selects the
+ * notification, a dialog is displayed asking him if he is ok to send a report</li>
+ * </ul>
+ */
+public enum ReportingInteractionMode {
+    /**
+     * No interaction, reports are sent silently and a "Force close" dialog
+     * terminates the app.
+     */
+    SILENT,
+    /**
+     * A status bar notification is triggered when the application crashes, the
+     * Force close dialog is not displayed. When the user selects the
+     * notification, a dialog is displayed asking him if he is ok to send a
+     * report.
+     */
+    NOTIFICATION,
+    /**
+     * A simple Toast is triggered when the application crashes, the Force close
+     * dialog is not displayed.
+     */
+    TOAST,
+    /**
+     * Direct dialog: a report confirmation dialog is displayed right after the crash.
+     * Will replace {@link #NOTIFICATION} mode.
+     */
+    DIALOG
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/annotation/ReportsCrashes.java b/acra/src/main/java/org/acra/annotation/ReportsCrashes.java
similarity index 54%
rename from src/main/java/org/acra/annotation/ReportsCrashes.java
rename to acra/src/main/java/org/acra/annotation/ReportsCrashes.java
index d4683609..0a12f031 100644
--- a/src/main/java/org/acra/annotation/ReportsCrashes.java
+++ b/acra/src/main/java/org/acra/annotation/ReportsCrashes.java
@@ -1,565 +1,664 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.annotation;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-import org.acra.BaseCrashReportDialog;
-import org.acra.CrashReportDialog;
-import org.acra.ReportField;
-import org.acra.ReportingInteractionMode;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-
-/**
- * Provide configuration elements to the
- * {@link ACRA#init(android.app.Application)} method. The only mandatory
- * configuration item is the {@link #formUri()} parameter which is the Uri
- * to the server that will receive your reports.
- * 
- * @author Kevin Gaudin
- * 
- */
-@Documented
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE)
-@Inherited
-public @interface ReportsCrashes {
-
-    /**
-     * The Uri of your own server-side script that will receive reports. This is
-     * to use if you don't want to send reports to Google Docs but to your own,
-     * self-hosted script.
-     * 
-     * @return URI of a custom server to which to post reports.
-     */
-    String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * <p>
-     * The interaction mode you want to implement. Default is
-     * {@link ReportingInteractionMode#SILENT} which does not require any
-     * resources configuration.
-     * </p>
-     * <p>
-     * Other modes have resources requirements:
-     * </p>
-     * <ul>
-     * <li>{@link ReportingInteractionMode#TOAST} requires
-     * {@link #resToastText()} to be provided to define the text that you want
-     * to be displayed to the user when a report is being sent.</li>
-     * <li>{@link ReportingInteractionMode#NOTIFICATION} requires
-     * {@link #resNotifTickerText()}, {@link #resNotifTitle()},
-     * {@link #resNotifText()}, {@link #resDialogText()}.</li>
-     * <li>{@link ReportingInteractionMode#DIALOG} requires
-     * {@link #resDialogText()}.</li>
-     * </ul>
-     * <p>
-     * Default is {@link ReportingInteractionMode#SILENT}
-     * </p>
-     * 
-     * @return the interaction mode that you want ACRA to implement.
-     */
-    ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
-
-    /**
-     * @return Resource id for the label of positive button in the crash dialog.
-     *         If not provided, defaults to 'OK'.
-     */
-    int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
-
-    /**
-     * @return Resource id for the label of negative button in the crash dialog.
-     *         If not provided, defaults to 'cancel'.
-     */
-    int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
-
-    /**
-     * @return Resource id for the user comment input label in the crash dialog.
-     *         If not provided, disables the input field.
-     */
-    int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the user email address input label in the crash
-     *         dialog. If not provided, disables the input field.
-     */
-    int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the icon in the crash dialog. Default value is
-     *         the system alert icon.
-     */
-    int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
-
-    /**
-     * @return Resource id for the Toast text triggered when the user accepts to
-     *         send a report in the crash dialog.
-     */
-    int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the text in the crash dialog.
-     */
-    int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the title in the crash dialog.
-     */
-    int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the icon in the status bar notification. Default
-     *         is the system error notification icon.
-     */
-    int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
-
-    /**
-     * @return Resource id for the text in the status bar notification.
-     */
-    int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the ticker text in the status bar notification.
-     */
-    int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Resource id for the title in the status bar notification.
-     */
-    int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * Resource id for the Toast text triggered when the application crashes if
-     * the {@link ReportingInteractionMode#TOAST} mode is used. Can also be used
-     * in {@link ReportingInteractionMode#NOTIFICATION} and
-     * {@link ReportingInteractionMode#DIALOG} modes to display a Toast message
-     * while the report is being created, before the dialog/notification
-     * appears. This allows the user to know what is happening just before the
-     * application is terminated.
-     * 
-     * @return Resource id for the Toast text triggered when the application
-     *         crashes.
-     */
-    int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
-
-    /**
-     * @return Name of the SharedPreferences that will host ACRA settings you
-     *         can make accessible to your users through a preferences screen:
-     *         <ul>
-     *         <li>
-     *         {@link ACRA#PREF_DISABLE_ACRA} or {@link ACRA#PREF_ENABLE_ACRA}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ALWAYS_ACCEPT}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ENABLE_DEVICE_ID}</li>
-     *         <li>
-     *         {@link ACRA#PREF_ENABLE_SYSTEM_LOGS}</li>
-     *         </ul>
-     *         preference. Default is to use the application default
-     *         SharedPreferences, as retrieved with
-     *         {@link PreferenceManager#getDefaultSharedPreferences(Context)}.
-     */
-    String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * If using a custom {@link ReportsCrashes#sharedPreferencesName()}, pass
-     * here the mode that you need for the SharedPreference file creation:
-     * {@link Context#MODE_PRIVATE}, {@link Context#MODE_WORLD_READABLE} or
-     * {@link Context#MODE_WORLD_WRITEABLE}. Default is
-     * {@link Context#MODE_PRIVATE}.
-     * 
-     * @return Mode to use with the SharedPreference creation.
-     * @see Context#getSharedPreferences(String, int)
-     */
-    int sharedPreferencesMode() default ACRAConstants.DEFAULT_SHARED_PREFERENCES_MODE;
-
-    /**
-     * If enabled, DropBox events collection will include system tags:
-     * <ul>
-     * <li>system_app_anr</li>
-     * <li>system_app_wtf</li>
-     * <li>system_app_crash</li>
-     * <li>system_server_anr</li>
-     * <li>system_server_wtf</li>
-     * <li>system_server_crash</li>
-     * <li>BATTERY_DISCHARGE_INFO</li>
-     * <li>SYSTEM_RECOVERY_LOG</li>
-     * <li>SYSTEM_BOOT</li>
-     * <li>SYSTEM_LAST_KMSG</li>
-     * <li>APANIC_CONSOLE</li>
-     * <li>APANIC_THREADS</li>
-     * <li>SYSTEM_RESTART</li>
-     * <li>SYSTEM_TOMBSTONE</li>
-     * <li>data_app_strictmode</li>
-     * </ul>
-     * 
-     * @return True if system tags are to be included as part of DropBox events.
-     */
-    boolean includeDropBoxSystemTags() default ACRAConstants.DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
-
-    /**
-     * @return Array of tags that you want to be fetched when collecting DropBox
-     *         entries.
-     */
-    String[] additionalDropBoxTags() default {};
-
-    /**
-     * @return Number of minutes to look back when collecting events from
-     *         DropBoxManager.
-     */
-    int dropboxCollectionMinutes() default ACRAConstants.DEFAULT_DROPBOX_COLLECTION_MINUTES;
-
-    /**
-     * <p>
-     * Arguments to be passed to the logcat command line. Default is { "-t",
-     * "100", "-v", "time" } for:
-     * </p>
-     * 
-     * <pre>
-     * logcat -t 100 -v time
-     * </pre>
-     * 
-     * <p>
-     * Do not include -b arguments for buffer selection, include
-     * {@link ReportField#EVENTSLOG} and {@link ReportField#RADIOLOG} in
-     * {@link ReportsCrashes#customReportContent()} to activate alternative
-     * logcat buffers reporting. They will use the same other arguments as those
-     * provided here.
-     * </p>
-     * 
-     * <p>
-     * See <a href=
-     * "http://developer.android.com/intl/fr/guide/developing/tools/adb.html#logcatoptions"
-     * >Listing of logcat Command Options</a>.
-     * </p>
-     * 
-     * @return Array of arguments to supply if retrieving the log as part of the
-     *         report.
-     */
-    String[] logcatArguments() default { "-t", "" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time" };
-
-    /**
-     * When using the {@link #formUri()} parameter to send reports to a custom
-     * server-side script, you can set here and in
-     * {@link #formUriBasicAuthPassword()} the credentials for a BASIC HTTP
-     * authentication.
-     * 
-     * @return Login to use when posting reports to a custom server.
-     */
-    String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
-
-    /**
-     * When using the {@link #formUri()} parameter to send reports to a custom
-     * server-side script, you can set here and in
-     * {@link #formUriBasicAuthLogin()} the credentials for a BASIC HTTP
-     * authentication.
-     * 
-     * @return Password to use when posting reports to a custom server.
-     */
-    String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
-
-    /**
-     * <p>
-     * Redefines the list of {@link ReportField}s collected and sent in your
-     * reports. If you modify this list, you have to create a new Google Drive
-     * Spreadsheet &amp; Form which will be based on these fields as column headers.
-     * </p>
-     * <p>
-     * The fields order is significant. You can also use this property to modify
-     * fields order in your reports.
-     * </p>
-     * <p>
-     * The default list is the following, except if you send reports by mail
-     * using {@link #mailTo()}.
-     * </p>
-     * <ul>
-     * <li>
-     * {@link ReportField#REPORT_ID}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_CODE}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_NAME}</li>
-     * <li>
-     * {@link ReportField#PACKAGE_NAME}</li>
-     * <li>
-     * {@link ReportField#FILE_PATH}</li>
-     * <li>
-     * {@link ReportField#PHONE_MODEL}</li>
-     * <li>
-     * {@link ReportField#BRAND}</li>
-     * <li>
-     * {@link ReportField#PRODUCT}</li>
-     * <li>
-     * {@link ReportField#ANDROID_VERSION}</li>
-     * <li>
-     * {@link ReportField#BUILD}</li>
-     * <li>
-     * {@link ReportField#TOTAL_MEM_SIZE}</li>
-     * <li>
-     * {@link ReportField#AVAILABLE_MEM_SIZE}</li>
-     * <li>
-     * {@link ReportField#CUSTOM_DATA}</li>
-     * <li>
-     * {@link ReportField#IS_SILENT}</li>
-     * <li>
-     * {@link ReportField#STACK_TRACE}</li>
-     * <li>
-     * {@link ReportField#INITIAL_CONFIGURATION}</li>
-     * <li>
-     * {@link ReportField#CRASH_CONFIGURATION}</li>
-     * <li>
-     * {@link ReportField#DISPLAY}</li>
-     * <li>
-     * {@link ReportField#USER_COMMENT}</li>
-     * <li>
-     * {@link ReportField#USER_EMAIL}</li>
-     * <li>
-     * {@link ReportField#USER_APP_START_DATE}</li>
-     * <li>
-     * {@link ReportField#USER_CRASH_DATE}</li>
-     * <li>
-     * {@link ReportField#DUMPSYS_MEMINFO}</li>
-     * <li>
-     * {@link ReportField#LOGCAT}</li>
-     * <li>
-     * {@link ReportField#INSTALLATION_ID}</li>
-     * <li>
-     * {@link ReportField#DEVICE_FEATURES}</li>
-     * <li>
-     * {@link ReportField#ENVIRONMENT}</li>
-     * <li>
-     * {@link ReportField#SHARED_PREFERENCES}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_SYSTEM}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_SECURE}</li>
-     * <li>
-     * {@link ReportField#SETTINGS_GLOBAL}</li>
-     * </ul>
-     * 
-     * @return ReportField Array listing the fields to be included in the
-     *         report.
-     */
-    ReportField[] customReportContent() default {};
-
-    /**
-     * <p>
-     * Add your crash reports mailbox here if you want to send reports via
-     * email. This allows to get rid of the INTERNET permission. Reports content
-     * can be customized with {@link #customReportContent()} . Default fields
-     * are:
-     * </p>
-     * <ul>
-     * <li>
-     * {@link ReportField#USER_COMMENT}</li>
-     * <li>
-     * {@link ReportField#ANDROID_VERSION}</li>
-     * <li>
-     * {@link ReportField#APP_VERSION_NAME}</li>
-     * <li>
-     * {@link ReportField#BRAND}</li>
-     * <li>
-     * {@link ReportField#PHONE_MODEL}</li>
-     * <li>
-     * {@link ReportField#CUSTOM_DATA}</li>
-     * <li>
-     * {@link ReportField#STACK_TRACE}</li>
-     * </ul>
-     * 
-     * @return email address to which to send reports.
-     */
-    String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
-
-    /**
-     * Controls whether unapproved reports are deleted on application start or
-     * not. Default is true. This is a change from versions of ACRA before 3.2
-     * as in {@link ReportingInteractionMode#NOTIFICATION} mode reports were
-     * previously kept until the user explicitly opens the Notification dialog
-     * AND choose to send or discard the report. Until then, on application
-     * restart, ACRA was issuing a new crash notification for previous reports
-     * pending for approval. This could be misunderstood by the user with a new
-     * crash, resulting in bad appreciation of the application.
-     * 
-     * @return true if ACRA should delete unapproved reports on application
-     *         start.
-     */
-    boolean deleteUnapprovedReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
-
-    /**
-     * This property can be used to determine whether old (out of date) reports
-     * should be sent or not. By default they are discarded.
-     * 
-     * @return true if ACRA should delete any unsent reports on startup if the
-     *         application has been updated since the last time the application
-     *         was started.
-     */
-    boolean deleteOldUnsentReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
-
-    /**
-     * @return Value in milliseconds for timeout attempting to connect to a
-     *         network (default 3000ms).
-     */
-    int connectionTimeout() default ACRAConstants.DEFAULT_CONNECTION_TIMEOUT;
-
-    /**
-     * If the request is retried due to timeout, the socketTimeout will double
-     * before retrying the request.
-     * 
-     * @return Value in milliseconds for timeout receiving a response to a
-     *         network request (default 5000ms).
-     * @see #maxNumberOfRequestRetries()
-     */
-    int socketTimeout() default ACRAConstants.DEFAULT_SOCKET_TIMEOUT;
-
-    /**
-     * @return Maximum number of times a network request will be retried when
-     *         receiving the response times out (default 3).
-     * @see #socketTimeout()
-     */
-    int maxNumberOfRequestRetries() default ACRAConstants.DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
-
-    /**
-     * In {@link ReportingInteractionMode#TOAST} mode, set this to true if you
-     * prefer displaying the native Force Close dialog after the Toast.
-     * 
-     * @return true if the Force Close dialog has to be displayed.
-     */
-    boolean forceCloseDialogAfterToast() default ACRAConstants.DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
-
-    /**
-     * Add here your {@link SharedPreferences} identifier Strings if you use
-     * others than your application's default. They will be added to the
-     * {@link ReportField#SHARED_PREFERENCES} field.
-     * 
-     * @return String Array containing the names of the additional preferences.
-     */
-    String[] additionalSharedPreferences() default {};
-
-    /**
-     * Set this to true if you want to include only logcat lines related to your
-     * Application process.
-     * 
-     * @return true if you want to filter logcat with your process id.
-     */
-    boolean logcatFilterByPid() default ACRAConstants.DEFAULT_LOGCAT_FILTER_BY_PID;
-
-    /**
-     * Set this to false if you want to disable sending reports in development
-     * mode. Only signed application packages will send reports. Default value
-     * is true.
-     * 
-     * @return false if reports should not be sent.
-     */
-    boolean sendReportsInDevMode() default ACRAConstants.DEFAULT_SEND_REPORTS_IN_DEV_MODE;
-
-    /**
-     * Set this to false if you want to disable sending reports at the time the
-     * exception is caught. In this case, reports will not be sent until the
-     * application is restarted.
-     *
-     * @return false if reports should not be sent.
-     */
-    boolean sendReportsAtShutdown() default ACRAConstants.DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
-
-    /**
-     * Provide here regex patterns to be evaluated on each SharedPreference key
-     * to exclude KV pairs from the collected SharedPreferences. This allows you
-     * to exclude sensitive user data like passwords to be collected.
-     * 
-     * @return an array of regex patterns, every matching key is not collected.
-     */
-    String[] excludeMatchingSharedPreferencesKeys() default {};
-
-    /**
-     * Provide here regex patterns to be evaluated on each Settings.System,
-     * Settings.Secure and Settings.Global key to exclude KV pairs from the
-     * collected SharedPreferences. This allows you to exclude sensitive data to
-     * be collected.
-     * 
-     * @return an array of regex patterns, every matching key is not collected.
-     */
-    String[] excludeMatchingSettingsKeys() default {};
-
-    /**
-     * The default value will be a BuildConfig class residing in the same package as the Application class.
-     *
-     * @return BuildConfig class from which to read any BuildConfig attributes.
-     */
-    Class buildConfigClass() default Object.class;
-
-    /**
-     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
-     * path/name of your application log file. If the string does not contain
-     * any path separator, the file is assumed as being in
-     * {@link Context#getFilesDir()}.
-     * 
-     * @return a String containing the path/name of your application log file.
-     *         If the string does not containt any path separator, the file is
-     *         assumed as being in {@link Context#getFilesDir()}.
-     */
-    String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
-
-    /**
-     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
-     * number of latest lines of your application log file to be collected.
-     * Default value is 100.
-     * 
-     * @return number of lines to collect.
-     */
-    int applicationLogFileLines() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE_LINES;
-
-    /**
-     * <p>
-     * Set this to true if you need to post reports to your own server using an
-     * SSL connection with a self-signed certificate.
-     * </p>
-     * 
-     * @return True if SSL certificates validation has to be ignored when
-     *         posting reports.
-     */
-    boolean disableSSLCertValidation() default ACRAConstants.DEFAULT_DISABLE_SSL_CERT_VALIDATION;
-
-    String httpsSocketFactoryFactoryClass() default ACRAConstants.DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS;
-
-    /**
-     * @return Class for the CrashReportDialog used when sending intent.
-     *  If not provided, defaults to CrashReportDialog.class
-     */
-    Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
-
-    /**
-     * <p>
-     * The {@link Method} to be used when posting with {@link #formUri()}.
-     * </p>
-     *
-     * @return HTTP method used when posting reports.
-     */
-    Method httpMethod() default Method.POST;
-
-    Type reportType() default Type.FORM;
-}
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.annotation;
+
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.RawRes;
+import android.support.annotation.StringRes;
+import android.support.annotation.StyleRes;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.ReportingInteractionMode;
+import org.acra.attachment.AttachmentUriProvider;
+import org.acra.attachment.DefaultAttachmentProvider;
+import org.acra.builder.NoOpReportPrimer;
+import org.acra.builder.ReportPrimer;
+import org.acra.config.DefaultRetryPolicy;
+import org.acra.config.RetryPolicy;
+import org.acra.dialog.BaseCrashReportDialog;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.file.Directory;
+import org.acra.security.KeyStoreFactory;
+import org.acra.security.NoKeyStoreFactory;
+import org.acra.sender.DefaultReportSenderFactory;
+import org.acra.sender.HttpSender;
+import org.acra.sender.ReportSenderFactory;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Provide configuration elements to the
+ * {@link ACRA#init(android.app.Application)} method.
+ *
+ * @author Kevin Gaudin
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Inherited
+@Configuration
+public @interface ReportsCrashes {
+
+    /**
+     * The Uri of your own server-side script that will receive reports.
+     *
+     * @return URI of a custom server to which to post reports.
+     */
+    @NonNull String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+    /**
+     * <p>
+     * The interaction mode you want to implement. Default is
+     * {@link ReportingInteractionMode#SILENT} which does not require any
+     * resources configuration.
+     * </p>
+     * <p>
+     * Other modes have resources requirements:
+     * </p>
+     * <ul>
+     * <li>{@link ReportingInteractionMode#TOAST} requires
+     * {@link #resToastText()} to be provided to define the text that you want
+     * to be displayed to the user when a report is being sent.</li>
+     * <li>{@link ReportingInteractionMode#NOTIFICATION} requires
+     * {@link #resNotifTickerText()}, {@link #resNotifTitle()},
+     * {@link #resNotifText()}, {@link #resDialogText()}.</li>
+     * <li>{@link ReportingInteractionMode#DIALOG} requires
+     * {@link #resDialogText()}.</li>
+     * </ul>
+     * <p>
+     * Default is {@link ReportingInteractionMode#SILENT}
+     * </p>
+     *
+     * @return the interaction mode that you want ACRA to implement.
+     */
+    @Name("reportingInteractionMode")
+    @NonNull ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
+
+    /**
+     * @return Resource id for the label of positive button in the crash dialog.
+     * If not provided, defaults to 'OK'.
+     */
+    @StringRes int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
+
+    /**
+     * @return Resource id for the label of negative button in the crash dialog.
+     * If not provided, defaults to 'cancel'.
+     */
+    @StringRes int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
+
+    /**
+     * @return Resource id for the user comment input label in the crash dialog.
+     * If not provided, disables the input field.
+     */
+    @StringRes int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the user email address input label in the crash
+     * dialog. If not provided, disables the input field.
+     */
+    @StringRes int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the icon in the crash dialog. Default value is
+     * the system alert icon.
+     */
+    @DrawableRes int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
+
+    /**
+     * @return Resource id for the Toast text triggered when the user accepts to
+     * send a report in the crash dialog.
+     */
+    @StringRes int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the text in the crash dialog.
+     */
+    @StringRes int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the title in the crash dialog.
+     */
+    @StringRes int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return resource id for the crash dialog theme
+     */
+    @StyleRes int resDialogTheme() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the icon in the status bar notification. Default
+     * is the system error notification icon.
+     */
+    @DrawableRes int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
+
+    /**
+     * @return Resource id for the text in the status bar notification.
+     */
+    @StringRes int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the ticker text in the status bar notification.
+     */
+    @StringRes int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Resource id for the title in the status bar notification.
+     */
+    @StringRes int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * Resource id for the Toast text triggered when the application crashes if
+     * the {@link ReportingInteractionMode#TOAST} mode is used. Can also be used
+     * in {@link ReportingInteractionMode#NOTIFICATION} and
+     * {@link ReportingInteractionMode#DIALOG} modes to display a Toast message
+     * while the report is being created, before the dialog/notification
+     * appears. This allows the user to know what is happening just before the
+     * application is terminated.
+     *
+     * @return Resource id for the Toast text triggered when the application
+     * crashes.
+     */
+    @StringRes int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return Name of the SharedPreferences that will host ACRA settings you
+     * can make accessible to your users through a preferences screen:
+     * <ul>
+     * <li>
+     * {@link org.acra.ACRA#PREF_DISABLE_ACRA} or {@link org.acra.ACRA#PREF_ENABLE_ACRA}</li>
+     * <li>
+     * {@link org.acra.ACRA#PREF_ALWAYS_ACCEPT}</li>
+     * <li>
+     * {@link org.acra.ACRA#PREF_ENABLE_DEVICE_ID}</li>
+     * <li>
+     * {@link org.acra.ACRA#PREF_ENABLE_SYSTEM_LOGS}</li>
+     * </ul>
+     * preference. Default is to use the application default
+     * SharedPreferences, as retrieved with
+     * {@link android.preference.PreferenceManager#getDefaultSharedPreferences(android.content.Context)}.
+     */
+    @NonNull String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+    /**
+     * If using a custom {@link ReportsCrashes#sharedPreferencesName()}, pass
+     * here the mode that you need for the SharedPreference file creation:
+     * {@link android.content.Context#MODE_PRIVATE}, {@link android.content.Context#MODE_WORLD_READABLE} or
+     * {@link android.content.Context#MODE_WORLD_WRITEABLE}. Default is
+     * {@link android.content.Context#MODE_PRIVATE}.
+     *
+     * @return Mode to use with the SharedPreference creation.
+     * @see android.content.Context#getSharedPreferences(String, int)
+     */
+    int sharedPreferencesMode() default ACRAConstants.DEFAULT_SHARED_PREFERENCES_MODE;
+
+    /**
+     * If enabled, DropBox events collection will include system tags:
+     * <ul>
+     * <li>system_app_anr</li>
+     * <li>system_app_wtf</li>
+     * <li>system_app_crash</li>
+     * <li>system_server_anr</li>
+     * <li>system_server_wtf</li>
+     * <li>system_server_crash</li>
+     * <li>BATTERY_DISCHARGE_INFO</li>
+     * <li>SYSTEM_RECOVERY_LOG</li>
+     * <li>SYSTEM_BOOT</li>
+     * <li>SYSTEM_LAST_KMSG</li>
+     * <li>APANIC_CONSOLE</li>
+     * <li>APANIC_THREADS</li>
+     * <li>SYSTEM_RESTART</li>
+     * <li>SYSTEM_TOMBSTONE</li>
+     * <li>data_app_strictmode</li>
+     * </ul>
+     *
+     * @return True if system tags are to be included as part of DropBox events.
+     */
+    boolean includeDropBoxSystemTags() default ACRAConstants.DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
+
+    /**
+     * @return Array of tags that you want to be fetched when collecting DropBox
+     * entries.
+     */
+    @NonNull String[] additionalDropBoxTags() default {};
+
+    /**
+     * @return Number of minutes to look back when collecting events from
+     * DropBoxManager.
+     */
+    int dropboxCollectionMinutes() default ACRAConstants.DEFAULT_DROPBOX_COLLECTION_MINUTES;
+
+    /**
+     * <p>
+     * Arguments to be passed to the logcat command line. Default is { "-t",
+     * "100", "-v", "time" } for:
+     * </p>
+     * <pre>
+     * logcat -t 100 -v time
+     * </pre>
+     * <p>
+     * Do not include -b arguments for buffer selection, include
+     * {@link ReportField#EVENTSLOG} and {@link ReportField#RADIOLOG} in
+     * {@link ReportsCrashes#customReportContent()} to activate alternative
+     * logcat buffers reporting. They will use the same other arguments as those
+     * provided here.
+     * </p>
+     * <p>
+     * See <a href=
+     * "http://developer.android.com/intl/fr/guide/developing/tools/adb.html#logcatoptions"
+     * >Listing of logcat Command Options</a>.
+     * </p>
+     *
+     * @return Array of arguments to supply if retrieving the log as part of the
+     * report.
+     */
+    @NonNull String[] logcatArguments() default {"-t", "" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time"};
+
+    /**
+     * When using the {@link #formUri()} parameter to send reports to a custom
+     * server-side script, you can set here and in
+     * {@link #formUriBasicAuthPassword()} the credentials for a BASIC HTTP
+     * authentication.
+     *
+     * @return Login to use when posting reports to a custom server.
+     */
+    @NonNull String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
+
+    /**
+     * When using the {@link #formUri()} parameter to send reports to a custom
+     * server-side script, you can set here and in
+     * {@link #formUriBasicAuthLogin()} the credentials for a BASIC HTTP
+     * authentication.
+     *
+     * @return Password to use when posting reports to a custom server.
+     */
+    @NonNull String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
+
+    /**
+     * <p>
+     * Redefines the list of {@link ReportField}s collected and sent in your
+     * reports.
+     * </p>
+     * <p>
+     * The fields order is significant. You can also use this property to modify
+     * fields order in your reports.
+     * </p>
+     * <p>
+     * The default list is the following, except if you send reports by mail
+     * using {@link #mailTo()}.
+     * </p>
+     * <ul>
+     * <li>
+     * {@link ReportField#REPORT_ID}</li>
+     * <li>
+     * {@link ReportField#APP_VERSION_CODE}</li>
+     * <li>
+     * {@link ReportField#APP_VERSION_NAME}</li>
+     * <li>
+     * {@link ReportField#PACKAGE_NAME}</li>
+     * <li>
+     * {@link ReportField#FILE_PATH}</li>
+     * <li>
+     * {@link ReportField#PHONE_MODEL}</li>
+     * <li>
+     * {@link ReportField#BRAND}</li>
+     * <li>
+     * {@link ReportField#PRODUCT}</li>
+     * <li>
+     * {@link ReportField#ANDROID_VERSION}</li>
+     * <li>
+     * {@link ReportField#BUILD}</li>
+     * <li>
+     * {@link ReportField#TOTAL_MEM_SIZE}</li>
+     * <li>
+     * {@link ReportField#AVAILABLE_MEM_SIZE}</li>
+     * <li>
+     * {@link ReportField#CUSTOM_DATA}</li>
+     * <li>
+     * {@link ReportField#IS_SILENT}</li>
+     * <li>
+     * {@link ReportField#STACK_TRACE}</li>
+     * <li>
+     * {@link ReportField#INITIAL_CONFIGURATION}</li>
+     * <li>
+     * {@link ReportField#CRASH_CONFIGURATION}</li>
+     * <li>
+     * {@link ReportField#DISPLAY}</li>
+     * <li>
+     * {@link ReportField#USER_COMMENT}</li>
+     * <li>
+     * {@link ReportField#USER_EMAIL}</li>
+     * <li>
+     * {@link ReportField#USER_APP_START_DATE}</li>
+     * <li>
+     * {@link ReportField#USER_CRASH_DATE}</li>
+     * <li>
+     * {@link ReportField#DUMPSYS_MEMINFO}</li>
+     * <li>
+     * {@link ReportField#LOGCAT}</li>
+     * <li>
+     * {@link ReportField#INSTALLATION_ID}</li>
+     * <li>
+     * {@link ReportField#DEVICE_FEATURES}</li>
+     * <li>
+     * {@link ReportField#ENVIRONMENT}</li>
+     * <li>
+     * {@link ReportField#SHARED_PREFERENCES}</li>
+     * <li>
+     * {@link ReportField#SETTINGS_SYSTEM}</li>
+     * <li>
+     * {@link ReportField#SETTINGS_SECURE}</li>
+     * <li>
+     * {@link ReportField#SETTINGS_GLOBAL}</li>
+     * </ul>
+     *
+     * @return ReportField Array listing the fields to be included in the
+     * report.
+     */
+    @NonNull ReportField[] customReportContent() default {};
+
+    /**
+     * <p>
+     * Add your crash reports mailbox here if you want to send reports via
+     * email. This allows to get rid of the INTERNET permission. Reports content
+     * can be customized with {@link #customReportContent()} . Default fields
+     * are:
+     * </p>
+     * <ul>
+     * <li>
+     * {@link ReportField#USER_COMMENT}</li>
+     * <li>
+     * {@link ReportField#ANDROID_VERSION}</li>
+     * <li>
+     * {@link ReportField#APP_VERSION_NAME}</li>
+     * <li>
+     * {@link ReportField#BRAND}</li>
+     * <li>
+     * {@link ReportField#PHONE_MODEL}</li>
+     * <li>
+     * {@link ReportField#CUSTOM_DATA}</li>
+     * <li>
+     * {@link ReportField#STACK_TRACE}</li>
+     * </ul>
+     *
+     * @return email address to which to send reports.
+     */
+    @NonNull String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+    /**
+     * Controls whether unapproved reports are deleted on application start or not.
+     * Default is true.
+     * <p>
+     * Silent and Toast reports are automatically approved.
+     * Dialog and Notification reports required explicit approval by the user before they are sent.
+     * </p>
+     * <p>
+     * On application restart the user is prompted with approval for any unsent reports.
+     * So you generally don't want to accumulate unapproved reports, otherwise you will prompt them multiple times.
+     * </p>
+     * <p>
+     * If this is set to true then all unapproved reports bar one will be deleted on application start.
+     * The last report is always retained because that is the report that probably just happened.
+     * </p>
+     * <p>
+     * If set to false then on restart the user will be prompted with approval for each unapproved report.
+     * </p>
+     *
+     * @return true if ACRA should delete unapproved reports on application start.
+     */
+    boolean deleteUnapprovedReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
+
+    /**
+     * This property can be used to determine whether old (out of date) reports
+     * should be sent or not. By default they are discarded.
+     *
+     * @return true if ACRA should delete any unsent reports on startup if the
+     * application has been updated since the last time the application
+     * was started.
+     */
+    boolean deleteOldUnsentReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
+
+    /**
+     * @return Value in milliseconds for timeout attempting to connect to a network (default 5000ms).
+     */
+    int connectionTimeout() default ACRAConstants.DEFAULT_CONNECTION_TIMEOUT;
+
+    /**
+     * If the request is retried due to timeout, the socketTimeout will double
+     * before retrying the request.
+     *
+     * @return Value in milliseconds for timeout receiving a response to a network request (default 8000ms).
+     */
+    int socketTimeout() default ACRAConstants.DEFAULT_SOCKET_TIMEOUT;
+
+    /**
+     * Set this to true if you prefer displaying the native force close dialog after the ACRA is done.
+     * Recommended: Keep this set to false if using {@link ReportingInteractionMode#DIALOG} for notification.
+     *
+     * @return true if the native force close dialog should be displayed.
+     */
+    boolean alsoReportToAndroidFramework() default ACRAConstants.DEFAULT_REPORT_TO_ANDROID_FRAMEWORK;
+
+    /**
+     * Add here your {@link android.content.SharedPreferences} identifier Strings if you use
+     * others than your application's default. They will be added to the
+     * {@link ReportField#SHARED_PREFERENCES} field.
+     *
+     * @return String Array containing the names of the additional preferences.
+     */
+    @NonNull String[] additionalSharedPreferences() default {};
+
+    /**
+     * Set this to true if you want to include only logcat lines related to your
+     * Application process.
+     *
+     * @return true if you want to filter logcat with your process id.
+     */
+    boolean logcatFilterByPid() default ACRAConstants.DEFAULT_LOGCAT_FILTER_BY_PID;
+
+    /**
+     * Set this to true if you want to read logcat lines in a non blocking way for your
+     * thread. It has a default timeout of 3 seconds.
+     *
+     * @return true if you want that reading of logcat lines to not block current thread.
+     */
+    boolean nonBlockingReadForLogcat() default ACRAConstants.DEFAULT_NON_BLOCKING_READ_FOR_LOGCAT;
+
+    /**
+     * Set this to false if you want to disable sending reports in development
+     * mode. Only signed application packages will send reports. Default value
+     * is true.
+     *
+     * @return false if reports should not be sent.
+     */
+    boolean sendReportsInDevMode() default ACRAConstants.DEFAULT_SEND_REPORTS_IN_DEV_MODE;
+
+    /**
+     * @return true.
+     * @deprecated since 4.8.3 no replacement. Now that we are using the SenderService in a separate process we always send at shutdown.
+     */
+    @Deprecated
+    boolean sendReportsAtShutdown() default true;
+
+    /**
+     * Provide here regex patterns to be evaluated on each SharedPreference key
+     * to exclude KV pairs from the collected SharedPreferences. This allows you
+     * to exclude sensitive user data like passwords to be collected.
+     *
+     * @return an array of regex patterns, every matching key is not collected.
+     */
+    @NonNull String[] excludeMatchingSharedPreferencesKeys() default {};
+
+    /**
+     * Provide here regex patterns to be evaluated on each Settings.System,
+     * Settings.Secure and Settings.Global key to exclude KV pairs from the
+     * collected SharedPreferences. This allows you to exclude sensitive data to
+     * be collected.
+     *
+     * @return an array of regex patterns, every matching key is not collected.
+     */
+    @NonNull String[] excludeMatchingSettingsKeys() default {};
+
+    /**
+     * The default value will be a BuildConfig class residing in the same package as the Application class.
+     *
+     * @return BuildConfig class from which to read any BuildConfig attributes.
+     */
+    @NonNull Class buildConfigClass() default Object.class;
+
+    /**
+     * The default {@link org.acra.sender.ReportSenderFactory} creates an {@link org.acra.sender.EmailIntentSender}
+     * if the 'mailTo' parameter is defined or an {@link org.acra.sender.HttpSender} if the 'formUri' parameter
+     * is defined (and internet permission has been granted.
+     *
+     * @return List of the {@link org.acra.sender.ReportSenderFactory} with which to construct the
+     * {@link org.acra.sender.ReportSender}s that will send the crash reports.
+     */
+    @NonNull Class<? extends ReportSenderFactory>[] reportSenderFactoryClasses() default {DefaultReportSenderFactory.class};
+
+    /**
+     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
+     * path/name of your application log file. If the string does not contain
+     * any path separator, the file is assumed as being in
+     * {@link android.content.Context#getFilesDir()}.
+     *
+     * @return a String containing the path/name of your application log file.
+     * If the string does not contain any path separator, the file is
+     * assumed as being in {@link android.content.Context#getFilesDir()}.
+     */
+    @NonNull String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
+
+    /**
+     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
+     * number of latest lines of your application log file to be collected.
+     * Default value is 100.
+     *
+     * @return number of lines to collect.
+     */
+    int applicationLogFileLines() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE_LINES;
+
+    /**
+     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the root
+     * for the path provided in {@link #applicationLogFile()}
+     *
+     * @return the directory of the application log file
+     */
+    @NonNull Directory applicationLogFileDir() default Directory.FILES_LEGACY;
+
+    /**
+     * @return Class for the CrashReportDialog used when prompting the user for crash details.
+     * If not provided, defaults to CrashReportDialog.class
+     */
+    @NonNull Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
+
+    /**
+     * @return Class that is ued to provide any extra details for a crash.
+     */
+    @NonNull Class<? extends ReportPrimer> reportPrimerClass() default NoOpReportPrimer.class;
+
+    /**
+     * <p>
+     * The {@link HttpSender.Method} to be used when posting with {@link #formUri()}.
+     * </p>
+     *
+     * @return HTTP method used when posting reports.
+     */
+    @NonNull HttpSender.Method httpMethod() default HttpSender.Method.POST;
+
+    /**
+     * <p>
+     * The {@link HttpSender.Type} to be used when posting with {@link #formUri()}.
+     * </p>
+     *
+     * @return the report type used when posting reports
+     */
+    @NonNull HttpSender.Type reportType() default HttpSender.Type.FORM;
+
+    /**
+     * @return Class which creates a keystore that can contain trusted certificates
+     */
+    @NonNull Class<? extends KeyStoreFactory> keyStoreFactoryClass() default NoKeyStoreFactory.class;
+
+    /**
+     * @return path to a custom trusted certificate. Must start with "asset://" if the file is in the assets folder
+     */
+    @NonNull String certificatePath() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+    /**
+     * @return resource id of a custom trusted certificate.
+     */
+    @RawRes int resCertificate() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     * @return specify the type of the certificate set in either {@link #certificatePath()} or {@link #resCertificate()}
+     */
+    @NonNull String certificateType() default ACRAConstants.DEFAULT_CERTIFICATE_TYPE;
+
+    /**
+     * @return a Class that decides if a report should be resent (usually if one or more senders failed).
+     * @since 4.9.1
+     */
+    @NonNull Class<? extends RetryPolicy> retryPolicyClass() default DefaultRetryPolicy.class;
+
+    /**
+     * @return true if all services running in a process should be stopped before it is killed.
+     * @since 4.9.2
+     */
+    boolean stopServicesOnCrash() default false;
+
+    /**
+     * Allows to attach files to crash reports.
+     * <p>
+     * ACRA contains a file provider under the following Uri:
+     * content://[applicationId].acra/[Directory]/[Path]
+     * where [applicationId] is your application package name,
+     * [Directory] is one of the enum constants in {@link Directory} in lower case
+     * and [Path] is the relative path to the file in that directory
+     * e.g. content://org.acra.provider/files/thisIsATest.txt
+     * </p>
+     * Side effects:
+     * <ul>
+     * <li>POST mode: requests will be sent with content-type multipart/mixed</li>
+     * <li>PUT mode: There will be additional requests with the attachments. Naming scheme: [report-id]-[filename] </li>
+     * <li>EMAIL mode: Some email clients do not support attachments, so some email may lack these attachments.
+     * Note that attachments will be readable to email clients when they are sent.</li>
+     * </ul>
+     *
+     * @return uris to be attached to crash reports.
+     * @since 4.9.3
+     */
+    @NonNull String[] attachmentUris() default {};
+
+    /**
+     * Allows attachmentUri configuration at runtime instead of compile time.
+     *
+     * @return a class that decides which uris should be attached to reports
+     * @since 4.9.3
+     */
+    @NonNull Class<? extends AttachmentUriProvider> attachmentUriProvider() default DefaultAttachmentProvider.class;
+
+    /**
+     * @return if the report should be an attachment instead of plain text. Supported for email mode.
+     */
+    boolean reportAsFile() default false;
+}
diff --git a/acra/src/main/java/org/acra/attachment/AcraContentProvider.java b/acra/src/main/java/org/acra/attachment/AcraContentProvider.java
new file mode 100644
index 00000000..2ca4c356
--- /dev/null
+++ b/acra/src/main/java/org/acra/attachment/AcraContentProvider.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.attachment;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import org.acra.ACRA;
+import org.acra.file.Directory;
+import org.acra.http.HttpUtils;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 13.03.2017
+ */
+
+public class AcraContentProvider extends ContentProvider {
+    private static final String[] COLUMNS = {
+            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE};
+    private String authority;
+
+    @Override
+    public boolean onCreate() {
+        //noinspection ConstantConditions
+        authority = getAuthority(getContext());
+        if (ACRA.DEV_LOGGING) ACRA.log.d(ACRA.LOG_TAG, "Registered content provider for authority " + authority);
+        return true;
+    }
+
+    @Nullable
+    @Override
+    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(ACRA.LOG_TAG, "Query: " + uri);
+        final File file = getFileForUri(uri);
+        if (file == null) {
+            return null;
+        }
+        if (projection == null) {
+            projection = COLUMNS;
+        }
+        final Map<String, Object> columnValueMap = new LinkedHashMap<String, Object>();
+        for (String column : projection) {
+            if (column.equals(OpenableColumns.DISPLAY_NAME)) {
+                columnValueMap.put(OpenableColumns.DISPLAY_NAME, file.getName());
+            } else if (column.equals(OpenableColumns.SIZE)) {
+                columnValueMap.put(OpenableColumns.SIZE, file.length());
+            }
+        }
+        final MatrixCursor cursor = new MatrixCursor(columnValueMap.keySet().toArray(new String[columnValueMap.size()]), 1);
+        cursor.addRow(columnValueMap.values());
+        return cursor;
+    }
+
+    @Nullable
+    private File getFileForUri(Uri uri) {
+        if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) || !authority.equals(uri.getAuthority())) {
+            return null;
+        }
+        final List<String> segments = new ArrayList<String>(uri.getPathSegments());
+        if (segments.size() < 2) return null;
+        final String dir = segments.remove(0).toUpperCase();
+        try {
+            final Directory directory = Directory.valueOf(dir);
+            //noinspection ConstantConditions
+            return directory.getFile(getContext(), TextUtils.join(File.separator, segments));
+        } catch (IllegalArgumentException e) {
+            return null;
+        }
+    }
+
+    @Nullable
+    @Override
+    public String getType(@NonNull Uri uri) {
+        return HttpUtils.guessMimeType(uri);
+    }
+
+    @Nullable
+    @Override
+    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
+        throw new UnsupportedOperationException("No insert supported");
+    }
+
+    @Override
+    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
+        throw new UnsupportedOperationException("No delete supported");
+    }
+
+    @Override
+    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
+        throw new UnsupportedOperationException("No update supported");
+    }
+
+    @Nullable
+    @Override
+    public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {
+        final File file = getFileForUri(uri);
+        if (file == null || !file.exists()) throw new FileNotFoundException("File represented by uri " + uri + " could not be found");
+        if (ACRA.DEV_LOGGING) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+                ACRA.log.d(ACRA.LOG_TAG, getCallingPackage() + " opened " + file.getPath());
+            } else {
+                ACRA.log.d(ACRA.LOG_TAG, file.getPath() + " was opened by an application");
+            }
+        }
+        return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+    }
+
+    private static String getAuthority(@NonNull Context context) {
+        return context.getPackageName() + ".acra";
+    }
+
+    /**
+     * Get an uri for this content provider for the given file
+     *
+     * @param context a context
+     * @param file    the file
+     * @return the uri
+     */
+    public static Uri getUriForFile(@NonNull Context context, @NonNull File file) {
+        return getUriForFile(context, Directory.ROOT, file.getPath());
+    }
+
+    /**
+     * Get an uri for this content provider for the given file
+     *
+     * @param context      a context
+     * @param directory    the directory, to with the path is relative
+     * @param relativePath the file path
+     * @return the uri
+     */
+    public static Uri getUriForFile(@NonNull Context context, @NonNull Directory directory, @NonNull String relativePath) {
+        return new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_CONTENT)
+                .authority(getAuthority(context))
+                .path(directory.name().toLowerCase() + (relativePath.charAt(0) == File.separatorChar ? "" : File.separator) + relativePath)
+                .build();
+    }
+}
diff --git a/acra/src/main/java/org/acra/attachment/AttachmentUriProvider.java b/acra/src/main/java/org/acra/attachment/AttachmentUriProvider.java
new file mode 100644
index 00000000..c1514de7
--- /dev/null
+++ b/acra/src/main/java/org/acra/attachment/AttachmentUriProvider.java
@@ -0,0 +1,20 @@
+package org.acra.attachment;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import org.acra.config.ACRAConfiguration;
+
+import java.util.List;
+
+/**
+ * @author F43nd1r
+ * @since 09.03.2017
+ */
+
+public interface AttachmentUriProvider {
+
+    @NonNull
+    List<Uri> getAttachments(Context context, ACRAConfiguration configuration);
+}
diff --git a/acra/src/main/java/org/acra/attachment/DefaultAttachmentProvider.java b/acra/src/main/java/org/acra/attachment/DefaultAttachmentProvider.java
new file mode 100644
index 00000000..178af90e
--- /dev/null
+++ b/acra/src/main/java/org/acra/attachment/DefaultAttachmentProvider.java
@@ -0,0 +1,34 @@
+package org.acra.attachment;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.config.ACRAConfiguration;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author F43nd1r
+ * @since 10.03.2017
+ */
+
+public class DefaultAttachmentProvider implements AttachmentUriProvider {
+    @NonNull
+    @Override
+    public List<Uri> getAttachments(Context context, ACRAConfiguration configuration) {
+        final ArrayList<Uri> result = new ArrayList<Uri>();
+        for (String s : configuration.attachmentUris()){
+            try {
+                result.add(Uri.parse(s));
+            }catch (Exception e){
+                ACRA.log.e(LOG_TAG, "Failed to parse Uri " + s, e);
+            }
+        }
+        return result;
+    }
+}
diff --git a/acra/src/main/java/org/acra/builder/LastActivityManager.java b/acra/src/main/java/org/acra/builder/LastActivityManager.java
new file mode 100644
index 00000000..83f1c8f9
--- /dev/null
+++ b/acra/src/main/java/org/acra/builder/LastActivityManager.java
@@ -0,0 +1,95 @@
+package org.acra.builder;
+
+import android.app.Activity;
+import android.app.Application;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.dialog.BaseCrashReportDialog;
+
+import java.lang.ref.WeakReference;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Responsible for tracking the last Activity other than any CrashReport dialog that was created.
+ *
+ * @since 4.8.0
+ */
+public final class LastActivityManager {
+
+    @NonNull
+    private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(null);
+
+    public LastActivityManager(@NonNull Application application) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+
+            // ActivityLifecycleCallback only available for API14+
+            application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
+                @Override
+                public void onActivityCreated(@NonNull Activity activity, Bundle savedInstanceState) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityCreated " + activity.getClass());
+                    if (!(activity instanceof BaseCrashReportDialog)) {
+                        // Ignore CrashReportDialog because we want the last
+                        // application Activity that was started so that we can explicitly kill it off.
+                        lastActivityCreated = new WeakReference<Activity>(activity);
+                    }
+                }
+
+                @Override
+                public void onActivityStarted(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityStarted " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityResumed(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityResumed " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityPaused(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityPaused " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityStopped(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityStopped " + activity.getClass());
+                    synchronized (this){
+                        notify();
+                    }
+                }
+
+                @Override
+                public void onActivitySaveInstanceState(@NonNull Activity activity, Bundle outState) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivitySaveInstanceState " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityDestroyed(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityDestroyed " + activity.getClass());
+                }
+            });
+        }
+    }
+
+    @Nullable
+    public Activity getLastActivity() {
+        return lastActivityCreated.get();
+    }
+
+    public void clearLastActivity() {
+        lastActivityCreated.clear();
+    }
+
+    public void waitForActivityStop(int timeOutInMillis){
+        synchronized (this) {
+            try {
+                wait(timeOutInMillis);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/builder/NoOpReportPrimer.java b/acra/src/main/java/org/acra/builder/NoOpReportPrimer.java
new file mode 100644
index 00000000..586ac940
--- /dev/null
+++ b/acra/src/main/java/org/acra/builder/NoOpReportPrimer.java
@@ -0,0 +1,16 @@
+package org.acra.builder;
+
+import android.content.Context;
+
+/**
+ * Does not perform any priming for the current report.
+ *
+ * @since 4.8.0
+ */
+public final class NoOpReportPrimer implements ReportPrimer {
+
+    @Override
+    public void primeReport(Context context, ReportBuilder builder) {
+        // Nothing to do.
+    }
+}
diff --git a/acra/src/main/java/org/acra/builder/ReportBuilder.java b/acra/src/main/java/org/acra/builder/ReportBuilder.java
new file mode 100644
index 00000000..fa892481
--- /dev/null
+++ b/acra/src/main/java/org/acra/builder/ReportBuilder.java
@@ -0,0 +1,152 @@
+package org.acra.builder;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Fluent API used to assemble the different options used for a crash report.
+ *
+ * @since 4.8.0
+ */
+public final class ReportBuilder {
+
+    private String message;
+    private Thread uncaughtExceptionThread;
+    private Throwable exception;
+    private final Map<String, String> customData = new HashMap<String, String>();
+
+    private boolean sendSilently = false;
+    private boolean endApplication = false;
+
+    /**
+     * Set the error message to be reported.
+     *
+     * @param msg the error message
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings( "unused" )
+    public ReportBuilder message(@Nullable String msg) {
+        message = msg;
+        return this;
+    }
+
+    @Nullable
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the Thread on which an uncaught Exception occurred.
+     *
+     * @param thread    Thread on which an uncaught Exception occurred.
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder uncaughtExceptionThread(@Nullable Thread thread) {
+        uncaughtExceptionThread = thread;
+        return this;
+    }
+
+    @Nullable
+    public Thread getUncaughtExceptionThread() {
+        return uncaughtExceptionThread;
+    }
+
+    /**
+     * Set the stack trace to be reported
+     *
+     * @param e The exception that should be associated with this report
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder exception(@Nullable Throwable e) {
+        exception = e;
+        return this;
+    }
+
+    @Nullable
+    public Throwable getException() {
+        return exception;
+    }
+
+    /**
+     * Sets additional values to be added to {@code CUSTOM_DATA}. Values
+     * specified here take precedence over globally specified custom data.
+     *
+     * @param customData a map of custom key-values to be attached to the report
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings("unused")
+    public ReportBuilder customData(@NonNull Map<String, String> customData) {
+        this.customData.putAll(customData);
+        return this;
+    }
+
+    /**
+     * Sets an additional value to be added to {@code CUSTOM_DATA}. The value
+     * specified here takes precedence over globally specified custom data.
+     *
+     * @param key the key identifying the custom data
+     * @param value the value for the custom data entry
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings("unused")
+    public ReportBuilder customData(@NonNull String key, String value) {
+        customData.put(key, value);
+        return this;
+    }
+
+    @NonNull
+    public Map<String, String> getCustomData() {
+        return customData;
+    }
+
+    /**
+     * Forces the report to be sent silently, ignoring the default interaction mode set in the config
+     *
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder sendSilently() {
+        sendSilently = true;
+        return this;
+    }
+
+    public boolean isSendSilently() {
+        return sendSilently;
+    }
+
+    /**
+     * Ends the application after sending the crash report
+     *
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder endApplication() {
+        endApplication = true;
+        return this;
+    }
+
+    public boolean isEndApplication() {
+        return endApplication;
+    }
+
+    /**
+     * Assembles and sends the crash report.
+     *
+     * @param reportExecutor    ReportExecutor to use to build the report.
+     */
+    public void build(@NonNull ReportExecutor reportExecutor) {
+        if (message == null && exception == null) {
+            message = "Report requested by developer";
+        }
+
+        reportExecutor.execute(this);
+    }
+}
diff --git a/acra/src/main/java/org/acra/builder/ReportExecutor.java b/acra/src/main/java/org/acra/builder/ReportExecutor.java
new file mode 100644
index 00000000..4f6dfc8d
--- /dev/null
+++ b/acra/src/main/java/org/acra/builder/ReportExecutor.java
@@ -0,0 +1,380 @@
+package org.acra.builder;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Debug;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.NotificationCompat;
+import android.widget.Toast;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportingInteractionMode;
+import org.acra.collector.CrashReportData;
+import org.acra.collector.CrashReportDataFactory;
+import org.acra.config.ACRAConfiguration;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.file.CrashReportPersister;
+import org.acra.file.ReportLocator;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.sender.SenderServiceStarter;
+import org.acra.util.ProcessFinisher;
+import org.acra.util.ToastSender;
+
+import java.io.File;
+import java.util.Date;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.IS_SILENT;
+import static org.acra.ReportField.USER_CRASH_DATE;
+
+/**
+ * Collates, records and initiates the sending of a report.
+ *
+ * @since 4.8.0
+ */
+public final class ReportExecutor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final CrashReportDataFactory crashReportDataFactory;
+
+    // A reference to the system's previous default UncaughtExceptionHandler
+    // kept in order to execute the default exception handling after sending the report.
+    private final Thread.UncaughtExceptionHandler defaultExceptionHandler;
+
+    private final ReportPrimer reportPrimer;
+    private final ProcessFinisher processFinisher;
+
+    private boolean enabled = false;
+
+    /**
+     * Used to create a new (non-cached) PendingIntent each time a new crash occurs.
+     */
+    private static int mNotificationCounter = 0;
+
+    public ReportExecutor(@NonNull Context context, @NonNull ACRAConfiguration config,
+                          @NonNull CrashReportDataFactory crashReportDataFactory, @Nullable Thread.UncaughtExceptionHandler defaultExceptionHandler,
+                          @NonNull ReportPrimer reportPrimer, @NonNull ProcessFinisher processFinisher) {
+        this.context = context;
+        this.config = config;
+        this.crashReportDataFactory = crashReportDataFactory;
+        this.defaultExceptionHandler = defaultExceptionHandler;
+        this.reportPrimer = reportPrimer;
+        this.processFinisher = processFinisher;
+    }
+
+    /**
+     * Helps manage
+     */
+    private static class TimeHelper {
+
+        private Long initialTimeMillis;
+
+        public void setInitialTimeMillis(long initialTimeMillis) {
+            this.initialTimeMillis = initialTimeMillis;
+        }
+
+        /**
+         * @return 0 if the initial time has yet to be set otherwise returns the difference between now and the initial time.
+         */
+        public long getElapsedTime() {
+            return (initialTimeMillis == null) ? 0 : System.currentTimeMillis() - initialTimeMillis;
+        }
+    }
+
+    public void handReportToDefaultExceptionHandler(@Nullable Thread t, @NonNull Throwable e) {
+        if (defaultExceptionHandler != null) {
+            ACRA.log.i(LOG_TAG, "ACRA is disabled for " + context.getPackageName()
+                    + " - forwarding uncaught Exception on to default ExceptionHandler");
+            defaultExceptionHandler.uncaughtException(t, e);
+        } else {
+            ACRA.log.e(LOG_TAG, "ACRA is disabled for " + context.getPackageName() + " - no default ExceptionHandler");
+            ACRA.log.e(LOG_TAG, "ACRA caught a " + e.getClass().getSimpleName() + " for " + context.getPackageName(), e);
+        }
+
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    /**
+     * Try to send a report, if an error occurs stores a report file for a later attempt.
+     *
+     * @param reportBuilder The report builder used to assemble the report
+     */
+    public void execute(@NonNull final ReportBuilder reportBuilder) {
+
+        if (!enabled) {
+            ACRA.log.v(LOG_TAG, "ACRA is disabled. Report not sent.");
+            return;
+        }
+
+        // Prime this crash report with any extra data.
+        reportPrimer.primeReport(context, reportBuilder);
+
+        boolean sendOnlySilentReports = false;
+        final ReportingInteractionMode reportingInteractionMode;
+        if (!reportBuilder.isSendSilently()) {
+            // No interaction mode defined in the ReportBuilder, we assume it has been set during ACRA.initACRA()
+            reportingInteractionMode = config.reportingInteractionMode();
+        } else {
+            reportingInteractionMode = ReportingInteractionMode.SILENT;
+
+            // An interaction mode has been provided. If ACRA has been
+            // initialized with a non SILENT mode and this mode is overridden
+            // with SILENT, then we have to send only reports which have been
+            // explicitly declared as silent via handleSilentException().
+            if (config.reportingInteractionMode() != ReportingInteractionMode.SILENT) {
+                sendOnlySilentReports = true;
+            }
+        }
+
+        final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
+                || (config.resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
+
+        final TimeHelper sentToastTimeMillis = new TimeHelper();
+        if (shouldDisplayToast) {
+            new Thread() {
+
+                /*
+                 * (non-Javadoc)
+                 *
+                 * @see java.lang.Thread#run()
+                 */
+                @Override
+                public void run() {
+                    Looper.prepare();
+                    ToastSender.sendToast(context, config.resToastText(), Toast.LENGTH_LONG);
+                    sentToastTimeMillis.setInitialTimeMillis(System.currentTimeMillis());
+                    Looper.loop();
+                }
+
+            }.start();
+
+            // We will wait a few seconds at the end of the method to be sure
+            // that the Toast can be read by the user.
+        }
+
+        final CrashReportData crashReportData = crashReportDataFactory.createCrashData(reportBuilder);
+
+        // Always write the report file
+
+        final File reportFile = getReportFileName(crashReportData);
+        saveCrashReportFile(reportFile, crashReportData);
+
+        final SharedPreferences prefs = new SharedPreferencesFactory(context, config).create();
+        if (reportingInteractionMode == ReportingInteractionMode.SILENT
+                || reportingInteractionMode == ReportingInteractionMode.TOAST
+                || prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
+
+            // Approve and then send reports now
+            startSendingReports(sendOnlySilentReports);
+            if ((reportingInteractionMode == ReportingInteractionMode.SILENT) && !reportBuilder.isEndApplication()) {
+                // Report is being sent silently and the application is not ending.
+                // So no need to wait around for the sender to complete.
+                return;
+            }
+
+        } else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating Notification.");
+            createNotification(reportFile, reportBuilder);
+        }
+
+        final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG)
+                && !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
+
+        if (shouldDisplayToast) {
+            // A toast is being displayed, we have to wait for its end before doing anything else.
+            if (ACRA.DEV_LOGGING)
+                ACRA.log.d(LOG_TAG, "Waiting for " + ACRAConstants.TOAST_WAIT_DURATION
+                        + " millis from " + sentToastTimeMillis.initialTimeMillis
+                        + " currentMillis=" + System.currentTimeMillis());
+            final long sleep = ACRAConstants.TOAST_WAIT_DURATION - sentToastTimeMillis.getElapsedTime();
+            try {
+                // Wait a bit to let the user read the toast
+                if (sleep > 0L) Thread.sleep(sleep);
+            } catch (InterruptedException e1) {
+                if (ACRA.DEV_LOGGING)
+                    ACRA.log.d(LOG_TAG, "Interrupted while waiting for Toast to end.", e1);
+            }
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Finished waiting for Toast");
+        }
+        dialogAndEnd(reportBuilder, reportFile, showDirectDialog);
+    }
+
+    private void dialogAndEnd(@NonNull ReportBuilder reportBuilder, @NonNull File reportFile, boolean shouldShowDialog) {
+        if (shouldShowDialog) {
+            // Create a new activity task with the confirmation dialog.
+            // This new task will be persisted on application restart
+            // right after its death.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating CrashReportDialog for " + reportFile);
+            final Intent dialogIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+            dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            context.startActivity(dialogIntent);
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Wait for Toast + worker ended. Kill Application ? " + reportBuilder.isEndApplication());
+
+        if (reportBuilder.isEndApplication()) {
+            if (Debug.isDebuggerConnected()) {
+                //Killing a process with a debugger attached would kill the whole application, so don't do that.
+                final String warning = "Warning: Acra may behave differently with a debugger attached";
+                new Thread() {
+                    @Override
+                    public void run() {
+                        Looper.prepare();
+                        Toast.makeText(context, warning, Toast.LENGTH_LONG).show();
+                        Looper.loop();
+                    }
+                }.start();
+                ACRA.log.w(LOG_TAG, warning);
+                //do as much cleanup as we can without killing the process
+                processFinisher.finishLastActivity(reportBuilder.getUncaughtExceptionThread());
+            } else {
+                endApplication(reportBuilder.getUncaughtExceptionThread(), reportBuilder.getException());
+            }
+        }
+    }
+
+    /**
+     * End the application.
+     */
+    private void endApplication(@Nullable Thread uncaughtExceptionThread, Throwable th) {
+        final boolean letDefaultHandlerEndApplication = config.alsoReportToAndroidFramework();
+
+        final boolean handlingUncaughtException = uncaughtExceptionThread != null;
+        if (handlingUncaughtException && letDefaultHandlerEndApplication && defaultExceptionHandler != null) {
+            // Let the system default handler do it's job and display the force close dialog.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Handing Exception on to default ExceptionHandler");
+            defaultExceptionHandler.uncaughtException(uncaughtExceptionThread, th);
+        } else {
+            processFinisher.endApplication(uncaughtExceptionThread);
+        }
+    }
+
+    /**
+     * Starts a Thread to start sending outstanding error reports.
+     *
+     * @param onlySendSilentReports If true then only send silent reports.
+     */
+    private void startSendingReports(boolean onlySendSilentReports) {
+        if (enabled) {
+            final SenderServiceStarter starter = new SenderServiceStarter(context, config);
+            starter.startService(onlySendSilentReports, true);
+        } else {
+            ACRA.log.w(LOG_TAG, "Would be sending reports, but ACRA is disabled");
+        }
+    }
+
+    /**
+     * Creates a status bar notification.
+     *
+     * The action triggered when the notification is selected is to start the
+     * {@link CrashReportDialog} Activity.
+     *
+     * @param reportFile Report file to send.
+     */
+    private void createNotification(@NonNull File reportFile, @NonNull ReportBuilder reportBuilder) {
+
+        final NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        // Default notification icon is the warning symbol
+        final int icon = config.resNotifIcon();
+
+        final CharSequence tickerText = context.getText(config.resNotifTickerText());
+        final long when = System.currentTimeMillis();
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating Notification for " + reportFile);
+        final Intent crashReportDialogIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+        final PendingIntent contentIntent = PendingIntent.getActivity(context, mNotificationCounter++, crashReportDialogIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        final CharSequence contentTitle = context.getText(config.resNotifTitle());
+        final CharSequence contentText = context.getText(config.resNotifText());
+
+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(context);
+        final Notification notification = builder
+                .setSmallIcon(icon)
+                .setTicker(tickerText)
+                .setWhen(when)
+                .setAutoCancel(true)
+                .setContentTitle(contentTitle)
+                .setContentText(contentText)
+                .setContentIntent(contentIntent)
+                .build();
+
+        notification.flags |= Notification.FLAG_AUTO_CANCEL;
+
+        // The deleteIntent is invoked when the user swipes away the Notification.
+        // In this case we invoke the CrashReportDialog with EXTRA_FORCE_CANCEL==true
+        // which will cause BaseCrashReportDialog to clear the crash report and finish itself.
+        final Intent deleteIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+        deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
+        notification.deleteIntent = PendingIntent.getActivity(context, -1, deleteIntent, 0);
+
+        // Send new notification
+        notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
+    }
+
+    @NonNull
+    private File getReportFileName(@NonNull CrashReportData crashData) {
+        final String timestamp = crashData.getProperty(USER_CRASH_DATE);
+        final String isSilent = crashData.getProperty(IS_SILENT);
+        final String fileName = (timestamp != null ? timestamp : new Date().getTime()) // Need to check for null because old version of ACRA did not always capture USER_CRASH_DATE
+                + (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
+                + ACRAConstants.REPORTFILE_EXTENSION;
+        final ReportLocator reportLocator = new ReportLocator(context);
+        return new File(reportLocator.getUnapprovedFolder(), fileName);
+    }
+
+    /**
+     * When a report can't be sent, it is saved here in a file in the root of
+     * the application private directory.
+     *
+     * @param file      In a few rare cases, we write the report again with additional
+     *                  data (user comment for example). In such cases, you can
+     *                  provide the already existing file name here to overwrite the
+     *                  report file. If null, a new file report will be generated
+     * @param crashData Can be used to save an alternative (or previously generated)
+     *                  report data. Used to store again a report with the addition of
+     *                  user comment. If null, the default current crash data are
+     *                  used.
+     */
+    private void saveCrashReportFile(@NonNull File file, @NonNull CrashReportData crashData) {
+        try {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Writing crash report file " + file);
+            final CrashReportPersister persister = new CrashReportPersister();
+            persister.store(crashData, file);
+        } catch (Exception e) {
+            ACRA.log.e(LOG_TAG, "An error occurred while writing the report file...", e);
+        }
+    }
+
+
+    /**
+     * Creates an Intent that can be used to create and show a CrashReportDialog.
+     *
+     * @param reportFile    Error report file to display in the crash report dialog.
+     * @param reportBuilder ReportBuilder containing the details of the crash.
+     */
+    @NonNull
+    private Intent createCrashReportDialogIntent(@NonNull File reportFile, @NonNull ReportBuilder reportBuilder) {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating DialogIntent for " + reportFile + " exception=" + reportBuilder.getException());
+        final Intent dialogIntent = new Intent(context, config.reportDialogClass());
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE, reportFile);
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION, reportBuilder.getException());
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_CONFIG, config);
+        return dialogIntent;
+    }
+}
diff --git a/acra/src/main/java/org/acra/builder/ReportPrimer.java b/acra/src/main/java/org/acra/builder/ReportPrimer.java
new file mode 100644
index 00000000..ee03d9b5
--- /dev/null
+++ b/acra/src/main/java/org/acra/builder/ReportPrimer.java
@@ -0,0 +1,30 @@
+package org.acra.builder;
+
+import android.content.Context;
+
+import java.util.Map;
+
+/**
+ * Primes a {@link ReportBuilder} with any extra data to record for the current crash report.
+ *
+ * ReportPrimer is configured declaratively via {@link org.acra.annotation.ReportsCrashes#reportPrimerClass()}.
+ * The ReportPrimer class MUST have a no arg constructor and is created when ACRA is initialised.
+ *
+ * Created by William on 9 Jan 2016.
+ * @since 4.8.0
+ */
+public interface ReportPrimer {
+
+    /**
+     * Update builder via {@link ReportBuilder#customData(Map)} or {@link ReportBuilder#customData(String, String)}
+     * with any extra dta application to just this crash.
+     *
+     * Builder is fully constructed when this method is called, so it can be introspected for details of the crash.
+     *
+     * Note that this method will only be called if ACRA is currently enabled.
+     *
+     * @param context   Application context from which to retrieve resources.
+     * @param builder   Full configured {@link ReportBuilder} for the current crash report.
+     */
+    void primeReport(Context context, ReportBuilder builder);
+}
diff --git a/src/main/java/org/acra/util/BoundedLinkedList.java b/acra/src/main/java/org/acra/collections/BoundedLinkedList.java
similarity index 77%
rename from src/main/java/org/acra/util/BoundedLinkedList.java
rename to acra/src/main/java/org/acra/collections/BoundedLinkedList.java
index fc50ec44..187ce428 100644
--- a/src/main/java/org/acra/util/BoundedLinkedList.java
+++ b/acra/src/main/java/org/acra/collections/BoundedLinkedList.java
@@ -1,130 +1,163 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.util;
-
-import java.util.Collection;
-import java.util.LinkedList;
-
-/**
- * A {@link LinkedList} version with a maximum number of elements. When adding
- * elements to the end of the list, first elements in the list are discarded if
- * the maximum size is reached.
- * 
- * @author Kevin Gaudin
- * 
- * @param <E>
- */
-@SuppressWarnings("serial")
-public class BoundedLinkedList<E> extends LinkedList<E> {
-
-    private final int maxSize;
-
-    public BoundedLinkedList(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(java.lang.Object)
-     */
-    @Override
-    public boolean add(E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        return super.add(object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(int, java.lang.Object)
-     */
-    @Override
-    public void add(int location, E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        super.add(location, object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(java.util.Collection)
-     */
-    @Override
-    public boolean addAll(Collection<? extends E> collection) {
-        final int totalNeededSize = size() + collection.size();
-        final int overhead = totalNeededSize - maxSize;
-        if (overhead > 0) {
-            removeRange(0, overhead);
-        }
-        return super.addAll(collection);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(int, java.util.Collection)
-     */
-    @Override
-    public boolean addAll(int location, Collection<? extends E> collection) {
-        // int totalNeededSize = size() + collection.size();
-        // int overhead = totalNeededSize - maxSize;
-        // if(overhead > 0) {
-        // removeRange(0, overhead);
-        // }
-        // return super.addAll(location, collection);
-        throw new UnsupportedOperationException();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addFirst(java.lang.Object)
-     */
-    @Override
-    public void addFirst(E object) {
-        // super.addFirst(object);
-        throw new UnsupportedOperationException();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addLast(java.lang.Object)
-     */
-    @Override
-    public void addLast(E object) {
-        add(object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.AbstractCollection#toString()
-     */
-    @Override
-    public String toString() {
-        final StringBuilder result = new StringBuilder();
-        for (E object : this) {
-            result.append(object.toString());
-        }
-        return result.toString();
-    }
-}
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.util.Collection;
+import java.util.LinkedList;
+
+/**
+ * A {@link LinkedList} version with a maximum number of elements. When adding
+ * elements to the end of the list, first elements in the list are discarded if
+ * the maximum size is reached.
+ *
+ * @author Kevin Gaudin
+ */
+@SuppressWarnings("serial")
+public final class BoundedLinkedList<E> extends LinkedList<E> {
+
+    private final int maxSize;
+
+    public BoundedLinkedList(int maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#add(java.lang.Object)
+     */
+    @Override
+    public boolean add(E object) {
+        if (size() == maxSize) {
+            removeFirst();
+        }
+        return super.add(object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#add(int, java.lang.Object)
+     */
+    @Override
+    public void add(int location, E object) {
+        if (size() == maxSize) {
+            removeFirst();
+        }
+        super.add(location, object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addAll(java.util.Collection)
+     */
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        final int size = collection.size();
+        if (size > maxSize) {
+            final LinkedList<? extends E> list = new LinkedList<E>(collection);
+            for (int i = 0; i < size - maxSize; i++) {
+                list.removeFirst();
+            }
+            collection = list;
+        }
+        final int totalNeededSize = size() + collection.size();
+        final int overhead = totalNeededSize - maxSize;
+        if (overhead > 0) {
+            removeRange(0, overhead);
+        }
+        return super.addAll(collection);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addAll(int, java.util.Collection)
+     */
+    @Override
+    public boolean addAll(int location, Collection<? extends E> collection) {
+        // int totalNeededSize = size() + collection.size();
+        // int overhead = totalNeededSize - maxSize;
+        // if(overhead > 0) {
+        // removeRange(0, overhead);
+        // }
+        // return super.addAll(location, collection);
+        if(location == size()){
+            return super.addAll(location, collection);
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addFirst(java.lang.Object)
+     */
+    @Override
+    public void addFirst(E object) {
+        // super.addFirst(object);
+        throw new UnsupportedOperationException();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addLast(java.lang.Object)
+     */
+    @Override
+    public void addLast(E object) {
+        add(object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.AbstractCollection#toString()
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        final StringBuilder result = new StringBuilder();
+        for (E object : this) {
+            result.append(object.toString());
+        }
+        return result.toString();
+    }
+
+    @Override
+    public boolean offer(E o) {
+        return add(o);
+    }
+
+    @Override
+    public boolean offerFirst(E e) {
+        addFirst(e);
+        return true;
+    }
+
+    @Override
+    public boolean offerLast(E e) {
+        return add(e);
+    }
+
+    @Override
+    public void push(E e) {
+        add(e);
+    }
+}
diff --git a/acra/src/main/java/org/acra/collections/ImmutableList.java b/acra/src/main/java/org/acra/collections/ImmutableList.java
new file mode 100644
index 00000000..61324f93
--- /dev/null
+++ b/acra/src/main/java/org/acra/collections/ImmutableList.java
@@ -0,0 +1,167 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ * Naive (not optimized) implementation of an Immutable List
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableList<E> implements List<E>, Serializable {
+
+    private final List<E> mList;
+
+    public ImmutableList(E... elements) {
+        this(Arrays.asList(elements));
+    }
+
+    public ImmutableList(Collection<E> collection) {
+        this.mList = new ArrayList<E>(collection);
+    }
+
+    @Override
+    public void add(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(int location, @NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return mList.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(@NonNull Collection<?> collection) {
+        return mList.containsAll(collection);
+    }
+
+    @Override
+    public E get(int location) {
+        return mList.get(location);
+    }
+
+    @Override
+    public int indexOf(Object object) {
+        return mList.indexOf(object);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mList.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Iterator<E> iterator() {
+        return new UnmodifiableIteratorWrapper<E>(mList.iterator());
+    }
+
+    @Override
+    public int lastIndexOf(Object object) {
+        return mList.lastIndexOf(object);
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        return new UnmodifiableListIteratorWrapper<E>(mList.listIterator());
+    }
+
+    @NonNull
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        return new UnmodifiableListIteratorWrapper<E>(mList.listIterator(location));
+    }
+
+    @Override
+    public E remove(int location) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public E set(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mList.size();
+    }
+
+    @NonNull
+    @Override
+    public List<E> subList(int start, int end) {
+        throw new UnsupportedOperationException();
+    }
+
+    @NonNull
+    @Override
+    public Object[] toArray() {
+        return mList.toArray();
+    }
+
+    @NonNull
+    @Override
+    public <T> T[] toArray(@NonNull T[] array) {
+        //noinspection SuspiciousToArrayCall
+        return mList.toArray(array);
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/collections/ImmutableMap.java b/acra/src/main/java/org/acra/collections/ImmutableMap.java
new file mode 100644
index 00000000..dd3a2bb2
--- /dev/null
+++ b/acra/src/main/java/org/acra/collections/ImmutableMap.java
@@ -0,0 +1,131 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Naive (not optimized) implementation of an Immutable Map
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableMap<K, V> implements Map<K, V>, Serializable {
+
+    private final Map<K, V> mMap;
+
+    public ImmutableMap(Map<K, V> map) {
+        this.mMap = new HashMap<K, V>(map);
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return mMap.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return mMap.containsValue(value);
+    }
+
+    @NonNull
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        final Set<Entry<K, V>> original = mMap.entrySet();
+        final ImmutableSet.Builder<Entry<K, V>> builder = new ImmutableSet.Builder<Entry<K, V>>();
+        for (Entry<K, V> entry : original) {
+            builder.add(new ImmutableEntryWrapper<K, V>(entry));
+        }
+        return builder.build();
+    }
+
+    @Override
+    public V get(Object key) {
+        return mMap.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mMap.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Set<K> keySet() {
+        return new ImmutableSet<K>(mMap.keySet());
+    }
+
+    @Override
+    public V put(K key, V value) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void putAll(@NonNull Map<? extends K, ? extends V> map) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mMap.size();
+    }
+
+    @NonNull
+    @Override
+    public Collection<V> values() {
+        return new ImmutableList<V>(mMap.values());
+    }
+
+    public static class ImmutableEntryWrapper<K, V> implements Map.Entry<K, V> {
+        private final Map.Entry<K, V> mEntry;
+
+        ImmutableEntryWrapper(Entry<K, V> mEntry) {
+            this.mEntry = mEntry;
+        }
+
+        @Override
+        public K getKey() {
+            return mEntry.getKey();
+        }
+
+        @Override
+        public V getValue() {
+            return mEntry.getValue();
+        }
+
+        @Override
+        public V setValue(Object object) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/collections/ImmutableSet.java b/acra/src/main/java/org/acra/collections/ImmutableSet.java
new file mode 100644
index 00000000..e2781a8e
--- /dev/null
+++ b/acra/src/main/java/org/acra/collections/ImmutableSet.java
@@ -0,0 +1,130 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Naive (not optimized) implementation of an Immutable Set with reliable, user-specified iteration order.
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableSet<E> implements Set<E>, Serializable {
+
+    private final Set<E> mSet;
+
+    public ImmutableSet(E... elements) {
+        this(Arrays.asList(elements));
+    }
+
+    public ImmutableSet(Collection<E> collection) {
+        this.mSet = new LinkedHashSet<E>(collection);
+    }
+
+    @Override
+    public boolean add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return mSet.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(@NonNull Collection<?> collection) {
+        return mSet.containsAll(collection);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mSet.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Iterator<E> iterator() {
+        return new UnmodifiableIteratorWrapper<E>(mSet.iterator());
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mSet.size();
+    }
+
+    @NonNull
+    @Override
+    public Object[] toArray() {
+        return mSet.toArray();
+    }
+
+    @NonNull
+    @Override
+    public <T> T[] toArray(@NonNull T[] array) {
+        //noinspection SuspiciousToArrayCall
+        return mSet.toArray(array);
+    }
+
+    public static final class Builder<E> {
+        private final Set<E> mSet;
+
+        public Builder() {
+            mSet = new LinkedHashSet<E>();
+        }
+
+        public void add(E element) {
+            mSet.add(element);
+        }
+
+        public ImmutableSet<E> build() {
+            return new ImmutableSet<E>(mSet);
+        }
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java b/acra/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java
new file mode 100644
index 00000000..c0308479
--- /dev/null
+++ b/acra/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java
@@ -0,0 +1,47 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import java.util.Iterator;
+
+/**
+ * Wrapper around an Iterator which prevents modifications
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+class UnmodifiableIteratorWrapper<E> implements Iterator<E> {
+    private final Iterator<E> mIterator;
+
+    UnmodifiableIteratorWrapper(Iterator<E> mIterator) {
+        this.mIterator = mIterator;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return mIterator.hasNext();
+    }
+
+    @Override
+    public E next() {
+        return mIterator.next();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/acra/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java b/acra/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java
new file mode 100644
index 00000000..97f0ab59
--- /dev/null
+++ b/acra/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java
@@ -0,0 +1,78 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import java.util.ListIterator;
+
+/**
+ * Wrapper around a ListIterator which prevents modifications
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+class UnmodifiableListIteratorWrapper<E> implements ListIterator<E> {
+    private final ListIterator<E> mIterator;
+
+    UnmodifiableListIteratorWrapper(ListIterator<E> mIterator) {
+        this.mIterator = mIterator;
+    }
+
+    @Override
+    public void add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasNext() {
+        return mIterator.hasNext();
+    }
+
+    @Override
+    public boolean hasPrevious() {
+        return mIterator.hasPrevious();
+    }
+
+    @Override
+    public E next() {
+        return mIterator.next();
+    }
+
+    @Override
+    public int nextIndex() {
+        return mIterator.nextIndex();
+    }
+
+    @Override
+    public E previous() {
+        return mIterator.previous();
+    }
+
+    @Override
+    public int previousIndex() {
+        return mIterator.previousIndex();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void set(E object) {
+        throw new UnsupportedOperationException();
+    }
+}
+
diff --git a/acra/src/main/java/org/acra/collector/Collector.java b/acra/src/main/java/org/acra/collector/Collector.java
new file mode 100644
index 00000000..7de6c49c
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/Collector.java
@@ -0,0 +1,77 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Size;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+
+import java.util.Set;
+
+/**
+ * Represents a collector.
+ * Maintains information on which fields can be collected by this collector.
+ * Validates constraints in which a field should (not) be collected.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+abstract class Collector {
+    private final ReportField[] reportFields;
+
+    /**
+     * create a new Collector that is able to collect these reportFields
+     * (Note: @Size is currently not working for varargs, it is still here as a hint to developers)
+     *
+     * @param reportFields the supported reportFields
+     */
+    Collector(@Size(min = 1) @NonNull ReportField... reportFields) {
+        this.reportFields = reportFields;
+    }
+
+    /**
+     * @return all fields this collector can collect
+     */
+    @NonNull
+    final ReportField[] canCollect() {
+        return reportFields;
+    }
+
+    /**
+     * this should check if the set contains the field, but may add additional checks like permissions etc.
+     *
+     * @param crashReportFields configured fields
+     * @param collect           the filed to collect
+     * @param reportBuilder     the current reportBuilder
+     * @return if this field should be collected now
+     */
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return crashReportFields.contains(collect);
+    }
+
+    /**
+     * will only be called if shouldCollect returned true for this ReportField
+     *
+     * @param reportField   the ReportField to collect
+     * @param reportBuilder the current reportBuilder
+     * @return Element of what was collected
+     */
+    @NonNull
+    abstract Element collect(ReportField reportField, ReportBuilder reportBuilder);
+}
diff --git a/src/main/java/org/acra/collector/ConfigurationCollector.java b/acra/src/main/java/org/acra/collector/ConfigurationCollector.java
similarity index 61%
rename from src/main/java/org/acra/collector/ConfigurationCollector.java
rename to acra/src/main/java/org/acra/collector/ConfigurationCollector.java
index 07d03f65..705b5f43 100644
--- a/src/main/java/org/acra/collector/ConfigurationCollector.java
+++ b/acra/src/main/java/org/acra/collector/ConfigurationCollector.java
@@ -1,233 +1,260 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.util.SparseArray;
-
-/**
- * Inspects a {@link Configuration} object through reflection API in order to
- * generate a human readable String with values replaced with their constants
- * names. The {@link Configuration#toString()} method was not enough as values
- * like 0, 1, 2 or 3 don't look readable to me. Using reflection API allows to
- * retrieve hidden fields and can make us hope to be compatible with all Android
- * API levels, even those which are not published yet.
- * 
- * @author Kevin Gaudin
- * 
- */
-public final class ConfigurationCollector {
-
-    private static final String SUFFIX_MASK = "_MASK";
-    private static final String FIELD_SCREENLAYOUT = "screenLayout";
-    private static final String FIELD_UIMODE = "uiMode";
-    private static final String FIELD_MNC = "mnc";
-    private static final String FIELD_MCC = "mcc";
-    private static final String PREFIX_UI_MODE = "UI_MODE_";
-    private static final String PREFIX_TOUCHSCREEN = "TOUCHSCREEN_";
-    private static final String PREFIX_SCREENLAYOUT = "SCREENLAYOUT_";
-    private static final String PREFIX_ORIENTATION = "ORIENTATION_";
-    private static final String PREFIX_NAVIGATIONHIDDEN = "NAVIGATIONHIDDEN_";
-    private static final String PREFIX_NAVIGATION = "NAVIGATION_";
-    private static final String PREFIX_KEYBOARDHIDDEN = "KEYBOARDHIDDEN_";
-    private static final String PREFIX_KEYBOARD = "KEYBOARD_";
-    private static final String PREFIX_HARDKEYBOARDHIDDEN = "HARDKEYBOARDHIDDEN_";
-
-    private final HashMap<String, SparseArray<String>> mValueArrays = new HashMap<String, SparseArray<String>>();
-
-    private ConfigurationCollector() {
-
-        final SparseArray<String> hardKeyboardHiddenValues = new SparseArray<String>();
-        final SparseArray<String> keyboardValues = new SparseArray<String>();
-        final SparseArray<String> keyboardHiddenValues = new SparseArray<String>();
-        final SparseArray<String> navigationValues = new SparseArray<String>();
-        final SparseArray<String> navigationHiddenValues = new SparseArray<String>();
-        final SparseArray<String> orientationValues = new SparseArray<String>();
-        final SparseArray<String> screenLayoutValues = new SparseArray<String>();
-        final SparseArray<String> touchScreenValues = new SparseArray<String>();
-        final SparseArray<String> uiModeValues = new SparseArray<String>();
-
-        for (final Field f : Configuration.class.getFields()) {
-            if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
-                final String fieldName = f.getName();
-                try {
-                    if (fieldName.startsWith(PREFIX_HARDKEYBOARDHIDDEN)) {
-                        hardKeyboardHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_KEYBOARD)) {
-                        keyboardValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_KEYBOARDHIDDEN)) {
-                        keyboardHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_NAVIGATION)) {
-                        navigationValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_NAVIGATIONHIDDEN)) {
-                        navigationHiddenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_ORIENTATION)) {
-                        orientationValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_SCREENLAYOUT)) {
-                        screenLayoutValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_TOUCHSCREEN)) {
-                        touchScreenValues.put(f.getInt(null), fieldName);
-                    } else if (fieldName.startsWith(PREFIX_UI_MODE)) {
-                        uiModeValues.put(f.getInt(null), fieldName);
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
-                }
-            }
-        }
-
-        mValueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, hardKeyboardHiddenValues);
-        mValueArrays.put(PREFIX_KEYBOARD, keyboardValues);
-        mValueArrays.put(PREFIX_KEYBOARDHIDDEN, keyboardHiddenValues);
-        mValueArrays.put(PREFIX_NAVIGATION, navigationValues);
-        mValueArrays.put(PREFIX_NAVIGATIONHIDDEN, navigationHiddenValues);
-        mValueArrays.put(PREFIX_ORIENTATION, orientationValues);
-        mValueArrays.put(PREFIX_SCREENLAYOUT, screenLayoutValues);
-        mValueArrays.put(PREFIX_TOUCHSCREEN, touchScreenValues);
-        mValueArrays.put(PREFIX_UI_MODE, uiModeValues);
-    }
-
-    /**
-     * Use this method to generate a human readable String listing all values
-     * from the provided Configuration instance.
-     * 
-     * @param conf
-     *            The Configuration to be described.
-     * @return A String describing all the fields of the given Configuration,
-     *         with values replaced by constant names.
-     */
-    private String toString(Configuration conf) {
-        final StringBuilder result = new StringBuilder();
-        for (final Field f : conf.getClass().getFields()) {
-            try {
-                if (!Modifier.isStatic(f.getModifiers())) {
-                    final String fieldName = f.getName();
-                    result.append(fieldName).append('=');
-                    if (f.getType().equals(int.class)) {
-                        result.append(getFieldValueName(conf, f));
-                    } else if(f.get(conf) != null){
-                        result.append(f.get(conf).toString());
-                    }
-                    result.append('\n');
-                }
-            } catch (IllegalArgumentException e) {
-                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            } catch (IllegalAccessException e) {
-                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            }
-        }
-        return result.toString();
-    }
-
-    /**
-     * Retrieve the name of the constant defined in the {@link Configuration}
-     * class which defines the value of a field in a {@link Configuration}
-     * instance.
-     * 
-     * @param conf
-     *            The instance of {@link Configuration} where the value is
-     *            stored.
-     * @param f
-     *            The {@link Field} to be inspected in the {@link Configuration}
-     *            instance.
-     * @return The value of the field f in instance conf translated to its
-     *         constant name.
-     * @throws IllegalAccessException if the supplied field is inaccessible.
-     */
-    private String getFieldValueName(Configuration conf, Field f) throws IllegalAccessException {
-        final String fieldName = f.getName();
-        if (fieldName.equals(FIELD_MCC) || fieldName.equals(FIELD_MNC)) {
-            return Integer.toString(f.getInt(conf));
-        } else if (fieldName.equals(FIELD_UIMODE)) {
-            return activeFlags(mValueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
-        } else if (fieldName.equals(FIELD_SCREENLAYOUT)) {
-            return activeFlags(mValueArrays.get(PREFIX_SCREENLAYOUT), f.getInt(conf));
-        } else {
-            final SparseArray<String> values = mValueArrays.get(fieldName.toUpperCase() + '_');
-            if (values == null) {
-                // Unknown field, return the raw int as String
-                return Integer.toString(f.getInt(conf));
-            }
-
-            final String value = values.get(f.getInt(conf));
-            if (value == null) {
-                // Unknown value, return the raw int as String
-                return Integer.toString(f.getInt(conf));
-            }
-            return value;
-        }
-    }
-
-    /**
-     * Some fields contain multiple value types which can be isolated by
-     * applying a bitmask. That method returns the concatenation of active
-     * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
-     * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
-     */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
-        final StringBuilder result = new StringBuilder();
-
-        // Look for masks, apply it an retrieve the masked value
-        for (int i = 0; i < valueNames.size(); i++) {
-            final int maskValue = valueNames.keyAt(i);
-            if (valueNames.get(maskValue).endsWith(SUFFIX_MASK)) {
-                final int value = bitfield & maskValue;
-                if (value > 0) {
-                    if (result.length() > 0) {
-                        result.append('+');
-                    }
-                    result.append(valueNames.get(value));
-                }
-            }
-        }
-        return result.toString();
-    }
-    
-    /**
-     * Returns the current Configuration for this application.
-     *
-     * @param context   Context for the application being reported.
-     * @return A String representation of the current configuration for the application.
-     */
-    public static String collectConfiguration(Context context) {
-        try {
-            final ConfigurationCollector collector = new ConfigurationCollector();
-            final Configuration crashConf = context.getResources().getConfiguration();
-            return collector.toString(crashConf);
-        } catch (RuntimeException e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve CrashConfiguration for : " + context.getPackageName(), e);
-            return "Couldn't retrieve crash config";
-        }
-    }
-}
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.content.res.Configuration;
+import android.support.annotation.NonNull;
+import android.util.SparseArray;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Inspects a {@link Configuration} object through reflection API in order to
+ * generate a human readable String with values replaced with their constants
+ * names. The {@link Configuration#toString()} method was not enough as values
+ * like 0, 1, 2 or 3 aren't readable. Using reflection API allows to
+ * retrieve hidden fields and can make us hope to be compatible with all Android
+ * API levels, even those which are not published yet.
+ *
+ * @author Kevin Gaudin and F43nd1r
+ */
+public final class ConfigurationCollector extends Collector {
+
+    private static final String SUFFIX_MASK = "_MASK";
+    private static final String FIELD_SCREENLAYOUT = "screenLayout";
+    private static final String FIELD_UIMODE = "uiMode";
+    private static final String FIELD_MNC = "mnc";
+    private static final String FIELD_MCC = "mcc";
+    private static final String PREFIX_UI_MODE = "UI_MODE_";
+    private static final String PREFIX_TOUCHSCREEN = "TOUCHSCREEN_";
+    private static final String PREFIX_SCREENLAYOUT = "SCREENLAYOUT_";
+    private static final String PREFIX_ORIENTATION = "ORIENTATION_";
+    private static final String PREFIX_NAVIGATIONHIDDEN = "NAVIGATIONHIDDEN_";
+    private static final String PREFIX_NAVIGATION = "NAVIGATION_";
+    private static final String PREFIX_KEYBOARDHIDDEN = "KEYBOARDHIDDEN_";
+    private static final String PREFIX_KEYBOARD = "KEYBOARD_";
+    private static final String PREFIX_HARDKEYBOARDHIDDEN = "HARDKEYBOARDHIDDEN_";
+
+    private final Context context;
+    private final Element initialConfiguration;
+
+    public ConfigurationCollector(@NonNull Context context, @NonNull Element initialConfiguration) {
+        super(ReportField.INITIAL_CONFIGURATION, ReportField.CRASH_CONFIGURATION);
+        this.context = context;
+        this.initialConfiguration = initialConfiguration;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case INITIAL_CONFIGURATION:
+                return initialConfiguration;
+            case CRASH_CONFIGURATION:
+                return collectConfiguration(context);
+            default:
+                throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Creates an Element listing all values human readable
+     * from the provided Configuration instance.
+     *
+     * @param conf The Configuration to be described.
+     * @return An Element describing all the fields of the given Configuration,
+     * with values replaced by constant names.
+     */
+    @NonNull
+    private static Element configToElement(@NonNull Configuration conf) {
+        final ComplexElement result = new ComplexElement();
+        final Map<String, SparseArray<String>> valueArrays = getValueArrays();
+        for (final Field f : conf.getClass().getFields()) {
+            try {
+                if (!Modifier.isStatic(f.getModifiers())) {
+                    final String fieldName = f.getName();
+                    try {
+                        if (f.getType().equals(int.class)) {
+                            result.put(fieldName, getFieldValueName(valueArrays, conf, f));
+                        } else if (f.get(conf) != null) {
+                            result.put(fieldName, f.get(conf));
+                        }
+                    } catch (JSONException e) {
+                        ACRA.log.w(LOG_TAG, "Could not collect configuration field " + fieldName, e);
+                    }
+                }
+            } catch (@NonNull IllegalArgumentException e) {
+                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
+            } catch (@NonNull IllegalAccessException e) {
+                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
+            }
+        }
+        return result;
+    }
+
+    private static Map<String, SparseArray<String>> getValueArrays() {
+        final Map<String, SparseArray<String>> valueArrays = new HashMap<String, SparseArray<String>>();
+        final SparseArray<String> hardKeyboardHiddenValues = new SparseArray<String>();
+        final SparseArray<String> keyboardValues = new SparseArray<String>();
+        final SparseArray<String> keyboardHiddenValues = new SparseArray<String>();
+        final SparseArray<String> navigationValues = new SparseArray<String>();
+        final SparseArray<String> navigationHiddenValues = new SparseArray<String>();
+        final SparseArray<String> orientationValues = new SparseArray<String>();
+        final SparseArray<String> screenLayoutValues = new SparseArray<String>();
+        final SparseArray<String> touchScreenValues = new SparseArray<String>();
+        final SparseArray<String> uiModeValues = new SparseArray<String>();
+
+        for (final Field f : Configuration.class.getFields()) {
+            if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
+                final String fieldName = f.getName();
+                try {
+                    if (fieldName.startsWith(PREFIX_HARDKEYBOARDHIDDEN)) {
+                        hardKeyboardHiddenValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_KEYBOARD)) {
+                        keyboardValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_KEYBOARDHIDDEN)) {
+                        keyboardHiddenValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_NAVIGATION)) {
+                        navigationValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_NAVIGATIONHIDDEN)) {
+                        navigationHiddenValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_ORIENTATION)) {
+                        orientationValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_SCREENLAYOUT)) {
+                        screenLayoutValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_TOUCHSCREEN)) {
+                        touchScreenValues.put(f.getInt(null), fieldName);
+                    } else if (fieldName.startsWith(PREFIX_UI_MODE)) {
+                        uiModeValues.put(f.getInt(null), fieldName);
+                    }
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
+                }
+            }
+        }
+
+        valueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, hardKeyboardHiddenValues);
+        valueArrays.put(PREFIX_KEYBOARD, keyboardValues);
+        valueArrays.put(PREFIX_KEYBOARDHIDDEN, keyboardHiddenValues);
+        valueArrays.put(PREFIX_NAVIGATION, navigationValues);
+        valueArrays.put(PREFIX_NAVIGATIONHIDDEN, navigationHiddenValues);
+        valueArrays.put(PREFIX_ORIENTATION, orientationValues);
+        valueArrays.put(PREFIX_SCREENLAYOUT, screenLayoutValues);
+        valueArrays.put(PREFIX_TOUCHSCREEN, touchScreenValues);
+        valueArrays.put(PREFIX_UI_MODE, uiModeValues);
+        return valueArrays;
+    }
+
+    /**
+     * Retrieve the name of the constant defined in the {@link Configuration}
+     * class which defines the value of a field in a {@link Configuration}
+     * instance.
+     *
+     * @param conf The instance of {@link Configuration} where the value is
+     *             stored.
+     * @param f    The {@link Field} to be inspected in the {@link Configuration}
+     *             instance.
+     * @return The value of the field f in instance conf translated to its
+     * constant name.
+     * @throws IllegalAccessException if the supplied field is inaccessible.
+     */
+    private static Object getFieldValueName(Map<String, SparseArray<String>> valueArrays, @NonNull Configuration conf, @NonNull Field f) throws IllegalAccessException {
+        final String fieldName = f.getName();
+        if (fieldName.equals(FIELD_MCC) || fieldName.equals(FIELD_MNC)) {
+            return f.getInt(conf);
+        } else if (fieldName.equals(FIELD_UIMODE)) {
+            return activeFlags(valueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
+        } else if (fieldName.equals(FIELD_SCREENLAYOUT)) {
+            return activeFlags(valueArrays.get(PREFIX_SCREENLAYOUT), f.getInt(conf));
+        } else {
+            final SparseArray<String> values = valueArrays.get(fieldName.toUpperCase() + '_');
+            if (values == null) {
+                // Unknown field, return the raw int as String
+                return f.getInt(conf);
+            }
+
+            final String value = values.get(f.getInt(conf));
+            if (value == null) {
+                // Unknown value, return the raw int as String
+                return f.getInt(conf);
+            }
+            return value;
+        }
+    }
+
+    /**
+     * Some fields contain multiple value types which can be isolated by
+     * applying a bitmask. That method returns the concatenation of active
+     * values.
+     *
+     * @param valueNames The array containing the different values and names for this
+     *                   field. Must contain mask values too.
+     * @param bitfield   The bitfield to inspect.
+     * @return The names of the different values contained in the bitfield,
+     * separated by '+'.
+     */
+    @NonNull
+    private static String activeFlags(@NonNull SparseArray<String> valueNames, int bitfield) {
+        final StringBuilder result = new StringBuilder();
+
+        // Look for masks, apply it an retrieve the masked value
+        for (int i = 0; i < valueNames.size(); i++) {
+            final int maskValue = valueNames.keyAt(i);
+            if (valueNames.get(maskValue).endsWith(SUFFIX_MASK)) {
+                final int value = bitfield & maskValue;
+                if (value > 0) {
+                    if (result.length() > 0) {
+                        result.append('+');
+                    }
+                    result.append(valueNames.get(value));
+                }
+            }
+        }
+        return result.toString();
+    }
+
+    /**
+     * Returns the current Configuration for this application.
+     *
+     * @param context Context for the application being reported.
+     * @return A String representation of the current configuration for the application.
+     */
+    @NonNull
+    public static Element collectConfiguration(@NonNull Context context) {
+        try {
+            return configToElement(context.getResources().getConfiguration());
+        } catch (RuntimeException e) {
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve CrashConfiguration for : " + context.getPackageName(), e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/collector/CrashReportData.java b/acra/src/main/java/org/acra/collector/CrashReportData.java
similarity index 62%
rename from src/main/java/org/acra/collector/CrashReportData.java
rename to acra/src/main/java/org/acra/collector/CrashReportData.java
index 60aae535..73ab4f60 100644
--- a/src/main/java/org/acra/collector/CrashReportData.java
+++ b/acra/src/main/java/org/acra/collector/CrashReportData.java
@@ -1,58 +1,77 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.util.EnumMap;
-import java.util.Properties;
-
-import org.acra.ReportField;
-import org.acra.util.JSONReportBuilder;
-import org.acra.util.JSONReportBuilder.JSONReportException;
-import org.json.JSONObject;
-
-/**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link Properties} adapted to extend an
- * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
- * amounts of android time in the generation of a date comment when storing to
- * file.
- */
-public final class CrashReportData extends EnumMap<ReportField, String> {
-
-    private static final long serialVersionUID = 4112578634029874840L;
-
-    /**
-     * Constructs a new {@code Properties} object.
-     */
-    public CrashReportData() {
-        super(ReportField.class);
-    }
-
-    /**
-     * Returns the property with the specified name.
-     * 
-     * @param key the name of the property to find.
-     * @return the named property value, or {@code null} if it can't be found.
-     */
-    public String getProperty(ReportField key) {
-        return super.get(key);
-    }
-
-    public JSONObject toJSON() throws JSONReportException {
-        return JSONReportBuilder.buildJSONReport(this);
-    }
-}
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ReportField;
+import org.acra.model.BooleanElement;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.JsonUtils;
+import org.json.JSONObject;
+
+import java.util.EnumMap;
+import java.util.Properties;
+
+/**
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
+ * <p>
+ * This is basically the source of {@link Properties} adapted to extend an
+ * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
+ * amounts of android time in the generation of a date comment when storing to file.
+ */
+public final class CrashReportData extends EnumMap<ReportField, Element> {
+
+    private static final long serialVersionUID = 5002578634500874842L;
+
+    /**
+     * Constructs a new {@code Properties} object.
+     */
+    public CrashReportData() {
+        super(ReportField.class);
+    }
+
+    /**
+     * Returns the property with the specified name.
+     *
+     * @param key the name of the property to find.
+     * @return the named property value, or {@code null} if it can't be found.
+     */
+    public String getProperty(@NonNull ReportField key) {
+        return super.get(key).toString();
+    }
+
+    public void putString(@NonNull ReportField key, String value) {
+        put(key, new StringElement(value));
+    }
+
+    public void putNumber(@NonNull ReportField key, Number value) {
+        put(key, new NumberElement(value));
+    }
+
+    public void putBoolean(@NonNull ReportField key, boolean value) {
+        put(key, new BooleanElement(value));
+    }
+
+    @NonNull
+    public JSONObject toJSON() {
+        return JsonUtils.toJson(this);
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/collector/CrashReportDataFactory.java b/acra/src/main/java/org/acra/collector/CrashReportDataFactory.java
new file mode 100644
index 00000000..fead91d7
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/CrashReportDataFactory.java
@@ -0,0 +1,173 @@
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.util.PackageManagerWrapper;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Responsible for creating the CrashReportData for an Exception.
+ * <p>
+ * Also responsible for holding the custom data to send with each report.
+ * </p>
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class CrashReportDataFactory {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final SharedPreferences prefs;
+    private final Map<String, String> customParameters = new LinkedHashMap<String, String>();
+    private final Calendar appStartDate;
+    private final Element initialConfiguration;
+
+    public CrashReportDataFactory(@NonNull Context context, @NonNull ACRAConfiguration config,
+                                  @NonNull SharedPreferences prefs, @NonNull Calendar appStartDate,
+                                  @NonNull Element initialConfiguration) {
+        this.context = context;
+        this.config = config;
+        this.prefs = prefs;
+        this.appStartDate = appStartDate;
+        this.initialConfiguration = initialConfiguration;
+    }
+
+    /**
+     * <p>
+     * Adds a custom key and value to be reported with the generated
+     * CashReportData.
+     * </p>
+     * <p>
+     * The key/value pairs will be stored in the "custom" column, as a text
+     * containing one 'key = value' pair on each line.
+     * </p>
+     *
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
+     * @return The previous value for this key if there was one, or null.
+     */
+    public String putCustomData(@NonNull String key, String value) {
+        return customParameters.put(key, value);
+    }
+
+    /**
+     * Removes a key/value pair from the custom data field.
+     *
+     * @param key The key of the data to be removed.
+     * @return The value for this key before removal.
+     */
+    public String removeCustomData(@NonNull String key) {
+        return customParameters.remove(key);
+    }
+
+    /**
+     * Removes all key/value pairs from the custom data field.
+     */
+    public void clearCustomData() {
+        customParameters.clear();
+    }
+
+    /**
+     * Gets the current value for a key in the custom data field.
+     *
+     * @param key The key of the data to be retrieved.
+     * @return The value for this key.
+     */
+    public String getCustomData(@NonNull String key) {
+        return customParameters.get(key);
+    }
+
+    /**
+     * Collects crash data.
+     *
+     * @param builder ReportBuilder for whom to crete the crash report.
+     * @return CrashReportData identifying the current crash.
+     */
+    @NonNull
+    public CrashReportData createCrashData(@NonNull ReportBuilder builder) {
+        final CrashReportData crashReportData = new CrashReportData();
+        try {
+            final Set<ReportField> crashReportFields = config.reportContent();
+            final List<Collector> collectors = getCollectorsOrdered();
+
+            //this will iterate over all collectors in descending order of priority
+            for (Collector collector : collectors) {
+                //catch absolutely everything possible here so no collector obstructs the others
+                try {
+                    for (ReportField reportField : collector.canCollect()) {
+                        try {
+                            if (collector.shouldCollect(crashReportFields, reportField, builder)) {
+                                crashReportData.put(reportField, collector.collect(reportField, builder));
+                            }
+                        } catch (RuntimeException e) {
+                            ACRA.log.e(LOG_TAG, "Error while retrieving " + reportField.name() + " data", e);
+                        }
+                    }
+                } catch (RuntimeException e) {
+                    ACRA.log.e(LOG_TAG, "Error in collector " + collector.getClass().getSimpleName(), e);
+                }
+            }
+
+        } catch (RuntimeException e) {
+            ACRA.log.e(LOG_TAG, "Error while retrieving crash data", e);
+        }
+
+        return crashReportData;
+    }
+
+    private List<Collector> getCollectorsOrdered() {
+        final List<Collector> collectors = new ArrayList<Collector>();
+        final PackageManagerWrapper pm = new PackageManagerWrapper(context);
+        collectors.add(new LogCatCollector(config, pm));
+        collectors.add(new DropBoxCollector(context, config, pm));
+        collectors.add(new StacktraceCollector());
+        collectors.add(new TimeCollector(appStartDate));
+        collectors.add(new SimpleValuesCollector(context));
+        collectors.add(new ConfigurationCollector(context, initialConfiguration));
+        collectors.add(new MemoryInfoCollector());
+        collectors.add(new ReflectionCollector(context, config));
+        collectors.add(new DisplayManagerCollector(context));
+        collectors.add(new CustomDataCollector(customParameters));
+        collectors.add(new SharedPreferencesCollector(context, config, prefs));
+        collectors.add(new DeviceFeaturesCollector(context));
+        collectors.add(new SettingsCollector(context, config));
+        collectors.add(new PackageManagerCollector(pm));
+        collectors.add(new DeviceIdCollector(context, pm, prefs));
+        collectors.add(new LogFileCollector(context, config));
+        collectors.add(new MediaCodecListCollector());
+        collectors.add(new ThreadCollector());
+        return collectors;
+    }
+}
\ No newline at end of file
diff --git a/acra/src/main/java/org/acra/collector/CustomDataCollector.java b/acra/src/main/java/org/acra/collector/CustomDataCollector.java
new file mode 100644
index 00000000..68bbceec
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/CustomDataCollector.java
@@ -0,0 +1,63 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Collects custom data supplied by the user
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class CustomDataCollector extends Collector {
+    private final Map<String, String> customParameters;
+
+    CustomDataCollector(Map<String, String> customParameters){
+        super(ReportField.CUSTOM_DATA);
+        this.customParameters = customParameters;
+    }
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        return createCustomInfoElement(reportBuilder.getCustomData());
+    }
+
+
+    /**
+     * Generates the Element which is posted in the single custom data field
+     *
+     * @return An Element with  key-value-pairs for the supplied custom data.
+     */
+    @NonNull
+    private Element createCustomInfoElement(@Nullable Map<String, String> reportCustomData) {
+        Map<String, String> params = customParameters;
+        if (reportCustomData != null) {
+            params = new HashMap<String, String>(params);
+            params.putAll(reportCustomData);
+        }
+        return new ComplexElement(params);
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/DeviceFeaturesCollector.java b/acra/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
new file mode 100644
index 00000000..0a74e8b1
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
@@ -0,0 +1,72 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.content.pm.FeatureInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Features declared as available on the device.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class DeviceFeaturesCollector extends Collector {
+    private final Context context;
+
+    DeviceFeaturesCollector(Context context) {
+        super(ReportField.DEVICE_FEATURES);
+        this.context = context;
+    }
+
+    /**
+     * collects device features
+     *
+     * @param reportField   the ReportField to collect
+     * @param reportBuilder the current reportBuilder
+     * @return Element of all device feature names
+     */
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final ComplexElement result = new ComplexElement();
+        try {
+            final PackageManager pm = context.getPackageManager();
+            final FeatureInfo[] features = pm.getSystemAvailableFeatures();
+            for (final FeatureInfo feature : features) {
+                final String featureName = feature.name;
+                if (featureName != null) {
+                    result.put(featureName, true);
+                } else {
+                    result.put("glEsVersion", feature.getGlEsVersion());
+                }
+            }
+        } catch (Throwable e) {
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceFeatures for " + context.getPackageName(), e);
+        }
+
+        return result;
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/DeviceIdCollector.java b/acra/src/main/java/org/acra/collector/DeviceIdCollector.java
new file mode 100644
index 00000000..f3c74d9b
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/DeviceIdCollector.java
@@ -0,0 +1,85 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.Manifest;
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.telephony.TelephonyManager;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.PackageManagerWrapper;
+
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects the device ID
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class DeviceIdCollector extends Collector {
+    private final Context context;
+    private final PackageManagerWrapper pm;
+    private final SharedPreferences prefs;
+
+    DeviceIdCollector(Context context, PackageManagerWrapper pm, SharedPreferences prefs) {
+        super(ReportField.DEVICE_ID);
+        this.context = context;
+        this.pm = pm;
+        this.prefs = prefs;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
+                && pm.hasPermission(Manifest.permission.READ_PHONE_STATE);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final String result = getDeviceId();
+        return result != null ? new StringElement(result) : ACRAConstants.NOT_AVAILABLE;
+    }
+
+    /**
+     * Returns the DeviceId according to the TelephonyManager.
+     *
+     * @return Returns the DeviceId according to the TelephonyManager or null if there is no TelephonyManager.
+     */
+    @SuppressLint("HardwareIds")
+    @Nullable
+    private String getDeviceId() {
+        try {
+            final TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            return tm.getDeviceId();
+        } catch (RuntimeException e) {
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceId for : " + context.getPackageName(), e);
+            return null;
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/DisplayManagerCollector.java b/acra/src/main/java/org/acra/collector/DisplayManagerCollector.java
new file mode 100644
index 00000000..01afb1af
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/DisplayManagerCollector.java
@@ -0,0 +1,234 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.v4.hardware.display.DisplayManagerCompat;
+import android.util.DisplayMetrics;
+import android.util.SparseArray;
+import android.view.Display;
+import android.view.Surface;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+
+/**
+ * Collects information about the connected display(s)
+ *
+ * @author (original author unknown) & F43nd1r
+ */
+final class DisplayManagerCollector extends Collector {
+    private final Context context;
+    private final SparseArray<String> flagNames = new SparseArray<String>();
+
+    DisplayManagerCollector(Context context) {
+        super(ReportField.DISPLAY);
+        this.context = context;
+    }
+
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final ComplexElement result = new ComplexElement();
+        for (Display display : DisplayManagerCompat.getInstance(context).getDisplays()) {
+            try {
+                result.put(String.valueOf(display.getDisplayId()), collectDisplayData(display));
+            } catch (JSONException e) {
+                ACRA.log.w(ACRA.LOG_TAG, "Failed to collect data for display " + display.getDisplayId(), e);
+            }
+        }
+
+        return result;
+    }
+
+    @NonNull
+    private JSONObject collectDisplayData(@NonNull Display display) throws JSONException {
+        final DisplayMetrics metrics = new DisplayMetrics();
+        display.getMetrics(metrics);
+
+        final JSONObject result = new JSONObject();
+        collectCurrentSizeRange(display, result);
+        collectFlags(display, result);
+        collectMetrics(display, result);
+        collectRealMetrics(display, result);
+        collectName(display, result);
+        collectRealSize(display, result);
+        collectRectSize(display, result);
+        collectSize(display, result);
+        collectRotation(display, result);
+        collectIsValid(display, result);
+        result.put("orientation", display.getRotation())
+                .put("refreshRate", display.getRefreshRate());
+        //noinspection deprecation
+        result.put("height", display.getHeight())
+                .put("width", display.getWidth())
+                .put("pixelFormat", display.getPixelFormat());
+        return result;
+    }
+
+    private static void collectIsValid(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            container.put("isValid", display.isValid());
+        }
+    }
+
+    private static void collectRotation(@NonNull Display display, JSONObject container) throws JSONException {
+        container.put("rotation", rotationToString(display.getRotation()));
+    }
+
+    @NonNull
+    private static String rotationToString(int rotation) {
+        switch (rotation) {
+            case Surface.ROTATION_0:
+                return "ROTATION_0";
+            case Surface.ROTATION_90:
+                return "ROTATION_90";
+            case Surface.ROTATION_180:
+                return "ROTATION_180";
+            case Surface.ROTATION_270:
+                return "ROTATION_270";
+            default:
+                return String.valueOf(rotation);
+        }
+    }
+
+    private static void collectRectSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final Rect size = new Rect();
+            display.getRectSize(size);
+            container.put("rectSize", new JSONArray(Arrays.asList(size.top, size.left, size.width(), size.height())));
+        }
+    }
+
+    private static void collectSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final Point size = new Point();
+            display.getSize(size);
+            container.put("size", new JSONArray(Arrays.asList(size.x, size.y)));
+        }
+    }
+
+    private static void collectRealSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final Point size = new Point();
+            display.getRealSize(size);
+            container.put("realSize", new JSONArray(Arrays.asList(size.x, size.y)));
+        }
+    }
+
+    private static void collectCurrentSizeRange(@NonNull Display display, @NonNull JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            final Point smallest = new Point();
+            final Point largest = new Point();
+            display.getCurrentSizeRange(smallest, largest);
+            final JSONObject result = new JSONObject();
+            result.put("smallest", new JSONArray(Arrays.asList(smallest.x, smallest.y)));
+            result.put("largest", new JSONArray(Arrays.asList(largest.x, largest.y)));
+            container.put("currentSizeRange", result);
+        }
+    }
+
+    private void collectFlags(@NonNull Display display, @NonNull JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final int flags = display.getFlags();
+            for (Field field : display.getClass().getFields()) {
+                if (field.getName().startsWith("FLAG_")) {
+                    try {
+                        flagNames.put(field.getInt(null), field.getName());
+                    } catch (IllegalAccessException ignored) {
+                    }
+                }
+            }
+            container.put("flags", activeFlags(flags));
+        }
+    }
+
+    private static void collectName(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            container.put("name", display.getName());
+        }
+    }
+
+    private static void collectMetrics(@NonNull Display display, JSONObject container) throws JSONException {
+        final DisplayMetrics metrics = new DisplayMetrics();
+        display.getMetrics(metrics);
+        final JSONObject result = new JSONObject();
+        collectMetrics(metrics, result);
+        container.put("metrics", result);
+    }
+
+    private static void collectRealMetrics(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final DisplayMetrics metrics = new DisplayMetrics();
+            display.getRealMetrics(metrics);
+            final JSONObject result = new JSONObject();
+            collectMetrics(metrics, result);
+            container.put("realMetrics", result);
+        }
+    }
+
+    private static void collectMetrics(@NonNull DisplayMetrics metrics, JSONObject container) throws JSONException {
+        container.put("density", metrics.density)
+                .put("densityDpi", metrics.densityDpi)
+                .put("scaledDensity", "x" + metrics.scaledDensity)
+                .put("widthPixels", metrics.widthPixels)
+                .put("heightPixels", metrics.heightPixels)
+                .put("xdpi", metrics.xdpi)
+                .put("ydpi", metrics.ydpi);
+    }
+
+    /**
+     * Some fields contain multiple value types which can be isolated by
+     * applying a bitmask. That method returns the concatenation of active
+     * values.
+     *
+     * @param bitfield The bitfield to inspect.
+     * @return The names of the different values contained in the bitfield,
+     * separated by '+'.
+     */
+    @NonNull
+    private String activeFlags(int bitfield) {
+        final StringBuilder result = new StringBuilder();
+
+        // Look for masks, apply it an retrieve the masked value
+        for (int i = 0; i < flagNames.size(); i++) {
+            final int maskValue = flagNames.keyAt(i);
+            final int value = bitfield & maskValue;
+            if (value > 0) {
+                if (result.length() > 0) {
+                    result.append('+');
+                }
+                result.append(flagNames.get(value));
+            }
+        }
+        return result.toString();
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/collector/DropBoxCollector.java b/acra/src/main/java/org/acra/collector/DropBoxCollector.java
new file mode 100644
index 00000000..2d1fd55e
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/DropBoxCollector.java
@@ -0,0 +1,138 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.Manifest;
+import android.content.Context;
+import android.os.Build;
+import android.os.DropBoxManager;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.acra.util.PackageManagerWrapper;
+
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects data from the {@link DropBoxManager}. A
+ * set of DropBox tags have been identified in the Android source code. , we
+ * collect data associated to these tags with hope that some of them could help
+ * debugging applications. Application specific tags can be provided by the app
+ * dev to track his own usage of the DropBoxManager.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class DropBoxCollector extends Collector {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final PackageManagerWrapper pm;
+
+    DropBoxCollector(Context context, ACRAConfiguration config, PackageManagerWrapper pm){
+        super(ReportField.DROPBOX);
+        this.context = context;
+        this.config = config;
+        this.pm = pm;
+    }
+
+    private static final String[] SYSTEM_TAGS = {"system_app_anr", "system_app_wtf", "system_app_crash",
+            "system_server_anr", "system_server_wtf", "system_server_crash", "BATTERY_DISCHARGE_INFO",
+            "SYSTEM_RECOVERY_LOG", "SYSTEM_BOOT", "SYSTEM_LAST_KMSG", "APANIC_CONSOLE", "APANIC_THREADS",
+            "SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode"};
+
+    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd'T'HHmmss", Locale.getDefault()); //iCal format (used for backwards compatibility)
+
+    /**
+     * Read latest messages contained in the DropBox for system related tags and
+     * optional developer-set tags.
+     *
+     * @return An Element listing messages retrieved.
+     */
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        try {
+            final DropBoxManager dropbox = (DropBoxManager) context.getSystemService(Context.DROPBOX_SERVICE);
+
+            final Calendar calendar = Calendar.getInstance();
+            calendar.roll(Calendar.MINUTE, -config.dropboxCollectionMinutes());
+            final long time = calendar.getTimeInMillis();
+            dateFormat.format(calendar.getTime());
+
+            final List<String> tags = new ArrayList<String>();
+            if (config.includeDropBoxSystemTags()) {
+                tags.addAll(Arrays.asList(SYSTEM_TAGS));
+            }
+            final List<String> additionalTags = config.additionalDropBoxTags();
+            if (!additionalTags.isEmpty()) {
+                tags.addAll(additionalTags);
+            }
+
+            if (tags.isEmpty()) {
+                return ACRAConstants.NOT_AVAILABLE;
+            }
+
+            final ComplexElement dropboxContent = new ComplexElement();
+            for (String tag : tags) {
+                final StringBuilder builder = new StringBuilder();
+                DropBoxManager.Entry entry = dropbox.getNextEntry(tag, time);
+                if (entry == null) {
+                    builder.append("Nothing.").append('\n');
+                    continue;
+                }
+                while (entry != null) {
+                    final long msec = entry.getTimeMillis();
+                    calendar.setTimeInMillis(msec);
+                    builder.append('@').append(dateFormat.format(calendar.getTime())).append('\n');
+                    final String text = entry.getText(500);
+                    if (text != null) {
+                        builder.append("Text: ").append(text).append('\n');
+                    } else {
+                        builder.append("Not Text!").append('\n');
+                    }
+                    entry.close();
+                    entry = dropbox.getNextEntry(tag, msec);
+                }
+                dropboxContent.put(tag, builder.toString());
+            }
+            return dropboxContent;
+
+        } catch (Exception e) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "DropBoxManager not available.");
+        }
+
+        return ACRAConstants.NOT_AVAILABLE;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && (pm.hasPermission(Manifest.permission.READ_LOGS) || Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN);
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/LogCatCollector.java b/acra/src/main/java/org/acra/collector/LogCatCollector.java
new file mode 100644
index 00000000..bfc6729e
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/LogCatCollector.java
@@ -0,0 +1,161 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.Manifest;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.android.internal.util.Predicate;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+import org.acra.util.PackageManagerWrapper;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+
+/**
+ * Executes logcat commands and collects it's output.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class LogCatCollector extends Collector {
+
+    private final ACRAConfiguration config;
+    private final PackageManagerWrapper pm;
+
+    LogCatCollector(ACRAConfiguration config, PackageManagerWrapper pm) {
+        super(ReportField.LOGCAT, ReportField.EVENTSLOG, ReportField.RADIOLOG);
+        this.config = config;
+        this.pm = pm;
+    }
+
+    /**
+     * Executes the logcat command with arguments taken from
+     * {@link ReportsCrashes#logcatArguments()}
+     *
+     * @param bufferName The name of the buffer to be read: "main" (default), "radio" or "events".
+     * @return A {@link String} containing the latest lines of the output.
+     * Default is 100 lines, use "-t", "300" in
+     * {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
+     * You should be aware that increasing this value causes a longer
+     * report generation time and a bigger footprint on the device data
+     * plan consumption.
+     */
+    private Element collectLogCat(@Nullable String bufferName) {
+        final int myPid = android.os.Process.myPid();
+        final String myPidStr = config.logcatFilterByPid() && myPid > 0 ? Integer.toString(myPid) + "):" : null;
+
+        final List<String> commandLine = new ArrayList<String>();
+        commandLine.add("logcat");
+        if (bufferName != null) {
+            commandLine.add("-b");
+            commandLine.add(bufferName);
+        }
+
+        final int tailCount;
+        final List<String> logcatArgumentsList = config.logcatArguments();
+
+        final int tailIndex = logcatArgumentsList.indexOf("-t");
+        if (tailIndex > -1 && tailIndex < logcatArgumentsList.size()) {
+            tailCount = Integer.parseInt(logcatArgumentsList.get(tailIndex + 1));
+        } else {
+            tailCount = -1;
+        }
+
+        Element logcat;
+        commandLine.addAll(logcatArgumentsList);
+
+        try {
+            final Process process =  new ProcessBuilder().command(commandLine).redirectErrorStream(true).start();
+
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Retrieving logcat output...");
+
+            logcat = new StringElement(streamToString(process.getInputStream(), new Predicate<String>() {
+                @Override
+                public boolean apply(String s) {
+                    return myPidStr == null || s.contains(myPidStr);
+                }
+            }, tailCount));
+            process.destroy();
+
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "LogCatCollector.collectLogCat could not retrieve data.", e);
+            logcat = ACRAConstants.NOT_AVAILABLE;
+        }
+
+        return logcat;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder)
+                && (pm.hasPermission(Manifest.permission.READ_LOGS)
+                || Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        String bufferName = null;
+        switch (reportField) {
+            case LOGCAT:
+                bufferName = null;
+                break;
+            case EVENTSLOG:
+                bufferName = "events";
+                break;
+            case RADIOLOG:
+                bufferName = "radio";
+                break;
+        }
+        return collectLogCat(bufferName);
+    }
+
+    /**
+     * Reads an InputStream into a string in an non blocking way for current thread
+     * It has a default timeout of 3 seconds.
+     *
+     * @param input  the stream
+     * @param filter should return false for lines which should be excluded
+     * @param limit  the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the stream cannot be read.
+     */
+    @NonNull
+    private String streamToString(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        if (config.nonBlockingReadForLogcat()) {
+            return IOUtils.streamToStringNonBlockingRead(input, filter, limit);
+        } else {
+            return IOUtils.streamToString(input, filter, limit);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/LogFileCollector.java b/acra/src/main/java/org/acra/collector/LogFileCollector.java
new file mode 100644
index 00000000..5e17f4b4
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/LogFileCollector.java
@@ -0,0 +1,102 @@
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.app.Application;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.Directory;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects the N last lines of a text stream. Use this collector if your
+ * application handles its own logging system.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class LogFileCollector extends Collector {
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    LogFileCollector(Context context, ACRAConfiguration config) {
+        super(ReportField.APPLICATION_LOG);
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Reads the last lines of a custom log file. The file name is assumed as
+     * located in the {@link Application#getFilesDir()} directory if it does not
+     * contain any path separator.
+     *
+     * @return An Element containing all of the requested lines.
+     */
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        try {
+            return new StringElement(IOUtils.streamToString(
+                    getStream(config.applicationLogFileDir(), config.applicationLogFile()),
+                    config.applicationLogFileLines()));
+        } catch (IOException e) {
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    /**
+     * get the application log file location and open it
+     *
+     * @param directory the base directory for the file path
+     * @param fileName the name of the file
+     * @return a stream to the file or an empty stream if the file was not found
+     */
+    @NonNull
+    private InputStream getStream(@NonNull Directory directory, @NonNull String fileName) {
+        final File file = directory.getFile(context, fileName);
+        if (!file.exists()) {
+            if (ACRA.DEV_LOGGING)
+                ACRA.log.d(LOG_TAG, "Log file '" + file.getPath() + "' does not exist");
+        } else if (file.isDirectory()) {
+            ACRA.log.e(LOG_TAG, "Log file '" + file.getPath() + "' is a directory");
+        } else if (!file.canRead()) {
+            ACRA.log.e(LOG_TAG, "Log file '" + file.getPath() + "' can't be read");
+        } else {
+            try {
+                return new FileInputStream(file);
+            } catch (IOException e) {
+                ACRA.log.e(LOG_TAG, "Could not open stream for log file '" + file.getPath() + "'");
+            }
+        }
+        return new ByteArrayInputStream(new byte[0]);
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/MediaCodecListCollector.java b/acra/src/main/java/org/acra/collector/MediaCodecListCollector.java
new file mode 100644
index 00000000..21fd5673
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/MediaCodecListCollector.java
@@ -0,0 +1,279 @@
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.annotation.TargetApi;
+import android.media.MediaCodecInfo;
+import android.media.MediaCodecList;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.SparseArray;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Set;
+
+/**
+ * Collects data about available codecs on the device through the MediaCodecList
+ * API introduced in Android 4.1 JellyBean.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class MediaCodecListCollector extends Collector {
+
+    private enum CodecType {
+        AVC, H263, MPEG4, AAC
+
+    }
+
+    private static final String COLOR_FORMAT_PREFIX = "COLOR_";
+    private static final String[] MPEG4_TYPES = {"mp4", "mpeg4", "MP4", "MPEG4"};
+    private static final String[] AVC_TYPES = {"avc", "h264", "AVC", "H264"};
+    private static final String[] H263_TYPES = {"h263", "H263"};
+    private static final String[] AAC_TYPES = {"aac", "AAC"};
+
+    private final SparseArray<String> mColorFormatValues = new SparseArray<String>();
+    private final SparseArray<String> mAVCLevelValues = new SparseArray<String>();
+    private final SparseArray<String> mAVCProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mH263LevelValues = new SparseArray<String>();
+    private final SparseArray<String> mH263ProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
+    private final SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mAACProfileValues = new SparseArray<String>();
+
+    MediaCodecListCollector() {
+        super(ReportField.MEDIA_CODEC_LIST);
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        try {
+            return collectMediaCodecList();
+        } catch (JSONException e) {
+            ACRA.log.w("Could not collect media codecs", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;
+    }
+
+    /**
+     * use reflection to prepare field arrays.
+     */
+    private void prepare() {
+        try {
+            final Class<?> codecCapabilitiesClass = Class.forName("android.media.MediaCodecInfo$CodecCapabilities");
+
+            // Retrieve list of possible Color Format
+            for (Field f : codecCapabilitiesClass.getFields()) {
+                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())
+                        && f.getName().startsWith(COLOR_FORMAT_PREFIX)) {
+                    mColorFormatValues.put(f.getInt(null), f.getName());
+                }
+            }
+
+            // Retrieve lists of possible codecs profiles and levels
+            final Class<?> codecProfileLevelClass = Class.forName("android.media.MediaCodecInfo$CodecProfileLevel");
+            for (Field f : codecProfileLevelClass.getFields()) {
+                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
+                    if (f.getName().startsWith("AVCLevel")) {
+                        mAVCLevelValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("AVCProfile")) {
+                        mAVCProfileValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("H263Level")) {
+                        mH263LevelValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("H263Profile")) {
+                        mH263ProfileValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("MPEG4Level")) {
+                        mMPEG4LevelValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("MPEG4Profile")) {
+                        mMPEG4ProfileValues.put(f.getInt(null), f.getName());
+                    } else if (f.getName().startsWith("AAC")) {
+                        mAACProfileValues.put(f.getInt(null), f.getName());
+                    }
+                }
+            }
+        } catch (@NonNull ClassNotFoundException ignored) {
+            // NOOP
+        } catch (@NonNull SecurityException ignored) {
+            // NOOP
+        } catch (@NonNull IllegalAccessException ignored) {
+            // NOOP
+        } catch (@NonNull IllegalArgumentException ignored) {
+            // NOOP
+        }
+
+    }
+
+    /**
+     * Builds an Element describing the list of available codecs on the device
+     * with their capabilities (supported Color Formats, Codec Profiles et
+     * Levels).
+     *
+     * @return The media codecs information
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    @NonNull
+    private Element collectMediaCodecList() throws JSONException {
+        prepare();
+        final MediaCodecInfo[] infos;
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            //noinspection deprecation
+            final int codecCount = MediaCodecList.getCodecCount();
+            infos = new MediaCodecInfo[codecCount];
+            for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
+                //noinspection deprecation
+                infos[codecIdx] = MediaCodecList.getCodecInfoAt(codecIdx);
+            }
+        } else {
+            infos = new MediaCodecList(MediaCodecList.ALL_CODECS).getCodecInfos();
+        }
+
+        final ComplexElement result = new ComplexElement();
+        for (int i = 0; i < infos.length; i++) {
+            final MediaCodecInfo codecInfo = infos[i];
+            final JSONObject codec = new JSONObject();
+            final String[] supportedTypes = codecInfo.getSupportedTypes();
+            codec.put("name", codecInfo.getName())
+                    .put("isEncoder", codecInfo.isEncoder());
+            final JSONObject supportedTypesJson = new JSONObject();
+            for (String type : supportedTypes) {
+                supportedTypesJson.put(type, collectCapabilitiesForType(codecInfo, type));
+            }
+            codec.put("supportedTypes", supportedTypesJson);
+            result.put(String.valueOf(i), codec);
+        }
+        return result;
+    }
+
+    /**
+     * Retrieve capabilities (ColorFormats and CodecProfileLevels) for a
+     * specific codec type.
+     *
+     * @param codecInfo the currently inspected codec
+     * @param type      supported type to collect
+     * @return the color formats and codec profile levels
+     * available for a specific codec type.
+     */
+    @NonNull
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private JSONObject collectCapabilitiesForType(@NonNull final MediaCodecInfo codecInfo, @NonNull String type) throws JSONException {
+        final JSONObject result = new JSONObject();
+        final MediaCodecInfo.CodecCapabilities codecCapabilities = codecInfo.getCapabilitiesForType(type);
+
+        // Color Formats
+        final int[] colorFormats = codecCapabilities.colorFormats;
+        if (colorFormats.length > 0) {
+            final JSONArray colorFormatsJson = new JSONArray();
+            for (int colorFormat : colorFormats) {
+                colorFormatsJson.put(mColorFormatValues.get(colorFormat));
+            }
+            result.put("colorFormats", colorFormatsJson);
+        }
+
+        final CodecType codecType = identifyCodecType(codecInfo);
+
+        // Profile Levels
+        final MediaCodecInfo.CodecProfileLevel[] codecProfileLevels = codecCapabilities.profileLevels;
+        if (codecProfileLevels.length > 0) {
+            final JSONArray profileLevels = new JSONArray();
+            for (MediaCodecInfo.CodecProfileLevel codecProfileLevel : codecProfileLevels) {
+                final int profileValue = codecProfileLevel.profile;
+                final int levelValue = codecProfileLevel.level;
+
+                if (codecType == null) {
+                    // Unknown codec
+                    profileLevels.put(profileValue + '-' + levelValue);
+                    break;
+                }
+
+                switch (codecType) {
+                    case AVC:
+                        profileLevels.put(profileValue + mAVCProfileValues.get(profileValue)
+                                + '-' + mAVCLevelValues.get(levelValue));
+                        break;
+                    case H263:
+                        profileLevels.put(mH263ProfileValues.get(profileValue)
+                                + '-' + mH263LevelValues.get(levelValue));
+                        break;
+                    case MPEG4:
+                        profileLevels.put(mMPEG4ProfileValues.get(profileValue)
+                                + '-' + mMPEG4LevelValues.get(levelValue));
+                        break;
+                    case AAC:
+                        profileLevels.put(mAACProfileValues.get(profileValue));
+                        break;
+                    default:
+                        break;
+                }
+            }
+            result.put("profileLevels", profileLevels);
+        }
+        return result;
+    }
+
+    /**
+     * Looks for keywords in the codec name to identify its nature ({@link CodecType}).
+     *
+     * @param codecInfo the currently inspected codec
+     * @return type of the codec or null if it could bot be guessed
+     */
+    @Nullable
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private CodecType identifyCodecType(@NonNull MediaCodecInfo codecInfo) {
+
+        final String name = codecInfo.getName();
+        for (String token : AVC_TYPES) {
+            if (name.contains(token)) {
+                return CodecType.AVC;
+            }
+        }
+        for (String token : H263_TYPES) {
+            if (name.contains(token)) {
+                return CodecType.H263;
+            }
+        }
+        for (String token : MPEG4_TYPES) {
+            if (name.contains(token)) {
+                return CodecType.MPEG4;
+            }
+        }
+        for (String token : AAC_TYPES) {
+            if (name.contains(token)) {
+                return CodecType.AAC;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/MemoryInfoCollector.java b/acra/src/main/java/org/acra/collector/MemoryInfoCollector.java
new file mode 100644
index 00000000..9e328151
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/MemoryInfoCollector.java
@@ -0,0 +1,140 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.os.Build;
+import android.os.Environment;
+import android.os.StatFs;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects results of the <code>dumpsys</code> command.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class MemoryInfoCollector extends Collector {
+    MemoryInfoCollector() {
+        super(ReportField.DUMPSYS_MEMINFO, ReportField.TOTAL_MEM_SIZE, ReportField.AVAILABLE_MEM_SIZE);
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && !(reportBuilder.getException() instanceof OutOfMemoryError);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case DUMPSYS_MEMINFO:
+                return collectMemInfo();
+            case TOTAL_MEM_SIZE:
+                return new NumberElement(getTotalInternalMemorySize());
+            case AVAILABLE_MEM_SIZE:
+                return new NumberElement(getAvailableInternalMemorySize());
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Collect results of the <code>dumpsys meminfo</code> command restricted to
+     * this application process.
+     *
+     * @return The execution result.
+     */
+    @NonNull
+    private static Element collectMemInfo() {
+
+        try {
+            final List<String> commandLine = new ArrayList<String>();
+            commandLine.add("dumpsys");
+            commandLine.add("meminfo");
+            commandLine.add(Integer.toString(android.os.Process.myPid()));
+
+            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
+            return new StringElement(IOUtils.streamToString(process.getInputStream()));
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "MemoryInfoCollector.meminfo could not retrieve data", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    /**
+     * Calculates the free memory of the device. This is based on an inspection of the filesystem, which in android
+     * devices is stored in RAM.
+     *
+     * @return Number of bytes available.
+     */
+    private static long getAvailableInternalMemorySize() {
+        final File path = Environment.getDataDirectory();
+        final StatFs stat = new StatFs(path.getPath());
+        final long blockSize;
+        final long availableBlocks;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            blockSize = stat.getBlockSizeLong();
+            availableBlocks = stat.getAvailableBlocksLong();
+        } else {
+            //noinspection deprecation
+            blockSize = stat.getBlockSize();
+            //noinspection deprecation
+            availableBlocks = stat.getAvailableBlocks();
+        }
+        return availableBlocks * blockSize;
+    }
+
+    /**
+     * Calculates the total memory of the device. This is based on an inspection of the filesystem, which in android
+     * devices is stored in RAM.
+     *
+     * @return Total number of bytes.
+     */
+    private static long getTotalInternalMemorySize() {
+        final File path = Environment.getDataDirectory();
+        final StatFs stat = new StatFs(path.getPath());
+        final long blockSize;
+        final long totalBlocks;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            blockSize = stat.getBlockSizeLong();
+            totalBlocks = stat.getBlockCountLong();
+        } else {
+            //noinspection deprecation
+            blockSize = stat.getBlockSize();
+            //noinspection deprecation
+            totalBlocks = stat.getBlockCount();
+        }
+        return totalBlocks * blockSize;
+    }
+
+}
\ No newline at end of file
diff --git a/acra/src/main/java/org/acra/collector/PackageManagerCollector.java b/acra/src/main/java/org/acra/collector/PackageManagerCollector.java
new file mode 100644
index 00000000..9d88e98a
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/PackageManagerCollector.java
@@ -0,0 +1,57 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.pm.PackageInfo;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.PackageManagerWrapper;
+
+/**
+ * Collects PackageInfo values
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class PackageManagerCollector extends Collector {
+    private final PackageManagerWrapper pm;
+
+    PackageManagerCollector(PackageManagerWrapper pm) {
+        super(ReportField.APP_VERSION_NAME, ReportField.APP_VERSION_CODE);
+        this.pm = pm;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final PackageInfo info = pm.getPackageInfo();
+        if (info != null) {
+            switch (reportField) {
+                case APP_VERSION_NAME:
+                    return new StringElement(info.versionName);
+                case APP_VERSION_CODE:
+                    return new NumberElement(info.versionCode);
+            }
+        }
+        return ACRAConstants.NOT_AVAILABLE;
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/ReflectionCollector.java b/acra/src/main/java/org/acra/collector/ReflectionCollector.java
new file mode 100644
index 00000000..d4fcd059
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/ReflectionCollector.java
@@ -0,0 +1,164 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.content.Context;
+import android.os.Build;
+import android.os.Environment;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collector retrieving key/value pairs from static fields and getters.
+ * Reflection API usage allows to retrieve data without having to
+ * implement a class for each android version of each interesting class.
+ * It can also help find hidden properties.
+ *
+ * @author Kevin Gaudin
+ */
+final class ReflectionCollector extends Collector {
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    ReflectionCollector(Context context, ACRAConfiguration config) {
+        super(ReportField.BUILD, ReportField.BUILD_CONFIG, ReportField.ENVIRONMENT);
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Retrieves key/value pairs from static fields of a class.
+     *
+     * @param someClass the class to be inspected.
+     */
+    private static void collectConstants(@NonNull Class<?> someClass, @NonNull JSONObject container) throws JSONException {
+        final Field[] fields = someClass.getFields();
+        for (final Field field : fields) {
+            try {
+                final Object value = field.get(null);
+                if (value != null) {
+                    if (field.getType().isArray()) {
+                        container.put(field.getName(), new JSONArray(Arrays.asList((Object[]) value)));
+                    } else {
+                        container.put(field.getName(), value);
+                    }
+                }
+            } catch (IllegalArgumentException ignored) {
+                // NOOP
+            } catch (IllegalAccessException ignored) {
+                // NOOP
+            }
+        }
+    }
+
+    /**
+     * Retrieves key/value pairs from static getters of a class (get*() or is*()).
+     *
+     * @param someClass the class to be inspected.
+     */
+    private static void collectStaticGettersResults(@NonNull Class<?> someClass, JSONObject container) throws JSONException {
+        final Method[] methods = someClass.getMethods();
+        for (final Method method : methods) {
+            if (method.getParameterTypes().length == 0
+                    && (method.getName().startsWith("get") || method.getName().startsWith("is"))
+                    && !"getClass".equals(method.getName())) {
+                try {
+                    container.put(method.getName(), method.invoke(null, (Object[]) null));
+                } catch (@NonNull IllegalArgumentException ignored) {
+                    // NOOP
+                } catch (@NonNull InvocationTargetException ignored) {
+                    // NOOP
+                } catch (@NonNull IllegalAccessException ignored) {
+                    // NOOP
+                }
+            }
+        }
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final ComplexElement result = new ComplexElement();
+        try {
+            switch (reportField) {
+                case BUILD:
+                    collectConstants(Build.class, result);
+                    final JSONObject version = new JSONObject();
+                    collectConstants(Build.VERSION.class, version);
+                    result.put("VERSION", version);
+                    break;
+                case BUILD_CONFIG:
+                    try {
+                        collectConstants(getBuildConfigClass(), result);
+                    } catch (ClassNotFoundException e) {
+                        //already logged in getBuildConfigClass
+                    }
+                    break;
+                case ENVIRONMENT:
+                    collectStaticGettersResults(Environment.class, result);
+                    break;
+                default:
+                    //will not happen if used correctly
+                    throw new IllegalArgumentException();
+            }
+        } catch (JSONException e) {
+            ACRA.log.w("Couldn't collect constants", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+        return result;
+    }
+
+    /**
+     * get the configured BuildConfigClass or guess it if not configured
+     * @return the BuildConfigClass
+     * @throws ClassNotFoundException if the class cannot be found
+     */
+    @NonNull
+    private Class<?> getBuildConfigClass() throws ClassNotFoundException {
+        final Class configuredBuildConfig = config.buildConfigClass();
+        if (!configuredBuildConfig.equals(Object.class)) {
+            // If set via annotations or programmatically then it will have a real value,
+            // otherwise it will be Object.class (default).
+            return configuredBuildConfig;
+        }
+
+        final String className = context.getPackageName() + ".BuildConfig";
+        try {
+            return Class.forName(className);
+        } catch (ClassNotFoundException e) {
+            ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
+            throw e;
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/SettingsCollector.java b/acra/src/main/java/org/acra/collector/SettingsCollector.java
new file mode 100644
index 00000000..3a55e7bc
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/SettingsCollector.java
@@ -0,0 +1,184 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.content.Context;
+import android.os.Build;
+import android.provider.Settings.Global;
+import android.provider.Settings.Secure;
+import android.provider.Settings.System;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
+
+import java.lang.reflect.Field;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * collects data from {@link System}, {@link Global} and {@link Secure} Settings
+ * classes.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class SettingsCollector extends Collector {
+
+    private static final String ERROR = "Error: ";
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    SettingsCollector(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        super(ReportField.SETTINGS_SYSTEM, ReportField.SETTINGS_SECURE, ReportField.SETTINGS_GLOBAL);
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Collect data from {@link System}. This
+     * collector uses reflection to be sure to always get the most accurate data
+     * whatever Android API level it runs on.
+     *
+     * @return collected key-value pairs.
+     */
+    @NonNull
+    private Element collectSystemSettings() throws JSONException {
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = System.class.getFields();
+        for (final Field key : keys) {
+            // Avoid retrieving deprecated fields... it is useless, has an
+            // impact on prefs, and the system writes many warnings in the
+            // logcat.
+            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class) {
+                try {
+                    final Object value = System.getString(context.getContentResolver(), (String) key.get(null));
+                    if (value != null) {
+                        result.put(key.getName(), value);
+                    }
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Collect data from {@link Secure}. This
+     * collector uses reflection to be sure to always get the most accurate data
+     * whatever Android API level it runs on.
+     *
+     * @return collected key-value pairs.
+     */
+    @NonNull
+    private Element collectSecureSettings() throws JSONException {
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = Secure.class.getFields();
+        for (final Field key : keys) {
+            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
+                try {
+                    final Object value = Secure.getString(context.getContentResolver(), (String) key.get(null));
+                    if (value != null) {
+                        result.put(key.getName(), value);
+                    }
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Collect data from {@link Global}. This
+     * collector uses reflection to be sure to always get the most accurate data
+     * whatever Android API level it runs on.
+     *
+     * @return collected key-value pairs.
+     */
+    @NonNull
+    private Element collectGlobalSettings() throws JSONException {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = Global.class.getFields();
+        for (final Field key : keys) {
+            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
+                try {
+                    final Object value = Global.getString(context.getContentResolver(), (String) key.get(null));
+                    if (value != null) {
+                        result.put(key.getName(), value);
+                    }
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull SecurityException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                }
+            }
+        }
+        return result;
+    }
+
+    private boolean isAuthorized(@Nullable Field key) {
+        if (key == null || key.getName().startsWith("WIFI_AP")) {
+            return false;
+        }
+        for (String regex : config.excludeMatchingSettingsKeys()) {
+            if (key.getName().matches(regex)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        try {
+        switch (reportField) {
+            case SETTINGS_SYSTEM:
+                    return collectSystemSettings();
+            case SETTINGS_SECURE:
+                return collectSecureSettings();
+            case SETTINGS_GLOBAL:
+                return collectGlobalSettings();
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+        } catch (JSONException e) {
+            ACRA.log.w("Could not collect Settings", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/SharedPreferencesCollector.java b/acra/src/main/java/org/acra/collector/SharedPreferencesCollector.java
new file mode 100644
index 00000000..686b2cef
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/SharedPreferencesCollector.java
@@ -0,0 +1,139 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects the content (key/value pairs) of SharedPreferences, from the
+ * application default preferences or any other preferences asked by the
+ * application developer.
+ */
+final class SharedPreferencesCollector extends Collector {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final SharedPreferences prefs;
+
+    SharedPreferencesCollector(@NonNull Context context, @NonNull ACRAConfiguration config, SharedPreferences prefs) {
+        super(ReportField.USER_EMAIL, ReportField.SHARED_PREFERENCES);
+        this.context = context;
+        this.config = config;
+        this.prefs = prefs;
+    }
+
+    /**
+     * Collects all key/value pairs in SharedPreferences.
+     * The application default SharedPreferences are always
+     * collected, and the developer can provide additional SharedPreferences
+     * names in the {@link ReportsCrashes#additionalSharedPreferences()}
+     * configuration item.
+     *
+     * @return the collected key/value pairs.
+     */
+    @NonNull
+    private Element collect() throws JSONException {
+        final ComplexElement result = new ComplexElement();
+
+        // Include the default SharedPreferences
+        final Map<String, SharedPreferences> sharedPrefs = new TreeMap<String, SharedPreferences>();
+        sharedPrefs.put("default", PreferenceManager.getDefaultSharedPreferences(context));
+
+        // Add in any additional SharedPreferences
+        for (final String sharedPrefId : config.additionalSharedPreferences()) {
+            sharedPrefs.put(sharedPrefId, context.getSharedPreferences(sharedPrefId, Context.MODE_PRIVATE));
+        }
+
+        // Iterate over all included preference files and add the preferences from each.
+        for (Map.Entry<String, SharedPreferences> entry : sharedPrefs.entrySet()) {
+            final String sharedPrefId = entry.getKey();
+            final SharedPreferences prefs = entry.getValue();
+
+            final Map<String, ?> prefEntries = prefs.getAll();
+
+            // Show that we have no preferences saved for that preference file.
+            if (prefEntries.isEmpty()) {
+                result.put(sharedPrefId, "empty");
+            } else {
+                for (final Iterator<String> iterator = prefEntries.keySet().iterator(); iterator.hasNext();){
+                    if(filteredKey(iterator.next())){
+                        iterator.remove();
+                    }
+                }
+                result.put(sharedPrefId, new JSONObject(prefEntries));
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Checks if the key matches one of the patterns provided by the developer
+     * to exclude some preferences from reports.
+     *
+     * @param key the name of the preference to be checked
+     * @return true if the key has to be excluded from reports.
+     */
+    private boolean filteredKey(@NonNull String key) {
+        for (String regex : config.excludeMatchingSharedPreferencesKeys()) {
+            if (key.matches(regex)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case USER_EMAIL:
+                final String email = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, null);
+                return email != null ? new StringElement(email) : ACRAConstants.NOT_AVAILABLE;
+            case SHARED_PREFERENCES:
+                try {
+                    return collect();
+                } catch (JSONException e) {
+                    ACRA.log.w(LOG_TAG, "Could not collect shared preferences", e);
+                    return ACRAConstants.NOT_AVAILABLE;
+                }
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/SimpleValuesCollector.java b/acra/src/main/java/org/acra/collector/SimpleValuesCollector.java
new file mode 100644
index 00000000..993541f7
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/SimpleValuesCollector.java
@@ -0,0 +1,125 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.BooleanElement;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.Installation;
+
+import java.io.File;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+import java.util.Set;
+import java.util.UUID;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects various simple values
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class SimpleValuesCollector extends Collector {
+    private final Context context;
+
+    SimpleValuesCollector(Context context) {
+        super(ReportField.IS_SILENT, ReportField.REPORT_ID, ReportField.INSTALLATION_ID,
+                ReportField.PACKAGE_NAME, ReportField.PHONE_MODEL, ReportField.ANDROID_VERSION,
+                ReportField.BRAND, ReportField.PRODUCT, ReportField.FILE_PATH, ReportField.USER_IP);
+        this.context = context;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return collect == ReportField.IS_SILENT || collect == ReportField.REPORT_ID || super.shouldCollect(crashReportFields, collect, reportBuilder);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case IS_SILENT:
+                return new BooleanElement(reportBuilder.isSendSilently());
+            case REPORT_ID:
+                return new StringElement(UUID.randomUUID().toString());
+            case INSTALLATION_ID:
+                return new StringElement(Installation.id(context));
+            case PACKAGE_NAME:
+                return new StringElement(context.getPackageName());
+            case PHONE_MODEL:
+                return new StringElement(Build.MODEL);
+            case ANDROID_VERSION:
+                return new StringElement(Build.VERSION.RELEASE);
+            case BRAND:
+                return new StringElement(Build.BRAND);
+            case PRODUCT:
+                return new StringElement(Build.PRODUCT);
+            case FILE_PATH:
+                return new StringElement(getApplicationFilePath());
+            case USER_IP:
+                return new StringElement(getLocalIpAddress());
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    @NonNull
+    private String getApplicationFilePath() {
+        final File filesDir = context.getFilesDir();
+        if (filesDir != null) {
+            return filesDir.getAbsolutePath();
+        }
+
+        ACRA.log.w(LOG_TAG, "Couldn't retrieve ApplicationFilePath for : " + context.getPackageName());
+        return "Couldn't retrieve ApplicationFilePath";
+    }
+
+    @NonNull
+    private static String getLocalIpAddress() {
+        final StringBuilder result = new StringBuilder();
+        boolean first = true;
+        try {
+            for (final Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
+                final NetworkInterface intf = en.nextElement();
+                for (final Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {
+                    final InetAddress inetAddress = enumIpAddr.nextElement();
+                    if (!inetAddress.isLoopbackAddress()) {
+                        if (!first) {
+                            result.append('\n');
+                        }
+                        result.append(inetAddress.getHostAddress());
+                        first = false;
+                    }
+                }
+            }
+        } catch (SocketException ex) {
+            ACRA.log.w(LOG_TAG, ex.toString());
+        }
+        return result.toString();
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/StacktraceCollector.java b/acra/src/main/java/org/acra/collector/StacktraceCollector.java
new file mode 100644
index 00000000..98b03fb1
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/StacktraceCollector.java
@@ -0,0 +1,100 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.Set;
+
+/**
+ * Collects the holy stacktrace
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class StacktraceCollector extends Collector {
+    StacktraceCollector() {
+        super(ReportField.STACK_TRACE, ReportField.STACK_TRACE_HASH);
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return collect == ReportField.STACK_TRACE || super.shouldCollect(crashReportFields, collect, reportBuilder);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case STACK_TRACE:
+                return new StringElement(
+                        getStackTrace(reportBuilder.getMessage(), reportBuilder.getException()));
+            case STACK_TRACE_HASH:
+                return new StringElement(getStackTraceHash(reportBuilder.getException()));
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    @NonNull
+    private String getStackTrace(@Nullable String msg, @Nullable Throwable th) {
+        final Writer result = new StringWriter();
+        final PrintWriter printWriter = new PrintWriter(result);
+
+        if (msg != null && !TextUtils.isEmpty(msg)) {
+            printWriter.println(msg);
+        }
+
+        // If the exception was thrown in a background thread inside
+        // AsyncTask, then the actual exception can be found with getCause
+        Throwable cause = th;
+        while (cause != null) {
+            cause.printStackTrace(printWriter);
+            cause = cause.getCause();
+        }
+        final String stacktraceAsString = result.toString();
+        printWriter.close();
+
+        return stacktraceAsString;
+    }
+
+    @NonNull
+    private String getStackTraceHash(@Nullable Throwable th) {
+        final StringBuilder res = new StringBuilder();
+        Throwable cause = th;
+        while (cause != null) {
+            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
+            for (final StackTraceElement e : stackTraceElements) {
+                res.append(e.getClassName());
+                res.append(e.getMethodName());
+            }
+            cause = cause.getCause();
+        }
+
+        return Integer.toHexString(res.toString().hashCode());
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/ThreadCollector.java b/acra/src/main/java/org/acra/collector/ThreadCollector.java
new file mode 100644
index 00000000..f45bfb0f
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/ThreadCollector.java
@@ -0,0 +1,64 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
+
+/**
+ * Collects some data identifying a Thread
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class ThreadCollector extends Collector {
+    ThreadCollector() {
+        super(ReportField.THREAD_DETAILS);
+    }
+
+    /**
+     * collects some data identifying the crashed thread
+     *
+     * @return the information including the id, name and priority of the thread.
+     */
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final Thread t = reportBuilder.getUncaughtExceptionThread();
+        final ComplexElement result = new ComplexElement();
+        if (t != null) {
+            try {
+                result.put("id", t.getId());
+                result.put("name", t.getName());
+                result.put("priority", t.getPriority());
+                if (t.getThreadGroup() != null) {
+                    result.put("groupName", t.getThreadGroup().getName());
+                }
+            } catch (JSONException e) {
+                e.printStackTrace();
+            }
+        } else {
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+        return result;
+    }
+}
diff --git a/acra/src/main/java/org/acra/collector/TimeCollector.java b/acra/src/main/java/org/acra/collector/TimeCollector.java
new file mode 100644
index 00000000..1b176219
--- /dev/null
+++ b/acra/src/main/java/org/acra/collector/TimeCollector.java
@@ -0,0 +1,74 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.Set;
+
+/**
+ * collects time information
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class TimeCollector extends Collector {
+    private final Calendar appStartDate;
+
+    TimeCollector(Calendar appStartDate) {
+        super(ReportField.USER_APP_START_DATE, ReportField.USER_CRASH_DATE);
+        this.appStartDate = appStartDate;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return true;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final Calendar time;
+        switch (reportField) {
+            case USER_APP_START_DATE:
+                time = appStartDate;
+                break;
+            case USER_CRASH_DATE:
+                time = new GregorianCalendar();
+                break;
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+        return new StringElement(getTimeString(time));
+    }
+
+    @NonNull
+    private static String getTimeString(@NonNull Calendar time) {
+        final SimpleDateFormat format = new SimpleDateFormat(ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
+        return format.format(time.getTimeInMillis());
+    }
+}
diff --git a/src/main/java/org/acra/ACRAConfigurationException.java b/acra/src/main/java/org/acra/config/ACRAConfigurationException.java
similarity index 85%
rename from src/main/java/org/acra/ACRAConfigurationException.java
rename to acra/src/main/java/org/acra/config/ACRAConfigurationException.java
index 55a27f3b..380d3e79 100644
--- a/src/main/java/org/acra/ACRAConfigurationException.java
+++ b/acra/src/main/java/org/acra/config/ACRAConfigurationException.java
@@ -1,30 +1,34 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-/**
- * A simple Exception used when required configuration items are missing.
- * 
- * @author Kevin Gaudin
- */
-public class ACRAConfigurationException extends Exception {
-
-    private static final long serialVersionUID = -7355339673505996110L;
-
-    public ACRAConfigurationException(String msg) {
-        super(msg);
-    }
-}
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+/**
+ * A simple Exception used when required configuration items are missing.
+ * 
+ * @author Kevin Gaudin
+ */
+public class ACRAConfigurationException extends Exception {
+
+    private static final long serialVersionUID = -7355339673505996110L;
+
+    public ACRAConfigurationException(String msg) {
+        super(msg);
+    }
+
+    public ACRAConfigurationException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+}
diff --git a/acra/src/main/java/org/acra/config/ConfigurationBuilder.java b/acra/src/main/java/org/acra/config/ConfigurationBuilder.java
new file mode 100644
index 00000000..19781b2e
--- /dev/null
+++ b/acra/src/main/java/org/acra/config/ConfigurationBuilder.java
@@ -0,0 +1,186 @@
+/*
+ *  Copyright 2011 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import android.app.Application;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.annotation.NoPropagation;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.sender.HttpSender;
+
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ACRAConstants.*;
+
+/**
+ * Builder responsible for programmatic construction of an immutable {@link ACRAConfiguration}.
+ *
+ * @since 4.8.1
+ */
+@SuppressWarnings("unused")
+@org.acra.annotation.ConfigurationBuilder
+public final class ConfigurationBuilder extends BaseConfigurationBuilder<ConfigurationBuilder> {
+
+    private final Map<String, String> httpHeaders;
+    private final Map<ReportField, Boolean> reportContentChanges;
+
+    /**
+     * Constructs a ConfigurationBuilder that is prepopulated with any
+     * '@ReportCrashes' annotation declared on the Application class.
+     *
+     * @param app Current Application, from which any annotated config will be gleaned.
+     */
+    public ConfigurationBuilder(@NonNull Application app) {
+        super(app);
+        httpHeaders = new HashMap<String, String>();
+        reportContentChanges = new EnumMap<ReportField, Boolean>(ReportField.class);
+    }
+
+    /**
+     * Builds the {@link ACRAConfiguration} which will be used to configure ACRA.
+     * <p>
+     * You can pass this {@link ConfigurationBuilder} to {@link ACRA#init(Application, ConfigurationBuilder)} and
+     * {@link ACRA#init(Application, ConfigurationBuilder)} will handle any Exception.
+     * </p>
+     *
+     * @return new ACRAConfiguration containing all the properties configured on this builder.
+     * @throws ACRAConfigurationException if the required values for the configured notification mode have not been provided.
+     */
+    @NoPropagation
+    @NonNull
+    public ACRAConfiguration build() throws ACRAConfigurationException {
+
+        switch (reportingInteractionMode()) {
+            case TOAST:
+                if (resToastText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            case NOTIFICATION:
+                if (resNotifTickerText() == DEFAULT_RES_VALUE || resNotifTitle() == DEFAULT_RES_VALUE || resNotifText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
+                }
+                if (CrashReportDialog.class.equals(reportDialogClass()) && resDialogText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            case DIALOG:
+                if (CrashReportDialog.class.equals(reportDialogClass()) && resDialogText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            default:
+                break;
+        }
+
+        if (reportSenderFactoryClasses().length == 0) {
+            throw new ACRAConfigurationException("Report sender factories: using no report senders will make ACRA useless. Configure at least one ReportSenderFactory.");
+        }
+        checkValidity((Class[]) reportSenderFactoryClasses());
+        checkValidity(reportDialogClass(), reportPrimerClass(), retryPolicyClass(), keyStoreFactoryClass());
+
+        return new ACRAConfiguration(this);
+    }
+
+    private void checkValidity(Class<?>... classes) throws ACRAConfigurationException {
+        for (Class<?> clazz : classes) {
+            if (clazz.isInterface()) {
+                throw new ACRAConfigurationException("Expected class, but found interface " + clazz.getName() + ".");
+            } else if (Modifier.isAbstract(clazz.getModifiers())) {
+                throw new ACRAConfigurationException("Class " + clazz.getName() + " cannot be abstract.");
+            }
+            try {
+                clazz.getConstructor();
+            } catch (NoSuchMethodException e) {
+                throw new ACRAConfigurationException("Class " + clazz.getName() + " is missing a no-args Constructor.", e);
+            }
+        }
+    }
+
+    /**
+     * Use this if you want to keep the default configuration of reportContent, but set some fields explicitly.
+     *
+     * @param field  the field to set
+     * @param enable if this field should be reported
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setReportField(@NonNull ReportField field, boolean enable) {
+        this.reportContentChanges.put(field, enable);
+        return this;
+    }
+
+    /**
+     * Set custom HTTP headers to be sent by the provided {@link HttpSender}.
+     * This should be used also by third party senders.
+     *
+     * @param headers A map associating HTTP header names to their values.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setHttpHeaders(@NonNull Map<String, String> headers) {
+        this.httpHeaders.clear();
+        this.httpHeaders.putAll(headers);
+        return this;
+    }
+
+    @NonNull
+    Map<String, String> httpHeaders() {
+        return httpHeaders;
+    }
+
+    @NoPropagation
+    @NonNull
+    @Override
+    ReportField[] customReportContent() {
+        return super.customReportContent();
+    }
+
+    @NonNull
+    Set<ReportField> reportContent() {
+        final Set<ReportField> reportContent = new LinkedHashSet<ReportField>();
+        if (customReportContent().length != 0) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using custom Report Fields");
+            reportContent.addAll(Arrays.asList(customReportContent()));
+        } else if (DEFAULT_STRING_VALUE.equals(mailTo())) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using default Report Fields");
+            reportContent.addAll(Arrays.asList(DEFAULT_REPORT_FIELDS));
+        } else {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using default Mail Report Fields");
+            reportContent.addAll(Arrays.asList(DEFAULT_MAIL_REPORT_FIELDS));
+        }
+
+        // Add or remove any extra fields.
+        for (Map.Entry<ReportField, Boolean> entry : reportContentChanges.entrySet()) {
+            if (entry.getValue()) {
+                reportContent.add(entry.getKey());
+            } else {
+                reportContent.remove(entry.getKey());
+            }
+        }
+        return reportContent;
+    }
+}
diff --git a/acra/src/main/java/org/acra/config/DefaultRetryPolicy.java b/acra/src/main/java/org/acra/config/DefaultRetryPolicy.java
new file mode 100644
index 00000000..d03639cf
--- /dev/null
+++ b/acra/src/main/java/org/acra/config/DefaultRetryPolicy.java
@@ -0,0 +1,33 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import org.acra.sender.ReportSender;
+
+import java.util.List;
+
+/**
+ * Default {@link RetryPolicy}. Only resend if all senders failed.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public class DefaultRetryPolicy implements RetryPolicy {
+    @Override
+    public boolean shouldRetrySend(List<ReportSender> senders, List<FailedSender> failedSenders) {
+        return (senders.size() == failedSenders.size()) && !senders.isEmpty();
+    }
+}
diff --git a/acra/src/main/java/org/acra/config/RetryPolicy.java b/acra/src/main/java/org/acra/config/RetryPolicy.java
new file mode 100644
index 00000000..b27b24ee
--- /dev/null
+++ b/acra/src/main/java/org/acra/config/RetryPolicy.java
@@ -0,0 +1,56 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import org.acra.sender.ReportSender;
+import org.acra.sender.ReportSenderException;
+
+import java.util.List;
+
+/**
+ * A policy which determines if a report should be resent.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public interface RetryPolicy {
+
+    /**
+     * @param senders a list of all senders.
+     * @param failedSenders a list of all failed senders with the thrown exceptions.
+     * @return <code>true</code> if the request should be resent later, otherwise <code>false</code>.
+     */
+    boolean shouldRetrySend(List<ReportSender> senders, List<FailedSender> failedSenders);
+
+    class FailedSender {
+
+        private final ReportSender sender;
+        private final ReportSenderException exception;
+
+        public FailedSender(ReportSender sender, ReportSenderException exception) {
+            this.sender = sender;
+            this.exception = exception;
+        }
+
+        public ReportSender getSender() {
+            return sender;
+        }
+
+        public ReportSenderException getException() {
+            return exception;
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/dialog/BaseCrashReportDialog.java b/acra/src/main/java/org/acra/dialog/BaseCrashReportDialog.java
new file mode 100644
index 00000000..45676c9c
--- /dev/null
+++ b/acra/src/main/java/org/acra/dialog/BaseCrashReportDialog.java
@@ -0,0 +1,154 @@
+package org.acra.dialog;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.FragmentActivity;
+import android.widget.Toast;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.BulkReportDeleter;
+import org.acra.file.CrashReportPersister;
+import org.acra.sender.SenderServiceStarter;
+import org.acra.util.ToastSender;
+import org.json.JSONException;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.USER_COMMENT;
+import static org.acra.ReportField.USER_EMAIL;
+
+/**
+ * Activity which implements the base functionality for a CrashReportDialog.
+ *
+ * Activities which extend from this class can override init to create a custom view.
+ *
+ * The methods sendCrash(comment, userEmail) and cancelReports() can be used to send or cancel
+ * sending of reports respectively.
+ *
+ * This Activity will be instantiated with 3 (or 4) arguments:
+ * <ol>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_FILE}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_CONFIG}</li>
+ * <li>{@link ACRAConstants#EXTRA_FORCE_CANCEL} (optional)</li>
+ * </ol>
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public abstract class BaseCrashReportDialog extends FragmentActivity {
+
+    private File reportFile;
+    private ACRAConfiguration config;
+    private Throwable exception;
+
+    /**
+     * NB if you were previously creating and showing your dialog in this method,
+     * you should move that code to {@link #init(Bundle)}.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    @Override
+    protected final void onCreate(@Nullable Bundle savedInstanceState) {
+        preInit(savedInstanceState);
+        super.onCreate(savedInstanceState);
+
+
+        if (ACRA.DEV_LOGGING) {
+            ACRA.log.d(LOG_TAG, "CrashReportDialog extras=" + getIntent().getExtras());
+        }
+
+        final Serializable sConfig = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_CONFIG);
+        final Serializable sReportFile = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_FILE);
+        final Serializable sException = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION);
+        final boolean forceCancel = getIntent().getBooleanExtra(ACRAConstants.EXTRA_FORCE_CANCEL, false);
+
+        if (forceCancel) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Forced reports deletion.");
+            cancelReports();
+            finish();
+        } else if ((sConfig instanceof ACRAConfiguration) && (sReportFile instanceof File) && ((sException instanceof Throwable) || sException == null)) {
+            config = (ACRAConfiguration) sConfig;
+            reportFile = (File) sReportFile;
+            exception = (Throwable) sException;
+            init(savedInstanceState);
+        } else {
+            ACRA.log.w(LOG_TAG, "Illegal or incomplete call of BaseCrashReportDialog.");
+            finish();
+        }
+    }
+
+    /**
+     * Handle any necessary pre-onCreate() setup here.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    protected void preInit(@Nullable Bundle savedInstanceState) {
+    }
+
+    /**
+     * Responsible for creating and showing the crash report dialog.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    protected void init(@Nullable Bundle savedInstanceState) {
+    }
+
+
+    /**
+     * Cancel any pending crash reports.
+     */
+    protected final void cancelReports() {
+        new BulkReportDeleter(getApplicationContext()).deleteReports(false, 0);
+    }
+
+
+    /**
+     * Send crash report given user's comment and email address. If none should be empty strings
+     *
+     * @param comment   Comment (may be null) provided by the user.
+     * @param userEmail Email address (may be null) provided by the client.
+     */
+    protected final void sendCrash(@Nullable String comment, @Nullable String userEmail) {
+        final CrashReportPersister persister = new CrashReportPersister();
+        try {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Add user comment to " + reportFile);
+            final CrashReportData crashData = persister.load(reportFile);
+            crashData.putString(USER_COMMENT, comment == null ? "" : comment);
+            crashData.putString(USER_EMAIL, userEmail == null ? "" : userEmail);
+            persister.store(crashData, reportFile);
+        } catch (IOException e) {
+            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
+        } catch (JSONException e) {
+            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
+        }
+
+        // Start the report sending task
+        final SenderServiceStarter starter = new SenderServiceStarter(getApplicationContext(), config);
+        starter.startService(false, true);
+
+        // Optional Toast to thank the user
+        final int toastId = config.resDialogOkToast();
+        if (toastId != 0) {
+            ToastSender.sendToast(getApplicationContext(), toastId, Toast.LENGTH_LONG);
+        }
+    }
+
+    protected final ACRAConfiguration getConfig() {
+        return config;
+    }
+
+    protected final Throwable getException() {
+        return exception;
+    }
+}
diff --git a/acra/src/main/java/org/acra/dialog/CrashReportDialog.java b/acra/src/main/java/org/acra/dialog/CrashReportDialog.java
new file mode 100644
index 00000000..f71f0313
--- /dev/null
+++ b/acra/src/main/java/org/acra/dialog/CrashReportDialog.java
@@ -0,0 +1,259 @@
+package org.acra.dialog;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.support.annotation.CallSuper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.InputType;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.ScrollView;
+import android.widget.TextView;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.prefs.PrefUtils;
+import org.acra.prefs.SharedPreferencesFactory;
+
+
+/**
+ * This is the dialog Activity used by ACRA to get authorization from the user
+ * to send reports. Requires android:launchMode="singleInstance" in your
+ * AndroidManifest to work properly.
+ **/
+@SuppressWarnings({"WeakerAccess", "unused"})
+public class CrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener {
+
+    private static final String STATE_EMAIL = "email";
+    private static final String STATE_COMMENT = "comment";
+    private static final int PADDING = 10;
+
+    private LinearLayout scrollable;
+    private EditText userCommentView;
+    private EditText userEmailView;
+    private SharedPreferencesFactory sharedPreferencesFactory;
+
+    private AlertDialog mDialog;
+
+    @CallSuper
+    @Override
+    protected void init(@Nullable Bundle savedInstanceState) {
+        scrollable = new LinearLayout(this);
+        scrollable.setOrientation(LinearLayout.VERTICAL);
+        sharedPreferencesFactory = new SharedPreferencesFactory(getApplicationContext(), getConfig());
+        final int themeResourceId = getConfig().resDialogTheme();
+        if(themeResourceId != ACRAConstants.DEFAULT_RES_VALUE) setTheme(themeResourceId);
+
+        buildAndShowDialog(savedInstanceState);
+    }
+
+    /**
+     * Build the dialog from the values in config
+     *
+     * @param savedInstanceState old state to restore
+     */
+    protected void buildAndShowDialog(@Nullable Bundle savedInstanceState) {
+        final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
+        final int titleResourceId = getConfig().resDialogTitle();
+        if (titleResourceId != ACRAConstants.DEFAULT_RES_VALUE) {
+            dialogBuilder.setTitle(titleResourceId);
+        }
+        final int iconResourceId = getConfig().resDialogIcon();
+        if (iconResourceId != ACRAConstants.DEFAULT_RES_VALUE) {
+            dialogBuilder.setIcon(iconResourceId);
+        }
+        dialogBuilder.setView(buildCustomView(savedInstanceState))
+                .setPositiveButton(getText(getConfig().resDialogPositiveButtonText()), this)
+                .setNegativeButton(getText(getConfig().resDialogNegativeButtonText()), this);
+
+        mDialog = dialogBuilder.create();
+        mDialog.setCanceledOnTouchOutside(false);
+        mDialog.show();
+    }
+
+    @NonNull
+    protected View buildCustomView(@Nullable Bundle savedInstanceState) {
+        final ScrollView root = new ScrollView(this);
+        root.setPadding(PADDING, PADDING, PADDING, PADDING);
+        root.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        root.setFocusable(true);
+        root.setFocusableInTouchMode(true);
+        root.addView(scrollable);
+
+        addViewToDialog(getMainView());
+
+        // Add an optional prompt for user comments
+        final View comment = getCommentLabel();
+        if (comment != null) {
+            comment.setPadding(comment.getPaddingLeft(), PADDING, comment.getPaddingRight(), comment.getPaddingBottom());
+            addViewToDialog(comment);
+            String savedComment = null;
+            if (savedInstanceState != null) {
+                savedComment = savedInstanceState.getString(STATE_COMMENT);
+            }
+            userCommentView = getCommentPrompt(savedComment);
+            addViewToDialog(userCommentView);
+        }
+
+        // Add an optional user email field
+        final View email = getEmailLabel();
+        if (email != null) {
+            email.setPadding(email.getPaddingLeft(), PADDING, email.getPaddingRight(), email.getPaddingBottom());
+            addViewToDialog(email);
+            String savedEmail = null;
+            if (savedInstanceState != null) {
+                savedEmail = savedInstanceState.getString(STATE_EMAIL);
+            }
+            userEmailView = getEmailPrompt(savedEmail);
+            addViewToDialog(userEmailView);
+        }
+        return root;
+    }
+
+    /**
+     * adds a view to the end of the dialog
+     *
+     * @param v the view to add
+     */
+    protected final void addViewToDialog(@NonNull View v) {
+        scrollable.addView(v);
+    }
+
+    /**
+     * Creates a main view containing text of resDialogText, or nothing if not found
+     *
+     * @return the main view
+     */
+    @NonNull
+    protected View getMainView() {
+        final TextView text = new TextView(this);
+        final int dialogTextId = getConfig().resDialogText();
+        if (dialogTextId != ACRAConstants.DEFAULT_RES_VALUE) {
+            text.setText(getText(dialogTextId));
+        }
+        return text;
+    }
+
+    /**
+     * creates a comment label view with resDialogCommentPrompt as text
+     *
+     * @return the label or null if there is no resource
+     */
+    @Nullable
+    protected View getCommentLabel() {
+        final int commentPromptId = getConfig().resDialogCommentPrompt();
+        if (commentPromptId != ACRAConstants.DEFAULT_RES_VALUE) {
+            final TextView labelView = new TextView(this);
+            labelView.setText(getText(commentPromptId));
+            return labelView;
+        }
+        return null;
+    }
+
+    /**
+     * creates a comment prompt
+     *
+     * @param savedComment the content of the prompt (usually from a saved state)
+     * @return the comment prompt
+     */
+    @NonNull
+    protected EditText getCommentPrompt(@Nullable CharSequence savedComment) {
+        final EditText userCommentView = new EditText(this);
+        userCommentView.setLines(2);
+        if (savedComment != null) {
+            userCommentView.setText(savedComment);
+        }
+        return userCommentView;
+    }
+
+    /**
+     * creates a email label view with resDialogEmailPrompt as text
+     *
+     * @return the label or null if there is no resource
+     */
+    @Nullable
+    protected View getEmailLabel() {
+        final int emailPromptId = getConfig().resDialogEmailPrompt();
+        if (emailPromptId != ACRAConstants.DEFAULT_RES_VALUE) {
+            final TextView labelView = new TextView(this);
+            labelView.setText(getText(emailPromptId));
+            return labelView;
+        }
+        return null;
+    }
+
+    /**
+     * creates an email prompt
+     *
+     * @param savedEmail the content of the prompt (usually from a saved state or settings)
+     * @return the email prompt
+     */
+    @NonNull
+    protected EditText getEmailPrompt(@Nullable CharSequence savedEmail) {
+        final EditText userEmailView = new EditText(this);
+        userEmailView.setSingleLine();
+        userEmailView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+
+        if (savedEmail != null) {
+            userEmailView.setText(savedEmail);
+        } else {
+            final SharedPreferences prefs = sharedPreferencesFactory.create();
+            userEmailView.setText(prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, ""));
+        }
+        return userEmailView;
+    }
+
+    @Override
+    public void onClick(DialogInterface dialog, int which) {
+        if (which == DialogInterface.BUTTON_POSITIVE) {
+            // Retrieve user comment
+            final String comment = userCommentView != null ? userCommentView.getText().toString() : "";
+
+            // Store the user email
+            final String userEmail;
+            final SharedPreferences prefs = sharedPreferencesFactory.create();
+            if (userEmailView != null) {
+                userEmail = userEmailView.getText().toString();
+                final SharedPreferences.Editor prefEditor = prefs.edit();
+                prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS, userEmail);
+                PrefUtils.save(prefEditor);
+            } else {
+                userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "");
+            }
+            sendCrash(comment, userEmail);
+        } else {
+            cancelReports();
+        }
+
+        finish();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
+     */
+    @CallSuper
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+        if (userCommentView != null && userCommentView.getText() != null) {
+            outState.putString(STATE_COMMENT, userCommentView.getText().toString());
+        }
+        if (userEmailView != null && userEmailView.getText() != null) {
+            outState.putString(STATE_EMAIL, userEmailView.getText().toString());
+        }
+    }
+
+    /**
+     * @return the AlertDialog displayed by this Activity
+     */
+    protected AlertDialog getDialog() {
+        return mDialog;
+    }
+}
\ No newline at end of file
diff --git a/acra/src/main/java/org/acra/file/BulkReportDeleter.java b/acra/src/main/java/org/acra/file/BulkReportDeleter.java
new file mode 100644
index 00000000..edc9b6b1
--- /dev/null
+++ b/acra/src/main/java/org/acra/file/BulkReportDeleter.java
@@ -0,0 +1,40 @@
+package org.acra.file;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.File;
+import java.util.Arrays;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Deletes unsent reports.
+ */
+public final class BulkReportDeleter {
+
+    @NonNull
+    private final ReportLocator reportLocator;
+
+    public BulkReportDeleter(@NonNull Context context) {
+        this.reportLocator = new ReportLocator(context);
+    }
+
+    /**
+     * @param approved  Whether to delete approved or unapproved reports.
+     * @param nrToKeep  Number of latest reports to keep.
+     */
+    public void deleteReports(boolean approved, int nrToKeep) {
+        final File[] files = approved ? reportLocator.getApprovedReports() : reportLocator.getUnapprovedReports();
+
+        Arrays.sort(files, new LastModifiedComparator());
+
+        for (int i = 0; i < files.length - nrToKeep; i++) {
+            if (!files[i].delete()) {
+                ACRA.log.w(LOG_TAG, "Could not delete report : " + files[i]);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/acra/CrashReportFileNameParser.java b/acra/src/main/java/org/acra/file/CrashReportFileNameParser.java
similarity index 84%
rename from src/main/java/org/acra/CrashReportFileNameParser.java
rename to acra/src/main/java/org/acra/file/CrashReportFileNameParser.java
index 609906d0..91b64642 100644
--- a/src/main/java/org/acra/CrashReportFileNameParser.java
+++ b/acra/src/main/java/org/acra/file/CrashReportFileNameParser.java
@@ -1,52 +1,57 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-/**
- * Responsible for determining the state of a Crash Report based on its file name.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-final class CrashReportFileNameParser {
-
-    /**
-     * Guess that a report is silent from its file name.
-     *
-     * @param reportFileName    Name of the report to check whether it should be sent silently.
-     * @return True if the report has been declared explicitly silent using {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    public boolean isSilent(String reportFileName) {
-        return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
-    }
-
-    /**
-     * Returns true if the report is considered as approved.
-     * <p>
-          This includes:
-     * </p>
-     * <ul>
-     * <li>Reports which were pending when the user agreed to send a report in the NOTIFICATION mode Dialog.</li>
-     * <li>Explicit silent reports</li>
-     * </ul>
-     *
-     * @param reportFileName    Name of report to check whether it is approved to be sent.
-     * @return True if a report can be sent.
-     */
-    public boolean isApproved(String reportFileName) {
-        return isSilent(reportFileName) || reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
-    }
-}
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ErrorReporter;
+
+/**
+ * Responsible for determining the state of a Crash Report based on its file name.
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class CrashReportFileNameParser {
+
+    /**
+     * Guess that a report is silent from its file name.
+     *
+     * @param reportFileName    Name of the report to check whether it should be sent silently.
+     * @return True if the report has been declared explicitly silent using {@link ErrorReporter#handleSilentException(Throwable)}.
+     */
+    public boolean isSilent(@NonNull String reportFileName) {
+        return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
+    }
+
+    /**
+     * Returns true if the report is considered as approved.
+     * <p>
+          This includes:
+     * </p>
+     * <ul>
+     * <li>Reports which were pending when the user agreed to send a report in the NOTIFICATION mode Dialog.</li>
+     * <li>Explicit silent reports</li>
+     * </ul>
+     *
+     * @param reportFileName    Name of report to check whether it is approved to be sent.
+     * @return True if a report can be sent.
+     */
+    public boolean isApproved(@NonNull String reportFileName) {
+        return isSilent(reportFileName) || reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
+    }
+}
diff --git a/acra/src/main/java/org/acra/file/CrashReportPersister.java b/acra/src/main/java/org/acra/file/CrashReportPersister.java
new file mode 100644
index 00000000..ac2ed412
--- /dev/null
+++ b/acra/src/main/java/org/acra/file/CrashReportPersister.java
@@ -0,0 +1,77 @@
+/*
+ * java.util.Properties.java modified by Kevin Gaudin to allow usage of enums as keys.
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.collector.CrashReportData;
+import org.acra.util.IOUtils;
+import org.acra.util.JsonUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
+ * This is basically the source of {@link java.util.Properties} adapted to extend an
+ * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
+ * amounts of android time in the generation of a date comment when storing to
+ * file.
+ */
+public final class CrashReportPersister {
+
+    /**
+     * Loads properties from the specified {@code File}.
+     *
+     * @param file  Report file from which to load the CrashData.
+     * @return CrashReportData read from the supplied File.
+     * @throws IOException if error occurs during reading from the {@code File}.
+     * @throws JSONException if the stream cannot be parsed as a JSON object.
+     */
+    @NonNull
+    public CrashReportData load(@NonNull File file) throws IOException, JSONException {
+
+        final InputStream in = new BufferedInputStream(new FileInputStream(file), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            return JsonUtils.toCrashReportData(new JSONObject(IOUtils.streamToString(in)));
+        }finally {
+            IOUtils.safeClose(in);
+        }
+    }
+
+    /**
+     * Stores the mappings in this Properties to the specified OutputStream,
+     * putting the specified comment at the beginning. The output from this
+     * method is suitable for being read by the load() method.
+     *
+     * @param crashData     CrashReportData to save.
+     * @param file          File into which to store the CrashReportData.
+     * @throws java.io.IOException if the CrashReportData could not be written to the OutputStream.
+     */
+    public void store(@NonNull CrashReportData crashData, @NonNull File file) throws IOException {
+        IOUtils.writeStringToFile(file, crashData.toJSON().toString());
+    }
+}
diff --git a/acra/src/main/java/org/acra/file/Directory.java b/acra/src/main/java/org/acra/file/Directory.java
new file mode 100644
index 00000000..c3903d8b
--- /dev/null
+++ b/acra/src/main/java/org/acra/file/Directory.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.file;
+
+import android.content.Context;
+import android.os.Environment;
+import android.support.annotation.NonNull;
+import android.support.v4.content.ContextCompat;
+
+import java.io.File;
+
+/**
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public enum Directory {
+    /**
+     * Legacy behaviour:
+     * If the string starts with a path separator, this behaves like {@link #ROOT}.
+     * Otherwise it behaves like {@link #FILES}.
+     */
+    FILES_LEGACY {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return (fileName.startsWith("/") ? Directory.ROOT : Directory.FILES).getFile(context, fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Context#getFilesDir()}
+     */
+    FILES {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(context.getFilesDir(), fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Context#getExternalFilesDir(String)}
+     */
+    EXTERNAL_FILES {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(context.getExternalFilesDir(null), fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Context#getCacheDir()}
+     */
+    CACHE {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(context.getCacheDir(), fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Context#getExternalCacheDir()}
+     */
+    EXTERNAL_CACHE {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(context.getExternalCacheDir(), fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Context#getNoBackupFilesDir()}.
+     * Will fall back to {@link Context#getFilesDir()} on API &lt; 21
+     */
+    NO_BACKUP_FILES {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(ContextCompat.getNoBackupFilesDir(context), fileName);
+        }
+    },
+    /**
+     * Directory returned by {@link Environment#getExternalStorageDirectory()}
+     */
+    EXTERNAL_STORAGE {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File(Environment.getExternalStorageDirectory(), fileName);
+        }
+    },
+    /**
+     * Root Directory, paths in this directory are absolute paths
+     */
+    ROOT {
+        @Override
+        public File getFile(@NonNull Context context, @NonNull String fileName) {
+            return new File("/", fileName);
+        }
+    };
+
+    public abstract File getFile(@NonNull Context context, @NonNull String fileName);
+}
diff --git a/acra/src/main/java/org/acra/file/LastModifiedComparator.java b/acra/src/main/java/org/acra/file/LastModifiedComparator.java
new file mode 100644
index 00000000..0bcaa808
--- /dev/null
+++ b/acra/src/main/java/org/acra/file/LastModifiedComparator.java
@@ -0,0 +1,18 @@
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import java.io.File;
+import java.util.Comparator;
+
+/**
+ * Orders files from oldest to newest based on their last modified date.
+ */
+final class LastModifiedComparator implements Comparator<File> {
+    @Override
+    public int compare(@NonNull File lhs, @NonNull File rhs) {
+        final long l = lhs.lastModified();
+        final long r = rhs.lastModified();
+        return l < r ? -1 : (l == r ? 0 : 1);
+    }
+}
diff --git a/acra/src/main/java/org/acra/file/ReportLocator.java b/acra/src/main/java/org/acra/file/ReportLocator.java
new file mode 100644
index 00000000..838a145c
--- /dev/null
+++ b/acra/src/main/java/org/acra/file/ReportLocator.java
@@ -0,0 +1,58 @@
+package org.acra.file;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import java.io.File;
+import java.util.Arrays;
+
+/**
+ * Locates crash reports.
+ *
+ * @author William Ferguson
+ * @since 4.8.0
+ */
+public final class ReportLocator {
+
+    // Folders under the app folder.
+    private static final String UNAPPROVED_FOLDER_NAME = "ACRA-unapproved";
+    private static final String APPROVED_FOLDER_NAME = "ACRA-approved";
+
+    private final Context context;
+
+    public ReportLocator(@NonNull Context context) {
+        this.context = context;
+    }
+
+    @NonNull
+    public File getUnapprovedFolder() {
+        return context.getDir(UNAPPROVED_FOLDER_NAME, Context.MODE_PRIVATE);
+    }
+
+    @NonNull
+    public File[] getUnapprovedReports() {
+        final File[] reports = getUnapprovedFolder().listFiles();
+        if (reports == null) {
+            return new File[0];
+        }
+        return reports;
+    }
+
+    @NonNull
+    public File getApprovedFolder() {
+        return context.getDir(APPROVED_FOLDER_NAME, Context.MODE_PRIVATE);
+    }
+
+    /**
+     * @return Approved reports sorted by creation time.
+     */
+    @NonNull
+    public File[] getApprovedReports() {
+        final File[] reports = getApprovedFolder().listFiles();
+        if (reports == null) {
+            return new File[0];
+        }
+        Arrays.sort(reports, new LastModifiedComparator());
+        return reports;
+    }
+}
diff --git a/acra/src/main/java/org/acra/http/BaseHttpRequest.java b/acra/src/main/java/org/acra/http/BaseHttpRequest.java
new file mode 100644
index 00000000..dda45c15
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/BaseHttpRequest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.http;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Base64;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.security.KeyStoreHelper;
+import org.acra.sender.HttpSender.Method;
+import org.acra.util.IOUtils;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.util.Map;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+
+import ch.acra.acra.BuildConfig;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author F43nd1r
+ * @since 03.03.2017
+ */
+public abstract class BaseHttpRequest<T> implements HttpRequest<T> {
+
+    @NonNull
+    private final ACRAConfiguration config;
+    @NonNull
+    private final Context context;
+    @NonNull
+    private final Method method;
+    private final String login;
+    private final String password;
+    private final int connectionTimeOut;
+    private final int socketTimeOut;
+    private final Map<String, String> headers;
+
+    public BaseHttpRequest(@NonNull ACRAConfiguration config, @NonNull Context context, @NonNull Method method,
+                           @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers) {
+        this.config = config;
+        this.context = context;
+        this.method = method;
+        this.login = login;
+        this.password = password;
+        this.connectionTimeOut = connectionTimeOut;
+        this.socketTimeOut = socketTimeOut;
+        this.headers = headers;
+    }
+
+
+    /**
+     * Sends to a URL.
+     *
+     * @param url     URL to which to send.
+     * @param content content to send.
+     * @throws IOException if the data cannot be sent.
+     */
+    @Override
+    public void send(@NonNull URL url, @NonNull T content) throws IOException {
+
+        final HttpURLConnection urlConnection = createConnection(url);
+        if (urlConnection instanceof HttpsURLConnection) {
+            try {
+                configureHttps((HttpsURLConnection) urlConnection);
+            } catch (GeneralSecurityException e) {
+                ACRA.log.e(LOG_TAG, "Could not configure SSL for ACRA request to " + url, e);
+            }
+        }
+        configureTimeouts(urlConnection, connectionTimeOut, socketTimeOut);
+        configureHeaders(urlConnection, login, password, headers, content);
+        if(ACRA.DEV_LOGGING){
+            ACRA.log.d(LOG_TAG, "Sending request to " + url);
+            ACRA.log.d(LOG_TAG, "Http " + method.name() + " content : ");
+            ACRA.log.d(LOG_TAG, content.toString());
+        }
+        writeContent(urlConnection, method, content);
+        handleResponse(urlConnection.getResponseCode(), urlConnection.getResponseMessage());
+        urlConnection.disconnect();
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    @NonNull
+    protected HttpURLConnection createConnection(@NonNull URL url) throws IOException {
+        return (HttpURLConnection) url.openConnection();
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void configureHttps(@NonNull HttpsURLConnection connection) throws GeneralSecurityException {
+        // Configure SSL
+        final String algorithm = TrustManagerFactory.getDefaultAlgorithm();
+        final TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
+        final KeyStore keyStore = KeyStoreHelper.getKeyStore(context, config);
+
+        tmf.init(keyStore);
+
+        final SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(null, tmf.getTrustManagers(), null);
+
+        connection.setSSLSocketFactory(sslContext.getSocketFactory());
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void configureTimeouts(@NonNull HttpURLConnection connection, int connectionTimeOut, int socketTimeOut){
+        connection.setConnectTimeout(connectionTimeOut);
+        connection.setReadTimeout(socketTimeOut);
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void configureHeaders(@NonNull HttpURLConnection connection, @Nullable String login, @Nullable String password,
+                                    @Nullable Map<String, String> customHeaders, @NonNull T t) throws IOException {
+        // Set Headers
+        connection.setRequestProperty("User-Agent", String.format("Android ACRA %1$s", BuildConfig.VERSION_NAME)); //sent ACRA version to server
+        connection.setRequestProperty("Accept",
+                "text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
+        connection.setRequestProperty("Content-Type", getContentType(context, t));
+
+        // Set Credentials
+        if (login != null && password != null) {
+            final String credentials = login + ':' + password;
+            final String encoded = new String(Base64.encode(credentials.getBytes(ACRAConstants.UTF8), Base64.NO_WRAP), ACRAConstants.UTF8);
+            connection.setRequestProperty("Authorization", "Basic " + encoded);
+        }
+
+        if (customHeaders != null) {
+            for (final Map.Entry<String, String> header : customHeaders.entrySet()) {
+                connection.setRequestProperty(header.getKey(), header.getValue());
+            }
+        }
+    }
+
+    protected abstract String getContentType(@NonNull Context context, @NonNull T t);
+
+    @SuppressWarnings("WeakerAccess")
+    protected void writeContent(@NonNull HttpURLConnection connection, @NonNull Method method, @NonNull T content) throws IOException{
+        final byte[] contentAsBytes = asBytes(content);
+        // write output - see http://developer.android.com/reference/java/net/HttpURLConnection.html
+        connection.setRequestMethod(method.name());
+        connection.setDoOutput(true);
+        connection.setFixedLengthStreamingMode(contentAsBytes.length);
+
+        // Disable ConnectionPooling because otherwise OkHttp ConnectionPool will try to start a Thread on #connect
+        System.setProperty("http.keepAlive", "false");
+
+        connection.connect();
+
+        final OutputStream outputStream = new BufferedOutputStream(connection.getOutputStream());
+        try {
+            outputStream.write(contentAsBytes);
+            outputStream.flush();
+        } finally {
+            IOUtils.safeClose(outputStream);
+        }
+    }
+
+    protected abstract byte[] asBytes(T content) throws IOException;
+
+    @SuppressWarnings("WeakerAccess")
+    protected void handleResponse(int responseCode, String responseMessage) throws IOException {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Request response : " + responseCode + " : " + responseMessage);
+        if (responseCode >= HttpURLConnection.HTTP_OK && responseCode < HttpURLConnection.HTTP_MULT_CHOICE) {
+            // All is good
+            ACRA.log.i(LOG_TAG, "Request received by server");
+        } else if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT || responseCode >= HttpURLConnection.HTTP_INTERNAL_ERROR) {
+            //timeout or server error. Repeat the request later.
+            ACRA.log.w(LOG_TAG, "Could not send ACRA Post responseCode=" + responseCode + " message=" + responseMessage);
+            throw new IOException("Host returned error code " + responseCode);
+        } else if (responseCode >= HttpURLConnection.HTTP_BAD_REQUEST && responseCode < HttpURLConnection.HTTP_INTERNAL_ERROR) {
+            // Client error. The request must not be repeated. Discard it.
+            ACRA.log.w(LOG_TAG, responseCode + ": Client error - request will be discarded");
+        } else {
+            ACRA.log.w(LOG_TAG, "Could not send ACRA Post - request will be discarded. responseCode=" + responseCode + " message=" + responseMessage);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/http/BinaryHttpRequest.java b/acra/src/main/java/org/acra/http/BinaryHttpRequest.java
new file mode 100644
index 00000000..a5dd08c3
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/BinaryHttpRequest.java
@@ -0,0 +1,38 @@
+package org.acra.http;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.config.ACRAConfiguration;
+import org.acra.sender.HttpSender;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 10.03.2017
+ */
+
+public class BinaryHttpRequest extends BaseHttpRequest<Uri> {
+    @NonNull
+    private final Context context;
+
+    public BinaryHttpRequest(@NonNull ACRAConfiguration config, @NonNull Context context, @NonNull HttpSender.Method method,
+                             @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers) {
+        super(config, context, method, login, password, connectionTimeOut, socketTimeOut, headers);
+        this.context = context;
+    }
+
+    @Override
+    protected String getContentType(@NonNull Context context, @NonNull Uri uri) {
+        return HttpUtils.getMimeType(context, uri);
+    }
+
+    @Override
+    protected byte[] asBytes(Uri content) throws IOException {
+        return HttpUtils.uriToByteArray(context, content);
+    }
+}
diff --git a/acra/src/main/java/org/acra/http/DefaultHttpRequest.java b/acra/src/main/java/org/acra/http/DefaultHttpRequest.java
new file mode 100644
index 00000000..2e1a4052
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/DefaultHttpRequest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.http;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.sender.HttpSender;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 10.03.2017
+ */
+
+public class DefaultHttpRequest extends BaseHttpRequest<String> {
+    @NonNull
+    private final HttpSender.Type type;
+
+    public DefaultHttpRequest(@NonNull ACRAConfiguration config, @NonNull Context context, @NonNull HttpSender.Method method, @NonNull HttpSender.Type type,
+                              @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers) {
+        super(config, context, method, login, password, connectionTimeOut, socketTimeOut, headers);
+        this.type = type;
+    }
+
+    @Override
+    protected String getContentType(@NonNull Context context, @NonNull String s) {
+        return type.getContentType();
+    }
+
+    @Override
+    protected byte[] asBytes(String content) throws IOException {
+        return content.getBytes(ACRAConstants.UTF8);
+    }
+}
diff --git a/acra/src/main/java/org/acra/http/HttpRequest.java b/acra/src/main/java/org/acra/http/HttpRequest.java
new file mode 100644
index 00000000..79e6ed16
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/HttpRequest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.http;
+
+import android.support.annotation.NonNull;
+
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * @author F43nd1r
+ * @since 03.03.2017
+ */
+public interface HttpRequest<T> {
+    void send(@NonNull URL url, @NonNull T content) throws IOException;
+}
diff --git a/acra/src/main/java/org/acra/http/HttpUtils.java b/acra/src/main/java/org/acra/http/HttpUtils.java
new file mode 100644
index 00000000..29cc9697
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/HttpUtils.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.http;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.OpenableColumns;
+import android.support.annotation.NonNull;
+import android.webkit.MimeTypeMap;
+
+import org.acra.ACRAConstants;
+
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 11.03.2017
+ */
+
+public final class HttpUtils {
+    private HttpUtils() {
+    }
+
+    @NonNull
+    public static byte[] uriToByteArray(@NonNull Context context, Uri uri) throws IOException {
+        final InputStream inputStream = context.getContentResolver().openInputStream(uri);
+        if (inputStream == null) {
+            throw new FileNotFoundException("Could not open " + uri.toString());
+        }
+        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        final byte[] buffer = new byte[ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES];
+        int length;
+        while ((length = inputStream.read(buffer)) > 0) {
+            outputStream.write(buffer, 0, length);
+        }
+        return outputStream.toByteArray();
+    }
+
+    /**
+     * Converts a Map of parameters into a URL encoded Sting.
+     *
+     * @param parameters Map of parameters to convert.
+     * @return URL encoded String representing the parameters.
+     * @throws UnsupportedEncodingException if one of the parameters couldn't be converted to UTF-8.
+     */
+    @NonNull
+    public static String getParamsAsFormString(@NonNull Map<?, ?> parameters) throws UnsupportedEncodingException {
+
+        final StringBuilder dataBfr = new StringBuilder();
+        for (final Map.Entry<?, ?> entry : parameters.entrySet()) {
+            if (dataBfr.length() != 0) {
+                dataBfr.append('&');
+            }
+            final Object preliminaryValue = entry.getValue();
+            final Object value = (preliminaryValue == null) ? "" : preliminaryValue;
+            dataBfr.append(URLEncoder.encode(entry.getKey().toString(), ACRAConstants.UTF8));
+            dataBfr.append('=');
+            dataBfr.append(URLEncoder.encode(value.toString(), ACRAConstants.UTF8));
+        }
+
+        return dataBfr.toString();
+    }
+
+    public static String getFileNameFromUri(Context context, Uri uri) {
+        String result = null;
+        if (uri.getScheme().equals(ContentResolver.SCHEME_CONTENT)) {
+            final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
+            try {
+                if (cursor != null && cursor.moveToFirst()) {
+                    result = cursor.getString(cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));
+                }
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+        if (result == null) {
+            result = uri.getPath();
+            final int cut = result.lastIndexOf('/');
+            if (cut != -1) {
+                result = result.substring(cut + 1);
+            }
+        }
+        return result;
+    }
+
+    public static String getMimeType(Context context, Uri uri) {
+        if (uri.getScheme().equals(ContentResolver.SCHEME_CONTENT)) {
+            final ContentResolver contentResolver = context.getContentResolver();
+            return contentResolver.getType(uri);
+        }
+        return guessMimeType(uri);
+    }
+
+    public static String guessMimeType(Uri uri){
+        String type = null;
+        final String fileExtension = MimeTypeMap.getFileExtensionFromUrl(uri
+                .toString());
+        if (fileExtension != null) {
+            type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(
+                    fileExtension.toLowerCase());
+        }
+        if (type == null) {
+            type = "application/octet-stream";
+        }
+        return type;
+    }
+}
diff --git a/acra/src/main/java/org/acra/http/MultipartHttpRequest.java b/acra/src/main/java/org/acra/http/MultipartHttpRequest.java
new file mode 100644
index 00000000..2457725c
--- /dev/null
+++ b/acra/src/main/java/org/acra/http/MultipartHttpRequest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.http;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.sender.HttpSender;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Produces <a href="https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html">RFC 1341</a> compliant requests
+ *
+ * @author F43nd1r
+ * @since 11.03.2017
+ */
+
+public class MultipartHttpRequest extends BaseHttpRequest<Pair<String, List<Uri>>> {
+
+    private static final String BOUNDARY = "%&ACRA_REPORT_DIVIDER&%";
+    private static final String BOUNDARY_FIX = "--";
+    private static final String NEW_LINE = "\r\n";
+    private static final String CONTENT_TYPE = "Content-Type: ";
+    @NonNull
+    private final Context context;
+    @NonNull
+    private final HttpSender.Type type;
+
+    public MultipartHttpRequest(@NonNull ACRAConfiguration config, @NonNull Context context, @NonNull HttpSender.Type type, @Nullable String login, @Nullable String password,
+                                int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers) {
+        super(config, context, HttpSender.Method.POST, login, password, connectionTimeOut, socketTimeOut, headers);
+        this.context = context;
+        this.type = type;
+    }
+
+    @Override
+    protected String getContentType(@NonNull Context context, @NonNull Pair<String, List<Uri>> stringListPair) {
+        return "multipart/mixed; boundary=" + BOUNDARY;
+    }
+
+    @Override
+    protected byte[] asBytes(Pair<String, List<Uri>> content) throws IOException {
+        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        final Writer writer = new OutputStreamWriter(outputStream, ACRAConstants.UTF8);
+        try {
+            writer.append(NEW_LINE).append(BOUNDARY_FIX).append(BOUNDARY).append(NEW_LINE);
+            writer.append(CONTENT_TYPE).append(type.getContentType()).append(NEW_LINE).append(NEW_LINE);
+            writer.append(content.first);
+            for (Uri uri : content.second) {
+                writer.append(NEW_LINE).append(BOUNDARY_FIX).append(BOUNDARY).append(NEW_LINE);
+                writer.append("Content-Disposition: attachment; filename=\"").append(HttpUtils.getFileNameFromUri(context, uri)).append('"').append(NEW_LINE);
+                writer.append(CONTENT_TYPE).append(HttpUtils.getMimeType(context, uri)).append(NEW_LINE).append(NEW_LINE);
+                writer.flush();
+                outputStream.write(HttpUtils.uriToByteArray(context, uri));
+            }
+            writer.append(NEW_LINE).append(BOUNDARY_FIX).append(BOUNDARY).append(BOUNDARY_FIX).append(NEW_LINE);
+            writer.flush();
+            return outputStream.toByteArray();
+        } finally {
+            writer.close();
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/legacy/LegacyFileHandler.java b/acra/src/main/java/org/acra/legacy/LegacyFileHandler.java
new file mode 100644
index 00000000..e73638a2
--- /dev/null
+++ b/acra/src/main/java/org/acra/legacy/LegacyFileHandler.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.legacy;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import org.acra.prefs.PrefUtils;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+public class LegacyFileHandler {
+    private static final String PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0 = "acra.legacyAlreadyConvertedTo4.8.0";
+    private static final String PREF__LEGACY_ALREADY_CONVERTED_TO_JSON = "acra.legacyAlreadyConvertedToJson";
+    private final Context context;
+    private final SharedPreferences prefs;
+
+    public LegacyFileHandler(Context context, SharedPreferences prefs) {
+        this.context = context;
+        this.prefs = prefs;
+    }
+
+    public void updateToCurrentVersionIfNecessary(){
+        // Check prefs to see if we have converted from legacy (pre 4.8.0) ACRA
+        if (!prefs.getBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0, false)) {
+            // If not then move reports to approved/unapproved folders and mark as converted.
+            new ReportMigrator(context).migrate();
+
+            // Mark as converted.
+            final SharedPreferences.Editor editor = prefs.edit().putBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0, true);
+            PrefUtils.save(editor);
+        }
+        if(!prefs.getBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_JSON, false)){
+            new ReportConverter(context).convert();
+
+            // Mark as converted.
+            final SharedPreferences.Editor editor = prefs.edit().putBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_JSON, true);
+            PrefUtils.save(editor);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/legacy/ReportConverter.java b/acra/src/main/java/org/acra/legacy/ReportConverter.java
new file mode 100644
index 00000000..b4df7b5e
--- /dev/null
+++ b/acra/src/main/java/org/acra/legacy/ReportConverter.java
@@ -0,0 +1,337 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.legacy;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.file.CrashReportPersister;
+import org.acra.file.ReportLocator;
+import org.acra.model.BooleanElement;
+import org.acra.model.ComplexElement;
+import org.acra.collector.CrashReportData;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+import org.json.JSONException;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Converts acras old file format to json
+ *
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+class ReportConverter {
+    private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;
+    private final Context context;
+
+    ReportConverter(Context context) {
+        this.context = context;
+    }
+
+    void convert() {
+        ACRA.log.i(LOG_TAG, "Converting unsent ACRA reports to json");
+        final ReportLocator locator = new ReportLocator(context);
+        final CrashReportPersister persister = new CrashReportPersister();
+        final List<File> reportFiles = new ArrayList<File>();
+        reportFiles.addAll(Arrays.asList(locator.getUnapprovedReports()));
+        reportFiles.addAll(Arrays.asList(locator.getApprovedReports()));
+        int converted = 0;
+        for (File report : reportFiles) {
+            InputStream in = null;
+            try {
+                in = new BufferedInputStream(new FileInputStream(report), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+                final CrashReportData data = legacyLoad(new InputStreamReader(in, "ISO8859-1")); //$NON-NLS-1$
+                if (data.containsKey(ReportField.REPORT_ID) && data.containsKey(ReportField.USER_CRASH_DATE)) {
+                    persister.store(data, report);
+                    converted++;
+                } else {
+                    //reports without these keys are probably invalid
+                    IOUtils.deleteReport(report);
+                }
+            } catch (Throwable e) {
+                try {
+                    //If this succeeds the report has already been converted, happens e.g. on preference clear.
+                    persister.load(report);
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Tried to convert already converted report file " + report.getPath() + ". Ignoring");
+                } catch (Throwable t) {
+                    //File matches neither of the known formats, remove it.
+                    ACRA.log.w(LOG_TAG, "Unable to read report file " + report.getPath() + ". Deleting", e);
+                    IOUtils.deleteReport(report);
+                }
+            } finally {
+                IOUtils.safeClose(in);
+            }
+        }
+        ACRA.log.i(LOG_TAG, "Converted " + converted + " unsent reports");
+    }
+
+
+    /**
+     * Loads properties from the specified InputStream. The properties are of
+     * the form <code>key=value</code>, one property per line. It may be not
+     * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
+     * according to the following rules:
+     * <ul>
+     * <li>Empty lines are ignored.</li>
+     * <li>Lines starting with either a "#" or a "!" are comment lines and are
+     * ignored.</li>
+     * <li>A backslash at the end of the line escapes the following newline
+     * character ("\r", "\n", "\r\n"). If there's a whitespace after the
+     * backslash it will just escape that whitespace instead of concatenating
+     * the lines. This does not apply to comment lines.</li>
+     * <li>A property line consists of the key, the space between the key and
+     * the value, and the value. The key goes up to the first whitespace, "=" or
+     * ":" that is not escaped. The space between the key and the value contains
+     * either one whitespace, one "=" or one ":" and any number of additional
+     * whitespaces before and after that character. The value starts with the
+     * first character after the space between the key and the value.</li>
+     * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
+     * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
+     * </ul>
+     *
+     * @param reader Reader from which to read the properties of this CrashReportData.
+     * @return CrashReportData read from the supplied Reader.
+     * @throws java.io.IOException if the properties could not be read.
+     * @since 1.6
+     */
+    @NonNull
+    private synchronized CrashReportData legacyLoad(@NonNull Reader reader) throws IOException {
+        int mode = NONE, unicode = 0, count = 0;
+        char nextChar;
+        char[] buf = new char[40];
+        int offset = 0, keyLength = -1, intVal;
+        boolean firstChar = true;
+
+        final CrashReportData crashData = new CrashReportData();
+        final BufferedReader br = new BufferedReader(reader, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            while (true) {
+                intVal = br.read();
+                if (intVal == -1) {
+                    break;
+                }
+                nextChar = (char) intVal;
+
+                if (offset == buf.length) {
+                    final char[] newBuf = new char[buf.length * 2];
+                    System.arraycopy(buf, 0, newBuf, 0, offset);
+                    buf = newBuf;
+                }
+                if (mode == UNICODE) {
+                    final int digit = Character.digit(nextChar, 16);
+                    if (digit >= 0) {
+                        unicode = (unicode << 4) + digit;
+                        if (++count < 4) {
+                            continue;
+                        }
+                    } else if (count <= 4) {
+                        // luni.09=Invalid Unicode sequence: illegal character
+                        throw new IllegalArgumentException("luni.09");
+                    }
+                    mode = NONE;
+                    buf[offset++] = (char) unicode;
+                    if (nextChar != '\n' && nextChar != '\u0085') {
+                        continue;
+                    }
+                }
+                if (mode == SLASH) {
+                    mode = NONE;
+                    switch (nextChar) {
+                        case '\r':
+                            mode = CONTINUE; // Look for a following \n
+                            continue;
+                        case '\u0085':
+                        case '\n':
+                            mode = IGNORE; // Ignore whitespace on the next line
+                            continue;
+                        case 'b':
+                            nextChar = '\b';
+                            break;
+                        case 'f':
+                            nextChar = '\f';
+                            break;
+                        case 'n':
+                            nextChar = '\n';
+                            break;
+                        case 'r':
+                            nextChar = '\r';
+                            break;
+                        case 't':
+                            nextChar = '\t';
+                            break;
+                        case 'u':
+                            mode = UNICODE;
+                            unicode = count = 0;
+                            continue;
+                    }
+                } else {
+                    switch (nextChar) {
+                        case '#':
+                        case '!':
+                            if (firstChar) {
+                                while (true) {
+                                    intVal = br.read();
+                                    if (intVal == -1) {
+                                        break;
+                                    }
+                                    nextChar = (char) intVal; // & 0xff
+                                    // not
+                                    // required
+                                    if (nextChar == '\r' || nextChar == '\n' || nextChar == '\u0085') {
+                                        break;
+                                    }
+                                }
+                                continue;
+                            }
+                            break;
+                        case '\n':
+                            if (mode == CONTINUE) { // Part of a \r\n sequence
+                                mode = IGNORE; // Ignore whitespace on the next line
+                                continue;
+                            }
+                            // fall into the next case
+                        case '\u0085':
+                        case '\r':
+                            mode = NONE;
+                            firstChar = true;
+                            if (offset > 0 || (offset == 0 && keyLength == 0)) {
+                                if (keyLength == -1) {
+                                    keyLength = offset;
+                                }
+                                final String temp = new String(buf, 0, offset);
+                                final String elementString = temp.substring(keyLength);
+                                Element element;
+                                try {
+                                    element = new ComplexElement(elementString);
+                                } catch (JSONException e1) {
+                                    try {
+                                        element = new NumberElement(Double.valueOf(elementString));
+                                    } catch (NumberFormatException e2) {
+                                        if (elementString.equals("true")) {
+                                            element = new BooleanElement(true);
+                                        } else if (elementString.equals("false")) {
+                                            element = new BooleanElement(false);
+                                        } else {
+                                            element = new StringElement(elementString);
+                                        }
+                                    }
+                                }
+                                crashData.put(Enum.valueOf(ReportField.class, temp.substring(0, keyLength)), element);
+                            }
+                            keyLength = -1;
+                            offset = 0;
+                            continue;
+                        case '\\':
+                            if (mode == KEY_DONE) {
+                                keyLength = offset;
+                            }
+                            mode = SLASH;
+                            continue;
+                        case ':':
+                        case '=':
+                            if (keyLength == -1) { // if parsing the key
+                                mode = NONE;
+                                keyLength = offset;
+                                continue;
+                            }
+                            break;
+                    }
+                    if (Character.isWhitespace(nextChar)) {
+                        if (mode == CONTINUE) {
+                            mode = IGNORE;
+                        }
+                        // if key length == 0 or value length == 0
+                        if (offset == 0 || offset == keyLength || mode == IGNORE) {
+                            continue;
+                        }
+                        if (keyLength == -1) { // if parsing the key
+                            mode = KEY_DONE;
+                            continue;
+                        }
+                    }
+                    if (mode == IGNORE || mode == CONTINUE) {
+                        mode = NONE;
+                    }
+                }
+                firstChar = false;
+                if (mode == KEY_DONE) {
+                    keyLength = offset;
+                    mode = NONE;
+                }
+                buf[offset++] = nextChar;
+            }
+            if (mode == UNICODE && count <= 4) {
+                // luni.08=Invalid Unicode sequence: expected format \\uxxxx
+                throw new IllegalArgumentException("luni.08");
+            }
+            if (keyLength == -1 && offset > 0) {
+                keyLength = offset;
+            }
+            if (keyLength >= 0) {
+                final String temp = new String(buf, 0, offset);
+                final ReportField key = Enum.valueOf(ReportField.class, temp.substring(0, keyLength));
+                String value = temp.substring(keyLength);
+                if (mode == SLASH) {
+                    value += "\u0000";
+                }
+                Element element;
+                try {
+                    element = new ComplexElement(value);
+                } catch (JSONException e1) {
+                    try {
+                        element = new NumberElement(Double.valueOf(value));
+                    } catch (NumberFormatException e2) {
+                        if (value.equals("true")) {
+                            element = new BooleanElement(true);
+                        } else if (value.equals("false")) {
+                            element = new BooleanElement(false);
+                        } else {
+                            element = new StringElement(value);
+                        }
+                    }
+                }
+                crashData.put(key, element);
+            }
+
+            IOUtils.safeClose(reader);
+
+            return crashData;
+        } finally {
+            IOUtils.safeClose(br);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/legacy/ReportMigrator.java b/acra/src/main/java/org/acra/legacy/ReportMigrator.java
new file mode 100644
index 00000000..f6abe927
--- /dev/null
+++ b/acra/src/main/java/org/acra/legacy/ReportMigrator.java
@@ -0,0 +1,78 @@
+package org.acra.legacy;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+
+import java.io.File;
+import java.io.FilenameFilter;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Migrates reports from the pre 4.8.0 location to the 4.8.0+ locations.
+ */
+final class ReportMigrator {
+
+    private final Context context;
+    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+    @NonNull
+    private final ReportLocator reportLocator;
+
+    ReportMigrator(@NonNull Context context) {
+        this.context = context;
+        this.reportLocator = new ReportLocator(context);
+    }
+
+    void migrate() {
+        ACRA.log.i(LOG_TAG, "Migrating unsent ACRA reports to new file locations");
+
+        final File[] reportFiles = getCrashReportFiles();
+
+        for (final File file : reportFiles) {
+            // Move it to unapproved or approved folders.
+            final String fileName = file.getName();
+            if (fileNameParser.isApproved(fileName)) {
+                if (file.renameTo(new File(reportLocator.getApprovedFolder(), fileName))) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Cold not migrate unsent ACRA crash report : " + fileName);
+                }
+            } else {
+                if (file.renameTo(new File(reportLocator.getUnapprovedFolder(), fileName))) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Cold not migrate unsent ACRA crash report : " + fileName);
+                }
+            }
+        }
+        ACRA.log.i(LOG_TAG, "Migrated " + reportFiles.length + " unsent reports");
+    }
+
+    /**
+     * Returns an array containing the names of pending crash report files.
+     *
+     * @return an array containing the names of pending crash report files.
+     */
+    @NonNull
+    private File[] getCrashReportFiles() {
+        final File dir = context.getFilesDir();
+        if (dir == null) {
+            ACRA.log.w(LOG_TAG, "Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
+            return new File[0];
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Looking for error files in " + dir.getAbsolutePath());
+
+        // Filter for ".stacktrace" files
+        final FilenameFilter filter = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, @NonNull String name) {
+                return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
+            }
+        };
+        final File[] result = dir.listFiles(filter);
+        return (result == null) ? new File[0] : result;
+    }
+
+}
diff --git a/acra/src/main/java/org/acra/log/ACRALog.java b/acra/src/main/java/org/acra/log/ACRALog.java
new file mode 100644
index 00000000..c909448a
--- /dev/null
+++ b/acra/src/main/java/org/acra/log/ACRALog.java
@@ -0,0 +1,30 @@
+package org.acra.log;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Responsible for providing ACRA classes with a platform neutral way of logging.
+ * <p>
+ *     One reason for using this mechanism is to allow ACRA classes to use a logging system,
+ *     but be able to execute in a test environment outside of an Android JVM.
+ * </p>
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public interface ACRALog {
+    int v(java.lang.String tag, java.lang.String msg);
+    int v(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int d(java.lang.String tag, java.lang.String msg);
+    int d(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int i(java.lang.String tag, java.lang.String msg);
+    int i(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int w(java.lang.String tag, java.lang.String msg);
+    int w(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    //public native  boolean isLoggable(java.lang.String tag, int level);
+    int w(java.lang.String tag, java.lang.Throwable tr);
+    int e(java.lang.String tag, java.lang.String msg);
+    int e(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    @Nullable
+    java.lang.String getStackTraceString(java.lang.Throwable tr);
+    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
+}
diff --git a/src/main/java/org/acra/log/AndroidLogDelegate.java b/acra/src/main/java/org/acra/log/AndroidLogDelegate.java
similarity index 89%
rename from src/main/java/org/acra/log/AndroidLogDelegate.java
rename to acra/src/main/java/org/acra/log/AndroidLogDelegate.java
index bd2a366c..d7e585e5 100644
--- a/src/main/java/org/acra/log/AndroidLogDelegate.java
+++ b/acra/src/main/java/org/acra/log/AndroidLogDelegate.java
@@ -1,51 +1,63 @@
-package org.acra.log;
-
-
-import android.util.Log;
-
-/**
- * Responsible for delegating calls to the Android logging system.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class AndroidLogDelegate implements ACRALog {
-    public int v(String tag, String msg) {
-        return Log.v(tag, msg);
-    }
-    public int v(String tag, String msg, Throwable tr) {
-        return Log.v(tag, msg, tr);
-    }
-    public int d(String tag, String msg) {
-        return Log.d(tag, msg);
-    }
-    public int d(String tag, String msg, Throwable tr) {
-        return Log.d(tag, msg, tr);
-    }
-    public int i(String tag, String msg) {
-        return Log.i(tag, msg);
-    }
-    public int i(String tag, String msg, Throwable tr) {
-        return Log.i(tag, msg, tr);
-    }
-    public int w(String tag, String msg) {
-        return Log.w(tag, msg);
-    }
-    public int w(String tag, String msg, Throwable tr) {
-        return Log.w(tag, msg, tr);
-    }
-    //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(String tag, Throwable tr) {
-        return Log.w(tag, tr);
-    }
-    public int e(String tag, String msg) {
-        return Log.e(tag, msg);
-    }
-    public int e(String tag, String msg, Throwable tr) {
-        return Log.e(tag, msg, tr);
-    }
-    public String getStackTraceString(Throwable tr) {
-        return Log.getStackTraceString(tr);
-    }
-    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
-}
+package org.acra.log;
+
+
+import android.util.Log;
+
+/**
+ * Responsible for delegating calls to the Android logging system.
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class AndroidLogDelegate implements ACRALog {
+    @Override
+    public int v(String tag, String msg) {
+        return Log.v(tag, msg);
+    }
+    @Override
+    public int v(String tag, String msg, Throwable tr) {
+        return Log.v(tag, msg, tr);
+    }
+    @Override
+    public int d(String tag, String msg) {
+        return Log.d(tag, msg);
+    }
+    @Override
+    public int d(String tag, String msg, Throwable tr) {
+        return Log.d(tag, msg, tr);
+    }
+    @Override
+    public int i(String tag, String msg) {
+        return Log.i(tag, msg);
+    }
+    @Override
+    public int i(String tag, String msg, Throwable tr) {
+        return Log.i(tag, msg, tr);
+    }
+    @Override
+    public int w(String tag, String msg) {
+        return Log.w(tag, msg);
+    }
+    @Override
+    public int w(String tag, String msg, Throwable tr) {
+        return Log.w(tag, msg, tr);
+    }
+    //public native  boolean isLoggable(java.lang.String tag, int level);
+    @Override
+    public int w(String tag, Throwable tr) {
+        return Log.w(tag, tr);
+    }
+    @Override
+    public int e(String tag, String msg) {
+        return Log.e(tag, msg);
+    }
+    @Override
+    public int e(String tag, String msg, Throwable tr) {
+        return Log.e(tag, msg, tr);
+    }
+    @Override
+    public String getStackTraceString(Throwable tr) {
+        return Log.getStackTraceString(tr);
+    }
+    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
+}
diff --git a/src/main/java/org/acra/log/HollowLog.java b/acra/src/main/java/org/acra/log/HollowLog.java
similarity index 89%
rename from src/main/java/org/acra/log/HollowLog.java
rename to acra/src/main/java/org/acra/log/HollowLog.java
index d5a93f50..94b2cb6c 100644
--- a/src/main/java/org/acra/log/HollowLog.java
+++ b/acra/src/main/java/org/acra/log/HollowLog.java
@@ -1,9 +1,12 @@
 package org.acra.log;
 
+import android.support.annotation.Nullable;
+
 /**
  * Stub implementation of {@link org.acra.log.ACRALog}, quenches all logging.
  */
-public class HollowLog implements ACRALog {
+@SuppressWarnings("unused")
+public final class HollowLog implements ACRALog {
     @Override
     public int v(String tag, String msg) {
         return 0;
@@ -59,6 +62,7 @@ public int e(String tag, String msg, Throwable tr) {
         return 0;
     }
 
+    @Nullable
     @Override
     public String getStackTraceString(Throwable tr) {
         return null;
diff --git a/acra/src/main/java/org/acra/model/BooleanElement.java b/acra/src/main/java/org/acra/model/BooleanElement.java
new file mode 100644
index 00000000..29559568
--- /dev/null
+++ b/acra/src/main/java/org/acra/model/BooleanElement.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 13.10.2016
+ */
+
+public class BooleanElement implements Element {
+    private final boolean content;
+
+    public BooleanElement(boolean content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{toString()};
+    }
+
+    @Override
+    public String toString() {
+        return String.valueOf(content);
+    }
+}
diff --git a/acra/src/main/java/org/acra/model/ComplexElement.java b/acra/src/main/java/org/acra/model/ComplexElement.java
new file mode 100644
index 00000000..55d16f73
--- /dev/null
+++ b/acra/src/main/java/org/acra/model/ComplexElement.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+import android.support.annotation.NonNull;
+
+import org.acra.util.JsonUtils;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public class ComplexElement extends JSONObject implements Element {
+    public ComplexElement() {
+    }
+
+    public ComplexElement(String json) throws JSONException {
+        super(json);
+    }
+
+    public ComplexElement(Map<String, ?> copyFrom) {
+        super(copyFrom);
+    }
+
+    public ComplexElement(JSONObject copyFrom) throws JSONException {
+        super(copyFrom, getNames(copyFrom));
+    }
+
+    @NonNull
+    private static String[] getNames(JSONObject object) throws JSONException {
+        final JSONArray json = object.names();
+        if(json != null) {
+            final String[] names = new String[json.length()];
+            for (int i = 0; i < json.length(); i++) {
+                names[i] = json.getString(i);
+            }
+            return names;
+        }
+        return new String[0];
+    }
+
+    @Override
+    public Object value() {
+        return this;
+    }
+
+    @Override
+    public String[] flatten() {
+        try {
+            return JsonUtils.flatten(this).toArray(new String[0]);
+        } catch (JSONException e) {
+            return new String[0];
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/model/Element.java b/acra/src/main/java/org/acra/model/Element.java
new file mode 100644
index 00000000..7e7e1ac0
--- /dev/null
+++ b/acra/src/main/java/org/acra/model/Element.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public interface Element {
+    /**
+     * @return this elements json value.
+     * This must be one of the valid json types: bull, boolean, number, String, JSONObject or JSONArray
+     */
+    Object value();
+
+    String[] flatten();
+}
diff --git a/acra/src/main/java/org/acra/model/NumberElement.java b/acra/src/main/java/org/acra/model/NumberElement.java
new file mode 100644
index 00000000..98c8109d
--- /dev/null
+++ b/acra/src/main/java/org/acra/model/NumberElement.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 13.10.2016
+ */
+
+public class NumberElement implements Element {
+    private final Number content;
+
+    public NumberElement(Number content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{toString()};
+    }
+
+    @Override
+    public String toString() {
+        return content.toString();
+    }
+}
diff --git a/acra/src/main/java/org/acra/model/StringElement.java b/acra/src/main/java/org/acra/model/StringElement.java
new file mode 100644
index 00000000..8d33b72f
--- /dev/null
+++ b/acra/src/main/java/org/acra/model/StringElement.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public class StringElement implements Element {
+    private final String content;
+
+    public StringElement(String content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{content};
+    }
+
+    @Override
+    public String toString() {
+        return content;
+    }
+}
diff --git a/acra/src/main/java/org/acra/prefs/PrefUtils.java b/acra/src/main/java/org/acra/prefs/PrefUtils.java
new file mode 100644
index 00000000..1359c6b5
--- /dev/null
+++ b/acra/src/main/java/org/acra/prefs/PrefUtils.java
@@ -0,0 +1,17 @@
+package org.acra.prefs;
+
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+public final class PrefUtils {
+    private PrefUtils(){}
+
+    public static void save(@NonNull SharedPreferences.Editor editor) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            editor.apply();
+        } else {
+            editor.commit();
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/prefs/SharedPreferencesFactory.java b/acra/src/main/java/org/acra/prefs/SharedPreferencesFactory.java
new file mode 100644
index 00000000..c9695c79
--- /dev/null
+++ b/acra/src/main/java/org/acra/prefs/SharedPreferencesFactory.java
@@ -0,0 +1,44 @@
+package org.acra.prefs;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
+
+import org.acra.annotation.ReportsCrashes;
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Responsible for creating a SharedPreferences instance which stores ACRA settings.
+ * <p>
+ * Retrieves the {@link SharedPreferences} instance where user adjustable
+ * settings for ACRA are stored. Default are the Application default
+ * SharedPreferences, but you can provide another SharedPreferences name
+ * with {@link ReportsCrashes#sharedPreferencesName()}.
+ * </p>
+ */
+public class SharedPreferencesFactory {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public SharedPreferencesFactory(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * @return The Shared Preferences where ACRA will retrieve its user adjustable setting.
+     */
+    @NonNull
+    public SharedPreferences create() {
+        //noinspection ConstantConditions
+        if (context == null) {
+            throw new IllegalStateException("Cannot call ACRA.getACRASharedPreferences() before ACRA.init().");
+        } else if (!"".equals(config.sharedPreferencesName())) {
+            return context.getSharedPreferences(config.sharedPreferencesName(), config.sharedPreferencesMode());
+        } else {
+            return PreferenceManager.getDefaultSharedPreferences(context);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/AssetKeyStoreFactory.java b/acra/src/main/java/org/acra/security/AssetKeyStoreFactory.java
new file mode 100644
index 00000000..9f3779a6
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/AssetKeyStoreFactory.java
@@ -0,0 +1,57 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * KeyStoreFactory for a certificate stored in an asset file
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class AssetKeyStoreFactory extends BaseKeyStoreFactory {
+
+    private final String assetName;
+
+    /**
+     * creates a new KeyStoreFactory for the specified asset with a custom certificate type
+     * @param certificateType the certificate type
+     * @param assetName the asset
+     */
+    AssetKeyStoreFactory(String certificateType, String assetName) {
+        super(certificateType);
+        this.assetName = assetName;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        try {
+            return context.getAssets().open(assetName);
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "Could not open certificate in asset://"+assetName, e);
+        }
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/BaseKeyStoreFactory.java b/acra/src/main/java/org/acra/security/BaseKeyStoreFactory.java
new file mode 100644
index 00000000..b51c9821
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/BaseKeyStoreFactory.java
@@ -0,0 +1,117 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.util.IOUtils;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Provides base KeyStoreFactory implementation
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public abstract class BaseKeyStoreFactory implements KeyStoreFactory {
+
+    public enum Type {
+        CERTIFICATE,
+        KEYSTORE
+    }
+
+    private final String certificateType;
+
+    /**
+     * creates a new KeyStoreFactory for the default certificate type {@link ACRAConstants#DEFAULT_CERTIFICATE_TYPE}
+     */
+    public BaseKeyStoreFactory() {
+        this(ACRAConstants.DEFAULT_CERTIFICATE_TYPE);
+    }
+
+    /**
+     * creates a new KeyStoreFactory with the specified certificate type
+     *
+     * @param certificateType the certificate type
+     */
+    public BaseKeyStoreFactory(String certificateType) {
+        this.certificateType = certificateType;
+    }
+
+    protected abstract InputStream getInputStream(@NonNull Context context);
+
+    protected String getKeyStoreType() {
+        return KeyStore.getDefaultType();
+    }
+
+    protected Type getStreamType() {
+        return Type.CERTIFICATE;
+    }
+
+    protected char[] getPassword() {
+        return null;
+    }
+
+    @Override
+    @Nullable
+    public final KeyStore create(@NonNull Context context) {
+        final InputStream inputStream = getInputStream(context);
+        if (inputStream != null) {
+            final BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);
+            try {
+                final KeyStore keyStore = KeyStore.getInstance(getKeyStoreType());
+                switch (getStreamType()) {
+                    case CERTIFICATE:
+                        final CertificateFactory certificateFactory = CertificateFactory.getInstance(certificateType);
+                        final Certificate certificate = certificateFactory.generateCertificate(bufferedInputStream);
+                        keyStore.load(null, null);
+                        keyStore.setCertificateEntry("ca", certificate);
+                        break;
+                    case KEYSTORE:
+                        keyStore.load(bufferedInputStream, getPassword());
+                }
+                return keyStore;
+            } catch (CertificateException e) {
+                ACRA.log.e(LOG_TAG, "Could not load certificate", e);
+            } catch (KeyStoreException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } catch (NoSuchAlgorithmException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } catch (IOException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } finally {
+                IOUtils.safeClose(bufferedInputStream);
+            }
+        }
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/FileKeyStoreFactory.java b/acra/src/main/java/org/acra/security/FileKeyStoreFactory.java
new file mode 100644
index 00000000..3aaa9d02
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/FileKeyStoreFactory.java
@@ -0,0 +1,58 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * KeyStoreFactory for a certificate stored in a file
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class FileKeyStoreFactory extends BaseKeyStoreFactory {
+
+    private final String filePath;
+
+    /**
+     * creates a new KeyStoreFactory for the specified file with a custom certificate type
+     * @param certificateType the certificate type
+     * @param filePath path to the file
+     */
+    FileKeyStoreFactory(String certificateType, String filePath) {
+        super(certificateType);
+        this.filePath = filePath;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        try {
+            return new FileInputStream(filePath);
+        } catch (FileNotFoundException e) {
+            ACRA.log.e(LOG_TAG, "Could not find File "+filePath, e);
+        }
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/KeyStoreFactory.java b/acra/src/main/java/org/acra/security/KeyStoreFactory.java
new file mode 100644
index 00000000..abd981c0
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/KeyStoreFactory.java
@@ -0,0 +1,34 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.security.KeyStore;
+
+/**
+ * The interface can be used to provide a KeyStore with certificates.
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+public interface KeyStoreFactory {
+
+    @Nullable
+    KeyStore create(@NonNull Context context);
+}
diff --git a/acra/src/main/java/org/acra/security/KeyStoreHelper.java b/acra/src/main/java/org/acra/security/KeyStoreHelper.java
new file mode 100644
index 00000000..ace808b3
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/KeyStoreHelper.java
@@ -0,0 +1,67 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.util.InstanceCreator;
+
+import java.security.KeyStore;
+
+/**
+ * Helper to get a KeyStore from a configuration
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class KeyStoreHelper {
+    private static final String ASSET_PREFIX = "asset://";
+
+    private KeyStoreHelper() {
+    }
+
+    /**
+     * try to get the keystore
+     * @param context a context
+     * @param config the configuration
+     * @return the keystore, or null if none provided / failure
+     */
+    @Nullable
+    public static KeyStore getKeyStore(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        final InstanceCreator instanceCreator = new InstanceCreator();
+        KeyStore keyStore = instanceCreator.create(config.keyStoreFactoryClass(), new NoKeyStoreFactory()).create(context);
+        if(keyStore == null) {
+            //either users factory did not create a keystore, or the configuration is default {@link NoKeyStoreFactory}
+            final int certificateRes = config.resCertificate();
+            final String certificatePath = config.certificatePath();
+            final String certificateType = config.certificateType();
+            if(certificateRes != ACRAConstants.DEFAULT_RES_VALUE){
+                keyStore = new ResourceKeyStoreFactory(certificateType, certificateRes).create(context);
+            }else if(!certificatePath.equals(ACRAConstants.DEFAULT_STRING_VALUE)){
+                if(certificatePath.startsWith(ASSET_PREFIX)) {
+                    keyStore = new AssetKeyStoreFactory(certificateType, certificatePath.substring(ASSET_PREFIX.length())).create(context);
+                } else {
+                    keyStore = new FileKeyStoreFactory(certificateType, certificatePath).create(context);
+                }
+            }
+        }
+        return keyStore;
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/NoKeyStoreFactory.java b/acra/src/main/java/org/acra/security/NoKeyStoreFactory.java
new file mode 100644
index 00000000..da833424
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/NoKeyStoreFactory.java
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.security.KeyStore;
+
+/**
+ * Default KeyStoreFactory. Does not provide any KeyStore
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public class NoKeyStoreFactory implements KeyStoreFactory {
+    @Nullable
+    @Override
+    public KeyStore create(@NonNull Context context) {
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/security/ResourceKeyStoreFactory.java b/acra/src/main/java/org/acra/security/ResourceKeyStoreFactory.java
new file mode 100644
index 00000000..dc8f1344
--- /dev/null
+++ b/acra/src/main/java/org/acra/security/ResourceKeyStoreFactory.java
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.RawRes;
+
+import java.io.InputStream;
+
+/**
+ * KeyStoreFactory for a certificate stored in a raw resource
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class ResourceKeyStoreFactory extends BaseKeyStoreFactory {
+
+    @RawRes
+    private final int rawRes;
+
+    /**
+     * creates a new KeyStoreFactory for the specified resource with a custom certificate type
+     * @param certificateType the certificate type
+     * @param rawRes raw resource id
+     */
+    ResourceKeyStoreFactory(String certificateType, @RawRes int rawRes) {
+        super(certificateType);
+        this.rawRes = rawRes;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        return context.getResources().openRawResource(rawRes);
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/DefaultReportSenderFactory.java b/acra/src/main/java/org/acra/sender/DefaultReportSenderFactory.java
new file mode 100644
index 00000000..540db463
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/DefaultReportSenderFactory.java
@@ -0,0 +1,50 @@
+package org.acra.sender;
+
+import android.Manifest;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.util.PackageManagerWrapper;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Will send reports by email if the 'mailTo' parameter is configured,
+ * otherwise via HTTP if the 'formUri' parameter is configured and
+ * internet permission has been granted.
+ *
+ * If neither 'formUri' or 'mailTo' has been configured, then a NullSender will be returned.
+ */
+public final class DefaultReportSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        final PackageManagerWrapper pm = new PackageManagerWrapper(context);
+        if (!"".equals(config.mailTo())) {
+            // Try to send by mail. If a mailTo address is provided, do not add other senders.
+            ACRA.log.i(LOG_TAG, context.getPackageName() + " reports will be sent by email (if accepted by user).");
+            return new EmailIntentSenderFactory().create(context, config);
+        } else if (!pm.hasPermission(Manifest.permission.INTERNET)) {
+            // NB If the PackageManager has died then this will erroneously log
+            // the error that the App doesn't have Internet (even though it does).
+            // I think that is a small price to pay to ensure that ACRA doesn't
+            // crash if the PackageManager has died.
+            ACRA.log.e(LOG_TAG,
+                    context.getPackageName()
+                            + " should be granted permission "
+                            + Manifest.permission.INTERNET
+                            + " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @AcraConfig(mailTo=\"your.account@domain.com\"");
+            return new NullSender();
+        } else if (!ACRAConstants.DEFAULT_STRING_VALUE.equals(config.formUri())) {
+            // If formUri is set, instantiate a sender for a generic HTTP POST form with default mapping.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, context.getPackageName() + " reports will be sent by Http.");
+            return new HttpSenderFactory().create(context, config);
+        } else {
+            return new NullSender();
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/EmailIntentSender.java b/acra/src/main/java/org/acra/sender/EmailIntentSender.java
new file mode 100644
index 00000000..7b5b56b0
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/EmailIntentSender.java
@@ -0,0 +1,275 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.attachment.AcraContentProvider;
+import org.acra.attachment.DefaultAttachmentProvider;
+import org.acra.collections.ImmutableSet;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.util.IOUtils;
+import org.acra.util.InstanceCreator;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Send reports through an email intent.
+ * <p>
+ * The user will be asked to chose his preferred email client if no default is set. Included report fields can be defined using
+ * {@link org.acra.annotation.ReportsCrashes#customReportContent()}. Crash receiving mailbox has to be
+ * defined with {@link ReportsCrashes#mailTo()}.
+ */
+@SuppressWarnings("WeakerAccess")
+public class EmailIntentSender implements ReportSender {
+
+    private final ACRAConfiguration config;
+
+    public EmailIntentSender(@NonNull ACRAConfiguration config) {
+        this.config = config;
+    }
+
+    @Override
+    public void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException {
+        final PackageManager pm = context.getPackageManager();
+
+        final String subject = buildSubject(context);
+        final String body = buildBody(errorContent);
+        final ArrayList<Uri> attachments = new ArrayList<Uri>();
+        final boolean contentAttached = fillAttachmentList(context, errorContent, attachments);
+
+        //we have to resolve with sendto, because send is supported by non-email apps
+        final Intent resolveIntent = buildResolveIntent(subject, body);
+        final ComponentName resolveActivity = resolveIntent.resolveActivity(pm);
+        if (resolveActivity != null) {
+            if (attachments.size() == 0) {
+                //no attachments, send directly
+                context.startActivity(resolveIntent);
+            } else {
+                final Intent attachmentIntent = buildAttachmentIntent(subject, body, attachments, contentAttached);
+                final List<Intent> initialIntents = buildInitialIntents(pm, resolveIntent, attachmentIntent);
+                final String packageName = getPackageName(resolveActivity, initialIntents);
+                attachmentIntent.setPackage(packageName);
+                if (packageName == null) {
+                    //let user choose email client
+                    for (Intent intent : initialIntents) {
+                        grantPermission(context, intent, intent.getPackage(), attachments);
+                    }
+                    showChooser(context, initialIntents);
+                } else if (attachmentIntent.resolveActivity(pm) != null) {
+                    //use default email client
+                    grantPermission(context, attachmentIntent, packageName, attachments);
+                    context.startActivity(attachmentIntent);
+                } else {
+                    ACRA.log.w(LOG_TAG, "No email client supporting attachments found. Attachments will be ignored");
+                    context.startActivity(resolveIntent);
+                }
+            }
+        } else {
+            throw new ReportSenderException("No email client found");
+        }
+    }
+
+    /**
+     * Finds the package name of the default email client supporting attachments
+     *
+     * @param resolveActivity the resolved activity
+     * @param initialIntents  a list of intents to be used when
+     * @return package name of the default email client, or null if more than one app match
+     */
+    @Nullable
+    private String getPackageName(@NonNull ComponentName resolveActivity, @NonNull List<Intent> initialIntents) {
+        String packageName = resolveActivity.getPackageName();
+        if (packageName.equals("android")) {
+            //multiple activities support the intent and no default is set
+            if (initialIntents.size() > 1) {
+                packageName = null;
+            } else if (initialIntents.size() == 1) {
+                //only one of them supports attachments, use that one
+                packageName = initialIntents.get(0).getPackage();
+            }
+        }
+        return packageName;
+    }
+
+    /**
+     * Builds an email intent with attachments
+     *
+     * @param subject         the message subject
+     * @param body            the message body
+     * @param attachments     the attachments
+     * @param contentAttached if the body is already contained in the attachments
+     * @return email intent
+     */
+    @NonNull
+    protected Intent buildAttachmentIntent(@NonNull String subject, @NonNull String body, @NonNull ArrayList<Uri> attachments, boolean contentAttached) {
+        final Intent intent = new Intent(Intent.ACTION_SEND_MULTIPLE);
+        intent.putExtra(Intent.EXTRA_EMAIL, new String[]{config.mailTo()});
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.putExtra(Intent.EXTRA_SUBJECT, subject);
+        intent.setType("message/rfc822");
+        intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, attachments);
+        if (!contentAttached) intent.putExtra(Intent.EXTRA_TEXT, body);
+        return intent;
+    }
+
+    /**
+     * Builds an intent used to resolve email clients and to send reports without attachments or as fallback if no attachments are supported
+     *
+     * @param subject the message subject
+     * @param body    the message body
+     * @return email intent
+     */
+    @NonNull
+    protected Intent buildResolveIntent(@NonNull String subject, @NonNull String body) {
+        final Intent intent = new Intent(Intent.ACTION_SENDTO);
+        intent.setData(Uri.fromParts("mailto", config.mailTo(), null));
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.putExtra(Intent.EXTRA_SUBJECT, subject);
+        intent.putExtra(Intent.EXTRA_TEXT, body);
+        return intent;
+    }
+
+    @NonNull
+    private List<Intent> buildInitialIntents(@NonNull PackageManager pm, @NonNull Intent resolveIntent, @NonNull Intent emailIntent) {
+        final List<ResolveInfo> resolveInfoList = pm.queryIntentActivities(resolveIntent, PackageManager.MATCH_DEFAULT_ONLY);
+        final List<Intent> initialIntents = new ArrayList<Intent>();
+        for (ResolveInfo info : resolveInfoList) {
+            final Intent packageSpecificIntent = new Intent(emailIntent);
+            packageSpecificIntent.setPackage(info.activityInfo.packageName);
+            if (packageSpecificIntent.resolveActivity(pm) != null) {
+                initialIntents.add(packageSpecificIntent);
+            }
+        }
+        return initialIntents;
+    }
+
+    private void showChooser(@NonNull Context context, @NonNull List<Intent> initialIntents) {
+        final Intent chooser = new Intent(Intent.ACTION_CHOOSER);
+        chooser.putExtra(Intent.EXTRA_INTENT, initialIntents.remove(0));
+        chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS, initialIntents.toArray(new Intent[initialIntents.size()]));
+        chooser.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(chooser);
+    }
+
+    private void grantPermission(@NonNull Context context, Intent intent, String packageName, List<Uri> attachments) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        } else {
+            //flags do not work on extras prior to lollipop, so we have to grant read permissions manually
+            for (Uri uri : attachments) {
+                context.grantUriPermission(packageName, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
+            }
+        }
+    }
+
+    /**
+     * Creates the message subject
+     *
+     * @param context a context
+     * @return the message subject
+     */
+    @NonNull
+    protected String buildSubject(@NonNull Context context) {
+        return context.getPackageName() + " Crash Report";
+    }
+
+    /**
+     * Creates the message body
+     *
+     * @param errorContent the report content
+     * @return the message body
+     */
+    @NonNull
+    protected String buildBody(@NonNull CrashReportData errorContent) {
+        Set<ReportField> fields = config.reportContent();
+        if (fields.isEmpty()) {
+            fields = new ImmutableSet<ReportField>(ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS);
+        }
+
+        final StringBuilder builder = new StringBuilder();
+        for (ReportField field : fields) {
+            builder.append(field.toString()).append('=');
+            final Element value = errorContent.get(field);
+            if (value != null) {
+                builder.append(TextUtils.join("\n\t", value.flatten()));
+            }
+            builder.append('\n');
+        }
+        return builder.toString();
+    }
+
+    /**
+     * Adds all attachment uris into the given list
+     *
+     * @param context      a context
+     * @param errorContent the report content
+     * @param attachments  the target list
+     * @return if the attachments contain the content
+     */
+    protected boolean fillAttachmentList(@NonNull Context context, @NonNull CrashReportData errorContent, @NonNull List<Uri> attachments) {
+        final InstanceCreator instanceCreator = new InstanceCreator();
+        attachments.addAll(instanceCreator.create(config.attachmentUriProvider(), new DefaultAttachmentProvider()).getAttachments(context, config));
+        if (config.reportAsFile()) {
+            final Uri report = createAttachmentFromString(context, "ACRA-report" + ACRAConstants.REPORTFILE_EXTENSION, errorContent.toJSON().toString());
+            if (report != null) {
+                attachments.add(report);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Creates a temporary file with the given content and name, to be used as an email attachment
+     *
+     * @param context a context
+     * @param name    the name
+     * @param content the content
+     * @return a content uri for the file
+     */
+    @Nullable
+    protected Uri createAttachmentFromString(@NonNull Context context, @NonNull String name, @NonNull String content) {
+        final File cache = new File(context.getCacheDir(), name);
+        try {
+            IOUtils.writeStringToFile(cache, content);
+            return AcraContentProvider.getUriForFile(context, cache);
+        } catch (IOException ignored) {
+        }
+        return null;
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/EmailIntentSenderFactory.java b/acra/src/main/java/org/acra/sender/EmailIntentSenderFactory.java
new file mode 100644
index 00000000..6b23f66a
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/EmailIntentSenderFactory.java
@@ -0,0 +1,18 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Constructs an {@link EmailIntentSender}.
+ */
+public final class EmailIntentSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        return new EmailIntentSender(config);
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/HttpSender.java b/acra/src/main/java/org/acra/sender/HttpSender.java
new file mode 100644
index 00000000..32807d3e
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/HttpSender.java
@@ -0,0 +1,348 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Pair;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.attachment.DefaultAttachmentProvider;
+import org.acra.collections.ImmutableSet;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.http.BinaryHttpRequest;
+import org.acra.http.DefaultHttpRequest;
+import org.acra.http.HttpUtils;
+import org.acra.http.MultipartHttpRequest;
+import org.acra.model.Element;
+import org.acra.util.InstanceCreator;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * <p>
+ * The {@link ReportSender} used by ACRA when {@link ReportsCrashes#formUri()}
+ * has been defined in order to post crash data to a custom server-side data
+ * collection script. It sends all data in a POST request with parameters named
+ * with easy to understand names (basically a string conversion of
+ * {@link ReportField} enum values) or based on your own conversion Map from
+ * {@link ReportField} values to String.
+ * </p>
+ * <p>
+ * To use specific POST parameter names, you can provide your own report fields
+ * mapping scheme:
+ * </p>
+ * <pre>
+ * Just create and declare a {@link ReportSenderFactory} that constructs a mapping
+ * from each {@link ReportField} to another name.
+ * </pre>
+ */
+public class HttpSender implements ReportSender {
+
+    /**
+     * Available HTTP methods to send data. Only POST and PUT are currently
+     * supported.
+     */
+    public enum Method {
+        POST {
+            @Override
+            URL createURL(String baseUrl, CrashReportData report) throws MalformedURLException {
+                return new URL(baseUrl);
+            }
+        },
+        PUT {
+            @Override
+            URL createURL(String baseUrl, CrashReportData report) throws MalformedURLException {
+                return new URL(baseUrl + '/' + report.getProperty(ReportField.REPORT_ID));
+            }
+        };
+
+        abstract URL createURL(String baseUrl, CrashReportData report) throws MalformedURLException;
+    }
+
+    /**
+     * Type of report data encoding, currently supports Html Form encoding and
+     * JSON.
+     */
+    public enum Type {
+        /**
+         * Send data as a www form encoded list of key/values.
+         *
+         * @see <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">Form content types</a>
+         */
+        FORM("application/x-www-form-urlencoded") {
+            @Override
+            String convertReport(HttpSender sender, CrashReportData report) throws IOException {
+                return HttpUtils.getParamsAsFormString(sender.convertToForm(report));
+            }
+        },
+        /**
+         * Send data as a structured JSON tree.
+         */
+        JSON("application/json") {
+            @Override
+            String convertReport(HttpSender sender, CrashReportData report) throws IOException {
+                return sender.convertToJson(report).toString();
+            }
+        };
+        private final String contentType;
+
+        Type(String contentType) {
+            this.contentType = contentType;
+        }
+
+        @NonNull
+        public String getContentType() {
+            return contentType;
+        }
+
+        abstract String convertReport(HttpSender sender, CrashReportData report) throws IOException;
+    }
+
+    private final ACRAConfiguration config;
+    @Nullable
+    private final Uri mFormUri;
+    private final Map<ReportField, String> mMapping;
+    private final Method mMethod;
+    private final Type mType;
+    @Nullable
+    private String mUsername;
+    @Nullable
+    private String mPassword;
+
+    /**
+     * <p>
+     * Create a new HttpSender instance with its destination taken from the supplied config.
+     * Uses {@link ReportField} values converted to String with .toString() as form parameters.
+     * </p>
+     *
+     * @param config AcraConfig declaring the
+     * @param method HTTP {@link Method} to be used to send data. Currently only
+     *               {@link Method#POST} and {@link Method#PUT} are available. If
+     *               {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
+     *               is appended to the formUri to be compliant with RESTful APIs.
+     * @param type   {@link Type} of encoding used to send the report body.
+     *               {@link Type#FORM} is a simple Key/Value pairs list as defined
+     *               by the application/x-www-form-urlencoded mime type.
+     */
+    public HttpSender(@NonNull ACRAConfiguration config, @NonNull Method method, @NonNull Type type) {
+        this(config, method, type, null);
+    }
+
+    /**
+     * <p>
+     * Create a new HttpSender instance with its destination taken from the supplied config.
+     * </p>
+     *
+     * @param config  AcraConfig declaring the
+     * @param method  HTTP {@link Method} to be used to send data. Currently only
+     *                {@link Method#POST} and {@link Method#PUT} are available. If
+     *                {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
+     *                is appended to the formUri to be compliant with RESTful APIs.
+     * @param type    {@link Type} of encoding used to send the report body.
+     *                {@link Type#FORM} is a simple Key/Value pairs list as defined
+     *                by the application/x-www-form-urlencoded mime type.
+     * @param mapping Applies only to {@link Method#POST} method parameter. If null,
+     *                POST parameters will be named with {@link ReportField} values
+     *                converted to String with .toString(). If not null, POST
+     *                parameters will be named with the result of
+     *                mapping.get(ReportField.SOME_FIELD);
+     */
+    public HttpSender(@NonNull ACRAConfiguration config, @NonNull Method method, @NonNull Type type, @Nullable Map<ReportField, String> mapping) {
+        this(config, method, type, null, mapping);
+    }
+
+    /**
+     * <p>
+     * Create a new HttpPostSender instance with a fixed destination provided as
+     * a parameter. Configuration changes to the formUri are not applied.
+     * </p>
+     *
+     * @param config  AcraConfig declaring the
+     * @param method  HTTP {@link Method} to be used to send data. Currently only
+     *                {@link Method#POST} and {@link Method#PUT} are available. If
+     *                {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
+     *                is appended to the formUri to be compliant with RESTful APIs.
+     * @param type    {@link Type} of encoding used to send the report body.
+     *                {@link Type#FORM} is a simple Key/Value pairs list as defined
+     *                by the application/x-www-form-urlencoded mime type.
+     * @param formUri The URL of your server-side crash report collection script.
+     * @param mapping Applies only to {@link Method#POST} method parameter. If null,
+     *                POST parameters will be named with {@link ReportField} values
+     *                converted to String with .toString(). If not null, POST
+     *                parameters will be named with the result of
+     *                mapping.get(ReportField.SOME_FIELD);
+     */
+    public HttpSender(@NonNull ACRAConfiguration config, @NonNull Method method, @NonNull Type type, @Nullable String formUri, @Nullable Map<ReportField, String> mapping) {
+        this.config = config;
+        mMethod = method;
+        mFormUri = (formUri == null) ? null : Uri.parse(formUri);
+        mMapping = mapping;
+        mType = type;
+        mUsername = null;
+        mPassword = null;
+    }
+
+    /**
+     * <p>
+     * Set credentials for this HttpSender that override (if present) the ones
+     * set globally.
+     * </p>
+     *
+     * @param username The username to set for HTTP Basic Auth.
+     * @param password The password to set for HTTP Basic Auth.
+     */
+    @SuppressWarnings("unused")
+    public void setBasicAuth(@Nullable String username, @Nullable String password) {
+        mUsername = username;
+        mPassword = password;
+    }
+
+    @Override
+    public void send(@NonNull Context context, @NonNull CrashReportData report) throws ReportSenderException {
+
+        try {
+            final String baseUrl = mFormUri == null ? config.formUri() : mFormUri.toString();
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Connect to " + baseUrl);
+
+            final String login = mUsername != null ? mUsername : isNull(config.formUriBasicAuthLogin()) ? null : config.formUriBasicAuthLogin();
+            final String password = mPassword != null ? mPassword : isNull(config.formUriBasicAuthPassword()) ? null : config.formUriBasicAuthPassword();
+
+            final InstanceCreator instanceCreator = new InstanceCreator();
+            final List<Uri> uris = instanceCreator.create(config.attachmentUriProvider(), new DefaultAttachmentProvider()).getAttachments(context, config);
+
+            // Generate report body depending on requested type
+            final String reportAsString = mType.convertReport(this, report);
+
+            // Adjust URL depending on method
+            final URL reportUrl = mMethod.createURL(baseUrl, report);
+
+            sendHttpRequests(config, context, mMethod, mType, login, password, config.connectionTimeout(),
+                    config.socketTimeout(), config.httpHeaders(), reportAsString, reportUrl, uris);
+
+        } catch (@NonNull IOException e) {
+            throw new ReportSenderException("Error while sending " + config.reportType()
+                    + " report via Http " + mMethod.name(), e);
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void sendHttpRequests(@NonNull ACRAConfiguration configuration, @NonNull Context context, @NonNull Method method, @NonNull Type type,
+                                    @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers,
+                                    @NonNull String content, @NonNull URL url, @NonNull List<Uri> attachments) throws IOException {
+        switch (method) {
+            case POST:
+                if (attachments.isEmpty()) {
+                    sendWithoutAttachments(configuration, context, method, type, login, password, connectionTimeOut, socketTimeOut, headers, content, url);
+                } else {
+                    postMultipart(configuration, context, type, login, password, connectionTimeOut, socketTimeOut, headers, content, url, attachments);
+                }
+                break;
+            case PUT:
+                sendWithoutAttachments(configuration, context, method, type, login, password, connectionTimeOut, socketTimeOut, headers, content, url);
+                for (Uri uri : attachments) {
+                    putAttachment(configuration, context, login, password, connectionTimeOut, socketTimeOut, headers, url, uri);
+                }
+                break;
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void sendWithoutAttachments(@NonNull ACRAConfiguration configuration, @NonNull Context context, @NonNull Method method, @NonNull Type type,
+                                          @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers,
+                                          @NonNull String content, @NonNull URL url) throws IOException {
+        new DefaultHttpRequest(configuration, context, method, type, login, password, connectionTimeOut, socketTimeOut, headers).send(url, content);
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void postMultipart(@NonNull ACRAConfiguration configuration, @NonNull Context context, @NonNull Type type,
+                                 @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers,
+                                 @NonNull String content, @NonNull URL url, @NonNull List<Uri> attachments) throws IOException {
+        new MultipartHttpRequest(configuration, context, type, login, password, connectionTimeOut, socketTimeOut, headers).send(url, Pair.create(content, attachments));
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected void putAttachment(@NonNull ACRAConfiguration configuration, @NonNull Context context,
+                                 @Nullable String login, @Nullable String password, int connectionTimeOut, int socketTimeOut, @Nullable Map<String, String> headers,
+                                 @NonNull URL url, @NonNull Uri attachment) throws IOException {
+        final URL attachmentUrl = new URL(url.toString() + "-" + HttpUtils.getFileNameFromUri(context, attachment));
+        new BinaryHttpRequest(configuration, context, Method.PUT, login, password, connectionTimeOut, socketTimeOut, headers).send(attachmentUrl, attachment);
+    }
+
+    /**
+     * Convert a report to json
+     *
+     * @param report the report to convert
+     * @return a json representation of the report
+     */
+    @SuppressWarnings("WeakerAccess")
+    protected JSONObject convertToJson(CrashReportData report) {
+        return report.toJSON();
+    }
+
+    /**
+     * Convert a report to a form-prepared map
+     *
+     * @param report the report to convert
+     * @return a form representation of the report
+     */
+    @SuppressWarnings("WeakerAccess")
+    protected Map<String, String> convertToForm(CrashReportData report) {
+        return remap(report);
+    }
+
+    @NonNull
+    private Map<String, String> remap(@NonNull Map<ReportField, Element> report) {
+
+        Set<ReportField> fields = config.reportContent();
+        if (fields.isEmpty()) {
+            fields = new ImmutableSet<ReportField>(ACRAConstants.DEFAULT_REPORT_FIELDS);
+        }
+
+        final Map<String, String> finalReport = new HashMap<String, String>(report.size());
+        for (ReportField field : fields) {
+            final Element element = report.get(field);
+            final String value = element != null ? TextUtils.join("\n", element.flatten()) : null;
+            if (mMapping == null || mMapping.get(field) == null) {
+                finalReport.put(field.toString(), value);
+            } else {
+                finalReport.put(mMapping.get(field), value);
+            }
+        }
+        return finalReport;
+    }
+
+    private boolean isNull(@Nullable String aString) {
+        return aString == null || ACRAConstants.NULL_VALUE.equals(aString);
+    }
+
+}
\ No newline at end of file
diff --git a/acra/src/main/java/org/acra/sender/HttpSenderFactory.java b/acra/src/main/java/org/acra/sender/HttpSenderFactory.java
new file mode 100644
index 00000000..69fc1d6f
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/HttpSenderFactory.java
@@ -0,0 +1,18 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Constructs a {@link HttpSender} with no report field mappings.
+ */
+public final class HttpSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        return new HttpSender(config, config.httpMethod(), config.reportType());
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/NullSender.java b/acra/src/main/java/org/acra/sender/NullSender.java
new file mode 100644
index 00000000..a3539c06
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/NullSender.java
@@ -0,0 +1,19 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.collector.CrashReportData;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Sends no report.
+ */
+final class NullSender implements ReportSender {
+    @Override
+    public void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException {
+        ACRA.log.w(LOG_TAG, context.getPackageName() + " reports will NOT be sent - no valid ReportSender is configured. Try setting 'formUri' or 'mailTo'");
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/ReportDistributor.java b/acra/src/main/java/org/acra/sender/ReportDistributor.java
new file mode 100644
index 00000000..9a4fdd20
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/ReportDistributor.java
@@ -0,0 +1,146 @@
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import org.acra.ACRA;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.config.DefaultRetryPolicy;
+import org.acra.config.RetryPolicy;
+import org.acra.file.CrashReportPersister;
+import org.acra.util.IOUtils;
+import org.acra.util.InstanceCreator;
+import org.json.JSONException;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Distributes reports to all Senders.
+ *
+ * @author William Ferguson
+ * @since 4.8.0
+ */
+final class ReportDistributor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final List<ReportSender> reportSenders;
+
+    /**
+     * Creates a new {@link ReportDistributor} to try sending pending reports.
+     *
+     * @param context               ApplicationContext in which the reports are being sent.
+     * @param config                Configuration to use while sending.
+     * @param reportSenders         List of ReportSender to use to send the crash reports.
+     */
+    ReportDistributor(@NonNull Context context, @NonNull ACRAConfiguration config, @NonNull List<ReportSender> reportSenders) {
+        this.context = context;
+        this.config = config;
+        this.reportSenders = reportSenders;
+    }
+
+    /**
+     * Send report via all senders.
+     *
+     * @param reportFile    Report to send.
+     */
+    public void distribute(@NonNull File reportFile) {
+
+        ACRA.log.i(LOG_TAG, "Sending report " + reportFile );
+        try {
+            final CrashReportPersister persister = new CrashReportPersister();
+            final CrashReportData previousCrashReport = persister.load(reportFile);
+            sendCrashReport(previousCrashReport);
+            IOUtils.deleteReport(reportFile);
+        } catch (RuntimeException e) {
+            ACRA.log.e(LOG_TAG, "Failed to send crash reports for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        } catch (JSONException e) {
+            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        }catch (ReportSenderException e) {
+            ACRA.log.e(LOG_TAG, "Failed to send crash report for " + reportFile, e);
+            // An issue occurred while sending this report but we can still try to
+            // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS
+            // so there's not much to fear about overloading a failing server.
+        }
+    }
+
+    /**
+     * Sends the report with all configured ReportSenders. If at least one
+     * sender completed its job, the report is considered as sent and will not
+     * be sent again for failing senders.
+     *
+     * @param errorContent  Crash data.
+     * @throws ReportSenderException if unable to send the crash report.
+     */
+    private void sendCrashReport(@NonNull CrashReportData errorContent) throws ReportSenderException {
+        if (!isDebuggable() || config.sendReportsInDevMode()) {
+            final List<RetryPolicy.FailedSender> failedSenders = new LinkedList<RetryPolicy.FailedSender>();
+            for (ReportSender sender : reportSenders) {
+                try {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Sending report using " + sender.getClass().getName());
+                    sender.send(context, errorContent);
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Sent report using " + sender.getClass().getName());
+                } catch (ReportSenderException e) {
+                    failedSenders.add(new RetryPolicy.FailedSender(sender, e));
+                }
+            }
+
+            final InstanceCreator instanceCreator = new InstanceCreator();
+            if (failedSenders.isEmpty()) {
+                if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Report was sent by all senders");
+            } else if (instanceCreator.create(config.retryPolicyClass(), new DefaultRetryPolicy()).shouldRetrySend(reportSenders, failedSenders)) {
+                final Throwable firstFailure = failedSenders.get(0).getException();
+                throw new ReportSenderException("Policy marked this task as incomplete. ACRA will try to send this report again.", firstFailure);
+            } else {
+                final StringBuilder builder = new StringBuilder("ReportSenders of classes [");
+                for (final RetryPolicy.FailedSender failedSender : failedSenders) {
+                    builder.append(failedSender.getSender().getClass().getName());
+                    builder.append(", ");
+                }
+                builder.append("] failed, but Policy marked this task as complete. ACRA will not send this report again.");
+                ACRA.log.w(LOG_TAG, builder.toString());
+            }
+        }
+    }
+
+    /**
+     * Returns true if the application is debuggable.
+     *
+     * @return true if the application is debuggable.
+     */
+    private boolean isDebuggable() {
+        final PackageManager pm = context.getPackageManager();
+        try {
+            return (pm.getApplicationInfo(context.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0;
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/sender/ReportSender.java b/acra/src/main/java/org/acra/sender/ReportSender.java
similarity index 69%
rename from src/main/java/org/acra/sender/ReportSender.java
rename to acra/src/main/java/org/acra/sender/ReportSender.java
index 5271019c..f7cb4125 100644
--- a/src/main/java/org/acra/sender/ReportSender.java
+++ b/acra/src/main/java/org/acra/sender/ReportSender.java
@@ -1,50 +1,50 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.sender;
-
-import android.content.Context;
-import org.acra.collector.CrashReportData;
-
-/**
- * A simple interface for defining various crash report senders. You can reuse
- * {@link HttpSender} to send reports to your custom server-side report
- * collection script even if you expect (or prefer) specific names for each
- * report field as {@link HttpSender#send(Context, CrashReportData)}
- * can take a {@code Map<ReportField, String>} as an input to convert each field name to
- * your preferred POST parameter name.
- * 
- * @author Kevin Gaudin
- * 
- */
-public interface ReportSender {
-    /**
-     * Send crash report data. You don't have to take care of managing Threads,
-     * just implement what is necessary to handle the data. ACRA will use a
-     * specific Thread (not the UI Thread) to run your sender.
-     *
-     *
-     *
-     * @param context       Android Context in which to send the crash report.
-     * @param errorContent
-     *            Stores key/value pairs for each report field. A report field
-     *            is identified by a {@link org.acra.ReportField} enum value.
-     * @throws ReportSenderException
-     *             If anything goes fatally wrong during the handling of crash
-     *             data, you can (should) throw a {@link ReportSenderException}
-     *             with a custom message.
-     */
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException;
-}
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.collector.CrashReportData;
+
+/**
+ * A simple interface for defining various crash report senders.
+ *
+ * You can reuse {@link HttpSender} to send reports to your custom server-side report
+ * collection script even if you expect (or prefer) specific names for each
+ * report field as {@link HttpSender#send(Context, CrashReportData)}
+ * can take a {@code Map<ReportField, String>} as an input to convert each field name to
+ * your preferred POST parameter name.
+ * 
+ * @author Kevin Gaudin
+ */
+public interface ReportSender {
+
+    /**
+     * Send crash report data.
+     *
+     * Method will be called from the {@link SenderService}.
+     *
+     * @param context       Android Context in which to send the crash report.
+     * @param errorContent  Stores key/value pairs for each report field.
+     *                      A report field is identified by a {@link org.acra.ReportField} enum value.
+     * @throws ReportSenderException
+     *             If anything goes fatally wrong during the handling of crash
+     *             data, you can (should) throw a {@link ReportSenderException}
+     *             with a custom message.
+     */
+    void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException;
+}
diff --git a/src/main/java/org/acra/sender/ReportSenderException.java b/acra/src/main/java/org/acra/sender/ReportSenderException.java
similarity index 92%
rename from src/main/java/org/acra/sender/ReportSenderException.java
rename to acra/src/main/java/org/acra/sender/ReportSenderException.java
index b4c8cf44..7b832dc4 100644
--- a/src/main/java/org/acra/sender/ReportSenderException.java
+++ b/acra/src/main/java/org/acra/sender/ReportSenderException.java
@@ -1,51 +1,51 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.sender;
-
-/**
- * This exception is thrown when an error ocurred while sending crash data in a
- * {@link ReportSender} implementation.
- * 
- * @author Kevin Gaudin
- * 
- */
-@SuppressWarnings("serial")
-public class ReportSenderException extends Exception {
-
-    /**
-     * Creates a new {@link ReportSenderException} instance. You can provide a
-     * detailed message to explain what went wrong.
-     * 
-     * @param detailMessage
-     *            A message to explain the cause of this exception.
-     * @param throwable
-     *            An optional throwable which caused this Exception.
-     */
-    public ReportSenderException(String detailMessage, Throwable throwable) {
-        super(detailMessage, throwable);
-    }
-
-    /**
-     * Creates a new {@link ReportSenderException} instance. You can provide a
-     * detailed message to explain what went wrong.
-     * 
-     * @param detailMessage
-     *            A message to explain the cause of this exception.
-     **/
-    public ReportSenderException(String detailMessage) {
-        super(detailMessage);
-    }
-}
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+/**
+ * This exception is thrown when an error occurred while sending crash data in a
+ * {@link ReportSender} implementation.
+ * 
+ * @author Kevin Gaudin
+ * 
+ */
+@SuppressWarnings("serial")
+public class ReportSenderException extends Exception {
+
+    /**
+     * Creates a new {@link ReportSenderException} instance. You can provide a
+     * detailed message to explain what went wrong.
+     * 
+     * @param detailMessage
+     *            A message to explain the cause of this exception.
+     * @param throwable
+     *            An optional throwable which caused this Exception.
+     */
+    public ReportSenderException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+    /**
+     * Creates a new {@link ReportSenderException} instance. You can provide a
+     * detailed message to explain what went wrong.
+     * 
+     * @param detailMessage
+     *            A message to explain the cause of this exception.
+     **/
+    public ReportSenderException(String detailMessage) {
+        super(detailMessage);
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/ReportSenderFactory.java b/acra/src/main/java/org/acra/sender/ReportSenderFactory.java
new file mode 100644
index 00000000..122abb2e
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/ReportSenderFactory.java
@@ -0,0 +1,25 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Factory for creating and configuring a {@link ReportSender} instance.
+ * Implementations must have a no argument constructor.
+ *
+ * Each configured ReportSenderFactory is created within the {@link SenderService}
+ * and is used to construct and configure a single {@link ReportSender}.
+ *
+ * Created by William on 4-JAN-2016.
+ */
+public interface ReportSenderFactory {
+
+    /**
+     * @param context   Application context.
+     * @param config    Configuration to use when sending reports.
+     * @return Fully configured instance of the relevant ReportSender.
+     */
+    @NonNull
+    ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config);
+}
diff --git a/acra/src/main/java/org/acra/sender/SenderService.java b/acra/src/main/java/org/acra/sender/SenderService.java
new file mode 100644
index 00000000..607e5670
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/SenderService.java
@@ -0,0 +1,123 @@
+/*
+ *  Copyright 2017
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+import org.acra.util.InstanceCreator;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+public class SenderService extends IntentService {
+
+    public static final String EXTRA_ONLY_SEND_SILENT_REPORTS = "onlySendSilentReports";
+    public static final String EXTRA_APPROVE_REPORTS_FIRST = "approveReportsFirst";
+    public static final String EXTRA_ACRA_CONFIG = "acraConfig";
+
+    private final ReportLocator locator = new ReportLocator(this);
+
+    public SenderService() {
+        super("ACRA SenderService");
+        setIntentRedelivery(true);
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable final Intent intent) {
+        if (intent == null || !intent.hasExtra(EXTRA_ACRA_CONFIG)) {
+            if(ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "SenderService was started but no valid intent was delivered, will now quit");
+            return;
+        }
+
+        final boolean onlySendSilentReports = intent.getBooleanExtra(EXTRA_ONLY_SEND_SILENT_REPORTS, false);
+        final boolean approveReportsFirst = intent.getBooleanExtra(EXTRA_APPROVE_REPORTS_FIRST, false);
+
+        final ACRAConfiguration config = (ACRAConfiguration) intent.getSerializableExtra(EXTRA_ACRA_CONFIG);
+
+        final Collection<Class<? extends ReportSenderFactory>> senderFactoryClasses = config.reportSenderFactoryClasses();
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "About to start sending reports from SenderService");
+        try {
+            final List<ReportSender> senderInstances = getSenderInstances(config, senderFactoryClasses);
+
+            // Mark reports as approved
+            if (approveReportsFirst) {
+                markReportsAsApproved();
+            }
+
+            // Get approved reports
+            final File[] reports = locator.getApprovedReports();
+
+            final ReportDistributor reportDistributor = new ReportDistributor(this, config, senderInstances);
+
+            // Iterate over approved reports and send via all Senders.
+            int reportsSentCount = 0; // Use to rate limit sending
+            final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+            for (final File report : reports) {
+                if (onlySendSilentReports && !fileNameParser.isSilent(report.getName())) {
+                    continue;
+                }
+
+                if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
+                    break; // send only a few reports to avoid overloading the network
+                }
+
+                reportDistributor.distribute(report);
+                reportsSentCount++;
+            }
+        } catch (Exception e) {
+            ACRA.log.e(LOG_TAG, "", e);
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Finished sending reports from SenderService");
+    }
+
+    @NonNull
+    private List<ReportSender> getSenderInstances(@NonNull ACRAConfiguration config, @NonNull Collection<Class<? extends ReportSenderFactory>> factoryClasses) {
+        final List<ReportSender> reportSenders = new ArrayList<ReportSender>();
+        final InstanceCreator instanceCreator = new InstanceCreator();
+        for (ReportSenderFactory factory : instanceCreator.create(factoryClasses)) {
+            reportSenders.add(factory.create(this.getApplication(), config));
+        }
+        return reportSenders;
+    }
+
+    /**
+     * Flag all pending reports as "approved" by the user. These reports can be sent.
+     */
+    private void markReportsAsApproved() {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Mark all pending reports as approved.");
+
+        for (File report : locator.getUnapprovedReports()) {
+            final File approvedReport = new File(locator.getApprovedFolder(), report.getName());
+            if (!report.renameTo(approvedReport)) {
+                ACRA.log.w(LOG_TAG, "Could not rename approved report from " + report + " to " + approvedReport);
+            }
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/sender/SenderServiceStarter.java b/acra/src/main/java/org/acra/sender/SenderServiceStarter.java
new file mode 100644
index 00000000..4475e247
--- /dev/null
+++ b/acra/src/main/java/org/acra/sender/SenderServiceStarter.java
@@ -0,0 +1,39 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.config.ACRAConfiguration;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Starts the Service(Intent)Service to process and send pending reports.
+ */
+public class SenderServiceStarter {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public SenderServiceStarter(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Starts a Thread to start sending outstanding error reports.
+     *
+     * @param onlySendSilentReports If true then only send silent reports.
+     * @param approveReportsFirst   If true then approve unapproved reports first.
+     */
+    public void startService(boolean onlySendSilentReports, boolean approveReportsFirst) {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "About to start SenderService");
+        final Intent intent = new Intent(context, SenderService.class);
+        intent.putExtra(SenderService.EXTRA_ONLY_SEND_SILENT_REPORTS, onlySendSilentReports);
+        intent.putExtra(SenderService.EXTRA_APPROVE_REPORTS_FIRST, approveReportsFirst);
+        intent.putExtra(SenderService.EXTRA_ACRA_CONFIG, config);
+        context.startService(intent);
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/ApplicationStartupProcessor.java b/acra/src/main/java/org/acra/util/ApplicationStartupProcessor.java
new file mode 100644
index 00000000..9f21df82
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/ApplicationStartupProcessor.java
@@ -0,0 +1,104 @@
+package org.acra.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.PackageInfo;
+import android.support.annotation.NonNull;
+import android.widget.Toast;
+import org.acra.ACRA;
+import org.acra.ReportingInteractionMode;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.BulkReportDeleter;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+import org.acra.prefs.PrefUtils;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.sender.SenderServiceStarter;
+
+import java.io.File;
+
+/**
+ * Looks for any existing reports and starts sending them.
+ */
+public final class ApplicationStartupProcessor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public ApplicationStartupProcessor(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Delete any old unsent reports if this is a newer version of the app than when we last started.
+     */
+    public void deleteUnsentReportsFromOldAppVersion() {
+        final SharedPreferences prefs = new SharedPreferencesFactory(context, config).create();
+        final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR, 0);
+        final int appVersion = getAppVersion();
+
+        if (appVersion > lastVersionNr) {
+            final BulkReportDeleter reportDeleter = new BulkReportDeleter(context);
+            reportDeleter.deleteReports(true, 0);
+            reportDeleter.deleteReports(false, 0);
+
+            final SharedPreferences.Editor prefsEditor = prefs.edit();
+            prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR, appVersion);
+            PrefUtils.save(prefsEditor);
+        }
+    }
+
+    /**
+     * Deletes all the unapproved reports except for the last one.
+     *
+     * NOTIFICATION or DIALOG mode require explicit approval by user.
+     * If latest notification/dialog has been ignored: neither accepted nor refused; they will accumulate.
+     * So destroy all unapproved reports bar the last one.
+     */
+    public void deleteAllUnapprovedReportsBarOne() {
+        new BulkReportDeleter(context).deleteReports(false, 1);
+    }
+
+    /**
+     * If ReportingInteractionMode == Toast and at least one non silent report then show a Toast.
+     * All approved reports will be sent.
+     */
+    public void sendApprovedReports() {
+
+        final ReportLocator reportLocator = new ReportLocator(context);
+        final File[] reportFiles = reportLocator.getApprovedReports();
+
+        if (reportFiles.length == 0) {
+            return; // There are no approved reports, so bail now.
+        }
+
+        if (config.reportingInteractionMode() == ReportingInteractionMode.TOAST && hasNonSilentApprovedReports(reportFiles)) {
+            ToastSender.sendToast(context, config.resToastText(), Toast.LENGTH_LONG);
+        }
+
+        // Send the approved reports.
+        final SenderServiceStarter starter = new SenderServiceStarter(context, config);
+        starter.startService(false, false);
+
+    }
+
+    /**
+     * @return app version or 0 if PackageInfo was not available.
+     */
+    private int getAppVersion() {
+        final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(context);
+        final PackageInfo packageInfo = packageManagerWrapper.getPackageInfo();
+        return (packageInfo == null) ? 0 : packageInfo.versionCode;
+    }
+
+    private boolean hasNonSilentApprovedReports(File[] reportFiles) {
+        final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+        for (final File file : reportFiles) {
+            if (!fileNameParser.isSilent(file.getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/IOUtils.java b/acra/src/main/java/org/acra/util/IOUtils.java
new file mode 100644
index 00000000..aa1b4199
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/IOUtils.java
@@ -0,0 +1,191 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.android.internal.util.Predicate;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.collections.BoundedLinkedList;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author William Ferguson, F43nd1r
+ * @since 4.6.0
+ */
+public final class IOUtils {
+
+    private static final Predicate<String> DEFAULT_FILTER = new Predicate<String>() {
+        @Override
+        public boolean apply(String s) {
+            return true;
+        }
+    };
+    private static final int NO_LIMIT = -1;
+    private static final int READ_TIMEOUT = 3000;
+
+    private IOUtils() {
+    }
+
+
+    /**
+     * Closes a Closeable.
+     *
+     * @param closeable Closeable to close. If closeable is null then method just returns.
+     */
+    public static void safeClose(@Nullable Closeable closeable) {
+        if (closeable == null) return;
+
+        try {
+            closeable.close();
+        } catch (IOException ignored) {
+            // We made out best effort to release this resource. Nothing more we can do.
+        }
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input InputStream to read.
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input) throws IOException {
+        return streamToString(input, DEFAULT_FILTER, NO_LIMIT);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @param filter should return false for lines which should be excluded
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, Predicate<String> filter) throws IOException {
+        return streamToString(input, filter, NO_LIMIT);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input InputStream to read.
+     * @param limit the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, int limit) throws IOException {
+        return streamToString(input, DEFAULT_FILTER, limit);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @param filter Predicate that should return false for lines which should be excluded.
+     * @param limit  the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(input), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            String line;
+            final List<String> buffer = limit == NO_LIMIT ? new LinkedList<String>() : new BoundedLinkedList<String>(limit);
+            while ((line = reader.readLine()) != null) {
+                if (filter.apply(line)) {
+                    buffer.add(line);
+                }
+            }
+            return TextUtils.join("\n", buffer);
+        } finally {
+            safeClose(reader);
+        }
+    }
+
+    /**
+     * Reads an InputStream into a string without blocking the current thread.
+     * It has a default timeout of 3 seconds.
+     *
+     * @param input  InputStream to read.
+     * @param filter Predicate that should return false for lines which should be excluded.
+     * @param limit  the maximum number of lines to read (the last x lines are kept).
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToStringNonBlockingRead(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(input), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        final NonBlockingBufferedReader nonBlockingReader = new NonBlockingBufferedReader(reader);
+        try {
+            final List<String> buffer = limit == NO_LIMIT ? new LinkedList<String>() : new BoundedLinkedList<String>(limit);
+            final long end = System.currentTimeMillis() + READ_TIMEOUT;
+            try {
+                while ((System.currentTimeMillis() < end)) {
+                    final String line = nonBlockingReader.readLine();
+                    if (line == null) {
+                        break;
+                    }
+                    if (filter.apply(line)) {
+                        buffer.add(line);
+                    }
+                }
+            } catch (InterruptedException e) {
+                if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Interrupted while reading stream", e);
+            }
+            return TextUtils.join("\n", buffer);
+        } finally {
+            nonBlockingReader.close();
+        }
+    }
+
+    public static void deleteReport(@NonNull File file) {
+        final boolean deleted = file.delete();
+        if (!deleted) {
+            ACRA.log.w(LOG_TAG, "Could not delete error report : " + file);
+        }
+    }
+
+    public static void writeStringToFile(@NonNull File file, @NonNull String content) throws IOException {
+        final OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), ACRAConstants.UTF8);
+        try {
+            writer.write(content);
+            writer.flush();
+        } finally {
+            safeClose(writer);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/util/Installation.java b/acra/src/main/java/org/acra/util/Installation.java
similarity index 81%
rename from src/main/java/org/acra/util/Installation.java
rename to acra/src/main/java/org/acra/util/Installation.java
index 16921f38..3000000c 100644
--- a/src/main/java/org/acra/util/Installation.java
+++ b/acra/src/main/java/org/acra/util/Installation.java
@@ -1,74 +1,78 @@
-/*
- * Class copied from the Android Developers Blog:
- * http://android-developers.blogspot.com/2011/03/identifying-app-installations.html 
- */
-package org.acra.util;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.util.UUID;
-
-import org.acra.ACRA;
-
-import android.content.Context;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * <p>
- * Creates a file storing a UUID on the first application start. This UUID can then be used as a identifier of this
- * specific application installation.
- * </p>
- * 
- * <p>
- * This was taken from <a href="http://android-developers.blogspot.com/2011/03/identifying-app-installations.html"> the
- * android developers blog.</a>
- * </p>
- */
-public class Installation {
-
-    private static String sID;
-    private static final String INSTALLATION = "ACRA-INSTALLATION";
-
-    public synchronized static String id(Context context) {
-        if (sID == null) {
-            final File installation = new File(context.getFilesDir(), INSTALLATION);
-            try {
-                if (!installation.exists()) {
-                    writeInstallationFile(installation);
-                }
-                sID = readInstallationFile(installation);
-            } catch (IOException e) {
-                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
-                return "Couldn't retrieve InstallationId";
-            } catch (RuntimeException e) {
-                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
-                return "Couldn't retrieve InstallationId";
-            }
-        }
-        return sID;
-    }
-
-    private static String readInstallationFile(File installation) throws IOException {
-        final RandomAccessFile f = new RandomAccessFile(installation, "r");
-        final byte[] bytes = new byte[(int) f.length()];
-        try {
-            f.readFully(bytes);
-        } finally {
-            f.close();
-        }
-        return new String(bytes);
-    }
-
-    private static void writeInstallationFile(File installation) throws IOException {
-        final FileOutputStream out = new FileOutputStream(installation);
-        try {
-            final String id = UUID.randomUUID().toString();
-            out.write(id.getBytes());
-        } finally {
-            out.close();
-        }
-    }
-}
+/*
+ * Class copied from the Android Developers Blog:
+ * http://android-developers.blogspot.com/2011/03/identifying-app-installations.html 
+ */
+package org.acra.util;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.UUID;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * <p>
+ * Creates a file storing a UUID on the first application start. This UUID can then be used as a identifier of this
+ * specific application installation.
+ * </p>
+ * 
+ * <p>
+ * This was taken from <a href="http://android-developers.blogspot.com/2011/03/identifying-app-installations.html"> the
+ * android developers blog.</a>
+ * </p>
+ */
+public final class Installation {
+    private Installation(){}
+
+    private static String sID;
+    private static final String INSTALLATION = "ACRA-INSTALLATION";
+
+    @NonNull
+    public static synchronized String id(@NonNull Context context) {
+        if (sID == null) {
+            final File installation = new File(context.getFilesDir(), INSTALLATION);
+            try {
+                if (!installation.exists()) {
+                    writeInstallationFile(installation);
+                }
+                sID = readInstallationFile(installation);
+            } catch (IOException e) {
+                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
+                return "Couldn't retrieve InstallationId";
+            } catch (RuntimeException e) {
+                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
+                return "Couldn't retrieve InstallationId";
+            }
+        }
+        return sID;
+    }
+
+    @NonNull
+    private static String readInstallationFile(@NonNull File installation) throws IOException {
+        final RandomAccessFile f = new RandomAccessFile(installation, "r");
+        final byte[] bytes = new byte[(int) f.length()];
+        try {
+            f.readFully(bytes);
+        } finally {
+            IOUtils.safeClose(f);
+        }
+        return new String(bytes);
+    }
+
+    private static void writeInstallationFile(@NonNull File installation) throws IOException {
+        final FileOutputStream out = new FileOutputStream(installation);
+        try {
+            final String id = UUID.randomUUID().toString();
+            out.write(id.getBytes());
+        } finally {
+            IOUtils.safeClose(out);
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/InstanceCreator.java b/acra/src/main/java/org/acra/util/InstanceCreator.java
new file mode 100644
index 00000000..8b2c85a4
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/InstanceCreator.java
@@ -0,0 +1,70 @@
+/*
+ *  Copyright 2017
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author F43nd1r
+ * @since 09.03.2017
+ */
+public final class InstanceCreator {
+
+    /**
+     * Create an instance of clazz
+     * @param clazz the clazz to create an instance of
+     * @param fallback the value to return in case of a failure
+     * @param <T> the return type
+     * @return a new instance of clazz or fallback
+     */
+    public <T> T create(@NonNull Class<? extends T> clazz, @Nullable T fallback) {
+        try {
+            return clazz.newInstance();
+        } catch (InstantiationException e) {
+            ACRA.log.e(LOG_TAG, "Failed to create instance of class " + clazz.getName(), e);
+        } catch (IllegalAccessException e) {
+            ACRA.log.e(LOG_TAG, "Failed to create instance of class " + clazz.getName(), e);
+        }
+        return fallback;
+    }
+
+    /**
+     * Create instances of the given classes
+     * @param classes the classes to create insatnces of
+     * @param <T> the return type
+     * @return a list of successfully created instances, does not contain null
+     */
+    @NonNull
+    public <T> List<T> create(@NonNull Collection<Class<? extends T>> classes) {
+        final List<T> result = new ArrayList<T>();
+        for (Class<? extends T> clazz : classes) {
+            final T instance = create(clazz, null);
+            if (instance != null) {
+                result.add(instance);
+            }
+        }
+        return result;
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/JsonUtils.java b/acra/src/main/java/org/acra/util/JsonUtils.java
new file mode 100644
index 00000000..e399d573
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/JsonUtils.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.util;
+
+import android.util.Log;
+
+import org.acra.ReportField;
+import org.acra.model.ComplexElement;
+import org.acra.collector.CrashReportData;
+import org.acra.model.Element;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+public final class JsonUtils {
+    private JsonUtils() {
+    }
+
+    public static JSONObject toJson(CrashReportData data) {
+        final Map<String, Object> map = new HashMap<String, Object>();
+        for (Map.Entry<ReportField, Element> entry : data.entrySet()) {
+            final Element element = entry.getValue();
+            map.put(entry.getKey().name(), element.value());
+        }
+        return new JSONObject(map);
+    }
+
+    public static CrashReportData toCrashReportData(JSONObject json) {
+        final CrashReportData data = new CrashReportData();
+        for (final Iterator<String> iterator = json.keys(); iterator.hasNext(); ) {
+            final String key = iterator.next();
+            try {
+                final ReportField field = ReportField.valueOf(key);
+                final Object value = json.get(key);
+                if (value instanceof JSONObject) {
+                    data.put(field, new ComplexElement((JSONObject) value));
+                } else if (value instanceof Number) {
+                    data.putNumber(field, (Number) value);
+                } else if (value instanceof Boolean) {
+                    data.putBoolean(field, (Boolean) value);
+                } else {
+                    data.putString(field, value.toString());
+                }
+            } catch (IllegalArgumentException e) {
+                Log.w(LOG_TAG, "Unknown report key " + key, e);
+            } catch (JSONException e) {
+                Log.w(LOG_TAG, "Unable to read report field " + key, e);
+            }
+        }
+        return data;
+    }
+
+    public static List<String> flatten(JSONObject json) throws JSONException {
+        final List<String> result = new ArrayList<String>();
+        for (final Iterator<String> iterator = json.keys(); iterator.hasNext(); ) {
+            final String key = iterator.next();
+            final Object value = json.get(key);
+            if (value instanceof JSONObject) {
+                for (String s : flatten((JSONObject) value)) {
+                    result.add(key + "." + s);
+                }
+            } else {
+                result.add(key + "=" + value);
+            }
+        }
+        return result;
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/NonBlockingBufferedReader.java b/acra/src/main/java/org/acra/util/NonBlockingBufferedReader.java
new file mode 100644
index 00000000..e9ceb54b
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/NonBlockingBufferedReader.java
@@ -0,0 +1,57 @@
+package org.acra.util;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Asynchronously reads a buffer into a List of String.
+ *
+ * @author C-Romeo
+ * @since 4.9.0
+ */
+final class NonBlockingBufferedReader {
+
+    private final BlockingQueue<String> lines = new LinkedBlockingQueue<String>();
+    private Thread backgroundReaderThread = null;
+    private volatile IOException exception = null;
+
+    NonBlockingBufferedReader(final BufferedReader bufferedReader) {
+        backgroundReaderThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    while (!Thread.interrupted()) {
+                        final String line = bufferedReader.readLine();
+                        if (line == null) {
+                            break;
+                        }
+                        lines.add(line);
+                    }
+                } catch (IOException e) {
+                    exception = e;
+                } finally {
+                    IOUtils.safeClose(bufferedReader);
+                }
+            }
+        });
+        backgroundReaderThread.setDaemon(true);
+        backgroundReaderThread.start();
+    }
+
+    String readLine() throws InterruptedException, IOException {
+        if(exception != null){
+            throw exception;
+        }
+        return lines.isEmpty() ? null : lines.poll(500L, TimeUnit.MILLISECONDS);
+    }
+
+    void close() {
+        if (backgroundReaderThread != null) {
+            backgroundReaderThread.interrupt();
+            backgroundReaderThread = null;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/util/PackageManagerWrapper.java b/acra/src/main/java/org/acra/util/PackageManagerWrapper.java
similarity index 73%
rename from src/main/java/org/acra/util/PackageManagerWrapper.java
rename to acra/src/main/java/org/acra/util/PackageManagerWrapper.java
index cb9ab87c..2de81172 100644
--- a/src/main/java/org/acra/util/PackageManagerWrapper.java
+++ b/acra/src/main/java/org/acra/util/PackageManagerWrapper.java
@@ -1,74 +1,76 @@
-package org.acra.util;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-
-import org.acra.ACRA;
-
-/**
- * Responsible for wrapping calls to PackageManager to ensure that they always complete without throwing RuntimeExceptions.
- * <p>
- *     Depending upon the state of the application it is possible that
- *     <ul>
- *         <li>Context has no PackageManager.</li>
- *         <li>PackageManager returned by Context throws RuntimeException("Package manager has died")
- *              because it cannot contact the remote PackageManager service.
- *         </li>
- *     </ul>
- *     I suspect that PackageManager death is caused during app installation.
- *     But we need to make ACRA bullet proof, so it's better to handle the condition safely so that the error report itself doesn't fail.
- * </p>
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class PackageManagerWrapper {
-
-    private final Context context;
-
-    public PackageManagerWrapper(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * @param permission    Manifest.permission to check whether it has been granted.
-     * @return true if the permission has been granted to the app, false if it hasn't been granted or the PackageManager could not be contacted.
-     */
-    public boolean hasPermission(String permission) {
-        final PackageManager pm = context.getPackageManager();
-        if (pm == null) {
-            return false;
-        }
-
-        try {
-            return pm.checkPermission(permission, context.getPackageName()) == PackageManager.PERMISSION_GRANTED;
-        } catch (RuntimeException e) {
-            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
-            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
-            return false;
-        }
-    }
-
-    /**
-     * @return PackageInfo for the current application or null if the PackageManager could not be contacted.
-     */
-    public PackageInfo getPackageInfo() {
-        final PackageManager pm = context.getPackageManager();
-        if (pm == null) {
-            return null;
-        }
-
-        try {
-            return pm.getPackageInfo(context.getPackageName(), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            ACRA.log.v(LOG_TAG, "Failed to find PackageInfo for current App : " + context.getPackageName());
-            return null;
-        } catch (RuntimeException e) {
-            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
-            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
-            return null;
-        }
-    }
-}
+package org.acra.util;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Responsible for wrapping calls to PackageManager to ensure that they always complete without throwing RuntimeExceptions.
+ * Depending upon the state of the application it is possible that
+ *     <ul>
+ *         <li>Context has no PackageManager.</li>
+ *         <li>PackageManager returned by Context throws RuntimeException("Package manager has died")
+ *             because it cannot contact the remote PackageManager service.
+ *         </li>
+ *     </ul>
+ * I suspect that PackageManager death is caused during app installation.
+ * But we need to make ACRA bullet proof, so it's better to handle the condition safely so that the error report itself doesn't fail.
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class PackageManagerWrapper {
+
+    private final Context context;
+
+    public PackageManagerWrapper(@NonNull Context context) {
+        this.context = context;
+    }
+
+    /**
+     * @param permission Manifest.permission to check whether it has been granted.
+     * @return true if the permission has been granted to the app, false if it hasn't been granted or the PackageManager could not be contacted.
+     */
+    public boolean hasPermission(@NonNull String permission) {
+        final PackageManager pm = context.getPackageManager();
+        if (pm == null) {
+            return false;
+        }
+
+        try {
+            return pm.checkPermission(permission, context.getPackageName()) == PackageManager.PERMISSION_GRANTED;
+        } catch (Throwable e) {
+            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
+            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
+            return false;
+        }
+    }
+
+    /**
+     * @return PackageInfo for the current application or null if the PackageManager could not be contacted.
+     */
+    @Nullable
+    public PackageInfo getPackageInfo() {
+        final PackageManager pm = context.getPackageManager();
+        if (pm == null) {
+            return null;
+        }
+
+        try {
+            return pm.getPackageInfo(context.getPackageName(), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            ACRA.log.w(LOG_TAG, "Failed to find PackageInfo for current App : " + context.getPackageName());
+            return null;
+        } catch (Throwable e) {
+            // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
+            // when the remote PackageManager is unavailable. I suspect this sometimes occurs when the App is being reinstalled.
+            return null;
+        }
+    }
+}
diff --git a/acra/src/main/java/org/acra/util/ProcessFinisher.java b/acra/src/main/java/org/acra/util/ProcessFinisher.java
new file mode 100644
index 00000000..968106a1
--- /dev/null
+++ b/acra/src/main/java/org/acra/util/ProcessFinisher.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.util;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.builder.LastActivityManager;
+import org.acra.config.ACRAConfiguration;
+import org.acra.sender.SenderService;
+
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Takes care of cleaning up a process and killing it.
+ *
+ * @author F43nd1r
+ * @since 4.9.2
+ */
+
+public final class ProcessFinisher {
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final LastActivityManager lastActivityManager;
+
+    public ProcessFinisher(@NonNull Context context, @NonNull ACRAConfiguration config, @NonNull LastActivityManager lastActivityManager) {
+        this.context = context;
+        this.config = config;
+        this.lastActivityManager = lastActivityManager;
+    }
+
+    public void endApplication(@Nullable Thread uncaughtExceptionThread) {
+        finishLastActivity(uncaughtExceptionThread);
+        stopServices();
+        killProcessAndExit();
+    }
+
+    public void finishLastActivity(@Nullable Thread uncaughtExceptionThread) {
+        // Trying to solve https://github.com/ACRA/acra/issues/42#issuecomment-12134144
+        // Determine the current/last Activity that was started and close
+        // it. Activity#finish (and maybe it's parent too).
+        final Activity lastActivity = lastActivityManager.getLastActivity();
+        if (lastActivity != null) {
+            if (ACRA.DEV_LOGGING)
+                ACRA.log.d(LOG_TAG, "Finishing the last Activity prior to killing the Process");
+            lastActivity.runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    lastActivity.finish();
+                    if (ACRA.DEV_LOGGING)
+                        ACRA.log.d(LOG_TAG, "Finished " + lastActivity.getClass());
+                }
+            });
+
+            // A crashed activity won't continue its lifecycle. So we only wait if something else crashed
+            if (uncaughtExceptionThread != lastActivity.getMainLooper().getThread()) {
+                lastActivityManager.waitForActivityStop(100);
+            }
+            lastActivityManager.clearLastActivity();
+        }
+    }
+
+    private void stopServices() {
+        if (config.stopServicesOnCrash()) {
+            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+            final List<ActivityManager.RunningServiceInfo> runningServices = activityManager.getRunningServices(Integer.MAX_VALUE);
+            final int pid = Process.myPid();
+            for (ActivityManager.RunningServiceInfo serviceInfo : runningServices) {
+                if (serviceInfo.pid == pid && !SenderService.class.getName().equals(serviceInfo.service.getClassName())) {
+                    try {
+                        final Intent intent = new Intent();
+                        intent.setComponent(serviceInfo.service);
+                        context.stopService(intent);
+                    } catch (SecurityException e) {
+                        if (ACRA.DEV_LOGGING)
+                            ACRA.log.d(ACRA.LOG_TAG, "Unable to stop Service " + serviceInfo.service.getClassName() + ". Permission denied");
+                    }
+                }
+            }
+        }
+    }
+
+    private void killProcessAndExit() {
+        android.os.Process.killProcess(android.os.Process.myPid());
+        System.exit(10);
+    }
+}
diff --git a/src/main/java/org/acra/util/ToastSender.java b/acra/src/main/java/org/acra/util/ToastSender.java
similarity index 50%
rename from src/main/java/org/acra/util/ToastSender.java
rename to acra/src/main/java/org/acra/util/ToastSender.java
index a8c952ae..526fc6b4 100644
--- a/src/main/java/org/acra/util/ToastSender.java
+++ b/acra/src/main/java/org/acra/util/ToastSender.java
@@ -1,32 +1,36 @@
-package org.acra.util;
-
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.widget.Toast;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Responsible for sending Toasts under all circumstances.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class ToastSender {
-
-    /**
-     * Sends a Toast and ensures that any Exception thrown during sending is handled.
-     *
-     * @param context           Application context.
-     * @param toastResourceId   Id of the resource to send as the Toast message.
-     * @param toastLength       Length of the Toast.
-     */
-    public static void sendToast(Context context, int toastResourceId, int toastLength) {
-        try {
-            Toast.makeText(context, toastResourceId, toastLength).show();
-        } catch (RuntimeException e) {
-            ACRA.log.e(LOG_TAG, "Could not send crash Toast", e);
-        }
-    }
-}
+package org.acra.util;
+
+import android.content.Context;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.StringRes;
+import android.widget.Toast;
+
+import org.acra.ACRA;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Responsible for sending Toasts under all circumstances.
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class ToastSender {
+    private ToastSender(){}
+
+    /**
+     * Sends a Toast and ensures that any Exception thrown during sending is handled.
+     *
+     * @param context         Application context.
+     * @param toastResourceId Id of the resource to send as the Toast message.
+     * @param toastLength     Length of the Toast.
+     */
+    public static void sendToast(@NonNull Context context, @StringRes int toastResourceId, @IntRange(from = 0, to = 1) int toastLength) {
+        try {
+            Toast.makeText(context, toastResourceId, toastLength).show();
+        } catch (RuntimeException e) {
+            ACRA.log.w(LOG_TAG, "Could not send crash Toast", e);
+        }
+    }
+}
diff --git a/acra/src/main/proguard/proguard.cfg b/acra/src/main/proguard/proguard.cfg
new file mode 100644
index 00000000..5c4d5e30
--- /dev/null
+++ b/acra/src/main/proguard/proguard.cfg
@@ -0,0 +1,19 @@
+#ACRA specifics
+# Restore some Source file names and restore approximate line numbers in the stack traces,
+# otherwise the stack traces are pretty useless
+-keepattributes SourceFile,LineNumberTable
+
+# ACRA needs "annotations" so add this...
+# Note: This may already be defined in the default "proguard-android-optimize.txt"
+# file in the SDK. If it is, then you don't need to duplicate it. See your
+# "project.properties" file to get the path to the default "proguard-android-optimize.txt".
+-keepattributes *Annotation*
+
+# Keep all the ACRA classes
+-keep class org.acra.** { *; }
+
+# Don't warn about removed methods from AppCompat
+-dontwarn android.support.v4.app.NotificationCompat*
+
+# These classes are constucted with reflection.
+-keep public class * implements org.acra.sender.ReportSenderFactory { public <methods>; }
diff --git a/acra/src/main/res/values/strings.xml b/acra/src/main/res/values/strings.xml
new file mode 100644
index 00000000..a3d564ca
--- /dev/null
+++ b/acra/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+This file is just here to force android-maven-plugin:4.4.3 to include a /res folder in the AAR
+which is now a requirement https://developer.android.com/studio/projects/android-library.html#aar-contents
+-->
+<resources>
+    <string name="not_used">Only here to ensure that android-maven-plugin:4.4.3 creates an R.txt</string>
+</resources>
diff --git a/annotationprocessor/build.gradle b/annotationprocessor/build.gradle
new file mode 100644
index 00000000..0c30ea17
--- /dev/null
+++ b/annotationprocessor/build.gradle
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+apply plugin: 'java'
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.google.auto.service:auto-service:1.0-rc2'
+    compile 'com.squareup:javapoet:1.7.0'
+    compile project(':annotations')
+}
+
+sourceCompatibility = "1.8"
+targetCompatibility = "1.8"
+version = '1.0.0'
diff --git a/annotationprocessor/src/main/java/org/acra/AcraAnnotationProcessor.java b/annotationprocessor/src/main/java/org/acra/AcraAnnotationProcessor.java
new file mode 100644
index 00000000..19d7591f
--- /dev/null
+++ b/annotationprocessor/src/main/java/org/acra/AcraAnnotationProcessor.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra;
+
+import com.google.auto.service.AutoService;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+
+import org.acra.annotation.Configuration;
+import org.acra.annotation.ConfigurationBuilder;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+import static org.acra.ModelUtils.*;
+
+/**
+ * Creates the BaseConfigurationBuilder class based on the annotation annotated with {@link Configuration}.
+ * Creates the ACRAConfiguration class based on the BaseConfigurationBuilder and the class annotated with {@link ConfigurationBuilder}
+ *
+ * @author F43nd1r
+ * @since 18.03.2017
+ */
+@AutoService(Processor.class)
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public class AcraAnnotationProcessor extends AbstractProcessor {
+
+    private Elements elementUtils;
+    private Types typeUtils;
+    private ModelUtils utils;
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+        super.init(processingEnv);
+        elementUtils = processingEnv.getElementUtils();
+        typeUtils = processingEnv.getTypeUtils();
+        utils = new ModelUtils(processingEnv);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+        return new HashSet<>(Arrays.asList(Configuration.class.getName(), ConfigurationBuilder.class.getName()));
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        try {
+            final Set<MethodDefinition> methodDefinitions = process(roundEnv, Configuration.class.getName(), ElementKind.ANNOTATION_TYPE, new HashSet<>(), this::createBuilderClass);
+            process(roundEnv, ConfigurationBuilder.class.getName(), ElementKind.CLASS, null, type -> createConfigClass(type, methodDefinitions));
+        } catch (Exception e) {
+            e.printStackTrace();
+            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Failed to generate acra classes");
+        }
+        return true;
+    }
+
+    private <T> T process(RoundEnvironment roundEnv, String annotationName, ElementKind kind, T defaultValue, CheckedFunction<TypeElement, T> function) throws IOException {
+        final TypeElement annotation = elementUtils.getTypeElement(annotationName);
+        final ArrayList<? extends Element> annotatedElements = new ArrayList<>(roundEnv.getElementsAnnotatedWith(annotation));
+        if (annotatedElements.size() > 1) {
+            for (Element e : annotatedElements) {
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format("Only one %s can be annotated with %s", kind.name(), annotationName), e);
+            }
+        } else if (!annotatedElements.isEmpty()) {
+            final Element e = annotatedElements.get(0);
+            if (e.getKind() == kind) {
+                return function.apply((TypeElement) e);
+            } else {
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format("%s is only supported on %s", annotationName, kind.name()), e);
+            }
+        }
+        return defaultValue;
+    }
+
+    /**
+     * Creates the ACRAConfiguration class
+     *
+     * @param builder           type of the builder which will be used to determine methods to generate
+     * @param methodDefinitions additional methods to be included in the configuration (e.g. from the builder base class)
+     * @return null
+     * @throws IOException if the class file can't be written
+     */
+    private Void createConfigClass(TypeElement builder, Set<MethodDefinition> methodDefinitions) throws IOException {
+        final Set<MethodDefinition> methods = getRelevantMethods(builder, methodDefinitions);
+        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(ACRA_CONFIGURATION)
+                .addSuperinterface(Serializable.class)
+                .addModifiers(Modifier.PUBLIC, Modifier.FINAL);
+        utils.addClassJavadoc(classBuilder, builder);
+        final CodeBlock.Builder constructor = CodeBlock.builder();
+        for (MethodDefinition method : methods) {
+            final String name = method.getName();
+            final TypeMirror type = utils.getImmutableType(method.getType());
+            if (type != method.getType()) {
+                constructor.addStatement("$1L = new $2T($3L.$1L())", name, type, PARAM_BUILDER);
+            } else {
+                constructor.addStatement("$1L = $2L.$1L()", name, PARAM_BUILDER);
+            }
+            final TypeName typeName = TypeName.get(type);
+            classBuilder.addField(FieldSpec.builder(typeName, name, Modifier.PRIVATE).addAnnotations(method.getAnnotations()).build());
+            classBuilder.addMethod(MethodSpec.methodBuilder(name)
+                    .returns(typeName)
+                    .addModifiers(Modifier.PUBLIC)
+                    .addAnnotations(method.getAnnotations())
+                    .addStatement("return $L", name)
+                    .build());
+        }
+        classBuilder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
+                .addParameter(ParameterSpec.builder(TypeName.get(builder.asType()), PARAM_BUILDER)
+                        .addAnnotation(AnnotationSpec.builder(ANNOTATION_NON_NULL).build())
+                        .build())
+                .addCode(constructor.build())
+                .build());
+        utils.write(classBuilder.build());
+        return null;
+    }
+
+    /**
+     * Collects all relevant methods from a type.
+     * For a definition of relevant methods, see {@link ModelUtils#shouldRetain(MethodDefinition)}.
+     *
+     * @param builder the type to collect methods from
+     * @return relevant methods in the type
+     */
+    private Set<MethodDefinition> getRelevantMethods(TypeElement builder, Set<MethodDefinition> methodDefinitions) {
+        final Set<MethodDefinition> result = builder.getEnclosedElements().stream().filter(e -> e.getKind() == ElementKind.METHOD && !e.getModifiers().contains(Modifier.PRIVATE))
+                .map(ExecutableElement.class::cast).map(MethodDefinition::from).collect(Collectors.toCollection(HashSet::new));
+        result.addAll(methodDefinitions);
+        return result.stream().filter(utils::shouldRetain).collect(Collectors.toSet());
+    }
+
+    /**
+     * Creates the BaseConfigurationBuilder class
+     *
+     * @param config the configuration annotation type which will be used to determine methods to generate
+     * @return all generated getters
+     * @throws IOException if the class file can't be written
+     */
+    private Set<MethodDefinition> createBuilderClass(TypeElement config) throws IOException {
+        final TypeVariableName returnType = TypeVariableName.get("T", ClassName.get(CONFIGURATION_PACKAGE, CONFIGURATION_BUILDER));
+        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(CONFIGURATION_BUILDER)
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .addTypeVariable(returnType);
+        utils.addClassJavadoc(classBuilder, config);
+        final CodeBlock.Builder constructor = CodeBlock.builder()
+                .addStatement("final $1T $2L = $3L.getClass().getAnnotation($1T.class)", config.asType(), VAR_ANNOTATION_CONFIG, PARAM_APP)
+                .beginControlFlow("if ($L != null)", VAR_ANNOTATION_CONFIG);
+        final Set<MethodDefinition> result = config.getEnclosedElements().stream().filter(element -> element.getKind() == ElementKind.METHOD)
+                .map(ExecutableElement.class::cast).filter(utils::isNotDeprecated).map(e -> handleMethod(e, classBuilder, constructor, returnType)).collect(Collectors.toSet());
+        constructor.endControlFlow();
+        classBuilder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
+                .addParameter(ParameterSpec.builder(APPLICATION, PARAM_APP)
+                        .addAnnotation(AnnotationSpec.builder(ANNOTATION_NON_NULL).build())
+                        .build())
+                .addCode(constructor.build())
+                .build());
+        utils.write(classBuilder.build());
+        return result;
+    }
+
+    /**
+     * Derives all code from one method: A setter, a getter, a field and a line in the constructor
+     *
+     * @param method       the method to derive from
+     * @param classBuilder the class to add methods to
+     * @param constructor  the constructor in which the field will be initialized
+     * @return the generated getter
+     */
+    private MethodDefinition handleMethod(ExecutableElement method, TypeSpec.Builder classBuilder, CodeBlock.Builder constructor, TypeName returnType) {
+        final String name = utils.getName(method);
+        final TypeMirror type = method.getReturnType();
+        final TypeName typeName = TypeName.get(type);
+        final TypeName boxedType = TypeName.get(utils.getBoxedType(type));
+        final List<AnnotationSpec> annotations = ModelUtils.getAnnotations(method);
+        classBuilder.addField(FieldSpec.builder(boxedType, name, Modifier.PRIVATE)
+                .addAnnotations(annotations)
+                .build());
+        classBuilder.addMethod(utils.addMethodJavadoc(MethodSpec.methodBuilder(PREFIX_SETTER + utils.capitalizeFirst(name)), method)
+                .returns(returnType)
+                .addParameter(ParameterSpec.builder(typeName, name).addAnnotations(annotations).build())
+                .varargs(type.getKind() == TypeKind.ARRAY)
+                .addModifiers(Modifier.PUBLIC)
+                .addStatement("this.$1L = $1L", name)
+                .addStatement("return ($T) this", returnType)
+                .build());
+        final CodeBlock.Builder code = CodeBlock.builder()
+                .beginControlFlow("if ($L != null)", name)
+                .addStatement("return $L", name)
+                .endControlFlow();
+        if (type.getKind() == TypeKind.ARRAY) {
+            code.addStatement("return new $T$L", typeUtils.erasure(type), method.getDefaultValue());
+        } else {
+            code.addStatement("return $L", method.getDefaultValue());
+        }
+        classBuilder.addMethod(MethodSpec.methodBuilder(name)
+                .returns(typeName)
+                .addAnnotations(annotations)
+                .addCode(code.build())
+                .build());
+        constructor.addStatement("$L = $L.$L()", name, VAR_ANNOTATION_CONFIG, method.getSimpleName().toString());
+        return new MethodDefinition(name, type, annotations);
+    }
+
+
+    @FunctionalInterface
+    interface CheckedFunction<T, R> {
+        R apply(T t) throws IOException;
+    }
+
+}
diff --git a/annotationprocessor/src/main/java/org/acra/MethodDefinition.java b/annotationprocessor/src/main/java/org/acra/MethodDefinition.java
new file mode 100644
index 00000000..d21cc58a
--- /dev/null
+++ b/annotationprocessor/src/main/java/org/acra/MethodDefinition.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra;
+
+import com.squareup.javapoet.AnnotationSpec;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * The minimal Definition needed to create a getter
+ *
+ * @author F43nd1r
+ * @since 18.03.2017
+ */
+class MethodDefinition {
+    private final String name;
+    private final TypeMirror type;
+    private final List<AnnotationSpec> annotations;
+
+    static MethodDefinition from(ExecutableElement method) {
+        return new MethodDefinition(method.getSimpleName().toString(), method.getReturnType(), ModelUtils.getAnnotations(method));
+    }
+
+    MethodDefinition(String name, TypeMirror type, List<AnnotationSpec> annotations) {
+        this.name = name;
+        this.type = type;
+        this.annotations = annotations;
+    }
+
+    String getName() {
+        return name;
+    }
+
+    TypeMirror getType() {
+        return type;
+    }
+
+    List<AnnotationSpec> getAnnotations() {
+        return annotations;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        final MethodDefinition that = (MethodDefinition) o;
+
+        return name.equals(that.name);
+
+    }
+
+    @Override
+    public int hashCode() {
+        return name.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return annotations.stream().map(AnnotationSpec::toString).collect(Collectors.joining(" ")) + " " + type + " " + name + "()";
+    }
+}
diff --git a/annotationprocessor/src/main/java/org/acra/ModelUtils.java b/annotationprocessor/src/main/java/org/acra/ModelUtils.java
new file mode 100644
index 00000000..7582a4ef
--- /dev/null
+++ b/annotationprocessor/src/main/java/org/acra/ModelUtils.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra;
+
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import org.acra.annotation.Name;
+import org.acra.annotation.NoPropagation;
+
+import java.io.IOException;
+import java.text.DateFormat;
+import java.util.Calendar;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Collection of constants and helper methods to generate ACRA classes
+ *
+ * @author F43nd1r
+ * @since 18.03.2017
+ */
+
+class ModelUtils {
+    static final String CONFIGURATION_PACKAGE = "org.acra.config";
+    static final String CONFIGURATION_BUILDER = "BaseConfigurationBuilder";
+    static final String ACRA_CONFIGURATION = "ACRAConfiguration";
+    static final String PREFIX_SETTER = "set";
+    static final String PARAM_APP = "app";
+    static final String PARAM_BUILDER = "builder";
+    static final String VAR_ANNOTATION_CONFIG = "annotationConfig";
+    static final ClassName APPLICATION = ClassName.bestGuess("android.app.Application");
+    static final ClassName ANNOTATION_NON_NULL = ClassName.bestGuess("android.support.annotation.NonNull");
+    private static final String IMMUTABLE_MAP = "org.acra.collections.ImmutableMap";
+    private static final String IMMUTABLE_LIST = "org.acra.collections.ImmutableList";
+    private static final String IMMUTABLE_SET = "org.acra.collections.ImmutableSet";
+    private static final ClassName ANNOTATION_NO_PROPAGATION = ClassName.get(NoPropagation.class);
+
+    private final Types typeUtils;
+    private final Elements elementUtils;
+    private final TypeMirror map;
+    private final TypeMirror set;
+    private final TypeElement immutableMap;
+    private final TypeElement immutableSet;
+    private final TypeElement immutableList;
+    private final ProcessingEnvironment processingEnv;
+    private final DateFormat dateFormat;
+
+    ModelUtils(ProcessingEnvironment processingEnv) {
+        this.processingEnv = processingEnv;
+        typeUtils = processingEnv.getTypeUtils();
+        elementUtils = processingEnv.getElementUtils();
+        map = elementUtils.getTypeElement(Map.class.getName()).asType();
+        set = elementUtils.getTypeElement(Set.class.getName()).asType();
+        immutableMap = elementUtils.getTypeElement(IMMUTABLE_MAP);
+        immutableSet = elementUtils.getTypeElement(IMMUTABLE_SET);
+        immutableList = elementUtils.getTypeElement(IMMUTABLE_LIST);
+        dateFormat = DateFormat.getDateTimeInstance();
+    }
+
+    /**
+     * Returns an immutable type extending this type, or if the type is an array a immutable list type
+     *
+     * @param type the type
+     * @return the immutable counterpart (might be type, if type is already immutable or no immutable type was found)
+     */
+    TypeMirror getImmutableType(TypeMirror type) {
+        if (typeUtils.isAssignable(typeUtils.erasure(type), map)) {
+            return getWithParams(immutableMap, type);
+        } else if (typeUtils.isAssignable(typeUtils.erasure(type), set)) {
+            return getWithParams(immutableSet, type);
+        } else if (type.getKind() == TypeKind.ARRAY) {
+            return typeUtils.getDeclaredType(immutableList, ((ArrayType) type).getComponentType());
+        }
+        return type;
+    }
+
+    /**
+     * Creates a type based on base, but with the type parameters from parameterType
+     *
+     * @param baseType      base
+     * @param parameterType parameterType
+     * @return the parametrized type
+     */
+    private TypeMirror getWithParams(TypeElement baseType, TypeMirror parameterType) {
+        final List<? extends TypeMirror> parameters = ((DeclaredType) parameterType).getTypeArguments();
+        return typeUtils.getDeclaredType(baseType, parameters.toArray(new TypeMirror[parameters.size()]));
+    }
+
+    /**
+     * Writes the given class to a respective file in the configuration package
+     *
+     * @param typeSpec the class
+     * @throws IOException if writing fails
+     */
+    void write(TypeSpec typeSpec) throws IOException {
+        JavaFile.builder(CONFIGURATION_PACKAGE, typeSpec)
+                .skipJavaLangImports(true)
+                .indent("    ")
+                .addFileComment("Copyright (c) " + Calendar.getInstance().get(Calendar.YEAR) + "\n\n" +
+                        "Licensed under the Apache License, Version 2.0 (the \"License\");\n" +
+                        "you may not use this file except in compliance with the License.\n\n" +
+                        "http://www.apache.org/licenses/LICENSE-2.0\n\n" +
+                        "Unless required by applicable law or agreed to in writing, software\n" +
+                        "distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
+                        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
+                        "See the License for the specific language governing permissions and\n" +
+                        "limitations under the License.")
+                .build()
+                .writeTo(processingEnv.getFiler());
+    }
+
+    /**
+     * @param method a method
+     * @return annotationSpecs for all relevant annotations on the method
+     */
+    static List<AnnotationSpec> getAnnotations(ExecutableElement method) {
+        return method.getAnnotationMirrors().stream().map(AnnotationSpec::get)
+                .filter(annotationSpec -> !ClassName.get(Name.class).equals(annotationSpec.type)).collect(Collectors.toList());
+    }
+
+    /**
+     * Box the type if it is primitive
+     *
+     * @param type the type to box
+     * @return the boxed type or type, if it is not primitive
+     */
+    TypeMirror getBoxedType(TypeMirror type) {
+        if (type.getKind().isPrimitive()) {
+            return typeUtils.boxedClass((PrimitiveType) type).asType();
+        } else {
+            return type;
+        }
+    }
+
+    /**
+     * Capitalizes the first letter in the given string
+     *
+     * @param word the string
+     * @return the string with a capitalized first letter
+     */
+    String capitalizeFirst(final String word) {
+        return Character.toUpperCase(word.charAt(0)) + word.substring(1);
+    }
+
+    /**
+     * Determines if a method is relevant for ACRAConfiguration generation
+     * A method is not relevant, if it starts with "set", or is annotated with @Hide
+     *
+     * @param method the method to check
+     * @return if the method is relevant
+     */
+    boolean shouldRetain(MethodDefinition method) {
+        return !method.getName().startsWith(PREFIX_SETTER) && !method.getAnnotations().stream().anyMatch(a -> a.type.equals(ANNOTATION_NO_PROPAGATION));
+    }
+
+    /**
+     * @param method a method
+     * @return false if the method is deprecated
+     */
+    boolean isNotDeprecated(ExecutableElement method) {
+        return method.getAnnotation(Deprecated.class) == null;
+    }
+
+    void addClassJavadoc(TypeSpec.Builder builder, TypeElement base) {
+        builder.addJavadoc("Class generated based on {@link $L} ($L)\n", base.getQualifiedName(), dateFormat.format(Calendar.getInstance().getTime()));
+    }
+
+    MethodSpec.Builder addMethodJavadoc(MethodSpec.Builder builder, ExecutableElement base) {
+        final String baseComment = elementUtils.getDocComment(base);
+        if (baseComment == null) return builder;
+        final String name = getName(base);
+        return builder.addJavadoc(baseComment.replaceAll("(\n|^) ", "$1").replaceAll("@return ((.|\n)*)$", "@param " + name + " $1@return this instance\n"));
+    }
+
+    String getName(ExecutableElement method) {
+        final Name name = method.getAnnotation(Name.class);
+        if(name != null){
+            return name.value();
+        }
+        return method.getSimpleName().toString();
+    }
+}
diff --git a/annotations/build.gradle b/annotations/build.gradle
new file mode 100644
index 00000000..d9b5d8da
--- /dev/null
+++ b/annotations/build.gradle
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply plugin: 'java'
+
+sourceCompatibility = "1.6"
+targetCompatibility = "1.6"
diff --git a/annotations/src/main/java/org/acra/annotation/Configuration.java b/annotations/src/main/java/org/acra/annotation/Configuration.java
new file mode 100644
index 00000000..07a0e362
--- /dev/null
+++ b/annotations/src/main/java/org/acra/annotation/Configuration.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The annotation annotated with this will be used as basis for the BaseConfigurationBuilder
+ *
+ * @author F43nd1r
+ * @since 17.03.2017
+ */
+
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.ANNOTATION_TYPE)
+public @interface Configuration {
+}
diff --git a/annotations/src/main/java/org/acra/annotation/ConfigurationBuilder.java b/annotations/src/main/java/org/acra/annotation/ConfigurationBuilder.java
new file mode 100644
index 00000000..157f15c1
--- /dev/null
+++ b/annotations/src/main/java/org/acra/annotation/ConfigurationBuilder.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The class annotated with this will be used as basis for the ACRAConfiguration
+ *
+ * @author F43nd1r
+ * @since 17.03.2017
+ */
+
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.TYPE)
+public @interface ConfigurationBuilder {
+}
diff --git a/annotations/src/main/java/org/acra/annotation/Name.java b/annotations/src/main/java/org/acra/annotation/Name.java
new file mode 100644
index 00000000..a42d7424
--- /dev/null
+++ b/annotations/src/main/java/org/acra/annotation/Name.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * @author F43nd1r
+ * @since 13.04.2017
+ */
+
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.METHOD)
+public @interface Name {
+    String value();
+}
diff --git a/annotations/src/main/java/org/acra/annotation/NoPropagation.java b/annotations/src/main/java/org/acra/annotation/NoPropagation.java
new file mode 100644
index 00000000..866d8bd2
--- /dev/null
+++ b/annotations/src/main/java/org/acra/annotation/NoPropagation.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2017
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Methods annotated with this will not be propagated into the ACRAConfiguration class
+ *
+ * @author F43nd1r
+ * @since 17.03.2017
+ */
+
+@Retention(RetentionPolicy.SOURCE)
+@Target(ElementType.METHOD)
+public @interface NoPropagation {
+}
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..a033afaf
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,29 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:4.4.0"
+        classpath "io.codearte.gradle.nexus:gradle-nexus-staging-plugin:0.9.0"
+        classpath 'net.researchgate:gradle-release:2.5.0'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'io.codearte.nexus-staging'
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
+
+task clean(type: Delete) {
+    delete rootProject.buildDir
+}
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..ceca5566
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,20 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+org.gradle.daemon=true
+org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..13372aef
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..0a66667d
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Feb 17 03:38:03 CET 2017
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 00000000..9d82f789
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..8a0b282a
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index 997b9727..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,209 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.sonatype.oss</groupId>
-        <artifactId>oss-parent</artifactId>
-        <version>7</version>
-    </parent>
-	<groupId>ch.acra</groupId>
-	<artifactId>acra</artifactId>
-	<version>4.6.3-SNAPSHOT</version>
-
-	<name>Application Crash Report for Android</name>
-
-	<description>
-        Publishes a report of an Android application crash to Google docs (or some other end point).
-    </description>
-
-	<url>http://acra.ch</url>
-	<inceptionYear>2010</inceptionYear>
-
-	<licenses>
-		<license>
-			<name>Apache 2</name>
-			<distribution>repo</distribution>
-			<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-			<comments>Go for it.</comments>
-		</license>
-	</licenses>
-
-	<developers>
-		<developer>
-			<id>kevin.gaudin</id>
-			<name>Kevin Gaudin</name>
-			<roles>
-				<role>developer</role>
-			</roles>
-		</developer>
-	</developers>
-
-	<properties>
-		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-		<!--
-			NB ACRA supports back to API3.
-			But in order to compile classes and method that will NOT be used except when the target platform is of sufficient version
-			we need to compile against version 17.
-		-->
-        <android.version>17</android.version>
-	</properties>
-
-	<dependencies>
-        <!--
-            To get this library to compile (with appropriate warnings) in your IDE, you need to point your IDE project SDK
-            to your Android SDK and choose an Android version. This library has been designed to run in Android-3 and newer versions.
-
-            To get this library to compile in Maven you need to have an Android SDK installed and pointed to
-            by an ANDROID_HOME environment variable. This is because we use a bootclasspath during compilation
-            to ensure that only APIs from a specific Android version have been used.
-            NB The AndroidAPI dependency is included below to allow test execution and javadoc generation.
-        -->
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android</artifactId>
-            <version>4.1.1.4</version>
-            <type>jar</type>
-            <scope>test</scope>
-        </dependency>
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<version>4.8.1</version>
-			<type>jar</type>
-			<scope>test</scope>
-		</dependency>
-        <dependency>
-            <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>20080701</version>
-            <scope>provided</scope>
-        </dependency>
-    </dependencies>
-
-	<build>
-		<pluginManagement>
-			<plugins>
-				<plugin>
-					<artifactId>maven-release-plugin</artifactId>
-					<version>2.1</version>
-				</plugin>
-				<plugin>
-					<artifactId>maven-compiler-plugin</artifactId>
-					<version>2.3.2</version>
-				</plugin>
-				<plugin>
-					<artifactId>maven-assembly-plugin</artifactId>
-					<version>2.2.1</version>
-				</plugin>
-				<plugin>
-					<artifactId>maven-javadoc-plugin</artifactId>
-					<version>2.7</version>
-				</plugin>
-				<plugin>
-					<artifactId>maven-source-plugin</artifactId>
-					<version>2.1.2</version>
-				</plugin>
-			</plugins>
-		</pluginManagement>
-
-		<plugins>
-			<plugin>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<configuration>
-					<source>1.6</source>
-					<target>1.6</target>
-					<showWarnings>true</showWarnings>
-                    <compilerArguments>
-                        <bootclasspath>${env.ANDROID_HOME}/platforms/android-${android.version}/android.jar</bootclasspath>
-                    </compilerArguments>
-				</configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-javadoc-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>attach-javadocs</id>
-						<goals>
-							<goal>jar</goal>
-						</goals>
-					</execution>
-				</executions>
-                <configuration>
-					<bootclasspath>${env.ANDROID_HOME}/platforms/android-${android.version}/android.jar</bootclasspath>
-                    <excludePackageNames>org.acra.log,org.acra.util</excludePackageNames>
-                </configuration>
-			</plugin>
-			<plugin>
-				<artifactId>maven-source-plugin</artifactId>
-				<executions>
-					<execution>
-						<id>attach-sources</id>
-						<goals>
-							<goal>jar</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-			<plugin>
-				<artifactId>maven-assembly-plugin</artifactId>
-				<configuration>
-					<descriptors>
-						<descriptor>src/main/assembly/distribution.xml</descriptor>
-					</descriptors>
-					<finalName>${project.build.finalName}</finalName>
-					<appendAssemblyId>false</appendAssemblyId>
-				</configuration>
-				<executions>
-					<execution>
-						<id>make-assembly</id>
-						<phase>package</phase>
-						<goals>
-							<goal>single</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-		<extensions>
-			<extension>
-				<groupId>org.jvnet.wagon-svn</groupId>
-				<artifactId>wagon-svn</artifactId>
-				<version>1.9</version>
-			</extension>
-		</extensions>
-	</build>
-
-	<scm>
-		<connection>scm:git:git@github.com:ACRA/acra.git</connection>
-		<developerConnection>scm:git:git@github.com:ACRA/acra.git</developerConnection>
-		<url>ssh://git@github.com:ACRA/acra.git</url>
-	</scm>
-    <profiles>
-        <profile>
-            <id>release-sign-artifacts</id>
-            <activation>
-                <property>
-                    <name>performRelease</name>
-                    <value>true</value>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-gpg-plugin</artifactId>
-                        <executions>
-                            <execution>
-                                <id>sign-artifacts</id>
-                                <phase>verify</phase>
-                                    <goals>
-                                        <goal>sign</goal>
-                                    </goals>
-                            </execution>
-                        </executions>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..988a1191
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':acra', ':annotationprocessor', ':annotations'
\ No newline at end of file
diff --git a/src/main/java/org/acra/ACRA.java b/src/main/java/org/acra/ACRA.java
deleted file mode 100644
index 04fd7f9f..00000000
--- a/src/main/java/org/acra/ACRA.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import org.acra.annotation.ReportsCrashes;
-import org.acra.log.ACRALog;
-import org.acra.log.HollowLog;
-import org.acra.log.AndroidLogDelegate;
-
-import android.app.Application;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.preference.PreferenceManager;
-
-/**
- * Use this class to initialize the crash reporting feature using
- * {@link #init(Application)} as soon as possible in your {@link Application}
- * subclass {@link Application#onCreate()} method. Configuration items must have
- * been set by using {@link ReportsCrashes} above the declaration of your
- * {@link Application} subclass.
- * 
- * @author Kevin Gaudin
- * 
- */
-public class ACRA {
-
-    public static final boolean DEV_LOGGING = false; // Should be false for
-                                                     // release.
-    public static final String LOG_TAG = ACRA.class.getSimpleName();
-    
-    public static ACRALog log = new AndroidLogDelegate();
-
-    /**
-     * The key of the application default SharedPreference where you can put a
-     * 'true' Boolean value to disable ACRA.
-     */
-    public static final String PREF_DISABLE_ACRA = "acra.disable";
-
-    /**
-     * Alternatively, you can use this key if you prefer your users to have the
-     * checkbox ticked to enable crash reports. If both acra.disable and
-     * acra.enable are set, the value of acra.disable takes over the other.
-     */
-    public static final String PREF_ENABLE_ACRA = "acra.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to disable sending
-     * content of logcat/dropbox. System logs collection is also dependent of
-     * the READ_LOGS permission.
-     */
-    public static final String PREF_ENABLE_SYSTEM_LOGS = "acra.syslog.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to disable sending his
-     * device id. Device ID collection is also dependent of the READ_PHONE_STATE
-     * permission.
-     */
-    public static final String PREF_ENABLE_DEVICE_ID = "acra.deviceid.enable";
-
-    /**
-     * The key of the SharedPreference allowing the user to always include his
-     * email address.
-     */
-    public static final String PREF_USER_EMAIL_ADDRESS = "acra.user.email";
-
-    /**
-     * The key of the SharedPreference allowing the user to automatically accept
-     * sending reports.
-     */
-    public static final String PREF_ALWAYS_ACCEPT = "acra.alwaysaccept";
-
-    /**
-     * The version number of the application the last time ACRA was started.
-     * This is used to determine whether unsent reports should be discarded
-     * because they are old and out of date.
-     */
-    public static final String PREF_LAST_VERSION_NR = "acra.lastVersionNr";
-
-    private static Application mApplication;
-
-    // Accessible via ACRA#getErrorReporter().
-    private static ErrorReporter errorReporterSingleton;
-
-    // NB don't convert to a local field because then it could be garbage
-    // collected and then we would have no PreferenceListener.
-    private static OnSharedPreferenceChangeListener mPrefListener;
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     * 
-     * @param app   Your Application class.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app) {
-        final ReportsCrashes reportsCrashes = app.getClass().getAnnotation(ReportsCrashes.class);
-        if (reportsCrashes == null) {
-            log.e(LOG_TAG,
-                    "ACRA#init called but no ReportsCrashes annotation on Application " + app.getPackageName());
-            return;
-        }
-        init(app, new ACRAConfiguration(reportsCrashes));
-    }
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     *
-     * @param app       Your Application class.
-     * @param config    ACRAConfiguration to manually set up ACRA configuration.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app, ACRAConfiguration config) {
-        init(app, config, true);
-    }
-
-    /**
-     * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
-     * </p>
-     *
-     * @param app       Your Application class.
-     * @param config    ACRAConfiguration to manually set up ACRA configuration.
-     * @param checkReportsOnApplicationStart    Whether to invoke
-     *     ErrorReporter.checkReportsOnApplicationStart(). Apps which adjust the
-     *     ReportSenders should set this to false and call
-     *     checkReportsOnApplicationStart() themselves to prevent a potential
-     *     race with the SendWorker and list of ReportSenders.
-     * @throws IllegalStateException if it is called more than once.
-     */
-    public static void init(Application app, ACRAConfiguration config, boolean checkReportsOnApplicationStart){
-
-        if (mApplication != null) {
-            log.w(LOG_TAG, "ACRA#init called more than once. Won't do anything more.");
-            return;
-        }
-        mApplication = app;
-        
-        if (config == null) {
-            log.e(LOG_TAG, "ACRA#init called but no ACRAConfiguration provided");
-            return;
-        }
-        configProxy = config;
-
-        final SharedPreferences prefs = getACRASharedPreferences();
-
-        try {
-            checkCrashResources(config);
-
-            log.d(LOG_TAG, "ACRA is enabled for " + mApplication.getPackageName() + ", initializing...");
-
-            // Initialize ErrorReporter with all required data
-            final boolean enableAcra = !shouldDisableACRA(prefs);
-            final ErrorReporter errorReporter = new ErrorReporter(mApplication, prefs, enableAcra);
-
-            // Append ReportSenders.
-            errorReporter.setDefaultReportSenders();
-
-            errorReporterSingleton = errorReporter;
-
-            // Check for pending reports
-            if (checkReportsOnApplicationStart) {
-                errorReporter.checkReportsOnApplicationStart();
-            }
-
-        } catch (ACRAConfigurationException e) {
-            log.w(LOG_TAG, "Error : ", e);
-        }
-
-        // We HAVE to keep a reference otherwise the listener could be garbage
-        // collected:
-        // http://stackoverflow.com/questions/2542938/sharedpreferences-onsharedpreferencechangelistener-not-being-called-consistently/3104265#3104265
-        mPrefListener = new OnSharedPreferenceChangeListener() {
-
-            @Override
-            public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
-                if (PREF_DISABLE_ACRA.equals(key) || PREF_ENABLE_ACRA.equals(key)) {
-                    final boolean enableAcra = !shouldDisableACRA(sharedPreferences);
-                    getErrorReporter().setEnabled(enableAcra);
-                }
-            }
-        };
-
-        // This listener has to be set after initAcra is called to avoid a
-        // NPE in ErrorReporter.disable() because
-        // the context could be null at this moment.
-        prefs.registerOnSharedPreferenceChangeListener(mPrefListener);
-    }
-
-    /**
-     * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
-     */
-    public static ErrorReporter getErrorReporter() {
-        if (errorReporterSingleton == null) {
-            throw new IllegalStateException("Cannot access ErrorReporter before ACRA#init");
-        }
-        return errorReporterSingleton;
-    }
-
-    
-
-    /**
-     * Check if the application default shared preferences contains true for the
-     * key "acra.disable", do not activate ACRA. Also checks the alternative
-     * opposite setting "acra.enable" if "acra.disable" is not found.
-     * 
-     * @param prefs
-     *            SharedPreferences to check to see whether ACRA should be
-     *            disabled.
-     * @return true if prefs indicate that ACRA should be disabled.
-     */
-    private static boolean shouldDisableACRA(SharedPreferences prefs) {
-        boolean disableAcra = false;
-        try {
-            final boolean enableAcra = prefs.getBoolean(PREF_ENABLE_ACRA, true);
-            disableAcra = prefs.getBoolean(PREF_DISABLE_ACRA, !enableAcra);
-        } catch (Exception e) {
-            // In case of a ClassCastException
-        }
-        return disableAcra;
-    }
-
-    /**
-     * Checks that mandatory configuration items have been provided.
-     * 
-     * @throws ACRAConfigurationException
-     *             if required values are missing.
-     */
-    static void checkCrashResources(ReportsCrashes conf) throws ACRAConfigurationException {
-        switch (conf.mode()) {
-        case TOAST:
-            if (conf.resToastText() == 0) {
-                throw new ACRAConfigurationException(
-                        "TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case NOTIFICATION:
-            if (conf.resNotifTickerText() == 0 || conf.resNotifTitle() == 0 || conf.resNotifText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
-            }
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case DIALOG:
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-		default:
-			break;
-        }
-    }
-
-    /**
-     * Retrieves the {@link SharedPreferences} instance where user adjustable
-     * settings for ACRA are stored. Default are the Application default
-     * SharedPreferences, but you can provide another SharedPreferences name
-     * with {@link ReportsCrashes#sharedPreferencesName()}.
-     * 
-     * @return The Shared Preferences where ACRA will retrieve its user
-     *         adjustable setting.
-     */
-    public static SharedPreferences getACRASharedPreferences() {
-        ReportsCrashes conf = getConfig();
-        if (!"".equals(conf.sharedPreferencesName())) {
-            return mApplication.getSharedPreferences(conf.sharedPreferencesName(), conf.sharedPreferencesMode());
-        } else {
-            return PreferenceManager.getDefaultSharedPreferences(mApplication);
-        }
-    }
-
-    /**
-     * Provides the current ACRA configuration.
-     * 
-     * @return Current ACRA {@link ReportsCrashes} configuration instance.
-     */
-    public static ACRAConfiguration getConfig() {
-        if (configProxy == null) {
-            if (mApplication == null) {
-                log.w(LOG_TAG,
-                        "Calling ACRA.getConfig() before ACRA.init() gives you an empty configuration instance. You might prefer calling ACRA.getNewDefaultConfig(Application) to get an instance with default values taken from a @ReportsCrashes annotation.");
-            }
-            configProxy = getNewDefaultConfig(mApplication);
-        }
-        return configProxy;
-    }
-
-    /**
-     * @param app       Your Application class.
-     * @return new {@link ACRAConfiguration} instance with values initialized
-     *         from the {@link ReportsCrashes} annotation.
-     */
-    public static ACRAConfiguration getNewDefaultConfig(Application app) {
-        if(app != null) {
-            return new ACRAConfiguration(app.getClass().getAnnotation(ReportsCrashes.class));
-        } else {
-            return new ACRAConfiguration(null);
-        }
-    }
-
-    private static ACRAConfiguration configProxy;
-
-    /**
-     * Returns true if the application is debuggable.
-     * 
-     * @return true if the application is debuggable.
-     */
-    static boolean isDebuggable() {
-        PackageManager pm = mApplication.getPackageManager();
-        try {
-            return ((pm.getApplicationInfo(mApplication.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0);
-        } catch (NameNotFoundException e) {
-            return false;
-        }
-    }
-    
-    static Application getApplication() {
-        return mApplication;
-    }
-
-    public static void setLog(ACRALog log) {
-        if (log == null) {
-            throw new NullPointerException("ACRALog cannot be null");
-        }
-        ACRA.log = log;
-    }
-}
diff --git a/src/main/java/org/acra/ACRAConfiguration.java b/src/main/java/org/acra/ACRAConfiguration.java
deleted file mode 100644
index 666c0f13..00000000
--- a/src/main/java/org/acra/ACRAConfiguration.java
+++ /dev/null
@@ -1,1360 +0,0 @@
-/*
- *  Copyright 2011 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import org.acra.annotation.ReportsCrashes;
-import org.acra.sender.HttpSender;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.acra.util.DefaultHttpsSocketFactoryFactory;
-import org.acra.util.HttpsSocketFactoryFactory;
-import org.acra.util.ReflectionException;
-import org.acra.util.ReflectionHelper;
-
-import java.lang.annotation.Annotation;
-import java.security.KeyStore;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ACRAConstants.*;
-
-/**
- * This class is to be used if you need to apply dynamic settings. This is
- * needed for example when using ACRA in an Android Library Project since ADT
- * v14 where resource ids are not final anymore and can't be passed as
- * annotation parameters values.
- */
-public class ACRAConfiguration implements ReportsCrashes {
-
-    private final ReflectionHelper reflectionHelper = new ReflectionHelper();
-
-    private String[] mAdditionalDropboxTags = null;
-
-    private String[] mAdditionalSharedPreferences = null;
-    private Integer mConnectionTimeout = null;
-    private ReportField[] mCustomReportContent = null;
-    private Boolean mDeleteUnapprovedReportsOnApplicationStart = null;
-    private Boolean mDeleteOldUnsentReportsOnApplicationStart = null;
-    private Integer mDropboxCollectionMinutes = null;
-    private Boolean mForceCloseDialogAfterToast = null;
-    private String mFormUri = null;
-    private String mFormUriBasicAuthLogin = null;
-    private String mFormUriBasicAuthPassword = null;
-    private Boolean mIncludeDropboxSystemTags = null;
-
-    private String[] mLogcatArguments = null;
-    private String mMailTo = null;
-    private Integer mMaxNumberOfRequestRetries = null;
-    private ReportingInteractionMode mMode = null;
-    private ReportsCrashes mReportsCrashes = null;
-    private Class<? extends BaseCrashReportDialog> mReportDialogClass = null;
-
-    private Integer mResDialogPositiveButtonText = null;
-    private Integer mResDialogNegativeButtonText = null;
-    private Integer mResDialogCommentPrompt = null;
-    private Integer mResDialogEmailPrompt = null;
-    private Integer mResDialogIcon = null;
-    private Integer mResDialogOkToast = null;
-    private Integer mResDialogText = null;
-    private Integer mResDialogTitle = null;
-    private Integer mResNotifIcon = null;
-    private Integer mResNotifText = null;
-    private Integer mResNotifTickerText = null;
-    private Integer mResNotifTitle = null;
-    private Integer mResToastText = null;
-    private Integer mSharedPreferenceMode = null;
-    private String mSharedPreferenceName = null;
-    private Integer mSocketTimeout = null;
-    private Boolean mLogcatFilterByPid = null;
-    private Boolean mSendReportsInDevMode = null;
-    private Boolean mSendReportsAtShutdown = null;
-
-    private String[] mExcludeMatchingSharedPreferencesKeys = null;
-    private String[] mExcludeMatchingSettingsKeys = null;
-    private Class mBuildConfigClass;
-    private String mApplicationLogFile = null;
-    private Integer mApplicationLogFileLines = null;
-
-    private Boolean mDisableSSLCertValidation = null;
-    private String mHttpsSocketFactoryFactoryClass = null;
-    private HttpsSocketFactoryFactory mHttpsSocketFactoryFactory;
-    private Method mHttpMethod = null;
-    private Type mReportType = null;
-    private Map<String, String> mHttpHeaders;
-    private KeyStore mKeyStore;
-
-    /**
-     * Set custom HTTP headers to be sent by the provided {@link HttpSender}.
-     * This should be used also by third party senders.
-     * 
-     * @param headers
-     *            A map associating HTTP header names to their values.
-     * @return The updated ACRA configuration
-     */
-    public ACRAConfiguration setHttpHeaders(Map<String, String> headers) {
-        this.mHttpHeaders = headers;
-        return this;
-    }
-
-    /**
-     * Retrieve HTTP headers defined by the application developer. These should
-     * be added to requests sent by any third-party sender (over HTTP of
-     * course).
-     * 
-     * @return A map associating http header names to their values.
-     */
-    public Map<String, String> getHttpHeaders() {
-        return mHttpHeaders;
-    }
-
-    /**
-     * @return List of ReportField that ACRA will provide to the server.
-     */
-    public List<ReportField> getReportFields() {
-        final ReportField[] customReportFields = customReportContent();
-
-        final ReportField[] fieldsList;
-        if (customReportFields.length != 0) {
-            ACRA.log.d(LOG_TAG, "Using custom Report Fields");
-            fieldsList = customReportFields;
-        } else if (mailTo() == null || "".equals(mailTo())) {
-            ACRA.log.d(LOG_TAG, "Using default Report Fields");
-            fieldsList = ACRAConstants.DEFAULT_REPORT_FIELDS;
-        } else {
-            ACRA.log.d(LOG_TAG, "Using default Mail Report Fields");
-            fieldsList = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
-        }
-        return Arrays.asList(fieldsList);
-    }
-
-    /**
-     * @param additionalDropboxTags
-     *            the additionalDropboxTags to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setAdditionalDropboxTags(String[] additionalDropboxTags) {
-        this.mAdditionalDropboxTags = additionalDropboxTags;
-        return this;
-    }
-
-    /**
-     * @param additionalSharedPreferences
-     *            the additionalSharedPreferences to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setAdditionalSharedPreferences(String[] additionalSharedPreferences) {
-        this.mAdditionalSharedPreferences = additionalSharedPreferences;
-        return this;
-    }
-
-    /**
-     * @param connectionTimeout
-     *            the connectionTimeout to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setConnectionTimeout(Integer connectionTimeout) {
-        this.mConnectionTimeout = connectionTimeout;
-        return this;
-    }
-
-    /**
-     * @param customReportContent
-     *            the customReportContent to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setCustomReportContent(ReportField[] customReportContent) {
-        this.mCustomReportContent = customReportContent;
-        return this;
-    }
-
-    /**
-     * @param deleteUnapprovedReportsOnApplicationStart
-     *            the deleteUnapprovedReportsOnApplicationStart to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDeleteUnapprovedReportsOnApplicationStart(Boolean deleteUnapprovedReportsOnApplicationStart) {
-        this.mDeleteUnapprovedReportsOnApplicationStart = deleteUnapprovedReportsOnApplicationStart;
-        return this;
-    }
-
-    /**
-     * @param deleteOldUnsentReportsOnApplicationStart    When to delete old (unsent) reports on startup.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDeleteOldUnsentReportsOnApplicationStart(Boolean deleteOldUnsentReportsOnApplicationStart) {
-        this.mDeleteOldUnsentReportsOnApplicationStart = deleteOldUnsentReportsOnApplicationStart;
-        return this;
-    }
-
-    /**
-     * @param dropboxCollectionMinutes
-     *            the dropboxCollectionMinutes to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDropboxCollectionMinutes(Integer dropboxCollectionMinutes) {
-        this.mDropboxCollectionMinutes = dropboxCollectionMinutes;
-        return this;
-    }
-
-    /**
-     * @param forceCloseDialogAfterToast
-     *            the forceCloseDialogAfterToast to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setForceCloseDialogAfterToast(Boolean forceCloseDialogAfterToast) {
-        this.mForceCloseDialogAfterToast = forceCloseDialogAfterToast;
-        return this;
-    }
-
-    /**
-     * Modify the formUri of your backend server receiving reports. You need to
-     * call {@link ErrorReporter#setDefaultReportSenders()} after modifying this
-     * value if you were not using a formUri before (a mailTo or formKey
-     * instead).
-     * 
-     * @param formUri
-     *            the formUri to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUri(String formUri) {
-        this.mFormUri = formUri;
-        return this;
-    }
-
-    /**
-     * @param formUriBasicAuthLogin
-     *            the formUriBasicAuthLogin to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUriBasicAuthLogin(String formUriBasicAuthLogin) {
-        this.mFormUriBasicAuthLogin = formUriBasicAuthLogin;
-        return this;
-    }
-
-    /**
-     * @param formUriBasicAuthPassword
-     *            the formUriBasicAuthPassword to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUriBasicAuthPassword(String formUriBasicAuthPassword) {
-        this.mFormUriBasicAuthPassword = formUriBasicAuthPassword;
-        return this;
-    }
-
-    /**
-     * @param includeDropboxSystemTags
-     *            the includeDropboxSystemTags to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setIncludeDropboxSystemTags(Boolean includeDropboxSystemTags) {
-        this.mIncludeDropboxSystemTags = includeDropboxSystemTags;
-        return this;
-    }
-
-    /**
-     * @param logcatArguments
-     *            the logcatArguments to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setLogcatArguments(String[] logcatArguments) {
-        this.mLogcatArguments = logcatArguments;
-        return this;
-    }
-
-    /**
-     * Modify the mailTo of the mail account receiving reports. You need to call
-     * {@link ErrorReporter#setDefaultReportSenders()} after modifying this
-     * value if you were not using a formKey before (a formKey or formUri
-     * instead).
-     * 
-     * @param mailTo
-     *            the mailTo to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMailTo(String mailTo) {
-        this.mMailTo = mailTo;
-        return this;
-    }
-
-    /**
-     * @param maxNumberOfRequestRetries
-     *            the maxNumberOfRequestRetries to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMaxNumberOfRequestRetries(Integer maxNumberOfRequestRetries) {
-        this.mMaxNumberOfRequestRetries = maxNumberOfRequestRetries;
-        return this;
-    }
-
-    /**
-     * Change the current {@link ReportingInteractionMode}. You must set
-     * required configuration items first.
-     * 
-     * @param mode
-     *            the new mode to set.
-     * @return The updated ACRA configuration
-     * @throws ACRAConfigurationException
-     *             if a configuration item is missing for this mode.
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMode(ReportingInteractionMode mode) throws ACRAConfigurationException {
-        this.mMode = mode;
-        ACRA.checkCrashResources(this);
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogPositiveButtonText(int resId) {
-        mResDialogPositiveButtonText = resId;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogNegativeButtonText(int resId) {
-        mResDialogNegativeButtonText = resId;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setReportDialogClass(Class<? extends BaseCrashReportDialog> reportDialogClass) {
-        mReportDialogClass = reportDialogClass;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogCommentPrompt()} comes from an Android
-     * Library Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resDialogCommentPrompt()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogCommentPrompt(int resId) {
-        mResDialogCommentPrompt = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogEmailPrompt()} comes from an Android
-     * Library Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resDialogEmailPrompt()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogEmailPrompt(int resId) {
-        mResDialogEmailPrompt = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogIcon()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogIcon()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogIcon(int resId) {
-        mResDialogIcon = resId;
-        return this;
-    }
-
-    /**
-     * Use this method BEFORE if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogOkToast()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogOkToast()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogOkToast(int resId) {
-        mResDialogOkToast = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogText(int resId) {
-        mResDialogText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogTitle()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogTitle()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogTitle(int resId) {
-        mResDialogTitle = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifIcon()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifIcon()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifIcon(int resId) {
-        mResNotifIcon = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifText(int resId) {
-        mResNotifText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifTickerText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resNotifTickerText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifTickerText(int resId) {
-        mResNotifTickerText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifTitle()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifTitle()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifTitle(int resId) {
-        mResNotifTitle = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resToastText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resToastText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResToastText(int resId) {
-        mResToastText = resId;
-        return this;
-    }
-
-    /**
-     * @param sharedPreferenceMode
-     *            the sharedPreferenceMode to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSharedPreferenceMode(Integer sharedPreferenceMode) {
-        this.mSharedPreferenceMode = sharedPreferenceMode;
-        return this;
-    }
-
-    /**
-     * @param sharedPreferenceName
-     *            the sharedPreferenceName to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSharedPreferenceName(String sharedPreferenceName) {
-        this.mSharedPreferenceName = sharedPreferenceName;
-        return this;
-    }
-
-    /**
-     * @param socketTimeout
-     *            the socketTimeout to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSocketTimeout(Integer socketTimeout) {
-        this.mSocketTimeout = socketTimeout;
-        return this;
-    }
-
-    /**
-     * 
-     * @param filterByPid
-     *            true if you want to collect only logcat lines related to your
-     *            application process.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setLogcatFilterByPid(Boolean filterByPid) {
-        mLogcatFilterByPid = filterByPid;
-        return this;
-    }
-
-    /**
-     * 
-     * @param sendReportsInDevMode
-     *            false if you want to disable sending reports in development
-     *            mode. Reports will be sent only on signed applications.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSendReportsInDevMode(Boolean sendReportsInDevMode) {
-        mSendReportsInDevMode = sendReportsInDevMode;
-        return this;
-    }
-
-    /**
-     * 
-     * @param sendReportsAtShutdown
-     *            false if you want to disable sending reports at the time the
-     *            exception is caught. Reports will be sent when the application
-     *            is restarted.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSendReportsAtShutdown(Boolean sendReportsAtShutdown) {
-        mSendReportsAtShutdown = sendReportsAtShutdown;
-        return this;
-    }
-
-    /**
-     * 
-     * @param excludeMatchingSharedPreferencesKeys
-     *            an array of Strings containing regexp defining
-     *            SharedPreferences keys that should be excluded from the data
-     *            collection.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setExcludeMatchingSharedPreferencesKeys(String[] excludeMatchingSharedPreferencesKeys) {
-        mExcludeMatchingSharedPreferencesKeys = excludeMatchingSharedPreferencesKeys;
-        return this;
-    }
-
-    /**
-     * 
-     * @param excludeMatchingSettingsKeys
-     *            an array of Strings containing regexp defining
-     *            Settings.System, Settings.Secure and Settings.Global keys that
-     *            should be excluded from the data collection.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setExcludeMatchingSettingsKeys(String[] excludeMatchingSettingsKeys) {
-        mExcludeMatchingSettingsKeys = excludeMatchingSettingsKeys;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setBuildConfigClass(Class buildConfigClass) {
-        mBuildConfigClass = buildConfigClass;
-        return this;
-    }
-    /**
-     * 
-     * @param applicationLogFile
-     *            The path and file name of your application log file, to be
-     *            used with {@link ReportField#APPLICATION_LOG}.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setApplicationLogFile(String applicationLogFile) {
-        mApplicationLogFile = applicationLogFile;
-        return this;
-    }
-
-    /**
-     * 
-     * @param applicationLogFileLines
-     *            The number of lines of your application log to be collected,
-     *            to be used with {@link ReportField#APPLICATION_LOG} and
-     *            {@link ReportsCrashes#applicationLogFile()}.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setApplicationLogFileLines(int applicationLogFileLines) {
-        mApplicationLogFileLines = applicationLogFileLines;
-        return this;
-    }
-
-    /**
-     * 
-     * @param disableSSLCertValidation
-     *            Set this to true if you need to send reports to a server over
-     *            SSL using a self-signed certificate.
-     * @return The updated ACRA configuration
-     */
-    public ACRAConfiguration setDisableSSLCertValidation(boolean disableSSLCertValidation) {
-        mDisableSSLCertValidation = disableSSLCertValidation;
-        return this;
-    }
-
-    /**
-     * 
-     * @param httpMethod
-     *            The method to be used to send data to the server.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setHttpMethod(Method httpMethod) {
-        mHttpMethod = httpMethod;
-        return this;
-    }
-
-    /**
-     * 
-     * @param type
-     *            The type of content encoding to be used to send data to the
-     *            server.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setReportType(Type type) {
-        mReportType = type;
-        return this;
-    }
-
-    /**
-     * 
-     * @param keyStore
-     *            Set this to the keystore that contains the trusted certificates
-     */
-    @SuppressWarnings( "unused" )
-    public void setKeyStore(KeyStore keyStore) {
-        mKeyStore = keyStore;
-    }
-
-    /**
-     * @param defaults  Defaults with which to initialise this {@link ACRAConfiguration}.
-     */
-    public ACRAConfiguration(ReportsCrashes defaults) {
-        mReportsCrashes = defaults;
-    }
-
-    /**
-     * Empty constructor which sets no defaults.
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration(){
-        this(null);
-    }
-
-    @Override
-    public String[] additionalDropBoxTags() {
-        if (mAdditionalDropboxTags != null) {
-            return mAdditionalDropboxTags;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.additionalDropBoxTags();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public String[] additionalSharedPreferences() {
-        if (mAdditionalSharedPreferences != null) {
-            return mAdditionalSharedPreferences;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.additionalSharedPreferences();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public Class<? extends Annotation> annotationType() {
-        return mReportsCrashes.annotationType();
-    }
-
-    @Override
-    public int connectionTimeout() {
-        if (mConnectionTimeout != null) {
-            return mConnectionTimeout;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.connectionTimeout();
-        }
-
-        return DEFAULT_CONNECTION_TIMEOUT;
-    }
-
-    @Override
-    public ReportField[] customReportContent() {
-        if (mCustomReportContent != null) {
-            return mCustomReportContent;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.customReportContent();
-        }
-
-        return new ReportField[0];
-    }
-
-    @Override
-    public boolean deleteUnapprovedReportsOnApplicationStart() {
-        if (mDeleteUnapprovedReportsOnApplicationStart != null) {
-            return mDeleteUnapprovedReportsOnApplicationStart;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.deleteUnapprovedReportsOnApplicationStart();
-        }
-
-        return DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
-    }
-
-    @Override
-    public boolean deleteOldUnsentReportsOnApplicationStart() {
-        if (mDeleteOldUnsentReportsOnApplicationStart != null) {
-            return mDeleteOldUnsentReportsOnApplicationStart;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.deleteOldUnsentReportsOnApplicationStart();
-        }
-
-        return DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
-    }
-
-    @Override
-    public int dropboxCollectionMinutes() {
-        if (mDropboxCollectionMinutes != null) {
-            return mDropboxCollectionMinutes;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.dropboxCollectionMinutes();
-        }
-
-        return DEFAULT_DROPBOX_COLLECTION_MINUTES;
-    }
-
-    @Override
-    public boolean forceCloseDialogAfterToast() {
-        if (mForceCloseDialogAfterToast != null) {
-            return mForceCloseDialogAfterToast;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.forceCloseDialogAfterToast();
-        }
-
-        return DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
-    }
-
-    @Override
-    public String formUri() {
-        if (mFormUri != null) {
-            return mFormUri;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUri();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public String formUriBasicAuthLogin() {
-        if (mFormUriBasicAuthLogin != null) {
-            return mFormUriBasicAuthLogin;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUriBasicAuthLogin();
-        }
-
-        return NULL_VALUE;
-    }
-
-    @Override
-    public String formUriBasicAuthPassword() {
-        if (mFormUriBasicAuthPassword != null) {
-            return mFormUriBasicAuthPassword;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUriBasicAuthPassword();
-        }
-
-        return NULL_VALUE;
-    }
-
-    @Override
-    public boolean includeDropBoxSystemTags() {
-        if (mIncludeDropboxSystemTags != null) {
-            return mIncludeDropboxSystemTags;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.includeDropBoxSystemTags();
-        }
-
-        return DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
-    }
-
-    @Override
-    public String[] logcatArguments() {
-        if (mLogcatArguments != null) {
-            return mLogcatArguments;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.logcatArguments();
-        }
-
-        return new String[] { "-t", Integer.toString(DEFAULT_LOGCAT_LINES), "-v", "time" };
-    }
-
-    @Override
-    public String mailTo() {
-        if (mMailTo != null) {
-            return mMailTo;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.mailTo();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public int maxNumberOfRequestRetries() {
-        if (mMaxNumberOfRequestRetries != null) {
-            return mMaxNumberOfRequestRetries;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.maxNumberOfRequestRetries();
-        }
-
-        return DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
-    }
-
-    @Override
-    public ReportingInteractionMode mode() {
-        if (mMode != null) {
-            return mMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.mode();
-        }
-
-        return ReportingInteractionMode.SILENT;
-    }
-
-    @Override
-    public int resDialogPositiveButtonText() {
-        if (mResDialogPositiveButtonText != null) {
-            return mResDialogPositiveButtonText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogPositiveButtonText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogNegativeButtonText() {
-        if (mResDialogNegativeButtonText != null) {
-            return mResDialogNegativeButtonText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogNegativeButtonText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogCommentPrompt() {
-        if (mResDialogCommentPrompt != null) {
-            return mResDialogCommentPrompt;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogCommentPrompt();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogEmailPrompt() {
-        if (mResDialogEmailPrompt != null) {
-            return mResDialogEmailPrompt;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogEmailPrompt();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogIcon() {
-        if (mResDialogIcon != null) {
-            return mResDialogIcon;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogIcon();
-        }
-
-        return DEFAULT_DIALOG_ICON;
-    }
-
-    @Override
-    public int resDialogOkToast() {
-        if (mResDialogOkToast != null) {
-            return mResDialogOkToast;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogOkToast();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogText() {
-        if (mResDialogText != null) {
-            return mResDialogText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogTitle() {
-        if (mResDialogTitle != null) {
-            return mResDialogTitle;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogTitle();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifIcon() {
-        if (mResNotifIcon != null) {
-            return mResNotifIcon;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifIcon();
-        }
-
-        return DEFAULT_NOTIFICATION_ICON;
-    }
-
-    @Override
-    public int resNotifText() {
-        if (mResNotifText != null) {
-            return mResNotifText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifTickerText() {
-        if (mResNotifTickerText != null) {
-            return mResNotifTickerText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifTickerText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifTitle() {
-        if (mResNotifTitle != null) {
-            return mResNotifTitle;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifTitle();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resToastText() {
-        if (mResToastText != null) {
-            return mResToastText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resToastText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int sharedPreferencesMode() {
-        if (mSharedPreferenceMode != null) {
-            return mSharedPreferenceMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sharedPreferencesMode();
-        }
-
-        return DEFAULT_SHARED_PREFERENCES_MODE;
-    }
-
-    @Override
-    public String sharedPreferencesName() {
-        if (mSharedPreferenceName != null) {
-            return mSharedPreferenceName;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sharedPreferencesName();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public int socketTimeout() {
-        if (mSocketTimeout != null) {
-            return mSocketTimeout;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.socketTimeout();
-        }
-
-        return DEFAULT_SOCKET_TIMEOUT;
-    }
-
-    @Override
-    public boolean logcatFilterByPid() {
-        if (mLogcatFilterByPid != null) {
-            return mLogcatFilterByPid;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.logcatFilterByPid();
-        }
-
-        return DEFAULT_LOGCAT_FILTER_BY_PID;
-    }
-
-    @Override
-    public boolean sendReportsInDevMode() {
-        if (mSendReportsInDevMode != null) {
-            return mSendReportsInDevMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sendReportsInDevMode();
-        }
-
-        return DEFAULT_SEND_REPORTS_IN_DEV_MODE;
-    }
-
-    @Override
-    public boolean sendReportsAtShutdown() {
-        if (mSendReportsAtShutdown != null) {
-            return mSendReportsAtShutdown;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sendReportsAtShutdown();
-        }
-
-        return DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
-    }
-
-    @Override
-    public String[] excludeMatchingSharedPreferencesKeys() {
-        if (mExcludeMatchingSharedPreferencesKeys != null) {
-            return mExcludeMatchingSharedPreferencesKeys;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.excludeMatchingSharedPreferencesKeys();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public String[] excludeMatchingSettingsKeys() {
-        if (mExcludeMatchingSettingsKeys != null) {
-            return mExcludeMatchingSettingsKeys;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.excludeMatchingSettingsKeys();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    /**
-     * Will return null if no value has been configured.
-     * It is up to clients to construct the recommended default value oof context.getClass().getPackage().getName() + BuildConfig.class
-     */
-    public Class buildConfigClass() {
-        if (mBuildConfigClass != null) {
-            return mBuildConfigClass;
-        }
-
-        if ((mReportsCrashes != null) && (mReportsCrashes.buildConfigClass() != null)) {
-            return mReportsCrashes.buildConfigClass();
-        }
-
-        return null;
-    }
-
-    @Override
-    public String applicationLogFile() {
-        if (mApplicationLogFile != null) {
-            return mApplicationLogFile;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.applicationLogFile();
-        }
-
-        return DEFAULT_APPLICATION_LOGFILE;
-    }
-
-    @Override
-    public int applicationLogFileLines() {
-        if (mApplicationLogFileLines != null) {
-            return mApplicationLogFileLines;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.applicationLogFileLines();
-        }
-
-        return DEFAULT_APPLICATION_LOGFILE_LINES;
-    }
-
-    @Override
-    public boolean disableSSLCertValidation() {
-        if (mDisableSSLCertValidation != null) {
-            return mDisableSSLCertValidation;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.disableSSLCertValidation();
-        }
-
-        return DEFAULT_DISABLE_SSL_CERT_VALIDATION;
-    }
-
-    @Override
-    public String httpsSocketFactoryFactoryClass() {
-        if (mHttpsSocketFactoryFactoryClass != null) {
-            return mHttpsSocketFactoryFactoryClass;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.httpsSocketFactoryFactoryClass();
-        }
-
-        return null;
-    }
-
-
-    @Override
-    public Class<? extends BaseCrashReportDialog> reportDialogClass() {
-        if (mReportDialogClass != null) {
-            return mReportDialogClass;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.reportDialogClass();
-        }
-
-        return CrashReportDialog.class;
-    }
-
-    /**
-     * @param httpsSocketFactoryFactory  HttpsSocketFactoryFactory to set.
-     */
-    @SuppressWarnings( "unused" )
-    public void setHttpsSocketFactoryFactory(HttpsSocketFactoryFactory httpsSocketFactoryFactory) {
-        this.mHttpsSocketFactoryFactory = httpsSocketFactoryFactory;
-    }
-
-    public HttpsSocketFactoryFactory getHttpSocketFactoryFactory() {
-        if (mHttpsSocketFactoryFactory != null) {
-            return mHttpsSocketFactoryFactory;
-        }
-
-        final String httpsSocketFactoryFactoryClass = httpsSocketFactoryFactoryClass();
-        if (httpsSocketFactoryFactoryClass != null) {
-            try {
-                final Object object = reflectionHelper.create(mReportsCrashes.httpsSocketFactoryFactoryClass());
-                if (object instanceof HttpsSocketFactoryFactory) {
-                    mHttpsSocketFactoryFactory = (HttpsSocketFactoryFactory) object;
-                } else {
-                    ACRA.log.w(LOG_TAG, "Using default httpsSocketFactoryFactory - not a HttpSocketFactoryFactory : " + httpsSocketFactoryFactoryClass);
-                }
-            } catch (ReflectionException e) {
-                ACRA.log.w(LOG_TAG, "Using default httpsSocketFactoryFactory - Could not construct : " + httpsSocketFactoryFactoryClass);
-            }
-        }
-
-        // If it's still null then take the default
-        if (mHttpsSocketFactoryFactoryClass == null) {
-            mHttpsSocketFactoryFactory = DefaultHttpsSocketFactoryFactory.INSTANCE;
-        }
-
-        return mHttpsSocketFactoryFactory;
-    }
-
-
-    @Override
-    public Method httpMethod() {
-        if (mHttpMethod != null) {
-            return mHttpMethod;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.httpMethod();
-        }
-
-        return Method.POST;
-    }
-
-    @Override
-    public Type reportType() {
-        if (mReportType != null) {
-            return mReportType;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.reportType();
-        }
-
-        return Type.FORM;
-    }
-
-    public KeyStore keyStore() {
-        if (mKeyStore != null) {
-            return mKeyStore;
-        }
-
-        return null;
-    }
-
-    public static boolean isNull(String aString) {
-        return aString == null || ACRAConstants.NULL_VALUE.equals(aString);
-    }
-
-}
diff --git a/src/main/java/org/acra/BaseCrashReportDialog.java b/src/main/java/org/acra/BaseCrashReportDialog.java
deleted file mode 100644
index bc024dbc..00000000
--- a/src/main/java/org/acra/BaseCrashReportDialog.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package org.acra;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.widget.Toast;
-import org.acra.collector.CrashReportData;
-import org.acra.util.ToastSender;
-
-import java.io.IOException;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.USER_COMMENT;
-import static org.acra.ReportField.USER_EMAIL;
-
-/**
- * Activity which implements the base functionality for a CrashReportDialog
- * Activities which extend from this class can override onCreate() to create a custom view,
- * but they must call super.onCreate() at the beginning of the method.
- *
- * The methods sendCrash(comment, usrEmail) and cancelReports() can be used to send or cancel
- * sending of reports respectively.
- *
- * This Activity will be instantiated with 2 arguments:
- * <ol>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_FILE_NAME}</li>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
- * </ol>
- */
-public abstract class BaseCrashReportDialog extends Activity {
-
-    private String mReportFileName;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ACRA.log.d(LOG_TAG, "CrashReportDialog extras=" + getIntent().getExtras());
-
-        final boolean forceCancel = getIntent().getBooleanExtra(ACRAConstants.EXTRA_FORCE_CANCEL, false);
-        if (forceCancel) {
-            ACRA.log.d(LOG_TAG, "Forced reports deletion.");
-            cancelReports();
-            finish();
-            return;
-        }
-
-        mReportFileName = getIntent().getStringExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME);
-        ACRA.log.d(LOG_TAG, "Opening CrashReportDialog for " + mReportFileName);
-        if (mReportFileName == null) {
-            finish();
-        }
-    }
-
-
-    /**
-     * Cancel any pending crash reports
-     */
-    protected void cancelReports() {
-        ACRA.getErrorReporter().deletePendingNonApprovedReports(false);
-    }
-
-
-    /**
-     * Send crash report given user's comment and email address. If none should be empty strings
-     * @param comment       Comment (may be null) provided by the user.
-     * @param userEmail     Email address (may be null) provided by the client.
-     */
-    protected void sendCrash(String comment, String userEmail) {
-        final CrashReportPersister persister = new CrashReportPersister(getApplicationContext());
-        try {
-            ACRA.log.d(LOG_TAG, "Add user comment to " + mReportFileName);
-            final CrashReportData crashData = persister.load(mReportFileName);
-            crashData.put(USER_COMMENT, comment == null ? "" : comment);
-            crashData.put(USER_EMAIL, userEmail == null ? "" : userEmail);
-            persister.store(crashData, mReportFileName);
-        } catch (IOException e) {
-            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
-        }
-
-        // Start the report sending task
-        ACRA.log.v(LOG_TAG, "About to start SenderWorker from CrashReportDialog");
-        ACRA.getErrorReporter().startSendingReports(false, true);
-
-        // Optional Toast to thank the user
-        final int toastId = ACRA.getConfig().resDialogOkToast();
-        if (toastId != 0) {
-            ToastSender.sendToast(getApplicationContext(), toastId, Toast.LENGTH_LONG);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/CrashReportDialog.java b/src/main/java/org/acra/CrashReportDialog.java
deleted file mode 100644
index c55f5923..00000000
--- a/src/main/java/org/acra/CrashReportDialog.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package org.acra;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.text.InputType;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.ScrollView;
-import android.widget.TextView;
-
-
-/**
- * This is the dialog Activity used by ACRA to get authorization from the user
- * to send reports. Requires android:launchMode="singleInstance" in your
- * AndroidManifest to work properly.
- **/
-public class CrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener, DialogInterface.OnDismissListener {
-
-    private static final String STATE_EMAIL = "email";
-    private static final String STATE_COMMENT = "comment";
-    private EditText userCommentView;
-    private EditText userEmailView;
-
-    AlertDialog mDialog;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
-        final int titleResourceId = ACRA.getConfig().resDialogTitle();
-        if (titleResourceId != 0) {
-            dialogBuilder.setTitle(titleResourceId);
-        }
-        final int iconResourceId = ACRA.getConfig().resDialogIcon();
-        if (iconResourceId != 0) {
-            dialogBuilder.setIcon(iconResourceId);
-        }
-        dialogBuilder.setView(buildCustomView(savedInstanceState));
-        dialogBuilder.setPositiveButton(getText(ACRA.getConfig().resDialogPositiveButtonText()), CrashReportDialog.this);
-        dialogBuilder.setNegativeButton(getText(ACRA.getConfig().resDialogNegativeButtonText()), CrashReportDialog.this);
-
-        mDialog = dialogBuilder.create();
-        mDialog.setCanceledOnTouchOutside(false);
-        mDialog.setOnDismissListener(this);
-        mDialog.show();
-    }
-
-    protected View buildCustomView(Bundle savedInstanceState) {
-        final LinearLayout root = new LinearLayout(this);
-        root.setOrientation(LinearLayout.VERTICAL);
-        root.setPadding(10, 10, 10, 10);
-        root.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        root.setFocusable(true);
-        root.setFocusableInTouchMode(true);
-
-        final ScrollView scroll = new ScrollView(this);
-        root.addView(scroll, new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT, 1.0f));
-        final LinearLayout scrollable = new LinearLayout(this);
-        scrollable.setOrientation(LinearLayout.VERTICAL);
-        scroll.addView(scrollable);
-
-        final TextView text = new TextView(this);
-        final int dialogTextId = ACRA.getConfig().resDialogText();
-        if (dialogTextId != 0) {
-            text.setText(getText(dialogTextId));
-        }
-        scrollable.addView(text);
-
-        // Add an optional prompt for user comments
-        final int commentPromptId = ACRA.getConfig().resDialogCommentPrompt();
-        if (commentPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(commentPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label, new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
-
-            userCommentView = new EditText(this);
-            userCommentView.setLines(2);
-            if (savedInstanceState != null) {
-                String savedValue = savedInstanceState.getString(STATE_COMMENT);
-                if (savedValue != null) {
-                    userCommentView.setText(savedValue);
-                }
-            }
-            scrollable.addView(userCommentView);
-        }
-
-        // Add an optional user email field
-        final int emailPromptId = ACRA.getConfig().resDialogEmailPrompt();
-        if (emailPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(emailPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label);
-
-            userEmailView = new EditText(this);
-            userEmailView.setSingleLine();
-            userEmailView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
-
-            String savedValue = null;
-            if (savedInstanceState != null) {
-                savedValue = savedInstanceState.getString(STATE_EMAIL);
-            }
-            if (savedValue != null) {
-                userEmailView.setText(savedValue);
-            } else {
-                final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-                userEmailView.setText(prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, ""));
-            }
-            scrollable.addView(userEmailView);
-        }
-
-        return root;
-    }
-
-    @Override
-    public void onClick(DialogInterface dialog, int which) {
-        if (which == DialogInterface.BUTTON_POSITIVE) {
-            // Retrieve user comment
-            final String comment = userCommentView != null ? userCommentView.getText().toString() : "";
-
-            // Store the user email
-            final String userEmail;
-            final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-            if (userEmailView != null) {
-                userEmail = userEmailView.getText().toString();
-                final SharedPreferences.Editor prefEditor = prefs.edit();
-                prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS, userEmail);
-                prefEditor.commit();
-            } else {
-                userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "");
-            }
-            sendCrash(comment, userEmail);
-        } else {
-            cancelReports();
-        }
-
-        finish();
-    }
-
-
-    @Override
-    public void onDismiss(DialogInterface dialog) {
-        finish();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (userCommentView != null && userCommentView.getText() != null) {
-            outState.putString(STATE_COMMENT, userCommentView.getText().toString());
-        }
-        if (userEmailView != null && userEmailView.getText() != null) {
-            outState.putString(STATE_EMAIL, userEmailView.getText().toString());
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/CrashReportFinder.java b/src/main/java/org/acra/CrashReportFinder.java
deleted file mode 100644
index 118fb7e0..00000000
--- a/src/main/java/org/acra/CrashReportFinder.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.File;
-import java.io.FilenameFilter;
-
-import android.content.Context;
-
-/**
- * Responsible for retrieving the location of Crash Report files.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-final class CrashReportFinder {
-
-    private final Context context;
-
-    public CrashReportFinder(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * Returns an array containing the names of pending crash report files.
-     *
-     * @return an array containing the names of pending crash report files.
-     */
-    public String[] getCrashReportFiles() {
-        if (context == null) {
-            ACRA.log.e(LOG_TAG, "Trying to get ACRA reports but ACRA is not initialized.");
-            return new String[0];
-        }
-
-        final File dir = context.getFilesDir();
-        if (dir == null) {
-            ACRA.log.w(LOG_TAG, "Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
-            return new String[0];
-        }
-
-        ACRA.log.d(LOG_TAG, "Looking for error files in " + dir.getAbsolutePath());
-
-        // Filter for ".stacktrace" files
-        final FilenameFilter filter = new FilenameFilter() {
-            public boolean accept(File dir, String name) {
-                return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
-            }
-        };
-        final String[] result = dir.list(filter);
-        return (result == null) ? new String[0] : result;
-    }
-}
diff --git a/src/main/java/org/acra/CrashReportPersister.java b/src/main/java/org/acra/CrashReportPersister.java
deleted file mode 100644
index aabcd107..00000000
--- a/src/main/java/org/acra/CrashReportPersister.java
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * java.util.Properties.java modified by Kevin Gaudin to allow usage of enums as keys.
- *
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra;
-
-import android.content.Context;
-
-import org.acra.collector.CollectorUtil;
-import org.acra.collector.CrashReportData;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Reader;
-import java.util.Map;
-
-/**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link java.util.Properties} adapted to extend an
- * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
- * amounts of android time in the generation of a date comment when storing to
- * file.
- */
-final class CrashReportPersister {
-
-    private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;
-    private static final String LINE_SEPARATOR = "\n";
-
-    private final Context context;
-
-    CrashReportPersister(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * Loads properties from the specified {@code InputStream}. The encoding is
-     * ISO8859-1.
-     *
-     * @param fileName  Name of the report file from which to load the CrashData.
-     * @return CrashReportData read from the supplied InputStream.
-     * @throws java.io.IOException if error occurs during reading from the {@code InputStream}.
-     */
-    public CrashReportData load(String fileName) throws IOException {
-
-        final FileInputStream in = context.openFileInput(fileName);
-        if (in == null) {
-            throw new IllegalArgumentException("Invalid crash report fileName : " + fileName);
-        }
-
-        try {
-            final BufferedInputStream bis = new BufferedInputStream(in, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-            return load(new InputStreamReader(bis, "ISO8859-1")); //$NON-NLS-1$
-        } finally {
-            in.close();
-        }
-    }
-
-    /**
-     * Stores the mappings in this Properties to the specified OutputStream,
-     * putting the specified comment at the beginning. The output from this
-     * method is suitable for being read by the load() method.
-     *
-     * @param crashData    CrashReportData to save.
-     * @param fileName      Name of the file to which to store the CrashReportData.
-     * @throws java.io.IOException if the CrashReportData could not be written to the OutputStream.
-     */
-    public void store(CrashReportData crashData, String fileName) throws IOException {
-
-        final OutputStream out = context.openFileOutput(fileName, Context.MODE_PRIVATE);
-        try {
-            final StringBuilder buffer = new StringBuilder(200);
-            final OutputStreamWriter writer = new OutputStreamWriter(out, "ISO8859_1"); //$NON-NLS-1$
-
-            for (final Map.Entry<ReportField, String> entry : crashData.entrySet()) {
-                final String key = entry.getKey().toString();
-                dumpString(buffer, key, true);
-                buffer.append('=');
-                dumpString(buffer, entry.getValue(), false);
-                buffer.append(LINE_SEPARATOR);
-                writer.write(buffer.toString());
-                buffer.setLength(0);
-            }
-            writer.flush();
-        } finally {
-            out.close();
-        }
-    }
-
-    /**
-     * Loads properties from the specified InputStream. The properties are of
-     * the form <code>key=value</code>, one property per line. It may be not
-     * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
-     * according to the following rules:
-     * <ul>
-     * <li>Empty lines are ignored.</li>
-     * <li>Lines starting with either a "#" or a "!" are comment lines and are
-     * ignored.</li>
-     * <li>A backslash at the end of the line escapes the following newline
-     * character ("\r", "\n", "\r\n"). If there's a whitespace after the
-     * backslash it will just escape that whitespace instead of concatenating
-     * the lines. This does not apply to comment lines.</li>
-     * <li>A property line consists of the key, the space between the key and
-     * the value, and the value. The key goes up to the first whitespace, "=" or
-     * ":" that is not escaped. The space between the key and the value contains
-     * either one whitespace, one "=" or one ":" and any number of additional
-     * whitespaces before and after that character. The value starts with the
-     * first character after the space between the key and the value.</li>
-     * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
-     * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
-     * </ul>
-     *
-     * @param reader    Reader from which to read the properties of this CrashReportData.
-     * @return CrashReportData read from the supplied Reader.
-     * @throws java.io.IOException if the properties could not be read.
-     * @since 1.6
-     */
-    private synchronized CrashReportData load(Reader reader) throws IOException {
-        int mode = NONE, unicode = 0, count = 0;
-        char nextChar, buf[] = new char[40];
-        int offset = 0, keyLength = -1, intVal;
-        boolean firstChar = true;
-
-        final CrashReportData crashData = new CrashReportData();
-        final BufferedReader br = new BufferedReader(reader, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-        while (true) {
-            intVal = br.read();
-            if (intVal == -1) {
-                break;
-            }
-            nextChar = (char) intVal;
-
-            if (offset == buf.length) {
-                final char[] newBuf = new char[buf.length * 2];
-                System.arraycopy(buf, 0, newBuf, 0, offset);
-                buf = newBuf;
-            }
-            if (mode == UNICODE) {
-                final int digit = Character.digit(nextChar, 16);
-                if (digit >= 0) {
-                    unicode = (unicode << 4) + digit;
-                    if (++count < 4) {
-                        continue;
-                    }
-                } else if (count <= 4) {
-                    // luni.09=Invalid Unicode sequence: illegal character
-                    throw new IllegalArgumentException("luni.09");
-                }
-                mode = NONE;
-                buf[offset++] = (char) unicode;
-                if (nextChar != '\n' && nextChar != '\u0085') {
-                    continue;
-                }
-            }
-            if (mode == SLASH) {
-                mode = NONE;
-                switch (nextChar) {
-                case '\r':
-                    mode = CONTINUE; // Look for a following \n
-                    continue;
-                case '\u0085':
-                case '\n':
-                    mode = IGNORE; // Ignore whitespace on the next line
-                    continue;
-                case 'b':
-                    nextChar = '\b';
-                    break;
-                case 'f':
-                    nextChar = '\f';
-                    break;
-                case 'n':
-                    nextChar = '\n';
-                    break;
-                case 'r':
-                    nextChar = '\r';
-                    break;
-                case 't':
-                    nextChar = '\t';
-                    break;
-                case 'u':
-                    mode = UNICODE;
-                    unicode = count = 0;
-                    continue;
-                }
-            } else {
-                switch (nextChar) {
-                case '#':
-                case '!':
-                    if (firstChar) {
-                        while (true) {
-                            intVal = br.read();
-                            if (intVal == -1) {
-                                break;
-                            }
-                            nextChar = (char) intVal; // & 0xff
-                                                      // not
-                                                      // required
-                            if (nextChar == '\r' || nextChar == '\n' || nextChar == '\u0085') {
-                                break;
-                            }
-                        }
-                        continue;
-                    }
-                    break;
-                case '\n':
-                    if (mode == CONTINUE) { // Part of a \r\n sequence
-                        mode = IGNORE; // Ignore whitespace on the next line
-                        continue;
-                    }
-                    // fall into the next case
-                case '\u0085':
-                case '\r':
-                    mode = NONE;
-                    firstChar = true;
-                    if (offset > 0 || (offset == 0 && keyLength == 0)) {
-                        if (keyLength == -1) {
-                            keyLength = offset;
-                        }
-                        final String temp = new String(buf, 0, offset);
-                        crashData.put(Enum.valueOf(ReportField.class, temp.substring(0, keyLength)), temp.substring(keyLength));
-                    }
-                    keyLength = -1;
-                    offset = 0;
-                    continue;
-                case '\\':
-                    if (mode == KEY_DONE) {
-                        keyLength = offset;
-                    }
-                    mode = SLASH;
-                    continue;
-                case ':':
-                case '=':
-                    if (keyLength == -1) { // if parsing the key
-                        mode = NONE;
-                        keyLength = offset;
-                        continue;
-                    }
-                    break;
-                }
-                if (Character.isWhitespace(nextChar)) {
-                    if (mode == CONTINUE) {
-                        mode = IGNORE;
-                    }
-                    // if key length == 0 or value length == 0
-                    if (offset == 0 || offset == keyLength || mode == IGNORE) {
-                        continue;
-                    }
-                    if (keyLength == -1) { // if parsing the key
-                        mode = KEY_DONE;
-                        continue;
-                    }
-                }
-                if (mode == IGNORE || mode == CONTINUE) {
-                    mode = NONE;
-                }
-            }
-            firstChar = false;
-            if (mode == KEY_DONE) {
-                keyLength = offset;
-                mode = NONE;
-            }
-            buf[offset++] = nextChar;
-        }
-        if (mode == UNICODE && count <= 4) {
-            // luni.08=Invalid Unicode sequence: expected format \\uxxxx
-            throw new IllegalArgumentException("luni.08");
-        }
-        if (keyLength == -1 && offset > 0) {
-            keyLength = offset;
-        }
-        if (keyLength >= 0) {
-            final String temp = new String(buf, 0, offset);
-            final ReportField key = Enum.valueOf(ReportField.class, temp.substring(0, keyLength));
-            String value = temp.substring(keyLength);
-            if (mode == SLASH) {
-                value += "\u0000";
-            }
-            crashData.put(key, value);
-        }
-
-        CollectorUtil.safeClose(reader);
-
-        return crashData;
-    }
-
-    /**
-     * Constructs a new {@code Properties} object.
-     *
-     * @param buffer    StringBuilder to populate with the supplied property.
-     * @param string    String to append to the buffer.
-     * @param key       Whether the String is a key value or not.
-     */
-    private void dumpString(StringBuilder buffer, String string, boolean key) {
-        int i = 0;
-        if (!key && i < string.length() && string.charAt(i) == ' ') {
-            buffer.append("\\ "); //$NON-NLS-1$
-            i++;
-        }
-
-        for (; i < string.length(); i++) {
-            char ch = string.charAt(i);
-            switch (ch) {
-            case '\t':
-                buffer.append("\\t"); //$NON-NLS-1$
-                break;
-            case '\n':
-                buffer.append("\\n"); //$NON-NLS-1$
-                break;
-            case '\f':
-                buffer.append("\\f"); //$NON-NLS-1$
-                break;
-            case '\r':
-                buffer.append("\\r"); //$NON-NLS-1$
-                break;
-            default:
-                if ("\\#!=:".indexOf(ch) >= 0 || (key && ch == ' ')) {
-                    buffer.append('\\');
-                }
-                if (ch >= ' ' && ch <= '~') {
-                    buffer.append(ch);
-                } else {
-                    final String hex = Integer.toHexString(ch);
-                    buffer.append("\\u"); //$NON-NLS-1$
-                    for (int j = 0; j < 4 - hex.length(); j++) {
-                        buffer.append("0"); //$NON-NLS-1$
-                    }
-                    buffer.append(hex);
-                }
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/acra/ErrorReporter.java b/src/main/java/org/acra/ErrorReporter.java
deleted file mode 100644
index d34e4af0..00000000
--- a/src/main/java/org/acra/ErrorReporter.java
+++ /dev/null
@@ -1,1145 +0,0 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import android.Manifest.permission;
-import android.app.Activity;
-import android.app.Application;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.os.Bundle;
-import android.os.Looper;
-import android.text.format.Time;
-import android.widget.Toast;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.collector.Compatibility;
-import org.acra.collector.ConfigurationCollector;
-import org.acra.collector.CrashReportData;
-import org.acra.collector.CrashReportDataFactory;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ApplicationHelper;
-import org.acra.sender.EmailIntentSender;
-import org.acra.sender.HttpSender;
-import org.acra.sender.ReportSender;
-import org.acra.util.PackageManagerWrapper;
-import org.acra.util.ToastSender;
-
-import java.io.File;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.IS_SILENT;
-
-/**
- * <p>
- * The ErrorReporter is a Singleton object in charge of collecting crash context
- * data and sending crash reports. It registers itself as the Application's
- * Thread default {@link UncaughtExceptionHandler}.
- * </p>
- * <p>
- * When a crash occurs, it collects data of the crash context (device, system,
- * stack trace...) and writes a report file in the application private
- * directory. This report file is then sent:
- * </p>
- * <ul>
- * <li>immediately if {@link ReportsCrashes#mode} is set to
- * {@link ReportingInteractionMode#SILENT} or
- * {@link ReportingInteractionMode#TOAST},</li>
- * <li>on application start if in the previous case the transmission could not
- * technically be made,</li>
- * <li>when the user accepts to send it if {@link ReportsCrashes#mode()} is set
- * to {@link ReportingInteractionMode#NOTIFICATION}.</li>
- * </ul>
- * <p>
- * If an error occurs while sending a report, it is kept for later attempts.
- * </p>
- */
-public class ErrorReporter implements Thread.UncaughtExceptionHandler {
-
-    private boolean enabled = false;
-
-    private final Application mContext;
-    private final SharedPreferences prefs;
-
-    /**
-     * Contains the active {@link ReportSender}s.
-     */
-    private final List<ReportSender> mReportSenders = new ArrayList<ReportSender>();
-
-    private final CrashReportDataFactory crashReportDataFactory;
-
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-
-    // A reference to the system's previous default UncaughtExceptionHandler
-    // kept in order to execute the default exception handling after sending the
-    // report.
-    private final Thread.UncaughtExceptionHandler mDfltExceptionHandler;
-
-    private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(null);
-
-    /**
-     * This is used to wait for the crash toast to end it's display duration
-     * before killing the Application.
-     */
-    private boolean toastWaitEnded = true;
-
-    private static final ExceptionHandlerInitializer NULL_EXCEPTION_HANDLER_INITIALIZER = new ExceptionHandlerInitializer() {
-        @Override
-        public void initializeExceptionHandler(ErrorReporter reporter) {
-        }
-    };
-
-    private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = NULL_EXCEPTION_HANDLER_INITIALIZER;
-
-    /**
-     * Used to create a new (non-cached) PendingIntent each time a new crash occurs.
-     */
-    private static int mNotificationCounter = 0;
-
-    /**
-     * Can only be constructed from within this class.
-     *
-     * @param context
-     *            Context for the application in which ACRA is running.
-     * @param prefs
-     *            SharedPreferences used by ACRA.
-     * @param enabled
-     *            Whether this ErrorReporter should capture Exceptions and
-     *            forward their reports.
-     */
-    ErrorReporter(Application context, SharedPreferences prefs, boolean enabled) {
-
-        this.mContext = context;
-        this.prefs = prefs;
-        this.enabled = enabled;
-
-        // Store the initial Configuration state.
-        // This is expensive to gather, so only do so if we plan to report it.
-        final String initialConfiguration;
-        if (ACRA.getConfig().getReportFields().contains(ReportField.INITIAL_CONFIGURATION)) {
-            initialConfiguration = ConfigurationCollector.collectConfiguration(mContext);
-        } else {
-            initialConfiguration = null;
-        }
-
-        // Sets the application start date.
-        // This will be included in the reports, will be helpful compared to
-        // user_crash date.
-        final Time appStartDate = new Time();
-        appStartDate.setToNow();
-
-        if (Compatibility.getAPILevel() >= Compatibility.VERSION_CODES.ICE_CREAM_SANDWICH) { // ActivityLifecycleCallback
-            // only available for API14+
-            ApplicationHelper.registerActivityLifecycleCallbacks(context, new ActivityLifecycleCallbacksCompat() {
-                @Override
-                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityCreated " + activity.getClass());
-                    if (!(activity instanceof BaseCrashReportDialog)) {
-                        // Ignore CrashReportDialog because we want the last
-                        // application Activity that was started so that we can
-                        // explicitly kill it off.
-                        lastActivityCreated = new WeakReference<Activity>(activity);
-                    }
-                }
-
-                @Override
-                public void onActivityStarted(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityStarted " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityResumed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityResumed " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityPaused(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityPaused " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityStopped(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(LOG_TAG, "onActivityStopped " + activity.getClass());
-                }
-
-                @Override
-                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(LOG_TAG, "onActivitySaveInstanceState " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityDestroyed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(LOG_TAG, "onActivityDestroyed " + activity.getClass());
-                }
-            });
-        }
-
-        crashReportDataFactory = new CrashReportDataFactory(mContext, prefs, appStartDate, initialConfiguration);
-
-        // If mDfltExceptionHandler is not null, initialization is already done.
-        // Don't do it twice to avoid losing the original handler.
-        mDfltExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-        Thread.setDefaultUncaughtExceptionHandler(this);
-    }
-
-    /**
-     * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
-     * @deprecated since 4.3.0 Use {@link org.acra.ACRA#getErrorReporter()}
-     *             instead.
-     */
-    @Deprecated
-    public static ErrorReporter getInstance() {
-        return ACRA.getErrorReporter();
-    }
-
-    /**
-     * Deprecated. Use {@link #putCustomData(String, String)}.
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     */
-    @Deprecated
-    @SuppressWarnings("unused")
-    public void addCustomData(String key, String value) {
-        crashReportDataFactory.putCustomData(key, value);
-    }
-
-    /**
-     * <p>
-     * Use this method to provide the ErrorReporter with data of your running
-     * application. You should call this at several key places in your code the
-     * same way as you would output important debug data in a log file. Only the
-     * latest value is kept for each key (no history of the values is sent in
-     * the report).
-     * </p>
-     * <p>
-     * The key/value pairs will be stored in the GoogleDoc spreadsheet in the
-     * "custom" column, as a text containing a 'key = value' pair on each line.
-     * </p>
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     * @return The previous value for this key if there was one, or null.
-     * @see #removeCustomData(String)
-     * @see #getCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String putCustomData(String key, String value) {
-        return crashReportDataFactory.putCustomData(key, value);
-    }
-
-    /**
-     * <p>
-     * Use this method to perform additional initialization before the
-     * ErrorReporter handles a throwable. This can be used, for example, to put
-     * custom data using {@link #putCustomData(String, String)}, which is not
-     * available immediately after startup. It can be, for example, last 20
-     * requests or something else. The call is thread safe.
-     * </p>
-     * <p>
-     * {@link ExceptionHandlerInitializer#initializeExceptionHandler(ErrorReporter)}
-     * will be executed on the main thread in case of uncaught exception and on
-     * the caller thread of {@link #handleSilentException(Throwable)} or
-     * {@link #handleException(Throwable)}.
-     * </p>
-     * <p>
-     * Example. Add to the {@link Application#onCreate()}:
-     * </p>
-     * 
-     * <pre>
-     * ACRA.getErrorReporter().setExceptionHandlerInitializer(new ExceptionHandlerInitializer() {
-     *     <code>@Override</code> public void initializeExceptionHandler(ErrorReporter reporter) {
-     *         reporter.putCustomData("CUSTOM_ACCUMULATED_DATA_TAG", someAccumulatedData.toString);
-     *     }
-     * });
-     * </pre>
-     * 
-     * @param initializer   The initializer. Can be <code>null</code>.
-     */
-    public void setExceptionHandlerInitializer(ExceptionHandlerInitializer initializer) {
-        exceptionHandlerInitializer = (initializer != null) ? initializer : NULL_EXCEPTION_HANDLER_INITIALIZER;
-    }
-
-    /**
-     * Removes a key/value pair from your reports custom data field.
-     *
-     * @param key
-     *            The key of the data to be removed.
-     * @return The value for this key before removal.
-     * @see #putCustomData(String, String)
-     * @see #getCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String removeCustomData(String key) {
-        return crashReportDataFactory.removeCustomData(key);
-    }
-
-    /**
-     * Removes all key/value pairs from your reports custom data field.
-     */
-    @SuppressWarnings("unused")
-    public void clearCustomData() {
-        crashReportDataFactory.clearCustomData();
-    }
-
-    /**
-     * Gets the current value for a key in your reports custom data field.
-     *
-     * @param key
-     *            The key of the data to be retrieved.
-     * @return The value for this key.
-     * @see #putCustomData(String, String)
-     * @see #removeCustomData(String)
-     */
-    @SuppressWarnings("unused")
-    public String getCustomData(String key) {
-        return crashReportDataFactory.getCustomData(key);
-    }
-
-    /**
-     * Add a {@link ReportSender} to the list of active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} to be added.
-     */
-    public void addReportSender(ReportSender sender) {
-        mReportSenders.add(sender);
-    }
-
-    /**
-     * Remove a specific instance of {@link ReportSender} from the list of
-     * active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} instance to be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSender(ReportSender sender) {
-        mReportSenders.remove(sender);
-    }
-
-    /**
-     * Remove all {@link ReportSender} instances from a specific class.
-     *
-     * @param senderClass
-     *            ReportSender class whose instances should be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSenders(Class<?> senderClass) {
-        if (ReportSender.class.isAssignableFrom(senderClass)) {
-            for (ReportSender sender : mReportSenders) {
-                if (senderClass.isInstance(sender)) {
-                    mReportSenders.remove(sender);
-                }
-            }
-        }
-    }
-
-    /**
-     * Clears the list of active {@link ReportSender}s. You should then call
-     * {@link #addReportSender(ReportSender)} or ACRA will not send any report
-     * anymore.
-     */
-    public void removeAllReportSenders() {
-        mReportSenders.clear();
-    }
-
-    /**
-     * Removes all previously set {@link ReportSender}s and set the given one as
-     * the new {@link ReportSender}.
-     *
-     * @param sender
-     *            ReportSender to set as the sole sender for this ErrorReporter.
-     */
-    public void setReportSender(ReportSender sender) {
-        removeAllReportSenders();
-        addReportSender(sender);
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see
-     * java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang
-     * .Thread, java.lang.Throwable)
-     */
-    @Override
-    public void uncaughtException(Thread t, Throwable e) {
-        try {
-            // If we're not enabled then just pass the Exception on to any
-            // defaultExceptionHandler.
-            if (!enabled) {
-                if (mDfltExceptionHandler != null) {
-                    ACRA.log.e(LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - forwarding uncaught Exception on to default ExceptionHandler");
-                    mDfltExceptionHandler.uncaughtException(t, e);
-                } else {
-                    ACRA.log.e(LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - no default ExceptionHandler");
-                    ACRA.log.e(LOG_TAG,
-                          "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-                }
-                return;
-            }
-
-            ACRA.log.e(LOG_TAG,
-                  "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-            ACRA.log.d(LOG_TAG, "Building report");
-
-            // Generate and send crash report
-            reportBuilder()
-                .uncaughtExceptionThread(t)
-                .exception(e)
-                .endsApplication()
-                .send();
-        } catch (Throwable fatality) {
-            // ACRA failed. Prevent any recursive call to
-            // ACRA.uncaughtException(), let the native reporter do its job.
-            if (mDfltExceptionHandler != null) {
-                mDfltExceptionHandler.uncaughtException(t, e);
-            }
-        }
-    }
-
-    /**
-     * End the application.
-     */
-    private void endApplication(Thread uncaughtExceptionThread, Throwable th) {
-        // TODO It would be better to create an explicit config attribute #letDefaultHandlerEndApplication
-        // as the intent is clearer and would allows you to switch it off for SILENT.
-        final boolean letDefaultHandlerEndApplication = (
-             ACRA.getConfig().mode() == ReportingInteractionMode.SILENT ||
-            (ACRA.getConfig().mode() == ReportingInteractionMode.TOAST && ACRA.getConfig().forceCloseDialogAfterToast())
-        );
-
-        final boolean handlingUncaughtException = uncaughtExceptionThread != null;
-        if (handlingUncaughtException && letDefaultHandlerEndApplication && (mDfltExceptionHandler != null)) {
-            // Let the system default handler do it's job and display the force close dialog.
-            ACRA.log.d(LOG_TAG, "Handing Exception on to default ExceptionHandler");
-            mDfltExceptionHandler.uncaughtException(uncaughtExceptionThread, th);
-        } else {
-            // If ACRA handles user notifications with a Toast or a Notification
-            // the Force Close dialog is one more notification to the user...
-            // We choose to close the process ourselves using the same actions.
-            ACRA.log.e(LOG_TAG, mContext.getPackageName() + " fatal error : " + th.getMessage(), th);
-
-            // Trying to solve
-            // https://github.com/ACRA/acra/issues/42#issuecomment-12134144
-            // Determine the current/last Activity that was started and close
-            // it. Activity#finish (and maybe it's parent too).
-            final Activity lastActivity = lastActivityCreated.get();
-            if (lastActivity != null) {
-                ACRA.log.i(LOG_TAG, "Finishing the last Activity prior to killing the Process");
-                lastActivity.finish();
-                ACRA.log.i(LOG_TAG, "Finished " + lastActivity.getClass());
-                lastActivityCreated.clear();
-            }
-
-            android.os.Process.killProcess(android.os.Process.myPid());
-            System.exit(10);
-        }
-    }
-
-    /**
-     * Send a report for this {@link Throwable} silently (forces the use of
-     * {@link ReportingInteractionMode#SILENT} for this report, whatever is the
-     * mode set for the application. Very useful for tracking difficult defects.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     */
-    public void handleSilentException(Throwable e) {
-        // Mark this report as silent.
-        if (enabled) {
-            reportBuilder()
-                .exception(e)
-                .forceSilent()
-                .send();
-            ACRA.log.d(LOG_TAG, "ACRA sent Silent report.");
-            return;
-        }
-
-        ACRA.log.d(LOG_TAG, "ACRA is disabled. Silent report not sent.");
-    }
-
-    /**
-     * Enable or disable this ErrorReporter. By default it is enabled.
-     *
-     * @param enabled
-     *            Whether this ErrorReporter should capture Exceptions and
-     *            forward them as crash reports.
-     */
-    public void setEnabled(boolean enabled) {
-        ACRA.log.i(LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled") + " for " + mContext.getPackageName());
-        this.enabled = enabled;
-    }
-
-    /**
-     * Starts a Thread to start sending outstanding error reports.
-     *
-     * @param onlySendSilentReports
-     *            If true then only send silent reports.
-     * @param approveReportsFirst
-     *            If true then approve unapproved reports first.
-     * @return SendWorker that will be sending the report.s
-     */
-    SendWorker startSendingReports(boolean onlySendSilentReports, boolean approveReportsFirst) {
-        final SendWorker worker = new SendWorker(mContext, mReportSenders, onlySendSilentReports, approveReportsFirst);
-        worker.start();
-        return worker;
-    }
-
-    /**
-     * Delete all report files stored.
-     */
-    void deletePendingReports() {
-        deletePendingReports(true, true, 0);
-    }
-
-    /**
-     * This method looks for pending reports and does the action required
-     * depending on the interaction mode set.
-     */
-    public void checkReportsOnApplicationStart() {
-
-        if (ACRA.getConfig().deleteOldUnsentReportsOnApplicationStart()) {
-            // Delete any old unsent reports if this is a newer version of the app
-            // than when we last started.
-            final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR, 0);
-            final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(mContext);
-            final PackageInfo packageInfo = packageManagerWrapper.getPackageInfo();
-            if (packageInfo != null) {
-                final boolean newVersion = packageInfo.versionCode > lastVersionNr;
-                if (newVersion) {
-                    deletePendingReports();
-                }
-                final SharedPreferences.Editor prefsEditor = prefs.edit();
-                prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR, packageInfo.versionCode);
-                prefsEditor.commit();
-            }
-        }
-
-        ReportingInteractionMode reportingInteractionMode = ACRA.getConfig().mode();
-
-        if ((reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && ACRA.getConfig().deleteUnapprovedReportsOnApplicationStart()) {
-            // NOTIFICATION or DIALOG mode, and there are unapproved reports to
-            // send (latest notification/dialog has been ignored: neither
-            // accepted
-            // nor refused). The application developer has decided that
-            // these reports should not be renotified ==> destroy them all but
-            // one.
-            deletePendingNonApprovedReports(true);
-        }
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        String[] filesList = reportFinder.getCrashReportFiles();
-
-        if (filesList != null && filesList.length > 0) {
-            // Immediately send reports for SILENT and TOAST modes.
-            // Immediately send reports in NOTIFICATION mode only if they are
-            // all silent or approved.
-            // If there is still one unapproved report in NOTIFICATION mode,
-            // notify it.
-            // If there are unapproved reports in DIALOG mode, show the dialog
-
-
-            final boolean onlySilentOrApprovedReports = containsOnlySilentOrApprovedReports(filesList);
-
-            if (reportingInteractionMode == ReportingInteractionMode.SILENT
-                || reportingInteractionMode == ReportingInteractionMode.TOAST
-                || (onlySilentOrApprovedReports && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG))) {
-
-                if (reportingInteractionMode == ReportingInteractionMode.TOAST && !onlySilentOrApprovedReports) {
-                    // Display the Toast in TOAST mode only if there are
-                    // non-silent reports.
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                }
-
-                ACRA.log.v(LOG_TAG, "About to start ReportSenderWorker from #checkReportOnApplicationStart");
-                startSendingReports(false, false);
-            }
-
-        }
-    }
-
-    /**
-     * Delete all pending non approved reports.
-     *
-     * @param keepOne
-     *            If you need to keep the latest report, set this to true.
-     */
-    void deletePendingNonApprovedReports(boolean keepOne) {
-        // In NOTIFICATION AND DIALOG mode, we have to keep the latest report
-        // which
-        // has been written before killing the app.
-        final int nbReportsToKeep = keepOne ? 1 : 0;
-        deletePendingReports(false, true, nbReportsToKeep);
-    }
-
-    /**
-     * Send a report for a {@link Throwable} with the reporting interaction mode
-     * configured by the developer.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     * @param endApplication
-     *            Set this to true if you want the application to be ended after
-     *            sending the report.
-     */
-    @SuppressWarnings("unused")
-    public void handleException(Throwable e, boolean endApplication) {
-        final ReportBuilder builder = reportBuilder()
-            .exception(e);
-        if (endApplication) {
-            builder.endsApplication();
-        }
-        builder.send();
-    }
-
-    /**
-     * Send a report for a {@link Throwable} with the reporting interaction mode
-     * configured by the developer, the application is then killed and restarted
-     * by the system.
-     *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
-     */
-    @SuppressWarnings("unused")
-    public void handleException(Throwable e) {
-        reportBuilder()
-            .exception(e)
-            .send();
-    }
-
-    /**
-     * Creates a new crash report builder
-     *
-     * @return the newly created {@code ReportBuilder}
-     */
-    public ReportBuilder reportBuilder() {
-        return new ReportBuilder();
-    }
-
-    /**
-     * Helps manage
-     */
-    private static class TimeHelper {
-
-        private Long initialTimeMillis;
-
-        public void setInitialTimeMillis(long initialTimeMillis) {
-            this.initialTimeMillis = initialTimeMillis;
-        }
-
-        /**
-         * @return 0 if the initial time has yet to be set otherwise returns the difference between now and the initial time.
-         */
-        public long getElapsedTime() {
-            return (initialTimeMillis == null) ? 0 : System.currentTimeMillis() - initialTimeMillis;
-        }
-    }
-
-    /**
-     * Try to send a report, if an error occurs stores a report file for a later
-     * attempt.
-     *
-     * @param reportBuilder The report builder used to assemble the report
-     */
-    private void report(final ReportBuilder reportBuilder) {
-
-        if (!enabled) {
-            return;
-        }
-
-        try {
-            exceptionHandlerInitializer.initializeExceptionHandler(this);
-        } catch (Exception exceptionInRunnable) {
-            ACRA.log.d(LOG_TAG, "Failed to initlize " + exceptionHandlerInitializer + " from #handleException");
-        }
-
-        boolean sendOnlySilentReports = false;
-        ReportingInteractionMode reportingInteractionMode;
-        if (!reportBuilder.mForceSilent) {
-            // No interaction mode defined, we assume it has been set during
-            // ACRA.initACRA()
-            reportingInteractionMode = ACRA.getConfig().mode();
-        } else {
-            reportingInteractionMode = ReportingInteractionMode.SILENT;
-
-            // An interaction mode has been provided. If ACRA has been
-            // initialized with a non SILENT mode and this mode is overridden
-            // with SILENT, then we have to send only reports which have been
-            // explicitly declared as silent via handleSilentException().
-            if (ACRA.getConfig().mode() != ReportingInteractionMode.SILENT) {
-                sendOnlySilentReports = true;
-            }
-        }
-
-        final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
-            || (ACRA.getConfig().resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
-
-        final TimeHelper sentToastTimeMillis = new TimeHelper();
-        if (shouldDisplayToast) {
-            new Thread() {
-
-                /*
-                 * (non-Javadoc)
-                 *
-                 * @see java.lang.Thread#run()
-                 */
-                @Override
-                public void run() {
-                    Looper.prepare();
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                    sentToastTimeMillis.setInitialTimeMillis(System.currentTimeMillis());
-                    Looper.loop();
-                }
-
-            }.start();
-
-            // We will wait a few seconds at the end of the method to be sure
-            // that the Toast can be read by the user.
-        }
-
-        final CrashReportData crashReportData = crashReportDataFactory.createCrashData(reportBuilder.mMessage,
-                                                                                       reportBuilder.mException, reportBuilder.mCustomData,
-                                                                                       reportBuilder.mForceSilent, reportBuilder.mUncaughtExceptionThread);
-
-        // Always write the report file
-
-        final String reportFileName = getReportFileName(crashReportData);
-        saveCrashReportFile(reportFileName, crashReportData);
-
-        if (reportBuilder.mEndsApplication && !ACRA.getConfig().sendReportsAtShutdown()) {
-            endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-        }
-
-        SendWorker sender = null;
-
-        if (reportingInteractionMode == ReportingInteractionMode.SILENT
-            || reportingInteractionMode == ReportingInteractionMode.TOAST
-            || prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
-
-            // Approve and then send reports now
-            ACRA.log.d(LOG_TAG, "About to start ReportSenderWorker from #handleException");
-            sender = startSendingReports(sendOnlySilentReports, true);
-            if ((reportingInteractionMode == ReportingInteractionMode.SILENT) && !reportBuilder.mEndsApplication) {
-                // Report is being sent silently and the application is not ending.
-                // So no need to wait around for the sender to complete.
-                return;
-            }
-
-        } else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
-            ACRA.log.d(LOG_TAG, "Creating Notification.");
-            createNotification(reportFileName, reportBuilder);
-        }
-
-        toastWaitEnded = true;
-        if (shouldDisplayToast) {
-            // A toast is being displayed, we have to wait for its end before doing anything else.
-            // The toastWaitEnded flag will be checked before any other operation.
-            toastWaitEnded = false;
-            new Thread() {
-
-                @Override
-                public void run() {
-                    ACRA.log.d(LOG_TAG, "Waiting for " + ACRAConstants.TOAST_WAIT_DURATION
-                        + " millis from " + sentToastTimeMillis.initialTimeMillis
-                        + " currentMillis=" + System.currentTimeMillis());
-                    while (sentToastTimeMillis.getElapsedTime() < ACRAConstants.TOAST_WAIT_DURATION) {
-                        try {
-                            // Wait a bit to let the user read the toast
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            ACRA.log.d(LOG_TAG, "Interrupted while waiting for Toast to end.", e1);
-                        }
-                    }
-                    toastWaitEnded = true;
-                }
-            }.start();
-        }
-
-        // Start an AsyncTask waiting for the end of the sender.
-        // Once sent, call endApplication() if reportBuilder.mEndApplication
-        final SendWorker worker = sender;
-        final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
-
-        new Thread() {
-
-            @Override
-            public void run() {
-                // We have to wait for the toast display to be completed.
-                ACRA.log.d(LOG_TAG, "Waiting for Toast");
-                while (!toastWaitEnded) {
-                    try {
-                        Thread.sleep(100);
-                    } catch (InterruptedException e1) {
-                        ACRA.log.d(LOG_TAG, "Error : ", e1);
-                    }
-                }
-                ACRA.log.d(LOG_TAG, "Finished waiting for Toast");
-
-                // We have to wait for the worker job to be completed.
-                if (worker != null) {
-                    ACRA.log.d(LOG_TAG, "Waiting for Worker");
-                    while (worker.isAlive()) {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            ACRA.log.d(LOG_TAG, "Error : ", e1);
-                        }
-                    }
-                    ACRA.log.d(LOG_TAG, "Finished waiting for Worker");
-                }
-
-                if (showDirectDialog) {
-                    // Create a new activity task with the confirmation dialog.
-                    // This new task will be persisted on application restart
-                    // right after its death.
-                    ACRA.log.d(LOG_TAG, "Creating CrashReportDialog for " + reportFileName);
-                    final Intent dialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    mContext.startActivity(dialogIntent);
-                }
-
-                ACRA.log.d(LOG_TAG, "Wait for Toast + worker ended. Kill Application ? " + reportBuilder.mEndsApplication);
-
-                if (reportBuilder.mEndsApplication) {
-                    endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-                }
-            }
-        }.start();
-    }
-
-    /**
-     * Creates an Intent that can be used to create and show a CrashReportDialog.
-     *
-     * @param reportFileName    Name of the error report to display in the crash report dialog.
-     * @param reportBuilder     ReportBuilder containing the details of the crash.
-     */
-    private Intent createCrashReportDialogIntent(String reportFileName, ReportBuilder reportBuilder) {
-        ACRA.log.d(LOG_TAG, "Creating DialogIntent for " + reportFileName + " exception=" + reportBuilder.mException);
-        final Intent dialogIntent = new Intent(mContext, ACRA.getConfig().reportDialogClass());
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME, reportFileName);
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION, reportBuilder.mException);
-        return dialogIntent;
-    }
-
-
-    /**
-     * Creates a status bar notification.
-     *
-     * The action triggered when the notification is selected is to start the
-     * {@link CrashReportDialog} Activity.
-     *
-     * @param reportFileName Name of the report file to send.
-     */
-    private void createNotification(String reportFileName, ReportBuilder reportBuilder) {
-
-        final NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        final ReportsCrashes conf = ACRA.getConfig();
-
-        // Default notification icon is the warning symbol
-        final int icon = conf.resNotifIcon();
-
-        final CharSequence tickerText = mContext.getText(conf.resNotifTickerText());
-        final long when = System.currentTimeMillis();
-        final Notification notification = new Notification(icon, tickerText, when);
-
-        final CharSequence contentTitle = mContext.getText(conf.resNotifTitle());
-        final CharSequence contentText = mContext.getText(conf.resNotifText());
-
-        ACRA.log.d(LOG_TAG, "Creating Notification for " + reportFileName);
-        final Intent crashReportDialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        final PendingIntent contentIntent = PendingIntent.getActivity(mContext, mNotificationCounter++, crashReportDialogIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-
-        notification.setLatestEventInfo(mContext, contentTitle, contentText, contentIntent);
-        notification.flags = notification.flags | Notification.FLAG_AUTO_CANCEL;
-
-        // The deleteIntent is invoked when the user swipes away the Notification.
-        // In this case we invoke the CrashReportDialog with EXTRA_FORCE_CANCEL==true
-        // which will cause BaseCrashReportDialog to clear the crash report and finish itself.
-        final Intent deleteIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
-        notification.deleteIntent = PendingIntent.getActivity(mContext, -1, deleteIntent, 0);
-
-        // Send new notification
-        notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
-    }
-
-    private String getReportFileName(CrashReportData crashData) {
-        final Time now = new Time();
-        now.setToNow();
-        final long timestamp = now.toMillis(false);
-        final String isSilent = crashData.getProperty(IS_SILENT);
-        return "" + timestamp + (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
-            + ACRAConstants.REPORTFILE_EXTENSION;
-    }
-
-    /**
-     * When a report can't be sent, it is saved here in a file in the root of
-     * the application private directory.
-     *
-     * @param fileName
-     *            In a few rare cases, we write the report again with additional
-     *            data (user comment for example). In such cases, you can
-     *            provide the already existing file name here to overwrite the
-     *            report file. If null, a new file report will be generated
-     * @param crashData
-     *            Can be used to save an alternative (or previously generated)
-     *            report data. Used to store again a report with the addition of
-     *            user comment. If null, the default current crash data are
-     *            used.
-     */
-    private void saveCrashReportFile(String fileName, CrashReportData crashData) {
-        try {
-            ACRA.log.d(LOG_TAG, "Writing crash report file " + fileName + ".");
-            final CrashReportPersister persister = new CrashReportPersister(mContext);
-            persister.store(crashData, fileName);
-        } catch (Exception e) {
-            ACRA.log.e(LOG_TAG, "An error occurred while writing the report file...", e);
-        }
-    }
-
-    /**
-     * Delete pending reports.
-     *
-     * @param deleteApprovedReports
-     *            Set to true to delete approved and silent reports.
-     * @param deleteNonApprovedReports
-     *            Set to true to delete non approved/silent reports.
-     * @param nbOfLatestToKeep
-     *            Number of pending reports to retain.
-     */
-    private void deletePendingReports(boolean deleteApprovedReports, boolean deleteNonApprovedReports,
-                                      int nbOfLatestToKeep) {
-        // TODO Check logic and instances where nbOfLatestToKeep = X, because
-        // that might stop us from deleting any reports.
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        final String[] filesList = reportFinder.getCrashReportFiles();
-        Arrays.sort(filesList);
-        for (int iFile = 0; iFile < filesList.length - nbOfLatestToKeep; iFile++) {
-            final String fileName = filesList[iFile];
-            final boolean isReportApproved = fileNameParser.isApproved(fileName);
-            if ((isReportApproved && deleteApprovedReports) || (!isReportApproved && deleteNonApprovedReports)) {
-                final File fileToDelete = new File(mContext.getFilesDir(), fileName);
-                ACRA.log.d(LOG_TAG, "Deleting file " + fileName);
-                if (!fileToDelete.delete()) {
-                    ACRA.log.e(LOG_TAG, "Could not delete report : " + fileToDelete);
-                }
-            }
-        }
-    }
-
-    /**
-     * Checks if an array of reports files names contains only silent or
-     * approved reports.
-     *
-     * @param reportFileNames
-     *            Array of report locations to check.
-     * @return True if there are only silent or approved reports. False if there
-     *         is at least one non-approved report.
-     */
-    private boolean containsOnlySilentOrApprovedReports(String[] reportFileNames) {
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Sets relevant ReportSenders to the ErrorReporter, replacing any
-     * previously set ReportSender.
-     */
-    public void setDefaultReportSenders() {
-        ReportsCrashes conf = ACRA.getConfig();
-        Application mApplication = ACRA.getApplication();
-        removeAllReportSenders();
-
-        // Try to send by mail. If a mailTo address is provided, do not add
-        // other senders.
-        if (!"".equals(conf.mailTo())) {
-            ACRA.log.w(LOG_TAG, mApplication.getPackageName() + " reports will be sent by email (if accepted by user).");
-            setReportSender(new EmailIntentSender(mApplication));
-            return;
-        }
-
-        final PackageManagerWrapper pm = new PackageManagerWrapper(mApplication);
-        if (!pm.hasPermission(permission.INTERNET)) {
-            // NB If the PackageManager has died then this will erroneously log
-            // the error that the App doesn't have Internet (even though it
-            // does).
-            // I think that is a small price to pay to ensure that ACRA doesn't
-            // crash if the PackageManager has died.
-            ACRA.log.e(LOG_TAG,
-                  mApplication.getPackageName()
-                      + " should be granted permission "
-                      + permission.INTERNET
-                      + " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @ReportsCrashes(mailTo=\"your.account@domain.com\"");
-            return;
-        }
-
-        // If formUri is set, instantiate a sender for a generic HTTP POST form
-        // with default mapping.
-        if (conf.formUri() != null && !"".equals(conf.formUri())) {
-            setReportSender(new HttpSender(ACRA.getConfig().httpMethod(), ACRA.getConfig().reportType(), null));
-        }
-    }
-
-    /**
-     * Fluent API used to assemble the different options used for a crash report
-     */
-    public final class ReportBuilder {
-
-        private String mMessage;
-        private Thread mUncaughtExceptionThread;
-        private Throwable mException;
-        private Map<String, String> mCustomData;
-
-        private boolean mForceSilent = false;
-        private boolean mEndsApplication = false;
-
-        /**
-         * Set the error message to be reported.
-         *
-         * @param msg the error message
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder message(String msg) {
-            mMessage = msg;
-            return this;
-        }
-
-        /**
-         * Sets the Thread on which an uncaught Exception occurred.
-         *
-         * @param thread    Thread on which an uncaught Exception occurred.
-         * @return the updated {@code ReportBuilder}
-         */
-        private ReportBuilder uncaughtExceptionThread(Thread thread) {
-            mUncaughtExceptionThread = thread;
-            return this;
-        }
-
-        /**
-         * Set the stack trace to be reported
-         *
-         * @param e The exception that should be associated with this report
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder exception(Throwable e) {
-            mException = e;
-            return this;
-        }
-
-        private void initCustomData() {
-            if (mCustomData ==  null)
-                mCustomData = new HashMap<String, String>();
-        }
-
-        /**
-         * Sets additional values to be added to {@code CUSTOM_DATA}. Values
-         * specified here take precedence over globally specified custom data.
-         *
-         * @param customData a map of custom key-values to be attached to the report
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(Map<String, String> customData) {
-            initCustomData();
-            mCustomData.putAll(customData);
-            return this;
-        }
-
-        /**
-         * Sets an additional value to be added to {@code CUSTOM_DATA}. The value
-         * specified here takes precedence over globally specified custom data.
-         *
-         * @param key the key identifying the custom data
-         * @param value the value for the custom data entry
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(String key, String value) {
-            initCustomData();
-            mCustomData.put(key, value);
-            return this;
-        }
-
-        /**
-         * Forces the report to be sent silently, ignoring the default interaction mode set in the config
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder forceSilent() {
-            mForceSilent = true;
-            return this;
-        }
-
-        /**
-         * Ends the application after sending the crash report
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder endsApplication() {
-            mEndsApplication = true;
-            return this;
-        }
-
-        /**
-         * Assembles and sends the crash report
-         */
-        public void send() {
-            if (mMessage == null && mException == null) {
-                mMessage = "Report requested by developer";
-            }
-            report(this);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/SendWorker.java b/src/main/java/org/acra/SendWorker.java
deleted file mode 100644
index 1a90da9a..00000000
--- a/src/main/java/org/acra/SendWorker.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-
-import org.acra.collector.CrashReportData;
-import org.acra.sender.ReportSender;
-import org.acra.sender.ReportSenderException;
-
-import android.content.Context;
-
-/**
- * Checks and send reports on a separate Thread.
- * 
- * @author Kevin Gaudin
- */
-final class SendWorker extends Thread {
-
-    private final Context context;
-    private final boolean sendOnlySilentReports;
-    private final boolean approvePendingReports;
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-    private final List<ReportSender> reportSenders;
-
-    /**
-     * Creates a new {@link SendWorker} to try sending pending reports.
-     * 
-     * @param context
-     *            ApplicationContext in which the reports are being sent.
-     * @param reportSenders
-     *            List of ReportSender to use to send the crash reports.
-     * @param sendOnlySilentReports
-     *            If set to true, will send only reports which have been
-     *            explicitly declared as silent by the application developer.
-     * @param approvePendingReports
-     *            if this endWorker should approve pending reports before
-     *            sending any reports.
-     */
-    public SendWorker(Context context, List<ReportSender> reportSenders, boolean sendOnlySilentReports,
-            boolean approvePendingReports) {
-        this.context = context;
-        this.reportSenders = reportSenders;
-        this.sendOnlySilentReports = sendOnlySilentReports;
-        this.approvePendingReports = approvePendingReports;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.lang.Thread#run()
-     */
-    @Override
-    public void run() {
-        if (approvePendingReports) {
-            approvePendingReports();
-        }
-        checkAndSendReports(context, sendOnlySilentReports);
-    }
-
-    /**
-     * Flag all pending reports as "approved" by the user. These reports can be
-     * sent.
-     */
-    private void approvePendingReports() {
-        ACRA.log.d(LOG_TAG, "Mark all pending reports as approved.");
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFileNames = reportFinder.getCrashReportFiles();
-
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                final File reportFile = new File(context.getFilesDir(), reportFileName);
-
-                // TODO look into how this could cause a file to go from
-                // -approved.stacktrace to -approved-approved.stacktrace
-                final String newName = reportFileName.replace(ACRAConstants.REPORTFILE_EXTENSION,
-                        ACRAConstants.APPROVED_SUFFIX + ACRAConstants.REPORTFILE_EXTENSION);
-
-                // TODO Look into whether rename is atomic. Is there a better
-                // option?
-                final File newFile = new File(context.getFilesDir(), newName);
-                if (!reportFile.renameTo(newFile)) {
-                    ACRA.log.e(LOG_TAG, "Could not rename approved report from " + reportFile + " to " + newFile);
-                }
-            }
-        }
-    }
-
-    /**
-     * Send pending reports.
-     * 
-     * @param context
-     *            The application context.
-     * @param sendOnlySilentReports
-     *            Send only reports explicitly declared as SILENT by the
-     *            developer (sent via
-     *            {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    private void checkAndSendReports(Context context, boolean sendOnlySilentReports) {
-        ACRA.log.d(LOG_TAG, "#checkAndSendReports - start");
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFiles = reportFinder.getCrashReportFiles();
-        Arrays.sort(reportFiles);
-
-        int reportsSentCount = 0;
-
-        for (String curFileName : reportFiles) {
-            if (sendOnlySilentReports && !fileNameParser.isSilent(curFileName)) {
-                continue;
-            }
-
-            if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
-                break; // send only a few reports to avoid overloading the
-                       // network
-            }
-
-            ACRA.log.i(LOG_TAG, "Sending file " + curFileName);
-            try {
-                final CrashReportPersister persister = new CrashReportPersister(context);
-                final CrashReportData previousCrashReport = persister.load(curFileName);
-                sendCrashReport(previousCrashReport);
-                deleteFile(context, curFileName);
-            } catch (RuntimeException e) {
-                ACRA.log.e(LOG_TAG, "Failed to send crash reports for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something really unexpected happened. Don't try to
-                       // send any more reports now.
-            } catch (IOException e) {
-                ACRA.log.e(LOG_TAG, "Failed to load crash report for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something unexpected happened when reading the crash
-                       // report. Don't try to send any more reports now.
-            } catch (ReportSenderException e) {
-                ACRA.log.e(LOG_TAG, "Failed to send crash report for " + curFileName, e);
-                // An issue occurred while sending this report but we can still try to
-                // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS
-                // so there's not much to fear about overloading a failing server.
-            }
-            reportsSentCount++;
-        }
-        ACRA.log.d(LOG_TAG, "#checkAndSendReports - finish");
-    }
-
-    /**
-     * Sends the report with all configured ReportSenders. If at least one
-     * sender completed its job, the report is considered as sent and will not
-     * be sent again for failing senders.
-     * 
-     * @param errorContent
-     *            Crash data.
-     * @throws ReportSenderException
-     *             if unable to send the crash report.
-     */
-    private void sendCrashReport(CrashReportData errorContent) throws ReportSenderException {
-        if (!ACRA.isDebuggable() || ACRA.getConfig().sendReportsInDevMode()) {
-            boolean sentAtLeastOnce = false;
-            ReportSenderException sendFailure = null;
-            String failedSender = null;
-            for (ReportSender sender : reportSenders) {
-                try {
-                    ACRA.log.d(LOG_TAG, "Sending report using " + sender.getClass().getName());
-                    sender.send(context, errorContent);
-                    ACRA.log.d(LOG_TAG, "Sent report using " + sender.getClass().getName());
-
-                    // If at least one sender worked, don't re-send the report later.
-                    sentAtLeastOnce = true;
-                } catch (ReportSenderException e) {
-                    sendFailure = e;
-                    failedSender = sender.getClass().getName();
-                }
-            }
-
-            if (sendFailure != null) {
-                // We had some failure
-                if (!sentAtLeastOnce) {
-                    throw sendFailure; // Don't log here because we aren't dealing with the Exception here.
-                } else {
-                    ACRA.log.w(LOG_TAG,
-                               "ReportSender of class "
-                                   + failedSender
-                                   + " failed but other senders completed their task. ACRA will not send this report again.");
-                }
-            }
-        }
-    }
-
-    private void deleteFile(Context context, String fileName) {
-        final boolean deleted = context.deleteFile(fileName);
-        if (!deleted) {
-            ACRA.log.w(LOG_TAG, "Could not delete error report : " + fileName);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/collector/CollectorUtil.java b/src/main/java/org/acra/collector/CollectorUtil.java
deleted file mode 100644
index fa0f8b5b..00000000
--- a/src/main/java/org/acra/collector/CollectorUtil.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.acra.collector;
-
-import java.io.IOException;
-import java.io.Reader;
-
-public final class CollectorUtil {
-
-    /**
-     * Closes a Reader.
-     *
-     * @param reader    Reader to close. If reader is null then method just returns.
-     */
-    public static void safeClose(Reader reader) {
-    	if (reader == null) return;
-    	
-        try {
-            reader.close();
-        } catch (IOException e) {
-            // We made out best effort to release this resource. Nothing more we can do.
-        }
-    }
-}
diff --git a/src/main/java/org/acra/collector/Compatibility.java b/src/main/java/org/acra/collector/Compatibility.java
deleted file mode 100644
index 66d94a40..00000000
--- a/src/main/java/org/acra/collector/Compatibility.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import android.content.Context;
-import android.os.Build;
-
-import java.lang.reflect.Field;
-
-/**
- * Utility class containing methods enabling backward compatibility.
- * 
- * @author Normal
- * 
- */
-public final class Compatibility {
-
-    public class VERSION_CODES {
-        public final static int ECLAIR = 5;
-        public final static int FROYO = 8;
-        public final static int ICE_CREAM_SANDWICH = 14;
-        public final static int JELLY_BEAN = 16;
-        public final static int JELLY_BEAN_MR1 = 17;
-        public final static int LOLLIPOP = 21;
-    }
-
-    /**
-     * Retrieves Android SDK API level using the best possible method.
-     * 
-     * @return The Android SDK API int level.
-     */
-    public static int getAPILevel() {
-        int apiLevel;
-        try {
-            // This field has been added in Android 1.6
-            final Field SDK_INT = Build.VERSION.class.getField("SDK_INT");
-            apiLevel = SDK_INT.getInt(null);
-        } catch (SecurityException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (NoSuchFieldException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalArgumentException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalAccessException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        }
-
-        return apiLevel;
-    }
-
-    /**
-     * Retrieve the DropBoxManager service name using reflection API.
-     *
-     * @return Name of the DropBox service regardless of Android version.
-     * @throws NoSuchFieldException if the field DROPBOX_SERVICE doesn't exist.
-     * @throws IllegalAccessException if the DROPBOX_SERVICE field is inaccessible.
-     */
-    public static String getDropBoxServiceName() throws NoSuchFieldException, IllegalAccessException {
-        final Field serviceName = Context.class.getField("DROPBOX_SERVICE");
-        if (serviceName != null) {
-            return (String) serviceName.get(null);
-        }
-        return null;
-    }
-}
diff --git a/src/main/java/org/acra/collector/CrashReportDataFactory.java b/src/main/java/org/acra/collector/CrashReportDataFactory.java
deleted file mode 100644
index 368820b7..00000000
--- a/src/main/java/org/acra/collector/CrashReportDataFactory.java
+++ /dev/null
@@ -1,598 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.*;
-
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-
-import android.text.TextUtils;
-import org.acra.ACRA;
-import org.acra.ReportField;
-import org.acra.util.Installation;
-import org.acra.util.PackageManagerWrapper;
-import org.acra.util.ReportUtils;
-
-import android.Manifest;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.os.Environment;
-import android.text.format.Time;
-
-/**
- * Responsible for creating the CrashReportData for an Exception.
- * <p>
- * Also responsible for holding the custom data to send with each report.
- * </p>
- *
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class CrashReportDataFactory {
-
-    private final Context context;
-    private final SharedPreferences prefs;
-    private final Map<String, String> customParameters = new LinkedHashMap<String, String>();
-    private final Time appStartDate;
-    private final String initialConfiguration;
-
-    public CrashReportDataFactory(Context context, SharedPreferences prefs, Time appStartDate,
-                                  String initialConfiguration) {
-        this.context = context;
-        this.prefs = prefs;
-        this.appStartDate = appStartDate;
-        this.initialConfiguration = initialConfiguration;
-    }
-
-    /**
-     * <p>
-     * Adds a custom key and value to be reported with the generated
-     * CashReportData.
-     * </p>
-     * <p>
-     * The key/value pairs will be stored in the "custom" column, as a text
-     * containing one 'key = value' pair on each line.
-     * </p>
-     *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
-     * @return The previous value for this key if there was one, or null.
-     */
-    public String putCustomData(String key, String value) {
-        return customParameters.put(key, value);
-    }
-
-    /**
-     * Removes a key/value pair from the custom data field.
-     *
-     * @param key
-     *            The key of the data to be removed.
-     * @return The value for this key before removal.
-     */
-    public String removeCustomData(String key) {
-        return customParameters.remove(key);
-    }
-
-    /**
-     * Removes all key/value pairs from the custom data field.
-     */
-    public void clearCustomData() {
-        customParameters.clear();
-    }
-
-    /**
-     * Gets the current value for a key in the custom data field.
-     *
-     * @param key
-     *            The key of the data to be retrieved.
-     * @return The value for this key.
-     */
-    public String getCustomData(String key) {
-        return customParameters.get(key);
-    }
-
-    /**
-     * Collects crash data.
-     *
-     * @param msg
-     *            A message to be associated with the crash report.
-     * @param th
-     *            Throwable that caused the crash.
-     * @param customData
-     *            Custom key/value pairs to be associated with the crash report.
-     * @param isSilentReport
-     *            Whether to report this report as being sent silently.
-     * @param brokenThread  Thread on which the error occurred.
-     * @return CrashReportData representing the current state of the application
-     *         at the instant of the Exception.
-     */
-    public CrashReportData createCrashData(String msg, Throwable th, Map<String, String> customData, boolean isSilentReport, Thread brokenThread) {
-        final CrashReportData crashReportData = new CrashReportData();
-        try {
-            final List<ReportField> crashReportFields = ACRA.getConfig().getReportFields();
-
-            // Make every entry here bullet proof and move any slightly dodgy
-            // ones to the end.
-            // This ensures that we collect as much info as possible before
-            // something crashes the collection process.
-
-            try {
-                crashReportData.put(STACK_TRACE, getStackTrace(msg, th));
-            } catch (RuntimeException e){
-                ACRA.log.e(LOG_TAG, "Error while retrieving STACK_TRACE data", e);
-            }
-
-            try {
-                crashReportData.put(ReportField.USER_APP_START_DATE, ReportUtils.getTimeString(appStartDate));
-            } catch (RuntimeException e){
-                ACRA.log.e(LOG_TAG, "Error while retrieving USER_APP_START_DATE data", e);
-            }
-
-            if (isSilentReport) {
-                crashReportData.put(IS_SILENT, "true");
-            }
-
-            // StackTrace hash
-            if (crashReportFields.contains(STACK_TRACE_HASH)) {
-                try {
-                    crashReportData.put(ReportField.STACK_TRACE_HASH, getStackTraceHash(th));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving STACK_TRACE_HASH data", e);
-                }
-            }
-
-            // Generate report uuid
-            if (crashReportFields.contains(REPORT_ID)) {
-                try {
-                    crashReportData.put(ReportField.REPORT_ID, UUID.randomUUID().toString());
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving REPORT_ID data", e);
-                }
-            }
-
-            // Installation unique ID
-            if (crashReportFields.contains(INSTALLATION_ID)) {
-                try {
-                    crashReportData.put(INSTALLATION_ID, Installation.id(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving INSTALLATION_ID data", e);
-                }
-            }
-
-            // Device Configuration when crashing
-            if (crashReportFields.contains(INITIAL_CONFIGURATION)) {
-                try {
-                    crashReportData.put(INITIAL_CONFIGURATION, initialConfiguration);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving INITIAL_CONFIGURATION data", e);
-                }
-            }
-            if (crashReportFields.contains(CRASH_CONFIGURATION)) {
-                try {
-                    crashReportData.put(CRASH_CONFIGURATION, ConfigurationCollector.collectConfiguration(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving CRASH_CONFIGURATION data", e);
-                }
-            }
-
-            // Collect meminfo
-            if (!(th instanceof OutOfMemoryError) && crashReportFields.contains(DUMPSYS_MEMINFO)) {
-                try {
-                    crashReportData.put(DUMPSYS_MEMINFO, DumpSysCollector.collectMemInfo());
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving DUMPSYS_MEMINFO data", e);
-                }
-            }
-
-            // Application Package name
-            if (crashReportFields.contains(PACKAGE_NAME)) {
-                try {
-                    crashReportData.put(PACKAGE_NAME, context.getPackageName());
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving PACKAGE_NAME data", e);
-                }
-            }
-
-            // Android OS Build details
-            if (crashReportFields.contains(BUILD)) {
-                try {
-                    crashReportData.put(BUILD, ReflectionCollector.collectConstants(android.os.Build.class) + ReflectionCollector.collectConstants(android.os.Build.VERSION.class, "VERSION"));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving BUILD data", e);
-                }
-            }
-
-            // Device model
-            if (crashReportFields.contains(PHONE_MODEL)) {
-                try {
-                    crashReportData.put(PHONE_MODEL, android.os.Build.MODEL);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving PHONE_MODEL data", e);
-                }
-            }
-            // Android version
-            if (crashReportFields.contains(ANDROID_VERSION)) {
-                try {
-                    crashReportData.put(ANDROID_VERSION, android.os.Build.VERSION.RELEASE);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving ANDROID_VERSION data", e);
-                }
-            }
-
-            // Device Brand (manufacturer)
-            if (crashReportFields.contains(BRAND)) {
-                try {
-                    crashReportData.put(BRAND, android.os.Build.BRAND);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving BRAND data", e);
-                }
-            }
-            if (crashReportFields.contains(PRODUCT)) {
-                try {
-                    crashReportData.put(PRODUCT, android.os.Build.PRODUCT);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving PRODUCT data", e);
-                }
-            }
-
-            // Device Memory
-            if (crashReportFields.contains(TOTAL_MEM_SIZE)) {
-                try {
-                    crashReportData.put(TOTAL_MEM_SIZE, Long.toString(ReportUtils.getTotalInternalMemorySize()));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving TOTAL_MEM_SIZE data", e);
-                }
-            }
-            if (crashReportFields.contains(AVAILABLE_MEM_SIZE)) {
-                try {
-                    crashReportData.put(AVAILABLE_MEM_SIZE, Long.toString(ReportUtils.getAvailableInternalMemorySize()));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving AVAILABLE_MEM_SIZE data", e);
-                }
-            }
-
-            // Application file path
-            if (crashReportFields.contains(FILE_PATH)) {
-                try {
-                    crashReportData.put(FILE_PATH, ReportUtils.getApplicationFilePath(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving FILE_PATH data", e);
-                }
-            }
-
-            // Main display details
-            if (crashReportFields.contains(DISPLAY)) {
-                try {
-                    crashReportData.put(DISPLAY, DisplayManagerCollector.collectDisplays(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving DISPLAY data", e);
-                }
-            }
-
-            // User crash date with local timezone
-            if (crashReportFields.contains(USER_CRASH_DATE)) {
-                try {
-                    final Time curDate = new Time();
-                    curDate.setToNow();
-                    crashReportData.put(USER_CRASH_DATE, ReportUtils.getTimeString(curDate));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving USER_CRASH_DATE data", e);
-                }
-            }
-
-            // Add custom info, they are all stored in a single field
-            if (crashReportFields.contains(CUSTOM_DATA)) {
-                try {
-                    crashReportData.put(CUSTOM_DATA, createCustomInfoString(customData));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving CUSTOM_DATA data", e);
-                }
-            }
-
-            if (crashReportFields.contains(BUILD_CONFIG)) {
-                try {
-                    final Class buildConfigClass = getBuildConfigClass();
-                    crashReportData.put(BUILD_CONFIG, ReflectionCollector.collectConstants(buildConfigClass));
-                } catch (ClassNotFoundException e) {
-                    // We have already logged this when we had the name of the class that wasn't found.
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving BUILD_CONFIG data", e);
-                }
-            }
-
-            // Add user email address, if set in the app's preferences
-            if (crashReportFields.contains(USER_EMAIL)) {
-                try {
-                    crashReportData.put(USER_EMAIL, prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "N/A"));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving USER_EMAIL data", e);
-                }
-            }
-
-            // Device features
-            if (crashReportFields.contains(DEVICE_FEATURES)) {
-                try {
-                    crashReportData.put(DEVICE_FEATURES, DeviceFeaturesCollector.getFeatures(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving DEVICE_FEATURES data", e);
-                }
-            }
-
-            // Environment (External storage state)
-            if (crashReportFields.contains(ENVIRONMENT)) {
-                try {
-                    crashReportData.put(ENVIRONMENT, ReflectionCollector.collectStaticGettersResults(Environment.class));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving ENVIRONMENT data", e);
-                }
-            }
-
-            // System settings
-            if (crashReportFields.contains(SETTINGS_SYSTEM)) {
-                try {
-                    crashReportData.put(SETTINGS_SYSTEM, SettingsCollector.collectSystemSettings(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving SETTINGS_SYSTEM data", e);
-                }
-            }
-
-            // Secure settings
-            if (crashReportFields.contains(SETTINGS_SECURE)) {
-                try {
-                    crashReportData.put(SETTINGS_SECURE, SettingsCollector.collectSecureSettings(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving SETTINGS_SECURE data", e);
-                }
-            }
-
-            // Global settings
-            if (crashReportFields.contains(SETTINGS_GLOBAL)) {
-                try {
-
-                    crashReportData.put(SETTINGS_GLOBAL, SettingsCollector.collectGlobalSettings(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving SETTINGS_GLOBAL data", e);
-                }
-            }
-
-            // SharedPreferences
-            if (crashReportFields.contains(SHARED_PREFERENCES)) {
-                try {
-                    crashReportData.put(SHARED_PREFERENCES, SharedPreferencesCollector.collect(context));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving SHARED_PREFERENCES data", e);
-                }
-            }
-
-            // Now get all the crash data that relies on the PackageManager
-            // (which may or may not be here).
-            final PackageManagerWrapper pm = new PackageManagerWrapper(context);
-
-            try {
-                final PackageInfo pi = pm.getPackageInfo();
-                if (pi != null) {
-                    // Application Version
-                    if (crashReportFields.contains(APP_VERSION_CODE)) {
-                        crashReportData.put(APP_VERSION_CODE, Integer.toString(pi.versionCode));
-                    }
-                    if (crashReportFields.contains(APP_VERSION_NAME)) {
-                        crashReportData.put(APP_VERSION_NAME, pi.versionName != null ? pi.versionName : "not set");
-                    }
-                } else {
-                    // Could not retrieve package info...
-                    crashReportData.put(APP_VERSION_NAME, "Package info unavailable");
-                }
-            } catch (RuntimeException e){
-                ACRA.log.e(LOG_TAG, "Error while retrieving APP_VERSION_CODE and APP_VERSION_NAME data", e);
-            }
-
-            // Retrieve UDID(IMEI) if permission is available
-            if (crashReportFields.contains(DEVICE_ID) && prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
-                && pm.hasPermission(Manifest.permission.READ_PHONE_STATE)) {
-                try {
-                    final String deviceId = ReportUtils.getDeviceId(context);
-                    if (deviceId != null) {
-                        crashReportData.put(DEVICE_ID, deviceId);
-                    }
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving DEVICE_ID data", e);
-                }
-            }
-
-            // Collect DropBox and logcat
-            // Before JellyBean, this required the READ_LOGS permission
-            // Since JellyBean, READ_LOGS is not granted to third-party apps anymore for security reasons.
-            // Though, we can call logcat without any permission and still get traces related to our app.
-            final boolean hasReadLogsPermission = pm.hasPermission(Manifest.permission.READ_LOGS) || (Compatibility.getAPILevel() >= Compatibility.VERSION_CODES.JELLY_BEAN);
-            if (prefs.getBoolean(ACRA.PREF_ENABLE_SYSTEM_LOGS, true) && hasReadLogsPermission) {
-                ACRA.log.i(LOG_TAG, "READ_LOGS granted! ACRA can include LogCat and DropBox data.");
-                if (crashReportFields.contains(LOGCAT)) {
-                    try {
-                        crashReportData.put(LOGCAT, LogCatCollector.collectLogCat(null));
-                    } catch (RuntimeException e){
-                        ACRA.log.e(LOG_TAG, "Error while retrieving LOGCAT data", e);
-                    }
-                }
-                if (crashReportFields.contains(EVENTSLOG)) {
-                    try {
-                        crashReportData.put(EVENTSLOG, LogCatCollector.collectLogCat("events"));
-                    } catch (RuntimeException e){
-                        ACRA.log.e(LOG_TAG, "Error while retrieving EVENTSLOG data", e);
-                    }
-                }
-                if (crashReportFields.contains(RADIOLOG)) {
-                    try {
-                        crashReportData.put(RADIOLOG, LogCatCollector.collectLogCat("radio"));
-                    } catch (RuntimeException e){
-                        ACRA.log.e(LOG_TAG, "Error while retrieving RADIOLOG data", e);
-                    }
-                }
-                if (crashReportFields.contains(DROPBOX)) {
-                    try {
-                        crashReportData.put(DROPBOX,
-                                            DropBoxCollector.read(context, ACRA.getConfig().additionalDropBoxTags()));
-                    } catch (RuntimeException e){
-                        ACRA.log.e(LOG_TAG, "Error while retrieving DROPBOX data", e);
-                    }
-                }
-            } else {
-                ACRA.log.i(LOG_TAG, "READ_LOGS not allowed. ACRA will not include LogCat and DropBox data.");
-            }
-
-            // Application specific log file
-            if (crashReportFields.contains(APPLICATION_LOG)) {
-                try {
-                    final String logFile = LogFileCollector.collectLogFile(context,
-                                                                           ACRA.getConfig().applicationLogFile(),
-                                                                           ACRA.getConfig().applicationLogFileLines());
-                    crashReportData.put(APPLICATION_LOG, logFile);
-                } catch (IOException e) {
-                    ACRA.log.e(LOG_TAG, "Error while reading application log file " + ACRA.getConfig().applicationLogFile(), e);
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving APPLICATION_LOG data", e);
-
-                }
-            }
-
-            // Media Codecs list
-            if (crashReportFields.contains(MEDIA_CODEC_LIST)) {
-                try {
-                    crashReportData.put(MEDIA_CODEC_LIST, MediaCodecListCollector.collecMediaCodecList());
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving MEDIA_CODEC_LIST data", e);
-                }
-            }
-
-            // Failing thread details
-            if (crashReportFields.contains(THREAD_DETAILS)) {
-                try {
-                    crashReportData.put(THREAD_DETAILS, ThreadCollector.collect(brokenThread));
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving THREAD_DETAILS data", e);
-                }
-            }
-
-            // IP addresses
-            if (crashReportFields.contains(USER_IP)) {
-                try {
-                    crashReportData.put(USER_IP, ReportUtils.getLocalIpAddress());
-                } catch (RuntimeException e){
-                    ACRA.log.e(LOG_TAG, "Error while retrieving USER_IP data", e);
-                }
-            }
-
-        } catch (RuntimeException e) {
-            ACRA.log.e(LOG_TAG, "Error while retrieving crash data", e);
-        }
-
-        return crashReportData;
-    }
-
-    /**
-     * Generates the string which is posted in the single custom data field in
-     * the GoogleDocs Form.
-     *
-     * @return A string with a 'key = value' pair on each line.
-     */
-    private String createCustomInfoString(Map<String, String> reportCustomData) {
-        Map<String, String> params = customParameters;
-
-        if (reportCustomData != null) {
-            params = new HashMap<String, String>(params);
-            params.putAll(reportCustomData);
-        }
-
-        final StringBuilder customInfo = new StringBuilder();
-        for (final String currentKey : params.keySet()) {
-            String currentVal = params.get(currentKey);
-            customInfo.append(currentKey);
-            customInfo.append(" = ");
-            // We need to escape new lines in values or they are transformed into new
-            // custom fields. => let's replace all '\n' with "\\n"
-            if(currentVal != null) {
-                currentVal = currentVal.replaceAll("\n", "\\\\n");
-            }
-            customInfo.append(currentVal);
-            customInfo.append("\n");
-        }
-        return customInfo.toString();
-    }
-
-    private String getStackTrace(String msg, Throwable th) {
-        final Writer result = new StringWriter();
-        final PrintWriter printWriter = new PrintWriter(result);
-
-        if (msg != null && !TextUtils.isEmpty(msg))
-            printWriter.println(msg);
-
-        // If the exception was thrown in a background thread inside
-        // AsyncTask, then the actual exception can be found with getCause
-        Throwable cause = th;
-        while (cause != null) {
-            cause.printStackTrace(printWriter);
-            cause = cause.getCause();
-        }
-        final String stacktraceAsString = result.toString();
-        printWriter.close();
-
-        return stacktraceAsString;
-    }
-
-    private String getStackTraceHash(Throwable th) {
-        final StringBuilder res = new StringBuilder();
-        Throwable cause = th;
-        while (cause != null) {
-            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
-            for (final StackTraceElement e : stackTraceElements) {
-                res.append(e.getClassName());
-                res.append(e.getMethodName());
-            }
-            cause = cause.getCause();
-        }
-
-        return Integer.toHexString(res.toString().hashCode());
-    }
-
-    private Class<?> getBuildConfigClass() throws ClassNotFoundException {
-        final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
-        if ((configuredBuildConfig != null) && !configuredBuildConfig.equals(Object.class)) {
-            // If set via annotations or programatically then it will have a real value,
-            // otherwise it will be Object.class (annotation default) or null (explicit programmatic).
-            return configuredBuildConfig;
-        }
-
-        final String className = context.getClass().getPackage().getName() + ".BuildConfig";
-        try {
-            return Class.forName(className);
-        } catch (ClassNotFoundException e) {
-            ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
-            throw e;
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java b/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
deleted file mode 100644
index f483d5ef..00000000
--- a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.lang.reflect.Method;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-
-import org.acra.ACRA;
-
-/**
- * Features declared as available on the device. Available only with API level > 5.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class DeviceFeaturesCollector {
-
-    public static String getFeatures(Context ctx) {
-
-        if (Compatibility.getAPILevel() < Compatibility.VERSION_CODES.ECLAIR) {
-            return "Data available only with API Level >= 5";
-        }
-
-        final StringBuilder result = new StringBuilder();
-        try {
-            final PackageManager pm = ctx.getPackageManager();
-            final Method getSystemAvailableFeatures = PackageManager.class.getMethod("getSystemAvailableFeatures", (Class[]) null);
-            final Object[] features = (Object[]) getSystemAvailableFeatures.invoke(pm);
-            for (final Object feature : features) {
-                final String featureName = (String) feature.getClass().getField("name").get(feature);
-                if(featureName != null) {
-                    result.append(featureName);
-                } else {
-                    final Method getGlEsVersion = feature.getClass().getMethod("getGlEsVersion", (Class[]) null);
-                    final String glEsVersion = (String) getGlEsVersion.invoke(feature);
-                    result.append("glEsVersion = ");
-                    result.append(glEsVersion);
-                }
-                result.append("\n");
-            }
-        } catch (Throwable e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceFeatures for " + ctx.getPackageName(), e);
-            result.append("Could not retrieve data: ");
-            result.append(e.getMessage());
-        }
-
-        return result.toString();
-    }
-}
diff --git a/src/main/java/org/acra/collector/DisplayManagerCollector.java b/src/main/java/org/acra/collector/DisplayManagerCollector.java
deleted file mode 100644
index d9593271..00000000
--- a/src/main/java/org/acra/collector/DisplayManagerCollector.java
+++ /dev/null
@@ -1,299 +0,0 @@
-package org.acra.collector;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.util.DisplayMetrics;
-import android.util.SparseArray;
-import android.view.Display;
-import android.view.Surface;
-import android.view.WindowManager;
-
-import static org.acra.ACRA.LOG_TAG;
-
-final class DisplayManagerCollector {
-
-    final static SparseArray<String> mFlagsNames = new SparseArray<String>();
-    final static SparseArray<String> mDensities = new SparseArray<String>();
-
-    public static String collectDisplays(Context ctx) {
-        Display[] displays = null;
-        final StringBuilder result = new StringBuilder();
-
-        if (Compatibility.getAPILevel() < Compatibility.VERSION_CODES.JELLY_BEAN_MR1) {
-            // Before Android 4.2, there was a single display available from the
-            // window manager
-            final WindowManager windowManager = (WindowManager) ctx
-                    .getSystemService(android.content.Context.WINDOW_SERVICE);
-            displays = new Display[1];
-            displays[0] = windowManager.getDefaultDisplay();
-        } else {
-            // Since Android 4.2, we can fetch multiple displays with the
-            // DisplayManager.
-            try {
-                Object displayManager = ctx.getSystemService((String) (ctx.getClass().getField("DISPLAY_SERVICE")
-                        .get(null)));
-                Method getDisplays = displayManager.getClass().getMethod("getDisplays");
-                displays = (Display[]) getDisplays.invoke(displayManager);
-            } catch (IllegalArgumentException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (SecurityException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (IllegalAccessException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchFieldException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchMethodException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (InvocationTargetException e) {
-                ACRA.log.w(LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            }
-        }
-
-        for (Display display : displays) {
-            result.append(collectDisplayData(display));
-        }
-
-        return result.toString();
-    }
-
-    private static Object collectDisplayData(Display display) {
-        final DisplayMetrics metrics = new DisplayMetrics();
-        display.getMetrics(metrics);
-
-        final StringBuilder result = new StringBuilder();
-
-        result.append(collectCurrentSizeRange(display));
-        result.append(collectFlags(display));
-        result.append(display.getDisplayId()).append(".height=").append(display.getHeight()).append('\n');
-        result.append(collectMetrics(display, "getMetrics"));
-        result.append(collectName(display));
-        result.append(display.getDisplayId()).append(".orientation=").append(display.getOrientation()).append('\n');
-        result.append(display.getDisplayId()).append(".pixelFormat=").append(display.getPixelFormat()).append('\n');
-        result.append(collectMetrics(display, "getRealMetrics"));
-        result.append(collectSize(display, "getRealSize"));
-        result.append(collectRectSize(display));
-        result.append(display.getDisplayId()).append(".refreshRate=").append(display.getRefreshRate()).append('\n');
-        result.append(collectRotation(display));
-        result.append(collectSize(display, "getSize"));
-        result.append(display.getDisplayId()).append(".width=").append(display.getWidth()).append('\n');
-        result.append(collectIsValid(display));
-
-        return result.toString();
-    }
-
-    private static Object collectIsValid(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method isValid = display.getClass().getMethod("isValid");
-            Boolean value = (Boolean) isValid.invoke(display);
-            result.append(display.getDisplayId()).append(".isValid=").append(value).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static Object collectRotation(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRotation = display.getClass().getMethod("getRotation");
-            int rotation = (Integer) getRotation.invoke(display);
-            result.append(display.getDisplayId()).append(".rotation=");
-            switch (rotation) {
-            case Surface.ROTATION_0:
-                result.append("ROTATION_0");
-                break;
-            case Surface.ROTATION_90:
-                result.append("ROTATION_90");
-                break;
-            case Surface.ROTATION_180:
-                result.append("ROTATION_180");
-                break;
-            case Surface.ROTATION_270:
-                result.append("ROTATION_270");
-                break;
-            default:
-                result.append(rotation);
-                break;
-            }
-            result.append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static Object collectRectSize(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRectSize = display.getClass().getMethod("getRectSize", Rect.class);
-            Rect size = new Rect();
-            getRectSize.invoke(display, size);
-            result.append(display.getDisplayId()).append(".rectSize=[").append(size.top).append(',').append(size.left)
-                    .append(',').append(size.width()).append(',').append(size.height()).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static Object collectSize(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRealSize = display.getClass().getMethod(methodName, Point.class);
-            Point size = new Point();
-            getRealSize.invoke(display, size);
-            result.append(display.getDisplayId()).append('.').append(methodName).append("=[").append(size.x)
-                    .append(',').append(size.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static String collectCurrentSizeRange(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getCurrentSizeRange = display.getClass().getMethod("getCurrentSizeRange", Point.class, Point.class);
-            Point smallest = new Point(), largest = new Point();
-            getCurrentSizeRange.invoke(display, smallest, largest);
-            result.append(display.getDisplayId()).append(".currentSizeRange.smallest=[").append(smallest.x).append(',')
-                    .append(smallest.y).append(']').append('\n');
-            result.append(display.getDisplayId()).append(".currentSizeRange.largest=[").append(largest.x).append(',')
-                    .append(largest.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static String collectFlags(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getFlags = display.getClass().getMethod("getFlags");
-            int flags = (Integer) getFlags.invoke(display);
-
-            for (Field field : display.getClass().getFields()) {
-                if (field.getName().startsWith("FLAG_")) {
-                    mFlagsNames.put(field.getInt(null), field.getName());
-                }
-            }
-
-            result.append(display.getDisplayId()).append(".flags=").append(activeFlags(mFlagsNames, flags))
-                    .append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static String collectName(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getName = display.getClass().getMethod("getName");
-            String name = (String) getName.invoke(display);
-
-            result.append(display.getDisplayId()).append(".name=").append(name).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        }
-        return result.toString();
-    }
-
-    private static Object collectMetrics(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getMetrics = display.getClass().getMethod(methodName);
-            DisplayMetrics metrics = (DisplayMetrics) getMetrics.invoke(display);
-
-            for (Field field : DisplayMetrics.class.getFields()) {
-                if (field.getType().equals(Integer.class) && field.getName().startsWith("DENSITY_")
-                        && !field.getName().equals("DENSITY_DEFAULT")) {
-                    mDensities.put(field.getInt(null), field.getName());
-                }
-            }
-
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".density=")
-                    .append(metrics.density).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".densityDpi=")
-                    .append(metrics.getClass().getField("densityDpi")).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append("scaledDensity=x")
-                    .append(metrics.scaledDensity).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".widthPixels=")
-                    .append(metrics.widthPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".heightPixels=")
-                    .append(metrics.heightPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".xdpi=").append(metrics.xdpi)
-                    .append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".ydpi=").append(metrics.ydpi)
-                    .append('\n');
-
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        } catch (NoSuchFieldException e) {
-        }
-        return result.toString();
-    }
-
-    /**
-     * Some fields contain multiple value types which can be isolated by
-     * applying a bitmask. That method returns the concatenation of active
-     * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
-     * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
-     */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
-        final StringBuilder result = new StringBuilder();
-
-        // Look for masks, apply it an retrieve the masked value
-        for (int i = 0; i < valueNames.size(); i++) {
-            final int maskValue = valueNames.keyAt(i);
-            final int value = bitfield & maskValue;
-            if (value > 0) {
-                if (result.length() > 0) {
-                    result.append('+');
-                }
-                result.append(valueNames.get(value));
-            }
-        }
-        return result.toString();
-    }
-
-}
diff --git a/src/main/java/org/acra/collector/DropBoxCollector.java b/src/main/java/org/acra/collector/DropBoxCollector.java
deleted file mode 100644
index a2673d12..00000000
--- a/src/main/java/org/acra/collector/DropBoxCollector.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.text.format.Time;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Collects data from the DropBoxManager introduced with Android API Level 8. A
- * set of DropBox tags have been identified in the Android source code. , we
- * collect data associated to these tags with hope that some of them could help
- * debugging applications. Application specific tags can be provided by the app
- * dev to track his own usage of the DropBoxManager.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class DropBoxCollector {
-
-    private static final String[] SYSTEM_TAGS = { "system_app_anr", "system_app_wtf", "system_app_crash",
-            "system_server_anr", "system_server_wtf", "system_server_crash", "BATTERY_DISCHARGE_INFO",
-            "SYSTEM_RECOVERY_LOG", "SYSTEM_BOOT", "SYSTEM_LAST_KMSG", "APANIC_CONSOLE", "APANIC_THREADS",
-            "SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode" };
-
-    private static final String NO_RESULT = "N/A";
-
-    /**
-     * Read latest messages contained in the DropBox for system related tags and
-     * optional developer-set tags.
-     * 
-     * @param context
-     *            The application context.
-     * @param additionalTags
-     *            An array of tags provided by the application developer.
-     * @return A readable formatted String listing messages retrieved.
-     */
-    public static String read(Context context, String[] additionalTags) {
-        try {
-            // Use reflection API to allow compilation with API Level 5.
-            final String serviceName = Compatibility.getDropBoxServiceName();
-            if (serviceName == null) {
-                return NO_RESULT;
-            }
-
-            final Object dropbox = context.getSystemService(serviceName);
-            final Method getNextEntry = dropbox.getClass().getMethod("getNextEntry", String.class, long.class);
-            if (getNextEntry == null) {
-                return "";
-            }
-
-            final Time timer = new Time();
-            timer.setToNow();
-            timer.minute -= ACRA.getConfig().dropboxCollectionMinutes();
-            timer.normalize(false);
-            final long time = timer.toMillis(false);
-
-            final List<String> tags = new ArrayList<String>();
-            if (ACRA.getConfig().includeDropBoxSystemTags()) {
-                tags.addAll(Arrays.asList(SYSTEM_TAGS));
-            }
-            if (additionalTags != null && additionalTags.length > 0) {
-                tags.addAll(Arrays.asList(additionalTags));
-            }
-
-            if (tags.isEmpty()) {
-                return "No tag configured for collection.";
-            }
-
-            final StringBuilder dropboxContent = new StringBuilder();
-            for (String tag : tags) {
-                dropboxContent.append("Tag: ").append(tag).append('\n');
-                Object entry = getNextEntry.invoke(dropbox, tag, time);
-                if (entry == null) {
-                    dropboxContent.append("Nothing.").append('\n');
-                    continue;
-                }
-
-                final Method getText = entry.getClass().getMethod("getText", int.class);
-                final Method getTimeMillis = entry.getClass().getMethod("getTimeMillis", (Class[]) null);
-                final Method close = entry.getClass().getMethod("close", (Class[]) null);
-                while (entry != null) {
-                    final long msec = (Long) getTimeMillis.invoke(entry, (Object[]) null);
-                    timer.set(msec);
-                    dropboxContent.append("@").append(timer.format2445()).append('\n');
-                    final String text = (String) getText.invoke(entry, 500);
-                    if (text != null) {
-                        dropboxContent.append("Text: ").append(text).append('\n');
-                    } else {
-                        dropboxContent.append("Not Text!").append('\n');
-                    }
-                    close.invoke(entry, (Object[]) null);
-                    entry = getNextEntry.invoke(dropbox, tag, msec);
-                }
-            }
-            return dropboxContent.toString();
-
-        } catch (SecurityException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchMethodException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalArgumentException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalAccessException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (InvocationTargetException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchFieldException e) {
-            ACRA.log.i(LOG_TAG, "DropBoxManager not available.");
-        }
-
-        return NO_RESULT;
-    }
-}
diff --git a/src/main/java/org/acra/collector/DumpSysCollector.java b/src/main/java/org/acra/collector/DumpSysCollector.java
deleted file mode 100644
index a6afd86e..00000000
--- a/src/main/java/org/acra/collector/DumpSysCollector.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Collects results of the <code>dumpsys</code> command.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class DumpSysCollector {
-
-    /**
-     * Collect results of the <code>dumpsys meminfo</code> command restricted to
-     * this application process.
-     * 
-     * @return The execution result.
-     */
-    public static String collectMemInfo() {
-
-        final StringBuilder meminfo = new StringBuilder();
-		BufferedReader bufferedReader = null;
-        try {
-            final List<String> commandLine = new ArrayList<String>();
-            commandLine.add("dumpsys");
-            commandLine.add("meminfo");
-            commandLine.add(Integer.toString(android.os.Process.myPid()));
-
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                meminfo.append(line);
-                meminfo.append("\n");
-            }
-
-        } catch (IOException e) {
-            ACRA.log.e(LOG_TAG, "DumpSysCollector.meminfo could not retrieve data", e);
-		}
-
-        CollectorUtil.safeClose(bufferedReader);
-
-        return meminfo.toString();
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/LogCatCollector.java b/src/main/java/org/acra/collector/LogCatCollector.java
deleted file mode 100644
index fd27ef26..00000000
--- a/src/main/java/org/acra/collector/LogCatCollector.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.util.BoundedLinkedList;
-
-
-/**
- * Executes logcat commands and collects it's output.
- * 
- * @author Kevin Gaudin
- * 
- */
-class LogCatCollector {
-
-    /**
-     * Default number of latest lines kept from the logcat output.
-     */
-    private static final int DEFAULT_TAIL_COUNT = 100;
-
-    /**
-     * Executes the logcat command with arguments taken from
-     * {@link ReportsCrashes#logcatArguments()}
-     * 
-     * @param bufferName
-     *            The name of the buffer to be read: "main" (default), "radio"
-     *            or "events".
-     * @return A {@link String} containing the latest lines of the output.
-     *         Default is 100 lines, use "-t", "300" in
-     *         {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
-     *         You should be aware that increasing this value causes a longer
-     *         report generation time and a bigger footprint on the device data
-     *         plan consumption.
-     */
-    public static String collectLogCat(String bufferName) {
-        final int myPid = android.os.Process.myPid();
-        String myPidStr = null;
-        if (ACRA.getConfig().logcatFilterByPid() && myPid > 0) {
-            myPidStr = Integer.toString(myPid) +"):";
-        }
-
-        final List<String> commandLine = new ArrayList<String>();
-        commandLine.add("logcat");
-        if (bufferName != null) {
-            commandLine.add("-b");
-            commandLine.add(bufferName);
-        }
-
-        // "-t n" argument has been introduced in FroYo (API level 8). For
-        // devices with lower API level, we will have to emulate its job.
-        final int tailCount;
-        final List<String> logcatArgumentsList = new ArrayList<String>(
-                Arrays.asList(ACRA.getConfig().logcatArguments()));
-
-        final int tailIndex = logcatArgumentsList.indexOf("-t");
-        if (tailIndex > -1 && tailIndex < logcatArgumentsList.size()) {
-            tailCount = Integer.parseInt(logcatArgumentsList.get(tailIndex + 1));
-            if (Compatibility.getAPILevel() < Compatibility.VERSION_CODES.FROYO) {
-                logcatArgumentsList.remove(tailIndex + 1);
-                logcatArgumentsList.remove(tailIndex);
-                logcatArgumentsList.add("-d");
-            }
-        } else {
-            tailCount = -1;
-        }
-
-        final LinkedList<String> logcatBuf = new BoundedLinkedList<String>(tailCount > 0 ? tailCount
-                : DEFAULT_TAIL_COUNT);
-        commandLine.addAll(logcatArgumentsList);
-        
-        BufferedReader bufferedReader = null;
-
-        try {
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-            ACRA.log.d(LOG_TAG, "Retrieving logcat output...");
-
-            // Dump stderr to null
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        InputStream stderr = process.getErrorStream();
-                        byte[] dummy = new byte[ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES];
-                        while (stderr.read(dummy) >= 0)
-                            ;
-                    } catch (IOException e) {
-                    }
-                }
-            }).start();
-
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                if (myPidStr == null || line.contains(myPidStr)) {
-                    logcatBuf.add(line + "\n");
-                }
-            }
-
-        } catch (IOException e) {
-            ACRA.log.e(LOG_TAG, "LogCatCollector.collectLogCat could not retrieve data.", e);
-        } finally {
-            CollectorUtil.safeClose(bufferedReader);
-        }
-
-        return logcatBuf.toString();
-    }
-}
diff --git a/src/main/java/org/acra/collector/LogFileCollector.java b/src/main/java/org/acra/collector/LogFileCollector.java
deleted file mode 100644
index ca9679e4..00000000
--- a/src/main/java/org/acra/collector/LogFileCollector.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-import org.acra.ACRA;
-import org.acra.util.BoundedLinkedList;
-
-import android.app.Application;
-import android.content.Context;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Collects the N last lines of a text stream. Use this collector if your
- * application handles its own logging system.
- * 
- * @author Kevin Gaudin
- * 
- */
-class LogFileCollector {
-
-    /**
-     * Private constructor to prevent instantiation.
-     */
-    private LogFileCollector() {
-    };
-
-    /**
-     * Reads the last lines of a custom log file. The file name is assumed as
-     * located in the {@link Application#getFilesDir()} directory if it does not
-     * contain any path separator.
-     * 
-     * @param context
-     * @param fileName
-     * @param numberOfLines
-     * @return
-     * @throws IOException
-     */
-    public static String collectLogFile(Context context, String fileName, int numberOfLines) throws IOException {
-        final BoundedLinkedList<String> resultBuffer = new BoundedLinkedList<String>(numberOfLines);
-        final BufferedReader reader = getReader(context, fileName);
-        try {
-            String line = reader.readLine();
-            while (line != null) {
-                resultBuffer.add(line + "\n");
-                line = reader.readLine();
-            }
-        } finally {
-            CollectorUtil.safeClose(reader);
-        }
-        return resultBuffer.toString();
-    }
-
-    private static BufferedReader getReader(Context context, String fileName) {
-        try {
-            if (fileName.contains("/")) {
-                return new BufferedReader(new InputStreamReader(new FileInputStream(fileName)), 1024);
-            } else {
-                return new BufferedReader(new InputStreamReader(context.openFileInput(fileName)), 1024);
-            }
-        } catch (FileNotFoundException e) {
-            ACRA.log.e(LOG_TAG, "Cannot find application log file : '" + ACRA.getConfig().applicationLogFile() + "'");
-            return new BufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[0])));
-        }
-    }
-}
diff --git a/src/main/java/org/acra/collector/MediaCodecListCollector.java b/src/main/java/org/acra/collector/MediaCodecListCollector.java
deleted file mode 100644
index 23c58890..00000000
--- a/src/main/java/org/acra/collector/MediaCodecListCollector.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.Arrays;
-
-import android.util.SparseArray;
-
-/**
- * Collects data about available codecs on the device through the MediaCodecList
- * API introduced in Android 4.1 JellyBean.
- * 
- * @author Kevin Gaudin
- * 
- */
-public class MediaCodecListCollector {
-    private enum CodecType {
-        AVC, H263, MPEG4, AAC
-
-    }
-
-    private static final String COLOR_FORMAT_PREFIX = "COLOR_";
-    private static final String[] MPEG4_TYPES = { "mp4", "mpeg4", "MP4", "MPEG4" };
-    private static final String[] AVC_TYPES = { "avc", "h264", "AVC", "H264" };
-    private static final String[] H263_TYPES = { "h263", "H263" };
-    private static final String[] AAC_TYPES = { "aac", "AAC" };
-
-    private static Class<?> mediaCodecListClass = null;
-    private static Method getCodecInfoAtMethod = null;
-    private static Class<?> mediaCodecInfoClass = null;
-    private static Method getNameMethod = null;
-    private static Method isEncoderMethod = null;
-    private static Method getSupportedTypesMethod = null;
-    private static Method getCapabilitiesForTypeMethod = null;
-    private static Class<?> codecCapabilitiesClass = null;
-    private static Field colorFormatsField = null;
-    private static Field profileLevelsField = null;
-    private static Field profileField = null;
-    private static Field levelField = null;
-    private static SparseArray<String> mColorFormatValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCLevelValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mH263LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mH263ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mAACProfileValues = new SparseArray<String>();
-
-    // static init where nearly all reflection inspection is done.
-    static {
-        try {
-            mediaCodecListClass = Class.forName("android.media.MediaCodecList");
-            // Get methods to retrieve media codec info
-            getCodecInfoAtMethod = mediaCodecListClass.getMethod("getCodecInfoAt", int.class);
-            mediaCodecInfoClass = Class.forName("android.media.MediaCodecInfo");
-            getNameMethod = mediaCodecInfoClass.getMethod("getName");
-            isEncoderMethod = mediaCodecInfoClass.getMethod("isEncoder");
-            getSupportedTypesMethod = mediaCodecInfoClass.getMethod("getSupportedTypes");
-            getCapabilitiesForTypeMethod = mediaCodecInfoClass.getMethod("getCapabilitiesForType", String.class);
-            codecCapabilitiesClass = Class.forName("android.media.MediaCodecInfo$CodecCapabilities");
-            colorFormatsField = codecCapabilitiesClass.getField("colorFormats");
-            profileLevelsField = codecCapabilitiesClass.getField("profileLevels");
-
-            // Retrieve list of possible Color Format
-            for (Field f : codecCapabilitiesClass.getFields()) {
-                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())
-                        && f.getName().startsWith(COLOR_FORMAT_PREFIX)) {
-                    mColorFormatValues.put(f.getInt(null), f.getName());
-                }
-            }
-
-            // Retrieve lists of possible codecs profiles and levels
-            Class<?> codecProfileLevelClass = Class.forName("android.media.MediaCodecInfo$CodecProfileLevel");
-            for (Field f : codecProfileLevelClass.getFields()) {
-                if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
-                    if (f.getName().startsWith("AVCLevel")) {
-                        mAVCLevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("AVCProfile")) {
-                        mAVCProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("H263Level")) {
-                        mH263LevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("H263Profile")) {
-                        mH263ProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("MPEG4Level")) {
-                        mMPEG4LevelValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("MPEG4Profile")) {
-                        mMPEG4ProfileValues.put(f.getInt(null), f.getName());
-                    } else if (f.getName().startsWith("AAC")) {
-                        mAACProfileValues.put(f.getInt(null), f.getName());
-                    }
-                }
-            }
-
-            profileField = codecProfileLevelClass.getField("profile");
-            levelField = codecProfileLevelClass.getField("level");
-
-        } catch (ClassNotFoundException e) {
-            // NOOP
-        } catch (NoSuchMethodException e) {
-            // NOOP
-        } catch (IllegalArgumentException e) {
-            // NOOP
-        } catch (IllegalAccessException e) {
-            // NOOP
-        } catch (SecurityException e) {
-            // NOOP
-        } catch (NoSuchFieldException e) {
-            // NOOP
-        }
-
-    }
-
-    /**
-     * Builds a String describing the list of available codecs on the device
-     * with their capabilities (supported Color Formats, Codec Profiles et
-     * Levels).
-     * 
-     * @return The media codecs information
-     */
-    public static String collecMediaCodecList() {
-        StringBuilder result = new StringBuilder();
-        if (mediaCodecListClass != null && mediaCodecInfoClass != null) {
-            try {
-                // Retrieve list of available media codecs
-                int codecCount = (Integer) (mediaCodecListClass.getMethod("getCodecCount").invoke(null));
-
-                // Go through each available media codec
-                Object codecInfo = null;
-                for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
-                    result.append("\n");
-                    codecInfo = getCodecInfoAtMethod.invoke(null, codecIdx);
-                    result.append(codecIdx).append(": ").append(getNameMethod.invoke(codecInfo)).append("\n");
-                    result.append("isEncoder: ").append(isEncoderMethod.invoke(codecInfo)).append("\n");
-                    String[] supportedTypes = (String[]) getSupportedTypesMethod.invoke(codecInfo);
-                    result.append("Supported types: ").append(Arrays.toString(supportedTypes)).append("\n");
-                    for (String type : supportedTypes) {
-                        result.append(collectCapabilitiesForType(codecInfo, type));
-                    }
-                    result.append("\n");
-                }
-            } catch (NoSuchMethodException e) {
-                // NOOP
-            } catch (IllegalAccessException e) {
-                // NOOP
-            } catch (InvocationTargetException e) {
-                // NOOP
-            }
-        }
-        return result.toString();
-    }
-
-    /**
-     * Retrieve capabilities (ColorFormats and CodecProfileLevels) for a
-     * specific codec type.
-     * 
-     * @param codecInfo
-     * @param type
-     * @return A string describing the color formats and codec profile levels
-     *         available for a specific codec type.
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
-     */
-    private static String collectCapabilitiesForType(final Object codecInfo, String type) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-
-        final StringBuilder result = new StringBuilder();
-        final Object codecCapabilities = getCapabilitiesForTypeMethod.invoke(codecInfo, type);
-
-        // Color Formats
-        final int[] colorFormats = (int[]) colorFormatsField.get(codecCapabilities);
-        if (colorFormats.length > 0) {
-            result.append(type).append(" color formats:");
-            for (int i = 0; i < colorFormats.length; i++) {
-                result.append(mColorFormatValues.get(colorFormats[i]));
-                if (i < colorFormats.length - 1) {
-                    result.append(',');
-                }
-            }
-            result.append("\n");
-        }
-
-        final CodecType codecType = identifyCodecType(codecInfo);
-
-        // Profile Levels
-        final Object[] codecProfileLevels = (Object[]) profileLevelsField.get(codecCapabilities);
-        if (codecProfileLevels.length > 0) {
-            result.append(type).append(" profile levels:");
-            for (int i = 0; i < codecProfileLevels.length; i++) {
-
-                final int profileValue = profileField.getInt(codecProfileLevels[i]);
-                final int levelValue = levelField.getInt(codecProfileLevels[i]);
-
-                if (codecType == null) {
-                    // Unknown codec
-                    result.append(profileValue).append('-').append(levelValue);
-                    break;
-                }
-
-                switch (codecType) {
-                case AVC:
-                    result.append(profileValue).append(mAVCProfileValues.get(profileValue)).append('-')
-                            .append(mAVCLevelValues.get(levelValue));
-                    break;
-                case H263:
-                    result.append(mH263ProfileValues.get(profileValue)).append('-')
-                            .append(mH263LevelValues.get(levelValue));
-                    break;
-                case MPEG4:
-                    result.append(mMPEG4ProfileValues.get(profileValue)).append('-')
-                            .append(mMPEG4LevelValues.get(levelValue));
-                    break;
-                case AAC:
-                    result.append(mAACProfileValues.get(profileValue));
-                    break;
-                default:
-                    break;
-                }
-
-                if (i < codecProfileLevels.length - 1) {
-                    result.append(',');
-                }
-
-            }
-            result.append("\n");
-        }
-        return result.append("\n").toString();
-    }
-
-    /**
-     * Looks for keywords in the codec name to identify its nature ({@link CodecType}).
-     * @param codecInfo
-     * @return
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
-     */
-    private static CodecType identifyCodecType(Object codecInfo) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-
-        String name = (String) getNameMethod.invoke(codecInfo);
-        for (String token : AVC_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.AVC;
-            }
-        }
-        for (String token : H263_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.H263;
-            }
-        }
-        for (String token : MPEG4_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.MPEG4;
-            }
-        }
-        for (String token : AAC_TYPES) {
-            if (name.contains(token)) {
-                return CodecType.AAC;
-            }
-        }
-
-        return null;
-    }
-}
diff --git a/src/main/java/org/acra/collector/ReflectionCollector.java b/src/main/java/org/acra/collector/ReflectionCollector.java
deleted file mode 100644
index 47a2a917..00000000
--- a/src/main/java/org/acra/collector/ReflectionCollector.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-
-/**
- * Tools to retrieve key/value pairs from static fields and getters of any
- * class. Reflection API usage allows to retrieve data without having to
- * implement a class for each android version of each interesting class.
- * It can also help find hidden properties.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class ReflectionCollector {
-
-    /**
-     * Retrieves key/value pairs from static fields of a class.
-     *
-     * @param someClass the class to be inspected.
-     * 
-     * @return A human readable string with a key=value pair on each line.
-     */
-    public static String collectConstants(Class<?> someClass, String prefix) {
-
-        final StringBuilder result = new StringBuilder();
-
-        final Field[] fields = someClass.getFields();
-        for (final Field field : fields) {
-            if (prefix != null && prefix.length() > 0) {
-                result.append(prefix).append('.');
-            }
-            result.append(field.getName()).append("=");
-            try {
-                final Object value = field.get(null);
-                if (value != null) {
-                    if (field.getType().isArray()) {
-                        result.append(Arrays.toString((Object[]) value));
-                    } else {
-                        result.append(value.toString());
-                    }
-                }
-            } catch (IllegalArgumentException e) {
-                result.append("N/A");
-            } catch (IllegalAccessException e) {
-                result.append("N/A");
-            }
-            result.append("\n");
-        }
-
-        return result.toString();
-    }
-
-    /**
-     * Retrieves key/value pairs from static getters of a class (get*() or is*()).
-     *
-     * @param someClass the class to be inspected.
-     * @return A human readable string with a key=value pair on each line.
-     */
-    public static String collectStaticGettersResults(Class<?> someClass) {
-        final StringBuilder result = new StringBuilder();
-        final Method[] methods = someClass.getMethods();
-        for (final Method method : methods) {
-            if (method.getParameterTypes().length == 0
-                    && (method.getName().startsWith("get") || method.getName().startsWith("is"))
-                    && !method.getName().equals("getClass")) {
-                try {
-                    result.append(method.getName());
-                    result.append('=');
-                    result.append(method.invoke(null, (Object[]) null));
-                    result.append("\n");
-                } catch (IllegalArgumentException e) {
-                    // NOOP
-                } catch (IllegalAccessException e) {
-                    // NOOP
-                } catch (InvocationTargetException e) {
-                    // NOOP
-                }
-            }
-        }
-
-        return result.toString();
-    }
-
-    public static String collectConstants(Class<?> someClass) {
-        return collectConstants(someClass, "");
-    }
-}
diff --git a/src/main/java/org/acra/collector/SettingsCollector.java b/src/main/java/org/acra/collector/SettingsCollector.java
deleted file mode 100644
index ef314f7b..00000000
--- a/src/main/java/org/acra/collector/SettingsCollector.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.acra.ACRA;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.provider.Settings;
-import android.provider.Settings.Secure;
-import android.provider.Settings.System;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Helper to collect data from {@link System} and {@link Secure} Settings
- * classes.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class SettingsCollector {
-
-    /**
-     * Collect data from {@link android.provider.Settings.System}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectSystemSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.System.class.getFields();
-        for (final Field key : keys) {
-            // Avoid retrieving deprecated fields... it is useless, has an
-            // impact on perfs, and the system writes many warnings in the
-            // logcat.
-            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class) {
-                try {
-                    final Object value = Settings.System.getString(ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                }
-            }
-        }
-
-        return result.toString();
-    }
-
-    /**
-     * Collect data from {@link android.provider.Settings.Secure}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectSecureSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.Secure.class.getFields();
-        for (final Field key : keys) {
-            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
-                try {
-                    final Object value = Settings.Secure.getString(ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                } catch (IllegalArgumentException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    ACRA.log.w(LOG_TAG, "Error : ", e);
-                }
-            }
-        }
-
-        return result.toString();
-    }
-
-    /**
-     * Collect data from {@link android.provider.Settings.Global}. This
-     * collector uses reflection to be sure to always get the most accurate data
-     * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
-     */
-    public static String collectGlobalSettings(Context ctx) {
-        if (Compatibility.getAPILevel() < Compatibility.VERSION_CODES.JELLY_BEAN_MR1) {
-            return "";
-        }
-
-        final StringBuilder result = new StringBuilder();
-        try {
-            final Class<?> globalClass = Class.forName("android.provider.Settings$Global");
-            final Field[] keys = globalClass.getFields();
-            final Method getString = globalClass.getMethod("getString", ContentResolver.class, String.class);
-            for (final Field key : keys) {
-                if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
-                    final Object value = getString.invoke(null, ctx.getContentResolver(), (String) key.get(null));
-                    if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
-                    }
-                }
-            }
-        } catch (IllegalArgumentException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (IllegalAccessException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (ClassNotFoundException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (SecurityException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (NoSuchMethodException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        } catch (InvocationTargetException e) {
-            ACRA.log.w(LOG_TAG, "Error : ", e);
-        }
-
-        return result.toString();
-    }
-
-    private static boolean isAuthorized(Field key) {
-        if (key == null || key.getName().startsWith("WIFI_AP")) {
-            return false;
-        }
-        for (String regex : ACRA.getConfig().excludeMatchingSettingsKeys()) {
-            if(key.getName().matches(regex)) {
-               return false; 
-            }
-        }
-        return true;
-    }
-
-}
diff --git a/src/main/java/org/acra/collector/SharedPreferencesCollector.java b/src/main/java/org/acra/collector/SharedPreferencesCollector.java
deleted file mode 100644
index d4ef0f7b..00000000
--- a/src/main/java/org/acra/collector/SharedPreferencesCollector.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import java.util.Map;
-import java.util.TreeMap;
-
-import org.acra.ACRA;
-import org.acra.annotation.ReportsCrashes;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Collects the content (key/value pairs) of SharedPreferences, from the
- * application default preferences or any other preferences asked by the
- * application developer.
- */
-final class SharedPreferencesCollector {
-
-    /**
-     * Collects all key/value pairs in SharedPreferences and writes them in a
-     * result String. The application default SharedPreferences are always
-     * collected, and the developer can provide additional SharedPreferences
-     * names in the {@link ReportsCrashes#additionalSharedPreferences()}
-     * configuration item.
-     * 
-     * 
-     * 
-     * @param context
-     *            the application context.
-     * @return A readable formatted String containing all key/value pairs.
-     */
-    public static String collect(Context context) {
-        final StringBuilder result = new StringBuilder();
-
-        // Include the default SharedPreferences
-        final Map<String, SharedPreferences> sharedPrefs = new TreeMap<String, SharedPreferences>();
-        sharedPrefs.put("default", PreferenceManager.getDefaultSharedPreferences(context));
-
-        // Add in any additional SharedPreferences
-        final String[] sharedPrefIds = ACRA.getConfig().additionalSharedPreferences();
-        if (sharedPrefIds != null) {
-            for (final String sharedPrefId : sharedPrefIds) {
-                sharedPrefs.put(sharedPrefId, context.getSharedPreferences(sharedPrefId, Context.MODE_PRIVATE));
-            }
-        }
-
-        // Iterate over all included preference files and add the preferences from each.
-        for (Map.Entry<String, SharedPreferences> entry : sharedPrefs.entrySet()) {
-            final String sharedPrefId = entry.getKey();
-            final SharedPreferences prefs = entry.getValue();
-
-            final Map<String, ?> prefEntries = prefs.getAll();
-
-            // Show that we have no preferences saved for that preference file.
-            if (prefEntries.isEmpty()) {
-                result.append(sharedPrefId).append('=').append("empty\n");
-                continue;
-            }
-
-            // Add all non-filtered preferences from that preference file.
-            for (final String key : prefEntries.keySet()) {
-                if (filteredKey(key)) {
-                    ACRA.log.d(LOG_TAG, "Filtered out sharedPreference=" + sharedPrefId + "  key=" + key + " due to filtering rule");
-                } else {
-                    final Object prefValue = prefEntries.get(key);
-                    result.append(sharedPrefId).append('.').append(key).append('=');
-                    result.append(prefValue == null ? "null" : prefValue.toString());
-                    result.append("\n");
-                }
-            }
-            result.append('\n');
-        }
-
-        return result.toString();
-    }
-
-    /**
-     * Checks if the key matches one of the patterns provided by the developer
-     * to exclude some preferences from reports.
-     * 
-     * @param key
-     *            the name of the preference to be checked
-     * @return true if the key has to be excluded from reports.
-     */
-    private static boolean filteredKey(String key) {
-        for (String regex : ACRA.getConfig().excludeMatchingSharedPreferencesKeys()) {
-            if(key.matches(regex)) {
-               return true; 
-            }
-        }
-        return false;
-    }
-}
diff --git a/src/main/java/org/acra/collector/ThreadCollector.java b/src/main/java/org/acra/collector/ThreadCollector.java
deleted file mode 100644
index 64e78dc7..00000000
--- a/src/main/java/org/acra/collector/ThreadCollector.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-/**
- * Collects some data identifying a Thread, usually the Thread which crashed.
- * 
- * @author Kevin Gaudin
- * 
- */
-public class ThreadCollector {
-
-    /**
-     * Convenience method that collects some data identifying a Thread, usually the Thread which
-     * crashed and returns a string containing the thread's id, name, priority and group name.
-     * 
-     * @param t the thread
-     * @return a string representation of the string including the id, name and priority of the thread.
-     */
-    public static String collect(Thread t) {
-        StringBuilder result = new StringBuilder();
-        if (t != null) {
-
-            result.append("id=").append(t.getId()).append("\n");
-            result.append("name=").append(t.getName()).append("\n");
-            result.append("priority=").append(t.getPriority()).append("\n");
-            if (t.getThreadGroup() != null) {
-                result.append("groupName=").append(t.getThreadGroup().getName()).append("\n");
-            }
-        } else {
-            result.append("No broken thread, this might be a silent exception.");
-        }
-        return result.toString();
-    }
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
deleted file mode 100644
index cb0762fa..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-/**
- * This adapter class provides empty implementations of the methods from {@link ActivityLifecycleCallbacksCompat}.
- * Any custom listener that cares only about a subset of the methods of this listener can simply subclass this
- * adapter class instead of implementing the interface directly.
- */
-public class ActivityLifecycleCallbacksAdapter implements ActivityLifecycleCallbacksCompat {
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {}
-
-    @Override
-    public void onActivityStarted(Activity activity) {}
-
-    @Override
-    public void onActivityResumed(Activity activity) {}
-
-    @Override
-    public void onActivityPaused(Activity activity) {}
-
-    @Override
-    public void onActivityStopped(Activity activity) {}
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {}
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
deleted file mode 100644
index 0d7f0df8..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-/**
- * Equivalent of {@link ActivityLifecycleCallbacks} to be used with
- * {@link ApplicationHelper#registerActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)} and
- * {@link ApplicationHelper#unregisterActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)}.
- */
-public interface ActivityLifecycleCallbacksCompat {
-    void onActivityCreated(Activity activity, Bundle savedInstanceState);
-
-    void onActivityStarted(Activity activity);
-
-    void onActivityResumed(Activity activity);
-
-    void onActivityPaused(Activity activity);
-
-    void onActivityStopped(Activity activity);
-
-    void onActivitySaveInstanceState(Activity activity, Bundle outState);
-
-    void onActivityDestroyed(Activity activity);
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
deleted file mode 100644
index b1656acb..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-/**
- * Wraps an {@link ActivityLifecycleCallbacksCompat} into an {@link ActivityLifecycleCallbacks}.
- */
-/* package */class ActivityLifecycleCallbacksWrapper implements ActivityLifecycleCallbacks {
-
-    private final ActivityLifecycleCallbacksCompat mCallback;
-
-    public ActivityLifecycleCallbacksWrapper(ActivityLifecycleCallbacksCompat callback) {
-        mCallback = callback;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        mCallback.onActivityCreated(activity, savedInstanceState);
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        mCallback.onActivityStarted(activity);
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        mCallback.onActivityResumed(activity);
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        mCallback.onActivityPaused(activity);
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        mCallback.onActivityStopped(activity);
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        mCallback.onActivitySaveInstanceState(activity, outState);
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        mCallback.onActivityDestroyed(activity);
-    }
-
-    /**
-     * Compare the current wrapped callback with another object wrapped callback
-     */
-    @Override
-    public boolean equals(Object object) {
-        if( !(object instanceof ActivityLifecycleCallbacksWrapper) ) {
-            return false;
-        }
-        final ActivityLifecycleCallbacksWrapper that = (ActivityLifecycleCallbacksWrapper) object;
-        return null == mCallback ? null == that.mCallback : mCallback.equals( that.mCallback );
-    }
-
-    /**
-     *
-     * return wrapped callback object hashCode
-     */
-    @Override
-    public int hashCode() {
-        return null != mCallback ? mCallback.hashCode() : 0;
-    }
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
deleted file mode 100644
index 5e42f949..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-
-/**
- * Helper for accessing {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} introduced in API level 14 in a
- * backwards compatible fashion.<br>
- *
- * When running on API level 14 or above, the framework's implementations of these methods will be used.
- */
-public final class ApplicationHelper {
-
-    /**
-     * Registers a callback to be called following the life cycle of the application's {@link Activity activities}.
-     * 
-     * @param application The application with which to register the callback.
-     * @param callback The callback to register.
-     */
-    public static void registerActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
-
-
-    /*
-     * Unregister.
-     */
-
-    /**
-     * Unregisters a previously registered callback.
-     * 
-     * @param application The application with which to unregister the callback.
-     * @param callback The callback to unregister.
-     */
-    public void unregisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.unregisterActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
deleted file mode 100644
index de1bb1ed..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import java.util.ArrayList;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-/**
- * Keeps a list of {@link ActivityLifecycleCallbacksCompat}s that will be called following the life cycle of the application's {@link Activity activities}.
- * This class is used when the app is running on an older platform version that does not support
- * {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}.
- */
-public class MainLifecycleDispatcher implements ActivityLifecycleCallbacksCompat {
-    private static final MainLifecycleDispatcher INSTANCE = new MainLifecycleDispatcher();
-
-    public static MainLifecycleDispatcher get() {
-        return INSTANCE;
-    }
-
-    private MainLifecycleDispatcher() {}
-
-    private ArrayList<ActivityLifecycleCallbacksCompat> mActivityLifecycleCallbacks = new ArrayList<ActivityLifecycleCallbacksCompat>();
-
-    /* package */void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.add(callback);
-        }
-    }
-
-    /* package */void unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.remove(callback);
-        }
-    }
-
-    private Object[] collectActivityLifecycleCallbacks() {
-        Object[] callbacks = null;
-        synchronized (mActivityLifecycleCallbacks) {
-            if (mActivityLifecycleCallbacks.size() > 0) {
-                callbacks = mActivityLifecycleCallbacks.toArray();
-            }
-        }
-        return callbacks;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityCreated(activity, savedInstanceState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStarted(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityResumed(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityPaused(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStopped(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivitySaveInstanceState(activity, outState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityDestroyed(activity);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/acra/log/ACRALog.java b/src/main/java/org/acra/log/ACRALog.java
deleted file mode 100644
index 482b4aba..00000000
--- a/src/main/java/org/acra/log/ACRALog.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.acra.log;
-
-/**
- * Responsible for providing ACRA classes with a platform neutral way of logging.
- * <p>
- *     One reason for using this mechanism is to allow ACRA classes to use a logging system,
- *     but be able to execute in a test environment outside of an Android JVM.
- * </p>
- * @author William Ferguson
- * @since 4.3.0
- */
-public interface ACRALog {
-    public int v(java.lang.String tag, java.lang.String msg);
-    public int v(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int d(java.lang.String tag, java.lang.String msg);
-    public int d(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int i(java.lang.String tag, java.lang.String msg);
-    public int i(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int w(java.lang.String tag, java.lang.String msg);
-    public int w(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(java.lang.String tag, java.lang.Throwable tr);
-    public int e(java.lang.String tag, java.lang.String msg);
-    public int e(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public java.lang.String getStackTraceString(java.lang.Throwable tr);
-    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
-}
diff --git a/src/main/java/org/acra/sender/EmailIntentSender.java b/src/main/java/org/acra/sender/EmailIntentSender.java
deleted file mode 100644
index 78cb165c..00000000
--- a/src/main/java/org/acra/sender/EmailIntentSender.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.sender;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-import org.acra.collector.CrashReportData;
-import org.acra.ReportField;
-import org.acra.annotation.ReportsCrashes;
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-
-/**
- * Send reports through an email intent. The user will be asked to chose his
- * preferred email client. Included report fields can be defined using
- * {@link org.acra.annotation.ReportsCrashes#customReportContent()}. Crash receiving mailbox has to be
- * defined with {@link ReportsCrashes#mailTo()}.
- */
-public class EmailIntentSender implements ReportSender {
-
-    private final Context mContext;
-
-    public EmailIntentSender(Context ctx) {
-        mContext = ctx;
-    }
-
-    @Override
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException {
-
-        final String subject = mContext.getPackageName() + " Crash Report";
-        final String body = buildBody(errorContent);
-
-        final Intent emailIntent = new Intent(android.content.Intent.ACTION_SENDTO);
-        emailIntent.setData(Uri.fromParts("mailto", ACRA.getConfig().mailTo(), null));
-        emailIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
-        emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, body);
-        mContext.startActivity(emailIntent);
-    }
-
-    private String buildBody(CrashReportData errorContent) {
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if(fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
-        }
-
-        final StringBuilder builder = new StringBuilder();
-        for (ReportField field : fields) {
-            builder.append(field.toString()).append("=");
-            builder.append(errorContent.get(field));
-            builder.append('\n');
-        }
-        return builder.toString();
-    }
-}
diff --git a/src/main/java/org/acra/sender/HttpSender.java b/src/main/java/org/acra/sender/HttpSender.java
deleted file mode 100644
index 0579ccf0..00000000
--- a/src/main/java/org/acra/sender/HttpSender.java
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.sender;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.IOException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-
-import android.content.Context;
-import org.acra.ACRA;
-import org.acra.ACRAConfiguration;
-import org.acra.ACRAConstants;
-import org.acra.ReportField;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.collector.CrashReportData;
-import org.acra.util.HttpRequest;
-import org.acra.util.JSONReportBuilder.JSONReportException;
-
-import android.net.Uri;
-
-/**
- * <p>
- * The {@link ReportSender} used by ACRA when {@link ReportsCrashes#formUri()}
- * has been defined in order to post crash data to a custom server-side data
- * collection script. It sends all data in a POST request with parameters named
- * with easy to understand names (basically a string conversion of
- * {@link ReportField} enum values) or based on your own conversion Map from
- * {@link ReportField} values to String.
- * </p>
- * 
- * <p>
- * To use specific POST parameter names, you can provide your own report fields
- * mapping scheme:
- * </p>
- * 
- * <pre>
- * &#64;ReportsCrashes(...)
- * public class myApplication extends Application {
- * 
- *     public void onCreate() {
- *         super.onCreate();
- *         ACRA.init(this);
- *         Map&lt;ReportField, String&gt; mapping = new HashMap&lt;ReportField, String&gt;();
- *         mapping.put(ReportField.APP_VERSION_CODE, &quot;myAppVerCode'); 
- *         mapping.put(ReportField.APP_VERSION_NAME, &quot;myAppVerName');
- *         //... 
- *         mapping.put(ReportField.USER_EMAIL, &quot;userEmail');
- *         // remove any default report sender
- *         ErrorReporter.getInstance().removeAllReportSenders();
- *         // create your own instance with your specific mapping
- *         ErrorReporter.getInstance().addReportSender(new ReportSender(&quot;http://my.domain.com/reports/receiver.py&quot;, mapping));
- *     }
- * }
- * </pre>
- * 
- */
-public class HttpSender implements ReportSender {
-
-    /**
-     * Available HTTP methods to send data. Only POST and PUT are currently
-     * supported.
-     */
-    public enum Method {
-        POST, PUT
-    }
-
-    /**
-     * Type of report data encoding, currently supports Html Form encoding and
-     * JSON.
-     */
-    public enum Type {
-        /**
-         * Send data as a www form encoded list of key/values.
-         * @see <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">Form content types</a>
-         */
-        FORM {
-            @Override
-            public String getContentType() {
-                return "application/x-www-form-urlencoded";
-            }
-        },
-        /**
-         * Send data as a structured JSON tree.
-         */
-        JSON {
-            @Override
-            public String getContentType() {
-                return "application/json";
-            }
-        };
-
-        public abstract String getContentType();
-    }
-
-    private final Uri mFormUri;
-    private final Map<ReportField, String> mMapping;
-    private final Method mMethod;
-    private final Type mType;
-    private String mUsername;
-    private String mPassword;
-
-    /**
-     * <p>
-     * Create a new HttpSender instance with its destination taken from
-     * {@link ACRA#getConfig()} dynamically. Configuration changes to the
-     * formUri are applied automatically.
-     * </p>
-     * 
-     * @param method
-     *            HTTP {@link Method} to be used to send data. Currently only
-     *            {@link Method#POST} and {@link Method#PUT} are available. If
-     *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
-     *            is appended to the formUri to be compliant with RESTful APIs.
-     * 
-     * @param type
-     *            {@link Type} of encoding used to send the report body.
-     *            {@link Type#FORM} is a simple Key/Value pairs list as defined
-     *            by the application/x-www-form-urlencoded mime type.
-     * 
-     * @param mapping
-     *            Applies only to {@link Method#POST} method parameter. If null,
-     *            POST parameters will be named with {@link ReportField} values
-     *            converted to String with .toString(). If not null, POST
-     *            parameters will be named with the result of
-     *            mapping.get(ReportField.SOME_FIELD);
-     */
-    public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
-        mMethod = method;
-        mFormUri = null;
-        mMapping = mapping;
-        mType = type;
-        mUsername = null;
-        mPassword = null;
-    }
-
-    /**
-     * <p>
-     * Create a new HttpPostSender instance with a fixed destination provided as
-     * a parameter. Configuration changes to the formUri are not applied.
-     * </p>
-     * 
-     * @param method
-     *            HTTP {@link Method} to be used to send data. Currently only
-     *            {@link Method#POST} and {@link Method#PUT} are available. If
-     *            {@link Method#PUT} is used, the {@link ReportField#REPORT_ID}
-     *            is appended to the formUri to be compliant with RESTful APIs.
-     * 
-     * @param type
-     *            {@link Type} of encoding used to send the report body.
-     *            {@link Type#FORM} is a simple Key/Value pairs list as defined
-     *            by the application/x-www-form-urlencoded mime type.
-     * @param formUri
-     *            The URL of your server-side crash report collection script.
-     * @param mapping
-     *            Applies only to {@link Method#POST} method parameter. If null,
-     *            POST parameters will be named with {@link ReportField} values
-     *            converted to String with .toString(). If not null, POST
-     *            parameters will be named with the result of
-     *            mapping.get(ReportField.SOME_FIELD);
-     */
-    public HttpSender(Method method, Type type, String formUri, Map<ReportField, String> mapping) {
-        mMethod = method;
-        mFormUri = Uri.parse(formUri);
-        mMapping = mapping;
-        mType = type;
-        mUsername = null;
-        mPassword = null;        
-    }
-    
-    /**
-     * <p>
-     * Set credentials for this HttpSender that override (if present) the ones
-     * set globally.
-     * </p>
-     * 
-     * @param username
-     *            The username to set for HTTP Basic Auth.
-     * @param password
-     *            The password to set for HTTP Basic Auth.
-     */
-    @SuppressWarnings( "unused" )
-    public void setBasicAuth(String username, String password) {
-        mUsername = username;
-        mPassword = password;
-    }    
-
-    @Override
-    public void send(Context context, CrashReportData report) throws ReportSenderException {
-
-        try {
-            URL reportUrl = mFormUri == null ? new URL(ACRA.getConfig().formUri()) : new URL(mFormUri.toString());
-            ACRA.log.d(LOG_TAG, "Connect to " + reportUrl.toString());
-
-            final String login = mUsername != null ? mUsername : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthLogin()) ? null : ACRA
-                    .getConfig().formUriBasicAuthLogin();
-            final String password = mPassword != null ? mPassword : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthPassword()) ? null : ACRA
-                    .getConfig().formUriBasicAuthPassword();
-
-            final HttpRequest request = new HttpRequest();
-            request.setConnectionTimeOut(ACRA.getConfig().connectionTimeout());
-            request.setSocketTimeOut(ACRA.getConfig().socketTimeout());
-            request.setMaxNrRetries(ACRA.getConfig().maxNumberOfRequestRetries());
-            request.setLogin(login);
-            request.setPassword(password);
-            request.setHeaders(ACRA.getConfig().getHttpHeaders());
-
-            // Generate report body depending on requested type
-            final String reportAsString;
-            switch (mType) {
-            case JSON:
-                reportAsString = report.toJSON().toString();
-                break;
-            case FORM:
-            default:
-                final Map<String, String> finalReport = remap(report);
-                reportAsString = HttpRequest.getParamsAsFormString(finalReport);
-                break;
-
-            }
-
-            // Adjust URL depending on method
-            switch (mMethod) {
-            case POST:
-                break;
-            case PUT:
-                reportUrl = new URL(reportUrl.toString() + '/' + report.getProperty(ReportField.REPORT_ID));
-                break;
-            default:
-                throw new UnsupportedOperationException("Unknown method: " + mMethod.name());
-            }
-            request.send(context, reportUrl, mMethod, reportAsString, mType);
-
-        } catch (IOException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
-                    + " report via Http " + mMethod.name(), e);
-        } catch (JSONReportException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
-                    + " report via Http " + mMethod.name(), e);
-        }
-    }
-
-    private Map<String, String> remap(Map<ReportField, String> report) {
-
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if (fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_REPORT_FIELDS;
-        }
-
-        final Map<String, String> finalReport = new HashMap<String, String>(report.size());
-        for (ReportField field : fields) {
-            if (mMapping == null || mMapping.get(field) == null) {
-                finalReport.put(field.toString(), report.get(field));
-            } else {
-                finalReport.put(mMapping.get(field), report.get(field));
-            }
-        }
-        return finalReport;
-    }
-
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
deleted file mode 100644
index c5b69bb3..00000000
--- a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.acra.util;
-
-import android.content.Context;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-
-/**
- * Default implementation of a HttpSocketFactoryFactory.
- */
-public final class DefaultHttpsSocketFactoryFactory implements HttpsSocketFactoryFactory {
-
-    public static final HttpsSocketFactoryFactory INSTANCE = new DefaultHttpsSocketFactoryFactory();
-
-    @Override
-    public SocketFactory create(Context context) {
-        return new TlsSniSocketFactory();
-    }
-}
diff --git a/src/main/java/org/acra/util/FakeSocketFactory.java b/src/main/java/org/acra/util/FakeSocketFactory.java
deleted file mode 100644
index 73b9a5c2..00000000
--- a/src/main/java/org/acra/util/FakeSocketFactory.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Utility class copied from http://transdroid.googlecode.com with the authorization from Eric Kok to redistribute it under Apache Software License. 
- */
-package org.acra.util;
-
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.TrustManager;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-
-public class FakeSocketFactory implements SocketFactory, LayeredSocketFactory {
-
-    private SSLContext sslcontext = null;
-
-    private static SSLContext createEasySSLContext() throws IOException {
-        try {
-            final SSLContext context = SSLContext.getInstance("TLS");
-            context.init(null, new TrustManager[] { new NaiveTrustManager() }, null);
-            return context;
-        } catch (Exception e) {
-            throw new IOException(e.getMessage());
-        }
-    }
-
-    private SSLContext getSSLContext() throws IOException {
-        if (this.sslcontext == null) {
-            this.sslcontext = createEasySSLContext();
-        }
-        return this.sslcontext;
-    }
-
-    @Override
-    public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        final int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
-        final int soTimeout = HttpConnectionParams.getSoTimeout(params);
-
-        final InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
-        final SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());
-
-        if ((localAddress != null) || (localPort > 0)) {
-            // we need to bind explicitly
-            if (localPort < 0) {
-                localPort = 0; // indicates "any"
-            }
-            final InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
-            sslsock.bind(isa);
-        }
-
-        sslsock.connect(remoteAddress, connTimeout);
-        sslsock.setSoTimeout(soTimeout);
-
-        return sslsock;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return getSSLContext().getSocketFactory().createSocket();
-    }
-
-    @Override
-    public boolean isSecure(Socket arg0) throws IllegalArgumentException {
-        return true;
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
-        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
-
-}
diff --git a/src/main/java/org/acra/util/HttpRequest.java b/src/main/java/org/acra/util/HttpRequest.java
deleted file mode 100644
index 20b5133e..00000000
--- a/src/main/java/org/acra/util/HttpRequest.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * This class was copied from this Stackoverflow Q&A:
- * http://stackoverflow.com/questions/2253061/secure-http-post-in-android/2253280#2253280
- * Thanks go to MattC!  
- */
-package org.acra.util;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.net.URLEncoder;
-import java.security.KeyManagementException;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.UnrecoverableKeyException;
-import java.util.Map;
-
-import android.content.Context;
-import org.acra.ACRA;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.params.ClientPNames;
-import org.apache.http.client.params.CookiePolicy;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.impl.auth.BasicScheme;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.SingleClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.protocol.BasicHttpContext;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.util.EntityUtils;
-
-import static org.acra.ACRA.LOG_TAG;
-
-public final class HttpRequest {
-
-    private static class SocketTimeOutRetryHandler implements HttpRequestRetryHandler {
-
-        private final HttpParams httpParams;
-        private final int maxNrRetries;
-
-        /**
-         * @param httpParams
-         *            HttpParams that will be used in the HttpRequest.
-         * @param maxNrRetries
-         *            Max number of times to retry Request on failure due to
-         *            SocketTimeOutException.
-         */
-        private SocketTimeOutRetryHandler(HttpParams httpParams, int maxNrRetries) {
-            this.httpParams = httpParams;
-            this.maxNrRetries = maxNrRetries;
-        }
-
-        @Override
-        public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-            if (exception instanceof SocketTimeoutException) {
-                if (executionCount <= maxNrRetries) {
-
-                    if (httpParams != null) {
-                        final int newSocketTimeOut = HttpConnectionParams.getSoTimeout(httpParams) * 2;
-                        HttpConnectionParams.setSoTimeout(httpParams, newSocketTimeOut);
-                        ACRA.log.d(LOG_TAG, "SocketTimeOut - increasing time out to " + newSocketTimeOut
-                                + " millis and trying again");
-                    } else {
-                        ACRA.log.d(LOG_TAG,
-                                "SocketTimeOut - no HttpParams, cannot increase time out. Trying again with current settings");
-                    }
-
-                    return true;
-                }
-
-                ACRA.log.d(LOG_TAG, "SocketTimeOut but exceeded max number of retries : " + maxNrRetries);
-            }
-
-            return false; // To change body of implemented methods use File |
-                          // Settings | File Templates.
-        }
-    }
-
-    private String login;
-    private String password;
-    private int connectionTimeOut = 3000;
-    private int socketTimeOut = 3000;
-    private int maxNrRetries = 3;
-    private Map<String,String> headers;
-    
-    public void setLogin(String login) {
-        this.login = login;
-    }
-
-    public void setPassword(String password) {
-        this.password = password;
-    }
-
-    public void setConnectionTimeOut(int connectionTimeOut) {
-        this.connectionTimeOut = connectionTimeOut;
-    }
-
-    public void setSocketTimeOut(int socketTimeOut) {
-        this.socketTimeOut = socketTimeOut;
-    }
-
-    public void setHeaders(Map<String,String> headers) {
-       this.headers = headers;
-    }
-
-    
-    /**
-     * The default number of retries is 3.
-     * 
-     * @param maxNrRetries
-     *            Max number of times to retry Request on failure due to
-     *            SocketTimeOutException.
-     */
-    public void setMaxNrRetries(int maxNrRetries) {
-        this.maxNrRetries = maxNrRetries;
-    }
-
-    /**
-     * Posts to a URL.
-     * 
-     *
-     * @param context   Android context for which to create the SocketFactory.
-     * @param url       URL to which to post.
-     * @param content   Map of parameters to post to a URL.
-     * @throws IOException if the data cannot be posted.
-     */
-    public void send(Context context, URL url, Method method, String content, Type type) throws IOException {
-
-        final HttpClient httpClient = getHttpClient(context);
-        final HttpEntityEnclosingRequestBase httpRequest = getHttpRequest(url, method, content, type);
-
-        ACRA.log.d(LOG_TAG, "Sending request to " + url);
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(LOG_TAG, "Http " + method.name() + " content : ");
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(LOG_TAG, content);
-
-        HttpResponse response = null;
-        try {
-            response = httpClient.execute(httpRequest, new BasicHttpContext());
-            if (response != null) {
-                final StatusLine statusLine = response.getStatusLine();
-                if (statusLine != null) {
-                    final String statusCode = Integer.toString(response.getStatusLine().getStatusCode());
-    
-                    if (!statusCode.equals("409") // 409 return code means that the
-                                                  // report has been received
-                                                  // already. So we can discard it.
-                            && !statusCode.equals("403") // a 403 error code is an explicit data validation refusal
-                                                         // from the server. The request must not be repeated.
-                                                         // Discard it.
-                            && (statusCode.startsWith("4") || statusCode.startsWith("5"))) {
-                        if (ACRA.DEV_LOGGING) {
-                            ACRA.log.d(LOG_TAG, "Could not send HttpPost : " + httpRequest);
-                            ACRA.log.d(LOG_TAG, "HttpResponse Status : "
-                                    + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                            final String respContent = EntityUtils.toString(response.getEntity());
-                            ACRA.log.d(LOG_TAG,
-                                    "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-                        }
-                        throw new IOException("Host returned error code " + statusCode);
-                    }
-                }
-
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG, "HttpResponse Status : "
-                            + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                final String respContent = EntityUtils.toString(response.getEntity());
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG,
-                            "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-
-            } else {
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(LOG_TAG, "HTTP no Response!!");
-            }
-        } finally {
-            if (response != null) {
-				response.getEntity().consumeContent();
-			}
-        }
-    }
-
-    /**
-     * @return HttpClient to use with this HttpRequest.
-     */
-    private HttpClient getHttpClient(Context context) {
-        final HttpParams httpParams = new BasicHttpParams();
-        httpParams.setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.RFC_2109);
-        HttpConnectionParams.setConnectionTimeout(httpParams, connectionTimeOut);
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeOut);
-        HttpConnectionParams.setSocketBufferSize(httpParams, 8192);
-
-        final SchemeRegistry registry = new SchemeRegistry();
-        registry.register(new Scheme("http", new PlainSocketFactory(), 80));
-        if (ACRA.getConfig().disableSSLCertValidation()) {
-            registry.register(new Scheme("https", (new FakeSocketFactory()), 443));
-        } else if (ACRA.getConfig().keyStore() != null) {
-            try {
-                SSLSocketFactory sf = new SSLSocketFactory(ACRA.getConfig().keyStore());
-                sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
-                registry.register(new Scheme("https", sf, 443));
-            } catch (KeyManagementException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (UnrecoverableKeyException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (NoSuchAlgorithmException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (KeyStoreException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            }
-        } else {
-            final HttpsSocketFactoryFactory factory = ACRA.getConfig().getHttpSocketFactoryFactory();
-            final SocketFactory socketFactory = factory.create(context);
-            registry.register(new Scheme("https", socketFactory, 443));
-        }
-
-        final ClientConnectionManager clientConnectionManager = new SingleClientConnManager(httpParams, registry);
-        final DefaultHttpClient httpClient = new DefaultHttpClient(clientConnectionManager, httpParams);
-
-        final HttpRequestRetryHandler retryHandler = new SocketTimeOutRetryHandler(httpParams, maxNrRetries);
-        httpClient.setHttpRequestRetryHandler(retryHandler);
-
-        return httpClient;
-    }
-
-    /**
-     * @return Credentials to use with this HttpRequest or null if no
-     *         credentials were supplied.
-     */
-    private UsernamePasswordCredentials getCredentials() {
-        if (login != null || password != null) {
-            return new UsernamePasswordCredentials(login, password);
-        }
-
-        return null;
-    }
-
-    private HttpEntityEnclosingRequestBase getHttpRequest(URL url, Method method, String content, Type type)
-            throws UnsupportedEncodingException, UnsupportedOperationException {
-
-        final HttpEntityEnclosingRequestBase httpRequest;
-        switch (method) {
-        case POST:
-            httpRequest = new HttpPost(url.toString());
-            break;
-        case PUT:
-            httpRequest = new HttpPut(url.toString());
-            break;
-        default:
-            throw new UnsupportedOperationException("Unknown method: " + method.name());
-        }
-
-        final UsernamePasswordCredentials creds = getCredentials();
-        if (creds != null) {
-            httpRequest.addHeader(BasicScheme.authenticate(creds, "UTF-8", false));
-        }
-        httpRequest.setHeader("User-Agent", "Android");
-        httpRequest
-                .setHeader("Accept",
-                        "text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
-        httpRequest.setHeader("Content-Type", type.getContentType());
-
-        if(headers != null) {
-            for (final String header : headers.keySet()) {
-              final String value = headers.get(header);
-              httpRequest.setHeader(header, value);
-           }
-        }
-        
-        httpRequest.setEntity(new StringEntity(content, "UTF-8"));
-
-        return httpRequest;
-    }
-
-    /**
-     * Converts a Map of parameters into a URL encoded Sting.
-     * 
-     * @param parameters
-     *            Map of parameters to convert.
-     * @return URL encoded String representing the parameters.
-     * @throws UnsupportedEncodingException
-     *             if one of the parameters couldn't be converted to UTF-8.
-     */
-    public static String getParamsAsFormString(Map<?, ?> parameters) throws UnsupportedEncodingException {
-
-        final StringBuilder dataBfr = new StringBuilder();
-        for (final Object key : parameters.keySet()) {
-            if (dataBfr.length() != 0) {
-                dataBfr.append('&');
-            }
-            final Object preliminaryValue = parameters.get(key);
-            final Object value = (preliminaryValue == null) ? "" : preliminaryValue;
-            dataBfr.append(URLEncoder.encode(key.toString(), "UTF-8"));
-            dataBfr.append('=');
-            dataBfr.append(URLEncoder.encode(value.toString(), "UTF-8"));
-        }
-
-        return dataBfr.toString();
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
deleted file mode 100644
index 398975d1..00000000
--- a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.acra.util;
-
-import android.content.Context;
-import org.apache.http.conn.scheme.SocketFactory;
-
-/**
- * Factory that creates an instance of a Https SocketFactory.
- */
-public interface HttpsSocketFactoryFactory {
-
-    /**
-     * @param context   Android context for which to create the SocketFactory.
-     * @return SocketFactory that was created.
-     */
-    public SocketFactory create(Context context);
-}
diff --git a/src/main/java/org/acra/util/JSONReportBuilder.java b/src/main/java/org/acra/util/JSONReportBuilder.java
deleted file mode 100644
index d0a19faa..00000000
--- a/src/main/java/org/acra/util/JSONReportBuilder.java
+++ /dev/null
@@ -1,237 +0,0 @@
-package org.acra.util;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.StringReader;
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.Locale;
-
-import org.acra.ACRA;
-import org.acra.ReportField;
-import org.acra.collector.CollectorUtil;
-import org.acra.collector.CrashReportData;
-import org.acra.sender.ReportSenderException;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import static org.acra.ACRA.LOG_TAG;
-
-public class JSONReportBuilder {
-    /**
-     * <p>
-     * Create a JSONObject containing the whole report data with the most
-     * detailed possible structure depth. Fields are not just converted to a
-     * single key=value pair. If a value can be decomposed into subobjects, it
-     * is done.
-     * </p>
-     *
-     * <p>
-     * For example, a String containing:
-     *
-     * <pre>
-     * some.key.name1=value1
-     * some.key.name2=value2
-     * some.other=value3
-     * any.other.key=value4
-     * key.without.value5
-     * </pre>
-     *
-     * is converted to
-     *
-     * <pre>
-     * {
-     *   some : {
-     *     key : {
-     *       name1 : "value1",
-     *       name2 : "value2"
-     *     },
-     *     other : "value3"
-     *   },
-     *   any : {
-     *     other : {
-     *       key : "value4"
-     *     }
-     *   }
-     *   key.without.value : true
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param errorContent
-     *            The ACRA report data structure.
-     * @return A JSONObject containing all fields from the report converted to
-     *         JSON.
-     * @throws ReportSenderException
-     * @throws JSONReportException
-     */
-    public static JSONObject buildJSONReport(CrashReportData errorContent) throws JSONReportException {
-        JSONObject jsonReport = new JSONObject();
-        BufferedReader reader = null;
-        for (ReportField key : errorContent.keySet()) {
-            try {
-                // Each ReportField can be identified as a substructure and not
-                // a simple String value.
-                if (key.containsKeyValuePairs()) {
-                    JSONObject subObject = new JSONObject();
-                    String strContent = errorContent.getProperty(key);
-                    reader = new BufferedReader(new StringReader(strContent), 1024);
-                    String line = null;
-                    try {
-                        while ((line = reader.readLine()) != null) {
-                            addJSONFromProperty(subObject, line);
-                        }
-                    } catch (IOException e) {
-                        ACRA.log.e(LOG_TAG, "Error while converting " + key.name() + " to JSON.", e);
-                    }
-                    jsonReport.accumulate(key.name(), subObject);
-                } else {
-                    // This field is a simple String value, store it as it is
-                    jsonReport.accumulate(key.name(), guessType(errorContent.getProperty(key)));
-                }
-            } catch (JSONException e) {
-                throw new JSONReportException("Could not create JSON object for key " + key, e);
-            } finally {
-            	CollectorUtil.safeClose(reader);
-            }
-        }
-        return jsonReport;
-    }
-
-    /**
-     * <p>
-     * Given a String containing key=value pairs on each line, adds a detailed
-     * JSON structure to an existing JSONObject, reusing intermediate subobjects
-     * if available when keys are composed of a succession of subkeys delimited
-     * by dots.
-     * </p>
-     *
-     * <p>
-     * For example, adding the string "metrics.xdpi=160.0" to an object
-     * containing
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * results in
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0", "xdpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param destination
-     *            The JSONObject where the data must be inserted.
-     * @param propertyString
-     *            A string containing "some.key.name=Any value"
-     * @throws JSONException
-     */
-    private static void addJSONFromProperty(JSONObject destination, String propertyString) throws JSONException {
-        int equalsIndex = propertyString.indexOf('=');
-        if (equalsIndex > 0) {
-            JSONObject finalObject = destination;
-            String currentKey = propertyString.substring(0, equalsIndex).trim();
-            String currentValue = propertyString.substring(equalsIndex + 1).trim();
-            Object value = guessType(currentValue);
-            if(value instanceof String) {
-                value = ((String) value).replaceAll("\\\\n","\n");
-            }
-            String[] splitKey = currentKey.split("\\.");
-            if (splitKey.length > 1) {
-                addJSONSubTree(finalObject, splitKey, value);
-            } else {
-                finalObject.accumulate(currentKey, value);
-            }
-        } else {
-            destination.put(propertyString.trim(), true);
-        }
-    }
-
-    private static Object guessType(String value) {
-        if (value.equalsIgnoreCase("true"))
-            return true;
-        if (value.equalsIgnoreCase("false"))
-            return false;
-
-        if (value.matches("(?:^|\\s)([1-9](?:\\d*|(?:\\d{0,2})(?:,\\d{3})*)(?:\\.\\d*[1-9])?|0?\\.\\d*[1-9]|0)(?:\\s|$)")) {
-            NumberFormat format = NumberFormat.getInstance(Locale.US);
-            try {
-                Number number = format.parse(value);
-                return number;
-            } catch (ParseException e) {
-                // never mind
-            }
-        }
-        return value;
-    }
-
-    /**
-     * Deep insert a value inside a JSONObject, reusing existing subobjects when
-     * available or creating them when necessary.
-     *
-     * @param destination
-     *            The JSONObject which receives the additional subitem.
-     * @param keys
-     *            An array containing the path keys leading to where the value
-     *            has to be inserted.
-     * @param value
-     *            The value to be inserted.
-     * @throws JSONException
-     */
-    private static void addJSONSubTree(JSONObject destination, String[] keys, Object value) throws JSONException {
-        for (int i = 0; i < keys.length; i++) {
-            String subKey = keys[i];
-            if (i < keys.length - 1) {
-                JSONObject intermediate = null;
-                if (destination.isNull(subKey)) {
-                    intermediate = new JSONObject();
-                    destination.accumulate(subKey, intermediate);
-                } else {
-                    Object target = destination.get(subKey);
-                    if (target instanceof JSONObject) {
-                        intermediate = destination.getJSONObject(subKey);
-                    } else if (target instanceof JSONArray) {
-                        // Unexpected JSONArray, see issue #186
-                        JSONArray wildCard = destination.getJSONArray(subKey);
-                        for (int j = 0; j < wildCard.length(); j++) {
-                            intermediate = wildCard.optJSONObject(j);
-                            if (intermediate != null) {
-                                // Found the original JSONObject we were looking for
-                                break;
-                            }
-                        }
-                    }
-
-                    if (intermediate == null) {
-                        ACRA.log.e(LOG_TAG, "Unknown json subtree type, see issue #186");
-                        // We should never get here, but if we do, drop this value to still send the report
-                        return;
-                    }
-                }
-                destination = intermediate;
-            } else {
-                destination.accumulate(subKey, value);
-            }
-        }
-    }
-
-    public static class JSONReportException extends Exception {
-        private static final long serialVersionUID = -694684023635442219L;
-
-        public JSONReportException(String message, Throwable e) {
-            super(message, e);
-        }
-    };
-}
diff --git a/src/main/java/org/acra/util/NaiveTrustManager.java b/src/main/java/org/acra/util/NaiveTrustManager.java
deleted file mode 100644
index 57746ecd..00000000
--- a/src/main/java/org/acra/util/NaiveTrustManager.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.util;
-
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.X509TrustManager;
-
-/**
- * Accepts any certificate, ideal for self-signed certificates.
- */
-class NaiveTrustManager implements X509TrustManager {
-    /*
-     * (non-Javadoc)
-     * 
-     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
-     */
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-        return new X509Certificate[0];
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkClientTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkClientTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkServerTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkServerTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/ReflectionException.java b/src/main/java/org/acra/util/ReflectionException.java
deleted file mode 100644
index 16bb0e26..00000000
--- a/src/main/java/org/acra/util/ReflectionException.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.acra.util;
-
-/**
- * Thrown when an error occurs during reflection.
- */
-public final class ReflectionException extends Exception  {
-
-    public ReflectionException(String msg, Throwable th) {
-        super(msg, th);
-    }
-}
diff --git a/src/main/java/org/acra/util/ReflectionHelper.java b/src/main/java/org/acra/util/ReflectionHelper.java
deleted file mode 100644
index 6463e309..00000000
--- a/src/main/java/org/acra/util/ReflectionHelper.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.acra.util;
-
-/**
- * Helps to construct objects via reflection.
- */
-public final class ReflectionHelper {
-
-    public Object create(String className) throws ReflectionException {
-        try {
-            final Class clazz = Class.forName(className);
-            return clazz.newInstance();
-        } catch (ClassNotFoundException e) {
-            throw new ReflectionException("Could not find class : " + className, e);
-        } catch (InstantiationException e) {
-            throw new ReflectionException("Could not instantiate class : " + className, e);
-        } catch (IllegalAccessException e) {
-            throw new ReflectionException("Could not access class : " + className, e);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/util/ReportUtils.java b/src/main/java/org/acra/util/ReportUtils.java
deleted file mode 100644
index 39684455..00000000
--- a/src/main/java/org/acra/util/ReportUtils.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package org.acra.util;
-
-import java.io.File;
-import java.net.InetAddress;
-import java.net.NetworkInterface;
-import java.net.SocketException;
-import java.text.SimpleDateFormat;
-import java.util.Enumeration;
-import java.util.Locale;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-
-import android.content.Context;
-import android.os.Environment;
-import android.os.StatFs;
-import android.telephony.TelephonyManager;
-import android.text.format.Time;
-import android.util.SparseArray;
-
-import static org.acra.ACRA.LOG_TAG;
-
-/**
- * Responsible for providing base utilities used when constructing the report.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class ReportUtils {
-
-    /**
-     * Calculates the free memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Number of bytes available.
-     */
-    public static long getAvailableInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long availableBlocks = stat.getAvailableBlocks();
-        return availableBlocks * blockSize;
-    }
-
-    /**
-     * Calculates the total memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Total number of bytes.
-     */
-    public static long getTotalInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long totalBlocks = stat.getBlockCount();
-        return totalBlocks * blockSize;
-    }
-
-    /**
-     * Returns the DeviceId according to the TelephonyManager.
-     *
-     * @param context   Context for the application being reported.
-     * @return Returns the DeviceId according to the TelephonyManager or null if there is no TelephonyManager.
-     */
-    public static String getDeviceId(Context context) {
-        try {
-            final TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-            return tm.getDeviceId();
-        } catch (RuntimeException e) {
-            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceId for : " + context.getPackageName(), e);
-            return null;
-        }
-    }
-
-    public static String getApplicationFilePath(Context context) {
-        final File filesDir = context.getFilesDir();
-        if (filesDir != null) {
-            return filesDir.getAbsolutePath();
-        }
-
-        ACRA.log.w(LOG_TAG, "Couldn't retrieve ApplicationFilePath for : " + context.getPackageName());
-        return "Couldn't retrieve ApplicationFilePath";
-    }
-    
-    /**
-     * Utility method used for debugging purposes, writes the content of a SparseArray to a String.
-     * @param sparseArray
-     * @return "{ key1 => value1, key2 => value2, ...}"
-     */
-    public static String sparseArrayToString(SparseArray<?> sparseArray) {
-        StringBuilder result = new StringBuilder();
-        if (sparseArray == null) {
-            return "null";
-        }
-
-        result.append('{');
-        for (int i = 0; i < sparseArray.size(); i++) {
-            result.append(sparseArray.keyAt(i));
-            result.append(" => ");
-            if (sparseArray.valueAt(i) == null) {
-                result.append("null");
-            } else {
-                result.append(sparseArray.valueAt(i).toString());
-            }
-            if(i < sparseArray.size() - 1) {
-                result.append(", ");
-            }
-        }
-        result.append('}');
-        return result.toString();
-    }
-
-    public static String getLocalIpAddress() {
-        StringBuilder result = new StringBuilder();
-        boolean first = true;
-        try {
-            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
-                NetworkInterface intf = en.nextElement();
-                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
-                    InetAddress inetAddress = enumIpAddr.nextElement();
-                    if (!inetAddress.isLoopbackAddress()) {
-                        if(!first) {
-                            result.append('\n');
-                        }
-                        result.append(inetAddress.getHostAddress().toString());
-                        first = false;
-                    }
-                }
-            }
-        } catch (SocketException ex) {
-            ACRA.log.w(LOG_TAG, ex.toString());
-        }
-        return result.toString();
-    }
-
-    public static String getTimeString(Time time)
-    {
-        SimpleDateFormat format = new SimpleDateFormat(ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
-        return format.format(time.toMillis(true));
-    }
-}
diff --git a/src/main/java/org/acra/util/TlsSniSocketFactory.java b/src/main/java/org/acra/util/TlsSniSocketFactory.java
deleted file mode 100644
index 06a25c45..00000000
--- a/src/main/java/org/acra/util/TlsSniSocketFactory.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * This class was copied from this blog post:
- * http://blog.dev001.net/post/67082904181/android-using-sni-and-tlsv1-2-with-apache-httpclient
- * Thanks go to Dev001!
- * Also, changes for using only secure cipher suites were included from code of DAVdroid.
- * Thankgs go to Ricki Hirner (bitfire web engineering)!
- */
-package org.acra.util;
-
-import android.net.SSLCertificateSocketFactory;
-import android.os.Build;
-import android.text.TextUtils;
-
-import org.acra.ACRA;
-import org.acra.collector.Compatibility;
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.ssl.BrowserCompatHostnameVerifier;
-import org.apache.http.params.HttpParams;
-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-
-/**
- * Provides a SSLSocketFactory that is able to use SNI for SSL connections and
- * therefore allows multiple SSL servers on one IP address.<br/>
- *   1) socket = createSocket() is called
- *   2) reasonable encryption settings are applied to socket
- *   3) SNI is set up for socket
- *   4) handshake and certificate/host name verification
- * <p/>
- * @author Philipp Kapfer
- * @since 4.6.0
- */
-public class TlsSniSocketFactory implements LayeredSocketFactory {
-
-    private static final String TAG =  TlsSniSocketFactory.class.getSimpleName();
-    
-    private final SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getDefault(0);
-
-    // use BrowserCompatHostnameVerifier to allow IP addresses in the Common Name
-    private final static HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
-
-    private static final List<String> ALLOWED_CIPHERS = Arrays.asList(
-        // allowed secure ciphers according to NIST.SP.800-52r1.pdf Section 3.3.1 (see http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r1.pdf)
-        // TLS 1.2
-        "TLS_RSA_WITH_AES_256_GCM_SHA384",
-        "TLS_RSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256",
-        // maximum interoperability
-        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_RSA_WITH_AES_128_CBC_SHA",
-        // additionally
-        "TLS_RSA_WITH_AES_256_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
-    );
-
-    // Plain TCP/IP (layer below TLS)
-
-    @Override
-    public Socket connectSocket(Socket s, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        return null;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return null;
-    }
-
-    @Override
-    public boolean isSecure(Socket s) throws IllegalArgumentException {
-        return (s instanceof SSLSocket) && s.isConnected();
-    }
-
-
-    // TLS layer
-
-    @Override
-    public Socket createSocket(Socket plainSocket, String host, int port, boolean autoClose) throws IOException {
-        if (autoClose) {
-            // we don't need the plainSocket
-            plainSocket.close();
-        }
-
-        // create and connect SSL socket, but don't do hostname/certificate verification yet
-        final SSLSocket ssl = (SSLSocket) sslSocketFactory.createSocket(InetAddress.getByName(host), port);
-
-        // establish and verify TLS connection
-        establishAndVerify(ssl, host);
-
-        return ssl;
-    }
-    
-    /**
-     * Establishes and verifies a TLS connection to a (TCP-)connected SSLSocket:
-     *   - set TLS parameters like allowed protocols and ciphers
-     *   - set SNI host name
-     *   - verify host name
-     *   - verify certificate
-     * @param socket    unconnected SSLSocket
-     * @param host      host name for SNI
-     * @throws IOException if the connection could not be established.
-     */
-    private void establishAndVerify(SSLSocket socket, String host) throws IOException {
-        setTlsParameters(socket);
-        setSniHostname(socket, host);
-        
-        // TLS handshake, throws an exception for untrusted certificates
-        socket.startHandshake();
-
-        // verify hostname and certificate
-        SSLSession session = socket.getSession();
-        if (!hostnameVerifier.verify(host, session)) {
-            // throw exception for invalid host names
-            throw new SSLPeerUnverifiedException(host);
-        }
-
-        ACRA.log.i(TAG, "Established " + session.getProtocol() + " connection with " + session.getPeerHost() + " using " + session.getCipherSuite());
-    }
-    
-    /**
-     * Prepares a TLS/SSL connection socket by:
-     *   - setting reasonable TLS protocol versions
-     *   - setting reasonable cipher suites (if required)
-     * @param socket   unconnected SSLSocket to prepare
-     */
-    private void setTlsParameters(SSLSocket socket) {
-        // Android 5.0+ (API level21) provides reasonable default settings
-        // but it still allows SSLv3
-        // https://developer.android.com/about/versions/android-5.0-changes.html#ssl
-
-        /* set reasonable protocol versions */
-        // - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android <5.0)
-        // - remove all SSL versions (especially SSLv3) because they're insecure now
-        final List<String> protocols = new LinkedList<String>();
-        for (String protocol : socket.getSupportedProtocols()) {
-            if (!protocol.toUpperCase().contains("SSL")) {
-                protocols.add(protocol);
-            }
-        }
-        ACRA.log.v(TAG, "Setting allowed TLS protocols: " + TextUtils.join(", ", protocols));
-        socket.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));
-
-        /* set reasonable cipher suites */
-        if (Compatibility.getAPILevel() < Compatibility.VERSION_CODES.LOLLIPOP) {
-            // choose secure cipher suites
-
-            final List<String> availableCiphers = Arrays.asList(socket.getSupportedCipherSuites());
-            
-            // preferred ciphers = allowed Ciphers \ availableCiphers
-            final Set<String> preferredCiphers = new HashSet<String>(ALLOWED_CIPHERS);
-            preferredCiphers.retainAll(availableCiphers);
-            
-            // add enabled ciphers to preferred ciphers
-            // for maximum security, preferred ciphers should *replace* enabled ciphers,
-            // but for the security level of ACRA, disabling of insecure
-            // ciphers should be a server-side task
-            preferredCiphers.addAll(Arrays.asList(socket.getEnabledCipherSuites()));
-            
-            ACRA.log.v(TAG, "Setting allowed TLS ciphers: " + TextUtils.join(", ", preferredCiphers));
-            socket.setEnabledCipherSuites(preferredCiphers.toArray(new String[preferredCiphers.size()]));
-        }
-    }
-    
-    private void setSniHostname(SSLSocket socket, String hostName) {
-        // set SNI host name
-        if (Compatibility.getAPILevel() >= Compatibility.VERSION_CODES.JELLY_BEAN_MR1) {
-            ACRA.log.d(TAG, "Using documented SNI with host name " + hostName);
-            sslSocketFactory.setHostname(socket, hostName);
-        } else {
-            ACRA.log.d(TAG, "No documented SNI support on Android <4.2, trying reflection method with host name " + hostName);
-            try {
-                final Method setHostnameMethod = socket.getClass().getMethod("setHostname", String.class);
-                setHostnameMethod.invoke(socket, hostName);
-            } catch (Exception e) {
-                ACRA.log.w(TAG, "SNI not usable", e);
-            }
-        }
-    }
-}
diff --git a/src/test/java/org/acra/log/NonAndroidLog.java b/src/test/java/org/acra/log/NonAndroidLog.java
deleted file mode 100644
index dad35e3b..00000000
--- a/src/test/java/org/acra/log/NonAndroidLog.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package org.acra.log;
-
-
-import java.io.PrintStream;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-
-/**
- * Responsible for delegating calls to the Android logging system.
- * <p/>
- * User: William
- * Date: 17/07/11
- * Time: 11:06 AM
- */
-public final class NonAndroidLog implements ACRALog {
-
-    // Not that it really matters but these levels match those used in Android.util.Log
-    public static final int VERBOSE = 2;
-    public static final int DEBUG = 3;
-    public static final int INFO = 4;
-    public static final int WARN = 5;
-    public static final int ERROR = 6;
-    //public static final int ASSERT = 7;
-
-    private int logLevel = VERBOSE;
-    private final PrintStream out = System.out;
-
-    /**
-     * Any log that is output at level less that the supplied logLevel will be ignored.
-     * <p>
-     *     The deault log level is {@link NonAndroidLog#VERBOSE}
-     * </p>
-     *
-     * @param logLevel LogLevel to use to filter log output.
-     */
-    public void setLogLevel(int logLevel) {
-        this.logLevel = logLevel;
-    }
-
-    public int v(String tag, String msg) {
-        if (logLevel <= VERBOSE) {
-            out.println(tag + " : " + msg);
-        }
-        return 0;
-    }
-
-    public int v(String tag, String msg, Throwable tr) {
-        if (logLevel <= VERBOSE) {
-            out.println(tag + " : " + msg);
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    public int d(String tag, String msg) {
-        if (logLevel <= DEBUG) {
-            out.println(tag + " : " + msg);
-        }
-        return 0;
-    }
-
-    public int d(String tag, String msg, Throwable tr) {
-        if (logLevel <= DEBUG) {
-            out.println(tag + " : " + msg);
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    public int i(String tag, String msg) {
-        if (logLevel <= INFO) {
-            out.println(tag + " : " + msg);
-        }
-        return 0;
-    }
-
-    public int i(String tag, String msg, Throwable tr) {
-        if (logLevel <= INFO) {
-            out.println(tag + " : " + msg);
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    public int w(String tag, String msg) {
-        if (logLevel <= WARN) {
-            out.println(tag + " : " + msg);
-        }
-        return 0;
-    }
-
-    public int w(String tag, String msg, Throwable tr) {
-        if (logLevel <= WARN) {
-            out.println(tag + " : " + msg);
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(String tag, Throwable tr) {
-        if (logLevel <= WARN) {
-            out.println(tag + " : ");
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    public int e(String tag, String msg) {
-        if (logLevel <= ERROR) {
-            out.println(tag + " : " + msg);
-        }
-        return 0;
-    }
-
-    public int e(String tag, String msg, Throwable tr) {
-        if (logLevel <= ERROR) {
-            out.println(tag + " : " + msg);
-            tr.printStackTrace(out);
-        }
-        return 0;
-    }
-
-    public String getStackTraceString(Throwable tr) {
-        final Writer result = new StringWriter();
-        final PrintWriter printWriter = new PrintWriter(result);
-
-        // If the exception was thrown in a background thread inside
-        // AsyncTask, then the actual exception can be found with getCause
-        Throwable cause = tr;
-        while (cause != null) {
-            cause.printStackTrace(printWriter);
-            cause = cause.getCause();
-        }
-        final String stacktraceAsString = result.toString();
-        printWriter.close();
-
-        return stacktraceAsString;
-    }
-    //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
-}
diff --git a/src/test/java/org/acra/util/HttpRequestTest.java b/src/test/java/org/acra/util/HttpRequestTest.java
deleted file mode 100644
index 10a9a1fc..00000000
--- a/src/test/java/org/acra/util/HttpRequestTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.acra.util;
-
-
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.acra.ACRA;
-import org.acra.log.NonAndroidLog;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-/**
- * Responsible for testing HttpRequest.
- * <p/>
- * User: William
- * Date: 17/07/11
- * Time: 9:37 AM
- */
-public class HttpRequestTest {
-
-    // This is a form for a publicly viewable GoogleDoc
-    // The Doc is viewable at https://spreadsheets.google.com/spreadsheet/ccc?key=0Al8DtaRlEtcodDAtVDRabnhvZVdIOUxXWTFEM3gzSlE
-    private static final String FORM_KEY = "dDAtVDRabnhvZVdIOUxXWTFEM3gzSlE6MQ";
-
-    @Before
-    public void setUp() throws Exception {
-        final NonAndroidLog log = new NonAndroidLog();
-        ACRA.setLog(log);
-        ACRA.getConfig().setDisableSSLCertValidation(true);
-    }
-
-
-    @Test
-    public void testSocketTimeOutCausesRequestToBeRetriedSeveralTimes_Issue63() throws Exception {
-
-        final URL url = new URL("https://spreadsheets.google.com/formResponse?formkey=" + FORM_KEY + "&amp;ifq");
-        final Map<String, String> params = new HashMap<String, String>();
-
-        // Values observed in the GoogleDocs original html form. I presume they are required to ensure the GoogleDoc form is posted to the spreadsheet.
-        params.put("pageNumber", "0");
-        params.put("backupCache", "");
-        params.put("submit", "Envoyer");
-
-        params.put("entry.0.single", "HttpRequestTest#testIssue63");
-        params.put("entry.1.single", new Date().toString());
-
-        final HttpRequest request = new HttpRequest();
-        request.setSocketTimeOut(100); // Set a very low SocketTimeOut. Something that will almost certainly fail.
-        request.setMaxNrRetries(0);
-
-        // Context will be null because default HttpsSocketFactoryFactory doesn't require the Android Context.
-        try {
-            request.send(null /*context*/, url, Method.POST, HttpRequest.getParamsAsFormString(params), Type.FORM);
-            Assert.fail("Should not be able to get a response with an impossibly low SocketTimeOut");
-        } catch (SocketTimeoutException e) {
-            // as expected.
-        }
-
-        // Tell the HttpRequest to retry on Socket time out.
-        request.setMaxNrRetries(5);
-        try {
-            request.send(null /*context*/, url, Method.POST, HttpRequest.getParamsAsFormString(params), Type.FORM);
-        } catch (SocketTimeoutException e) {
-            Assert.fail("Should not get a SocketTimeOut when using SocketTimeOutRetryHandler");
-        }
-    }
-}
