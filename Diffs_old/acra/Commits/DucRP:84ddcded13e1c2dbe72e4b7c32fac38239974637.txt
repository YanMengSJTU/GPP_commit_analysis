diff --git a/.classpath b/.classpath
deleted file mode 100644
index 74e64030..00000000
--- a/.classpath
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" output="target/classes" path="src/main/java">
-		<attributes>
-			<attribute name="optional" value="true"/>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
-		<attributes>
-			<attribute name="optional" value="true"/>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="con" path="org.eclipse.iam.jdt.core.mavenClasspathContainer"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="output" path="target/classes"/>
-</classpath>
diff --git a/.gitignore b/.gitignore
index 04a2dd73..1b0642ed 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,3 +6,4 @@ pom.xml.releaseBackup
 release.properties
 *.iml
 *.idea/*
+build/
\ No newline at end of file
diff --git a/.project b/.project
deleted file mode 100644
index deff9e99..00000000
--- a/.project
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>acra</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.iam.jdt.core.mavenIncrementalBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.m2e.core.maven2Builder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.m2e.core.maven2Nature</nature>
-		<nature>org.eclipse.iam.jdt.core.mavenNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.settings/org.eclipse.core.resources.prefs b/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index ee4149c1..00000000
--- a/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,5 +0,0 @@
-#Sun Oct 09 00:54:43 CEST 2011
-eclipse.preferences.version=1
-encoding//src/main/java=UTF-8
-encoding//src/test/java=UTF-8
-encoding/<project>=UTF-8
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index c877301f..00000000
--- a/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,6 +0,0 @@
-#Sun Oct 09 00:54:43 CEST 2011
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/.settings/org.eclipse.m2e.core.prefs b/.settings/org.eclipse.m2e.core.prefs
deleted file mode 100644
index 20747b01..00000000
--- a/.settings/org.eclipse.m2e.core.prefs
+++ /dev/null
@@ -1,5 +0,0 @@
-#Sun Oct 09 00:54:35 CEST 2011
-activeProfiles=
-eclipse.preferences.version=1
-resolveWorkspaceProjects=true
-version=1
diff --git a/NOTICE b/NOTICE
index 97bd4cb3..dd203f43 100644
--- a/NOTICE
+++ b/NOTICE
@@ -3,5 +3,3 @@ Copyright (c) 2013 Kevin Gaudin
 http://acra.ch
 
 This product is licensed under the terms of the Apache Software License 2.0. See the LICENSE file for the full license text.
-
-This product includes software (package org.acra.jraf.android.util.activitylifecyclecallbackscompat) developed at JRAF, Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org), ASL 2.0.
diff --git a/README.md b/README.md
index 7c2a2517..db649f83 100644
--- a/README.md
+++ b/README.md
@@ -1,147 +1,44 @@
 [![Click here to lend your support to: ACRA - Application Crash Reports for Android and make a donation at www.pledgie.com !](https://pledgie.com/campaigns/18789.png?skin_name=chrome)](http://www.pledgie.com/campaigns/18789) [![Flattr this project](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=kevingaudin&url=http://acra.ch&title=ACRA%20-%20Application%20Crash%20Reports%20for%20Android&language=&tags=opensource%2Candroid&category=software&description=ACRA%20%28Application%20Crash%20Reports%20for%20Android%29%20is%20an%20open%20source%20android%20library%20for%20developers%2C%20enabling%20their%20apps%20to%20send%20detailed%20reports%20when%20they%20crash.)
 
-Please tell us how you use ACRA
-===============================
-
-In order to focus future developments on what is really important to you, please [take this survey](https://spreadsheets.google.com/viewform?hl=en&formkey=dDV5ek03OS1SOWNlZlBxNkFXbV9kSmc6MQ#gid=0)!
-
-You can view the survey results [here](https://spreadsheets.google.com/spreadsheet/viewanalytics?hl=en&formkey=dDV5ek03OS1SOWNlZlBxNkFXbV9kSmc6MQ).
-
-<a href="https://plus.google.com/118444843928759726538" rel="publisher">Follow ACRA on Google+ for latest news and tips.</a>
-
-[![](https://ssl.gstatic.com/images/icons/gplus-32.png)](https://plus.google.com/118444843928759726538)
-
 What is ACRA ?
 ==============
 
-ACRA is a library enabling Android Application to automatically post their crash reports to a GoogleDoc form. It is targetted to android applications developers to help them get data from their applications when they crash or behave erroneously.
+ACRA is a library enabling Android Application to automatically post their crash reports to a report server. It is targeted to android applications developers to help them get data from their applications when they crash or behave erroneously.
 
-ACRA is used in 2.76% ([See AppBrain/stats](http://www.appbrain.com/stats/libraries/details/acra/acra)) of all apps on Google Play as of Jan 2015. That's over 40M **apps** using ACRA. And since the average US user has 41 apps installed on their phone that means there is a 70% that ACRA is running on any phone. That means ACRA is running on over a **billion devices**.
+ACRA is used in 2.68% ([See AppBrain/stats](http://www.appbrain.com/stats/libraries/details/acra/acra)) of all apps on Google Play as of Feb 2016. That's over 53K **apps** using ACRA. And since the average US user has 41 apps installed on their phone that means there is a 70% chance that ACRA is running on any phone. That means ACRA is running on over a **billion devices**.
 
 See [BasicSetup](http://github.com/ACRA/acra/wiki/BasicSetup) for a step-by-step installation and usage guide.
 
 A crash reporting feature for android apps is native since Android 2.2 (FroYo) but only available through the official Android Market (and with limited data). ACRA is a great help for Android developers :
 
   * [developer configurable user interaction](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-User_Interaction): silent reports, Toast notification, status bar notification + dialog or direct dialog
-  * usable with ALL versions of android (compiled with 1.5, not tested on 1.0/1.1 but might work... but who does really care ?) and capable of retrieving data from latest versions through reflection.
+  * usable with ALL versions of Android from 2.2 onwards.
   * more [detailed crash reports](http://github.com/ACRA/acra/wiki/ReportContent) about the device running the app than what is displayed in the Android Market developer console error reports
   * you can [add your own variables content or debug traces](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Adding_your_own_variables_content_or_traces_in_crash_reports) to the reports
   * you can send [error reports even if the application doesn't crash](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Sending_reports_for_caught_exceptions)
-  * works for any application even if not delivered through Google's Android Market => great for devices/regions where the Android Market is not available, beta releases or for enterprise private apps
+  * works for any application even if not delivered through Google PLay => great for devices/regions where the Google Play is not available, beta releases or for enterprise private apps
   * if there is no network coverage, reports are kept and sent on a later application restart
   * can be used with [your own self-hosted report receiver script](http://github.com/ACRA/acra/wiki/AdvancedUsage#wiki-Reports_destination)
-  * google doc reports can be shared with a whole development team. Other benefits from the Google Docs platform are still to be investigated (stats, macros...)
 
-ACRA's notification systems are clean. If a crash occurs, your application does not add user notifications over existing system's crash notifications or reporting features. If you use the Toast, Status bar notification or direct dialog modes, the "force close" dialog is not displayed anymore and devices where the system native reporting feature is enabled do not offer the user to send an additional report.
+ACRA's notification systems are clean. If a crash occurs, your application does not add user notifications over existing system's crash notifications or reporting features. By default, the "force close" dialog is not displayed anymore, to enable it set `alsoReportToAndroidFramework` to `true`.
 
-The user is notified of an error only once, and you might enhance the percieved quality of your application by defining your own texts in the notifications/dialogs.
+The user is notified of an error only once, and you might enhance the perceived quality of your application by defining your own texts in the notifications/dialogs.
 
 Please do not hesitate to open defects/enhancements requests in [the issue tracker](http://github.com/ACRA/acra/issues).
 
-Change Log
-==========
+Latest version ACRA v4.9.2 - 7-JAN-2017
+===========================================
 
 For a complete changelog, please see the [ChangeLog page](http://github.com/ACRA/acra/wiki/ChangeLog) in the Wiki.
 
-ACRA v4.6
-===============================
-
-The summarized changelog is here: https://github.com/ACRA/acra/wiki/ChangeLog
-
-Included in this release (summarized summary):
-- CustomReportDialog using @ReportCrashes#reportDialogClass (NB must extend from BaseCrashReportDialog).
-- many bugfixes
-
-ACRA v4.5 - enabling the future
-===============================
-
-**ACRA 4.5.0 is now the official stable version.**
-
-https://oss.sonatype.org/content/groups/public/ch/acra/acra/4.5.0/acra-4.5.0.zip
-(also available in Maven Central repository)
-
-The summarized changelog is here: https://github.com/ACRA/acra/wiki/ChangeLog
-
-Included in this release (summarized summary):
-- many bugfixes
-- no more exception thrown in ACRA.init() if called twice (widget developers will enjoy it)
-- HttpPostSender is renamed HttpSender and can send PUT and POST requests with data encoded as FORM (same as before) and JSON. The JSON mode enables a fully structured JSON tree to be sent to your backend.
-- Display configuration details can benefit of the newly introduced DisplayManager from Android 4.2
-- CrashReportDialog is now using AlertDialog.Builder to ensure that dialogs are created using the UX guidelines enforced by the android version. (you should remove its theme attribute in your manifest to benefit from the default theme of the device)
-- Ability to set Http Headers with `ACRAConfig.setHttpHeaders()`
-
-The most important part of this release is to enable the usage of Acralyzer (http://github.com/ACRA/acralyzer) which will be the default backend in future release.
-
-Next release will be 5.0 with important changes in mind:
-- no more default support of old Google Forms
-- use JSON as the default report storage and management mode (current implementation transforms flat data into JSON just before sending it)
-
-New ideas about the project are always welcome, you can open feature requests in the Github issue tracker.
-
-
-ACRA v4.4 - enforcing security
-==============================
-
-ACRA has been named in [this report](http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf) as a potential cause of SSL vulnerability for all android apps using it.
-
-The truth is that, in order to let devs use alternative backends over an SSL connection with self-signed certificates, I chose to disable certificate validation in earlier versions of the lib. But this was done only on the scope of ACRA reports senders. Using ACRA did not imply that your app became unsafe for all its SSL communications.
-
-Prior to ACRA v4.4.0, reports content were indeed vulnerable to a man in the middle attack. There "can" be some private data in there, but there are really few by default.
-
-ACRA v4.4.0 has been modified to use SSL certificate validation by default. If you send your reports to your own server via SSL with a self-signed certificate, you have to set the option `disableSSLCertValidation` to `true` (annotation or dynamic config).
-
-ACRA v4.3 is now STABLE
-=======================
-
-After 15 months of great service and more than 11700 downloads, it's time for v4.2.3 to bow out and live a new life among the deprecated releases.
-
-Here's what's new in ACRA 4.3.0:
-
-* cleaned, more stable code base, reducing reports duplicates (thanks to William Ferguson)
-* new experimental and long awaited **direct dialog** interaction mode, _without notifications_ (thanks to Julia Segal)
-* full **runtime configuration API**, required for projects using Android Library Projects since ADT14, and very handy for developers in need of dynamic ACRA configuration.
-* addition of a collector for a custom log file
-* addition of a collector for the details of the broken thread (id, name, groupname)
-* addition of a collector for the new MediaCodecList provided in the Jelly Bean API
-
-A more detailed description of the changes has been introduced in [this Google+ post](https://plus.google.com/b/118444843928759726538/118444843928759726538/posts/cnABXX7bbxV), based on the [ChangeLog](acra/wiki/ChangeLog).
-
-If you upgrade from 4.2.3, be aware that the default list of ReportFields has changed. You would better create a new spreadsheet & form with the help of the doc/CrashReports-Template.csv or use `@ReportsCrashes(customReportContent={...})` to redefine your own list of fields.
-
-Thanks a lot to everyone for testing during these 3 weeks of Beta (with special thanks to Nikolay Elenkov for his feedback on the dynamic configuration API), the 3 successive beta releases have reached 397 downloads on googlecode, not including Maven downloads. There has been very few reports during the Beta, a proof that you can rely on this new version even more than you could rely on the previous.
-
-About Maven. ACRA is now available on Maven Central, with 4.2.3 and 4.3.0 stable releases available on the central repository. Just note these IDs: groupId `ch.acra` artifactId `acra`.
-
-If you think there are missing parts in the documentation, please open an issue. 
-
-_Kevin_
-
-----
-
-ACRA v4.X main new features
-===========================
-
-You can read in the [ChangeLog](http://code.google.com/p/acra/acra/wiki/ChangeLog) that many things have been added since ACRA 3.1. Here is a summary:
-
-  * In addition to standard logcat data, reports can contain eventslog and radioevents data
-  * Reports will contain the result of the "`adb shell dumpsys meminfo <pid>`" command which gives details about your application memory usage right after the crash.
-  * Introduction of an abstraction layer for report senders. This allows to:
-    * use the `formUri` parameter to send reports to your custom server script with POST parameters names not related to Google Forms naming. POST parameters will have easy to understand names.
-    * introduce a new report sending mode: email (see below)
-    * create your own custom report senders. There is now a simple public interface allowing you to code your own class in charge of handling report data. Your sender(s) can be added to default senders or replace them.
-  * Reports can now be sent via email (through an `ACTION_SEND` intent so the user has to choose the email client he wants to use and then send the email containing report fields in the body). The list of report fields included is configurable. This allows to get rid of the `INTERNET` permission in apps where it does not make any sense.
-  * Custom report receiver server scripts can be secured with basic http authentication (login/password can be configured in ACRA)
-  * If the `READ_PHONE_STATE` permission is granted, reports include the Unique Device Identifier (IMEI). This can be really useful for enterprise applications deployment.
-
------
 
 And after that?
 ===============
 
 Now that ACRA is stabilized on the device side (there shouldn't be much more data required...), the effort should be placed on crash data analysis and reports management tools for developers.
 
-You can look at [some contributions](http://github.com/ACRA/acra/wiki/Contribs) that have already been published. Most of them are work in progress, so if you feel like joining the effort, please do!
+You can look at [some contributions](https://github.com/ACRA/acra/wiki/Backends) that have already been published.
 
-[Acralyzer](http://github.com/ACRA/acralyzer) will soon be the official backend for reports storage and analysis. It is a free and open source modern web app, based on a full open stack and using advanced
+[Acralyzer](http://github.com/ACRA/acralyzer) is the official backend for reports storage and analysis. It is a free and open source modern web app, based on a full open stack and using advanced
 technology like CouchDB (JSON document storage with a RESTful API and Map/Reduce querying), AngularJS (one of the most advanced client-side JS frameworks), D3JS (for data visualisation)... If you are interested
 in webapps development, this project can become your playground too ;-)
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..c1997d58
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,36 @@
+apply plugin: 'com.android.library'
+
+ext {
+    final def pom = new XmlSlurper().parse(new File(projectDir, "pom.xml"))
+    acraVersion = pom.version.toString()
+    supportVersion = pom.depthFirst().find { it.name() == 'support.version' }.toString()
+    androidVersion = pom.depthFirst().find { it.name() == 'android.version' }.toInteger()
+    proguardFile = pom.depthFirst().find { it.name() == 'consumerProguardFile' }.toString()
+    println("building ACRA $acraVersion for android $androidVersion with support version $supportVersion")
+}
+
+android {
+    compileSdkVersion androidVersion
+    buildToolsVersion "23.0.3"
+
+    lintOptions {
+        abortOnError false
+    }
+
+    defaultConfig {
+        minSdkVersion 8
+        targetSdkVersion androidVersion
+        versionName acraVersion
+        consumerProguardFile proguardFile
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
+    }
+}
+
+dependencies {
+    compile "com.android.support:support-v4:$supportVersion"
+    compile "com.android.support:support-annotations:$supportVersion"
+}
diff --git a/pom.xml b/pom.xml
index f6ed4282..11643e3c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -7,7 +7,8 @@
     </parent>
 	<groupId>ch.acra</groupId>
 	<artifactId>acra</artifactId>
-	<version>4.6.2-SNAPSHOT</version>
+	<packaging>aar</packaging>
+	<version>4.9.3-SNAPSHOT</version>
 
 	<name>Application Crash Report for Android</name>
 
@@ -35,11 +36,26 @@
 				<role>developer</role>
 			</roles>
 		</developer>
+		<developer>
+			<id>william.ferguson</id>
+			<name>William Ferguson</name>
+			<roles>
+				<role>developer</role>
+			</roles>
+		</developer>
 	</developers>
 
 	<properties>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-        <android.version>17</android.version>
+
+		<!--
+			NB ACRA supports back to API 8.
+
+			But in order to compile classes and method that will NOT be used except when the target platform is of sufficient version
+			we need to compile against version 23. All such classes are in the org.acra.jraf package.
+		-->
+        <android.version>23</android.version>
+		<support.version>24.1.1</support.version>
 	</properties>
 
 	<dependencies>
@@ -53,12 +69,26 @@
             NB The AndroidAPI dependency is included below to allow test execution and javadoc generation.
         -->
         <dependency>
-            <groupId>com.google.android</groupId>
+            <groupId>android</groupId> <!-- deployed using the android-maven-sdk-deployer -->
             <artifactId>android</artifactId>
-            <version>4.1.1.4</version>
+            <version>6.0_r1</version>
             <type>jar</type>
             <scope>provided</scope>
         </dependency>
+		<dependency>
+			<groupId>com.android.support</groupId>
+			<artifactId>support-v4</artifactId>
+			<version>${support.version}</version>
+			<type>aar</type>
+		</dependency>
+
+		<dependency>
+			<groupId>com.android.support</groupId>
+			<artifactId>support-annotations</artifactId>
+			<version>${support.version}</version>
+			<type>jar</type>
+		</dependency>
+
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
@@ -66,12 +96,6 @@
 			<type>jar</type>
 			<scope>test</scope>
 		</dependency>
-        <dependency>
-            <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>20080701</version>
-            <scope>provided</scope>
-        </dependency>
     </dependencies>
 
 	<build>
@@ -91,7 +115,7 @@
 				</plugin>
 				<plugin>
 					<artifactId>maven-javadoc-plugin</artifactId>
-					<version>2.7</version>
+					<version>2.10.3</version>
 				</plugin>
 				<plugin>
 					<artifactId>maven-source-plugin</artifactId>
@@ -101,6 +125,32 @@
 		</pluginManagement>
 
 		<plugins>
+			<plugin>
+				<groupId>com.simpligility.maven.plugins</groupId>
+				<artifactId>android-maven-plugin</artifactId>
+				<version>4.4.3</version>
+				<extensions>true</extensions>
+				<configuration>
+
+					<sdk>
+						<platform>${android.version}</platform>
+					</sdk>
+
+					<consumerProguardFiles>
+						<consumerProguardFile>src/main/proguard/proguard.cfg</consumerProguardFile>
+					</consumerProguardFiles>
+
+					<buildConfigConstants>
+						<buildConfigConstant>
+							<name>VERSION_NAME</name>
+							<type>String</type>
+							<value>${project.version}</value>
+						</buildConfigConstant>
+					</buildConfigConstants>
+
+				</configuration>
+			</plugin>
+
 			<plugin>
 				<artifactId>maven-compiler-plugin</artifactId>
 				<configuration>
@@ -123,6 +173,7 @@
 					</execution>
 				</executions>
                 <configuration>
+					<bootclasspath>${env.JAVA_HOME}/jre/lib/rt.jar;${env.ANDROID_HOME}/platforms/android-${android.version}/android.jar</bootclasspath>
                     <excludePackageNames>org.acra.log,org.acra.util</excludePackageNames>
                 </configuration>
 			</plugin>
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..c5d4a733
--- /dev/null
+++ b/src/main/AndroidManifest.xml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (c) Xandar IP 2013.
+  ~
+  ~ All Rights Reserved
+  ~ No part of this application may be reproduced, copied, modified or adapted, without the prior written consent
+  ~ of the author, unless otherwise indicated for stand-alone materials.
+  ~
+  ~ Contact support@xandar.com.au for copyright requests.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="ch.acra.acra">
+    
+    <!--
+        Version API Name
+        6.0     23  Marshmallow
+        5.0     21  Lollipop
+        4.4W    20  KitKat Watch
+        4.4.2   19  KitKat
+        4.3     18
+        4.2     17
+        4.1     16  Jelly Bean
+        4.0.3   15
+        4.0     14  Ice Cream Sandwich
+        3.2     13
+        3.1.X   12
+        3.0     11  Honeycomb
+        2.3.3   10  Gingerbread
+        2.3     9
+        2.2     8   Froyo
+        2.1     7   Eclair
+        2.0.1   6
+        2.0     5
+        1.6     4   Donut
+        1.5     3   Cupcake
+        1.1     2
+        1.0     1
+    -->
+    <uses-sdk android:minSdkVersion="8"/>
+
+    <application>
+        <activity
+            android:name="org.acra.dialog.CrashReportDialog"
+            android:theme="@android:style/Theme.Dialog"
+            android:launchMode="singleInstance"
+            android:excludeFromRecents="true"
+            android:finishOnTaskLaunch="true"
+            android:process=":acra"/>
+
+        <service
+            android:name="org.acra.sender.SenderService"
+            android:exported="false"
+            android:process=":acra" />
+    </application>
+</manifest>
\ No newline at end of file
diff --git a/src/main/assembly/distribution.xml b/src/main/assembly/distribution.xml
index f172fbb2..a138b3f8 100644
--- a/src/main/assembly/distribution.xml
+++ b/src/main/assembly/distribution.xml
@@ -19,7 +19,7 @@
 			<directory>${project.build.directory}</directory>
 			<outputDirectory>build</outputDirectory>
 			<includes>
-				<include>${project.build.finalName}.jar</include>
+				<include>${project.build.finalName}.aar</include>
 			</includes>
 		</fileSet>
 		<fileSet>
diff --git a/src/main/java/org/acra/ACRA.java b/src/main/java/org/acra/ACRA.java
index a3425a22..56864999 100644
--- a/src/main/java/org/acra/ACRA.java
+++ b/src/main/java/org/acra/ACRA.java
@@ -15,17 +15,27 @@
  */
 package org.acra;
 
+import android.app.Application;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import org.acra.annotation.ReportsCrashes;
+import org.acra.config.ACRAConfiguration;
+import org.acra.config.ACRAConfigurationException;
+import org.acra.config.ConfigurationBuilder;
+import org.acra.legacy.LegacyFileHandler;
 import org.acra.log.ACRALog;
 import org.acra.log.AndroidLogDelegate;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.util.ApplicationStartupProcessor;
+import org.acra.util.IOUtils;
 
-import android.app.Application;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.preference.PreferenceManager;
+import java.io.FileInputStream;
+import java.io.IOException;
 
 /**
  * Use this class to initialize the crash reporting feature using
@@ -33,18 +43,23 @@
  * subclass {@link Application#onCreate()} method. Configuration items must have
  * been set by using {@link ReportsCrashes} above the declaration of your
  * {@link Application} subclass.
- * 
+ *
  * @author Kevin Gaudin
- * 
+ *
  */
-public class ACRA {
+@SuppressWarnings({"WeakerAccess","unused"})
+public final class ACRA {
+    private ACRA(){}
+
+    public static /*non-final*/ boolean DEV_LOGGING = false; // Should be false for release.
 
-    public static final boolean DEV_LOGGING = false; // Should be false for
-                                                     // release.
     public static final String LOG_TAG = ACRA.class.getSimpleName();
-    
+
+    @NonNull
     public static ACRALog log = new AndroidLogDelegate();
 
+    private static final String ACRA_PRIVATE_PROCESS_NAME= ":acra";
+
     /**
      * The key of the application default SharedPreference where you can put a
      * 'true' Boolean value to disable ACRA.
@@ -92,102 +107,155 @@
     public static final String PREF_LAST_VERSION_NR = "acra.lastVersionNr";
 
     private static Application mApplication;
+    @Nullable
+    private static ACRAConfiguration configProxy;
 
     // Accessible via ACRA#getErrorReporter().
+    @Nullable
     private static ErrorReporter errorReporterSingleton;
 
     // NB don't convert to a local field because then it could be garbage
     // collected and then we would have no PreferenceListener.
-    private static OnSharedPreferenceChangeListener mPrefListener;
+    private static OnSharedPreferenceChangeListener mPrefListener; // TODO consider moving to ErrorReport so it doesn't need to be a static field.
 
     /**
      * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Uses the configuration as configured with the @ReportCrashes annotation.
+     * Sends any unsent reports.
      * </p>
-     * 
+     *
      * @param app   Your Application class.
      * @throws IllegalStateException if it is called more than once.
      */
-    public static void init(Application app) {
+    public static void init(@NonNull Application app) {
         final ReportsCrashes reportsCrashes = app.getClass().getAnnotation(ReportsCrashes.class);
         if (reportsCrashes == null) {
-            log.e(LOG_TAG,
-                    "ACRA#init called but no ReportsCrashes annotation on Application " + app.getPackageName());
+            log.e(LOG_TAG, "ACRA#init(Application) called but no ReportsCrashes annotation on Application " + app.getPackageName());
             return;
         }
-        init(app, new ACRAConfiguration(reportsCrashes));
+        init(app, new ConfigurationBuilder(app));
     }
 
     /**
      * <p>
-     * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
-     * method.
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Uses the configuration as configured with the @ReportCrashes annotation.
+     * Sends any unsent reports.
+     * </p>
+     *
+     * @param app     Your Application class.
+     * @param builder ConfigurationBuilder to manually set up ACRA configuration.
+     */
+    public static void init(@NonNull Application app, @NonNull ConfigurationBuilder builder) {
+        init(app, builder, true);
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)}  method.
+     * </p>
+     *
+     * @param app                            Your Application class.
+     * @param builder                        ConfigurationBuilder to manually set up ACRA configuration.
+     * @param checkReportsOnApplicationStart Whether to invoke ErrorReporter.checkReportsOnApplicationStart().
+     */
+    public static void init(@NonNull Application app, @NonNull ConfigurationBuilder builder, boolean checkReportsOnApplicationStart) {
+        try {
+            init(app, builder.build(), checkReportsOnApplicationStart);
+        } catch (ACRAConfigurationException e) {
+            log.w(LOG_TAG, "Configuration Error - ACRA not started : " + e.getMessage());
+        }
+    }
+
+    /**
+     * <p>
+     * Initialize ACRA for a given Application.
+     *
+     * The call to this method should be placed as soon as possible in the {@link Application#attachBaseContext(Context)} method.
+     *
+     * Sends any unsent reports.
      * </p>
      *
      * @param app       Your Application class.
      * @param config    ACRAConfiguration to manually set up ACRA configuration.
      * @throws IllegalStateException if it is called more than once.
      */
-    public static void init(Application app, ACRAConfiguration config) {
+    public static void init(@NonNull Application app, @NonNull ACRAConfiguration config) {
         init(app, config, true);
     }
 
     /**
      * <p>
      * Initialize ACRA for a given Application. The call to this method should
-     * be placed as soon as possible in the {@link Application#onCreate()}
+     * be placed as soon as possible in the {@link Application#attachBaseContext(Context)}
      * method.
      * </p>
      *
      * @param app       Your Application class.
      * @param config    ACRAConfiguration to manually set up ACRA configuration.
-     * @param checkReportsOnApplicationStart    Whether to invoke
-     *     ErrorReporter.checkReportsOnApplicationStart(). Apps which adjust the
-     *     ReportSenders should set this to false and call
-     *     checkReportsOnApplicationStart() themselves to prevent a potential
-     *     race with the SendWorker and list of ReportSenders.
+     * @param checkReportsOnApplicationStart    Whether to invoke ErrorReporter.checkReportsOnApplicationStart().
      * @throws IllegalStateException if it is called more than once.
      */
-    public static void init(Application app, ACRAConfiguration config, boolean checkReportsOnApplicationStart){
+    public static void init(@NonNull Application app, @NonNull ACRAConfiguration config, boolean checkReportsOnApplicationStart){
+
+        final boolean senderServiceProcess = isACRASenderServiceProcess();
+        if (senderServiceProcess) {
+            if (ACRA.DEV_LOGGING) log.d(LOG_TAG, "Not initialising ACRA to listen for uncaught Exceptions as this is the SendWorker process and we only send reports, we don't capture them to avoid infinite loops");
+        }
+
+        final boolean supportedAndroidVersion = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+        if (!supportedAndroidVersion){
+            // NB We keep initialising so that everything is configured. But ACRA is never enabled below.
+            log.w(LOG_TAG, "ACRA 4.7.0+ requires Froyo or greater. ACRA is disabled and will NOT catch crashes or send messages.");
+        }
 
         if (mApplication != null) {
             log.w(LOG_TAG, "ACRA#init called more than once. Won't do anything more.");
             return;
         }
         mApplication = app;
-        
+
+        //noinspection ConstantConditions
         if (config == null) {
             log.e(LOG_TAG, "ACRA#init called but no ACRAConfiguration provided");
             return;
         }
-        setConfig(config);
-
-        final SharedPreferences prefs = getACRASharedPreferences();
-
-        try {
-            checkCrashResources(config);
+        configProxy = config;
 
-            log.d(LOG_TAG, "ACRA is enabled for " + mApplication.getPackageName() + ", intializing...");
+        final SharedPreferences prefs = new SharedPreferencesFactory(mApplication, configProxy).create();
 
-            // Initialize ErrorReporter with all required data
-            final boolean enableAcra = !shouldDisableACRA(prefs);
-            final ErrorReporter errorReporter = new ErrorReporter(mApplication, prefs, enableAcra);
+        new LegacyFileHandler(app, prefs).updateToCurrentVersionIfNecessary();
 
-            // Append ReportSenders.
-            errorReporter.setDefaultReportSenders();
-
-            errorReporterSingleton = errorReporter;
-
-            // Check for pending reports
-            if (checkReportsOnApplicationStart) {
-                errorReporter.checkReportsOnApplicationStart();
+        // Initialize ErrorReporter with all required data
+        final boolean enableAcra = supportedAndroidVersion && !shouldDisableACRA(prefs);
+        if (!senderServiceProcess) {
+            // Indicate that ACRA is or is not listening for crashes.
+            log.i(LOG_TAG, "ACRA is " + (enableAcra ? "enabled" : "disabled") + " for " + mApplication.getPackageName() + ", initializing...");
+        }
+        errorReporterSingleton = new ErrorReporter(mApplication, configProxy, prefs, enableAcra, supportedAndroidVersion, !senderServiceProcess);
+
+        // Check for approved reports and send them (if enabled).
+        // NB don't check if senderServiceProcess as it will gather these reports itself.
+        if (checkReportsOnApplicationStart && !senderServiceProcess) {
+            final ApplicationStartupProcessor startupProcessor = new ApplicationStartupProcessor(mApplication,  config);
+            if (config.deleteOldUnsentReportsOnApplicationStart()) {
+                startupProcessor.deleteUnsentReportsFromOldAppVersion();
+            }
+            if (config.deleteUnapprovedReportsOnApplicationStart()) {
+                startupProcessor.deleteAllUnapprovedReportsBarOne();
+            }
+            if (enableAcra) {
+                startupProcessor.sendApprovedReports();
             }
-
-        } catch (ACRAConfigurationException e) {
-            log.w(LOG_TAG, "Error : ", e);
         }
 
         // We HAVE to keep a reference otherwise the listener could be garbage
@@ -196,7 +264,7 @@ public static void init(Application app, ACRAConfiguration config, boolean check
         mPrefListener = new OnSharedPreferenceChangeListener() {
 
             @Override
-            public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
+            public void onSharedPreferenceChanged(@NonNull SharedPreferences sharedPreferences, String key) {
                 if (PREF_DISABLE_ACRA.equals(key) || PREF_ENABLE_ACRA.equals(key)) {
                     final boolean enableAcra = !shouldDisableACRA(sharedPreferences);
                     getErrorReporter().setEnabled(enableAcra);
@@ -210,12 +278,39 @@ public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, Strin
         prefs.registerOnSharedPreferenceChangeListener(mPrefListener);
     }
 
+    /**
+     * @return true is ACRA has been initialised.
+     */
+    @SuppressWarnings("unused")
+    public static boolean isInitialised() {
+        return configProxy != null;
+    }
+
+    /**
+     * @return true if the current process is the process running the SenderService.
+     *          NB this assumes that your SenderService is configured to used the default ':acra' process.
+     */
+    public static boolean isACRASenderServiceProcess() {
+        final String processName = getCurrentProcessName();
+        if (ACRA.DEV_LOGGING) log.d(LOG_TAG, "ACRA processName='" + processName + '\'');
+        //processName sometimes (or always?) starts with the package name, so we use endsWith instead of equals
+        return processName != null && processName.endsWith(ACRA_PRIVATE_PROCESS_NAME);
+    }
+
+    @Nullable
+    private static String getCurrentProcessName() {
+        try {
+            return IOUtils.streamToString(new FileInputStream("/proc/self/cmdline")).trim();
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
     /**
      * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
+     * @throws IllegalStateException if {@link ACRA#init(android.app.Application)} has not yet been called.
      */
+    @NonNull
     public static ErrorReporter getErrorReporter() {
         if (errorReporterSingleton == null) {
             throw new IllegalStateException("Cannot access ErrorReporter before ACRA#init");
@@ -223,19 +318,19 @@ public static ErrorReporter getErrorReporter() {
         return errorReporterSingleton;
     }
 
-    
+
 
     /**
      * Check if the application default shared preferences contains true for the
      * key "acra.disable", do not activate ACRA. Also checks the alternative
      * opposite setting "acra.enable" if "acra.disable" is not found.
-     * 
+     *
      * @param prefs
      *            SharedPreferences to check to see whether ACRA should be
      *            disabled.
      * @return true if prefs indicate that ACRA should be disabled.
      */
-    private static boolean shouldDisableACRA(SharedPreferences prefs) {
+    private static boolean shouldDisableACRA(@NonNull SharedPreferences prefs) {
         boolean disableAcra = false;
         try {
             final boolean enableAcra = prefs.getBoolean(PREF_ENABLE_ACRA, true);
@@ -247,118 +342,37 @@ private static boolean shouldDisableACRA(SharedPreferences prefs) {
     }
 
     /**
-     * Checks that mandatory configuration items have been provided.
-     * 
-     * @throws ACRAConfigurationException
-     *             if required values are missing.
-     */
-    static void checkCrashResources(ReportsCrashes conf) throws ACRAConfigurationException {
-        switch (conf.mode()) {
-        case TOAST:
-            if (conf.resToastText() == 0) {
-                throw new ACRAConfigurationException(
-                        "TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case NOTIFICATION:
-            if (conf.resNotifTickerText() == 0 || conf.resNotifTitle() == 0 || conf.resNotifText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
-            }
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-        case DIALOG:
-            if (CrashReportDialog.class.equals(conf.reportDialogClass()) && conf.resDialogText() == 0) {
-                throw new ACRAConfigurationException(
-                        "DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
-            }
-            break;
-		default:
-			break;
-        }
-    }
-
-    /**
-     * Retrieves the {@link SharedPreferences} instance where user adjustable
-     * settings for ACRA are stored. Default are the Application default
-     * SharedPreferences, but you can provide another SharedPreferences name
-     * with {@link ReportsCrashes#sharedPreferencesName()}.
-     * 
-     * @return The Shared Preferences where ACRA will retrieve its user
-     *         adjustable setting.
+     * @return The Shared Preferences where ACRA will retrieve its user adjustable setting.
+     * @deprecated since 4.8.0 use {@link SharedPreferencesFactory} instead.
      */
+    @SuppressWarnings( "unused" )
+    @NonNull
     public static SharedPreferences getACRASharedPreferences() {
-        ReportsCrashes conf = getConfig();
-        if (!"".equals(conf.sharedPreferencesName())) {
-            return mApplication.getSharedPreferences(conf.sharedPreferencesName(), conf.sharedPreferencesMode());
-        } else {
-            return PreferenceManager.getDefaultSharedPreferences(mApplication);
+        if (configProxy == null) {
+            throw new IllegalStateException("Cannot call ACRA.getACRASharedPreferences() before ACRA.init().");
         }
+        return new SharedPreferencesFactory(mApplication, configProxy).create();
     }
 
     /**
      * Provides the current ACRA configuration.
-     * 
+     *
      * @return Current ACRA {@link ReportsCrashes} configuration instance.
+     * @deprecated since 4.8.0 {@link ACRAConfiguration} should be passed into classes instead of retrieved statically.
      */
+    @NonNull
     public static ACRAConfiguration getConfig() {
         if (configProxy == null) {
-            if (mApplication == null) {
-                log.w(ACRA.LOG_TAG,
-                        "Calling ACRA.getConfig() before ACRA.init() gives you an empty configuration instance. You might prefer calling ACRA.getNewDefaultConfig(Application) to get an instance with default values taken from a @ReportsCrashes annotation.");
-            }
-            configProxy = getNewDefaultConfig(mApplication);
+            throw new IllegalStateException("Cannot call ACRA.getConfig() before ACRA.init().");
         }
         return configProxy;
     }
 
-    /**
-     * Sets the whole ACRA configuration.
-     * 
-     * @param conf
-     *            ACRAConfiguration to use as a proxy for config info.
-     */
-    public static void setConfig(ACRAConfiguration conf) {
-        configProxy = conf;
-    }
-
-    /**
-     * @param app       Your Application class.
-     * @return new {@link ACRAConfiguration} instance with values initialized
-     *         from the {@link ReportsCrashes} annotation.
-     */
-    public static ACRAConfiguration getNewDefaultConfig(Application app) {
-        if(app != null) {
-            return new ACRAConfiguration(app.getClass().getAnnotation(ReportsCrashes.class));
-        } else {
-            return new ACRAConfiguration(null);
-        }
-    }
-
-    private static ACRAConfiguration configProxy;
-
-    /**
-     * Returns true if the application is debuggable.
-     * 
-     * @return true if the application is debuggable.
-     */
-    static boolean isDebuggable() {
-        PackageManager pm = mApplication.getPackageManager();
-        try {
-            return ((pm.getApplicationInfo(mApplication.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0);
-        } catch (NameNotFoundException e) {
-            return false;
+    public static void setLog(@NonNull ACRALog log) {
+        //noinspection ConstantConditions (do not rely on annotation alone)
+        if (log == null) {
+            throw new NullPointerException("ACRALog cannot be null");
         }
-    }
-    
-    static Application getApplication() {
-        return mApplication;
-    }
-    
-    public static void setLog(ACRALog log) {
         ACRA.log = log;
     }
 }
diff --git a/src/main/java/org/acra/ACRAConfiguration.java b/src/main/java/org/acra/ACRAConfiguration.java
deleted file mode 100644
index add1f1bf..00000000
--- a/src/main/java/org/acra/ACRAConfiguration.java
+++ /dev/null
@@ -1,1337 +0,0 @@
-/*
- *  Copyright 2011 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import org.acra.annotation.ReportsCrashes;
-import org.acra.sender.HttpSender;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.acra.util.DefaultHttpsSocketFactoryFactory;
-import org.acra.util.HttpsSocketFactoryFactory;
-import org.acra.util.ReflectionException;
-import org.acra.util.ReflectionHelper;
-
-import java.lang.annotation.Annotation;
-import java.security.KeyStore;
-import java.util.Map;
-
-import static org.acra.ACRAConstants.*;
-
-/**
- * This class is to be used if you need to apply dynamic settings. This is
- * needed for example when using ACRA in an Android Library Project since ADT
- * v14 where resource ids are not final anymore and can't be passed as
- * annotation parameters values.
- */
-public class ACRAConfiguration implements ReportsCrashes {
-
-    private final ReflectionHelper reflectionHelper = new ReflectionHelper();
-
-    private String[] mAdditionalDropboxTags = null;
-
-    private String[] mAdditionalSharedPreferences = null;
-    private Integer mConnectionTimeout = null;
-    private ReportField[] mCustomReportContent = null;
-    private Boolean mDeleteUnapprovedReportsOnApplicationStart = null;
-    private Boolean mDeleteOldUnsentReportsOnApplicationStart = null;
-    private Integer mDropboxCollectionMinutes = null;
-    private Boolean mForceCloseDialogAfterToast = null;
-    private String mFormUri = null;
-    private String mFormUriBasicAuthLogin = null;
-    private String mFormUriBasicAuthPassword = null;
-    private Boolean mIncludeDropboxSystemTags = null;
-
-    private String[] mLogcatArguments = null;
-    private String mMailTo = null;
-    private Integer mMaxNumberOfRequestRetries = null;
-    private ReportingInteractionMode mMode = null;
-    private ReportsCrashes mReportsCrashes = null;
-    private Class<? extends BaseCrashReportDialog> mReportDialogClass = null;
-
-    private Integer mResDialogPositiveButtonText = null;
-    private Integer mResDialogNegativeButtonText = null;
-    private Integer mResDialogCommentPrompt = null;
-    private Integer mResDialogEmailPrompt = null;
-    private Integer mResDialogIcon = null;
-    private Integer mResDialogOkToast = null;
-    private Integer mResDialogText = null;
-    private Integer mResDialogTitle = null;
-    private Integer mResNotifIcon = null;
-    private Integer mResNotifText = null;
-    private Integer mResNotifTickerText = null;
-    private Integer mResNotifTitle = null;
-    private Integer mResToastText = null;
-    private Integer mSharedPreferenceMode = null;
-    private String mSharedPreferenceName = null;
-    private Integer mSocketTimeout = null;
-    private Boolean mLogcatFilterByPid = null;
-    private Boolean mSendReportsInDevMode = null;
-    private Boolean mSendReportsAtShutdown = null;
-
-    private String[] mExcludeMatchingSharedPreferencesKeys = null;
-    private String[] mExcludeMatchingSettingsKeys = null;
-    private Class mBuildConfigClass;
-    private String mApplicationLogFile = null;
-    private Integer mApplicationLogFileLines = null;
-
-    private Boolean mDisableSSLCertValidation = null;
-    private String mHttpsSocketFactoryFactoryClass = null;
-    private HttpsSocketFactoryFactory mHttpsSocketFactoryFactory;
-    private Method mHttpMethod = null;
-    private Type mReportType = null;
-    private Map<String, String> mHttpHeaders;
-    private KeyStore mKeyStore;
-
-    /**
-     * Set custom HTTP headers to be sent by the provided {@link HttpSender}.
-     * This should be used also by third party senders.
-     * 
-     * @param headers
-     *            A map associating HTTP header names to their values.
-     * @return The updated ACRA configuration
-     */
-    public ACRAConfiguration setHttpHeaders(Map<String, String> headers) {
-        this.mHttpHeaders = headers;
-        return this;
-    }
-
-    /**
-     * Retrieve HTTP headers defined by the application developer. These should
-     * be added to requests sent by any third-party sender (over HTTP of
-     * course).
-     * 
-     * @return A map associating http header names to their values.
-     */
-    public Map<String, String> getHttpHeaders() {
-        return mHttpHeaders;
-    }
-
-    /**
-     * @param additionalDropboxTags
-     *            the additionalDropboxTags to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setAdditionalDropboxTags(String[] additionalDropboxTags) {
-        this.mAdditionalDropboxTags = additionalDropboxTags;
-        return this;
-    }
-
-    /**
-     * @param additionalSharedPreferences
-     *            the additionalSharedPreferences to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setAdditionalSharedPreferences(String[] additionalSharedPreferences) {
-        this.mAdditionalSharedPreferences = additionalSharedPreferences;
-        return this;
-    }
-
-    /**
-     * @param connectionTimeout
-     *            the connectionTimeout to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setConnectionTimeout(Integer connectionTimeout) {
-        this.mConnectionTimeout = connectionTimeout;
-        return this;
-    }
-
-    /**
-     * @param customReportContent
-     *            the customReportContent to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setCustomReportContent(ReportField[] customReportContent) {
-        this.mCustomReportContent = customReportContent;
-        return this;
-    }
-
-    /**
-     * @param deleteUnapprovedReportsOnApplicationStart
-     *            the deleteUnapprovedReportsOnApplicationStart to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDeleteUnapprovedReportsOnApplicationStart(Boolean deleteUnapprovedReportsOnApplicationStart) {
-        this.mDeleteUnapprovedReportsOnApplicationStart = deleteUnapprovedReportsOnApplicationStart;
-        return this;
-    }
-
-    /**
-     * @param deleteOldUnsentReportsOnApplicationStart    When to delete old (unsent) reports on startup.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDeleteOldUnsentReportsOnApplicationStart(Boolean deleteOldUnsentReportsOnApplicationStart) {
-        this.mDeleteOldUnsentReportsOnApplicationStart = deleteOldUnsentReportsOnApplicationStart;
-        return this;
-    }
-
-    /**
-     * @param dropboxCollectionMinutes
-     *            the dropboxCollectionMinutes to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setDropboxCollectionMinutes(Integer dropboxCollectionMinutes) {
-        this.mDropboxCollectionMinutes = dropboxCollectionMinutes;
-        return this;
-    }
-
-    /**
-     * @param forceCloseDialogAfterToast
-     *            the forceCloseDialogAfterToast to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setForceCloseDialogAfterToast(Boolean forceCloseDialogAfterToast) {
-        this.mForceCloseDialogAfterToast = forceCloseDialogAfterToast;
-        return this;
-    }
-
-    /**
-     * Modify the formUri of your backend server receiving reports. You need to
-     * call {@link ErrorReporter#setDefaultReportSenders()} after modifying this
-     * value if you were not using a formUri before (a mailTo or formKey
-     * instead).
-     * 
-     * @param formUri
-     *            the formUri to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUri(String formUri) {
-        this.mFormUri = formUri;
-        return this;
-    }
-
-    /**
-     * @param formUriBasicAuthLogin
-     *            the formUriBasicAuthLogin to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUriBasicAuthLogin(String formUriBasicAuthLogin) {
-        this.mFormUriBasicAuthLogin = formUriBasicAuthLogin;
-        return this;
-    }
-
-    /**
-     * @param formUriBasicAuthPassword
-     *            the formUriBasicAuthPassword to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setFormUriBasicAuthPassword(String formUriBasicAuthPassword) {
-        this.mFormUriBasicAuthPassword = formUriBasicAuthPassword;
-        return this;
-    }
-
-    /**
-     * @param includeDropboxSystemTags
-     *            the includeDropboxSystemTags to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setIncludeDropboxSystemTags(Boolean includeDropboxSystemTags) {
-        this.mIncludeDropboxSystemTags = includeDropboxSystemTags;
-        return this;
-    }
-
-    /**
-     * @param logcatArguments
-     *            the logcatArguments to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setLogcatArguments(String[] logcatArguments) {
-        this.mLogcatArguments = logcatArguments;
-        return this;
-    }
-
-    /**
-     * Modify the mailTo of the mail account receiving reports. You need to call
-     * {@link ErrorReporter#setDefaultReportSenders()} after modifying this
-     * value if you were not using a formKey before (a formKey or formUri
-     * instead).
-     * 
-     * @param mailTo
-     *            the mailTo to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMailTo(String mailTo) {
-        this.mMailTo = mailTo;
-        return this;
-    }
-
-    /**
-     * @param maxNumberOfRequestRetries
-     *            the maxNumberOfRequestRetries to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMaxNumberOfRequestRetries(Integer maxNumberOfRequestRetries) {
-        this.mMaxNumberOfRequestRetries = maxNumberOfRequestRetries;
-        return this;
-    }
-
-    /**
-     * Change the current {@link ReportingInteractionMode}. You must set
-     * required configuration items first.
-     * 
-     * @param mode
-     *            the new mode to set.
-     * @return The updated ACRA configuration
-     * @throws ACRAConfigurationException
-     *             if a configuration item is missing for this mode.
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setMode(ReportingInteractionMode mode) throws ACRAConfigurationException {
-        this.mMode = mode;
-        ACRA.checkCrashResources(this);
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogPositiveButtonText(int resId) {
-        mResDialogPositiveButtonText = resId;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogNegativeButtonText(int resId) {
-        mResDialogNegativeButtonText = resId;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setReportDialogClass(Class<? extends BaseCrashReportDialog> reportDialogClass) {
-        mReportDialogClass = reportDialogClass;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogCommentPrompt()} comes from an Android
-     * Library Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resDialogCommentPrompt()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogCommentPrompt(int resId) {
-        mResDialogCommentPrompt = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogEmailPrompt()} comes from an Android
-     * Library Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resDialogEmailPrompt()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogEmailPrompt(int resId) {
-        mResDialogEmailPrompt = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogIcon()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogIcon()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogIcon(int resId) {
-        mResDialogIcon = resId;
-        return this;
-    }
-
-    /**
-     * Use this method BEFORE if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogOkToast()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogOkToast()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogOkToast(int resId) {
-        mResDialogOkToast = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogText(int resId) {
-        mResDialogText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resDialogTitle()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resDialogTitle()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResDialogTitle(int resId) {
-        mResDialogTitle = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifIcon()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifIcon()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifIcon(int resId) {
-        mResNotifIcon = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifText(int resId) {
-        mResNotifText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifTickerText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see
-     *            {@link ReportsCrashes#resNotifTickerText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifTickerText(int resId) {
-        mResNotifTickerText = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resNotifTitle()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resNotifTitle()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResNotifTitle(int resId) {
-        mResNotifTitle = resId;
-        return this;
-    }
-
-    /**
-     * Use this method if the id you wanted to give to
-     * {@link ReportsCrashes#resToastText()} comes from an Android Library
-     * Project.
-     * 
-     * @param resId
-     *            The resource id, see {@link ReportsCrashes#resToastText()}
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setResToastText(int resId) {
-        mResToastText = resId;
-        return this;
-    }
-
-    /**
-     * @param sharedPreferenceMode
-     *            the sharedPreferenceMode to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSharedPreferenceMode(Integer sharedPreferenceMode) {
-        this.mSharedPreferenceMode = sharedPreferenceMode;
-        return this;
-    }
-
-    /**
-     * @param sharedPreferenceName
-     *            the sharedPreferenceName to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSharedPreferenceName(String sharedPreferenceName) {
-        this.mSharedPreferenceName = sharedPreferenceName;
-        return this;
-    }
-
-    /**
-     * @param socketTimeout
-     *            the socketTimeout to set
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSocketTimeout(Integer socketTimeout) {
-        this.mSocketTimeout = socketTimeout;
-        return this;
-    }
-
-    /**
-     * 
-     * @param filterByPid
-     *            true if you want to collect only logcat lines related to your
-     *            application process.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setLogcatFilterByPid(Boolean filterByPid) {
-        mLogcatFilterByPid = filterByPid;
-        return this;
-    }
-
-    /**
-     * 
-     * @param sendReportsInDevMode
-     *            false if you want to disable sending reports in development
-     *            mode. Reports will be sent only on signed applications.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSendReportsInDevMode(Boolean sendReportsInDevMode) {
-        mSendReportsInDevMode = sendReportsInDevMode;
-        return this;
-    }
-
-    /**
-     * 
-     * @param sendReportsAtShutdown
-     *            false if you want to disable sending reports at the time the
-     *            exception is caught. Reports will be sent when the application
-     *            is restarted.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setSendReportsAtShutdown(Boolean sendReportsAtShutdown) {
-        mSendReportsAtShutdown = sendReportsAtShutdown;
-        return this;
-    }
-
-    /**
-     * 
-     * @param excludeMatchingSharedPreferencesKeys
-     *            an array of Strings containing regexp defining
-     *            SharedPreferences keys that should be excluded from the data
-     *            collection.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setExcludeMatchingSharedPreferencesKeys(String[] excludeMatchingSharedPreferencesKeys) {
-        mExcludeMatchingSharedPreferencesKeys = excludeMatchingSharedPreferencesKeys;
-        return this;
-    }
-
-    /**
-     * 
-     * @param excludeMatchingSettingsKeys
-     *            an array of Strings containing regexp defining
-     *            Settings.System, Settings.Secure and Settings.Global keys that
-     *            should be excluded from the data collection.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setExcludeMatchingSettingsKeys(String[] excludeMatchingSettingsKeys) {
-        mExcludeMatchingSettingsKeys = excludeMatchingSettingsKeys;
-        return this;
-    }
-
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setBuildConfigClass(Class buildConfigClass) {
-        mBuildConfigClass = buildConfigClass;
-        return this;
-    }
-    /**
-     * 
-     * @param applicationLogFile
-     *            The path and file name of your application log file, to be
-     *            used with {@link ReportField#APPLICATION_LOG}.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setApplicationLogFile(String applicationLogFile) {
-        mApplicationLogFile = applicationLogFile;
-        return this;
-    }
-
-    /**
-     * 
-     * @param applicationLogFileLines
-     *            The number of lines of your application log to be collected,
-     *            to be used with {@link ReportField#APPLICATION_LOG} and
-     *            {@link ReportsCrashes#applicationLogFile()}.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setApplicationLogFileLines(int applicationLogFileLines) {
-        mApplicationLogFileLines = applicationLogFileLines;
-        return this;
-    }
-
-    /**
-     * 
-     * @param disableSSLCertValidation
-     *            Set this to true if you need to send reports to a server over
-     *            SSL using a self-signed certificate.
-     * @return The updated ACRA configuration
-     */
-    public ACRAConfiguration setDisableSSLCertValidation(boolean disableSSLCertValidation) {
-        mDisableSSLCertValidation = disableSSLCertValidation;
-        return this;
-    }
-
-    /**
-     * 
-     * @param httpMethod
-     *            The method to be used to send data to the server.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setHttpMethod(Method httpMethod) {
-        mHttpMethod = httpMethod;
-        return this;
-    }
-
-    /**
-     * 
-     * @param type
-     *            The type of content encoding to be used to send data to the
-     *            server.
-     * @return The updated ACRA configuration
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration setReportType(Type type) {
-        mReportType = type;
-        return this;
-    }
-
-    /**
-     * 
-     * @param keyStore
-     *            Set this to the keystore that contains the trusted certificates
-     */
-    @SuppressWarnings( "unused" )
-    public void setKeyStore(KeyStore keyStore) {
-        mKeyStore = keyStore;
-    }
-
-    /**
-     * @param defaults  Defaults with which to initialise this {@link ACRAConfiguration}.
-     */
-    public ACRAConfiguration(ReportsCrashes defaults) {
-        mReportsCrashes = defaults;
-    }
-
-    /**
-     * Empty constructor which sets no defaults.
-     */
-    @SuppressWarnings( "unused" )
-    public ACRAConfiguration(){
-        this(null);
-    }
-
-    @Override
-    public String[] additionalDropBoxTags() {
-        if (mAdditionalDropboxTags != null) {
-            return mAdditionalDropboxTags;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.additionalDropBoxTags();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public String[] additionalSharedPreferences() {
-        if (mAdditionalSharedPreferences != null) {
-            return mAdditionalSharedPreferences;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.additionalSharedPreferences();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public Class<? extends Annotation> annotationType() {
-        return mReportsCrashes.annotationType();
-    }
-
-    @Override
-    public int connectionTimeout() {
-        if (mConnectionTimeout != null) {
-            return mConnectionTimeout;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.connectionTimeout();
-        }
-
-        return DEFAULT_CONNECTION_TIMEOUT;
-    }
-
-    @Override
-    public ReportField[] customReportContent() {
-        if (mCustomReportContent != null) {
-            return mCustomReportContent;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.customReportContent();
-        }
-
-        return new ReportField[0];
-    }
-
-    @Override
-    public boolean deleteUnapprovedReportsOnApplicationStart() {
-        if (mDeleteUnapprovedReportsOnApplicationStart != null) {
-            return mDeleteUnapprovedReportsOnApplicationStart;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.deleteUnapprovedReportsOnApplicationStart();
-        }
-
-        return DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
-    }
-
-    @Override
-    public boolean deleteOldUnsentReportsOnApplicationStart() {
-        if (mDeleteOldUnsentReportsOnApplicationStart != null) {
-            return mDeleteOldUnsentReportsOnApplicationStart;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.deleteOldUnsentReportsOnApplicationStart();
-        }
-
-        return DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
-    }
-
-    @Override
-    public int dropboxCollectionMinutes() {
-        if (mDropboxCollectionMinutes != null) {
-            return mDropboxCollectionMinutes;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.dropboxCollectionMinutes();
-        }
-
-        return DEFAULT_DROPBOX_COLLECTION_MINUTES;
-    }
-
-    @Override
-    public boolean forceCloseDialogAfterToast() {
-        if (mForceCloseDialogAfterToast != null) {
-            return mForceCloseDialogAfterToast;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.forceCloseDialogAfterToast();
-        }
-
-        return DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
-    }
-
-    @Override
-    public String formUri() {
-        if (mFormUri != null) {
-            return mFormUri;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUri();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public String formUriBasicAuthLogin() {
-        if (mFormUriBasicAuthLogin != null) {
-            return mFormUriBasicAuthLogin;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUriBasicAuthLogin();
-        }
-
-        return NULL_VALUE;
-    }
-
-    @Override
-    public String formUriBasicAuthPassword() {
-        if (mFormUriBasicAuthPassword != null) {
-            return mFormUriBasicAuthPassword;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.formUriBasicAuthPassword();
-        }
-
-        return NULL_VALUE;
-    }
-
-    @Override
-    public boolean includeDropBoxSystemTags() {
-        if (mIncludeDropboxSystemTags != null) {
-            return mIncludeDropboxSystemTags;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.includeDropBoxSystemTags();
-        }
-
-        return DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
-    }
-
-    @Override
-    public String[] logcatArguments() {
-        if (mLogcatArguments != null) {
-            return mLogcatArguments;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.logcatArguments();
-        }
-
-        return new String[] { "-t", Integer.toString(DEFAULT_LOGCAT_LINES), "-v", "time" };
-    }
-
-    @Override
-    public String mailTo() {
-        if (mMailTo != null) {
-            return mMailTo;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.mailTo();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public int maxNumberOfRequestRetries() {
-        if (mMaxNumberOfRequestRetries != null) {
-            return mMaxNumberOfRequestRetries;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.maxNumberOfRequestRetries();
-        }
-
-        return DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
-    }
-
-    @Override
-    public ReportingInteractionMode mode() {
-        if (mMode != null) {
-            return mMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.mode();
-        }
-
-        return ReportingInteractionMode.SILENT;
-    }
-
-    @Override
-    public int resDialogPositiveButtonText() {
-        if (mResDialogPositiveButtonText != null) {
-            return mResDialogPositiveButtonText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogPositiveButtonText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogNegativeButtonText() {
-        if (mResDialogNegativeButtonText != null) {
-            return mResDialogNegativeButtonText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogNegativeButtonText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogCommentPrompt() {
-        if (mResDialogCommentPrompt != null) {
-            return mResDialogCommentPrompt;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogCommentPrompt();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogEmailPrompt() {
-        if (mResDialogEmailPrompt != null) {
-            return mResDialogEmailPrompt;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogEmailPrompt();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogIcon() {
-        if (mResDialogIcon != null) {
-            return mResDialogIcon;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogIcon();
-        }
-
-        return DEFAULT_DIALOG_ICON;
-    }
-
-    @Override
-    public int resDialogOkToast() {
-        if (mResDialogOkToast != null) {
-            return mResDialogOkToast;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogOkToast();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogText() {
-        if (mResDialogText != null) {
-            return mResDialogText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resDialogTitle() {
-        if (mResDialogTitle != null) {
-            return mResDialogTitle;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resDialogTitle();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifIcon() {
-        if (mResNotifIcon != null) {
-            return mResNotifIcon;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifIcon();
-        }
-
-        return DEFAULT_NOTIFICATION_ICON;
-    }
-
-    @Override
-    public int resNotifText() {
-        if (mResNotifText != null) {
-            return mResNotifText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifTickerText() {
-        if (mResNotifTickerText != null) {
-            return mResNotifTickerText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifTickerText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resNotifTitle() {
-        if (mResNotifTitle != null) {
-            return mResNotifTitle;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resNotifTitle();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int resToastText() {
-        if (mResToastText != null) {
-            return mResToastText;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.resToastText();
-        }
-
-        return DEFAULT_RES_VALUE;
-    }
-
-    @Override
-    public int sharedPreferencesMode() {
-        if (mSharedPreferenceMode != null) {
-            return mSharedPreferenceMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sharedPreferencesMode();
-        }
-
-        return DEFAULT_SHARED_PREFERENCES_MODE;
-    }
-
-    @Override
-    public String sharedPreferencesName() {
-        if (mSharedPreferenceName != null) {
-            return mSharedPreferenceName;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sharedPreferencesName();
-        }
-
-        return DEFAULT_STRING_VALUE;
-    }
-
-    @Override
-    public int socketTimeout() {
-        if (mSocketTimeout != null) {
-            return mSocketTimeout;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.socketTimeout();
-        }
-
-        return DEFAULT_SOCKET_TIMEOUT;
-    }
-
-    @Override
-    public boolean logcatFilterByPid() {
-        if (mLogcatFilterByPid != null) {
-            return mLogcatFilterByPid;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.logcatFilterByPid();
-        }
-
-        return DEFAULT_LOGCAT_FILTER_BY_PID;
-    }
-
-    @Override
-    public boolean sendReportsInDevMode() {
-        if (mSendReportsInDevMode != null) {
-            return mSendReportsInDevMode;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sendReportsInDevMode();
-        }
-
-        return DEFAULT_SEND_REPORTS_IN_DEV_MODE;
-    }
-
-    @Override
-    public boolean sendReportsAtShutdown() {
-        if (mSendReportsAtShutdown != null) {
-            return mSendReportsAtShutdown;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.sendReportsAtShutdown();
-        }
-
-        return DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
-    }
-
-    @Override
-    public String[] excludeMatchingSharedPreferencesKeys() {
-        if (mExcludeMatchingSharedPreferencesKeys != null) {
-            return mExcludeMatchingSharedPreferencesKeys;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.excludeMatchingSharedPreferencesKeys();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    public String[] excludeMatchingSettingsKeys() {
-        if (mExcludeMatchingSettingsKeys != null) {
-            return mExcludeMatchingSettingsKeys;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.excludeMatchingSettingsKeys();
-        }
-
-        return new String[0];
-    }
-
-    @Override
-    /**
-     * Will return null if no value has been configured.
-     * It is up to clients to construct the recommended default value oof context.getClass().getPackage().getName() + BuildConfig.class
-     */
-    public Class buildConfigClass() {
-        if (mBuildConfigClass != null) {
-            return mBuildConfigClass;
-        }
-
-        if ((mReportsCrashes != null) && (mReportsCrashes.buildConfigClass() != null)) {
-            return mReportsCrashes.buildConfigClass();
-        }
-
-        return null;
-    }
-
-    @Override
-    public String applicationLogFile() {
-        if (mApplicationLogFile != null) {
-            return mApplicationLogFile;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.applicationLogFile();
-        }
-
-        return DEFAULT_APPLICATION_LOGFILE;
-    }
-
-    @Override
-    public int applicationLogFileLines() {
-        if (mApplicationLogFileLines != null) {
-            return mApplicationLogFileLines;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.applicationLogFileLines();
-        }
-
-        return DEFAULT_APPLICATION_LOGFILE_LINES;
-    }
-
-    @Override
-    public boolean disableSSLCertValidation() {
-        if (mDisableSSLCertValidation != null) {
-            return mDisableSSLCertValidation;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.disableSSLCertValidation();
-        }
-
-        return DEFAULT_DISABLE_SSL_CERT_VALIDATION;
-    }
-
-    @Override
-    public String httpsSocketFactoryFactoryClass() {
-        if (mHttpsSocketFactoryFactoryClass != null) {
-            return mHttpsSocketFactoryFactoryClass;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.httpsSocketFactoryFactoryClass();
-        }
-
-        return null;
-    }
-
-
-    @Override
-    public Class<? extends BaseCrashReportDialog> reportDialogClass() {
-        if (mReportDialogClass != null) {
-            return mReportDialogClass;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.reportDialogClass();
-        }
-
-        return CrashReportDialog.class;
-    }
-
-    /**
-     * @param httpsSocketFactoryFactory  HttpsSocketFactoryFactory to set.
-     */
-    @SuppressWarnings( "unused" )
-    public void setHttpsSocketFactoryFactory(HttpsSocketFactoryFactory httpsSocketFactoryFactory) {
-        this.mHttpsSocketFactoryFactory = httpsSocketFactoryFactory;
-    }
-
-    public HttpsSocketFactoryFactory getHttpSocketFactoryFactory() {
-        if (mHttpsSocketFactoryFactory != null) {
-            return mHttpsSocketFactoryFactory;
-        }
-
-        final String httpsSocketFactoryFactoryClass = httpsSocketFactoryFactoryClass();
-        if (httpsSocketFactoryFactoryClass != null) {
-            try {
-                final Object object = reflectionHelper.create(mReportsCrashes.httpsSocketFactoryFactoryClass());
-                if (object instanceof HttpsSocketFactoryFactory) {
-                    mHttpsSocketFactoryFactory = (HttpsSocketFactoryFactory) object;
-                } else {
-                    ACRA.log.w(ACRA.LOG_TAG, "Using default httpsSocketFactoryFactory - not a HttpSocketFactoryFactory : " + httpsSocketFactoryFactoryClass);
-                }
-            } catch (ReflectionException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Using default httpsSocketFactoryFactory - Could not construct : " + httpsSocketFactoryFactoryClass);
-            }
-        }
-
-        // If it's still null then take the default
-        if (mHttpsSocketFactoryFactoryClass == null) {
-            mHttpsSocketFactoryFactory = DefaultHttpsSocketFactoryFactory.INSTANCE;
-        }
-
-        return mHttpsSocketFactoryFactory;
-    }
-
-
-    @Override
-    public Method httpMethod() {
-        if (mHttpMethod != null) {
-            return mHttpMethod;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.httpMethod();
-        }
-
-        return Method.POST;
-    }
-
-    @Override
-    public Type reportType() {
-        if (mReportType != null) {
-            return mReportType;
-        }
-
-        if (mReportsCrashes != null) {
-            return mReportsCrashes.reportType();
-        }
-
-        return Type.FORM;
-    }
-
-    public KeyStore keyStore() {
-        if (mKeyStore != null) {
-            return mKeyStore;
-        }
-
-        return null;
-    }
-
-    public static boolean isNull(String aString) {
-        return aString == null || ACRAConstants.NULL_VALUE.equals(aString);
-    }
-
-}
diff --git a/src/main/java/org/acra/ACRAConstants.java b/src/main/java/org/acra/ACRAConstants.java
index d34f3acf..7d4e837c 100644
--- a/src/main/java/org/acra/ACRAConstants.java
+++ b/src/main/java/org/acra/ACRAConstants.java
@@ -16,6 +16,12 @@
 package org.acra;
 
 import android.content.Context;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.StringRes;
+
+import org.acra.dialog.CrashReportDialog;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
 
 import static org.acra.ReportField.*;
 
@@ -26,6 +32,7 @@
  * @since 4.3.0
  */
 public final class ACRAConstants {
+    private ACRAConstants(){}
 
     public static final String REPORTFILE_EXTENSION = ".stacktrace";
 
@@ -33,25 +40,25 @@
      * Suffix to be added to report files when they have been approved by the
      * user in NOTIFICATION mode
      */
-    static final String APPROVED_SUFFIX = "-approved";
+    public static final String APPROVED_SUFFIX = "-approved";
     /**
      * This key is used to store the silent state of a report sent by
      * handleSilentException().
      */
-    static final String SILENT_SUFFIX = "-" + IS_SILENT;
+    public static final String SILENT_SUFFIX = "-" + IS_SILENT;
     /**
-     * This is the number of previously stored reports that we send in
-     * {@link SendWorker#checkAndSendReports(android.content.Context, boolean)}.
-     * The number of reports is limited to avoid ANR on application start.
+     * This is the maximum number of previously stored reports that we send
+     * in one batch to avoid overloading the network.
      */
-    static final int MAX_SEND_REPORTS = 5;
+    public static final int MAX_SEND_REPORTS = 5;
 
     /**
      * Used in the intent starting CrashReportDialog to provide the name of the
      * latest generated report file in order to be able to associate the user
      * comment.
      */
-    public static final String EXTRA_REPORT_FILE_NAME = "REPORT_FILE_NAME";
+    public static final String EXTRA_REPORT_FILE = "REPORT_FILE";
+
     /**
      * Used in the intent starting CrashReportDialog to provide the Exception that caused the crash.
      *
@@ -60,19 +67,24 @@
     public static final String EXTRA_REPORT_EXCEPTION = "REPORT_EXCEPTION";
 
     /**
-     * Set this extra to true to force the deletion of reports by the
-     * {@link CrashReportDialog} activity.
+     * Used in the intent starting CrashReportDialog to provide the AcraConfig to use when gathering the crash info.
+     *
+     * This can be used by any BaseCrashReportDialog subclass to custom the dialog.
+     */
+    public static final String EXTRA_REPORT_CONFIG = "REPORT_CONFIG";
+
+    /**
+     * Set this extra to true to force the deletion of reports by the {@link CrashReportDialog} activity.
      */
-    protected static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
+    public static final String EXTRA_FORCE_CANCEL = "FORCE_CANCEL";
     /**
-     * This is the identifier (value = 666) use for the status bar notification
-     * issued when crashes occur.
+     * This is the identifier (value = 666) use for the status bar notification issued when crashes occur.
      */
-    static final int NOTIF_CRASH_ID = 666;
+    public static final int NOTIF_CRASH_ID = 666;
     /**
      * Number of milliseconds to wait after displaying a toast.
      */
-    static final int TOAST_WAIT_DURATION = 2000;
+    public static final int TOAST_WAIT_DURATION = 2000;
 
     /**
      * A special String value to allow the usage of a pseudo-null default value
@@ -80,13 +92,11 @@
      */
     public static final String NULL_VALUE = "ACRA-NULL-STRING";
 
-    public static final boolean DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST = false;
+    public static final boolean DEFAULT_REPORT_TO_ANDROID_FRAMEWORK = false;
 
-    public static final int DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES = 3;
+    public static final int DEFAULT_SOCKET_TIMEOUT = 20000;
 
-    public static final int DEFAULT_SOCKET_TIMEOUT = 5000;
-
-    public static final int DEFAULT_CONNECTION_TIMEOUT = 3000;
+    public static final int DEFAULT_CONNECTION_TIMEOUT = 5000;
 
     public static final boolean DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START = true;
 
@@ -98,12 +108,16 @@
 
     public static final int DEFAULT_SHARED_PREFERENCES_MODE = Context.MODE_PRIVATE;
 
+    @DrawableRes
     public static final int DEFAULT_NOTIFICATION_ICON = android.R.drawable.stat_notify_error;
 
+    @DrawableRes
     public static final int DEFAULT_DIALOG_ICON = android.R.drawable.ic_dialog_alert;
 
+    @StringRes
     public static final int DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT = android.R.string.ok;
 
+    @StringRes
     public static final int DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT = android.R.string.cancel;
 
     public static final int DEFAULT_RES_VALUE = 0;
@@ -116,18 +130,14 @@
 
     public static final boolean DEFAULT_LOGCAT_FILTER_BY_PID = false;
 
-    public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
+    public static final boolean DEFAULT_NON_BLOCKING_READ_FOR_LOGCAT = false;
 
-    public static final boolean DEFAULT_SEND_REPORTS_AT_SHUTDOWN = true;
+    public static final boolean DEFAULT_SEND_REPORTS_IN_DEV_MODE = true;
 
     public static final String DEFAULT_APPLICATION_LOGFILE = DEFAULT_STRING_VALUE;
 
     public static final int DEFAULT_APPLICATION_LOGFILE_LINES = DEFAULT_LOGCAT_LINES;
 
-    public static final boolean DEFAULT_DISABLE_SSL_CERT_VALIDATION = false;
-
-    public static final String DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS = "org.acra.util.DefaultHttpsSocketFactoryFactory";
-
     /**
      * Default list of {@link ReportField}s to be sent in email reports. You can
      * set your own list with
@@ -135,7 +145,7 @@
      * 
      * @see org.acra.annotation.ReportsCrashes#mailTo()
      */
-    public final static ReportField[] DEFAULT_MAIL_REPORT_FIELDS = { USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME,
+    public static final ReportField[] DEFAULT_MAIL_REPORT_FIELDS = { USER_COMMENT, ANDROID_VERSION, APP_VERSION_NAME,
             BRAND, PHONE_MODEL, CUSTOM_DATA, STACK_TRACE };
 
     /**
@@ -147,8 +157,11 @@
             PACKAGE_NAME, FILE_PATH, PHONE_MODEL, BRAND, PRODUCT, ANDROID_VERSION, BUILD, TOTAL_MEM_SIZE,
             AVAILABLE_MEM_SIZE, BUILD_CONFIG, CUSTOM_DATA, IS_SILENT, STACK_TRACE, INITIAL_CONFIGURATION, CRASH_CONFIGURATION,
             DISPLAY, USER_COMMENT, USER_EMAIL, USER_APP_START_DATE, USER_CRASH_DATE, DUMPSYS_MEMINFO, LOGCAT,
-            INSTALLATION_ID, DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES, SETTINGS_SYSTEM, SETTINGS_SECURE,
-            SETTINGS_GLOBAL };
+            INSTALLATION_ID, DEVICE_FEATURES, ENVIRONMENT, SHARED_PREFERENCES };
 
     public static final String DATE_TIME_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ";
+
+    public static final String DEFAULT_CERTIFICATE_TYPE = "X.509";
+
+    public static final Element NOT_AVAILABLE = new StringElement("N/A");
 }
diff --git a/src/main/java/org/acra/BaseCrashReportDialog.java b/src/main/java/org/acra/BaseCrashReportDialog.java
deleted file mode 100644
index 6bb1f618..00000000
--- a/src/main/java/org/acra/BaseCrashReportDialog.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.acra;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-import org.acra.collector.CrashReportData;
-import org.acra.util.ToastSender;
-
-import java.io.IOException;
-
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.USER_COMMENT;
-import static org.acra.ReportField.USER_EMAIL;
-
-/**
- * Activity which implements the base functionality for a CrashReportDialog
- * Activities which extend from this class can override onCreate() to create a custom view,
- * but they must call super.onCreate() at the beginning of the method.
- *
- * The methods sendCrash(comment, usrEmail) and cancelReports() can be used to send or cancel
- * sending of reports respectively.
- *
- * This Activity will be instantiated with 2 arguments:
- * <ol>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_FILE_NAME}</li>
- *     <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
- * </ol>
- */
-public abstract class BaseCrashReportDialog extends Activity {
-
-    private String mReportFileName;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ACRA.log.d(ACRA.LOG_TAG, "CrashReportDialog extras=" + getIntent().getExtras());
-
-        final boolean forceCancel = getIntent().getBooleanExtra(ACRAConstants.EXTRA_FORCE_CANCEL, false);
-        if (forceCancel) {
-            ACRA.log.d(ACRA.LOG_TAG, "Forced reports deletion.");
-            cancelReports();
-            finish();
-            return;
-        }
-
-        mReportFileName = getIntent().getStringExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME);
-        Log.d(LOG_TAG, "Opening CrashReportDialog for " + mReportFileName);
-        if (mReportFileName == null) {
-            finish();
-        }
-    }
-
-
-    /**
-     * Cancel any pending crash reports
-     */
-    protected void cancelReports() {
-        ACRA.getErrorReporter().deletePendingNonApprovedReports(false);
-    }
-
-
-    /**
-     * Send crash report given user's comment and email address. If none should be empty strings
-     * @param comment       Comment (may be null) provided by the user.
-     * @param userEmail     Email address (may be null) provided by the client.
-     */
-    protected void sendCrash(String comment, String userEmail) {
-        final CrashReportPersister persister = new CrashReportPersister(getApplicationContext());
-        try {
-            Log.d(LOG_TAG, "Add user comment to " + mReportFileName);
-            final CrashReportData crashData = persister.load(mReportFileName);
-            crashData.put(USER_COMMENT, comment == null ? "" : comment);
-            crashData.put(USER_EMAIL, userEmail == null ? "" : userEmail);
-            persister.store(crashData, mReportFileName);
-        } catch (IOException e) {
-            Log.w(LOG_TAG, "User comment not added: ", e);
-        }
-
-        // Start the report sending task
-        Log.v(ACRA.LOG_TAG, "About to start SenderWorker from CrashReportDialog");
-        ACRA.getErrorReporter().startSendingReports(false, true);
-
-        // Optional Toast to thank the user
-        final int toastId = ACRA.getConfig().resDialogOkToast();
-        if (toastId != 0) {
-            ToastSender.sendToast(getApplicationContext(), toastId, Toast.LENGTH_LONG);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/CrashReportDialog.java b/src/main/java/org/acra/CrashReportDialog.java
index 92a3ca42..f113167f 100644
--- a/src/main/java/org/acra/CrashReportDialog.java
+++ b/src/main/java/org/acra/CrashReportDialog.java
@@ -1,170 +1,20 @@
-package org.acra;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.text.InputType;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.ScrollView;
-import android.widget.TextView;
-
-
-/**
- * This is the dialog Activity used by ACRA to get authorization from the user
- * to send reports. Requires android:launchMode="singleInstance" in your
- * AndroidManifest to work properly.
- **/
-public class CrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener, DialogInterface.OnDismissListener {
-
-    private static final String STATE_EMAIL = "email";
-    private static final String STATE_COMMENT = "comment";
-    private EditText userCommentView;
-    private EditText userEmailView;
-
-    AlertDialog mDialog;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
-        final int titleResourceId = ACRA.getConfig().resDialogTitle();
-        if (titleResourceId != 0) {
-            dialogBuilder.setTitle(titleResourceId);
-        }
-        final int iconResourceId = ACRA.getConfig().resDialogIcon();
-        if (iconResourceId != 0) {
-            dialogBuilder.setIcon(iconResourceId);
-        }
-        dialogBuilder.setView(buildCustomView(savedInstanceState));
-        dialogBuilder.setPositiveButton(getText(ACRA.getConfig().resDialogPositiveButtonText()), CrashReportDialog.this);
-        dialogBuilder.setNegativeButton(getText(ACRA.getConfig().resDialogNegativeButtonText()), CrashReportDialog.this);
-
-        mDialog = dialogBuilder.create();
-        mDialog.setCanceledOnTouchOutside(false);
-        mDialog.setOnDismissListener(this);
-        mDialog.show();
-    }
-
-    protected View buildCustomView(Bundle savedInstanceState) {
-        final LinearLayout root = new LinearLayout(this);
-        root.setOrientation(LinearLayout.VERTICAL);
-        root.setPadding(10, 10, 10, 10);
-        root.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
-        root.setFocusable(true);
-        root.setFocusableInTouchMode(true);
-
-        final ScrollView scroll = new ScrollView(this);
-        root.addView(scroll, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1.0f));
-        final LinearLayout scrollable = new LinearLayout(this);
-        scrollable.setOrientation(LinearLayout.VERTICAL);
-        scroll.addView(scrollable);
-
-        final TextView text = new TextView(this);
-        final int dialogTextId = ACRA.getConfig().resDialogText();
-        if (dialogTextId != 0) {
-            text.setText(getText(dialogTextId));
-        }
-        scrollable.addView(text);
-
-        // Add an optional prompt for user comments
-        final int commentPromptId = ACRA.getConfig().resDialogCommentPrompt();
-        if (commentPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(commentPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,
-                    LayoutParams.WRAP_CONTENT));
-
-            userCommentView = new EditText(this);
-            userCommentView.setLines(2);
-            if (savedInstanceState != null) {
-                String savedValue = savedInstanceState.getString(STATE_COMMENT);
-                if (savedValue != null) {
-                    userCommentView.setText(savedValue);
-                }
-            }
-            scrollable.addView(userCommentView);
-        }
-
-        // Add an optional user email field
-        final int emailPromptId = ACRA.getConfig().resDialogEmailPrompt();
-        if (emailPromptId != 0) {
-            final TextView label = new TextView(this);
-            label.setText(getText(emailPromptId));
-
-            label.setPadding(label.getPaddingLeft(), 10, label.getPaddingRight(), label.getPaddingBottom());
-            scrollable.addView(label);
-
-            userEmailView = new EditText(this);
-            userEmailView.setSingleLine();
-            userEmailView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
-
-            String savedValue = null;
-            if (savedInstanceState != null) {
-                savedValue = savedInstanceState.getString(STATE_EMAIL);
-            }
-            if (savedValue != null) {
-                userEmailView.setText(savedValue);
-            } else {
-                final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-                userEmailView.setText(prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, ""));
-            }
-            scrollable.addView(userEmailView);
-        }
-
-        return root;
-    }
-
-    @Override
-    public void onClick(DialogInterface dialog, int which) {
-        if (which == DialogInterface.BUTTON_POSITIVE) {
-            // Retrieve user comment
-            final String comment = userCommentView != null ? userCommentView.getText().toString() : "";
-
-            // Store the user email
-            final String userEmail;
-            final SharedPreferences prefs = ACRA.getACRASharedPreferences();
-            if (userEmailView != null) {
-                userEmail = userEmailView.getText().toString();
-                final SharedPreferences.Editor prefEditor = prefs.edit();
-                prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS, userEmail);
-                prefEditor.commit();
-            } else {
-                userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "");
-            }
-            sendCrash(comment, userEmail);
-        } else {
-            cancelReports();
-        }
-
-        finish();
-    }
-
-
-    @Override
-    public void onDismiss(DialogInterface dialog) {
-        finish();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (userCommentView != null && userCommentView.getText() != null) {
-            outState.putString(STATE_COMMENT, userCommentView.getText().toString());
-        }
-        if (userEmailView != null && userEmailView.getText() != null) {
-            outState.putString(STATE_EMAIL, userEmailView.getText().toString());
-        }
-    }
+package org.acra;
+
+import android.os.Bundle;
+
+import static org.acra.ACRA.LOG_TAG;
+
+
+/**
+ * Old crash report dialog.
+ *
+ * @deprecated since 4.8.0 use {@link org.acra.dialog.CrashReportDialog} instead
+ **/
+public final class CrashReportDialog extends org.acra.dialog.CrashReportDialog {
+
+    @Override
+    protected void buildAndShowDialog(Bundle savedInstanceState){
+        ACRA.log.w(LOG_TAG, "org.acra.CrashReportDialog has been deprecated. Please use org.acra.dialog.CrashReportDialog instead");
+        super.buildAndShowDialog(savedInstanceState);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/CrashReportFinder.java b/src/main/java/org/acra/CrashReportFinder.java
deleted file mode 100644
index f7562c1b..00000000
--- a/src/main/java/org/acra/CrashReportFinder.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.File;
-import java.io.FilenameFilter;
-
-import android.content.Context;
-import android.util.Log;
-
-/**
- * Responsible for retrieving the location of Crash Report files.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-final class CrashReportFinder {
-
-    private final Context context;
-
-    public CrashReportFinder(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * Returns an array containing the names of pending crash report files.
-     *
-     * @return an array containing the names of pending crash report files.
-     */
-    public String[] getCrashReportFiles() {
-        if (context == null) {
-            Log.e(LOG_TAG, "Trying to get ACRA reports but ACRA is not initialized.");
-            return new String[0];
-        }
-
-        final File dir = context.getFilesDir();
-        if (dir == null) {
-            Log.w(LOG_TAG, "Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
-            return new String[0];
-        }
-
-        Log.d(LOG_TAG, "Looking for error files in " + dir.getAbsolutePath());
-
-        // Filter for ".stacktrace" files
-        final FilenameFilter filter = new FilenameFilter() {
-            public boolean accept(File dir, String name) {
-                return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
-            }
-        };
-        final String[] result = dir.list(filter);
-        return (result == null) ? new String[0] : result;
-    }
-}
diff --git a/src/main/java/org/acra/CrashReportPersister.java b/src/main/java/org/acra/CrashReportPersister.java
deleted file mode 100644
index 8f94084b..00000000
--- a/src/main/java/org/acra/CrashReportPersister.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/*
- * java.util.Properties.java modified by Kevin Gaudin to allow usage of enums as keys.
- * 
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra;
-
-import android.content.Context;
-
-import org.acra.collector.CollectorUtil;
-import org.acra.collector.CrashReportData;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Reader;
-import java.util.Map;
-
-/**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link java.util.Properties} adapted to extend an
- * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
- * amounts of android time in the generation of a date comment when storing to
- * file.
- */
-final class CrashReportPersister {
-
-    private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;
-    private static final String LINE_SEPARATOR = "\n";
-
-    private final Context context;
-
-    CrashReportPersister(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * Loads properties from the specified {@code InputStream}. The encoding is
-     * ISO8859-1.
-     *
-     * @param fileName  Name of the report file from which to load the CrashData.
-     * @return CrashReportData read from the supplied InputStream.
-     * @throws java.io.IOException if error occurs during reading from the {@code InputStream}.
-     */
-    public CrashReportData load(String fileName) throws IOException {
-
-        final FileInputStream in = context.openFileInput(fileName);
-        if (in == null) {
-            throw new IllegalArgumentException("Invalid crash report fileName : " + fileName);
-        }
-
-        try {
-            final BufferedInputStream bis = new BufferedInputStream(in, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-            bis.mark(Integer.MAX_VALUE);
-            final boolean isEbcdic = isEbcdic(bis);
-            bis.reset();
-
-            if (!isEbcdic) {
-                return load(new InputStreamReader(bis, "ISO8859-1")); //$NON-NLS-1$
-            } else {
-                return load(new InputStreamReader(bis)); //$NON-NLS-1$
-            }
-        } finally {
-            in.close();
-        }
-    }
-
-    /**
-     * Stores the mappings in this Properties to the specified OutputStream,
-     * putting the specified comment at the beginning. The output from this
-     * method is suitable for being read by the load() method.
-     *
-     * @param crashData    CrashReportData to save.
-     * @param fileName      Name of the file to which to store the CrashReportData.
-     * @throws java.io.IOException if the CrashReportData could not be written to the OutputStream.
-     */
-    public void store(CrashReportData crashData, String fileName) throws IOException {
-
-        final OutputStream out = context.openFileOutput(fileName, Context.MODE_PRIVATE);
-        try {
-            final StringBuilder buffer = new StringBuilder(200);
-            final OutputStreamWriter writer = new OutputStreamWriter(out, "ISO8859_1"); //$NON-NLS-1$
-
-            for (final Map.Entry<ReportField, String> entry : crashData.entrySet()) {
-                final String key = entry.getKey().toString();
-                dumpString(buffer, key, true);
-                buffer.append('=');
-                dumpString(buffer, entry.getValue(), false);
-                buffer.append(LINE_SEPARATOR);
-                writer.write(buffer.toString());
-                buffer.setLength(0);
-            }
-            writer.flush();
-        } finally {
-            out.close();
-        }
-    }
-
-    private boolean isEbcdic(BufferedInputStream in) throws IOException {
-        byte b;
-        while ((b = (byte) in.read()) != -1) {
-            if (b == 0x23 || b == 0x0a || b == 0x3d) {// ascii: newline/#/=
-                return false;
-            }
-            if (b == 0x15) {// EBCDIC newline
-                return true;
-            }
-        }
-        // we found no ascii newline, '#', neither '=', relative safe to
-        // consider it
-        // as non-ascii, the only exception will be a single line with only
-        // key(no value and '=')
-        // in this case, it should be no harm to read it in default charset
-        return false;
-    }
-
-    /**
-     * Loads properties from the specified InputStream. The properties are of
-     * the form <code>key=value</code>, one property per line. It may be not
-     * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
-     * according to the following rules:
-     * <ul>
-     * <li>Empty lines are ignored.</li>
-     * <li>Lines starting with either a "#" or a "!" are comment lines and are
-     * ignored.</li>
-     * <li>A backslash at the end of the line escapes the following newline
-     * character ("\r", "\n", "\r\n"). If there's a whitespace after the
-     * backslash it will just escape that whitespace instead of concatenating
-     * the lines. This does not apply to comment lines.</li>
-     * <li>A property line consists of the key, the space between the key and
-     * the value, and the value. The key goes up to the first whitespace, "=" or
-     * ":" that is not escaped. The space between the key and the value contains
-     * either one whitespace, one "=" or one ":" and any number of additional
-     * whitespaces before and after that character. The value starts with the
-     * first character after the space between the key and the value.</li>
-     * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
-     * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
-     * </ul>
-     *
-     * @param reader    Reader from which to read the properties of this CrashReportData.
-     * @return CrashReportData read from the supplied Reader.
-     * @throws java.io.IOException if the properties could not be read.
-     * @since 1.6
-     */
-    private synchronized CrashReportData load(Reader reader) throws IOException {
-        int mode = NONE, unicode = 0, count = 0;
-        char nextChar, buf[] = new char[40];
-        int offset = 0, keyLength = -1, intVal;
-        boolean firstChar = true;
-
-        final CrashReportData crashData = new CrashReportData();
-        final BufferedReader br = new BufferedReader(reader, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-        while (true) {
-            intVal = br.read();
-            if (intVal == -1) {
-                break;
-            }
-            nextChar = (char) intVal;
-
-            if (offset == buf.length) {
-                final char[] newBuf = new char[buf.length * 2];
-                System.arraycopy(buf, 0, newBuf, 0, offset);
-                buf = newBuf;
-            }
-            if (mode == UNICODE) {
-                final int digit = Character.digit(nextChar, 16);
-                if (digit >= 0) {
-                    unicode = (unicode << 4) + digit;
-                    if (++count < 4) {
-                        continue;
-                    }
-                } else if (count <= 4) {
-                    // luni.09=Invalid Unicode sequence: illegal character
-                    throw new IllegalArgumentException("luni.09");
-                }
-                mode = NONE;
-                buf[offset++] = (char) unicode;
-                if (nextChar != '\n' && nextChar != '\u0085') {
-                    continue;
-                }
-            }
-            if (mode == SLASH) {
-                mode = NONE;
-                switch (nextChar) {
-                case '\r':
-                    mode = CONTINUE; // Look for a following \n
-                    continue;
-                case '\u0085':
-                case '\n':
-                    mode = IGNORE; // Ignore whitespace on the next line
-                    continue;
-                case 'b':
-                    nextChar = '\b';
-                    break;
-                case 'f':
-                    nextChar = '\f';
-                    break;
-                case 'n':
-                    nextChar = '\n';
-                    break;
-                case 'r':
-                    nextChar = '\r';
-                    break;
-                case 't':
-                    nextChar = '\t';
-                    break;
-                case 'u':
-                    mode = UNICODE;
-                    unicode = count = 0;
-                    continue;
-                }
-            } else {
-                switch (nextChar) {
-                case '#':
-                case '!':
-                    if (firstChar) {
-                        while (true) {
-                            intVal = br.read();
-                            if (intVal == -1) {
-                                break;
-                            }
-                            nextChar = (char) intVal; // & 0xff
-                                                      // not
-                                                      // required
-                            if (nextChar == '\r' || nextChar == '\n' || nextChar == '\u0085') {
-                                break;
-                            }
-                        }
-                        continue;
-                    }
-                    break;
-                case '\n':
-                    if (mode == CONTINUE) { // Part of a \r\n sequence
-                        mode = IGNORE; // Ignore whitespace on the next line
-                        continue;
-                    }
-                    // fall into the next case
-                case '\u0085':
-                case '\r':
-                    mode = NONE;
-                    firstChar = true;
-                    if (offset > 0 || (offset == 0 && keyLength == 0)) {
-                        if (keyLength == -1) {
-                            keyLength = offset;
-                        }
-                        final String temp = new String(buf, 0, offset);
-                        crashData.put(Enum.valueOf(ReportField.class, temp.substring(0, keyLength)), temp.substring(keyLength));
-                    }
-                    keyLength = -1;
-                    offset = 0;
-                    continue;
-                case '\\':
-                    if (mode == KEY_DONE) {
-                        keyLength = offset;
-                    }
-                    mode = SLASH;
-                    continue;
-                case ':':
-                case '=':
-                    if (keyLength == -1) { // if parsing the key
-                        mode = NONE;
-                        keyLength = offset;
-                        continue;
-                    }
-                    break;
-                }
-                if (Character.isWhitespace(nextChar)) {
-                    if (mode == CONTINUE) {
-                        mode = IGNORE;
-                    }
-                    // if key length == 0 or value length == 0
-                    if (offset == 0 || offset == keyLength || mode == IGNORE) {
-                        continue;
-                    }
-                    if (keyLength == -1) { // if parsing the key
-                        mode = KEY_DONE;
-                        continue;
-                    }
-                }
-                if (mode == IGNORE || mode == CONTINUE) {
-                    mode = NONE;
-                }
-            }
-            firstChar = false;
-            if (mode == KEY_DONE) {
-                keyLength = offset;
-                mode = NONE;
-            }
-            buf[offset++] = nextChar;
-        }
-        if (mode == UNICODE && count <= 4) {
-            // luni.08=Invalid Unicode sequence: expected format \\uxxxx
-            throw new IllegalArgumentException("luni.08");
-        }
-        if (keyLength == -1 && offset > 0) {
-            keyLength = offset;
-        }
-        if (keyLength >= 0) {
-            final String temp = new String(buf, 0, offset);
-            final ReportField key = Enum.valueOf(ReportField.class, temp.substring(0, keyLength));
-            String value = temp.substring(keyLength);
-            if (mode == SLASH) {
-                value += "\u0000";
-            }
-            crashData.put(key, value);
-        }
-        
-        CollectorUtil.safeClose(reader);
-
-        return crashData;
-    }
-
-    /**
-     * Constructs a new {@code Properties} object.
-     *
-     * @param buffer    StringBuilder to populate with the supplied property.
-     * @param string    String to append to the buffer.
-     * @param key       Whether the String is a key value or not.
-     */
-    private void dumpString(StringBuilder buffer, String string, boolean key) {
-        int i = 0;
-        if (!key && i < string.length() && string.charAt(i) == ' ') {
-            buffer.append("\\ "); //$NON-NLS-1$
-            i++;
-        }
-
-        for (; i < string.length(); i++) {
-            char ch = string.charAt(i);
-            switch (ch) {
-            case '\t':
-                buffer.append("\\t"); //$NON-NLS-1$
-                break;
-            case '\n':
-                buffer.append("\\n"); //$NON-NLS-1$
-                break;
-            case '\f':
-                buffer.append("\\f"); //$NON-NLS-1$
-                break;
-            case '\r':
-                buffer.append("\\r"); //$NON-NLS-1$
-                break;
-            default:
-                if ("\\#!=:".indexOf(ch) >= 0 || (key && ch == ' ')) {
-                    buffer.append('\\');
-                }
-                if (ch >= ' ' && ch <= '~') {
-                    buffer.append(ch);
-                } else {
-                    final String hex = Integer.toHexString(ch);
-                    buffer.append("\\u"); //$NON-NLS-1$
-                    for (int j = 0; j < 4 - hex.length(); j++) {
-                        buffer.append("0"); //$NON-NLS-1$
-                    }
-                    buffer.append(hex);
-                }
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/acra/ErrorReporter.java b/src/main/java/org/acra/ErrorReporter.java
index b3b62b44..9cd9ed8e 100644
--- a/src/main/java/org/acra/ErrorReporter.java
+++ b/src/main/java/org/acra/ErrorReporter.java
@@ -15,45 +15,29 @@
  */
 package org.acra;
 
-import android.Manifest.permission;
-import android.app.Activity;
 import android.app.Application;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.os.Bundle;
-import android.os.Looper;
-import android.text.format.Time;
-import android.util.Log;
-import android.widget.Toast;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import org.acra.annotation.ReportsCrashes;
-import org.acra.collector.Compatibility;
+import org.acra.builder.LastActivityManager;
+import org.acra.builder.NoOpReportPrimer;
+import org.acra.builder.ReportBuilder;
+import org.acra.builder.ReportExecutor;
+import org.acra.builder.ReportPrimer;
 import org.acra.collector.ConfigurationCollector;
-import org.acra.collector.CrashReportData;
 import org.acra.collector.CrashReportDataFactory;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat;
-import org.acra.jraf.android.util.activitylifecyclecallbackscompat.ApplicationHelper;
-import org.acra.sender.EmailIntentSender;
-import org.acra.sender.HttpSender;
-import org.acra.sender.ReportSender;
-import org.acra.util.PackageManagerWrapper;
-import org.acra.util.ToastSender;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.util.ApplicationStartupProcessor;
+import org.acra.util.ProcessFinisher;
 
-import java.io.File;
 import java.lang.Thread.UncaughtExceptionHandler;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
 
 import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.IS_SILENT;
 
 /**
  * <p>
@@ -81,158 +65,82 @@
  */
 public class ErrorReporter implements Thread.UncaughtExceptionHandler {
 
-    private boolean enabled = false;
-
-    private final Application mContext;
-    private final SharedPreferences prefs;
+    private final boolean supportedAndroidVersion;
 
-    /**
-     * Contains the active {@link ReportSender}s.
-     */
-    private final List<ReportSender> mReportSenders = new ArrayList<ReportSender>();
+    private final Application context;
+    @NonNull
+    private final ACRAConfiguration config;
 
+    @NonNull
     private final CrashReportDataFactory crashReportDataFactory;
+    @NonNull
+    private final ReportExecutor reportExecutor;
 
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-
-    // A reference to the system's previous default UncaughtExceptionHandler
-    // kept in order to execute the default exception handling after sending the
-    // report.
-    private final Thread.UncaughtExceptionHandler mDfltExceptionHandler;
-
-    private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(null);
-
-    /**
-     * This is used to wait for the crash toast to end it's display duration
-     * before killing the Application.
-     */
-    private static boolean toastWaitEnded = true;
-
-    private static final ExceptionHandlerInitializer NULL_EXCEPTION_HANDLER_INITIALIZER = new ExceptionHandlerInitializer() {
+    @NonNull
+    private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = new ExceptionHandlerInitializer() {
         @Override
         public void initializeExceptionHandler(ErrorReporter reporter) {
         }
     };
 
-    private volatile ExceptionHandlerInitializer exceptionHandlerInitializer = NULL_EXCEPTION_HANDLER_INITIALIZER;
-
-    /**
-     * Used to create a new (non-cached) PendingIntent each time a new crash occurs.
-     */
-    private static int mNotificationCounter = 0;
 
     /**
      * Can only be constructed from within this class.
      *
-     * @param context
-     *            Context for the application in which ACRA is running.
-     * @param prefs
-     *            SharedPreferences used by ACRA.
-     * @param enabled
-     *            Whether this ErrorReporter should capture Exceptions and
-     *            forward their reports.
+     * @param context   Context for the application in which ACRA is running.
+     * @param config    AcraConfig to use when reporting and sending errors.
+     * @param prefs     SharedPreferences used by ACRA.
+     * @param enabled   Whether this ErrorReporter should capture Exceptions and forward their reports.
+     * @param listenForUncaughtExceptions   Whether to listen for uncaught Exceptions.
      */
-    ErrorReporter(Application context, SharedPreferences prefs, boolean enabled) {
+    ErrorReporter(@NonNull Application context, @NonNull ACRAConfiguration config, @NonNull SharedPreferences prefs,
+                  boolean enabled, boolean supportedAndroidVersion, boolean listenForUncaughtExceptions) {
 
-        this.mContext = context;
-        this.prefs = prefs;
-        this.enabled = enabled;
+        this.context = context;
+        this.config = config;
+        this.supportedAndroidVersion = supportedAndroidVersion;
 
         // Store the initial Configuration state.
-        final String initialConfiguration = ConfigurationCollector.collectConfiguration(mContext);
+        // This is expensive to gather, so only do so if we plan to report it.
+        final Element initialConfiguration;
+        if (config.getReportFields().contains(ReportField.INITIAL_CONFIGURATION)) {
+            initialConfiguration = ConfigurationCollector.collectConfiguration(this.context);
+        } else {
+            initialConfiguration = ACRAConstants.NOT_AVAILABLE;
+        }
 
         // Sets the application start date.
-        // This will be included in the reports, will be helpful compared to
-        // user_crash date.
-        final Time appStartDate = new Time();
-        appStartDate.setToNow();
-
-        if (Compatibility.getAPILevel() >= 14) { // ActivityLifecycleCallback
-            // only available for API14+
-            ApplicationHelper.registerActivityLifecycleCallbacks(context, new ActivityLifecycleCallbacksCompat() {
-                @Override
-                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(ACRA.LOG_TAG, "onActivityCreated " + activity.getClass());
-                    if (!(activity instanceof BaseCrashReportDialog)) {
-                        // Ignore CrashReportDialog because we want the last
-                        // application Activity that was started so that we can
-                        // explicitly kill it off.
-                        lastActivityCreated = new WeakReference<Activity>(activity);
-                    }
-                }
-
-                @Override
-                public void onActivityStarted(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(ACRA.LOG_TAG, "onActivityStarted " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityResumed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(ACRA.LOG_TAG, "onActivityResumed " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityPaused(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(ACRA.LOG_TAG, "onActivityPaused " + activity.getClass());
-                }
-
-                @Override
-                public void onActivityStopped(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.d(ACRA.LOG_TAG, "onActivityStopped " + activity.getClass());
-                }
+        // This will be included in the reports, will be helpful compared to user_crash date.
+        final Calendar appStartDate = new GregorianCalendar();
 
-                @Override
-                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(ACRA.LOG_TAG, "onActivitySaveInstanceState " + activity.getClass());
-                }
+        crashReportDataFactory = new CrashReportDataFactory(this.context, config, prefs, appStartDate, initialConfiguration);
 
-                @Override
-                public void onActivityDestroyed(Activity activity) {
-                    if (ACRA.DEV_LOGGING)
-                        ACRA.log.i(ACRA.LOG_TAG, "onActivityDestroyed " + activity.getClass());
-                }
-            });
+        final Thread.UncaughtExceptionHandler defaultExceptionHandler;
+        if (listenForUncaughtExceptions) {
+            defaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+            Thread.setDefaultUncaughtExceptionHandler(this);
+        } else {
+            defaultExceptionHandler = null;
         }
 
-        crashReportDataFactory = new CrashReportDataFactory(mContext, prefs, appStartDate, initialConfiguration);
+        final LastActivityManager lastActivityManager = new LastActivityManager(this.context);
+        final ReportPrimer reportPrimer = getReportPrimer(config);
+        final ProcessFinisher processFinisher = new ProcessFinisher(context, config, lastActivityManager);
 
-        // If mDfltExceptionHandler is not null, initialization is already done.
-        // Don't do it twice to avoid losing the original handler.
-        mDfltExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-        Thread.setDefaultUncaughtExceptionHandler(this);
-    }
-
-    /**
-     * @return the current instance of ErrorReporter.
-     * @throws IllegalStateException
-     *             if {@link ACRA#init(android.app.Application)} has not yet
-     *             been called.
-     * @deprecated since 4.3.0 Use {@link org.acra.ACRA#getErrorReporter()}
-     *             instead.
-     */
-    @Deprecated
-    public static ErrorReporter getInstance() {
-        return ACRA.getErrorReporter();
+        reportExecutor = new ReportExecutor(context, config, crashReportDataFactory, defaultExceptionHandler, reportPrimer, processFinisher);
+        reportExecutor.setEnabled(enabled);
     }
 
     /**
      * Deprecated. Use {@link #putCustomData(String, String)}.
      *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
      */
     @Deprecated
     @SuppressWarnings("unused")
-    public void addCustomData(String key, String value) {
-        crashReportDataFactory.putCustomData(key, value);
+    public void addCustomData(@NonNull String key, String value) {
+        putCustomData(key, value);
     }
 
     /**
@@ -243,21 +151,15 @@ public void addCustomData(String key, String value) {
      * latest value is kept for each key (no history of the values is sent in
      * the report).
      * </p>
-     * <p>
-     * The key/value pairs will be stored in the GoogleDoc spreadsheet in the
-     * "custom" column, as a text containing a 'key = value' pair on each line.
-     * </p>
      *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
      * @return The previous value for this key if there was one, or null.
      * @see #removeCustomData(String)
      * @see #getCustomData(String)
      */
     @SuppressWarnings("unused")
-    public String putCustomData(String key, String value) {
+    public String putCustomData(@NonNull String key, String value) {
         return crashReportDataFactory.putCustomData(key, value);
     }
 
@@ -278,7 +180,7 @@ public String putCustomData(String key, String value) {
      * <p>
      * Example. Add to the {@link Application#onCreate()}:
      * </p>
-     * 
+     *
      * <pre>
      * ACRA.getErrorReporter().setExceptionHandlerInitializer(new ExceptionHandlerInitializer() {
      *     <code>@Override</code> public void initializeExceptionHandler(ErrorReporter reporter) {
@@ -286,24 +188,30 @@ public String putCustomData(String key, String value) {
      *     }
      * });
      * </pre>
-     * 
+     *
      * @param initializer   The initializer. Can be <code>null</code>.
-     */
-    public void setExceptionHandlerInitializer(ExceptionHandlerInitializer initializer) {
-        exceptionHandlerInitializer = (initializer != null) ? initializer : NULL_EXCEPTION_HANDLER_INITIALIZER;
+     * @deprecated since 4.8.0 use {@link ReportPrimer} mechanism instead.
+     */
+    public void setExceptionHandlerInitializer(@Nullable ExceptionHandlerInitializer initializer) {
+        exceptionHandlerInitializer = (initializer != null)
+                ? initializer
+                : new ExceptionHandlerInitializer() {
+                    @Override
+                    public void initializeExceptionHandler(ErrorReporter reporter) {
+                    }
+                };
     }
 
     /**
      * Removes a key/value pair from your reports custom data field.
      *
-     * @param key
-     *            The key of the data to be removed.
+     * @param key   The key of the data to be removed.
      * @return The value for this key before removal.
      * @see #putCustomData(String, String)
      * @see #getCustomData(String)
      */
     @SuppressWarnings("unused")
-    public String removeCustomData(String key) {
+    public String removeCustomData(@NonNull String key) {
         return crashReportDataFactory.removeCustomData(key);
     }
 
@@ -325,70 +233,10 @@ public void clearCustomData() {
      * @see #removeCustomData(String)
      */
     @SuppressWarnings("unused")
-    public String getCustomData(String key) {
+    public String getCustomData(@NonNull String key) {
         return crashReportDataFactory.getCustomData(key);
     }
 
-    /**
-     * Add a {@link ReportSender} to the list of active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} to be added.
-     */
-    public void addReportSender(ReportSender sender) {
-        mReportSenders.add(sender);
-    }
-
-    /**
-     * Remove a specific instance of {@link ReportSender} from the list of
-     * active {@link ReportSender}s.
-     *
-     * @param sender
-     *            The {@link ReportSender} instance to be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSender(ReportSender sender) {
-        mReportSenders.remove(sender);
-    }
-
-    /**
-     * Remove all {@link ReportSender} instances from a specific class.
-     *
-     * @param senderClass
-     *            ReportSender class whose instances should be removed.
-     */
-    @SuppressWarnings("unused")
-    public void removeReportSenders(Class<?> senderClass) {
-        if (ReportSender.class.isAssignableFrom(senderClass)) {
-            for (ReportSender sender : mReportSenders) {
-                if (senderClass.isInstance(sender)) {
-                    mReportSenders.remove(sender);
-                }
-            }
-        }
-    }
-
-    /**
-     * Clears the list of active {@link ReportSender}s. You should then call
-     * {@link #addReportSender(ReportSender)} or ACRA will not send any report
-     * anymore.
-     */
-    public void removeAllReportSenders() {
-        mReportSenders.clear();
-    }
-
-    /**
-     * Removes all previously set {@link ReportSender}s and set the given one as
-     * the new {@link ReportSender}.
-     *
-     * @param sender
-     *            ReportSender to set as the sole sender for this ErrorReporter.
-     */
-    public void setReportSender(ReportSender sender) {
-        removeAllReportSenders();
-        addReportSender(sender);
-    }
-
     /*
      * (non-Javadoc)
      *
@@ -397,103 +245,47 @@ public void setReportSender(ReportSender sender) {
      * .Thread, java.lang.Throwable)
      */
     @Override
-    public void uncaughtException(Thread t, Throwable e) {
+    public void uncaughtException(@Nullable Thread t, @NonNull Throwable e) {
+
+        // If we're not enabled then just pass the Exception on to the defaultExceptionHandler.
+        if (!reportExecutor.isEnabled()) {
+            reportExecutor.handReportToDefaultExceptionHandler(t, e);
+            return;
+        }
+
         try {
-            // If we're not enabled then just pass the Exception on to any
-            // defaultExceptionHandler.
-            if (!enabled) {
-                if (mDfltExceptionHandler != null) {
-                    Log.e(ACRA.LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - forwarding uncaught Exception on to default ExceptionHandler");
-                    mDfltExceptionHandler.uncaughtException(t, e);
-                } else {
-                    Log.e(ACRA.LOG_TAG, "ACRA is disabled for " + mContext.getPackageName()
-                        + " - no default ExceptionHandler");
-                    Log.e(ACRA.LOG_TAG,
-                          "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-                }
-                return;
-            }
+            ACRA.log.e(LOG_TAG, "ACRA caught a " + e.getClass().getSimpleName() + " for " + context.getPackageName(), e);
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Building report");
 
-            Log.e(ACRA.LOG_TAG,
-                  "ACRA caught a " + e.getClass().getSimpleName() + " for " + mContext.getPackageName(), e);
-            Log.d(ACRA.LOG_TAG, "Building report");
+            performDeprecatedReportPriming();
 
             // Generate and send crash report
-            reportBuilder()
+            new ReportBuilder()
                 .uncaughtExceptionThread(t)
                 .exception(e)
-                .endsApplication()
-                .send();
-        } catch (Throwable fatality) {
-            // ACRA failed. Prevent any recursive call to
-            // ACRA.uncaughtException(), let the native reporter do its job.
-            if (mDfltExceptionHandler != null) {
-                mDfltExceptionHandler.uncaughtException(t, e);
-            }
-        }
-    }
-
-    /**
-     * End the application.
-     */
-    private void endApplication(Thread uncaughtExceptionThread, Throwable th) {
-        // TODO It would be better to create an explicit config attribute #letDefaultHandlerEndApplication
-        // as the intent is clearer and would allows you to switch it off for SILENT.
-        final boolean letDefaultHandlerEndApplication = (
-             ACRA.getConfig().mode() == ReportingInteractionMode.SILENT ||
-            (ACRA.getConfig().mode() == ReportingInteractionMode.TOAST && ACRA.getConfig().forceCloseDialogAfterToast())
-        );
+                .endApplication()
+                .build(reportExecutor);
 
-        final boolean handlingUncaughtException = uncaughtExceptionThread != null;
-        if (handlingUncaughtException && letDefaultHandlerEndApplication && (mDfltExceptionHandler != null)) {
-            // Let the system default handler do it's job and display the force close dialog.
-            Log.d(ACRA.LOG_TAG, "Handing Exception on to default ExceptionHandler");
-            mDfltExceptionHandler.uncaughtException(uncaughtExceptionThread, th);
-        } else {
-            // If ACRA handles user notifications with a Toast or a Notification
-            // the Force Close dialog is one more notification to the user...
-            // We choose to close the process ourselves using the same actions.
-            Log.e(LOG_TAG, mContext.getPackageName() + " fatal error : " + th.getMessage(), th);
-
-            // Trying to solve
-            // https://github.com/ACRA/acra/issues/42#issuecomment-12134144
-            // Determine the current/last Activity that was started and close
-            // it. Activity#finish (and maybe it's parent too).
-            final Activity lastActivity = lastActivityCreated.get();
-            if (lastActivity != null) {
-                Log.i(LOG_TAG, "Finishing the last Activity prior to killing the Process");
-                lastActivity.finish();
-                Log.i(LOG_TAG, "Finished " + lastActivity.getClass());
-                lastActivityCreated.clear();
-            }
-
-            android.os.Process.killProcess(android.os.Process.myPid());
-            System.exit(10);
+        } catch (Throwable fatality) {
+            // ACRA failed. Prevent any recursive call to ACRA.uncaughtException(), let the native reporter do its job.
+            ACRA.log.e(LOG_TAG, "ACRA failed to capture the error - handing off to native error reporter" , fatality);
+            reportExecutor.handReportToDefaultExceptionHandler(t, e);
         }
     }
 
     /**
-     * Send a report for this {@link Throwable} silently (forces the use of
-     * {@link ReportingInteractionMode#SILENT} for this report, whatever is the
-     * mode set for the application. Very useful for tracking difficult defects.
+     * Mark this report as silent as send it.
      *
-     * @param e
-     *            The {@link Throwable} to be reported. If null the report will
-     *            contain a new Exception("Report requested by developer").
+     * @param e The {@link Throwable} to be reported. If null the report will
+     *          contain a new Exception("Report requested by developer").
      */
-    public void handleSilentException(Throwable e) {
-        // Mark this report as silent.
-        if (enabled) {
-            reportBuilder()
+    @SuppressWarnings("unused")
+    public void handleSilentException(@Nullable Throwable e) {
+        performDeprecatedReportPriming();
+        new ReportBuilder()
                 .exception(e)
-                .forceSilent()
-                .send();
-            Log.d(LOG_TAG, "ACRA sent Silent report.");
-            return;
-        }
-
-        Log.d(LOG_TAG, "ACRA is disabled. Silent report not sent.");
+                .sendSilently()
+                .build(reportExecutor);
     }
 
     /**
@@ -504,113 +296,38 @@ public void handleSilentException(Throwable e) {
      *            forward them as crash reports.
      */
     public void setEnabled(boolean enabled) {
-        Log.i(ACRA.LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled") + " for " + mContext.getPackageName());
-        this.enabled = enabled;
+        if (supportedAndroidVersion) {
+            ACRA.log.i(LOG_TAG, "ACRA is " + (enabled ? "enabled" : "disabled") + " for " + context.getPackageName());
+            reportExecutor.setEnabled(enabled);
+        } else {
+            ACRA.log.w(LOG_TAG, "ACRA 4.7.0+ requires Froyo or greater. ACRA is disabled and will NOT catch crashes or send messages.");
+        }
     }
 
     /**
-     * Starts a Thread to start sending outstanding error reports.
+     * This method looks for pending reports and does the action required depending on the interaction mode set.
      *
-     * @param onlySendSilentReports
-     *            If true then only send silent reports.
-     * @param approveReportsFirst
-     *            If true then approve unapproved reports first.
-     * @return SendWorker that will be sending the report.s
-     */
-    SendWorker startSendingReports(boolean onlySendSilentReports, boolean approveReportsFirst) {
-        final SendWorker worker = new SendWorker(mContext, mReportSenders, onlySendSilentReports, approveReportsFirst);
-        worker.start();
-        return worker;
-    }
-
-    /**
-     * Delete all report files stored.
-     */
-    void deletePendingReports() {
-        deletePendingReports(true, true, 0);
-    }
-
-    /**
-     * This method looks for pending reports and does the action required
-     * depending on the interaction mode set.
+     * There is no need to call this method as ACRA will by default check for errors on report start.
+     *
+     * Whether ACRA checks for reports on app start is controlled by {@link ACRA#init(Application, ACRAConfiguration, boolean)},
+     * but the default is that it will.
+     *
+     * @deprecated since 4.8.0 No replacement.
      */
+    @SuppressWarnings( " unused" )
     public void checkReportsOnApplicationStart() {
-
-        if (ACRA.getConfig().deleteOldUnsentReportsOnApplicationStart()) {
-            // Delete any old unsent reports if this is a newer version of the app
-            // than when we last started.
-            final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR, 0);
-            final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(mContext);
-            final PackageInfo packageInfo = packageManagerWrapper.getPackageInfo();
-            if (packageInfo != null) {
-                final boolean newVersion = packageInfo.versionCode > lastVersionNr;
-                if (newVersion) {
-                    deletePendingReports();
-                }
-                final SharedPreferences.Editor prefsEditor = prefs.edit();
-                prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR, packageInfo.versionCode);
-                prefsEditor.commit();
-            }
+        final ApplicationStartupProcessor startupProcessor = new ApplicationStartupProcessor(context,  config);
+        if (config.deleteOldUnsentReportsOnApplicationStart()) {
+            startupProcessor.deleteUnsentReportsFromOldAppVersion();
         }
-
-        ReportingInteractionMode reportingInteractionMode = ACRA.getConfig().mode();
-
-        if ((reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && ACRA.getConfig().deleteUnapprovedReportsOnApplicationStart()) {
-            // NOTIFICATION or DIALOG mode, and there are unapproved reports to
-            // send (latest notification/dialog has been ignored: neither
-            // accepted
-            // nor refused). The application developer has decided that
-            // these reports should not be renotified ==> destroy them all but
-            // one.
-            deletePendingNonApprovedReports(true);
+        if (config.deleteUnapprovedReportsOnApplicationStart()) {
+            startupProcessor.deleteAllUnapprovedReportsBarOne();
         }
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        String[] filesList = reportFinder.getCrashReportFiles();
-
-        if (filesList != null && filesList.length > 0) {
-            // Immediately send reports for SILENT and TOAST modes.
-            // Immediately send reports in NOTIFICATION mode only if they are
-            // all silent or approved.
-            // If there is still one unapproved report in NOTIFICATION mode,
-            // notify it.
-            // If there are unapproved reports in DIALOG mode, show the dialog
-
-
-            final boolean onlySilentOrApprovedReports = containsOnlySilentOrApprovedReports(filesList);
-
-            if (reportingInteractionMode == ReportingInteractionMode.SILENT
-                || reportingInteractionMode == ReportingInteractionMode.TOAST
-                || (onlySilentOrApprovedReports && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG))) {
-
-                if (reportingInteractionMode == ReportingInteractionMode.TOAST && !onlySilentOrApprovedReports) {
-                    // Display the Toast in TOAST mode only if there are
-                    // non-silent reports.
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                }
-
-                Log.v(ACRA.LOG_TAG, "About to start ReportSenderWorker from #checkReportOnApplicationStart");
-                startSendingReports(false, false);
-            }
-
+        if (reportExecutor.isEnabled()) {
+            startupProcessor.sendApprovedReports();
         }
     }
 
-    /**
-     * Delete all pending non approved reports.
-     *
-     * @param keepOne
-     *            If you need to keep the latest report, set this to true.
-     */
-    void deletePendingNonApprovedReports(boolean keepOne) {
-        // In NOTIFICATION AND DIALOG mode, we have to keep the latest report
-        // which
-        // has been written before killing the app.
-        final int nbReportsToKeep = keepOne ? 1 : 0;
-        deletePendingReports(false, true, nbReportsToKeep);
-    }
-
     /**
      * Send a report for a {@link Throwable} with the reporting interaction mode
      * configured by the developer.
@@ -623,13 +340,14 @@ void deletePendingNonApprovedReports(boolean keepOne) {
      *            sending the report.
      */
     @SuppressWarnings("unused")
-    public void handleException(Throwable e, boolean endApplication) {
-        final ReportBuilder builder = reportBuilder()
-            .exception(e);
+    public void handleException(@Nullable Throwable e, boolean endApplication) {
+        performDeprecatedReportPriming();
+        final ReportBuilder builder = new ReportBuilder();
+        builder.exception(e);
         if (endApplication) {
-            builder.endsApplication();
+            builder.endApplication();
         }
-        builder.send();
+        builder.build(reportExecutor);
     }
 
     /**
@@ -642,493 +360,32 @@ public void handleException(Throwable e, boolean endApplication) {
      *            contain a new Exception("Report requested by developer").
      */
     @SuppressWarnings("unused")
-    public void handleException(Throwable e) {
-        reportBuilder()
-            .exception(e)
-            .send();
-    }
-
-    /**
-     * Creates a new crash report builder
-     *
-     * @return the newly created {@code ReportBuilder}
-     */
-    public ReportBuilder reportBuilder() {
-        return new ReportBuilder();
+    public void handleException(@Nullable Throwable e) {
+        handleException(e, false);
     }
 
     /**
-     * Helps manage
+     * This method is only here to support the deprecated {@link ExceptionHandlerInitializer} mechanism
+     * for adding additional data to a crash report.
      */
-    private static class TimeHelper {
-
-        private Long initialTimeMillis;
-
-        public void setInitialTimeMillis(long initialTimeMillis) {
-            this.initialTimeMillis = initialTimeMillis;
-        }
-
-        /**
-         * @return 0 if the initial time has yet to be set otherwise returns the difference between now and the initial time.
-         */
-        public long getElapsedTime() {
-            return (initialTimeMillis == null) ? 0 : System.currentTimeMillis() - initialTimeMillis;
-        }
-    }
-
-    /**
-     * Try to send a report, if an error occurs stores a report file for a later
-     * attempt.
-     *
-     * @param reportBuilder The report builder used to assemble the report
-     */
-    private void report(final ReportBuilder reportBuilder) {
-
-        if (!enabled) {
-            return;
-        }
-
+    private void performDeprecatedReportPriming() {
         try {
             exceptionHandlerInitializer.initializeExceptionHandler(this);
         } catch (Exception exceptionInRunnable) {
-            Log.d(ACRA.LOG_TAG, "Failed to initlize " + exceptionHandlerInitializer + " from #handleException");
-        }
-
-        boolean sendOnlySilentReports = false;
-        ReportingInteractionMode reportingInteractionMode;
-        if (!reportBuilder.mForceSilent) {
-            // No interaction mode defined, we assume it has been set during
-            // ACRA.initACRA()
-            reportingInteractionMode = ACRA.getConfig().mode();
-        } else {
-            reportingInteractionMode = ReportingInteractionMode.SILENT;
-
-            // An interaction mode has been provided. If ACRA has been
-            // initialized with a non SILENT mode and this mode is overridden
-            // with SILENT, then we have to send only reports which have been
-            // explicitly declared as silent via handleSilentException().
-            if (ACRA.getConfig().mode() != ReportingInteractionMode.SILENT) {
-                sendOnlySilentReports = true;
-            }
+            ACRA.log.w(LOG_TAG, "Failed to initialize " + exceptionHandlerInitializer + " from #handleException");
         }
-
-        final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
-            || (ACRA.getConfig().resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
-
-        final TimeHelper sentToastTimeMillis = new TimeHelper();
-        if (shouldDisplayToast) {
-            new Thread() {
-
-                /*
-                 * (non-Javadoc)
-                 *
-                 * @see java.lang.Thread#run()
-                 */
-                @Override
-                public void run() {
-                    Looper.prepare();
-                    ToastSender.sendToast(mContext, ACRA.getConfig().resToastText(), Toast.LENGTH_LONG);
-                    sentToastTimeMillis.setInitialTimeMillis(System.currentTimeMillis());
-                    Looper.loop();
-                }
-
-            }.start();
-
-            // We will wait a few seconds at the end of the method to be sure
-            // that the Toast can be read by the user.
-        }
-
-        final CrashReportData crashReportData = crashReportDataFactory.createCrashData(reportBuilder.mMessage,
-                                                                                       reportBuilder.mException, reportBuilder.mCustomData,
-                                                                                       reportBuilder.mForceSilent, reportBuilder.mUncaughtExceptionThread);
-
-        // Always write the report file
-
-        final String reportFileName = getReportFileName(crashReportData);
-        saveCrashReportFile(reportFileName, crashReportData);
-
-        if (reportBuilder.mEndsApplication && !ACRA.getConfig().sendReportsAtShutdown()) {
-            endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-        }
-
-        SendWorker sender = null;
-
-        if (reportingInteractionMode == ReportingInteractionMode.SILENT
-            || reportingInteractionMode == ReportingInteractionMode.TOAST
-            || prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
-
-            // Approve and then send reports now
-            Log.d(ACRA.LOG_TAG, "About to start ReportSenderWorker from #handleException");
-            sender = startSendingReports(sendOnlySilentReports, true);
-            if ((reportingInteractionMode == ReportingInteractionMode.SILENT) && !reportBuilder.mEndsApplication) {
-                // Report is being sent silently and the application is not ending.
-                // So no need to wait around for the sender to complete.
-                return;
-            }
-
-        } else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
-            Log.d(ACRA.LOG_TAG, "Creating Notification.");
-            createNotification(reportFileName, reportBuilder);
-        }
-
-        if (shouldDisplayToast) {
-            // A toast is being displayed, we have to wait for its end before
-            // doing anything else.
-            // The toastWaitEnded flag will be checked before any other
-            // operation.
-            toastWaitEnded = false;
-            new Thread() {
-
-                @Override
-                public void run() {
-                    Log.d(LOG_TAG, "Waiting for " + ACRAConstants.TOAST_WAIT_DURATION
-                        + " millis from " + sentToastTimeMillis.initialTimeMillis
-                        + " currentMillis=" + System.currentTimeMillis());
-                    while (sentToastTimeMillis.getElapsedTime() < ACRAConstants.TOAST_WAIT_DURATION) {
-                        try {
-                            // Wait a bit to let the user read the toast
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            Log.d(LOG_TAG, "Interrupted while waiting for Toast to end.", e1);
-                        }
-                    }
-                    toastWaitEnded = true;
-                }
-            }.start();
-        }
-
-        // Start an AsyncTask waiting for the end of the sender.
-        // Once sent, call endApplication() if reportBuilder.mEndApplication
-        final SendWorker worker = sender;
-        final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG)
-            && !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
-
-        new Thread() {
-
-            @Override
-            public void run() {
-                // We have to wait for BOTH the toast display wait AND
-                // the worker job to be completed.
-                if (toastWaitEnded || (worker == null)) {
-                    // Nothing to wait for.
-                    Log.d(LOG_TAG, "Toast (if any) and worker completed - not waiting");
-                } else {
-                    Log.d(LOG_TAG, "Waiting for " + (toastWaitEnded ? "Toast " : " -- ") + (worker.isAlive() ? "and Worker" : ""));
-                    while (!toastWaitEnded || worker.isAlive()) {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e1) {
-                            Log.e(LOG_TAG, "Error : ", e1);
-                        }
-                    }
-                    Log.d(LOG_TAG, "Finished waiting for Toast + Worker");
-                }
-
-                if (showDirectDialog) {
-                    // Create a new activity task with the confirmation dialog.
-                    // This new task will be persisted on application restart
-                    // right after its death.
-                    Log.d(LOG_TAG, "Creating CrashReportDialog for " + reportFileName);
-                    final Intent dialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    mContext.startActivity(dialogIntent);
-                }
-
-                Log.d(LOG_TAG, "Wait for Toast + worker ended. Kill Application ? " + reportBuilder.mEndsApplication);
-
-                if (reportBuilder.mEndsApplication) {
-                    endApplication(reportBuilder.mUncaughtExceptionThread, reportBuilder.mException);
-                }
-            }
-        }.start();
-    }
-
-    /**
-     * Creates an Intent that can be used to create and show a CrashReportDialog.
-     *
-     * @param reportFileName    Name of the error report to display in the crash report dialog.
-     * @param reportBuilder     ReportBuilder containing the details of the crash.
-     */
-    private Intent createCrashReportDialogIntent(String reportFileName, ReportBuilder reportBuilder) {
-        Log.d(LOG_TAG, "Creating DialogIntent for " + reportFileName + " exception=" + reportBuilder.mException);
-        final Intent dialogIntent = new Intent(mContext, ACRA.getConfig().reportDialogClass());
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE_NAME, reportFileName);
-        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION, reportBuilder.mException);
-        return dialogIntent;
-    }
-
-
-    /**
-     * Creates a status bar notification.
-     *
-     * The action triggered when the notification is selected is to start the
-     * {@link CrashReportDialog} Activity.
-     *
-     * @param reportFileName Name of the report file to send.
-     */
-    private void createNotification(String reportFileName, ReportBuilder reportBuilder) {
-
-        final NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        final ReportsCrashes conf = ACRA.getConfig();
-
-        // Default notification icon is the warning symbol
-        final int icon = conf.resNotifIcon();
-
-        final CharSequence tickerText = mContext.getText(conf.resNotifTickerText());
-        final long when = System.currentTimeMillis();
-        final Notification notification = new Notification(icon, tickerText, when);
-
-        final CharSequence contentTitle = mContext.getText(conf.resNotifTitle());
-        final CharSequence contentText = mContext.getText(conf.resNotifText());
-
-        Log.d(LOG_TAG, "Creating Notification for " + reportFileName);
-        final Intent crashReportDialogIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        final PendingIntent contentIntent = PendingIntent.getActivity(mContext, mNotificationCounter++, crashReportDialogIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-
-        notification.setLatestEventInfo(mContext, contentTitle, contentText, contentIntent);
-        notification.flags = notification.flags | Notification.FLAG_AUTO_CANCEL;
-
-        // The deleteIntent is invoked when the user swipes away the Notification.
-        // In this case we invoke the CrashReportDialog with EXTRA_FORCE_CANCEL==true
-        // which will cause BaseCrashReportDialog to clear the crash report and finish itself.
-        final Intent deleteIntent = createCrashReportDialogIntent(reportFileName, reportBuilder);
-        deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
-        notification.deleteIntent = PendingIntent.getActivity(mContext, -1, deleteIntent, 0);
-
-        // Send new notification
-        notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
     }
 
-    private String getReportFileName(CrashReportData crashData) {
-        final Time now = new Time();
-        now.setToNow();
-        final long timestamp = now.toMillis(false);
-        final String isSilent = crashData.getProperty(IS_SILENT);
-        return "" + timestamp + (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
-            + ACRAConstants.REPORTFILE_EXTENSION;
-    }
-
-    /**
-     * When a report can't be sent, it is saved here in a file in the root of
-     * the application private directory.
-     *
-     * @param fileName
-     *            In a few rare cases, we write the report again with additional
-     *            data (user comment for example). In such cases, you can
-     *            provide the already existing file name here to overwrite the
-     *            report file. If null, a new file report will be generated
-     * @param crashData
-     *            Can be used to save an alternative (or previously generated)
-     *            report data. Used to store again a report with the addition of
-     *            user comment. If null, the default current crash data are
-     *            used.
-     */
-    private void saveCrashReportFile(String fileName, CrashReportData crashData) {
+    @NonNull
+    private static ReportPrimer getReportPrimer(@NonNull ACRAConfiguration config) {
         try {
-            Log.d(LOG_TAG, "Writing crash report file " + fileName + ".");
-            final CrashReportPersister persister = new CrashReportPersister(mContext);
-            persister.store(crashData, fileName);
-        } catch (Exception e) {
-            Log.e(LOG_TAG, "An error occurred while writing the report file...", e);
-        }
-    }
-
-    /**
-     * Delete pending reports.
-     *
-     * @param deleteApprovedReports
-     *            Set to true to delete approved and silent reports.
-     * @param deleteNonApprovedReports
-     *            Set to true to delete non approved/silent reports.
-     * @param nbOfLatestToKeep
-     *            Number of pending reports to retain.
-     */
-    private void deletePendingReports(boolean deleteApprovedReports, boolean deleteNonApprovedReports,
-                                      int nbOfLatestToKeep) {
-        // TODO Check logic and instances where nbOfLatestToKeep = X, because
-        // that might stop us from deleting any reports.
-        final CrashReportFinder reportFinder = new CrashReportFinder(mContext);
-        final String[] filesList = reportFinder.getCrashReportFiles();
-        Arrays.sort(filesList);
-        for (int iFile = 0; iFile < filesList.length - nbOfLatestToKeep; iFile++) {
-            final String fileName = filesList[iFile];
-            final boolean isReportApproved = fileNameParser.isApproved(fileName);
-            if ((isReportApproved && deleteApprovedReports) || (!isReportApproved && deleteNonApprovedReports)) {
-                final File fileToDelete = new File(mContext.getFilesDir(), fileName);
-                ACRA.log.d(ACRA.LOG_TAG, "Deleting file " + fileName);
-                if (!fileToDelete.delete()) {
-                    Log.e(ACRA.LOG_TAG, "Could not delete report : " + fileToDelete);
-                }
-            }
+            return config.reportPrimerClass().newInstance();
+        } catch (InstantiationException e) {
+            ACRA.log.w(LOG_TAG, "Could not construct ReportPrimer from " + config.reportPrimerClass() + " - not priming", e);
+        } catch (IllegalAccessException e) {
+            ACRA.log.w(LOG_TAG, "Could not construct ReportPrimer from " + config.reportPrimerClass() + " - not priming", e);
         }
-    }
 
-    /**
-     * Checks if an array of reports files names contains only silent or
-     * approved reports.
-     *
-     * @param reportFileNames
-     *            Array of report locations to check.
-     * @return True if there are only silent or approved reports. False if there
-     *         is at least one non-approved report.
-     */
-    private boolean containsOnlySilentOrApprovedReports(String[] reportFileNames) {
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Sets relevant ReportSenders to the ErrorReporter, replacing any
-     * previously set ReportSender.
-     */
-    public void setDefaultReportSenders() {
-        ReportsCrashes conf = ACRA.getConfig();
-        Application mApplication = ACRA.getApplication();
-        removeAllReportSenders();
-
-        // Try to send by mail. If a mailTo address is provided, do not add
-        // other senders.
-        if (!"".equals(conf.mailTo())) {
-            Log.w(LOG_TAG, mApplication.getPackageName() + " reports will be sent by email (if accepted by user).");
-            setReportSender(new EmailIntentSender(mApplication));
-            return;
-        }
-
-        final PackageManagerWrapper pm = new PackageManagerWrapper(mApplication);
-        if (!pm.hasPermission(permission.INTERNET)) {
-            // NB If the PackageManager has died then this will erroneously log
-            // the error that the App doesn't have Internet (even though it
-            // does).
-            // I think that is a small price to pay to ensure that ACRA doesn't
-            // crash if the PackageManager has died.
-            Log.e(LOG_TAG,
-                  mApplication.getPackageName()
-                      + " should be granted permission "
-                      + permission.INTERNET
-                      + " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @ReportsCrashes(mailTo=\"your.account@domain.com\"");
-            return;
-        }
-
-        // If formUri is set, instantiate a sender for a generic HTTP POST form
-        // with default mapping.
-        if (conf.formUri() != null && !"".equals(conf.formUri())) {
-            setReportSender(new HttpSender(ACRA.getConfig().httpMethod(), ACRA.getConfig().reportType(), null));
-        }
-    }
-
-    /**
-     * Fluent API used to assemble the different options used for a crash report
-     */
-    public final class ReportBuilder {
-
-        private String mMessage;
-        private Thread mUncaughtExceptionThread;
-        private Throwable mException;
-        private Map<String, String> mCustomData;
-
-        private boolean mForceSilent = false;
-        private boolean mEndsApplication = false;
-
-        /**
-         * Set the error message to be reported.
-         *
-         * @param msg the error message
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder message(String msg) {
-            mMessage = msg;
-            return this;
-        }
-
-        /**
-         * Sets the Thread on which an uncaught Exception occurred.
-         *
-         * @param thread    Thread on which an uncaught Exception occurred.
-         * @return the updated {@code ReportBuilder}
-         */
-        private ReportBuilder uncaughtExceptionThread(Thread thread) {
-            mUncaughtExceptionThread = thread;
-            return this;
-        }
-
-        /**
-         * Set the stack trace to be reported
-         *
-         * @param e The exception that should be associated with this report
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder exception(Throwable e) {
-            mException = e;
-            return this;
-        }
-
-        private void initCustomData() {
-            if (mCustomData ==  null)
-                mCustomData = new HashMap<String, String>();
-        }
-
-        /**
-         * Sets additional values to be added to {@code CUSTOM_DATA}. Values
-         * specified here take precedence over globally specified custom data.
-         *
-         * @param customData a map of custom key-values to be attached to the report
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(Map<String, String> customData) {
-            initCustomData();
-            mCustomData.putAll(customData);
-            return this;
-        }
-
-        /**
-         * Sets an additional value to be added to {@code CUSTOM_DATA}. The value
-         * specified here takes precedence over globally specified custom data.
-         *
-         * @param key the key identifying the custom data
-         * @param value the value for the custom data entry
-         * @return the updated {@code ReportBuilder}
-         */
-        @SuppressWarnings("unused")
-        public ReportBuilder customData(String key, String value) {
-            initCustomData();
-            mCustomData.put(key, value);
-            return this;
-        }
-
-        /**
-         * Forces the report to be sent silently, ignoring the default interaction mode set in the config
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder forceSilent() {
-            mForceSilent = true;
-            return this;
-        }
-
-        /**
-         * Ends the application after sending the crash report
-         *
-         * @return the updated {@code ReportBuilder}
-         */
-        public ReportBuilder endsApplication() {
-            mEndsApplication = true;
-            return this;
-        }
-
-        /**
-         * Assembles and sends the crash report
-         */
-        public void send() {
-            if (mMessage == null && mException == null) {
-                mMessage = "Report requested by developer";
-            }
-            report(this);
-        }
+        return new NoOpReportPrimer();
     }
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/ExceptionHandlerInitializer.java b/src/main/java/org/acra/ExceptionHandlerInitializer.java
index fc532bb9..4e48616c 100644
--- a/src/main/java/org/acra/ExceptionHandlerInitializer.java
+++ b/src/main/java/org/acra/ExceptionHandlerInitializer.java
@@ -7,6 +7,7 @@
  * exception is handled.
  * 
  * @see ErrorReporter#setExceptionHandlerInitializer(ExceptionHandlerInitializer)
+ * @deprecated since 4.8.0 use {@link org.acra.builder.ReportPrimer} mechanism instead.
  */
 public interface ExceptionHandlerInitializer {
     /**
diff --git a/src/main/java/org/acra/ReportField.java b/src/main/java/org/acra/ReportField.java
index 3815b11b..34bf13de 100644
--- a/src/main/java/org/acra/ReportField.java
+++ b/src/main/java/org/acra/ReportField.java
@@ -15,10 +15,10 @@
  */
 package org.acra;
 
-import org.acra.annotation.ReportsCrashes;
-
 import android.content.res.Configuration;
 
+import org.acra.annotation.ReportsCrashes;
+
 /**
  * Specifies all the different fields available in a crash report.
  * 
@@ -27,7 +27,7 @@
  */
 public enum ReportField {
     /**
-     * Report Identifier
+     * Report Identifier.
      */
     REPORT_ID,
     /**
@@ -293,7 +293,7 @@ public boolean containsKeyValuePairs() {
      * Whether this field is a collection of key/value pairs.
      * 
      * @return true if the field contains a string with a key/value pair on each
-     *         line, key and value separated by an equal sugn
+     *         line, key and value separated by an equal sign
      * 
      */
     public boolean containsKeyValuePairs() {
diff --git a/src/main/java/org/acra/SendWorker.java b/src/main/java/org/acra/SendWorker.java
deleted file mode 100644
index 1f804ab7..00000000
--- a/src/main/java/org/acra/SendWorker.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-
-import org.acra.collector.CrashReportData;
-import org.acra.sender.ReportSender;
-import org.acra.sender.ReportSenderException;
-
-import android.content.Context;
-import android.util.Log;
-
-/**
- * Checks and send reports on a separate Thread.
- * 
- * @author Kevin Gaudin
- */
-final class SendWorker extends Thread {
-
-    private final Context context;
-    private final boolean sendOnlySilentReports;
-    private final boolean approvePendingReports;
-    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
-    private final List<ReportSender> reportSenders;
-
-    /**
-     * Creates a new {@link SendWorker} to try sending pending reports.
-     * 
-     * @param context
-     *            ApplicationContext in which the reports are being sent.
-     * @param reportSenders
-     *            List of ReportSender to use to send the crash reports.
-     * @param sendOnlySilentReports
-     *            If set to true, will send only reports which have been
-     *            explicitly declared as silent by the application developer.
-     * @param approvePendingReports
-     *            if this endWorker should approve pending reports before
-     *            sending any reports.
-     */
-    public SendWorker(Context context, List<ReportSender> reportSenders, boolean sendOnlySilentReports,
-            boolean approvePendingReports) {
-        this.context = context;
-        this.reportSenders = reportSenders;
-        this.sendOnlySilentReports = sendOnlySilentReports;
-        this.approvePendingReports = approvePendingReports;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.lang.Thread#run()
-     */
-    @Override
-    public void run() {
-        if (approvePendingReports) {
-            approvePendingReports();
-        }
-        checkAndSendReports(context, sendOnlySilentReports);
-    }
-
-    /**
-     * Flag all pending reports as "approved" by the user. These reports can be
-     * sent.
-     */
-    private void approvePendingReports() {
-        Log.d(LOG_TAG, "Mark all pending reports as approved.");
-
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFileNames = reportFinder.getCrashReportFiles();
-
-        for (String reportFileName : reportFileNames) {
-            if (!fileNameParser.isApproved(reportFileName)) {
-                final File reportFile = new File(context.getFilesDir(), reportFileName);
-
-                // TODO look into how this could cause a file to go from
-                // -approved.stacktrace to -approved-approved.stacktrace
-                final String newName = reportFileName.replace(ACRAConstants.REPORTFILE_EXTENSION,
-                        ACRAConstants.APPROVED_SUFFIX + ACRAConstants.REPORTFILE_EXTENSION);
-
-                // TODO Look into whether rename is atomic. Is there a better
-                // option?
-                final File newFile = new File(context.getFilesDir(), newName);
-                if (!reportFile.renameTo(newFile)) {
-                    Log.e(LOG_TAG, "Could not rename approved report from " + reportFile + " to " + newFile);
-                }
-            }
-        }
-    }
-
-    /**
-     * Send pending reports.
-     * 
-     * @param context
-     *            The application context.
-     * @param sendOnlySilentReports
-     *            Send only reports explicitly declared as SILENT by the
-     *            developer (sent via
-     *            {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    private void checkAndSendReports(Context context, boolean sendOnlySilentReports) {
-        Log.d(LOG_TAG, "#checkAndSendReports - start");
-        final CrashReportFinder reportFinder = new CrashReportFinder(context);
-        final String[] reportFiles = reportFinder.getCrashReportFiles();
-        Arrays.sort(reportFiles);
-
-        int reportsSentCount = 0;
-
-        for (String curFileName : reportFiles) {
-            if (sendOnlySilentReports && !fileNameParser.isSilent(curFileName)) {
-                continue;
-            }
-
-            if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
-                break; // send only a few reports to avoid overloading the
-                       // network
-            }
-
-            Log.i(LOG_TAG, "Sending file " + curFileName);
-            try {
-                final CrashReportPersister persister = new CrashReportPersister(context);
-                final CrashReportData previousCrashReport = persister.load(curFileName);
-                sendCrashReport(previousCrashReport);
-                deleteFile(context, curFileName);
-            } catch (RuntimeException e) {
-                Log.e(ACRA.LOG_TAG, "Failed to send crash reports for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something really unexpected happened. Don't try to
-                       // send any more reports now.
-            } catch (IOException e) {
-                Log.e(ACRA.LOG_TAG, "Failed to load crash report for " + curFileName, e);
-                deleteFile(context, curFileName);
-                break; // Something unexpected happened when reading the crash
-                       // report. Don't try to send any more reports now.
-            } catch (ReportSenderException e) {
-                Log.e(ACRA.LOG_TAG, "Failed to send crash report for " + curFileName, e);
-                // An issue occurred while sending this report but we can still try to
-                // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS
-                // so there's not much to fear about overloading a failing server.
-            }
-            reportsSentCount++;
-        }
-        Log.d(LOG_TAG, "#checkAndSendReports - finish");
-    }
-
-    /**
-     * Sends the report with all configured ReportSenders. If at least one
-     * sender completed its job, the report is considered as sent and will not
-     * be sent again for failing senders.
-     * 
-     * @param errorContent
-     *            Crash data.
-     * @throws ReportSenderException
-     *             if unable to send the crash report.
-     */
-    private void sendCrashReport(CrashReportData errorContent) throws ReportSenderException {
-        if (!ACRA.isDebuggable() || ACRA.getConfig().sendReportsInDevMode()) {
-            boolean sentAtLeastOnce = false;
-            for (ReportSender sender : reportSenders) {
-                try {
-                    sender.send(context, errorContent);
-                    // If at least one sender worked, don't re-send the report
-                    // later.
-                    sentAtLeastOnce = true;
-                } catch (ReportSenderException e) {
-                    if (!sentAtLeastOnce) {
-                        throw e; // Don't log here because we aren't dealing
-                                 // with the Exception here.
-                    } else {
-                        Log.w(LOG_TAG,
-                                "ReportSender of class "
-                                        + sender.getClass().getName()
-                                        + " failed but other senders completed their task. ACRA will not send this report again.");
-                    }
-                }
-            }
-        }
-    }
-
-    private void deleteFile(Context context, String fileName) {
-        final boolean deleted = context.deleteFile(fileName);
-        if (!deleted) {
-            Log.w(ACRA.LOG_TAG, "Could not delete error report : " + fileName);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/annotation/ReportsCrashes.java b/src/main/java/org/acra/annotation/ReportsCrashes.java
index d4683609..fada4123 100644
--- a/src/main/java/org/acra/annotation/ReportsCrashes.java
+++ b/src/main/java/org/acra/annotation/ReportsCrashes.java
@@ -15,25 +15,39 @@
  */
 package org.acra.annotation;
 
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.RawRes;
+import android.support.annotation.StringRes;
+import android.support.annotation.StyleRes;
 
 import org.acra.ACRA;
 import org.acra.ACRAConstants;
-import org.acra.BaseCrashReportDialog;
-import org.acra.CrashReportDialog;
 import org.acra.ReportField;
 import org.acra.ReportingInteractionMode;
+import org.acra.builder.NoOpReportPrimer;
+import org.acra.builder.ReportPrimer;
+import org.acra.config.DefaultRetryPolicy;
+import org.acra.config.RetryPolicy;
+import org.acra.dialog.BaseCrashReportDialog;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.file.Directory;
+import org.acra.security.KeyStoreFactory;
+import org.acra.security.NoKeyStoreFactory;
+import org.acra.sender.DefaultReportSenderFactory;
 import org.acra.sender.HttpSender.Method;
 import org.acra.sender.HttpSender.Type;
+import org.acra.sender.ReportSenderFactory;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 /**
  * Provide configuration elements to the
@@ -57,7 +71,7 @@
      * 
      * @return URI of a custom server to which to post reports.
      */
-    String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
+    @NonNull String formUri() default ACRAConstants.DEFAULT_STRING_VALUE;
 
     /**
      * <p>
@@ -84,74 +98,80 @@
      * 
      * @return the interaction mode that you want ACRA to implement.
      */
-    ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
+    @NonNull ReportingInteractionMode mode() default ReportingInteractionMode.SILENT;
 
     /**
      * @return Resource id for the label of positive button in the crash dialog.
      *         If not provided, defaults to 'OK'.
      */
-    int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
+    @StringRes int resDialogPositiveButtonText() default ACRAConstants.DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
 
     /**
      * @return Resource id for the label of negative button in the crash dialog.
      *         If not provided, defaults to 'cancel'.
      */
-    int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
+    @StringRes int resDialogNegativeButtonText() default ACRAConstants.DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
 
     /**
      * @return Resource id for the user comment input label in the crash dialog.
      *         If not provided, disables the input field.
      */
-    int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resDialogCommentPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the user email address input label in the crash
      *         dialog. If not provided, disables the input field.
      */
-    int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resDialogEmailPrompt() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the icon in the crash dialog. Default value is
      *         the system alert icon.
      */
-    int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
+    @DrawableRes int resDialogIcon() default ACRAConstants.DEFAULT_DIALOG_ICON;
 
     /**
      * @return Resource id for the Toast text triggered when the user accepts to
      *         send a report in the crash dialog.
      */
-    int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resDialogOkToast() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the text in the crash dialog.
      */
-    int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resDialogText() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the title in the crash dialog.
      */
-    int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resDialogTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+
+    /**
+     *
+     * @return resource id for the crash dialog theme
+     */
+    @StyleRes int resDialogTheme() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the icon in the status bar notification. Default
      *         is the system error notification icon.
      */
-    int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
+    @DrawableRes int resNotifIcon() default ACRAConstants.DEFAULT_NOTIFICATION_ICON;
 
     /**
      * @return Resource id for the text in the status bar notification.
      */
-    int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resNotifText() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the ticker text in the status bar notification.
      */
-    int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resNotifTickerText() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Resource id for the title in the status bar notification.
      */
-    int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resNotifTitle() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * Resource id for the Toast text triggered when the application crashes if
@@ -165,7 +185,7 @@
      * @return Resource id for the Toast text triggered when the application
      *         crashes.
      */
-    int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
+    @StringRes int resToastText() default ACRAConstants.DEFAULT_RES_VALUE;
 
     /**
      * @return Name of the SharedPreferences that will host ACRA settings you
@@ -184,7 +204,7 @@
      *         SharedPreferences, as retrieved with
      *         {@link PreferenceManager#getDefaultSharedPreferences(Context)}.
      */
-    String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
+    @NonNull String sharedPreferencesName() default ACRAConstants.DEFAULT_STRING_VALUE;
 
     /**
      * If using a custom {@link ReportsCrashes#sharedPreferencesName()}, pass
@@ -226,7 +246,7 @@
      * @return Array of tags that you want to be fetched when collecting DropBox
      *         entries.
      */
-    String[] additionalDropBoxTags() default {};
+    @NonNull String[] additionalDropBoxTags() default {};
 
     /**
      * @return Number of minutes to look back when collecting events from
@@ -261,7 +281,7 @@
      * @return Array of arguments to supply if retrieving the log as part of the
      *         report.
      */
-    String[] logcatArguments() default { "-t", "" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time" };
+    @NonNull String[] logcatArguments() default { "-t", "" + ACRAConstants.DEFAULT_LOGCAT_LINES, "-v", "time" };
 
     /**
      * When using the {@link #formUri()} parameter to send reports to a custom
@@ -271,7 +291,7 @@
      * 
      * @return Login to use when posting reports to a custom server.
      */
-    String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
+    @NonNull String formUriBasicAuthLogin() default ACRAConstants.NULL_VALUE;
 
     /**
      * When using the {@link #formUri()} parameter to send reports to a custom
@@ -281,7 +301,7 @@
      * 
      * @return Password to use when posting reports to a custom server.
      */
-    String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
+    @NonNull String formUriBasicAuthPassword() default ACRAConstants.NULL_VALUE;
 
     /**
      * <p>
@@ -365,7 +385,7 @@
      * @return ReportField Array listing the fields to be included in the
      *         report.
      */
-    ReportField[] customReportContent() default {};
+    @NonNull ReportField[] customReportContent() default {};
 
     /**
      * <p>
@@ -393,20 +413,24 @@
      * 
      * @return email address to which to send reports.
      */
-    String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
+    @NonNull String mailTo() default ACRAConstants.DEFAULT_STRING_VALUE;
 
     /**
-     * Controls whether unapproved reports are deleted on application start or
-     * not. Default is true. This is a change from versions of ACRA before 3.2
-     * as in {@link ReportingInteractionMode#NOTIFICATION} mode reports were
-     * previously kept until the user explicitly opens the Notification dialog
-     * AND choose to send or discard the report. Until then, on application
-     * restart, ACRA was issuing a new crash notification for previous reports
-     * pending for approval. This could be misunderstood by the user with a new
-     * crash, resulting in bad appreciation of the application.
-     * 
-     * @return true if ACRA should delete unapproved reports on application
-     *         start.
+     * Controls whether unapproved reports are deleted on application start or not.
+     * Default is true.
+     *
+     * Silent and Toast reports are automatically approved.
+     * Dialog and Notification reports required explicit approval by the user before they are sent.
+     *
+     * On application restart the user is prompted with approval for any unsent reports.
+     * So you generally don't want to accumulate unapproved reports, otherwise you will prompt them multiple times.
+     *
+     * If this is set to true then all unapproved reports bar one will be deleted on application start.
+     * The last report is always retained because that is the report that probably just happened.
+     *
+     * If set to false then on restart the user will be prompted with approval for each unapproved report.
+     *
+     * @return true if ACRA should delete unapproved reports on application start.
      */
     boolean deleteUnapprovedReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
 
@@ -421,8 +445,7 @@
     boolean deleteOldUnsentReportsOnApplicationStart() default ACRAConstants.DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
 
     /**
-     * @return Value in milliseconds for timeout attempting to connect to a
-     *         network (default 3000ms).
+     * @return Value in milliseconds for timeout attempting to connect to a network (default 5000ms).
      */
     int connectionTimeout() default ACRAConstants.DEFAULT_CONNECTION_TIMEOUT;
 
@@ -430,26 +453,17 @@
      * If the request is retried due to timeout, the socketTimeout will double
      * before retrying the request.
      * 
-     * @return Value in milliseconds for timeout receiving a response to a
-     *         network request (default 5000ms).
-     * @see #maxNumberOfRequestRetries()
+     * @return Value in milliseconds for timeout receiving a response to a network request (default 8000ms).
      */
     int socketTimeout() default ACRAConstants.DEFAULT_SOCKET_TIMEOUT;
 
     /**
-     * @return Maximum number of times a network request will be retried when
-     *         receiving the response times out (default 3).
-     * @see #socketTimeout()
-     */
-    int maxNumberOfRequestRetries() default ACRAConstants.DEFAULT_MAX_NUMBER_OF_REQUEST_RETRIES;
-
-    /**
-     * In {@link ReportingInteractionMode#TOAST} mode, set this to true if you
-     * prefer displaying the native Force Close dialog after the Toast.
+     * Set this to true if you prefer displaying the native force close dialog after the ACRA is done.
+     * Recommended: Keep this set to false if using {@link ReportingInteractionMode#DIALOG} for notification.
      * 
-     * @return true if the Force Close dialog has to be displayed.
+     * @return true if the native force close dialog should be displayed.
      */
-    boolean forceCloseDialogAfterToast() default ACRAConstants.DEFAULT_FORCE_CLOSE_DIALOG_AFTER_TOAST;
+    boolean alsoReportToAndroidFramework() default ACRAConstants.DEFAULT_REPORT_TO_ANDROID_FRAMEWORK;
 
     /**
      * Add here your {@link SharedPreferences} identifier Strings if you use
@@ -458,7 +472,7 @@
      * 
      * @return String Array containing the names of the additional preferences.
      */
-    String[] additionalSharedPreferences() default {};
+    @NonNull String[] additionalSharedPreferences() default {};
 
     /**
      * Set this to true if you want to include only logcat lines related to your
@@ -468,6 +482,14 @@
      */
     boolean logcatFilterByPid() default ACRAConstants.DEFAULT_LOGCAT_FILTER_BY_PID;
 
+    /**
+     * Set this to true if you want to read logcat lines in a non blocking way for your
+     * thread. It has a default timeout of 3 seconds.
+     *
+     * @return true if you want that reading of logcat lines to not block current thread.
+     */
+    boolean nonBlockingReadForLogcat() default  ACRAConstants.DEFAULT_NON_BLOCKING_READ_FOR_LOGCAT;
+
     /**
      * Set this to false if you want to disable sending reports in development
      * mode. Only signed application packages will send reports. Default value
@@ -478,13 +500,10 @@
     boolean sendReportsInDevMode() default ACRAConstants.DEFAULT_SEND_REPORTS_IN_DEV_MODE;
 
     /**
-     * Set this to false if you want to disable sending reports at the time the
-     * exception is caught. In this case, reports will not be sent until the
-     * application is restarted.
-     *
-     * @return false if reports should not be sent.
+     * @return true.
+     * @deprecated since 4.8.3 no replacement. Now that we are using the SenderService in a separate process we always send at shutdown.
      */
-    boolean sendReportsAtShutdown() default ACRAConstants.DEFAULT_SEND_REPORTS_AT_SHUTDOWN;
+    boolean sendReportsAtShutdown() default true;
 
     /**
      * Provide here regex patterns to be evaluated on each SharedPreference key
@@ -493,7 +512,7 @@
      * 
      * @return an array of regex patterns, every matching key is not collected.
      */
-    String[] excludeMatchingSharedPreferencesKeys() default {};
+    @NonNull String[] excludeMatchingSharedPreferencesKeys() default {};
 
     /**
      * Provide here regex patterns to be evaluated on each Settings.System,
@@ -503,14 +522,24 @@
      * 
      * @return an array of regex patterns, every matching key is not collected.
      */
-    String[] excludeMatchingSettingsKeys() default {};
+    @NonNull String[] excludeMatchingSettingsKeys() default {};
 
     /**
      * The default value will be a BuildConfig class residing in the same package as the Application class.
      *
      * @return BuildConfig class from which to read any BuildConfig attributes.
      */
-    Class buildConfigClass() default Object.class;
+    @NonNull Class buildConfigClass() default Object.class;
+
+    /**
+     * The default {@link org.acra.sender.ReportSenderFactory} creates an {@link org.acra.sender.EmailIntentSender}
+     * if the 'mailTo' parameter is defined or an {@link org.acra.sender.HttpSender} if the 'formUri' parameter
+     * is defined (and internet permission has been granted.
+     *
+     * @return List of the {@link org.acra.sender.ReportSenderFactory} with which to construct the
+     *         {@link org.acra.sender.ReportSender}s that will send the crash reports.
+     */
+    @NonNull Class<? extends ReportSenderFactory>[] reportSenderFactoryClasses() default {DefaultReportSenderFactory.class};
 
     /**
      * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
@@ -519,10 +548,10 @@
      * {@link Context#getFilesDir()}.
      * 
      * @return a String containing the path/name of your application log file.
-     *         If the string does not containt any path separator, the file is
+     *         If the string does not contain any path separator, the file is
      *         assumed as being in {@link Context#getFilesDir()}.
      */
-    String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
+    @NonNull String applicationLogFile() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE;
 
     /**
      * To use in combination with {@link ReportField#APPLICATION_LOG} to set the
@@ -534,23 +563,23 @@
     int applicationLogFileLines() default ACRAConstants.DEFAULT_APPLICATION_LOGFILE_LINES;
 
     /**
-     * <p>
-     * Set this to true if you need to post reports to your own server using an
-     * SSL connection with a self-signed certificate.
-     * </p>
-     * 
-     * @return True if SSL certificates validation has to be ignored when
-     *         posting reports.
+     * To use in combination with {@link ReportField#APPLICATION_LOG} to set the root
+     * for the path provided in {@link #applicationLogFile()}
+     *
+     * @return the directory of the application log file
      */
-    boolean disableSSLCertValidation() default ACRAConstants.DEFAULT_DISABLE_SSL_CERT_VALIDATION;
+    @NonNull Directory applicationLogFileDir() default Directory.FILES_LEGACY;
 
-    String httpsSocketFactoryFactoryClass() default ACRAConstants.DEFAULT_HTTP_SOCKET_FACTORY_FACTORY_CLASS;
+    /**
+     * @return Class for the CrashReportDialog used when prompting the user for crash details.
+     *          If not provided, defaults to CrashReportDialog.class
+     */
+    @NonNull Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
 
     /**
-     * @return Class for the CrashReportDialog used when sending intent.
-     *  If not provided, defaults to CrashReportDialog.class
+     * @return Class that is ued to provide any extra details for a crash.
      */
-    Class<? extends BaseCrashReportDialog> reportDialogClass() default CrashReportDialog.class;
+    @NonNull Class<? extends ReportPrimer> reportPrimerClass() default NoOpReportPrimer.class;
 
     /**
      * <p>
@@ -559,7 +588,39 @@
      *
      * @return HTTP method used when posting reports.
      */
-    Method httpMethod() default Method.POST;
+    @NonNull Method httpMethod() default Method.POST;
+
+    @NonNull Type reportType() default Type.FORM;
+
+    /**
+     * @return Class which creates a keystore that can contain trusted certificates
+     */
+    @NonNull Class<? extends KeyStoreFactory> keyStoreFactoryClass() default NoKeyStoreFactory.class;
+
+    /**
+     * @return path to a custom trusted certificate. Must start with "asset://" if the file is in the assets folder
+     */
+    @NonNull String certificatePath() default ACRAConstants.DEFAULT_STRING_VALUE;
+
+    /**
+     * @return resource id of a custom trusted certificate.
+     */
+    @RawRes int resCertificate() default ACRAConstants.DEFAULT_RES_VALUE;
 
-    Type reportType() default Type.FORM;
+    /**
+     * @return specify the type of the certificate set in either {@link #certificatePath()} or {@link #resCertificate()}
+     */
+    @NonNull String certificateType() default ACRAConstants.DEFAULT_CERTIFICATE_TYPE;
+
+    /**
+     * @return a Class that decides if a report should be resent (usually if one or more senders failed).
+     * @since 4.9.1
+     */
+    @NonNull Class<? extends RetryPolicy> retryPolicyClass() default DefaultRetryPolicy.class;
+
+    /**
+     * @return true if all services running in a process should be stopped before it is killed.
+     * @since 4.9.2
+     */
+    boolean stopServicesOnCrash() default false;
 }
diff --git a/src/main/java/org/acra/builder/LastActivityManager.java b/src/main/java/org/acra/builder/LastActivityManager.java
new file mode 100644
index 00000000..83f1c8f9
--- /dev/null
+++ b/src/main/java/org/acra/builder/LastActivityManager.java
@@ -0,0 +1,95 @@
+package org.acra.builder;
+
+import android.app.Activity;
+import android.app.Application;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.dialog.BaseCrashReportDialog;
+
+import java.lang.ref.WeakReference;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Responsible for tracking the last Activity other than any CrashReport dialog that was created.
+ *
+ * @since 4.8.0
+ */
+public final class LastActivityManager {
+
+    @NonNull
+    private WeakReference<Activity> lastActivityCreated = new WeakReference<Activity>(null);
+
+    public LastActivityManager(@NonNull Application application) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+
+            // ActivityLifecycleCallback only available for API14+
+            application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
+                @Override
+                public void onActivityCreated(@NonNull Activity activity, Bundle savedInstanceState) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityCreated " + activity.getClass());
+                    if (!(activity instanceof BaseCrashReportDialog)) {
+                        // Ignore CrashReportDialog because we want the last
+                        // application Activity that was started so that we can explicitly kill it off.
+                        lastActivityCreated = new WeakReference<Activity>(activity);
+                    }
+                }
+
+                @Override
+                public void onActivityStarted(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityStarted " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityResumed(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityResumed " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityPaused(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityPaused " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityStopped(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityStopped " + activity.getClass());
+                    synchronized (this){
+                        notify();
+                    }
+                }
+
+                @Override
+                public void onActivitySaveInstanceState(@NonNull Activity activity, Bundle outState) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivitySaveInstanceState " + activity.getClass());
+                }
+
+                @Override
+                public void onActivityDestroyed(@NonNull Activity activity) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "onActivityDestroyed " + activity.getClass());
+                }
+            });
+        }
+    }
+
+    @Nullable
+    public Activity getLastActivity() {
+        return lastActivityCreated.get();
+    }
+
+    public void clearLastActivity() {
+        lastActivityCreated.clear();
+    }
+
+    public void waitForActivityStop(int timeOutInMillis){
+        synchronized (this) {
+            try {
+                wait(timeOutInMillis);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/acra/builder/NoOpReportPrimer.java b/src/main/java/org/acra/builder/NoOpReportPrimer.java
new file mode 100644
index 00000000..586ac940
--- /dev/null
+++ b/src/main/java/org/acra/builder/NoOpReportPrimer.java
@@ -0,0 +1,16 @@
+package org.acra.builder;
+
+import android.content.Context;
+
+/**
+ * Does not perform any priming for the current report.
+ *
+ * @since 4.8.0
+ */
+public final class NoOpReportPrimer implements ReportPrimer {
+
+    @Override
+    public void primeReport(Context context, ReportBuilder builder) {
+        // Nothing to do.
+    }
+}
diff --git a/src/main/java/org/acra/builder/ReportBuilder.java b/src/main/java/org/acra/builder/ReportBuilder.java
new file mode 100644
index 00000000..fa892481
--- /dev/null
+++ b/src/main/java/org/acra/builder/ReportBuilder.java
@@ -0,0 +1,152 @@
+package org.acra.builder;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Fluent API used to assemble the different options used for a crash report.
+ *
+ * @since 4.8.0
+ */
+public final class ReportBuilder {
+
+    private String message;
+    private Thread uncaughtExceptionThread;
+    private Throwable exception;
+    private final Map<String, String> customData = new HashMap<String, String>();
+
+    private boolean sendSilently = false;
+    private boolean endApplication = false;
+
+    /**
+     * Set the error message to be reported.
+     *
+     * @param msg the error message
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings( "unused" )
+    public ReportBuilder message(@Nullable String msg) {
+        message = msg;
+        return this;
+    }
+
+    @Nullable
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the Thread on which an uncaught Exception occurred.
+     *
+     * @param thread    Thread on which an uncaught Exception occurred.
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder uncaughtExceptionThread(@Nullable Thread thread) {
+        uncaughtExceptionThread = thread;
+        return this;
+    }
+
+    @Nullable
+    public Thread getUncaughtExceptionThread() {
+        return uncaughtExceptionThread;
+    }
+
+    /**
+     * Set the stack trace to be reported
+     *
+     * @param e The exception that should be associated with this report
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder exception(@Nullable Throwable e) {
+        exception = e;
+        return this;
+    }
+
+    @Nullable
+    public Throwable getException() {
+        return exception;
+    }
+
+    /**
+     * Sets additional values to be added to {@code CUSTOM_DATA}. Values
+     * specified here take precedence over globally specified custom data.
+     *
+     * @param customData a map of custom key-values to be attached to the report
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings("unused")
+    public ReportBuilder customData(@NonNull Map<String, String> customData) {
+        this.customData.putAll(customData);
+        return this;
+    }
+
+    /**
+     * Sets an additional value to be added to {@code CUSTOM_DATA}. The value
+     * specified here takes precedence over globally specified custom data.
+     *
+     * @param key the key identifying the custom data
+     * @param value the value for the custom data entry
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    @SuppressWarnings("unused")
+    public ReportBuilder customData(@NonNull String key, String value) {
+        customData.put(key, value);
+        return this;
+    }
+
+    @NonNull
+    public Map<String, String> getCustomData() {
+        return customData;
+    }
+
+    /**
+     * Forces the report to be sent silently, ignoring the default interaction mode set in the config
+     *
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder sendSilently() {
+        sendSilently = true;
+        return this;
+    }
+
+    public boolean isSendSilently() {
+        return sendSilently;
+    }
+
+    /**
+     * Ends the application after sending the crash report
+     *
+     * @return the updated {@code ReportBuilder}
+     */
+    @NonNull
+    public ReportBuilder endApplication() {
+        endApplication = true;
+        return this;
+    }
+
+    public boolean isEndApplication() {
+        return endApplication;
+    }
+
+    /**
+     * Assembles and sends the crash report.
+     *
+     * @param reportExecutor    ReportExecutor to use to build the report.
+     */
+    public void build(@NonNull ReportExecutor reportExecutor) {
+        if (message == null && exception == null) {
+            message = "Report requested by developer";
+        }
+
+        reportExecutor.execute(this);
+    }
+}
diff --git a/src/main/java/org/acra/builder/ReportExecutor.java b/src/main/java/org/acra/builder/ReportExecutor.java
new file mode 100644
index 00000000..ad938e4c
--- /dev/null
+++ b/src/main/java/org/acra/builder/ReportExecutor.java
@@ -0,0 +1,390 @@
+package org.acra.builder;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Debug;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.NotificationCompat;
+import android.widget.Toast;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportingInteractionMode;
+import org.acra.collector.CrashReportData;
+import org.acra.collector.CrashReportDataFactory;
+import org.acra.config.ACRAConfiguration;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.file.CrashReportPersister;
+import org.acra.file.ReportLocator;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.sender.SenderServiceStarter;
+import org.acra.util.ProcessFinisher;
+import org.acra.util.ToastSender;
+
+import java.io.File;
+import java.util.Date;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.IS_SILENT;
+import static org.acra.ReportField.USER_CRASH_DATE;
+
+/**
+ * Collates, records and initiates the sending of a report.
+ *
+ * @since 4.8.0
+ */
+public final class ReportExecutor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final CrashReportDataFactory crashReportDataFactory;
+
+    // A reference to the system's previous default UncaughtExceptionHandler
+    // kept in order to execute the default exception handling after sending the report.
+    private final Thread.UncaughtExceptionHandler defaultExceptionHandler;
+
+    private final ReportPrimer reportPrimer;
+    private final ProcessFinisher processFinisher;
+
+    private boolean enabled = false;
+
+    /**
+     * Used to create a new (non-cached) PendingIntent each time a new crash occurs.
+     */
+    private static int mNotificationCounter = 0;
+
+    public ReportExecutor(@NonNull Context context, @NonNull ACRAConfiguration config,
+                          @NonNull CrashReportDataFactory crashReportDataFactory, @Nullable Thread.UncaughtExceptionHandler defaultExceptionHandler,
+                          @NonNull ReportPrimer reportPrimer, @NonNull ProcessFinisher processFinisher) {
+        this.context = context;
+        this.config = config;
+        this.crashReportDataFactory = crashReportDataFactory;
+        this.defaultExceptionHandler = defaultExceptionHandler;
+        this.reportPrimer = reportPrimer;
+        this.processFinisher = processFinisher;
+    }
+
+    /**
+     * Helps manage
+     */
+    private static class TimeHelper {
+
+        private Long initialTimeMillis;
+
+        public void setInitialTimeMillis(long initialTimeMillis) {
+            this.initialTimeMillis = initialTimeMillis;
+        }
+
+        /**
+         * @return 0 if the initial time has yet to be set otherwise returns the difference between now and the initial time.
+         */
+        public long getElapsedTime() {
+            return (initialTimeMillis == null) ? 0 : System.currentTimeMillis() - initialTimeMillis;
+        }
+    }
+
+    public void handReportToDefaultExceptionHandler(@Nullable Thread t, @NonNull Throwable e) {
+        if (defaultExceptionHandler != null) {
+            ACRA.log.i(LOG_TAG, "ACRA is disabled for " + context.getPackageName()
+                    + " - forwarding uncaught Exception on to default ExceptionHandler");
+            defaultExceptionHandler.uncaughtException(t, e);
+        } else {
+            ACRA.log.e(LOG_TAG, "ACRA is disabled for " + context.getPackageName() + " - no default ExceptionHandler");
+            ACRA.log.e(LOG_TAG, "ACRA caught a " + e.getClass().getSimpleName() + " for " + context.getPackageName(), e);
+        }
+
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    /**
+     * Try to send a report, if an error occurs stores a report file for a later attempt.
+     *
+     * @param reportBuilder The report builder used to assemble the report
+     */
+    public void execute(@NonNull final ReportBuilder reportBuilder) {
+
+        if (!enabled) {
+            ACRA.log.v(LOG_TAG, "ACRA is disabled. Report not sent.");
+            return;
+        }
+
+        // Prime this crash report with any extra data.
+        reportPrimer.primeReport(context, reportBuilder);
+
+        boolean sendOnlySilentReports = false;
+        final ReportingInteractionMode reportingInteractionMode;
+        if (!reportBuilder.isSendSilently()) {
+            // No interaction mode defined in the ReportBuilder, we assume it has been set during ACRA.initACRA()
+            reportingInteractionMode = config.mode();
+        } else {
+            reportingInteractionMode = ReportingInteractionMode.SILENT;
+
+            // An interaction mode has been provided. If ACRA has been
+            // initialized with a non SILENT mode and this mode is overridden
+            // with SILENT, then we have to send only reports which have been
+            // explicitly declared as silent via handleSilentException().
+            if (config.mode() != ReportingInteractionMode.SILENT) {
+                sendOnlySilentReports = true;
+            }
+        }
+
+        final boolean shouldDisplayToast = reportingInteractionMode == ReportingInteractionMode.TOAST
+                || (config.resToastText() != 0 && (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION || reportingInteractionMode == ReportingInteractionMode.DIALOG));
+
+        final TimeHelper sentToastTimeMillis = new TimeHelper();
+        if (shouldDisplayToast) {
+            new Thread() {
+
+                /*
+                 * (non-Javadoc)
+                 *
+                 * @see java.lang.Thread#run()
+                 */
+                @Override
+                public void run() {
+                    Looper.prepare();
+                    ToastSender.sendToast(context, config.resToastText(), Toast.LENGTH_LONG);
+                    sentToastTimeMillis.setInitialTimeMillis(System.currentTimeMillis());
+                    Looper.loop();
+                }
+
+            }.start();
+
+            // We will wait a few seconds at the end of the method to be sure
+            // that the Toast can be read by the user.
+        }
+
+        final CrashReportData crashReportData = crashReportDataFactory.createCrashData(reportBuilder);
+
+        // Always write the report file
+
+        final File reportFile = getReportFileName(crashReportData);
+        saveCrashReportFile(reportFile, crashReportData);
+
+        final SharedPreferences prefs = new SharedPreferencesFactory(context, config).create();
+        if (reportingInteractionMode == ReportingInteractionMode.SILENT
+                || reportingInteractionMode == ReportingInteractionMode.TOAST
+                || prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false)) {
+
+            // Approve and then send reports now
+            startSendingReports(sendOnlySilentReports);
+            if ((reportingInteractionMode == ReportingInteractionMode.SILENT) && !reportBuilder.isEndApplication()) {
+                // Report is being sent silently and the application is not ending.
+                // So no need to wait around for the sender to complete.
+                return;
+            }
+
+        } else if (reportingInteractionMode == ReportingInteractionMode.NOTIFICATION) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating Notification.");
+            createNotification(reportFile, reportBuilder);
+        }
+
+        final boolean showDirectDialog = (reportingInteractionMode == ReportingInteractionMode.DIALOG)
+                && !prefs.getBoolean(ACRA.PREF_ALWAYS_ACCEPT, false);
+
+        if (shouldDisplayToast) {
+            // A toast is being displayed, we have to wait for its end before doing anything else.
+            new Thread() {
+
+                @Override
+                public void run() {
+                    if (ACRA.DEV_LOGGING)
+                        ACRA.log.d(LOG_TAG, "Waiting for " + ACRAConstants.TOAST_WAIT_DURATION
+                                + " millis from " + sentToastTimeMillis.initialTimeMillis
+                                + " currentMillis=" + System.currentTimeMillis());
+                    final long sleep = ACRAConstants.TOAST_WAIT_DURATION - sentToastTimeMillis.getElapsedTime();
+                    try {
+                        // Wait a bit to let the user read the toast
+                        if (sleep > 0L) Thread.sleep(sleep);
+                    } catch (InterruptedException e1) {
+                        if (ACRA.DEV_LOGGING)
+                            ACRA.log.d(LOG_TAG, "Interrupted while waiting for Toast to end.", e1);
+                    }
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Finished waiting for Toast");
+                    dialogAndEnd(reportBuilder, reportFile, showDirectDialog);
+                }
+            }.start();
+        } else {
+            dialogAndEnd(reportBuilder, reportFile, showDirectDialog);
+        }
+    }
+
+    private void dialogAndEnd(@NonNull ReportBuilder reportBuilder, @NonNull File reportFile, boolean shouldShowDialog) {
+        if (shouldShowDialog) {
+            // Create a new activity task with the confirmation dialog.
+            // This new task will be persisted on application restart
+            // right after its death.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating CrashReportDialog for " + reportFile);
+            final Intent dialogIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+            dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            context.startActivity(dialogIntent);
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Wait for Toast + worker ended. Kill Application ? " + reportBuilder.isEndApplication());
+
+        if (reportBuilder.isEndApplication()) {
+            if(Debug.isDebuggerConnected()){
+                //Killing a process with a debugger attached would kill the whole application, so don't do that.
+                final String warning = "Warning: Acra may behave differently with a debugger attached";
+                new Thread() {
+                    @Override
+                    public void run() {
+                        Looper.prepare();
+                        Toast.makeText(context, warning, Toast.LENGTH_LONG).show();
+                        Looper.loop();
+                    }
+                }.start();
+                ACRA.log.w(LOG_TAG, warning);
+                //do as much cleanup as we can without killing the process
+                processFinisher.finishLastActivity(reportBuilder.getUncaughtExceptionThread());
+            }else {
+                endApplication(reportBuilder.getUncaughtExceptionThread(), reportBuilder.getException());
+            }
+        }
+    }
+
+    /**
+     * End the application.
+     */
+    private void endApplication(@Nullable Thread uncaughtExceptionThread, Throwable th) {
+        final boolean letDefaultHandlerEndApplication = config.alsoReportToAndroidFramework();
+
+        final boolean handlingUncaughtException = uncaughtExceptionThread != null;
+        if (handlingUncaughtException && letDefaultHandlerEndApplication && defaultExceptionHandler != null) {
+            // Let the system default handler do it's job and display the force close dialog.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Handing Exception on to default ExceptionHandler");
+            defaultExceptionHandler.uncaughtException(uncaughtExceptionThread, th);
+        } else {
+            processFinisher.endApplication(uncaughtExceptionThread);
+        }
+    }
+
+    /**
+     * Starts a Thread to start sending outstanding error reports.
+     *
+     * @param onlySendSilentReports If true then only send silent reports.
+     */
+    private void startSendingReports(boolean onlySendSilentReports) {
+        if (enabled) {
+            final SenderServiceStarter starter = new SenderServiceStarter(context, config);
+            starter.startService(onlySendSilentReports, true);
+        } else {
+            ACRA.log.w(LOG_TAG, "Would be sending reports, but ACRA is disabled");
+        }
+    }
+
+    /**
+     * Creates a status bar notification.
+     *
+     * The action triggered when the notification is selected is to start the
+     * {@link CrashReportDialog} Activity.
+     *
+     * @param reportFile    Report file to send.
+     */
+    private void createNotification(@NonNull File reportFile, @NonNull ReportBuilder reportBuilder) {
+
+        final NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        // Default notification icon is the warning symbol
+        final int icon = config.resNotifIcon();
+
+        final CharSequence tickerText = context.getText(config.resNotifTickerText());
+        final long when = System.currentTimeMillis();
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating Notification for " + reportFile);
+        final Intent crashReportDialogIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+        final PendingIntent contentIntent = PendingIntent.getActivity(context, mNotificationCounter++, crashReportDialogIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        final CharSequence contentTitle = context.getText(config.resNotifTitle());
+        final CharSequence contentText = context.getText(config.resNotifText());
+
+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(context);
+        final Notification notification = builder
+                .setSmallIcon(icon)
+                .setTicker(tickerText)
+                .setWhen(when)
+                .setAutoCancel(true)
+                .setContentTitle(contentTitle)
+                .setContentText(contentText)
+                .setContentIntent(contentIntent)
+                .build();
+
+        notification.flags |= Notification.FLAG_AUTO_CANCEL;
+
+        // The deleteIntent is invoked when the user swipes away the Notification.
+        // In this case we invoke the CrashReportDialog with EXTRA_FORCE_CANCEL==true
+        // which will cause BaseCrashReportDialog to clear the crash report and finish itself.
+        final Intent deleteIntent = createCrashReportDialogIntent(reportFile, reportBuilder);
+        deleteIntent.putExtra(ACRAConstants.EXTRA_FORCE_CANCEL, true);
+        notification.deleteIntent = PendingIntent.getActivity(context, -1, deleteIntent, 0);
+
+        // Send new notification
+        notificationManager.notify(ACRAConstants.NOTIF_CRASH_ID, notification);
+    }
+
+    @NonNull
+    private File getReportFileName(@NonNull CrashReportData crashData) {
+        final String timestamp = crashData.getProperty(USER_CRASH_DATE);
+        final String isSilent = crashData.getProperty(IS_SILENT);
+        final String fileName = (timestamp != null ? timestamp : new Date().getTime()) // Need to check for null because old version of ACRA did not always capture USER_CRASH_DATE
+                + (isSilent != null ? ACRAConstants.SILENT_SUFFIX : "")
+                + ACRAConstants.REPORTFILE_EXTENSION;
+        final ReportLocator reportLocator = new ReportLocator(context);
+        return new File(reportLocator.getUnapprovedFolder(), fileName);
+    }
+
+    /**
+     * When a report can't be sent, it is saved here in a file in the root of
+     * the application private directory.
+     *
+     * @param file
+     *            In a few rare cases, we write the report again with additional
+     *            data (user comment for example). In such cases, you can
+     *            provide the already existing file name here to overwrite the
+     *            report file. If null, a new file report will be generated
+     * @param crashData
+     *            Can be used to save an alternative (or previously generated)
+     *            report data. Used to store again a report with the addition of
+     *            user comment. If null, the default current crash data are
+     *            used.
+     */
+    private void saveCrashReportFile(@NonNull File file, @NonNull CrashReportData crashData) {
+        try {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Writing crash report file " + file);
+            final CrashReportPersister persister = new CrashReportPersister();
+            persister.store(crashData, file);
+        } catch (Exception e) {
+            ACRA.log.e(LOG_TAG, "An error occurred while writing the report file...", e);
+        }
+    }
+
+
+    /**
+     * Creates an Intent that can be used to create and show a CrashReportDialog.
+     *
+     * @param reportFile        Error report file to display in the crash report dialog.
+     * @param reportBuilder     ReportBuilder containing the details of the crash.
+     */
+    @NonNull
+    private Intent createCrashReportDialogIntent(@NonNull File reportFile, @NonNull ReportBuilder reportBuilder) {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Creating DialogIntent for " + reportFile + " exception=" + reportBuilder.getException());
+        final Intent dialogIntent = new Intent(context, config.reportDialogClass());
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_FILE, reportFile);
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION, reportBuilder.getException());
+        dialogIntent.putExtra(ACRAConstants.EXTRA_REPORT_CONFIG, config);
+        return dialogIntent;
+    }
+}
diff --git a/src/main/java/org/acra/builder/ReportPrimer.java b/src/main/java/org/acra/builder/ReportPrimer.java
new file mode 100644
index 00000000..ee03d9b5
--- /dev/null
+++ b/src/main/java/org/acra/builder/ReportPrimer.java
@@ -0,0 +1,30 @@
+package org.acra.builder;
+
+import android.content.Context;
+
+import java.util.Map;
+
+/**
+ * Primes a {@link ReportBuilder} with any extra data to record for the current crash report.
+ *
+ * ReportPrimer is configured declaratively via {@link org.acra.annotation.ReportsCrashes#reportPrimerClass()}.
+ * The ReportPrimer class MUST have a no arg constructor and is created when ACRA is initialised.
+ *
+ * Created by William on 9 Jan 2016.
+ * @since 4.8.0
+ */
+public interface ReportPrimer {
+
+    /**
+     * Update builder via {@link ReportBuilder#customData(Map)} or {@link ReportBuilder#customData(String, String)}
+     * with any extra dta application to just this crash.
+     *
+     * Builder is fully constructed when this method is called, so it can be introspected for details of the crash.
+     *
+     * Note that this method will only be called if ACRA is currently enabled.
+     *
+     * @param context   Application context from which to retrieve resources.
+     * @param builder   Full configured {@link ReportBuilder} for the current crash report.
+     */
+    void primeReport(Context context, ReportBuilder builder);
+}
diff --git a/src/main/java/org/acra/util/BoundedLinkedList.java b/src/main/java/org/acra/collections/BoundedLinkedList.java
similarity index 77%
rename from src/main/java/org/acra/util/BoundedLinkedList.java
rename to src/main/java/org/acra/collections/BoundedLinkedList.java
index fc50ec44..187ce428 100644
--- a/src/main/java/org/acra/util/BoundedLinkedList.java
+++ b/src/main/java/org/acra/collections/BoundedLinkedList.java
@@ -1,130 +1,163 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.util;
-
-import java.util.Collection;
-import java.util.LinkedList;
-
-/**
- * A {@link LinkedList} version with a maximum number of elements. When adding
- * elements to the end of the list, first elements in the list are discarded if
- * the maximum size is reached.
- * 
- * @author Kevin Gaudin
- * 
- * @param <E>
- */
-@SuppressWarnings("serial")
-public class BoundedLinkedList<E> extends LinkedList<E> {
-
-    private final int maxSize;
-
-    public BoundedLinkedList(int maxSize) {
-        this.maxSize = maxSize;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(java.lang.Object)
-     */
-    @Override
-    public boolean add(E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        return super.add(object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#add(int, java.lang.Object)
-     */
-    @Override
-    public void add(int location, E object) {
-        if (size() == maxSize) {
-            removeFirst();
-        }
-        super.add(location, object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(java.util.Collection)
-     */
-    @Override
-    public boolean addAll(Collection<? extends E> collection) {
-        final int totalNeededSize = size() + collection.size();
-        final int overhead = totalNeededSize - maxSize;
-        if (overhead > 0) {
-            removeRange(0, overhead);
-        }
-        return super.addAll(collection);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addAll(int, java.util.Collection)
-     */
-    @Override
-    public boolean addAll(int location, Collection<? extends E> collection) {
-        // int totalNeededSize = size() + collection.size();
-        // int overhead = totalNeededSize - maxSize;
-        // if(overhead > 0) {
-        // removeRange(0, overhead);
-        // }
-        // return super.addAll(location, collection);
-        throw new UnsupportedOperationException();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addFirst(java.lang.Object)
-     */
-    @Override
-    public void addFirst(E object) {
-        // super.addFirst(object);
-        throw new UnsupportedOperationException();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.LinkedList#addLast(java.lang.Object)
-     */
-    @Override
-    public void addLast(E object) {
-        add(object);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.AbstractCollection#toString()
-     */
-    @Override
-    public String toString() {
-        final StringBuilder result = new StringBuilder();
-        for (E object : this) {
-            result.append(object.toString());
-        }
-        return result.toString();
-    }
-}
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.util.Collection;
+import java.util.LinkedList;
+
+/**
+ * A {@link LinkedList} version with a maximum number of elements. When adding
+ * elements to the end of the list, first elements in the list are discarded if
+ * the maximum size is reached.
+ *
+ * @author Kevin Gaudin
+ */
+@SuppressWarnings("serial")
+public final class BoundedLinkedList<E> extends LinkedList<E> {
+
+    private final int maxSize;
+
+    public BoundedLinkedList(int maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#add(java.lang.Object)
+     */
+    @Override
+    public boolean add(E object) {
+        if (size() == maxSize) {
+            removeFirst();
+        }
+        return super.add(object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#add(int, java.lang.Object)
+     */
+    @Override
+    public void add(int location, E object) {
+        if (size() == maxSize) {
+            removeFirst();
+        }
+        super.add(location, object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addAll(java.util.Collection)
+     */
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        final int size = collection.size();
+        if (size > maxSize) {
+            final LinkedList<? extends E> list = new LinkedList<E>(collection);
+            for (int i = 0; i < size - maxSize; i++) {
+                list.removeFirst();
+            }
+            collection = list;
+        }
+        final int totalNeededSize = size() + collection.size();
+        final int overhead = totalNeededSize - maxSize;
+        if (overhead > 0) {
+            removeRange(0, overhead);
+        }
+        return super.addAll(collection);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addAll(int, java.util.Collection)
+     */
+    @Override
+    public boolean addAll(int location, Collection<? extends E> collection) {
+        // int totalNeededSize = size() + collection.size();
+        // int overhead = totalNeededSize - maxSize;
+        // if(overhead > 0) {
+        // removeRange(0, overhead);
+        // }
+        // return super.addAll(location, collection);
+        if(location == size()){
+            return super.addAll(location, collection);
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addFirst(java.lang.Object)
+     */
+    @Override
+    public void addFirst(E object) {
+        // super.addFirst(object);
+        throw new UnsupportedOperationException();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.LinkedList#addLast(java.lang.Object)
+     */
+    @Override
+    public void addLast(E object) {
+        add(object);
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.AbstractCollection#toString()
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        final StringBuilder result = new StringBuilder();
+        for (E object : this) {
+            result.append(object.toString());
+        }
+        return result.toString();
+    }
+
+    @Override
+    public boolean offer(E o) {
+        return add(o);
+    }
+
+    @Override
+    public boolean offerFirst(E e) {
+        addFirst(e);
+        return true;
+    }
+
+    @Override
+    public boolean offerLast(E e) {
+        return add(e);
+    }
+
+    @Override
+    public void push(E e) {
+        add(e);
+    }
+}
diff --git a/src/main/java/org/acra/collections/ImmutableList.java b/src/main/java/org/acra/collections/ImmutableList.java
new file mode 100644
index 00000000..61324f93
--- /dev/null
+++ b/src/main/java/org/acra/collections/ImmutableList.java
@@ -0,0 +1,167 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ * Naive (not optimized) implementation of an Immutable List
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableList<E> implements List<E>, Serializable {
+
+    private final List<E> mList;
+
+    public ImmutableList(E... elements) {
+        this(Arrays.asList(elements));
+    }
+
+    public ImmutableList(Collection<E> collection) {
+        this.mList = new ArrayList<E>(collection);
+    }
+
+    @Override
+    public void add(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(int location, @NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return mList.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(@NonNull Collection<?> collection) {
+        return mList.containsAll(collection);
+    }
+
+    @Override
+    public E get(int location) {
+        return mList.get(location);
+    }
+
+    @Override
+    public int indexOf(Object object) {
+        return mList.indexOf(object);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mList.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Iterator<E> iterator() {
+        return new UnmodifiableIteratorWrapper<E>(mList.iterator());
+    }
+
+    @Override
+    public int lastIndexOf(Object object) {
+        return mList.lastIndexOf(object);
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        return new UnmodifiableListIteratorWrapper<E>(mList.listIterator());
+    }
+
+    @NonNull
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        return new UnmodifiableListIteratorWrapper<E>(mList.listIterator(location));
+    }
+
+    @Override
+    public E remove(int location) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public E set(int location, E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mList.size();
+    }
+
+    @NonNull
+    @Override
+    public List<E> subList(int start, int end) {
+        throw new UnsupportedOperationException();
+    }
+
+    @NonNull
+    @Override
+    public Object[] toArray() {
+        return mList.toArray();
+    }
+
+    @NonNull
+    @Override
+    public <T> T[] toArray(@NonNull T[] array) {
+        //noinspection SuspiciousToArrayCall
+        return mList.toArray(array);
+    }
+
+}
diff --git a/src/main/java/org/acra/collections/ImmutableMap.java b/src/main/java/org/acra/collections/ImmutableMap.java
new file mode 100644
index 00000000..dd3a2bb2
--- /dev/null
+++ b/src/main/java/org/acra/collections/ImmutableMap.java
@@ -0,0 +1,131 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Naive (not optimized) implementation of an Immutable Map
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableMap<K, V> implements Map<K, V>, Serializable {
+
+    private final Map<K, V> mMap;
+
+    public ImmutableMap(Map<K, V> map) {
+        this.mMap = new HashMap<K, V>(map);
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return mMap.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return mMap.containsValue(value);
+    }
+
+    @NonNull
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        final Set<Entry<K, V>> original = mMap.entrySet();
+        final ImmutableSet.Builder<Entry<K, V>> builder = new ImmutableSet.Builder<Entry<K, V>>();
+        for (Entry<K, V> entry : original) {
+            builder.add(new ImmutableEntryWrapper<K, V>(entry));
+        }
+        return builder.build();
+    }
+
+    @Override
+    public V get(Object key) {
+        return mMap.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mMap.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Set<K> keySet() {
+        return new ImmutableSet<K>(mMap.keySet());
+    }
+
+    @Override
+    public V put(K key, V value) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void putAll(@NonNull Map<? extends K, ? extends V> map) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mMap.size();
+    }
+
+    @NonNull
+    @Override
+    public Collection<V> values() {
+        return new ImmutableList<V>(mMap.values());
+    }
+
+    public static class ImmutableEntryWrapper<K, V> implements Map.Entry<K, V> {
+        private final Map.Entry<K, V> mEntry;
+
+        ImmutableEntryWrapper(Entry<K, V> mEntry) {
+            this.mEntry = mEntry;
+        }
+
+        @Override
+        public K getKey() {
+            return mEntry.getKey();
+        }
+
+        @Override
+        public V getValue() {
+            return mEntry.getValue();
+        }
+
+        @Override
+        public V setValue(Object object) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+}
diff --git a/src/main/java/org/acra/collections/ImmutableSet.java b/src/main/java/org/acra/collections/ImmutableSet.java
new file mode 100644
index 00000000..e2781a8e
--- /dev/null
+++ b/src/main/java/org/acra/collections/ImmutableSet.java
@@ -0,0 +1,130 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import android.support.annotation.NonNull;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Naive (not optimized) implementation of an Immutable Set with reliable, user-specified iteration order.
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class ImmutableSet<E> implements Set<E>, Serializable {
+
+    private final Set<E> mSet;
+
+    public ImmutableSet(E... elements) {
+        this(Arrays.asList(elements));
+    }
+
+    public ImmutableSet(Collection<E> collection) {
+        this.mSet = new LinkedHashSet<E>(collection);
+    }
+
+    @Override
+    public boolean add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean addAll(@NonNull Collection<? extends E> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return mSet.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(@NonNull Collection<?> collection) {
+        return mSet.containsAll(collection);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return mSet.isEmpty();
+    }
+
+    @NonNull
+    @Override
+    public Iterator<E> iterator() {
+        return new UnmodifiableIteratorWrapper<E>(mSet.iterator());
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(@NonNull Collection<?> collection) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int size() {
+        return mSet.size();
+    }
+
+    @NonNull
+    @Override
+    public Object[] toArray() {
+        return mSet.toArray();
+    }
+
+    @NonNull
+    @Override
+    public <T> T[] toArray(@NonNull T[] array) {
+        //noinspection SuspiciousToArrayCall
+        return mSet.toArray(array);
+    }
+
+    public static final class Builder<E> {
+        private final Set<E> mSet;
+
+        public Builder() {
+            mSet = new LinkedHashSet<E>();
+        }
+
+        public void add(E element) {
+            mSet.add(element);
+        }
+
+        public ImmutableSet<E> build() {
+            return new ImmutableSet<E>(mSet);
+        }
+    }
+
+}
diff --git a/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java b/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java
new file mode 100644
index 00000000..c0308479
--- /dev/null
+++ b/src/main/java/org/acra/collections/UnmodifiableIteratorWrapper.java
@@ -0,0 +1,47 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import java.util.Iterator;
+
+/**
+ * Wrapper around an Iterator which prevents modifications
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+class UnmodifiableIteratorWrapper<E> implements Iterator<E> {
+    private final Iterator<E> mIterator;
+
+    UnmodifiableIteratorWrapper(Iterator<E> mIterator) {
+        this.mIterator = mIterator;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return mIterator.hasNext();
+    }
+
+    @Override
+    public E next() {
+        return mIterator.next();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java b/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java
new file mode 100644
index 00000000..97f0ab59
--- /dev/null
+++ b/src/main/java/org/acra/collections/UnmodifiableListIteratorWrapper.java
@@ -0,0 +1,78 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collections;
+
+import java.util.ListIterator;
+
+/**
+ * Wrapper around a ListIterator which prevents modifications
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+class UnmodifiableListIteratorWrapper<E> implements ListIterator<E> {
+    private final ListIterator<E> mIterator;
+
+    UnmodifiableListIteratorWrapper(ListIterator<E> mIterator) {
+        this.mIterator = mIterator;
+    }
+
+    @Override
+    public void add(E object) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasNext() {
+        return mIterator.hasNext();
+    }
+
+    @Override
+    public boolean hasPrevious() {
+        return mIterator.hasPrevious();
+    }
+
+    @Override
+    public E next() {
+        return mIterator.next();
+    }
+
+    @Override
+    public int nextIndex() {
+        return mIterator.nextIndex();
+    }
+
+    @Override
+    public E previous() {
+        return mIterator.previous();
+    }
+
+    @Override
+    public int previousIndex() {
+        return mIterator.previousIndex();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void set(E object) {
+        throw new UnsupportedOperationException();
+    }
+}
+
diff --git a/src/main/java/org/acra/collector/Collector.java b/src/main/java/org/acra/collector/Collector.java
new file mode 100644
index 00000000..7de6c49c
--- /dev/null
+++ b/src/main/java/org/acra/collector/Collector.java
@@ -0,0 +1,77 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Size;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+
+import java.util.Set;
+
+/**
+ * Represents a collector.
+ * Maintains information on which fields can be collected by this collector.
+ * Validates constraints in which a field should (not) be collected.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+abstract class Collector {
+    private final ReportField[] reportFields;
+
+    /**
+     * create a new Collector that is able to collect these reportFields
+     * (Note: @Size is currently not working for varargs, it is still here as a hint to developers)
+     *
+     * @param reportFields the supported reportFields
+     */
+    Collector(@Size(min = 1) @NonNull ReportField... reportFields) {
+        this.reportFields = reportFields;
+    }
+
+    /**
+     * @return all fields this collector can collect
+     */
+    @NonNull
+    final ReportField[] canCollect() {
+        return reportFields;
+    }
+
+    /**
+     * this should check if the set contains the field, but may add additional checks like permissions etc.
+     *
+     * @param crashReportFields configured fields
+     * @param collect           the filed to collect
+     * @param reportBuilder     the current reportBuilder
+     * @return if this field should be collected now
+     */
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return crashReportFields.contains(collect);
+    }
+
+    /**
+     * will only be called if shouldCollect returned true for this ReportField
+     *
+     * @param reportField   the ReportField to collect
+     * @param reportBuilder the current reportBuilder
+     * @return Element of what was collected
+     */
+    @NonNull
+    abstract Element collect(ReportField reportField, ReportBuilder reportBuilder);
+}
diff --git a/src/main/java/org/acra/collector/CollectorUtil.java b/src/main/java/org/acra/collector/CollectorUtil.java
deleted file mode 100644
index fa0f8b5b..00000000
--- a/src/main/java/org/acra/collector/CollectorUtil.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.acra.collector;
-
-import java.io.IOException;
-import java.io.Reader;
-
-public final class CollectorUtil {
-
-    /**
-     * Closes a Reader.
-     *
-     * @param reader    Reader to close. If reader is null then method just returns.
-     */
-    public static void safeClose(Reader reader) {
-    	if (reader == null) return;
-    	
-        try {
-            reader.close();
-        } catch (IOException e) {
-            // We made out best effort to release this resource. Nothing more we can do.
-        }
-    }
-}
diff --git a/src/main/java/org/acra/collector/Compatibility.java b/src/main/java/org/acra/collector/Compatibility.java
deleted file mode 100644
index 32ac14fb..00000000
--- a/src/main/java/org/acra/collector/Compatibility.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import android.content.Context;
-import android.os.Build;
-
-import java.lang.reflect.Field;
-
-/**
- * Utility class containing methods enabling backward compatibility.
- * 
- * @author Normal
- * 
- */
-public final class Compatibility {
-
-    /**
-     * Retrieves Android SDK API level using the best possible method.
-     * 
-     * @return The Android SDK API int level.
-     */
-    public static int getAPILevel() {
-        int apiLevel;
-        try {
-            // This field has been added in Android 1.6
-            final Field SDK_INT = Build.VERSION.class.getField("SDK_INT");
-            apiLevel = SDK_INT.getInt(null);
-        } catch (SecurityException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (NoSuchFieldException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalArgumentException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        } catch (IllegalAccessException e) {
-            apiLevel = Integer.parseInt(Build.VERSION.SDK);
-        }
-
-        return apiLevel;
-    }
-
-    /**
-     * Retrieve the DropBoxManager service name using reflection API.
-     *
-     * @return Name of the DropBox service regardless of Android version.
-     * @throws NoSuchFieldException if the field DROPBOX_SERVICE doesn't exist.
-     * @throws IllegalAccessException if the DROPBOX_SERVICE field is inaccessible.
-     */
-    public static String getDropBoxServiceName() throws NoSuchFieldException, IllegalAccessException {
-        final Field serviceName = Context.class.getField("DROPBOX_SERVICE");
-        if (serviceName != null) {
-            return (String) serviceName.get(null);
-        }
-        return null;
-    }
-}
diff --git a/src/main/java/org/acra/collector/ConfigurationCollector.java b/src/main/java/org/acra/collector/ConfigurationCollector.java
index 36662fa8..b1f6fc43 100644
--- a/src/main/java/org/acra/collector/ConfigurationCollector.java
+++ b/src/main/java/org/acra/collector/ConfigurationCollector.java
@@ -15,31 +15,37 @@
  */
 package org.acra.collector;
 
-import static org.acra.ACRA.LOG_TAG;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.support.annotation.NonNull;
+import android.util.SparseArray;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.HashMap;
+import java.util.Map;
 
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.util.Log;
-import android.util.SparseArray;
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * Inspects a {@link Configuration} object through reflection API in order to
  * generate a human readable String with values replaced with their constants
  * names. The {@link Configuration#toString()} method was not enough as values
- * like 0, 1, 2 or 3 don't look readable to me. Using reflection API allows to
+ * like 0, 1, 2 or 3 aren't readable. Using reflection API allows to
  * retrieve hidden fields and can make us hope to be compatible with all Android
  * API levels, even those which are not published yet.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin and F43nd1r
  */
-public final class ConfigurationCollector {
+public final class ConfigurationCollector extends Collector {
 
     private static final String SUFFIX_MASK = "_MASK";
     private static final String FIELD_SCREENLAYOUT = "screenLayout";
@@ -55,128 +61,151 @@
     private static final String PREFIX_KEYBOARDHIDDEN = "KEYBOARDHIDDEN_";
     private static final String PREFIX_KEYBOARD = "KEYBOARD_";
     private static final String PREFIX_HARDKEYBOARDHIDDEN = "HARDKEYBOARDHIDDEN_";
-    private static SparseArray<String> mHardKeyboardHiddenValues = new SparseArray<String>();
-    private static SparseArray<String> mKeyboardValues = new SparseArray<String>();
-    private static SparseArray<String> mKeyboardHiddenValues = new SparseArray<String>();
-    private static SparseArray<String> mNavigationValues = new SparseArray<String>();
-    private static SparseArray<String> mNavigationHiddenValues = new SparseArray<String>();
-    private static SparseArray<String> mOrientationValues = new SparseArray<String>();
-    private static SparseArray<String> mScreenLayoutValues = new SparseArray<String>();
-    private static SparseArray<String> mTouchScreenValues = new SparseArray<String>();
-    private static SparseArray<String> mUiModeValues = new SparseArray<String>();
-
-    private static final HashMap<String, SparseArray<String>> mValueArrays = new HashMap<String, SparseArray<String>>();
-
-    // Static init
-    static {
-        mValueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, mHardKeyboardHiddenValues);
-        mValueArrays.put(PREFIX_KEYBOARD, mKeyboardValues);
-        mValueArrays.put(PREFIX_KEYBOARDHIDDEN, mKeyboardHiddenValues);
-        mValueArrays.put(PREFIX_NAVIGATION, mNavigationValues);
-        mValueArrays.put(PREFIX_NAVIGATIONHIDDEN, mNavigationHiddenValues);
-        mValueArrays.put(PREFIX_ORIENTATION, mOrientationValues);
-        mValueArrays.put(PREFIX_SCREENLAYOUT, mScreenLayoutValues);
-        mValueArrays.put(PREFIX_TOUCHSCREEN, mTouchScreenValues);
-        mValueArrays.put(PREFIX_UI_MODE, mUiModeValues);
+
+    private final Context context;
+    private final Element initialConfiguration;
+
+    public ConfigurationCollector(@NonNull Context context, @NonNull Element initialConfiguration) {
+        super(ReportField.INITIAL_CONFIGURATION, ReportField.CRASH_CONFIGURATION);
+        this.context = context;
+        this.initialConfiguration = initialConfiguration;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case INITIAL_CONFIGURATION:
+                return initialConfiguration;
+            case CRASH_CONFIGURATION:
+                return collectConfiguration(context);
+            default:
+                throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Creates an Element listing all values human readable
+     * from the provided Configuration instance.
+     *
+     * @param conf The Configuration to be described.
+     * @return An Element describing all the fields of the given Configuration,
+     * with values replaced by constant names.
+     */
+    @NonNull
+    private static Element configToElement(@NonNull Configuration conf) {
+        final ComplexElement result = new ComplexElement();
+        Map<String, SparseArray<String>> valueArrays = getValueArrays();
+        for (final Field f : conf.getClass().getFields()) {
+            try {
+                if (!Modifier.isStatic(f.getModifiers())) {
+                    final String fieldName = f.getName();
+                    try {
+                        if (f.getType().equals(int.class)) {
+                            result.put(fieldName, getFieldValueName(valueArrays, conf, f));
+                        } else if (f.get(conf) != null) {
+                            result.put(fieldName, f.get(conf));
+                        }
+                    } catch (JSONException e) {
+                        ACRA.log.w(LOG_TAG, "Could not collect configuration field " + fieldName, e);
+                    }
+                }
+            } catch (@NonNull IllegalArgumentException e) {
+                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
+            } catch (@NonNull IllegalAccessException e) {
+                ACRA.log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
+            }
+        }
+        return result;
+    }
+
+    private static Map<String, SparseArray<String>> getValueArrays() {
+        Map<String, SparseArray<String>> valueArrays = new HashMap<String, SparseArray<String>>();
+        final SparseArray<String> hardKeyboardHiddenValues = new SparseArray<String>();
+        final SparseArray<String> keyboardValues = new SparseArray<String>();
+        final SparseArray<String> keyboardHiddenValues = new SparseArray<String>();
+        final SparseArray<String> navigationValues = new SparseArray<String>();
+        final SparseArray<String> navigationHiddenValues = new SparseArray<String>();
+        final SparseArray<String> orientationValues = new SparseArray<String>();
+        final SparseArray<String> screenLayoutValues = new SparseArray<String>();
+        final SparseArray<String> touchScreenValues = new SparseArray<String>();
+        final SparseArray<String> uiModeValues = new SparseArray<String>();
 
         for (final Field f : Configuration.class.getFields()) {
             if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
                 final String fieldName = f.getName();
                 try {
                     if (fieldName.startsWith(PREFIX_HARDKEYBOARDHIDDEN)) {
-                        mHardKeyboardHiddenValues.put(f.getInt(null), fieldName);
+                        hardKeyboardHiddenValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_KEYBOARD)) {
-                        mKeyboardValues.put(f.getInt(null), fieldName);
+                        keyboardValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_KEYBOARDHIDDEN)) {
-                        mKeyboardHiddenValues.put(f.getInt(null), fieldName);
+                        keyboardHiddenValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_NAVIGATION)) {
-                        mNavigationValues.put(f.getInt(null), fieldName);
+                        navigationValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_NAVIGATIONHIDDEN)) {
-                        mNavigationHiddenValues.put(f.getInt(null), fieldName);
+                        navigationHiddenValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_ORIENTATION)) {
-                        mOrientationValues.put(f.getInt(null), fieldName);
+                        orientationValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_SCREENLAYOUT)) {
-                        mScreenLayoutValues.put(f.getInt(null), fieldName);
+                        screenLayoutValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_TOUCHSCREEN)) {
-                        mTouchScreenValues.put(f.getInt(null), fieldName);
+                        touchScreenValues.put(f.getInt(null), fieldName);
                     } else if (fieldName.startsWith(PREFIX_UI_MODE)) {
-                        mUiModeValues.put(f.getInt(null), fieldName);
+                        uiModeValues.put(f.getInt(null), fieldName);
                     }
-                } catch (IllegalArgumentException e) {
-                    Log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
-                } catch (IllegalAccessException e) {
-                    Log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, "Error while inspecting device configuration: ", e);
                 }
             }
         }
-    }
 
-    /**
-     * Use this method to generate a human readable String listing all values
-     * from the provided Configuration instance.
-     * 
-     * @param conf
-     *            The Configuration to be described.
-     * @return A String describing all the fields of the given Configuration,
-     *         with values replaced by constant names.
-     */
-    public static String toString(Configuration conf) {
-        final StringBuilder result = new StringBuilder();
-        for (final Field f : conf.getClass().getFields()) {
-            try {
-                if (!Modifier.isStatic(f.getModifiers())) {
-                    final String fieldName = f.getName();
-                    result.append(fieldName).append('=');
-                    if (f.getType().equals(int.class)) {
-                        result.append(getFieldValueName(conf, f));
-                    } else if(f.get(conf) != null){
-                        result.append(f.get(conf).toString());
-                    }
-                    result.append('\n');
-                }
-            } catch (IllegalArgumentException e) {
-                Log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            } catch (IllegalAccessException e) {
-                Log.e(LOG_TAG, "Error while inspecting device configuration: ", e);
-            }
-        }
-        return result.toString();
+        valueArrays.put(PREFIX_HARDKEYBOARDHIDDEN, hardKeyboardHiddenValues);
+        valueArrays.put(PREFIX_KEYBOARD, keyboardValues);
+        valueArrays.put(PREFIX_KEYBOARDHIDDEN, keyboardHiddenValues);
+        valueArrays.put(PREFIX_NAVIGATION, navigationValues);
+        valueArrays.put(PREFIX_NAVIGATIONHIDDEN, navigationHiddenValues);
+        valueArrays.put(PREFIX_ORIENTATION, orientationValues);
+        valueArrays.put(PREFIX_SCREENLAYOUT, screenLayoutValues);
+        valueArrays.put(PREFIX_TOUCHSCREEN, touchScreenValues);
+        valueArrays.put(PREFIX_UI_MODE, uiModeValues);
+        return valueArrays;
     }
 
     /**
      * Retrieve the name of the constant defined in the {@link Configuration}
      * class which defines the value of a field in a {@link Configuration}
      * instance.
-     * 
-     * @param conf
-     *            The instance of {@link Configuration} where the value is
-     *            stored.
-     * @param f
-     *            The {@link Field} to be inspected in the {@link Configuration}
-     *            instance.
+     *
+     * @param conf The instance of {@link Configuration} where the value is
+     *             stored.
+     * @param f    The {@link Field} to be inspected in the {@link Configuration}
+     *             instance.
      * @return The value of the field f in instance conf translated to its
-     *         constant name.
+     * constant name.
      * @throws IllegalAccessException if the supplied field is inaccessible.
      */
-    private static String getFieldValueName(Configuration conf, Field f) throws IllegalAccessException {
+    private static Object getFieldValueName(Map<String, SparseArray<String>> valueArrays, @NonNull Configuration conf, @NonNull Field f) throws IllegalAccessException {
         final String fieldName = f.getName();
         if (fieldName.equals(FIELD_MCC) || fieldName.equals(FIELD_MNC)) {
-            return Integer.toString(f.getInt(conf));
+            return f.getInt(conf);
         } else if (fieldName.equals(FIELD_UIMODE)) {
-            return activeFlags(mValueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
+            return activeFlags(valueArrays.get(PREFIX_UI_MODE), f.getInt(conf));
         } else if (fieldName.equals(FIELD_SCREENLAYOUT)) {
-            return activeFlags(mValueArrays.get(PREFIX_SCREENLAYOUT), f.getInt(conf));
+            return activeFlags(valueArrays.get(PREFIX_SCREENLAYOUT), f.getInt(conf));
         } else {
-            final SparseArray<String> values = mValueArrays.get(fieldName.toUpperCase() + '_');
+            final SparseArray<String> values = valueArrays.get(fieldName.toUpperCase() + '_');
             if (values == null) {
                 // Unknown field, return the raw int as String
-                return Integer.toString(f.getInt(conf));
+                return f.getInt(conf);
             }
 
             final String value = values.get(f.getInt(conf));
             if (value == null) {
                 // Unknown value, return the raw int as String
-                return Integer.toString(f.getInt(conf));
+                return f.getInt(conf);
             }
             return value;
         }
@@ -186,16 +215,15 @@ private static String getFieldValueName(Configuration conf, Field f) throws Ille
      * Some fields contain multiple value types which can be isolated by
      * applying a bitmask. That method returns the concatenation of active
      * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
+     *
+     * @param valueNames The array containing the different values and names for this
+     *                   field. Must contain mask values too.
+     * @param bitfield   The bitfield to inspect.
      * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
+     * separated by '+'.
      */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
+    @NonNull
+    private static String activeFlags(@NonNull SparseArray<String> valueNames, int bitfield) {
         final StringBuilder result = new StringBuilder();
 
         // Look for masks, apply it an retrieve the masked value
@@ -213,20 +241,20 @@ private static String activeFlags(SparseArray<String> valueNames, int bitfield)
         }
         return result.toString();
     }
-    
+
     /**
      * Returns the current Configuration for this application.
      *
-     * @param context   Context for the application being reported.
+     * @param context Context for the application being reported.
      * @return A String representation of the current configuration for the application.
      */
-    public static String collectConfiguration(Context context) {
+    @NonNull
+    public static Element collectConfiguration(@NonNull Context context) {
         try {
-            final Configuration crashConf = context.getResources().getConfiguration();
-            return ConfigurationCollector.toString(crashConf);
+            return configToElement(context.getResources().getConfiguration());
         } catch (RuntimeException e) {
-            Log.w(ACRA.LOG_TAG, "Couldn't retrieve CrashConfiguration for : " + context.getPackageName(), e);
-            return "Couldn't retrieve crash config";
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve CrashConfiguration for : " + context.getPackageName(), e);
+            return ACRAConstants.NOT_AVAILABLE;
         }
     }
 }
diff --git a/src/main/java/org/acra/collector/CrashReportData.java b/src/main/java/org/acra/collector/CrashReportData.java
index 60aae535..73ab4f60 100644
--- a/src/main/java/org/acra/collector/CrashReportData.java
+++ b/src/main/java/org/acra/collector/CrashReportData.java
@@ -1,58 +1,77 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.acra.collector;
-
-import java.util.EnumMap;
-import java.util.Properties;
-
-import org.acra.ReportField;
-import org.acra.util.JSONReportBuilder;
-import org.acra.util.JSONReportBuilder.JSONReportException;
-import org.json.JSONObject;
-
-/**
- * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
- * This is basically the source of {@link Properties} adapted to extend an
- * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
- * amounts of android time in the generation of a date comment when storing to
- * file.
- */
-public final class CrashReportData extends EnumMap<ReportField, String> {
-
-    private static final long serialVersionUID = 4112578634029874840L;
-
-    /**
-     * Constructs a new {@code Properties} object.
-     */
-    public CrashReportData() {
-        super(ReportField.class);
-    }
-
-    /**
-     * Returns the property with the specified name.
-     * 
-     * @param key the name of the property to find.
-     * @return the named property value, or {@code null} if it can't be found.
-     */
-    public String getProperty(ReportField key) {
-        return super.get(key);
-    }
-
-    public JSONObject toJSON() throws JSONReportException {
-        return JSONReportBuilder.buildJSONReport(this);
-    }
-}
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ReportField;
+import org.acra.model.BooleanElement;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.JsonUtils;
+import org.json.JSONObject;
+
+import java.util.EnumMap;
+import java.util.Properties;
+
+/**
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
+ * <p>
+ * This is basically the source of {@link Properties} adapted to extend an
+ * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
+ * amounts of android time in the generation of a date comment when storing to file.
+ */
+public final class CrashReportData extends EnumMap<ReportField, Element> {
+
+    private static final long serialVersionUID = 5002578634500874842L;
+
+    /**
+     * Constructs a new {@code Properties} object.
+     */
+    public CrashReportData() {
+        super(ReportField.class);
+    }
+
+    /**
+     * Returns the property with the specified name.
+     *
+     * @param key the name of the property to find.
+     * @return the named property value, or {@code null} if it can't be found.
+     */
+    public String getProperty(@NonNull ReportField key) {
+        return super.get(key).toString();
+    }
+
+    public void putString(@NonNull ReportField key, String value) {
+        put(key, new StringElement(value));
+    }
+
+    public void putNumber(@NonNull ReportField key, Number value) {
+        put(key, new NumberElement(value));
+    }
+
+    public void putBoolean(@NonNull ReportField key, boolean value) {
+        put(key, new BooleanElement(value));
+    }
+
+    @NonNull
+    public JSONObject toJSON() {
+        return JsonUtils.toJson(this);
+    }
+
+}
diff --git a/src/main/java/org/acra/collector/CrashReportDataFactory.java b/src/main/java/org/acra/collector/CrashReportDataFactory.java
index f0764f85..e042a7b5 100644
--- a/src/main/java/org/acra/collector/CrashReportDataFactory.java
+++ b/src/main/java/org/acra/collector/CrashReportDataFactory.java
@@ -16,35 +16,25 @@
 
 package org.acra.collector;
 
-import static org.acra.ACRA.LOG_TAG;
-import static org.acra.ReportField.*;
-
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
 
 import org.acra.ACRA;
-import org.acra.ACRAConstants;
 import org.acra.ReportField;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.util.Installation;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
 import org.acra.util.PackageManagerWrapper;
-import org.acra.util.ReportUtils;
 
-import android.Manifest;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.os.Environment;
-import android.text.format.Time;
-import android.util.Log;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * Responsible for creating the CrashReportData for an Exception.
@@ -58,14 +48,17 @@
 public final class CrashReportDataFactory {
 
     private final Context context;
+    private final ACRAConfiguration config;
     private final SharedPreferences prefs;
     private final Map<String, String> customParameters = new LinkedHashMap<String, String>();
-    private final Time appStartDate;
-    private final String initialConfiguration;
+    private final Calendar appStartDate;
+    private final Element initialConfiguration;
 
-    public CrashReportDataFactory(Context context, SharedPreferences prefs, Time appStartDate,
-                                  String initialConfiguration) {
+    public CrashReportDataFactory(@NonNull Context context, @NonNull ACRAConfiguration config,
+                                  @NonNull SharedPreferences prefs, @NonNull Calendar appStartDate,
+                                  @NonNull Element initialConfiguration) {
         this.context = context;
+        this.config = config;
         this.prefs = prefs;
         this.appStartDate = appStartDate;
         this.initialConfiguration = initialConfiguration;
@@ -81,24 +74,21 @@ public CrashReportDataFactory(Context context, SharedPreferences prefs, Time app
      * containing one 'key = value' pair on each line.
      * </p>
      *
-     * @param key
-     *            A key for your custom data.
-     * @param value
-     *            The value associated to your key.
+     * @param key   A key for your custom data.
+     * @param value The value associated to your key.
      * @return The previous value for this key if there was one, or null.
      */
-    public String putCustomData(String key, String value) {
+    public String putCustomData(@NonNull String key, String value) {
         return customParameters.put(key, value);
     }
 
     /**
      * Removes a key/value pair from the custom data field.
      *
-     * @param key
-     *            The key of the data to be removed.
+     * @param key The key of the data to be removed.
      * @return The value for this key before removal.
      */
-    public String removeCustomData(String key) {
+    public String removeCustomData(@NonNull String key) {
         return customParameters.remove(key);
     }
 
@@ -112,357 +102,72 @@ public void clearCustomData() {
     /**
      * Gets the current value for a key in the custom data field.
      *
-     * @param key
-     *            The key of the data to be retrieved.
+     * @param key The key of the data to be retrieved.
      * @return The value for this key.
      */
-    public String getCustomData(String key) {
+    public String getCustomData(@NonNull String key) {
         return customParameters.get(key);
     }
 
     /**
      * Collects crash data.
      *
-     * @param msg
-     *            A message to be associated with the crash report.
-     * @param th
-     *            Throwable that caused the crash.
-     * @param customData
-     *            Custom key/value pairs to be associated with the crash report.
-     * @param isSilentReport
-     *            Whether to report this report as being sent silently.
-     * @param brokenThread  Thread on which the error occurred.
-     * @return CrashReportData representing the current state of the application
-     *         at the instant of the Exception.
+     * @param builder ReportBuilder for whom to crete the crash report.
+     * @return CrashReportData identifying the current crash.
      */
-    public CrashReportData createCrashData(String msg, Throwable th, Map<String, String> customData, boolean isSilentReport, Thread brokenThread) {
+    @NonNull
+    public CrashReportData createCrashData(@NonNull ReportBuilder builder) {
         final CrashReportData crashReportData = new CrashReportData();
         try {
-            final List<ReportField> crashReportFields = getReportFields();
-
-            // Make every entry here bullet proof and move any slightly dodgy
-            // ones to the end.
-            // This ensures that we collect as much info as possible before
-            // something crashes the collection process.
+            final Set<ReportField> crashReportFields = config.getReportFields();
+            final List<Collector> collectors = getCollectorsOrdered();
 
-            crashReportData.put(STACK_TRACE, getStackTrace(msg, th));
-            crashReportData.put(ReportField.USER_APP_START_DATE, ReportUtils.getTimeString(appStartDate));
-
-            if (isSilentReport) {
-                crashReportData.put(IS_SILENT, "true");
-            }
-
-            // StackTrace hash
-            if (crashReportFields.contains(STACK_TRACE_HASH)) {
-                crashReportData.put(ReportField.STACK_TRACE_HASH, getStackTraceHash(th));
-            }
-
-            // Generate report uuid
-            if (crashReportFields.contains(REPORT_ID)) {
-                crashReportData.put(ReportField.REPORT_ID, UUID.randomUUID().toString());
-            }
-
-            // Installation unique ID
-            if (crashReportFields.contains(INSTALLATION_ID)) {
-                crashReportData.put(INSTALLATION_ID, Installation.id(context));
-            }
-
-            // Device Configuration when crashing
-            if (crashReportFields.contains(INITIAL_CONFIGURATION)) {
-                crashReportData.put(INITIAL_CONFIGURATION, initialConfiguration);
-            }
-            if (crashReportFields.contains(CRASH_CONFIGURATION)) {
-                crashReportData.put(CRASH_CONFIGURATION, ConfigurationCollector.collectConfiguration(context));
-            }
-
-            // Collect meminfo
-            if (!(th instanceof OutOfMemoryError) && crashReportFields.contains(DUMPSYS_MEMINFO)) {
-                crashReportData.put(DUMPSYS_MEMINFO, DumpSysCollector.collectMemInfo());
-            }
-
-            // Application Package name
-            if (crashReportFields.contains(PACKAGE_NAME)) {
-                crashReportData.put(PACKAGE_NAME, context.getPackageName());
-            }
-
-            // Android OS Build details
-            if (crashReportFields.contains(BUILD)) {
-                crashReportData.put(BUILD, ReflectionCollector.collectConstants(android.os.Build.class) + ReflectionCollector.collectConstants(android.os.Build.VERSION.class, "VERSION"));
-            }
-
-            // Device model
-            if (crashReportFields.contains(PHONE_MODEL)) {
-                crashReportData.put(PHONE_MODEL, android.os.Build.MODEL);
-            }
-            // Android version
-            if (crashReportFields.contains(ANDROID_VERSION)) {
-                crashReportData.put(ANDROID_VERSION, android.os.Build.VERSION.RELEASE);
-            }
-
-            // Device Brand (manufacturer)
-            if (crashReportFields.contains(BRAND)) {
-                crashReportData.put(BRAND, android.os.Build.BRAND);
-            }
-            if (crashReportFields.contains(PRODUCT)) {
-                crashReportData.put(PRODUCT, android.os.Build.PRODUCT);
-            }
-
-            // Device Memory
-            if (crashReportFields.contains(TOTAL_MEM_SIZE)) {
-                crashReportData.put(TOTAL_MEM_SIZE, Long.toString(ReportUtils.getTotalInternalMemorySize()));
-            }
-            if (crashReportFields.contains(AVAILABLE_MEM_SIZE)) {
-                crashReportData.put(AVAILABLE_MEM_SIZE, Long.toString(ReportUtils.getAvailableInternalMemorySize()));
-            }
-
-            // Application file path
-            if (crashReportFields.contains(FILE_PATH)) {
-                crashReportData.put(FILE_PATH, ReportUtils.getApplicationFilePath(context));
-            }
-
-            // Main display details
-            if (crashReportFields.contains(DISPLAY)) {
-                crashReportData.put(DISPLAY, DisplayManagerCollector.collectDisplays(context));
-            }
-
-            // User crash date with local timezone
-            if (crashReportFields.contains(USER_CRASH_DATE)) {
-                final Time curDate = new Time();
-                curDate.setToNow();
-                crashReportData.put(USER_CRASH_DATE, ReportUtils.getTimeString(curDate));
-            }
-
-            // Add custom info, they are all stored in a single field
-            if (crashReportFields.contains(CUSTOM_DATA)) {
-                crashReportData.put(CUSTOM_DATA, createCustomInfoString(customData));
-            }
-
-            if (crashReportFields.contains(BUILD_CONFIG)) {
+            //this will iterate over all collectors in descending order of priority
+            for (Collector collector : collectors) {
+                //catch absolutely everything possible here so no collector obstructs the others
                 try {
-                    final Class buildConfigClass = getBuildConfigClass();
-                    crashReportData.put(BUILD_CONFIG, ReflectionCollector.collectConstants(buildConfigClass));
-                } catch (ClassNotFoundException e) {
-                    // We have already logged this when we had the name of the class that wasn't found.
+                    for (ReportField reportField : collector.canCollect()) {
+                        try {
+                            if (collector.shouldCollect(crashReportFields, reportField, builder)) {
+                                crashReportData.put(reportField, collector.collect(reportField, builder));
+                            }
+                        } catch (RuntimeException e) {
+                            ACRA.log.e(LOG_TAG, "Error while retrieving " + reportField.name() + " data", e);
+                        }
+                    }
+                } catch (RuntimeException e) {
+                    ACRA.log.e(LOG_TAG, "Error in collector " + collector.getClass().getSimpleName(), e);
                 }
             }
 
-            // Add user email address, if set in the app's preferences
-            if (crashReportFields.contains(USER_EMAIL)) {
-                crashReportData.put(USER_EMAIL, prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "N/A"));
-            }
-
-            // Device features
-            if (crashReportFields.contains(DEVICE_FEATURES)) {
-                crashReportData.put(DEVICE_FEATURES, DeviceFeaturesCollector.getFeatures(context));
-            }
-
-            // Environment (External storage state)
-            if (crashReportFields.contains(ENVIRONMENT)) {
-                crashReportData.put(ENVIRONMENT, ReflectionCollector.collectStaticGettersResults(Environment.class));
-            }
-
-            // System settings
-            if (crashReportFields.contains(SETTINGS_SYSTEM)) {
-                crashReportData.put(SETTINGS_SYSTEM, SettingsCollector.collectSystemSettings(context));
-            }
-
-            // Secure settings
-            if (crashReportFields.contains(SETTINGS_SECURE)) {
-                crashReportData.put(SETTINGS_SECURE, SettingsCollector.collectSecureSettings(context));
-            }
-
-            // Global settings
-            if (crashReportFields.contains(SETTINGS_GLOBAL)) {
-                crashReportData.put(SETTINGS_GLOBAL, SettingsCollector.collectGlobalSettings(context));
-            }
-
-            // SharedPreferences
-            if (crashReportFields.contains(SHARED_PREFERENCES)) {
-                crashReportData.put(SHARED_PREFERENCES, SharedPreferencesCollector.collect(context));
-            }
-
-            // Now get all the crash data that relies on the PackageManager
-            // (which may or may not be here).
-            final PackageManagerWrapper pm = new PackageManagerWrapper(context);
-
-            final PackageInfo pi = pm.getPackageInfo();
-            if (pi != null) {
-                // Application Version
-                if (crashReportFields.contains(APP_VERSION_CODE)) {
-                    crashReportData.put(APP_VERSION_CODE, Integer.toString(pi.versionCode));
-                }
-                if (crashReportFields.contains(APP_VERSION_NAME)) {
-                    crashReportData.put(APP_VERSION_NAME, pi.versionName != null ? pi.versionName : "not set");
-                }
-            } else {
-                // Could not retrieve package info...
-                crashReportData.put(APP_VERSION_NAME, "Package info unavailable");
-            }
-
-            // Retrieve UDID(IMEI) if permission is available
-            if (crashReportFields.contains(DEVICE_ID) && prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
-                && pm.hasPermission(Manifest.permission.READ_PHONE_STATE)) {
-                final String deviceId = ReportUtils.getDeviceId(context);
-                if (deviceId != null) {
-                    crashReportData.put(DEVICE_ID, deviceId);
-                }
-            }
-
-            // Collect DropBox and logcat
-            // Before JellyBean, this required the READ_LOGS permission
-            // Since JellyBean, READ_LOGS is not granted to third-party apps anymore for security reasons.
-            // Though, we can call logcat without any permission and still get traces related to our app.
-            final boolean hasReadLogsPermission = pm.hasPermission(Manifest.permission.READ_LOGS) || (Compatibility.getAPILevel() >= 16);
-            if (prefs.getBoolean(ACRA.PREF_ENABLE_SYSTEM_LOGS, true) && hasReadLogsPermission) {
-                Log.i(ACRA.LOG_TAG, "READ_LOGS granted! ACRA can include LogCat and DropBox data.");
-                if (crashReportFields.contains(LOGCAT)) {
-                    crashReportData.put(LOGCAT, LogCatCollector.collectLogCat(null));
-                }
-                if (crashReportFields.contains(EVENTSLOG)) {
-                    crashReportData.put(EVENTSLOG, LogCatCollector.collectLogCat("events"));
-                }
-                if (crashReportFields.contains(RADIOLOG)) {
-                    crashReportData.put(RADIOLOG, LogCatCollector.collectLogCat("radio"));
-                }
-                if (crashReportFields.contains(DROPBOX)) {
-                    crashReportData.put(DROPBOX,
-                                        DropBoxCollector.read(context, ACRA.getConfig().additionalDropBoxTags()));
-                }
-            } else {
-                Log.i(ACRA.LOG_TAG, "READ_LOGS not allowed. ACRA will not include LogCat and DropBox data.");
-            }
-
-            // Application specific log file
-            if (crashReportFields.contains(APPLICATION_LOG)) {
-                try {
-                    final String logFile = LogFileCollector.collectLogFile(context,
-                                                                           ACRA.getConfig().applicationLogFile(),
-                                                                           ACRA.getConfig().applicationLogFileLines());
-                    crashReportData.put(APPLICATION_LOG, logFile);
-                } catch (IOException e) {
-                    Log.e(LOG_TAG, "Error while reading application log file " + ACRA.getConfig().applicationLogFile(), e);
-                }
-            }
-
-            // Media Codecs list
-            if (crashReportFields.contains(MEDIA_CODEC_LIST)) {
-                crashReportData.put(MEDIA_CODEC_LIST, MediaCodecListCollector.collecMediaCodecList());
-            }
-
-            // Failing thread details
-            if (crashReportFields.contains(THREAD_DETAILS)) {
-                crashReportData.put(THREAD_DETAILS, ThreadCollector.collect(brokenThread));
-            }
-
-            // IP addresses
-            if (crashReportFields.contains(USER_IP)) {
-                crashReportData.put(USER_IP, ReportUtils.getLocalIpAddress());
-            }
-
         } catch (RuntimeException e) {
-            Log.e(LOG_TAG, "Error while retrieving crash data", e);
+            ACRA.log.e(LOG_TAG, "Error while retrieving crash data", e);
         }
 
         return crashReportData;
     }
 
-    /**
-     * Generates the string which is posted in the single custom data field in
-     * the GoogleDocs Form.
-     *
-     * @return A string with a 'key = value' pair on each line.
-     */
-    private String createCustomInfoString(Map<String, String> reportCustomData) {
-        Map<String, String> params = customParameters;
-
-        if (reportCustomData != null) {
-            params = new HashMap<String, String>(params);
-            params.putAll(reportCustomData);
-        }
-
-        final StringBuilder customInfo = new StringBuilder();
-        for (final String currentKey : params.keySet()) {
-            String currentVal = params.get(currentKey);
-            customInfo.append(currentKey);
-            customInfo.append(" = ");
-            // We need to escape new lines in values or they are transformed into new
-            // custom fields. => let's replace all '\n' with "\\n"
-            if(currentVal != null) {
-                currentVal = currentVal.replaceAll("\n", "\\\\n");
-            }
-            customInfo.append(currentVal);
-            customInfo.append("\n");
-        }
-        return customInfo.toString();
-    }
-
-    private String getStackTrace(String msg, Throwable th) {
-        final Writer result = new StringWriter();
-        final PrintWriter printWriter = new PrintWriter(result);
-
-        if (msg != null && !msg.isEmpty())
-            printWriter.println(msg);
-
-        // If the exception was thrown in a background thread inside
-        // AsyncTask, then the actual exception can be found with getCause
-        Throwable cause = th;
-        while (cause != null) {
-            cause.printStackTrace(printWriter);
-            cause = cause.getCause();
-        }
-        final String stacktraceAsString = result.toString();
-        printWriter.close();
-
-        return stacktraceAsString;
-    }
-
-    private String getStackTraceHash(Throwable th) {
-        final StringBuilder res = new StringBuilder();
-        Throwable cause = th;
-        while (cause != null) {
-            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
-            for (final StackTraceElement e : stackTraceElements) {
-                res.append(e.getClassName());
-                res.append(e.getMethodName());
-            }
-            cause = cause.getCause();
-        }
-
-        return Integer.toHexString(res.toString().hashCode());
-    }
-
-    private List<ReportField> getReportFields() {
-        final ReportsCrashes config = ACRA.getConfig();
-        final ReportField[] customReportFields = config.customReportContent();
-
-        final ReportField[] fieldsList;
-        if (customReportFields.length != 0) {
-            Log.d(LOG_TAG, "Using custom Report Fields");
-            fieldsList = customReportFields;
-        } else if (config.mailTo() == null || "".equals(config.mailTo())) {
-            Log.d(LOG_TAG, "Using default Report Fields");
-            fieldsList = ACRAConstants.DEFAULT_REPORT_FIELDS;
-        } else {
-            Log.d(LOG_TAG, "Using default Mail Report Fields");
-            fieldsList = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
-        }
-        return Arrays.asList(fieldsList);
-    }
-
-    private Class<?> getBuildConfigClass() throws ClassNotFoundException {
-        final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
-        if ((configuredBuildConfig != null) && !configuredBuildConfig.equals(Object.class)) {
-            // If set via annotations or programatically then it will have a real value,
-            // otherwise it will be Object.class (annotation default) or null (explicit programmatic).
-            return configuredBuildConfig;
-        }
-
-        final String className = context.getClass().getPackage().getName() + ".BuildConfig";
-        try {
-            return Class.forName(className);
-        } catch (ClassNotFoundException e) {
-            Log.e(ACRA.LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
-            throw e;
-        }
+    private List<Collector> getCollectorsOrdered() {
+        List<Collector> collectors = new ArrayList<Collector>();
+        PackageManagerWrapper pm = new PackageManagerWrapper(context);
+        collectors.add(new LogCatCollector(config, pm));
+        collectors.add(new DropBoxCollector(context, config, pm));
+        collectors.add(new StacktraceCollector());
+        collectors.add(new TimeCollector(appStartDate));
+        collectors.add(new SimpleValuesCollector(context));
+        collectors.add(new ConfigurationCollector(context, initialConfiguration));
+        collectors.add(new MemoryInfoCollector());
+        collectors.add(new ReflectionCollector(context, config));
+        collectors.add(new DisplayManagerCollector(context));
+        collectors.add(new CustomDataCollector(customParameters));
+        collectors.add(new SharedPreferencesCollector(context, config, prefs));
+        collectors.add(new DeviceFeaturesCollector(context));
+        collectors.add(new SettingsCollector(context, config));
+        collectors.add(new PackageManagerCollector(pm));
+        collectors.add(new DeviceIdCollector(context, pm, prefs));
+        collectors.add(new LogFileCollector(context, config));
+        collectors.add(new MediaCodecListCollector());
+        collectors.add(new ThreadCollector());
+        return collectors;
     }
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/CustomDataCollector.java b/src/main/java/org/acra/collector/CustomDataCollector.java
new file mode 100644
index 00000000..68bbceec
--- /dev/null
+++ b/src/main/java/org/acra/collector/CustomDataCollector.java
@@ -0,0 +1,63 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Collects custom data supplied by the user
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class CustomDataCollector extends Collector {
+    private final Map<String, String> customParameters;
+
+    CustomDataCollector(Map<String, String> customParameters){
+        super(ReportField.CUSTOM_DATA);
+        this.customParameters = customParameters;
+    }
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        return createCustomInfoElement(reportBuilder.getCustomData());
+    }
+
+
+    /**
+     * Generates the Element which is posted in the single custom data field
+     *
+     * @return An Element with  key-value-pairs for the supplied custom data.
+     */
+    @NonNull
+    private Element createCustomInfoElement(@Nullable Map<String, String> reportCustomData) {
+        Map<String, String> params = customParameters;
+        if (reportCustomData != null) {
+            params = new HashMap<String, String>(params);
+            params.putAll(reportCustomData);
+        }
+        return new ComplexElement(params);
+    }
+}
diff --git a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java b/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
index d902f51e..b29ac2b9 100644
--- a/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
+++ b/src/main/java/org/acra/collector/DeviceFeaturesCollector.java
@@ -15,51 +15,58 @@
  */
 package org.acra.collector;
 
-import static org.acra.ACRA.LOG_TAG;
-
-import java.lang.reflect.Method;
-
 import android.content.Context;
+import android.content.pm.FeatureInfo;
 import android.content.pm.PackageManager;
-import android.util.Log;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
- * Features declared as available on the device. Available only with API level > 5.
- * 
- * @author Kevin Gaudin
- * 
+ * Features declared as available on the device.
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-final class DeviceFeaturesCollector {
-
-    public static String getFeatures(Context ctx) {
+final class DeviceFeaturesCollector extends Collector {
+    private final Context context;
 
-        if (Compatibility.getAPILevel() < 5) {
-            return "Data available only with API Level >= 5";
-        }
+    DeviceFeaturesCollector(Context context) {
+        super(ReportField.DEVICE_FEATURES);
+        this.context = context;
+    }
 
-        final StringBuilder result = new StringBuilder();
+    /**
+     * collects device features
+     *
+     * @param reportField   the ReportField to collect
+     * @param reportBuilder the current reportBuilder
+     * @return Element of all device feature names
+     */
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final ComplexElement result = new ComplexElement();
         try {
-            final PackageManager pm = ctx.getPackageManager();
-            final Method getSystemAvailableFeatures = PackageManager.class.getMethod("getSystemAvailableFeatures", (Class[]) null);
-            final Object[] features = (Object[]) getSystemAvailableFeatures.invoke(pm);
-            for (final Object feature : features) {
-                final String featureName = (String) feature.getClass().getField("name").get(feature);
-                if(featureName != null) {
-                    result.append(featureName);
+            final PackageManager pm = context.getPackageManager();
+            final FeatureInfo[] features = pm.getSystemAvailableFeatures();
+            for (final FeatureInfo feature : features) {
+                final String featureName = feature.name;
+                if (featureName != null) {
+                    result.put(featureName, true);
                 } else {
-                    final Method getGlEsVersion = feature.getClass().getMethod("getGlEsVersion", (Class[]) null);
-                    final String glEsVersion = (String) getGlEsVersion.invoke(feature);
-                    result.append("glEsVersion = ");
-                    result.append(glEsVersion);
+                    result.put("glEsVersion", feature.getGlEsVersion());
                 }
-                result.append("\n");
             }
         } catch (Throwable e) {
-            Log.w(LOG_TAG, "Couldn't retrieve DeviceFeatures for " + ctx.getPackageName(), e);
-            result.append("Could not retrieve data: ");
-            result.append(e.getMessage());
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceFeatures for " + context.getPackageName(), e);
         }
 
-        return result.toString();
+        return result;
     }
 }
diff --git a/src/main/java/org/acra/collector/DeviceIdCollector.java b/src/main/java/org/acra/collector/DeviceIdCollector.java
new file mode 100644
index 00000000..d94229a7
--- /dev/null
+++ b/src/main/java/org/acra/collector/DeviceIdCollector.java
@@ -0,0 +1,85 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.Manifest;
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.telephony.TelephonyManager;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.PackageManagerWrapper;
+
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects the device ID
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class DeviceIdCollector extends Collector {
+    private final Context context;
+    private final PackageManagerWrapper pm;
+    private final SharedPreferences prefs;
+
+    DeviceIdCollector(Context context, PackageManagerWrapper pm, SharedPreferences prefs) {
+        super(ReportField.DEVICE_ID);
+        this.context = context;
+        this.pm = pm;
+        this.prefs = prefs;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && prefs.getBoolean(ACRA.PREF_ENABLE_DEVICE_ID, true)
+                && pm.hasPermission(Manifest.permission.READ_PHONE_STATE);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        String result = getDeviceId();
+        return result != null ? new StringElement(result) : ACRAConstants.NOT_AVAILABLE;
+    }
+
+    /**
+     * Returns the DeviceId according to the TelephonyManager.
+     *
+     * @return Returns the DeviceId according to the TelephonyManager or null if there is no TelephonyManager.
+     */
+    @SuppressLint("HardwareIds")
+    @Nullable
+    private String getDeviceId() {
+        try {
+            final TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            return tm.getDeviceId();
+        } catch (RuntimeException e) {
+            ACRA.log.w(LOG_TAG, "Couldn't retrieve DeviceId for : " + context.getPackageName(), e);
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/collector/DisplayManagerCollector.java b/src/main/java/org/acra/collector/DisplayManagerCollector.java
index 39141fc3..82eed946 100644
--- a/src/main/java/org/acra/collector/DisplayManagerCollector.java
+++ b/src/main/java/org/acra/collector/DisplayManagerCollector.java
@@ -1,294 +1,231 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package org.acra.collector;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.acra.ACRA;
-
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.Rect;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.v4.hardware.display.DisplayManagerCompat;
 import android.util.DisplayMetrics;
 import android.util.SparseArray;
 import android.view.Display;
 import android.view.Surface;
-import android.view.WindowManager;
 
-final class DisplayManagerCollector {
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
 
-    final static SparseArray<String> mFlagsNames = new SparseArray<String>();
-    final static SparseArray<String> mDensities = new SparseArray<String>();
+import java.lang.reflect.Field;
+import java.util.Arrays;
+
+/**
+ * Collects information about the connected display(s)
+ *
+ * @author (original author unknown) & F43nd1r
+ */
+final class DisplayManagerCollector extends Collector {
+    private final Context context;
+    private final SparseArray<String> flagNames = new SparseArray<String>();
+
+    DisplayManagerCollector(Context context) {
+        super(ReportField.DISPLAY);
+        this.context = context;
+    }
 
-    public static String collectDisplays(Context ctx) {
-        Display[] displays = null;
-        final StringBuilder result = new StringBuilder();
 
-        if (Compatibility.getAPILevel() < 17) {
-            // Before Android 4.2, there was a single display available from the
-            // window manager
-            final WindowManager windowManager = (WindowManager) ctx
-                    .getSystemService(android.content.Context.WINDOW_SERVICE);
-            displays = new Display[1];
-            displays[0] = windowManager.getDefaultDisplay();
-        } else {
-            // Since Android 4.2, we can fetch multiple displays with the
-            // DisplayManager.
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        final ComplexElement result = new ComplexElement();
+        for (Display display : DisplayManagerCompat.getInstance(context).getDisplays()) {
             try {
-                Object displayManager = ctx.getSystemService((String) (ctx.getClass().getField("DISPLAY_SERVICE")
-                        .get(null)));
-                Method getDisplays = displayManager.getClass().getMethod("getDisplays");
-                displays = (Display[]) getDisplays.invoke(displayManager);
-            } catch (IllegalArgumentException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (SecurityException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (IllegalAccessException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchFieldException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (NoSuchMethodException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
-            } catch (InvocationTargetException e) {
-                ACRA.log.w(ACRA.LOG_TAG, "Error while collecting DisplayManager data: ", e);
+                result.put(String.valueOf(display.getDisplayId()), collectDisplayData(display));
+            } catch (JSONException e) {
+                ACRA.log.w(ACRA.LOG_TAG, "Failed to collect data for display " + display.getDisplayId(), e);
             }
         }
 
-        for (Display display : displays) {
-            result.append(collectDisplayData(display));
-        }
-
-        return result.toString();
+        return result;
     }
 
-    private static Object collectDisplayData(Display display) {
+    @NonNull
+    private JSONObject collectDisplayData(@NonNull Display display) throws JSONException {
         final DisplayMetrics metrics = new DisplayMetrics();
         display.getMetrics(metrics);
 
-        final StringBuilder result = new StringBuilder();
-
-        result.append(collectCurrentSizeRange(display));
-        result.append(collectFlags(display));
-        result.append(display.getDisplayId()).append(".height=").append(display.getHeight()).append('\n');
-        result.append(collectMetrics(display, "getMetrics"));
-        result.append(collectName(display));
-        result.append(display.getDisplayId()).append(".orientation=").append(display.getOrientation()).append('\n');
-        result.append(display.getDisplayId()).append(".pixelFormat=").append(display.getPixelFormat()).append('\n');
-        result.append(collectMetrics(display, "getRealMetrics"));
-        result.append(collectSize(display, "getRealSize"));
-        result.append(collectRectSize(display));
-        result.append(display.getDisplayId()).append(".refreshRate=").append(display.getRefreshRate()).append('\n');
-        result.append(collectRotation(display));
-        result.append(collectSize(display, "getSize"));
-        result.append(display.getDisplayId()).append(".width=").append(display.getWidth()).append('\n');
-        result.append(collectIsValid(display));
-
-        return result.toString();
+        final JSONObject result = new JSONObject();
+        collectCurrentSizeRange(display, result);
+        collectFlags(display, result);
+        collectMetrics(display, result);
+        collectRealMetrics(display, result);
+        collectName(display, result);
+        collectRealSize(display, result);
+        collectRectSize(display, result);
+        collectSize(display, result);
+        collectRotation(display, result);
+        collectIsValid(display, result);
+        result.put("orientation", display.getRotation())
+                .put("refreshRate", display.getRefreshRate());
+        //noinspection deprecation
+        result.put("height", display.getHeight())
+                .put("width", display.getWidth())
+                .put("pixelFormat", display.getPixelFormat());
+        return result;
     }
 
-    private static Object collectIsValid(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method isValid = display.getClass().getMethod("isValid");
-            Boolean value = (Boolean) isValid.invoke(display);
-            result.append(display.getDisplayId()).append(".isValid=").append(value).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+    private static void collectIsValid(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            container.put("isValid", display.isValid());
         }
-        return result.toString();
     }
 
-    private static Object collectRotation(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRotation = display.getClass().getMethod("getRotation");
-            int rotation = (Integer) getRotation.invoke(display);
-            result.append(display.getDisplayId()).append(".rotation=");
-            switch (rotation) {
+    private static void collectRotation(@NonNull Display display, JSONObject container) throws JSONException {
+        container.put("rotation", rotationToString(display.getRotation()));
+    }
+
+    @NonNull
+    private static String rotationToString(int rotation) {
+        switch (rotation) {
             case Surface.ROTATION_0:
-                result.append("ROTATION_0");
-                break;
+                return "ROTATION_0";
             case Surface.ROTATION_90:
-                result.append("ROTATION_90");
-                break;
+                return "ROTATION_90";
             case Surface.ROTATION_180:
-                result.append("ROTATION_180");
-                break;
+                return "ROTATION_180";
             case Surface.ROTATION_270:
-                result.append("ROTATION_270");
-                break;
+                return "ROTATION_270";
             default:
-                result.append(rotation);
-                break;
-            }
-            result.append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+                return String.valueOf(rotation);
         }
-        return result.toString();
     }
 
-    private static Object collectRectSize(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRectSize = display.getClass().getMethod("getRectSize", Rect.class);
-            Rect size = new Rect();
-            getRectSize.invoke(display, size);
-            result.append(display.getDisplayId()).append(".rectSize=[").append(size.top).append(',').append(size.left)
-                    .append(',').append(size.width()).append(',').append(size.height()).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+    private static void collectRectSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final Rect size = new Rect();
+            display.getRectSize(size);
+            container.put("rectSize", new JSONArray(Arrays.asList(size.top, size.left, size.width(), size.height())));
         }
-        return result.toString();
     }
 
-    private static Object collectSize(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getRealSize = display.getClass().getMethod(methodName, Point.class);
-            Point size = new Point();
-            getRealSize.invoke(display, size);
-            result.append(display.getDisplayId()).append('.').append(methodName).append("=[").append(size.x)
-                    .append(',').append(size.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+    private static void collectSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final Point size = new Point();
+            display.getSize(size);
+            container.put("size", new JSONArray(Arrays.asList(size.x, size.y)));
         }
-        return result.toString();
     }
 
-    private static String collectCurrentSizeRange(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getCurrentSizeRange = display.getClass().getMethod("getCurrentSizeRange", Point.class, Point.class);
-            Point smallest = new Point(), largest = new Point();
-            getCurrentSizeRange.invoke(display, smallest, largest);
-            result.append(display.getDisplayId()).append(".currentSizeRange.smallest=[").append(smallest.x).append(',')
-                    .append(smallest.y).append(']').append('\n');
-            result.append(display.getDisplayId()).append(".currentSizeRange.largest=[").append(largest.x).append(',')
-                    .append(largest.y).append(']').append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+    private static void collectRealSize(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final Point size = new Point();
+            display.getRealSize(size);
+            container.put("realSize", new JSONArray(Arrays.asList(size.x, size.y)));
         }
-        return result.toString();
     }
 
-    private static String collectFlags(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getFlags = display.getClass().getMethod("getFlags");
-            int flags = (Integer) getFlags.invoke(display);
+    private static void collectCurrentSizeRange(@NonNull Display display, @NonNull JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            final Point smallest = new Point();
+            final Point largest = new Point();
+            display.getCurrentSizeRange(smallest, largest);
+            JSONObject result = new JSONObject();
+            result.put("smallest", new JSONArray(Arrays.asList(smallest.x, smallest.y)));
+            result.put("largest", new JSONArray(Arrays.asList(largest.x, largest.y)));
+            container.put("currentSizeRange", result);
+        }
+    }
 
+    private void collectFlags(@NonNull Display display, @NonNull JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final int flags = display.getFlags();
             for (Field field : display.getClass().getFields()) {
                 if (field.getName().startsWith("FLAG_")) {
-                    mFlagsNames.put(field.getInt(null), field.getName());
+                    try {
+                        flagNames.put(field.getInt(null), field.getName());
+                    } catch (IllegalAccessException ignored) {
+                    }
                 }
             }
-
-            result.append(display.getDisplayId()).append(".flags=").append(activeFlags(mFlagsNames, flags))
-                    .append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+            container.put("flags", activeFlags(flags));
         }
-        return result.toString();
     }
 
-    private static String collectName(Display display) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getName = display.getClass().getMethod("getName");
-            String name = (String) getName.invoke(display);
-
-            result.append(display.getDisplayId()).append(".name=").append(name).append('\n');
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
+    private static void collectName(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            container.put("name", display.getName());
         }
-        return result.toString();
     }
 
-    private static Object collectMetrics(Display display, String methodName) {
-        StringBuilder result = new StringBuilder();
-        try {
-            Method getMetrics = display.getClass().getMethod(methodName);
-            DisplayMetrics metrics = (DisplayMetrics) getMetrics.invoke(display);
-
-            for (Field field : DisplayMetrics.class.getFields()) {
-                if (field.getType().equals(Integer.class) && field.getName().startsWith("DENSITY_")
-                        && !field.getName().equals("DENSITY_DEFAULT")) {
-                    mDensities.put(field.getInt(null), field.getName());
-                }
-            }
-
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".density=")
-                    .append(metrics.density).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".densityDpi=")
-                    .append(metrics.getClass().getField("densityDpi")).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append("scaledDensity=x")
-                    .append(metrics.scaledDensity).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".widthPixels=")
-                    .append(metrics.widthPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".heightPixels=")
-                    .append(metrics.heightPixels).append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".xdpi=").append(metrics.xdpi)
-                    .append('\n');
-            result.append(display.getDisplayId()).append('.').append(methodName).append(".ydpi=").append(metrics.ydpi)
-                    .append('\n');
+    private static void collectMetrics(@NonNull Display display, JSONObject container) throws JSONException {
+        final DisplayMetrics metrics = new DisplayMetrics();
+        display.getMetrics(metrics);
+        JSONObject result = new JSONObject();
+        collectMetrics(metrics, result);
+        container.put("metrics", result);
+    }
 
-        } catch (SecurityException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        } catch (InvocationTargetException e) {
-        } catch (NoSuchFieldException e) {
+    private static void collectRealMetrics(@NonNull Display display, JSONObject container) throws JSONException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final DisplayMetrics metrics = new DisplayMetrics();
+            display.getRealMetrics(metrics);
+            JSONObject result = new JSONObject();
+            collectMetrics(metrics, result);
+            container.put("realMetrics", result);
         }
-        return result.toString();
+    }
+
+    private static void collectMetrics(@NonNull DisplayMetrics metrics, JSONObject container) throws JSONException {
+        container.put("density", metrics.density)
+                .put("densityDpi", metrics.densityDpi)
+                .put("scaledDensity", "x" + metrics.scaledDensity)
+                .put("widthPixels", metrics.widthPixels)
+                .put("heightPixels", metrics.heightPixels)
+                .put("xdpi", metrics.xdpi)
+                .put("ydpi", metrics.ydpi);
     }
 
     /**
      * Some fields contain multiple value types which can be isolated by
      * applying a bitmask. That method returns the concatenation of active
      * values.
-     * 
-     * @param valueNames
-     *            The array containing the different values and names for this
-     *            field. Must contain mask values too.
-     * @param bitfield
-     *            The bitfield to inspect.
+     *
+     * @param bitfield The bitfield to inspect.
      * @return The names of the different values contained in the bitfield,
-     *         separated by '+'.
+     * separated by '+'.
      */
-    private static String activeFlags(SparseArray<String> valueNames, int bitfield) {
+    @NonNull
+    private String activeFlags(int bitfield) {
         final StringBuilder result = new StringBuilder();
 
         // Look for masks, apply it an retrieve the masked value
-        for (int i = 0; i < valueNames.size(); i++) {
-            final int maskValue = valueNames.keyAt(i);
+        for (int i = 0; i < flagNames.size(); i++) {
+            final int maskValue = flagNames.keyAt(i);
             final int value = bitfield & maskValue;
             if (value > 0) {
                 if (result.length() > 0) {
                     result.append('+');
                 }
-                result.append(valueNames.get(value));
+                result.append(flagNames.get(value));
             }
         }
         return result.toString();
diff --git a/src/main/java/org/acra/collector/DropBoxCollector.java b/src/main/java/org/acra/collector/DropBoxCollector.java
index 4bf146bd..2c3f6b83 100644
--- a/src/main/java/org/acra/collector/DropBoxCollector.java
+++ b/src/main/java/org/acra/collector/DropBoxCollector.java
@@ -15,121 +15,124 @@
  */
 package org.acra.collector;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+import android.Manifest;
+import android.content.Context;
+import android.os.Build;
+import android.os.DropBoxManager;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.acra.util.PackageManagerWrapper;
+
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Calendar;
 import java.util.List;
+import java.util.Locale;
+import java.util.Set;
 
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.text.format.Time;
-import android.util.Log;
+import static org.acra.ACRA.LOG_TAG;
 
 /**
- * Collects data from the DropBoxManager introduced with Android API Level 8. A
+ * Collects data from the {@link DropBoxManager}. A
  * set of DropBox tags have been identified in the Android source code. , we
  * collect data associated to these tags with hope that some of them could help
  * debugging applications. Application specific tags can be provided by the app
  * dev to track his own usage of the DropBoxManager.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-final class DropBoxCollector {
+final class DropBoxCollector extends Collector {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final PackageManagerWrapper pm;
 
-    private static final String[] SYSTEM_TAGS = { "system_app_anr", "system_app_wtf", "system_app_crash",
+    DropBoxCollector(Context context, ACRAConfiguration config, PackageManagerWrapper pm){
+        super(ReportField.DROPBOX);
+        this.context = context;
+        this.config = config;
+        this.pm = pm;
+    }
+
+    private static final String[] SYSTEM_TAGS = {"system_app_anr", "system_app_wtf", "system_app_crash",
             "system_server_anr", "system_server_wtf", "system_server_crash", "BATTERY_DISCHARGE_INFO",
             "SYSTEM_RECOVERY_LOG", "SYSTEM_BOOT", "SYSTEM_LAST_KMSG", "APANIC_CONSOLE", "APANIC_THREADS",
-            "SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode" };
+            "SYSTEM_RESTART", "SYSTEM_TOMBSTONE", "data_app_strictmode"};
 
-    private static final String NO_RESULT = "N/A";
+    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd'T'HHmmss", Locale.getDefault()); //iCal format (used for backwards compatibility)
 
     /**
      * Read latest messages contained in the DropBox for system related tags and
      * optional developer-set tags.
-     * 
-     * @param context
-     *            The application context.
-     * @param additionalTags
-     *            An array of tags provided by the application developer.
-     * @return A readable formatted String listing messages retrieved.
+     *
+     * @return An Element listing messages retrieved.
      */
-    public static String read(Context context, String[] additionalTags) {
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
         try {
-            // Use reflection API to allow compilation with API Level 5.
-            final String serviceName = Compatibility.getDropBoxServiceName();
-            if (serviceName == null) {
-                return NO_RESULT;
-            }
-
-            final Object dropbox = context.getSystemService(serviceName);
-            final Method getNextEntry = dropbox.getClass().getMethod("getNextEntry", String.class, long.class);
-            if (getNextEntry == null) {
-                return "";
-            }
+            final DropBoxManager dropbox = (DropBoxManager) context.getSystemService(Context.DROPBOX_SERVICE);
 
-            final Time timer = new Time();
-            timer.setToNow();
-            timer.minute -= ACRA.getConfig().dropboxCollectionMinutes();
-            timer.normalize(false);
-            final long time = timer.toMillis(false);
+            final Calendar calendar = Calendar.getInstance();
+            calendar.roll(Calendar.MINUTE, -config.dropboxCollectionMinutes());
+            final long time = calendar.getTimeInMillis();
+            dateFormat.format(calendar.getTime());
 
             final List<String> tags = new ArrayList<String>();
-            if (ACRA.getConfig().includeDropBoxSystemTags()) {
+            if (config.includeDropBoxSystemTags()) {
                 tags.addAll(Arrays.asList(SYSTEM_TAGS));
             }
-            if (additionalTags != null && additionalTags.length > 0) {
-                tags.addAll(Arrays.asList(additionalTags));
+            final Set<String> additionalTags = config.additionalDropBoxTags();
+            if (!additionalTags.isEmpty()) {
+                tags.addAll(additionalTags);
             }
 
             if (tags.isEmpty()) {
-                return "No tag configured for collection.";
+                return ACRAConstants.NOT_AVAILABLE;
             }
 
-            final StringBuilder dropboxContent = new StringBuilder();
+            final ComplexElement dropboxContent = new ComplexElement();
             for (String tag : tags) {
-                dropboxContent.append("Tag: ").append(tag).append('\n');
-                Object entry = getNextEntry.invoke(dropbox, tag, time);
+                final StringBuilder builder = new StringBuilder();
+                DropBoxManager.Entry entry = dropbox.getNextEntry(tag, time);
                 if (entry == null) {
-                    dropboxContent.append("Nothing.").append('\n');
+                    builder.append("Nothing.").append('\n');
                     continue;
                 }
-
-                final Method getText = entry.getClass().getMethod("getText", int.class);
-                final Method getTimeMillis = entry.getClass().getMethod("getTimeMillis", (Class[]) null);
-                final Method close = entry.getClass().getMethod("close", (Class[]) null);
                 while (entry != null) {
-                    final long msec = (Long) getTimeMillis.invoke(entry, (Object[]) null);
-                    timer.set(msec);
-                    dropboxContent.append("@").append(timer.format2445()).append('\n');
-                    final String text = (String) getText.invoke(entry, 500);
+                    final long msec = entry.getTimeMillis();
+                    calendar.setTimeInMillis(msec);
+                    builder.append('@').append(dateFormat.format(calendar.getTime())).append('\n');
+                    final String text = entry.getText(500);
                     if (text != null) {
-                        dropboxContent.append("Text: ").append(text).append('\n');
+                        builder.append("Text: ").append(text).append('\n');
                     } else {
-                        dropboxContent.append("Not Text!").append('\n');
+                        builder.append("Not Text!").append('\n');
                     }
-                    close.invoke(entry, (Object[]) null);
-                    entry = getNextEntry.invoke(dropbox, tag, msec);
+                    entry.close();
+                    entry = dropbox.getNextEntry(tag, msec);
                 }
+                dropboxContent.put(tag, builder.toString());
             }
-            return dropboxContent.toString();
-
-        } catch (SecurityException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchMethodException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalArgumentException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
-        } catch (IllegalAccessException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
-        } catch (InvocationTargetException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
-        } catch (NoSuchFieldException e) {
-            Log.i(ACRA.LOG_TAG, "DropBoxManager not available.");
+            return dropboxContent;
+
+        } catch (Exception e) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "DropBoxManager not available.");
         }
 
-        return NO_RESULT;
+        return ACRAConstants.NOT_AVAILABLE;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && (pm.hasPermission(Manifest.permission.READ_LOGS) || Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN);
     }
 }
diff --git a/src/main/java/org/acra/collector/DumpSysCollector.java b/src/main/java/org/acra/collector/DumpSysCollector.java
deleted file mode 100644
index 774dd4ab..00000000
--- a/src/main/java/org/acra/collector/DumpSysCollector.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.collector;
-
-import android.util.Log;
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Collects results of the <code>dumpsys</code> command.
- * 
- * @author Kevin Gaudin
- * 
- */
-final class DumpSysCollector {
-
-    /**
-     * Collect results of the <code>dumpsys meminfo</code> command restricted to
-     * this application process.
-     * 
-     * @return The execution result.
-     */
-    public static String collectMemInfo() {
-
-        final StringBuilder meminfo = new StringBuilder();
-		BufferedReader bufferedReader = null;
-        try {
-            final List<String> commandLine = new ArrayList<String>();
-            commandLine.add("dumpsys");
-            commandLine.add("meminfo");
-            commandLine.add(Integer.toString(android.os.Process.myPid()));
-
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                meminfo.append(line);
-                meminfo.append("\n");
-            }
-
-        } catch (IOException e) {
-            Log.e(ACRA.LOG_TAG, "DumpSysCollector.meminfo could not retrieve data", e);
-		}
-
-        CollectorUtil.safeClose(bufferedReader);
-
-        return meminfo.toString();
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/LogCatCollector.java b/src/main/java/org/acra/collector/LogCatCollector.java
index 325e5ebe..99cc522e 100644
--- a/src/main/java/org/acra/collector/LogCatCollector.java
+++ b/src/main/java/org/acra/collector/LogCatCollector.java
@@ -15,57 +15,64 @@
  */
 package org.acra.collector;
 
-import static org.acra.ACRA.LOG_TAG;
+import android.Manifest;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.android.internal.util.Predicate;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+import org.acra.util.PackageManagerWrapper;
 
-import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedList;
 import java.util.List;
+import java.util.Set;
 
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-import org.acra.annotation.ReportsCrashes;
-import org.acra.util.BoundedLinkedList;
+import static org.acra.ACRA.LOG_TAG;
 
-import android.util.Log;
 
 /**
  * Executes logcat commands and collects it's output.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-class LogCatCollector {
+final class LogCatCollector extends Collector {
 
-    /**
-     * Default number of latest lines kept from the logcat output.
-     */
-    private static final int DEFAULT_TAIL_COUNT = 100;
+    private final ACRAConfiguration config;
+    private final PackageManagerWrapper pm;
+
+    LogCatCollector(ACRAConfiguration config, PackageManagerWrapper pm) {
+        super(ReportField.LOGCAT, ReportField.EVENTSLOG, ReportField.RADIOLOG);
+        this.config = config;
+        this.pm = pm;
+    }
 
     /**
      * Executes the logcat command with arguments taken from
      * {@link ReportsCrashes#logcatArguments()}
-     * 
-     * @param bufferName
-     *            The name of the buffer to be read: "main" (default), "radio"
-     *            or "events".
+     *
+     * @param bufferName The name of the buffer to be read: "main" (default), "radio" or "events".
      * @return A {@link String} containing the latest lines of the output.
-     *         Default is 100 lines, use "-t", "300" in
-     *         {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
-     *         You should be aware that increasing this value causes a longer
-     *         report generation time and a bigger footprint on the device data
-     *         plan consumption.
+     * Default is 100 lines, use "-t", "300" in
+     * {@link ReportsCrashes#logcatArguments()} if you want 300 lines.
+     * You should be aware that increasing this value causes a longer
+     * report generation time and a bigger footprint on the device data
+     * plan consumption.
      */
-    public static String collectLogCat(String bufferName) {
+    private Element collectLogCat(@Nullable String bufferName) {
         final int myPid = android.os.Process.myPid();
-        String myPidStr = null;
-        if (ACRA.getConfig().logcatFilterByPid() && myPid > 0) {
-            myPidStr = Integer.toString(myPid) +"):";
-        }
+        final String myPidStr = config.logcatFilterByPid() && myPid > 0 ? Integer.toString(myPid) + "):" : null;
 
         final List<String> commandLine = new ArrayList<String>();
         commandLine.add("logcat");
@@ -74,65 +81,81 @@ public static String collectLogCat(String bufferName) {
             commandLine.add(bufferName);
         }
 
-        // "-t n" argument has been introduced in FroYo (API level 8). For
-        // devices with lower API level, we will have to emulate its job.
         final int tailCount;
-        final List<String> logcatArgumentsList = new ArrayList<String>(
-                Arrays.asList(ACRA.getConfig().logcatArguments()));
+        final List<String> logcatArgumentsList = config.logcatArguments();
 
         final int tailIndex = logcatArgumentsList.indexOf("-t");
         if (tailIndex > -1 && tailIndex < logcatArgumentsList.size()) {
             tailCount = Integer.parseInt(logcatArgumentsList.get(tailIndex + 1));
-            if (Compatibility.getAPILevel() < 8) {
-                logcatArgumentsList.remove(tailIndex + 1);
-                logcatArgumentsList.remove(tailIndex);
-                logcatArgumentsList.add("-d");
-            }
         } else {
             tailCount = -1;
         }
 
-        final LinkedList<String> logcatBuf = new BoundedLinkedList<String>(tailCount > 0 ? tailCount
-                : DEFAULT_TAIL_COUNT);
+        Element logcat;
         commandLine.addAll(logcatArgumentsList);
-        
-        BufferedReader bufferedReader = null;
 
         try {
-            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
-            bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
-
-            Log.d(LOG_TAG, "Retrieving logcat output...");
-
-            // Dump stderr to null
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        InputStream stderr = process.getErrorStream();
-                        byte[] dummy = new byte[ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES];
-                        while (stderr.read(dummy) >= 0)
-                            ;
-                    } catch (IOException e) {
-                    }
-                }
-            }).start();
+            final Process process =  new ProcessBuilder().command(commandLine).redirectErrorStream(true).start();
 
-            while (true) {
-                final String line = bufferedReader.readLine();
-                if (line == null) {
-                    break;
-                }
-                if (myPidStr == null || line.contains(myPidStr)) {
-                    logcatBuf.add(line + "\n");
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Retrieving logcat output...");
+
+            logcat = new StringElement(streamToString(process.getInputStream(), new Predicate<String>() {
+                @Override
+                public boolean apply(String s) {
+                    return myPidStr == null || s.contains(myPidStr);
                 }
-            }
+            }, tailCount));
+            process.destroy();
 
         } catch (IOException e) {
-            Log.e(ACRA.LOG_TAG, "LogCatCollector.collectLogCat could not retrieve data.", e);
-        } finally {
-            CollectorUtil.safeClose(bufferedReader);
+            ACRA.log.e(LOG_TAG, "LogCatCollector.collectLogCat could not retrieve data.", e);
+            logcat = ACRAConstants.NOT_AVAILABLE;
         }
 
-        return logcatBuf.toString();
+        return logcat;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder)
+                && (pm.hasPermission(Manifest.permission.READ_LOGS)
+                || Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        String bufferName = null;
+        switch (reportField) {
+            case LOGCAT:
+                bufferName = null;
+                break;
+            case EVENTSLOG:
+                bufferName = "events";
+                break;
+            case RADIOLOG:
+                bufferName = "radio";
+                break;
+        }
+        return collectLogCat(bufferName);
+    }
+
+    /**
+     * Reads an InputStream into a string in an non blocking way for current thread
+     * It has a default timeout of 3 seconds.
+     *
+     * @param input  the stream
+     * @param filter should return false for lines which should be excluded
+     * @param limit  the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the stream cannot be read.
+     */
+    @NonNull
+    private String streamToString(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        if (config.nonBlockingReadForLogcat()) {
+            return IOUtils.streamToStringNonBlockingRead(input, filter, limit);
+        } else {
+            return IOUtils.streamToString(input, filter, limit);
+        }
     }
 }
diff --git a/src/main/java/org/acra/collector/LogFileCollector.java b/src/main/java/org/acra/collector/LogFileCollector.java
index c3311365..322e588a 100644
--- a/src/main/java/org/acra/collector/LogFileCollector.java
+++ b/src/main/java/org/acra/collector/LogFileCollector.java
@@ -16,59 +16,117 @@
 
 package org.acra.collector;
 
-import java.io.BufferedReader;
+import android.app.Application;
+import android.content.Context;
+import android.os.Environment;
+import android.support.annotation.NonNull;
+import android.support.v4.content.ContextCompat;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.Directory;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.InputStream;
 
-import org.acra.util.BoundedLinkedList;
-
-import android.app.Application;
-import android.content.Context;
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * Collects the N last lines of a text stream. Use this collector if your
  * application handles its own logging system.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-class LogFileCollector {
+final class LogFileCollector extends Collector {
+    private final Context context;
+    private final ACRAConfiguration config;
 
-    /**
-     * Private constructor to prevent instantiation.
-     */
-    private LogFileCollector() {
-    };
+    LogFileCollector(Context context, ACRAConfiguration config) {
+        super(ReportField.APPLICATION_LOG);
+        this.context = context;
+        this.config = config;
+    }
 
     /**
      * Reads the last lines of a custom log file. The file name is assumed as
      * located in the {@link Application#getFilesDir()} directory if it does not
      * contain any path separator.
-     * 
-     * @param context
-     * @param fileName
-     * @param numberOfLines
-     * @return
-     * @throws IOException
+     *
+     * @return An Element containing all of the requested lines.
      */
-    public static String collectLogFile(Context context, String fileName, int numberOfLines) throws IOException {
-        final BoundedLinkedList<String> resultBuffer = new BoundedLinkedList<String>(numberOfLines);
-        final BufferedReader reader;
-        if (fileName.contains("/")) {
-            reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)), 1024);
-        } else {
-            reader = new BufferedReader(new InputStreamReader(context.openFileInput(fileName)), 1024);
-        }
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
         try {
-            String line = reader.readLine();
-            while (line != null) {
-                resultBuffer.add(line + "\n");
-                line = reader.readLine();
+            return new StringElement(IOUtils.streamToString(
+                    getStream(config.applicationLogFileDir(), config.applicationLogFile()),
+                    config.applicationLogFileLines()));
+        } catch (IOException e) {
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    /**
+     * get the application log file location and open it
+     *
+     * @param directory the base directory for the file path
+     * @param fileName the name of the file
+     * @return a stream to the file or an empty stream if the file was not found
+     */
+    @NonNull
+    private InputStream getStream(@NonNull Directory directory, @NonNull String fileName) {
+        if (directory == Directory.FILES_LEGACY) {
+            directory = fileName.startsWith("/") ? Directory.ROOT : Directory.FILES;
+        }
+        final File dir;
+        switch (directory) {
+            case FILES:
+                dir = context.getFilesDir();
+                break;
+            case EXTERNAL_FILES:
+                dir = context.getExternalFilesDir(null);
+                break;
+            case CACHE:
+                dir = context.getCacheDir();
+                break;
+            case EXTERNAL_CACHE:
+                dir = context.getExternalCacheDir();
+                break;
+            case NO_BACKUP_FILES:
+                dir = ContextCompat.getNoBackupFilesDir(context);
+                break;
+            case EXTERNAL_STORAGE:
+                dir = Environment.getExternalStorageDirectory();
+                break;
+            case ROOT:
+            default:
+                dir = new File("/");
+                break;
+        }
+        final File file = new File(dir, fileName);
+        if (!file.exists()) {
+            if (ACRA.DEV_LOGGING)
+                ACRA.log.d(LOG_TAG, "Log file '" + file.getPath() + "' does not exist");
+        } else if (file.isDirectory()) {
+            ACRA.log.e(LOG_TAG, "Log file '" + file.getPath() + "' is a directory");
+        } else if (!file.canRead()) {
+            ACRA.log.e(LOG_TAG, "Log file '" + file.getPath() + "' can't be read");
+        } else {
+            try {
+                return new FileInputStream(file);
+            } catch (IOException e) {
+                ACRA.log.e(LOG_TAG, "Could not open stream for log file '" + file.getPath() + "'");
             }
-        } finally {
-            CollectorUtil.safeClose(reader);
         }
-        return resultBuffer.toString();
+        return new ByteArrayInputStream(new byte[0]);
     }
 }
diff --git a/src/main/java/org/acra/collector/MediaCodecListCollector.java b/src/main/java/org/acra/collector/MediaCodecListCollector.java
index 4ca24819..1039687c 100644
--- a/src/main/java/org/acra/collector/MediaCodecListCollector.java
+++ b/src/main/java/org/acra/collector/MediaCodecListCollector.java
@@ -16,68 +16,83 @@
 
 package org.acra.collector;
 
+import android.annotation.TargetApi;
+import android.media.MediaCodecInfo;
+import android.media.MediaCodecList;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.SparseArray;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.Arrays;
-
-import android.util.SparseArray;
+import java.util.Set;
 
 /**
  * Collects data about available codecs on the device through the MediaCodecList
  * API introduced in Android 4.1 JellyBean.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-public class MediaCodecListCollector {
+final class MediaCodecListCollector extends Collector {
+
     private enum CodecType {
         AVC, H263, MPEG4, AAC
 
     }
 
     private static final String COLOR_FORMAT_PREFIX = "COLOR_";
-    private static final String[] MPEG4_TYPES = { "mp4", "mpeg4", "MP4", "MPEG4" };
-    private static final String[] AVC_TYPES = { "avc", "h264", "AVC", "H264" };
-    private static final String[] H263_TYPES = { "h263", "H263" };
-    private static final String[] AAC_TYPES = { "aac", "AAC" };
+    private static final String[] MPEG4_TYPES = {"mp4", "mpeg4", "MP4", "MPEG4"};
+    private static final String[] AVC_TYPES = {"avc", "h264", "AVC", "H264"};
+    private static final String[] H263_TYPES = {"h263", "H263"};
+    private static final String[] AAC_TYPES = {"aac", "AAC"};
 
-    private static Class<?> mediaCodecListClass = null;
-    private static Method getCodecInfoAtMethod = null;
-    private static Class<?> mediaCodecInfoClass = null;
-    private static Method getNameMethod = null;
-    private static Method isEncoderMethod = null;
-    private static Method getSupportedTypesMethod = null;
-    private static Method getCapabilitiesForTypeMethod = null;
-    private static Class<?> codecCapabilitiesClass = null;
-    private static Field colorFormatsField = null;
-    private static Field profileLevelsField = null;
-    private static Field profileField = null;
-    private static Field levelField = null;
-    private static SparseArray<String> mColorFormatValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCLevelValues = new SparseArray<String>();
-    private static SparseArray<String> mAVCProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mH263LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mH263ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
-    private static SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
-    private static SparseArray<String> mAACProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mColorFormatValues = new SparseArray<String>();
+    private final SparseArray<String> mAVCLevelValues = new SparseArray<String>();
+    private final SparseArray<String> mAVCProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mH263LevelValues = new SparseArray<String>();
+    private final SparseArray<String> mH263ProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mMPEG4LevelValues = new SparseArray<String>();
+    private final SparseArray<String> mMPEG4ProfileValues = new SparseArray<String>();
+    private final SparseArray<String> mAACProfileValues = new SparseArray<String>();
 
-    // static init where nearly all reflection inspection is done.
-    static {
+    MediaCodecListCollector() {
+        super(ReportField.MEDIA_CODEC_LIST);
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
         try {
-            mediaCodecListClass = Class.forName("android.media.MediaCodecList");
-            // Get methods to retrieve media codec info
-            getCodecInfoAtMethod = mediaCodecListClass.getMethod("getCodecInfoAt", int.class);
-            mediaCodecInfoClass = Class.forName("android.media.MediaCodecInfo");
-            getNameMethod = mediaCodecInfoClass.getMethod("getName");
-            isEncoderMethod = mediaCodecInfoClass.getMethod("isEncoder");
-            getSupportedTypesMethod = mediaCodecInfoClass.getMethod("getSupportedTypes");
-            getCapabilitiesForTypeMethod = mediaCodecInfoClass.getMethod("getCapabilitiesForType", String.class);
-            codecCapabilitiesClass = Class.forName("android.media.MediaCodecInfo$CodecCapabilities");
-            colorFormatsField = codecCapabilitiesClass.getField("colorFormats");
-            profileLevelsField = codecCapabilitiesClass.getField("profileLevels");
+            return collectMediaCodecList();
+        } catch (JSONException e) {
+            ACRA.log.w("Could not collect media codecs", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;
+    }
+
+    /**
+     * use reflection to prepare field arrays.
+     */
+    private void prepare() {
+        try {
+            final Class<?> codecCapabilitiesClass = Class.forName("android.media.MediaCodecInfo$CodecCapabilities");
 
             // Retrieve list of possible Color Format
             for (Field f : codecCapabilitiesClass.getFields()) {
@@ -88,7 +103,7 @@
             }
 
             // Retrieve lists of possible codecs profiles and levels
-            Class<?> codecProfileLevelClass = Class.forName("android.media.MediaCodecInfo$CodecProfileLevel");
+            final Class<?> codecProfileLevelClass = Class.forName("android.media.MediaCodecInfo$CodecProfileLevel");
             for (Field f : codecProfileLevelClass.getFields()) {
                 if (Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers())) {
                     if (f.getName().startsWith("AVCLevel")) {
@@ -108,153 +123,136 @@
                     }
                 }
             }
-
-            profileField = codecProfileLevelClass.getField("profile");
-            levelField = codecProfileLevelClass.getField("level");
-
-        } catch (ClassNotFoundException e) {
+        } catch (@NonNull ClassNotFoundException ignored) {
             // NOOP
-        } catch (NoSuchMethodException e) {
+        } catch (@NonNull SecurityException ignored) {
             // NOOP
-        } catch (IllegalArgumentException e) {
+        } catch (@NonNull IllegalAccessException ignored) {
             // NOOP
-        } catch (IllegalAccessException e) {
-            // NOOP
-        } catch (SecurityException e) {
-            // NOOP
-        } catch (NoSuchFieldException e) {
+        } catch (@NonNull IllegalArgumentException ignored) {
             // NOOP
         }
 
     }
 
     /**
-     * Builds a String describing the list of available codecs on the device
+     * Builds an Element describing the list of available codecs on the device
      * with their capabilities (supported Color Formats, Codec Profiles et
      * Levels).
-     * 
+     *
      * @return The media codecs information
      */
-    public static String collecMediaCodecList() {
-        StringBuilder result = new StringBuilder();
-        if (mediaCodecListClass != null && mediaCodecInfoClass != null) {
-            try {
-                // Retrieve list of available media codecs
-                int codecCount = (Integer) (mediaCodecListClass.getMethod("getCodecCount").invoke(null));
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    @NonNull
+    private Element collectMediaCodecList() throws JSONException {
+        prepare();
+        final MediaCodecInfo[] infos;
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            //noinspection deprecation
+            final int codecCount = MediaCodecList.getCodecCount();
+            infos = new MediaCodecInfo[codecCount];
+            for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
+                //noinspection deprecation
+                infos[codecIdx] = MediaCodecList.getCodecInfoAt(codecIdx);
+            }
+        } else {
+            infos = new MediaCodecList(MediaCodecList.ALL_CODECS).getCodecInfos();
+        }
 
-                // Go through each available media codec
-                Object codecInfo = null;
-                for (int codecIdx = 0; codecIdx < codecCount; codecIdx++) {
-                    result.append("\n");
-                    codecInfo = getCodecInfoAtMethod.invoke(null, codecIdx);
-                    result.append(codecIdx).append(": ").append(getNameMethod.invoke(codecInfo)).append("\n");
-                    result.append("isEncoder: ").append(isEncoderMethod.invoke(codecInfo)).append("\n");
-                    String[] supportedTypes = (String[]) getSupportedTypesMethod.invoke(codecInfo);
-                    result.append("Supported types: ").append(Arrays.toString(supportedTypes)).append("\n");
-                    for (String type : supportedTypes) {
-                        result.append(collectCapabilitiesForType(codecInfo, type));
-                    }
-                    result.append("\n");
-                }
-            } catch (NoSuchMethodException e) {
-                // NOOP
-            } catch (IllegalAccessException e) {
-                // NOOP
-            } catch (InvocationTargetException e) {
-                // NOOP
+        final ComplexElement result = new ComplexElement();
+        for (int i = 0; i < infos.length; i++) {
+            final MediaCodecInfo codecInfo = infos[i];
+            JSONObject codec = new JSONObject();
+            final String[] supportedTypes = codecInfo.getSupportedTypes();
+            codec.put("name", codecInfo.getName())
+                    .put("isEncoder", codecInfo.isEncoder());
+            JSONObject supportedTypesJson = new JSONObject();
+            for (String type : supportedTypes) {
+                supportedTypesJson.put(type, collectCapabilitiesForType(codecInfo, type));
             }
+            codec.put("supportedTypes", supportedTypesJson);
+            result.put(String.valueOf(i), codec);
         }
-        return result.toString();
+        return result;
     }
 
     /**
      * Retrieve capabilities (ColorFormats and CodecProfileLevels) for a
      * specific codec type.
-     * 
-     * @param codecInfo
-     * @param type
-     * @return A string describing the color formats and codec profile levels
-     *         available for a specific codec type.
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
+     *
+     * @param codecInfo the currently inspected codec
+     * @param type      supported type to collect
+     * @return the color formats and codec profile levels
+     * available for a specific codec type.
      */
-    private static String collectCapabilitiesForType(Object codecInfo, String type) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
-        StringBuilder result = new StringBuilder();
-
-        Object codecCapabilities = getCapabilitiesForTypeMethod.invoke(codecInfo, type);
+    @NonNull
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private JSONObject collectCapabilitiesForType(@NonNull final MediaCodecInfo codecInfo, @NonNull String type) throws JSONException {
+        final JSONObject result = new JSONObject();
+        final MediaCodecInfo.CodecCapabilities codecCapabilities = codecInfo.getCapabilitiesForType(type);
 
         // Color Formats
-        int[] colorFormats = (int[]) colorFormatsField.get(codecCapabilities);
+        final int[] colorFormats = codecCapabilities.colorFormats;
         if (colorFormats.length > 0) {
-            result.append(type).append(" color formats:");
-            for (int i = 0; i < colorFormats.length; i++) {
-                result.append(mColorFormatValues.get(colorFormats[i]));
-                if (i < colorFormats.length - 1) {
-                    result.append(',');
-                }
+            JSONArray colorFormatsJson = new JSONArray();
+            for (int colorFormat : colorFormats) {
+                colorFormatsJson.put(mColorFormatValues.get(colorFormat));
             }
-            result.append("\n");
+            result.put("colorFormats", colorFormatsJson);
         }
 
+        final CodecType codecType = identifyCodecType(codecInfo);
+
         // Profile Levels
-        Object[] codecProfileLevels = (Object[]) profileLevelsField.get(codecCapabilities);
+        final MediaCodecInfo.CodecProfileLevel[] codecProfileLevels = codecCapabilities.profileLevels;
         if (codecProfileLevels.length > 0) {
-            result.append(type).append(" profile levels:");
-            for (int i = 0; i < codecProfileLevels.length; i++) {
-
-                CodecType codecType = identifyCodecType(codecInfo);
-                int profileValue = profileField.getInt(codecProfileLevels[i]);
-                int levelValue = levelField.getInt(codecProfileLevels[i]);
+            JSONArray profileLevels = new JSONArray();
+            for (MediaCodecInfo.CodecProfileLevel codecProfileLevel : codecProfileLevels) {
+                final int profileValue = codecProfileLevel.profile;
+                final int levelValue = codecProfileLevel.level;
 
                 if (codecType == null) {
                     // Unknown codec
-                    result.append(profileValue).append('-').append(levelValue);
-                }
-
-                switch (codecType) {
-                case AVC:
-                    result.append(profileValue).append(mAVCProfileValues.get(profileValue)).append('-')
-                            .append(mAVCLevelValues.get(levelValue));
-                    break;
-                case H263:
-                    result.append(mH263ProfileValues.get(profileValue)).append('-')
-                            .append(mH263LevelValues.get(levelValue));
-                    break;
-                case MPEG4:
-                    result.append(mMPEG4ProfileValues.get(profileValue)).append('-')
-                            .append(mMPEG4LevelValues.get(levelValue));
-                    break;
-                case AAC:
-                    result.append(mAACProfileValues.get(profileValue));
-                    break;
-                default:
+                    profileLevels.put(profileValue + '-' + levelValue);
                     break;
                 }
 
-                if (i < codecProfileLevels.length - 1) {
-                    result.append(',');
+                switch (codecType) {
+                    case AVC:
+                        profileLevels.put(profileValue + mAVCProfileValues.get(profileValue)
+                                + '-' + mAVCLevelValues.get(levelValue));
+                        break;
+                    case H263:
+                        profileLevels.put(mH263ProfileValues.get(profileValue)
+                                + '-' + mH263LevelValues.get(levelValue));
+                        break;
+                    case MPEG4:
+                        profileLevels.put(mMPEG4ProfileValues.get(profileValue)
+                                + '-' + mMPEG4LevelValues.get(levelValue));
+                        break;
+                    case AAC:
+                        profileLevels.put(mAACProfileValues.get(profileValue));
+                        break;
+                    default:
+                        break;
                 }
-
             }
-            result.append("\n");
+            result.put("profileLevels", profileLevels);
         }
-        return result.append("\n").toString();
+        return result;
     }
 
     /**
      * Looks for keywords in the codec name to identify its nature ({@link CodecType}).
-     * @param codecInfo
-     * @return
-     * @throws IllegalArgumentException
-     * @throws IllegalAccessException
-     * @throws InvocationTargetException
+     *
+     * @param codecInfo the currently inspected codec
+     * @return type of the codec or null if it could bot be guessed
      */
-    private static CodecType identifyCodecType(Object codecInfo) throws IllegalArgumentException,
-            IllegalAccessException, InvocationTargetException {
+    @Nullable
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private CodecType identifyCodecType(@NonNull MediaCodecInfo codecInfo) {
 
-        String name = (String) getNameMethod.invoke(codecInfo);
+        final String name = codecInfo.getName();
         for (String token : AVC_TYPES) {
             if (name.contains(token)) {
                 return CodecType.AVC;
diff --git a/src/main/java/org/acra/collector/MemoryInfoCollector.java b/src/main/java/org/acra/collector/MemoryInfoCollector.java
new file mode 100644
index 00000000..9e328151
--- /dev/null
+++ b/src/main/java/org/acra/collector/MemoryInfoCollector.java
@@ -0,0 +1,140 @@
+/*
+ *  Copyright 2010 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.os.Build;
+import android.os.Environment;
+import android.os.StatFs;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects results of the <code>dumpsys</code> command.
+ *
+ * @author Kevin Gaudin & F43nd1r
+ */
+final class MemoryInfoCollector extends Collector {
+    MemoryInfoCollector() {
+        super(ReportField.DUMPSYS_MEMINFO, ReportField.TOTAL_MEM_SIZE, ReportField.AVAILABLE_MEM_SIZE);
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return super.shouldCollect(crashReportFields, collect, reportBuilder) && !(reportBuilder.getException() instanceof OutOfMemoryError);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case DUMPSYS_MEMINFO:
+                return collectMemInfo();
+            case TOTAL_MEM_SIZE:
+                return new NumberElement(getTotalInternalMemorySize());
+            case AVAILABLE_MEM_SIZE:
+                return new NumberElement(getAvailableInternalMemorySize());
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Collect results of the <code>dumpsys meminfo</code> command restricted to
+     * this application process.
+     *
+     * @return The execution result.
+     */
+    @NonNull
+    private static Element collectMemInfo() {
+
+        try {
+            final List<String> commandLine = new ArrayList<String>();
+            commandLine.add("dumpsys");
+            commandLine.add("meminfo");
+            commandLine.add(Integer.toString(android.os.Process.myPid()));
+
+            final Process process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()]));
+            return new StringElement(IOUtils.streamToString(process.getInputStream()));
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "MemoryInfoCollector.meminfo could not retrieve data", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
+
+    /**
+     * Calculates the free memory of the device. This is based on an inspection of the filesystem, which in android
+     * devices is stored in RAM.
+     *
+     * @return Number of bytes available.
+     */
+    private static long getAvailableInternalMemorySize() {
+        final File path = Environment.getDataDirectory();
+        final StatFs stat = new StatFs(path.getPath());
+        final long blockSize;
+        final long availableBlocks;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            blockSize = stat.getBlockSizeLong();
+            availableBlocks = stat.getAvailableBlocksLong();
+        } else {
+            //noinspection deprecation
+            blockSize = stat.getBlockSize();
+            //noinspection deprecation
+            availableBlocks = stat.getAvailableBlocks();
+        }
+        return availableBlocks * blockSize;
+    }
+
+    /**
+     * Calculates the total memory of the device. This is based on an inspection of the filesystem, which in android
+     * devices is stored in RAM.
+     *
+     * @return Total number of bytes.
+     */
+    private static long getTotalInternalMemorySize() {
+        final File path = Environment.getDataDirectory();
+        final StatFs stat = new StatFs(path.getPath());
+        final long blockSize;
+        final long totalBlocks;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            blockSize = stat.getBlockSizeLong();
+            totalBlocks = stat.getBlockCountLong();
+        } else {
+            //noinspection deprecation
+            blockSize = stat.getBlockSize();
+            //noinspection deprecation
+            totalBlocks = stat.getBlockCount();
+        }
+        return totalBlocks * blockSize;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/acra/collector/PackageManagerCollector.java b/src/main/java/org/acra/collector/PackageManagerCollector.java
new file mode 100644
index 00000000..2abee1e5
--- /dev/null
+++ b/src/main/java/org/acra/collector/PackageManagerCollector.java
@@ -0,0 +1,57 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.pm.PackageInfo;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.PackageManagerWrapper;
+
+/**
+ * Collects PackageInfo values
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class PackageManagerCollector extends Collector {
+    private final PackageManagerWrapper pm;
+
+    PackageManagerCollector(PackageManagerWrapper pm) {
+        super(ReportField.APP_VERSION_NAME, ReportField.APP_VERSION_CODE);
+        this.pm = pm;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        PackageInfo info = pm.getPackageInfo();
+        if (info != null) {
+            switch (reportField) {
+                case APP_VERSION_NAME:
+                    return new StringElement(info.versionName);
+                case APP_VERSION_CODE:
+                    return new NumberElement(info.versionCode);
+            }
+        }
+        return ACRAConstants.NOT_AVAILABLE;
+    }
+}
diff --git a/src/main/java/org/acra/collector/ReflectionCollector.java b/src/main/java/org/acra/collector/ReflectionCollector.java
index ebde1088..8316ff5d 100644
--- a/src/main/java/org/acra/collector/ReflectionCollector.java
+++ b/src/main/java/org/acra/collector/ReflectionCollector.java
@@ -16,86 +16,149 @@
 
 package org.acra.collector;
 
+import android.content.Context;
+import android.os.Build;
+import android.os.Environment;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.Arrays;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
- * Tools to retrieve key/value pairs from static fields and getters of any
- * class. Reflection API usage allows to retrieve data without having to
+ * Collector retrieving key/value pairs from static fields and getters.
+ * Reflection API usage allows to retrieve data without having to
  * implement a class for each android version of each interesting class.
  * It can also help find hidden properties.
- * 
+ *
  * @author Kevin Gaudin
- * 
  */
-final class ReflectionCollector {
+final class ReflectionCollector extends Collector {
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    ReflectionCollector(Context context, ACRAConfiguration config) {
+        super(ReportField.BUILD, ReportField.BUILD_CONFIG, ReportField.ENVIRONMENT);
+        this.context = context;
+        this.config = config;
+    }
 
     /**
      * Retrieves key/value pairs from static fields of a class.
      *
      * @param someClass the class to be inspected.
-     * 
-     * @return A human readable string with a key=value pair on each line.
      */
-    public static String collectConstants(Class<?> someClass, String prefix) {
-
-        final StringBuilder result = new StringBuilder();
-
+    private static void collectConstants(@NonNull Class<?> someClass, @NonNull JSONObject container) throws JSONException {
         final Field[] fields = someClass.getFields();
         for (final Field field : fields) {
-            if (prefix != null && prefix.length() > 0) {
-                result.append(prefix).append('.');
-            }
-            result.append(field.getName()).append("=");
             try {
                 final Object value = field.get(null);
                 if (value != null) {
-                    result.append(value.toString());
+                    if (field.getType().isArray()) {
+                        container.put(field.getName(), new JSONArray(Arrays.asList((Object[]) value)));
+                    } else {
+                        container.put(field.getName(), value);
+                    }
                 }
-            } catch (IllegalArgumentException e) {
-                result.append("N/A");
-            } catch (IllegalAccessException e) {
-                result.append("N/A");
+            } catch (IllegalArgumentException ignored) {
+                // NOOP
+            } catch (IllegalAccessException ignored) {
+                // NOOP
             }
-            result.append("\n");
         }
-
-        return result.toString();
     }
 
     /**
      * Retrieves key/value pairs from static getters of a class (get*() or is*()).
      *
      * @param someClass the class to be inspected.
-     * @return A human readable string with a key=value pair on each line.
      */
-    public static String collectStaticGettersResults(Class<?> someClass) {
-        final StringBuilder result = new StringBuilder();
+    private static void collectStaticGettersResults(@NonNull Class<?> someClass, JSONObject container) throws JSONException {
         final Method[] methods = someClass.getMethods();
         for (final Method method : methods) {
             if (method.getParameterTypes().length == 0
                     && (method.getName().startsWith("get") || method.getName().startsWith("is"))
-                    && !method.getName().equals("getClass")) {
+                    && !"getClass".equals(method.getName())) {
                 try {
-                    result.append(method.getName());
-                    result.append('=');
-                    result.append(method.invoke(null, (Object[]) null));
-                    result.append("\n");
-                } catch (IllegalArgumentException e) {
+                    container.put(method.getName(), method.invoke(null, (Object[]) null));
+                } catch (@NonNull IllegalArgumentException ignored) {
                     // NOOP
-                } catch (IllegalAccessException e) {
+                } catch (@NonNull InvocationTargetException ignored) {
                     // NOOP
-                } catch (InvocationTargetException e) {
+                } catch (@NonNull IllegalAccessException ignored) {
                     // NOOP
                 }
             }
         }
+    }
 
-        return result.toString();
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        ComplexElement result = new ComplexElement();
+        try {
+            switch (reportField) {
+                case BUILD:
+                    collectConstants(Build.class, result);
+                    JSONObject version = new JSONObject();
+                    collectConstants(Build.VERSION.class, version);
+                    result.put("VERSION", version);
+                    break;
+                case BUILD_CONFIG:
+                    try {
+                        collectConstants(getBuildConfigClass(), result);
+                    } catch (ClassNotFoundException e) {
+                        //already logged in getBuildConfigClass
+                    }
+                    break;
+                case ENVIRONMENT:
+                    collectStaticGettersResults(Environment.class, result);
+                    break;
+                default:
+                    //will not happen if used correctly
+                    throw new IllegalArgumentException();
+            }
+        } catch (JSONException e) {
+            ACRA.log.w("Couldn't collect constants", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+        return result;
     }
 
-    public static String collectConstants(Class<?> someClass) {
-        return collectConstants(someClass, "");
+    /**
+     * get the configured BuildConfigClass or guess it if not configured
+     * @return the BuildConfigClass
+     * @throws ClassNotFoundException if the class cannot be found
+     */
+    @NonNull
+    private Class<?> getBuildConfigClass() throws ClassNotFoundException {
+        final Class configuredBuildConfig = config.buildConfigClass();
+        if (!configuredBuildConfig.equals(Object.class)) {
+            // If set via annotations or programmatically then it will have a real value,
+            // otherwise it will be Object.class (default).
+            return configuredBuildConfig;
+        }
+
+        final String className = context.getPackageName() + ".BuildConfig";
+        try {
+            return Class.forName(className);
+        } catch (ClassNotFoundException e) {
+            ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
+            throw e;
+        }
     }
 }
diff --git a/src/main/java/org/acra/collector/SettingsCollector.java b/src/main/java/org/acra/collector/SettingsCollector.java
index 7b4cbf0f..d45c9db4 100644
--- a/src/main/java/org/acra/collector/SettingsCollector.java
+++ b/src/main/java/org/acra/collector/SettingsCollector.java
@@ -16,145 +16,169 @@
 
 package org.acra.collector;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.acra.ACRA;
-
-import android.content.ContentResolver;
 import android.content.Context;
-import android.provider.Settings;
+import android.os.Build;
+import android.provider.Settings.Global;
 import android.provider.Settings.Secure;
 import android.provider.Settings.System;
-import android.util.Log;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
+
+import java.lang.reflect.Field;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
- * Helper to collect data from {@link System} and {@link Secure} Settings
+ * collects data from {@link System}, {@link Global} and {@link Secure} Settings
  * classes.
- * 
- * @author Kevin Gaudin
- * 
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-final class SettingsCollector {
+final class SettingsCollector extends Collector {
+
+    private static final String ERROR = "Error: ";
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    SettingsCollector(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        super(ReportField.SETTINGS_SYSTEM, ReportField.SETTINGS_SECURE, ReportField.SETTINGS_GLOBAL);
+        this.context = context;
+        this.config = config;
+    }
 
     /**
-     * Collect data from {@link android.provider.Settings.System}. This
+     * Collect data from {@link System}. This
      * collector uses reflection to be sure to always get the most accurate data
      * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
+     *
+     * @return collected key-value pairs.
      */
-    public static String collectSystemSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.System.class.getFields();
+    @NonNull
+    private Element collectSystemSettings() throws JSONException {
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = System.class.getFields();
         for (final Field key : keys) {
             // Avoid retrieving deprecated fields... it is useless, has an
-            // impact on perfs, and the system writes many warnings in the
+            // impact on prefs, and the system writes many warnings in the
             // logcat.
             if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class) {
                 try {
-                    final Object value = Settings.System.getString(ctx.getContentResolver(), (String) key.get(null));
+                    final Object value = System.getString(context.getContentResolver(), (String) key.get(null));
                     if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
+                        result.put(key.getName(), value);
                     }
-                } catch (IllegalArgumentException e) {
-                    Log.w(ACRA.LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    Log.w(ACRA.LOG_TAG, "Error : ", e);
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
                 }
             }
         }
-
-        return result.toString();
+        return result;
     }
 
     /**
-     * Collect data from {@link android.provider.Settings.Secure}. This
+     * Collect data from {@link Secure}. This
      * collector uses reflection to be sure to always get the most accurate data
      * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
+     *
+     * @return collected key-value pairs.
      */
-    public static String collectSecureSettings(Context ctx) {
-        final StringBuilder result = new StringBuilder();
-        final Field[] keys = Settings.Secure.class.getFields();
+    @NonNull
+    private Element collectSecureSettings() throws JSONException {
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = Secure.class.getFields();
         for (final Field key : keys) {
             if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
                 try {
-                    final Object value = Settings.Secure.getString(ctx.getContentResolver(), (String) key.get(null));
+                    final Object value = Secure.getString(context.getContentResolver(), (String) key.get(null));
                     if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
+                        result.put(key.getName(), value);
                     }
-                } catch (IllegalArgumentException e) {
-                    Log.w(ACRA.LOG_TAG, "Error : ", e);
-                } catch (IllegalAccessException e) {
-                    Log.w(ACRA.LOG_TAG, "Error : ", e);
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
                 }
             }
         }
-
-        return result.toString();
+        return result;
     }
 
     /**
-     * Collect data from {@link android.provider.Settings.Global}. This
+     * Collect data from {@link Global}. This
      * collector uses reflection to be sure to always get the most accurate data
      * whatever Android API level it runs on.
-     * 
-     * @param ctx
-     *            Application context.
-     * @return A human readable String containing one key=value pair per line.
+     *
+     * @return collected key-value pairs.
      */
-    public static String collectGlobalSettings(Context ctx) {
-        if (Compatibility.getAPILevel() < 17) {
-            return "";
+    @NonNull
+    private Element collectGlobalSettings() throws JSONException {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            return ACRAConstants.NOT_AVAILABLE;
         }
 
-        final StringBuilder result = new StringBuilder();
-        try {
-            final Class<?> globalClass = Class.forName("android.provider.Settings$Global");
-            final Field[] keys = globalClass.getFields();
-            final Method getString = globalClass.getMethod("getString", ContentResolver.class, String.class);
-            for (final Field key : keys) {
-                if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
-                    final Object value = getString.invoke(null, ctx.getContentResolver(), (String) key.get(null));
+        final ComplexElement result = new ComplexElement();
+        final Field[] keys = Global.class.getFields();
+        for (final Field key : keys) {
+            if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
+                try {
+                    final Object value = Global.getString(context.getContentResolver(), (String) key.get(null));
                     if (value != null) {
-                        result.append(key.getName()).append("=").append(value).append("\n");
+                        result.put(key.getName(), value);
                     }
+                } catch (@NonNull IllegalArgumentException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull SecurityException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
+                } catch (@NonNull IllegalAccessException e) {
+                    ACRA.log.w(LOG_TAG, ERROR, e);
                 }
             }
-        } catch (IllegalArgumentException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
-        } catch (IllegalAccessException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
-        } catch (ClassNotFoundException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
-        } catch (SecurityException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
-        } catch (NoSuchMethodException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
-        } catch (InvocationTargetException e) {
-            Log.w(ACRA.LOG_TAG, "Error : ", e);
         }
-
-        return result.toString();
+        return result;
     }
 
-    private static boolean isAuthorized(Field key) {
+    private boolean isAuthorized(@Nullable Field key) {
         if (key == null || key.getName().startsWith("WIFI_AP")) {
             return false;
         }
-        for (String regex : ACRA.getConfig().excludeMatchingSettingsKeys()) {
-            if(key.getName().matches(regex)) {
-               return false; 
+        for (String regex : config.excludeMatchingSettingsKeys()) {
+            if (key.getName().matches(regex)) {
+                return false;
             }
         }
         return true;
     }
 
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        try {
+        switch (reportField) {
+            case SETTINGS_SYSTEM:
+                    return collectSystemSettings();
+            case SETTINGS_SECURE:
+                return collectSecureSettings();
+            case SETTINGS_GLOBAL:
+                return collectGlobalSettings();
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+        } catch (JSONException e) {
+            ACRA.log.w("Could not collect Settings", e);
+            return ACRAConstants.NOT_AVAILABLE;
+        }
+    }
 }
diff --git a/src/main/java/org/acra/collector/SharedPreferencesCollector.java b/src/main/java/org/acra/collector/SharedPreferencesCollector.java
index 7dd91e51..1ba167da 100644
--- a/src/main/java/org/acra/collector/SharedPreferencesCollector.java
+++ b/src/main/java/org/acra/collector/SharedPreferencesCollector.java
@@ -15,49 +15,67 @@
  */
 package org.acra.collector;
 
-import java.util.Map;
-import java.util.TreeMap;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
 
 import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
 import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.ReportBuilder;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.json.JSONException;
+import org.json.JSONObject;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * Collects the content (key/value pairs) of SharedPreferences, from the
  * application default preferences or any other preferences asked by the
  * application developer.
  */
-final class SharedPreferencesCollector {
+final class SharedPreferencesCollector extends Collector {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final SharedPreferences prefs;
+
+    SharedPreferencesCollector(@NonNull Context context, @NonNull ACRAConfiguration config, SharedPreferences prefs) {
+        super(ReportField.USER_EMAIL, ReportField.SHARED_PREFERENCES);
+        this.context = context;
+        this.config = config;
+        this.prefs = prefs;
+    }
 
     /**
-     * Collects all key/value pairs in SharedPreferences and writes them in a
-     * result String. The application default SharedPreferences are always
+     * Collects all key/value pairs in SharedPreferences.
+     * The application default SharedPreferences are always
      * collected, and the developer can provide additional SharedPreferences
      * names in the {@link ReportsCrashes#additionalSharedPreferences()}
      * configuration item.
-     * 
-     * 
-     * 
-     * @param context
-     *            the application context.
-     * @return A readable formatted String containing all key/value pairs.
+     *
+     * @return the collected key/value pairs.
      */
-    public static String collect(Context context) {
-        final StringBuilder result = new StringBuilder();
+    @NonNull
+    private Element collect() throws JSONException {
+        final ComplexElement result = new ComplexElement();
 
         // Include the default SharedPreferences
         final Map<String, SharedPreferences> sharedPrefs = new TreeMap<String, SharedPreferences>();
         sharedPrefs.put("default", PreferenceManager.getDefaultSharedPreferences(context));
 
         // Add in any additional SharedPreferences
-        final String[] sharedPrefIds = ACRA.getConfig().additionalSharedPreferences();
-        if (sharedPrefIds != null) {
-            for (final String sharedPrefId : sharedPrefIds) {
-                sharedPrefs.put(sharedPrefId, context.getSharedPreferences(sharedPrefId, Context.MODE_PRIVATE));
-            }
+        for (final String sharedPrefId : config.additionalSharedPreferences()) {
+            sharedPrefs.put(sharedPrefId, context.getSharedPreferences(sharedPrefId, Context.MODE_PRIVATE));
         }
 
         // Iterate over all included preference files and add the preferences from each.
@@ -69,41 +87,53 @@ public static String collect(Context context) {
 
             // Show that we have no preferences saved for that preference file.
             if (prefEntries.isEmpty()) {
-                result.append(sharedPrefId).append('=').append("empty\n");
-                continue;
-            }
-
-            // Add all non-filtered preferences from that preference file.
-            for (final String key : prefEntries.keySet()) {
-                if (filteredKey(key)) {
-                    ACRA.log.d(ACRA.LOG_TAG, "Filtered out sharedPreference=" + sharedPrefId + "  key=" + key + " due to filtering rule");
-                } else {
-                    final Object prefValue = prefEntries.get(key);
-                    result.append(sharedPrefId).append('.').append(key).append('=');
-                    result.append(prefValue == null ? "null" : prefValue.toString());
-                    result.append("\n");
+                result.put(sharedPrefId, "empty");
+            } else {
+                for (Iterator<String> iterator = prefEntries.keySet().iterator(); iterator.hasNext();){
+                    if(filteredKey(iterator.next())){
+                        iterator.remove();
+                    }
                 }
+                result.put(sharedPrefId, new JSONObject(prefEntries));
             }
-            result.append('\n');
         }
 
-        return result.toString();
+        return result;
     }
 
     /**
      * Checks if the key matches one of the patterns provided by the developer
      * to exclude some preferences from reports.
-     * 
-     * @param key
-     *            the name of the preference to be checked
+     *
+     * @param key the name of the preference to be checked
      * @return true if the key has to be excluded from reports.
      */
-    private static boolean filteredKey(String key) {
-        for (String regex : ACRA.getConfig().excludeMatchingSharedPreferencesKeys()) {
-            if(key.matches(regex)) {
-               return true; 
+    private boolean filteredKey(@NonNull String key) {
+        for (String regex : config.excludeMatchingSharedPreferencesKeys()) {
+            if (key.matches(regex)) {
+                return true;
             }
         }
         return false;
     }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case USER_EMAIL:
+                String email = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, null);
+                return email != null ? new StringElement(email) : ACRAConstants.NOT_AVAILABLE;
+            case SHARED_PREFERENCES:
+                try {
+                    return collect();
+                } catch (JSONException e) {
+                    ACRA.log.w(LOG_TAG, "Could not collect shared preferences", e);
+                    return ACRAConstants.NOT_AVAILABLE;
+                }
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
 }
diff --git a/src/main/java/org/acra/collector/SimpleValuesCollector.java b/src/main/java/org/acra/collector/SimpleValuesCollector.java
new file mode 100644
index 00000000..f57f3899
--- /dev/null
+++ b/src/main/java/org/acra/collector/SimpleValuesCollector.java
@@ -0,0 +1,125 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.BooleanElement;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+import org.acra.util.Installation;
+
+import java.io.File;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+import java.util.Set;
+import java.util.UUID;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Collects various simple values
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class SimpleValuesCollector extends Collector {
+    private final Context context;
+
+    SimpleValuesCollector(Context context) {
+        super(ReportField.IS_SILENT, ReportField.REPORT_ID, ReportField.INSTALLATION_ID,
+                ReportField.PACKAGE_NAME, ReportField.PHONE_MODEL, ReportField.ANDROID_VERSION,
+                ReportField.BRAND, ReportField.PRODUCT, ReportField.FILE_PATH, ReportField.USER_IP);
+        this.context = context;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return collect == ReportField.IS_SILENT || collect == ReportField.REPORT_ID || super.shouldCollect(crashReportFields, collect, reportBuilder);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case IS_SILENT:
+                return new BooleanElement(reportBuilder.isSendSilently());
+            case REPORT_ID:
+                return new StringElement(UUID.randomUUID().toString());
+            case INSTALLATION_ID:
+                return new StringElement(Installation.id(context));
+            case PACKAGE_NAME:
+                return new StringElement(context.getPackageName());
+            case PHONE_MODEL:
+                return new StringElement(Build.MODEL);
+            case ANDROID_VERSION:
+                return new StringElement(Build.VERSION.RELEASE);
+            case BRAND:
+                return new StringElement(Build.BRAND);
+            case PRODUCT:
+                return new StringElement(Build.PRODUCT);
+            case FILE_PATH:
+                return new StringElement(getApplicationFilePath());
+            case USER_IP:
+                return new StringElement(getLocalIpAddress());
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    @NonNull
+    private String getApplicationFilePath() {
+        final File filesDir = context.getFilesDir();
+        if (filesDir != null) {
+            return filesDir.getAbsolutePath();
+        }
+
+        ACRA.log.w(LOG_TAG, "Couldn't retrieve ApplicationFilePath for : " + context.getPackageName());
+        return "Couldn't retrieve ApplicationFilePath";
+    }
+
+    @NonNull
+    private static String getLocalIpAddress() {
+        final StringBuilder result = new StringBuilder();
+        boolean first = true;
+        try {
+            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
+                final NetworkInterface intf = en.nextElement();
+                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {
+                    final InetAddress inetAddress = enumIpAddr.nextElement();
+                    if (!inetAddress.isLoopbackAddress()) {
+                        if (!first) {
+                            result.append('\n');
+                        }
+                        result.append(inetAddress.getHostAddress());
+                        first = false;
+                    }
+                }
+            }
+        } catch (SocketException ex) {
+            ACRA.log.w(LOG_TAG, ex.toString());
+        }
+        return result.toString();
+    }
+}
diff --git a/src/main/java/org/acra/collector/StacktraceCollector.java b/src/main/java/org/acra/collector/StacktraceCollector.java
new file mode 100644
index 00000000..98b03fb1
--- /dev/null
+++ b/src/main/java/org/acra/collector/StacktraceCollector.java
@@ -0,0 +1,100 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.Set;
+
+/**
+ * Collects the holy stacktrace
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class StacktraceCollector extends Collector {
+    StacktraceCollector() {
+        super(ReportField.STACK_TRACE, ReportField.STACK_TRACE_HASH);
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return collect == ReportField.STACK_TRACE || super.shouldCollect(crashReportFields, collect, reportBuilder);
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        switch (reportField) {
+            case STACK_TRACE:
+                return new StringElement(
+                        getStackTrace(reportBuilder.getMessage(), reportBuilder.getException()));
+            case STACK_TRACE_HASH:
+                return new StringElement(getStackTraceHash(reportBuilder.getException()));
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+    }
+
+    @NonNull
+    private String getStackTrace(@Nullable String msg, @Nullable Throwable th) {
+        final Writer result = new StringWriter();
+        final PrintWriter printWriter = new PrintWriter(result);
+
+        if (msg != null && !TextUtils.isEmpty(msg)) {
+            printWriter.println(msg);
+        }
+
+        // If the exception was thrown in a background thread inside
+        // AsyncTask, then the actual exception can be found with getCause
+        Throwable cause = th;
+        while (cause != null) {
+            cause.printStackTrace(printWriter);
+            cause = cause.getCause();
+        }
+        final String stacktraceAsString = result.toString();
+        printWriter.close();
+
+        return stacktraceAsString;
+    }
+
+    @NonNull
+    private String getStackTraceHash(@Nullable Throwable th) {
+        final StringBuilder res = new StringBuilder();
+        Throwable cause = th;
+        while (cause != null) {
+            final StackTraceElement[] stackTraceElements = cause.getStackTrace();
+            for (final StackTraceElement e : stackTraceElements) {
+                res.append(e.getClassName());
+                res.append(e.getMethodName());
+            }
+            cause = cause.getCause();
+        }
+
+        return Integer.toHexString(res.toString().hashCode());
+    }
+}
diff --git a/src/main/java/org/acra/collector/ThreadCollector.java b/src/main/java/org/acra/collector/ThreadCollector.java
index 64e78dc7..b762944b 100644
--- a/src/main/java/org/acra/collector/ThreadCollector.java
+++ b/src/main/java/org/acra/collector/ThreadCollector.java
@@ -16,34 +16,49 @@
 
 package org.acra.collector;
 
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.ComplexElement;
+import org.acra.model.Element;
+import org.json.JSONException;
+
 /**
- * Collects some data identifying a Thread, usually the Thread which crashed.
- * 
- * @author Kevin Gaudin
- * 
+ * Collects some data identifying a Thread
+ *
+ * @author Kevin Gaudin & F43nd1r
  */
-public class ThreadCollector {
+final class ThreadCollector extends Collector {
+    ThreadCollector() {
+        super(ReportField.THREAD_DETAILS);
+    }
 
     /**
-     * Convenience method that collects some data identifying a Thread, usually the Thread which
-     * crashed and returns a string containing the thread's id, name, priority and group name.
-     * 
-     * @param t the thread
-     * @return a string representation of the string including the id, name and priority of the thread.
+     * collects some data identifying the crashed thread
+     *
+     * @return the information including the id, name and priority of the thread.
      */
-    public static String collect(Thread t) {
-        StringBuilder result = new StringBuilder();
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        Thread t = reportBuilder.getUncaughtExceptionThread();
+        final ComplexElement result = new ComplexElement();
         if (t != null) {
-
-            result.append("id=").append(t.getId()).append("\n");
-            result.append("name=").append(t.getName()).append("\n");
-            result.append("priority=").append(t.getPriority()).append("\n");
-            if (t.getThreadGroup() != null) {
-                result.append("groupName=").append(t.getThreadGroup().getName()).append("\n");
+            try {
+                result.put("id", t.getId());
+                result.put("name", t.getName());
+                result.put("priority", t.getPriority());
+                if (t.getThreadGroup() != null) {
+                    result.put("groupName", t.getThreadGroup().getName());
+                }
+            } catch (JSONException e) {
+                e.printStackTrace();
             }
         } else {
-            result.append("No broken thread, this might be a silent exception.");
+            return ACRAConstants.NOT_AVAILABLE;
         }
-        return result.toString();
+        return result;
     }
 }
diff --git a/src/main/java/org/acra/collector/TimeCollector.java b/src/main/java/org/acra/collector/TimeCollector.java
new file mode 100644
index 00000000..a34fb4f5
--- /dev/null
+++ b/src/main/java/org/acra/collector/TimeCollector.java
@@ -0,0 +1,74 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.collector;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.builder.ReportBuilder;
+import org.acra.model.Element;
+import org.acra.model.StringElement;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.Set;
+
+/**
+ * collects time information
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+final class TimeCollector extends Collector {
+    private final Calendar appStartDate;
+
+    TimeCollector(Calendar appStartDate) {
+        super(ReportField.USER_APP_START_DATE, ReportField.USER_CRASH_DATE);
+        this.appStartDate = appStartDate;
+    }
+
+    @Override
+    boolean shouldCollect(Set<ReportField> crashReportFields, ReportField collect, ReportBuilder reportBuilder) {
+        return true;
+    }
+
+    @NonNull
+    @Override
+    Element collect(ReportField reportField, ReportBuilder reportBuilder) {
+        Calendar time;
+        switch (reportField) {
+            case USER_APP_START_DATE:
+                time = appStartDate;
+                break;
+            case USER_CRASH_DATE:
+                time = new GregorianCalendar();
+                break;
+            default:
+                //will not happen if used correctly
+                throw new IllegalArgumentException();
+        }
+        return new StringElement(getTimeString(time));
+    }
+
+    @NonNull
+    private static String getTimeString(@NonNull Calendar time) {
+        final SimpleDateFormat format = new SimpleDateFormat(ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
+        return format.format(time.getTimeInMillis());
+    }
+}
diff --git a/src/main/java/org/acra/config/ACRAConfiguration.java b/src/main/java/org/acra/config/ACRAConfiguration.java
new file mode 100644
index 00000000..bffcdd3e
--- /dev/null
+++ b/src/main/java/org/acra/config/ACRAConfiguration.java
@@ -0,0 +1,446 @@
+/*
+ *  Copyright 2011 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import android.support.annotation.StringRes;
+import android.support.annotation.StyleRes;
+
+import org.acra.ReportField;
+import org.acra.ReportingInteractionMode;
+import org.acra.builder.ReportPrimer;
+import org.acra.collections.ImmutableList;
+import org.acra.dialog.BaseCrashReportDialog;
+import org.acra.file.Directory;
+import org.acra.security.KeyStoreFactory;
+import org.acra.sender.HttpSender.Method;
+import org.acra.sender.HttpSender.Type;
+import org.acra.sender.ReportSenderFactory;
+import org.acra.collections.ImmutableMap;
+import org.acra.collections.ImmutableSet;
+
+import java.io.Serializable;
+
+/**
+ * Represents the configuration that ACRA will use when handling crash reports.
+ *
+ * Use {@link ConfigurationBuilder} to programmatically construct an ACRAConfiguration.
+ */
+public final class ACRAConfiguration implements Serializable {
+
+    private final ImmutableSet<String> additionalDropBoxTags;
+    private final ImmutableSet<String> additionalSharedPreferences;
+    private final int connectionTimeout;
+    private final ImmutableSet<ReportField> reportContent;
+    private final boolean deleteUnapprovedReportsOnApplicationStart;
+    private final boolean deleteOldUnsentReportsOnApplicationStart;
+    private final int dropboxCollectionMinutes;
+    private final boolean alsoReportToAndroidFramework;
+    private final String formUri;
+    private final String formUriBasicAuthLogin;
+    private final String formUriBasicAuthPassword;
+    private final boolean includeDropBoxSystemTags;
+
+    private final ImmutableList<String> logcatArguments;
+    private final String mailTo;
+    private final ReportingInteractionMode reportingInteractionMode;
+    private final Class<? extends BaseCrashReportDialog> reportDialogClass;
+    private final Class<? extends ReportPrimer> reportPrimerClass;
+
+    @StringRes
+    private final int resDialogPositiveButtonText;
+    @StringRes
+    private final int resDialogNegativeButtonText;
+    @StringRes
+    private final int resDialogCommentPrompt;
+    @StringRes
+    private final int resDialogEmailPrompt;
+    @DrawableRes
+    private final int resDialogIcon;
+    @StringRes
+    private final int resDialogOkToast;
+    @StringRes
+    private final int resDialogText;
+    @StringRes
+    private final int resDialogTitle;
+    @StyleRes
+    private final int resDialogTheme;
+    @DrawableRes
+    private final int resNotifIcon;
+    @StringRes
+    private final int resNotifText;
+    @StringRes
+    private final int resNotifTickerText;
+    @StringRes
+    private final int resNotifTitle;
+    @StringRes
+    private final int resToastText;
+    private final int sharedPreferencesMode;
+    private final String sharedPreferencesName;
+    private final int socketTimeout;
+    private final boolean logcatFilterByPid;
+    private final boolean nonBlockingReadForLogcat;
+    private final boolean sendReportsInDevMode;
+
+    private final ImmutableSet<String> excludeMatchingSharedPreferencesKeys;
+    private final ImmutableSet<String> excludeMatchingSettingsKeys;
+    private final Class buildConfigClass;
+    private final String applicationLogFile;
+    private final int applicationLogFileLines;
+    private final Directory applicationLogFileDir;
+
+    private final Method httpMethod;
+    private final Type reportType;
+    private final ImmutableMap<String, String> httpHeaders;
+    private final Class<? extends KeyStoreFactory> keyStoreFactoryClass;
+    private final ImmutableSet<Class<? extends ReportSenderFactory>> reportSenderFactoryClasses;
+    @RawRes
+    private final int resCertificate;
+    private final String certificatePath;
+    private final String certificateType;
+    private final Class<? extends RetryPolicy> retryPolicyClass;
+    private final boolean stopServicesOnCrash;
+
+    /**
+     * @param builder ConfigurationBuilder with which to initialise this {@link ACRAConfiguration}.
+     */
+    ACRAConfiguration(@NonNull ConfigurationBuilder builder) {
+        additionalDropBoxTags = new ImmutableSet<String>(builder.additionalDropBoxTags());
+        additionalSharedPreferences = new ImmutableSet<String>(builder.additionalSharedPreferences());
+        connectionTimeout = builder.connectionTimeout();
+        reportContent = new ImmutableSet<ReportField>(builder.reportContent());
+        deleteUnapprovedReportsOnApplicationStart = builder.deleteUnapprovedReportsOnApplicationStart();
+        deleteOldUnsentReportsOnApplicationStart = builder.deleteOldUnsentReportsOnApplicationStart();
+        dropboxCollectionMinutes = builder.dropboxCollectionMinutes();
+        alsoReportToAndroidFramework = builder.alsoReportToAndroidFramework();
+        formUri = builder.formUri();
+        formUriBasicAuthLogin = builder.formUriBasicAuthLogin();
+        formUriBasicAuthPassword = builder.formUriBasicAuthPassword();
+        includeDropBoxSystemTags = builder.includeDropBoxSystemTags();
+        logcatArguments = new ImmutableList<String>(builder.logcatArguments());
+        mailTo = builder.mailTo();
+        reportingInteractionMode = builder.reportingInteractionMode();
+        resDialogIcon = builder.resDialogIcon();
+        resDialogPositiveButtonText = builder.resDialogPositiveButtonText();
+        resDialogNegativeButtonText = builder.resDialogNegativeButtonText();
+        resDialogCommentPrompt = builder.resDialogCommentPrompt();
+        resDialogEmailPrompt = builder.resDialogEmailPrompt();
+        resDialogOkToast = builder.resDialogOkToast();
+        resDialogText = builder.resDialogText();
+        resDialogTitle = builder.resDialogTitle();
+        resDialogTheme = builder.resDialogTheme();
+        resNotifIcon = builder.resNotifIcon();
+        resNotifText = builder.resNotifText();
+        resNotifTickerText = builder.resNotifTickerText();
+        resNotifTitle = builder.resNotifTitle();
+        resToastText = builder.resToastText();
+        sharedPreferencesMode = builder.sharedPreferencesMode();
+        sharedPreferencesName = builder.sharedPreferencesName();
+        socketTimeout = builder.socketTimeout();
+        logcatFilterByPid = builder.logcatFilterByPid();
+        nonBlockingReadForLogcat = builder.nonBlockingReadForLogcat();
+        sendReportsInDevMode = builder.sendReportsInDevMode();
+        excludeMatchingSharedPreferencesKeys = new ImmutableSet<String>(builder.excludeMatchingSharedPreferencesKeys());
+        excludeMatchingSettingsKeys = new ImmutableSet<String>(builder.excludeMatchingSettingsKeys());
+        buildConfigClass = builder.buildConfigClass();
+        applicationLogFile = builder.applicationLogFile();
+        applicationLogFileLines = builder.applicationLogFileLines();
+        applicationLogFileDir = builder.applicationLogFileDir();
+        reportDialogClass = builder.reportDialogClass();
+        reportPrimerClass = builder.reportPrimerClass();
+        httpMethod = builder.httpMethod();
+        httpHeaders = new ImmutableMap<String, String>(builder.httpHeaders());
+        reportType = builder.reportType();
+        reportSenderFactoryClasses = new ImmutableSet<Class<? extends ReportSenderFactory>>(builder.reportSenderFactoryClasses());
+        keyStoreFactoryClass = builder.keyStoreFactoryClass();
+        resCertificate = builder.resCertificate();
+        certificatePath = builder.certificatePath();
+        certificateType = builder.certificateType();
+        retryPolicyClass = builder.retryPolicyClass();
+        stopServicesOnCrash = builder.stopServicesOnCrash();
+    }
+
+    /**
+     * Retrieve HTTP headers defined by the application developer. These should
+     * be added to requests sent by any third-party sender (over HTTP of
+     * course).
+     *
+     * @return A map associating http header names to their values.
+     */
+    @NonNull
+    public ImmutableMap<String, String> getHttpHeaders() {
+        return httpHeaders;
+    }
+
+    /**
+     * @return List of ReportField that ACRA will provide to the server.
+     */
+    @NonNull
+    public ImmutableSet<ReportField> getReportFields() {
+        return reportContent;
+    }
+
+    @NonNull
+    public ImmutableSet<String> additionalDropBoxTags() {
+        return additionalDropBoxTags;
+    }
+
+    @NonNull
+    public ImmutableSet<String> additionalSharedPreferences() {
+        return additionalSharedPreferences;
+    }
+
+    public int connectionTimeout() {
+        return connectionTimeout;
+    }
+
+    public boolean deleteUnapprovedReportsOnApplicationStart() {
+        return deleteUnapprovedReportsOnApplicationStart;
+    }
+
+    public boolean deleteOldUnsentReportsOnApplicationStart() {
+        return deleteOldUnsentReportsOnApplicationStart;
+    }
+
+    public int dropboxCollectionMinutes() {
+        return dropboxCollectionMinutes;
+    }
+
+    public boolean alsoReportToAndroidFramework() {
+        return alsoReportToAndroidFramework;
+    }
+
+    @Nullable
+    public String formUri() {
+        return formUri;
+    }
+
+    @Nullable
+    public String formUriBasicAuthLogin() {
+        return formUriBasicAuthLogin;
+    }
+
+    @Nullable
+    public String formUriBasicAuthPassword() {
+        return formUriBasicAuthPassword;
+    }
+
+    public boolean includeDropBoxSystemTags() {
+        return includeDropBoxSystemTags;
+    }
+
+    @NonNull
+    public ImmutableList<String> logcatArguments() {
+        return logcatArguments;
+    }
+
+    @Nullable
+    public String mailTo() {
+        return mailTo;
+    }
+
+    @NonNull
+    public ReportingInteractionMode mode() {
+        return reportingInteractionMode;
+    }
+
+    @StringRes
+    public int resDialogPositiveButtonText() {
+        return resDialogPositiveButtonText;
+    }
+
+    @StringRes
+    public int resDialogNegativeButtonText() {
+        return resDialogNegativeButtonText;
+    }
+
+    @StringRes
+    public int resDialogCommentPrompt() {
+        return resDialogCommentPrompt;
+    }
+
+    @StringRes
+    public int resDialogEmailPrompt() {
+        return resDialogEmailPrompt;
+    }
+
+    @DrawableRes
+    public int resDialogIcon() {
+        return resDialogIcon;
+    }
+
+    @StringRes
+    public int resDialogOkToast() {
+        return resDialogOkToast;
+    }
+
+    @StringRes
+    public int resDialogText() {
+        return resDialogText;
+    }
+
+    @StringRes
+    public int resDialogTitle() {
+        return resDialogTitle;
+    }
+
+    @StyleRes
+    public int resDialogTheme() {
+        return resDialogTheme;
+    }
+
+    @DrawableRes
+    public int resNotifIcon() {
+        return resNotifIcon;
+    }
+
+    @StringRes
+    public int resNotifText() {
+        return resNotifText;
+    }
+
+    @StringRes
+    public int resNotifTickerText() {
+        return resNotifTickerText;
+    }
+
+    @StringRes
+    public int resNotifTitle() {
+        return resNotifTitle;
+    }
+
+    @StringRes
+    public int resToastText() {
+        return resToastText;
+    }
+
+    public int sharedPreferencesMode() {
+        return sharedPreferencesMode;
+    }
+
+    @NonNull
+    public String sharedPreferencesName() {
+        return sharedPreferencesName;
+    }
+
+    public int socketTimeout() {
+        return socketTimeout;
+    }
+
+    public boolean logcatFilterByPid() {
+        return logcatFilterByPid;
+    }
+
+    public boolean nonBlockingReadForLogcat() {
+        return nonBlockingReadForLogcat;
+    }
+
+    public boolean sendReportsInDevMode() {
+        return sendReportsInDevMode;
+    }
+
+    @NonNull
+    public ImmutableSet<String> excludeMatchingSharedPreferencesKeys() {
+        return excludeMatchingSharedPreferencesKeys;
+    }
+
+    @NonNull
+    public ImmutableSet<String> excludeMatchingSettingsKeys() {
+        return excludeMatchingSettingsKeys;
+    }
+
+    /**
+     * Will return null if no value has been configured.
+     * It is up to clients to construct the recommended default value of context.getClass().getPackage().getName() + BuildConfig.class
+     *
+     * @return Class generated at compile time containing the build config for this application.
+     */
+    @NonNull
+    public Class buildConfigClass() {
+        return buildConfigClass;
+    }
+
+    @NonNull
+    public String applicationLogFile() {
+        return applicationLogFile;
+    }
+
+    public int applicationLogFileLines() {
+        return applicationLogFileLines;
+    }
+
+    @NonNull
+    public Directory applicationLogFileDir() {
+        return applicationLogFileDir;
+    }
+
+    @NonNull
+    public Class<? extends BaseCrashReportDialog> reportDialogClass() {
+        return reportDialogClass;
+    }
+
+    @NonNull
+    public Class<? extends ReportPrimer> reportPrimerClass() {
+        return reportPrimerClass;
+    }
+
+    @NonNull
+    public Method httpMethod() {
+        return httpMethod;
+    }
+
+    @NonNull
+    public Type reportType() {
+        return reportType;
+    }
+
+    @NonNull
+    public ImmutableSet<Class<? extends ReportSenderFactory>> reportSenderFactoryClasses() {
+        return reportSenderFactoryClasses;
+    }
+
+    @NonNull
+    public Class<? extends KeyStoreFactory> keyStoreFactoryClass() {
+        return keyStoreFactoryClass;
+    }
+
+    @RawRes
+    public int resCertificate() {
+        return resCertificate;
+    }
+
+    @NonNull
+    public String certificatePath() {
+        return certificatePath;
+    }
+
+    @NonNull
+    public String certificateType() {
+        return certificateType;
+    }
+
+    @NonNull
+    public Class<? extends RetryPolicy> retryPolicyClass() {
+        return retryPolicyClass;
+    }
+
+    public boolean stopServicesOnCrash(){
+        return stopServicesOnCrash;
+    }
+}
diff --git a/src/main/java/org/acra/ACRAConfigurationException.java b/src/main/java/org/acra/config/ACRAConfigurationException.java
similarity index 85%
rename from src/main/java/org/acra/ACRAConfigurationException.java
rename to src/main/java/org/acra/config/ACRAConfigurationException.java
index 55a27f3b..380d3e79 100644
--- a/src/main/java/org/acra/ACRAConfigurationException.java
+++ b/src/main/java/org/acra/config/ACRAConfigurationException.java
@@ -1,30 +1,34 @@
-/*
- *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-/**
- * A simple Exception used when required configuration items are missing.
- * 
- * @author Kevin Gaudin
- */
-public class ACRAConfigurationException extends Exception {
-
-    private static final long serialVersionUID = -7355339673505996110L;
-
-    public ACRAConfigurationException(String msg) {
-        super(msg);
-    }
-}
+/*
+ *  Copyright 2010 Emmanuel Astier & Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+/**
+ * A simple Exception used when required configuration items are missing.
+ * 
+ * @author Kevin Gaudin
+ */
+public class ACRAConfigurationException extends Exception {
+
+    private static final long serialVersionUID = -7355339673505996110L;
+
+    public ACRAConfigurationException(String msg) {
+        super(msg);
+    }
+
+    public ACRAConfigurationException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+}
diff --git a/src/main/java/org/acra/config/ConfigurationBuilder.java b/src/main/java/org/acra/config/ConfigurationBuilder.java
new file mode 100644
index 00000000..c56f4ae7
--- /dev/null
+++ b/src/main/java/org/acra/config/ConfigurationBuilder.java
@@ -0,0 +1,1306 @@
+/*
+ *  Copyright 2011 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import android.app.Application;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import android.support.annotation.StringRes;
+import android.support.annotation.StyleRes;
+
+import org.acra.ACRA;
+import org.acra.ReportField;
+import org.acra.ReportingInteractionMode;
+import org.acra.annotation.ReportsCrashes;
+import org.acra.builder.NoOpReportPrimer;
+import org.acra.builder.ReportPrimer;
+import org.acra.dialog.BaseCrashReportDialog;
+import org.acra.dialog.CrashReportDialog;
+import org.acra.file.Directory;
+import org.acra.security.KeyStoreFactory;
+import org.acra.security.NoKeyStoreFactory;
+import org.acra.sender.DefaultReportSenderFactory;
+import org.acra.sender.HttpSender;
+import org.acra.sender.HttpSender.Method;
+import org.acra.sender.HttpSender.Type;
+import org.acra.sender.ReportSenderFactory;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ACRAConstants.*;
+
+/**
+ * Builder responsible for programmatic construction of an {@link ACRAConfiguration}.
+ *
+ * {@link ACRAConfiguration} should be considered immutable and in the future will be.
+ *
+ * @since 4.8.1
+ */
+@SuppressWarnings("unused")
+public final class ConfigurationBuilder {
+
+    @Nullable
+    private final Class<? extends Annotation> annotationType;
+
+    private String[] additionalDropBoxTags;
+    private String[] additionalSharedPreferences;
+    private Integer connectionTimeout;
+    private ReportField[] customReportContent;
+    private final Map<ReportField, Boolean> reportContentChanges = new EnumMap<ReportField, Boolean>(ReportField.class);
+    private Boolean deleteUnapprovedReportsOnApplicationStart;
+    private Boolean deleteOldUnsentReportsOnApplicationStart;
+    private Integer dropboxCollectionMinutes;
+    private Boolean alsoReportToAndroidFramework;
+    private String formUri;
+    private String formUriBasicAuthLogin;
+    private String formUriBasicAuthPassword;
+    private Boolean includeDropBoxSystemTags;
+
+    private String[] logcatArguments;
+    private String mailTo;
+    private ReportingInteractionMode reportingInteractionMode;
+    private Class<? extends BaseCrashReportDialog> reportDialogClass;
+    private Class<? extends ReportPrimer> reportPrimerClass;
+
+    @StringRes private Integer resDialogPositiveButtonText;
+    @StringRes private Integer resDialogNegativeButtonText;
+    @StringRes private Integer resDialogCommentPrompt;
+    @StringRes  private Integer resDialogEmailPrompt;
+    @DrawableRes private Integer resDialogIcon;
+    @StringRes private Integer resDialogOkToast;
+    @StringRes private Integer resDialogText;
+    @StringRes private Integer resDialogTitle;
+    @StyleRes private Integer resDialogTheme;
+    @DrawableRes private Integer resNotifIcon;
+    @StringRes private Integer resNotifText;
+    @StringRes private Integer resNotifTickerText;
+    @StringRes private Integer resNotifTitle;
+    @StringRes private Integer resToastText;
+    private Integer sharedPreferencesMode;
+    private String sharedPreferencesName;
+    private Integer socketTimeout;
+    private Boolean logcatFilterByPid;
+    private Boolean nonBlockingReadForLogcat;
+    private Boolean sendReportsInDevMode;
+
+    private String[] excludeMatchingSharedPreferencesKeys;
+    private String[] excludeMatchingSettingsKeys;
+    private Class buildConfigClass;
+    private String applicationLogFile;
+    private Integer applicationLogFileLines;
+    private Directory applicationLogFileDir;
+
+    private Method httpMethod;
+    private Type reportType;
+    private final Map<String, String> httpHeaders = new HashMap<String, String>();
+    private Class<? extends KeyStoreFactory> keyStoreFactoryClass;
+    private Class<? extends ReportSenderFactory>[] reportSenderFactoryClasses;
+    @RawRes private Integer resCertificate;
+    private String certificatePath;
+    private String certificateType;
+    private Class<? extends RetryPolicy> retryPolicyClass;
+    private Boolean stopServicesOnCrash;
+
+
+    /**
+     * Constructs a ConfigurationBuilder that is prepopulated with any
+     * '@ReportCrashes' annotation declared on the Application class.
+     *
+     * @param app Current Application, from which any annotated config will be gleaned.
+     */
+    public ConfigurationBuilder(@NonNull Application app) {
+
+        // Populate with annotated config
+        final ReportsCrashes annotationConfig = app.getClass().getAnnotation(ReportsCrashes.class);
+
+        if (annotationConfig != null) {
+            annotationType = annotationConfig.annotationType();
+
+            additionalDropBoxTags = annotationConfig.additionalDropBoxTags();
+            additionalSharedPreferences = annotationConfig.additionalSharedPreferences();
+            connectionTimeout = annotationConfig.connectionTimeout();
+            customReportContent = annotationConfig.customReportContent();
+            deleteUnapprovedReportsOnApplicationStart = annotationConfig.deleteUnapprovedReportsOnApplicationStart();
+            deleteOldUnsentReportsOnApplicationStart = annotationConfig.deleteOldUnsentReportsOnApplicationStart();
+            dropboxCollectionMinutes = annotationConfig.dropboxCollectionMinutes();
+            alsoReportToAndroidFramework = annotationConfig.alsoReportToAndroidFramework();
+            formUri = annotationConfig.formUri();
+            formUriBasicAuthLogin = annotationConfig.formUriBasicAuthLogin();
+            formUriBasicAuthPassword = annotationConfig.formUriBasicAuthPassword();
+            includeDropBoxSystemTags = annotationConfig.includeDropBoxSystemTags();
+            logcatArguments = annotationConfig.logcatArguments();
+            mailTo = annotationConfig.mailTo();
+            reportingInteractionMode = annotationConfig.mode();
+            resDialogIcon = annotationConfig.resDialogIcon();
+            resDialogPositiveButtonText = annotationConfig.resDialogPositiveButtonText();
+            resDialogNegativeButtonText = annotationConfig.resDialogNegativeButtonText();
+            resDialogCommentPrompt = annotationConfig.resDialogCommentPrompt();
+            resDialogEmailPrompt = annotationConfig.resDialogEmailPrompt();
+            resDialogOkToast = annotationConfig.resDialogOkToast();
+            resDialogText = annotationConfig.resDialogText();
+            resDialogTitle = annotationConfig.resDialogTitle();
+            resDialogTheme = annotationConfig.resDialogTheme();
+            resNotifIcon = annotationConfig.resNotifIcon();
+            resNotifText = annotationConfig.resNotifText();
+            resNotifTickerText = annotationConfig.resNotifTickerText();
+            resNotifTitle = annotationConfig.resNotifTitle();
+            resToastText = annotationConfig.resToastText();
+            sharedPreferencesMode = annotationConfig.sharedPreferencesMode();
+            sharedPreferencesName = annotationConfig.sharedPreferencesName();
+            socketTimeout = annotationConfig.socketTimeout();
+            logcatFilterByPid = annotationConfig.logcatFilterByPid();
+            nonBlockingReadForLogcat = annotationConfig.nonBlockingReadForLogcat();
+            sendReportsInDevMode = annotationConfig.sendReportsInDevMode();
+            excludeMatchingSharedPreferencesKeys = annotationConfig.excludeMatchingSharedPreferencesKeys();
+            excludeMatchingSettingsKeys = annotationConfig.excludeMatchingSettingsKeys();
+            buildConfigClass = annotationConfig.buildConfigClass();
+            applicationLogFile = annotationConfig.applicationLogFile();
+            applicationLogFileLines = annotationConfig.applicationLogFileLines();
+            applicationLogFileDir = annotationConfig.applicationLogFileDir();
+            reportDialogClass = annotationConfig.reportDialogClass();
+            reportPrimerClass = annotationConfig.reportPrimerClass();
+            httpMethod = annotationConfig.httpMethod();
+            reportType = annotationConfig.reportType();
+            reportSenderFactoryClasses = annotationConfig.reportSenderFactoryClasses();
+            keyStoreFactoryClass = annotationConfig.keyStoreFactoryClass();
+            resCertificate = annotationConfig.resCertificate();
+            certificatePath = annotationConfig.certificatePath();
+            certificateType = annotationConfig.certificateType();
+            retryPolicyClass = annotationConfig.retryPolicyClass();
+            stopServicesOnCrash = annotationConfig.stopServicesOnCrash();
+        } else {
+            annotationType = null;
+        }
+    }
+
+    /**
+     * Builds the {@link ACRAConfiguration} which will be used to configure ACRA.
+     * <p>
+     * You can pass this {@link ConfigurationBuilder} to {@link ACRA#init(Application, ConfigurationBuilder)} and
+     * {@link ACRA#init(Application, ConfigurationBuilder)} will handle any Exception.
+     * </p>
+     *
+     * @return new ACRAConfiguration containing all the properties configured on this builder.
+     * @throws ACRAConfigurationException if the required values for the configured notification mode have not been provided.
+     */
+    @NonNull
+    public ACRAConfiguration build() throws ACRAConfigurationException {
+
+        switch (reportingInteractionMode()) {
+            case TOAST:
+                if (resToastText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("TOAST mode: you have to define the resToastText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            case NOTIFICATION:
+                if (resNotifTickerText() == DEFAULT_RES_VALUE || resNotifTitle() == DEFAULT_RES_VALUE || resNotifText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("NOTIFICATION mode: you have to define at least the resNotifTickerText, resNotifTitle, resNotifText parameters in your application @ReportsCrashes() annotation.");
+                }
+                if (CrashReportDialog.class.equals(reportDialogClass()) && resDialogText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("NOTIFICATION mode: using the (default) CrashReportDialog requires you have to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            case DIALOG:
+                if (CrashReportDialog.class.equals(reportDialogClass()) && resDialogText() == DEFAULT_RES_VALUE) {
+                    throw new ACRAConfigurationException("DIALOG mode: using the (default) CrashReportDialog requires you to define the resDialogText parameter in your application @ReportsCrashes() annotation.");
+                }
+                break;
+            default:
+                break;
+        }
+
+        if (reportSenderFactoryClasses().length == 0) {
+            throw new ACRAConfigurationException("Report sender factories: using no report senders will make ACRA useless. Configure at least one ReportSenderFactory.");
+        }
+        checkValidity((Class[]) reportSenderFactoryClasses());
+        checkValidity(reportDialogClass(), reportPrimerClass(), retryPolicyClass(), keyStoreFactoryClass());
+
+        return new ACRAConfiguration(this);
+    }
+
+    private void checkValidity(Class<?>... classes) throws ACRAConfigurationException {
+        for (Class<?> clazz : classes) {
+            if (clazz.isInterface()) {
+                throw new ACRAConfigurationException("Expected class, but found interface " + clazz.getName() + ".");
+            } else if (Modifier.isAbstract(clazz.getModifiers())) {
+                throw new ACRAConfigurationException("Class " + clazz.getName() + " cannot be abstract.");
+            }
+            try {
+                clazz.getConstructor();
+            } catch (NoSuchMethodException e) {
+                throw new ACRAConfigurationException("Class " + clazz.getName() + " is missing a no-args Constructor.", e);
+            }
+        }
+    }
+
+    /**
+     * Set custom HTTP headers to be sent by the provided {@link HttpSender}.
+     * This should be used also by third party senders.
+     *
+     * @param headers A map associating HTTP header names to their values.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setHttpHeaders(@NonNull Map<String, String> headers) {
+        this.httpHeaders.clear();
+        this.httpHeaders.putAll(headers);
+        return this;
+    }
+
+    /**
+     * @param additionalDropboxTags the additionalDropboxTags to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setAdditionalDropboxTags(@NonNull String... additionalDropboxTags) {
+        this.additionalDropBoxTags = additionalDropboxTags;
+        return this;
+    }
+
+    /**
+     * @param additionalSharedPreferences the additionalSharedPreferences to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setAdditionalSharedPreferences(@NonNull String... additionalSharedPreferences) {
+        this.additionalSharedPreferences = additionalSharedPreferences;
+        return this;
+    }
+
+    /**
+     * @param connectionTimeout the connectionTimeout to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setConnectionTimeout(int connectionTimeout) {
+        this.connectionTimeout = connectionTimeout;
+        return this;
+    }
+
+    /**
+     * @param customReportContent the customReportContent to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setCustomReportContent(@NonNull ReportField... customReportContent) {
+        this.customReportContent = customReportContent;
+        return this;
+    }
+
+    /**
+     * Use this if you want to keep the default configuration of reportContent, but set some fields explicitly.
+     *
+     * @param field  the field to set
+     * @param enable if this field should be reported
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setReportField(@NonNull ReportField field, boolean enable) {
+        this.reportContentChanges.put(field, enable);
+        return this;
+    }
+
+    /**
+     * @param deleteUnapprovedReportsOnApplicationStart the deleteUnapprovedReportsOnApplicationStart to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setDeleteUnapprovedReportsOnApplicationStart(boolean deleteUnapprovedReportsOnApplicationStart) {
+        this.deleteUnapprovedReportsOnApplicationStart = deleteUnapprovedReportsOnApplicationStart;
+        return this;
+    }
+
+    /**
+     * @param deleteOldUnsentReportsOnApplicationStart When to delete old (unsent) reports on startup.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setDeleteOldUnsentReportsOnApplicationStart(boolean deleteOldUnsentReportsOnApplicationStart) {
+        this.deleteOldUnsentReportsOnApplicationStart = deleteOldUnsentReportsOnApplicationStart;
+        return this;
+    }
+
+    /**
+     * @param dropboxCollectionMinutes the dropboxCollectionMinutes to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setDropboxCollectionMinutes(int dropboxCollectionMinutes) {
+        this.dropboxCollectionMinutes = dropboxCollectionMinutes;
+        return this;
+    }
+
+    /**
+     * @param alsoReportToAndroidFramework Whether to also report the failure to the Android framework.
+     *                                     NB this will cause the native force dialog dialog to be displayed
+     *                                     as well as any ACRA notification.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setAlsoReportToAndroidFramework(boolean alsoReportToAndroidFramework) {
+        this.alsoReportToAndroidFramework = alsoReportToAndroidFramework;
+        return this;
+    }
+
+    /**
+     * Modify the formUri of your backend server receiving reports.
+     *
+     * @param formUri formUri to set.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setFormUri(@Nullable String formUri) {
+        this.formUri = formUri;
+        return this;
+    }
+
+    /**
+     * @param formUriBasicAuthLogin the formUriBasicAuthLogin to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setFormUriBasicAuthLogin(@Nullable String formUriBasicAuthLogin) {
+        this.formUriBasicAuthLogin = formUriBasicAuthLogin;
+        return this;
+    }
+
+    /**
+     * @param formUriBasicAuthPassword the formUriBasicAuthPassword to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setFormUriBasicAuthPassword(@Nullable String formUriBasicAuthPassword) {
+        this.formUriBasicAuthPassword = formUriBasicAuthPassword;
+        return this;
+    }
+
+    /**
+     * @param includeDropboxSystemTags the includeDropboxSystemTags to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setIncludeDropboxSystemTags(boolean includeDropboxSystemTags) {
+        this.includeDropBoxSystemTags = includeDropboxSystemTags;
+        return this;
+    }
+
+    /**
+     * @param logcatArguments the logcatArguments to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setLogcatArguments(@NonNull String... logcatArguments) {
+        this.logcatArguments = logcatArguments;
+        return this;
+    }
+
+    /**
+     * Modify the mailTo of the mail account receiving reports.
+     *
+     * @param mailTo mailTo to set.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setMailTo(@Nullable String mailTo) {
+        this.mailTo = mailTo;
+        return this;
+    }
+
+    /**
+     * Change the current {@link ReportingInteractionMode}.
+     *
+     * @param mode ReportingInteractionMode to set.
+     * @return this instance
+     * @deprecated since 4.8.2 use {@link #setReportingInteractionMode(ReportingInteractionMode)} instead.
+     */
+    @NonNull
+    public ConfigurationBuilder setMode(@NonNull ReportingInteractionMode mode) {
+        this.reportingInteractionMode = mode;
+        return this;
+    }
+
+    /**
+     * Change the current {@link ReportingInteractionMode}.
+     *
+     * @param mode ReportingInteractionMode to set.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setReportingInteractionMode(@NonNull ReportingInteractionMode mode) {
+        this.reportingInteractionMode = mode;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setResDialogPositiveButtonText(@StringRes int resId) {
+        resDialogPositiveButtonText = resId;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setResDialogNegativeButtonText(@StringRes int resId) {
+        resDialogNegativeButtonText = resId;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setReportDialogClass(@NonNull Class<? extends BaseCrashReportDialog> reportDialogClass) {
+        this.reportDialogClass = reportDialogClass;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogCommentPrompt()} comes from an Android
+     * Library Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogCommentPrompt()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogCommentPrompt(@StringRes int resId) {
+        resDialogCommentPrompt = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogEmailPrompt()} comes from an Android Library Project.
+     *
+     * @param resId The resource id, see
+     *              {@link ReportsCrashes#resDialogEmailPrompt()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogEmailPrompt(@StringRes int resId) {
+        resDialogEmailPrompt = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogIcon()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogIcon()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogIcon(@DrawableRes int resId) {
+        resDialogIcon = resId;
+        return this;
+    }
+
+    /**
+     * Use this method BEFORE if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogOkToast()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogOkToast()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogOkToast(@StringRes int resId) {
+        resDialogOkToast = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogText()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogText()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogText(@StringRes int resId) {
+        resDialogText = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resDialogTitle()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogTitle()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogTitle(@StringRes int resId) {
+        resDialogTitle = resId;
+        return this;
+    }
+
+    /**
+     * @param resId The resource id, see {@link ReportsCrashes#resDialogTheme()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResDialogTheme(@StyleRes int resId) {
+        resDialogTheme = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resNotifIcon()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resNotifIcon()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResNotifIcon(@DrawableRes int resId) {
+        resNotifIcon = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resNotifText()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resNotifText()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResNotifText(@StringRes int resId) {
+        resNotifText = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resNotifTickerText()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see
+     *              {@link ReportsCrashes#resNotifTickerText()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResNotifTickerText(@StringRes int resId) {
+        resNotifTickerText = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resNotifTitle()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resNotifTitle()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResNotifTitle(@StringRes int resId) {
+        resNotifTitle = resId;
+        return this;
+    }
+
+    /**
+     * Use this method if the id you wanted to give to
+     * {@link ReportsCrashes#resToastText()} comes from an Android Library
+     * Project.
+     *
+     * @param resId The resource id, see {@link ReportsCrashes#resToastText()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setResToastText(@StringRes int resId) {
+        resToastText = resId;
+        return this;
+    }
+
+    /**
+     * @param sharedPreferenceMode the sharedPreferenceMode to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setSharedPreferenceMode(int sharedPreferenceMode) {
+        this.sharedPreferencesMode = sharedPreferenceMode;
+        return this;
+    }
+
+    /**
+     * @param sharedPreferenceName the sharedPreferenceName to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setSharedPreferenceName(@NonNull String sharedPreferenceName) {
+        this.sharedPreferencesName = sharedPreferenceName;
+        return this;
+    }
+
+    /**
+     * @param socketTimeout the socketTimeout to set
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setSocketTimeout(int socketTimeout) {
+        this.socketTimeout = socketTimeout;
+        return this;
+    }
+
+    /**
+     * @param filterByPid true if you want to collect only logcat lines related to your
+     *                    application process.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setLogcatFilterByPid(boolean filterByPid) {
+        logcatFilterByPid = filterByPid;
+        return this;
+    }
+
+    /**
+     * @param nonBlockingRead true if you want that collecting of logcat lines
+     *                        should not block current thread. Read operation
+     *                        has a timeout of 3 seconds.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setNonBlockingReadForLogcat(boolean nonBlockingRead) {
+        nonBlockingReadForLogcat = nonBlockingRead;
+        return this;
+    }
+
+    /**
+     * @param sendReportsInDevMode false if you want to disable sending reports in development
+     *                             mode. Reports will be sent only on signed applications.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setSendReportsInDevMode(boolean sendReportsInDevMode) {
+        this.sendReportsInDevMode = sendReportsInDevMode;
+        return this;
+    }
+
+    /**
+     * @param sendReportsAtShutdown Ignored.
+     * @return this instance
+     * @deprecated since 4.8.3 no replacement. Now that we are using the SenderService in a separate process we always send at shutdown.
+     */
+    @NonNull
+    public ConfigurationBuilder setSendReportsAtShutdown(boolean sendReportsAtShutdown) {
+        return this;
+    }
+
+    /**
+     * @param excludeMatchingSharedPreferencesKeys an array of Strings containing regexp defining
+     *                                             SharedPreferences keys that should be excluded from the data
+     *                                             collection.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setExcludeMatchingSharedPreferencesKeys(@NonNull String... excludeMatchingSharedPreferencesKeys) {
+        this.excludeMatchingSharedPreferencesKeys = excludeMatchingSharedPreferencesKeys;
+        return this;
+    }
+
+    /**
+     * @param excludeMatchingSettingsKeys an array of Strings containing regexp defining
+     *                                    Settings.System, Settings.Secure and Settings.Global keys that
+     *                                    should be excluded from the data collection.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setExcludeMatchingSettingsKeys(@NonNull String... excludeMatchingSettingsKeys) {
+        this.excludeMatchingSettingsKeys = excludeMatchingSettingsKeys;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setBuildConfigClass(@Nullable Class buildConfigClass) {
+        this.buildConfigClass = buildConfigClass;
+        return this;
+    }
+
+    /**
+     * @param applicationLogFile The path and file name of your application log file, to be
+     *                           used with {@link ReportField#APPLICATION_LOG}.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setApplicationLogFile(@NonNull String applicationLogFile) {
+        this.applicationLogFile = applicationLogFile;
+        return this;
+    }
+
+    /**
+     * @param applicationLogFileLines The number of lines of your application log to be collected,
+     *                                to be used with {@link ReportField#APPLICATION_LOG} and
+     *                                {@link ReportsCrashes#applicationLogFile()}.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setApplicationLogFileLines(int applicationLogFileLines) {
+        this.applicationLogFileLines = applicationLogFileLines;
+        return this;
+    }
+
+    /**
+     * @param directory The directory in which the application log file will be searched,
+     *                  to be used with {@link ReportField#APPLICATION_LOG} and
+     *                  {@link ReportsCrashes#applicationLogFile()}
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setApplicationLogFileDir(@NonNull Directory directory) {
+        this.applicationLogFileDir = directory;
+        return this;
+    }
+
+    /**
+     * @param httpMethod The method to be used to send data to the server.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setHttpMethod(@NonNull Method httpMethod) {
+        this.httpMethod = httpMethod;
+        return this;
+    }
+
+    /**
+     * @param type The type of content encoding to be used to send data to the
+     *             server.
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setReportType(@NonNull Type type) {
+        reportType = type;
+        return this;
+    }
+
+    /**
+     * @param keyStoreFactoryClass Set this to a factory class which creates a the keystore that contains the trusted certificates
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setKeyStoreFactoryClass(Class<? extends KeyStoreFactory> keyStoreFactoryClass) {
+        this.keyStoreFactoryClass = keyStoreFactoryClass;
+        return this;
+    }
+
+    /**
+     * @param resCertificate a raw resource of a custom certificate file
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setCertificate(@RawRes int resCertificate) {
+        this.resCertificate = resCertificate;
+        return this;
+    }
+
+    /**
+     * @param certificatePath path to a custom trusted certificate. Must start with "asset://" if the file is in the assets folder
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setCertificate(@NonNull String certificatePath) {
+        this.certificatePath = certificatePath;
+        return this;
+    }
+
+    /**
+     * @param type custom certificate type
+     * @return this instance
+     */
+    @NonNull
+    public ConfigurationBuilder setCertificateType(@NonNull String type) {
+        this.certificateType = type;
+        return this;
+    }
+
+    @SafeVarargs
+    @NonNull
+    public final ConfigurationBuilder setReportSenderFactoryClasses(@NonNull Class<? extends ReportSenderFactory>... reportSenderFactoryClasses) {
+        this.reportSenderFactoryClasses = reportSenderFactoryClasses;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setReportPrimerClass(@NonNull Class<? extends ReportPrimer> reportPrimerClass) {
+        this.reportPrimerClass = reportPrimerClass;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setRetryPolicyClass(@NonNull Class<? extends RetryPolicy> retryPolicyClass) {
+        this.retryPolicyClass = retryPolicyClass;
+        return this;
+    }
+
+    @NonNull
+    public ConfigurationBuilder setStopServicesOnCrash(boolean stopServicesOnCrash) {
+        this.stopServicesOnCrash = stopServicesOnCrash;
+        return this;
+    }
+
+
+    // Getters - used to provide values and !DEFAULTS! to ACRConfiguration during construction
+
+    @NonNull
+    String[] additionalDropBoxTags() {
+        if (additionalDropBoxTags != null) {
+            return additionalDropBoxTags;
+        }
+        return new String[0];
+    }
+
+    @NonNull
+    String[] additionalSharedPreferences() {
+        if (additionalSharedPreferences != null) {
+            return additionalSharedPreferences;
+        }
+        return new String[0];
+    }
+
+    /**
+     * @deprecated since 4.8.1 no replacement.
+     */
+    @Nullable
+    Class<? extends Annotation> annotationType() {
+        return annotationType; // Why would this ever be needed?
+    }
+
+    int connectionTimeout() {
+        if (connectionTimeout != null) {
+            return connectionTimeout;
+        }
+        return DEFAULT_CONNECTION_TIMEOUT;
+    }
+
+    @NonNull
+    Set<ReportField> reportContent() {
+        final Set<ReportField> reportContent = new LinkedHashSet<ReportField>();
+        if (customReportContent != null && customReportContent.length != 0) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using custom Report Fields");
+            reportContent.addAll(Arrays.asList(customReportContent));
+        } else if (mailTo == null || DEFAULT_STRING_VALUE.equals(mailTo)) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using default Report Fields");
+            reportContent.addAll(Arrays.asList(DEFAULT_REPORT_FIELDS));
+        } else {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Using default Mail Report Fields");
+            reportContent.addAll(Arrays.asList(DEFAULT_MAIL_REPORT_FIELDS));
+        }
+
+        // Add or remove any extra fields.
+        for (Map.Entry<ReportField, Boolean> entry : reportContentChanges.entrySet()) {
+            if (entry.getValue()) {
+                reportContent.add(entry.getKey());
+            } else {
+                reportContent.remove(entry.getKey());
+            }
+        }
+        return reportContent;
+    }
+
+    boolean deleteUnapprovedReportsOnApplicationStart() {
+        if (deleteUnapprovedReportsOnApplicationStart != null) {
+            return deleteUnapprovedReportsOnApplicationStart;
+        }
+        return DEFAULT_DELETE_UNAPPROVED_REPORTS_ON_APPLICATION_START;
+    }
+
+    boolean deleteOldUnsentReportsOnApplicationStart() {
+        if (deleteOldUnsentReportsOnApplicationStart != null) {
+            return deleteOldUnsentReportsOnApplicationStart;
+        }
+        return DEFAULT_DELETE_OLD_UNSENT_REPORTS_ON_APPLICATION_START;
+    }
+
+    int dropboxCollectionMinutes() {
+        if (dropboxCollectionMinutes != null) {
+            return dropboxCollectionMinutes;
+        }
+        return DEFAULT_DROPBOX_COLLECTION_MINUTES;
+    }
+
+    boolean alsoReportToAndroidFramework() {
+        if (alsoReportToAndroidFramework != null) {
+            return alsoReportToAndroidFramework;
+        }
+        return DEFAULT_REPORT_TO_ANDROID_FRAMEWORK;
+    }
+
+    @NonNull
+    String formUri() {
+        if (formUri != null) {
+            return formUri;
+        }
+        return DEFAULT_STRING_VALUE;
+    }
+
+    @NonNull
+    String formUriBasicAuthLogin() {
+        if (formUriBasicAuthLogin != null) {
+            return formUriBasicAuthLogin;
+        }
+        return NULL_VALUE;
+    }
+
+    @NonNull
+    String formUriBasicAuthPassword() {
+        if (formUriBasicAuthPassword != null) {
+            return formUriBasicAuthPassword;
+        }
+        return NULL_VALUE;
+    }
+
+    boolean includeDropBoxSystemTags() {
+        if (includeDropBoxSystemTags != null) {
+            return includeDropBoxSystemTags;
+        }
+        return DEFAULT_INCLUDE_DROPBOX_SYSTEM_TAGS;
+    }
+
+    @NonNull
+    String[] logcatArguments() {
+        if (logcatArguments != null) {
+            return logcatArguments;
+        }
+        return new String[]{"-t", Integer.toString(DEFAULT_LOGCAT_LINES), "-v", "time"};
+    }
+
+    @NonNull
+    String mailTo() {
+        if (mailTo != null) {
+            return mailTo;
+        }
+        return DEFAULT_STRING_VALUE;
+    }
+
+    @NonNull
+    ReportingInteractionMode reportingInteractionMode() {
+        if (reportingInteractionMode != null) {
+            return reportingInteractionMode;
+        }
+        return ReportingInteractionMode.SILENT;
+    }
+
+    @StringRes
+    public int resDialogPositiveButtonText() {
+        if (resDialogPositiveButtonText != null) {
+            return resDialogPositiveButtonText;
+        }
+        return DEFAULT_DIALOG_POSITIVE_BUTTON_TEXT;
+    }
+
+    @StringRes
+    int resDialogNegativeButtonText() {
+        if (resDialogNegativeButtonText != null) {
+            return resDialogNegativeButtonText;
+        }
+        return DEFAULT_DIALOG_NEGATIVE_BUTTON_TEXT;
+    }
+
+    @StringRes
+    int resDialogCommentPrompt() {
+        if (resDialogCommentPrompt != null) {
+            return resDialogCommentPrompt;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resDialogEmailPrompt() {
+        if (resDialogEmailPrompt != null) {
+            return resDialogEmailPrompt;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @DrawableRes
+    int resDialogIcon() {
+        if (resDialogIcon != null) {
+            return resDialogIcon;
+        }
+        return DEFAULT_DIALOG_ICON;
+    }
+
+    @StringRes
+    int resDialogOkToast() {
+        if (resDialogOkToast != null) {
+            return resDialogOkToast;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resDialogText() {
+        if (resDialogText != null) {
+            return resDialogText;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resDialogTitle() {
+        if (resDialogTitle != null) {
+            return resDialogTitle;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StyleRes
+    int resDialogTheme() {
+        if (resDialogTheme != null) {
+            return resDialogTheme;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @DrawableRes
+    int resNotifIcon() {
+        if (resNotifIcon != null) {
+            return resNotifIcon;
+        }
+        return DEFAULT_NOTIFICATION_ICON;
+    }
+
+    @StringRes
+    int resNotifText() {
+        if (resNotifText != null) {
+            return resNotifText;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resNotifTickerText() {
+        if (resNotifTickerText != null) {
+            return resNotifTickerText;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resNotifTitle() {
+        if (resNotifTitle != null) {
+            return resNotifTitle;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @StringRes
+    int resToastText() {
+        if (resToastText != null) {
+            return resToastText;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    int sharedPreferencesMode() {
+        if (sharedPreferencesMode != null) {
+            return sharedPreferencesMode;
+        }
+        return DEFAULT_SHARED_PREFERENCES_MODE;
+    }
+
+    @NonNull
+    String sharedPreferencesName() {
+        if (sharedPreferencesName != null) {
+            return sharedPreferencesName;
+        }
+
+        return DEFAULT_STRING_VALUE;
+    }
+
+    int socketTimeout() {
+        if (socketTimeout != null) {
+            return socketTimeout;
+        }
+        return DEFAULT_SOCKET_TIMEOUT;
+    }
+
+    boolean logcatFilterByPid() {
+        if (logcatFilterByPid != null) {
+            return logcatFilterByPid;
+        }
+        return DEFAULT_LOGCAT_FILTER_BY_PID;
+    }
+
+    boolean nonBlockingReadForLogcat() {
+        if (nonBlockingReadForLogcat != null) {
+            return nonBlockingReadForLogcat;
+        }
+        return DEFAULT_NON_BLOCKING_READ_FOR_LOGCAT;
+    }
+
+    boolean sendReportsInDevMode() {
+        if (sendReportsInDevMode != null) {
+            return sendReportsInDevMode;
+        }
+        return DEFAULT_SEND_REPORTS_IN_DEV_MODE;
+    }
+
+    @NonNull
+    String[] excludeMatchingSharedPreferencesKeys() {
+        if (excludeMatchingSharedPreferencesKeys != null) {
+            return excludeMatchingSharedPreferencesKeys;
+        }
+        return new String[0];
+    }
+
+    @NonNull
+    String[] excludeMatchingSettingsKeys() {
+        if (excludeMatchingSettingsKeys != null) {
+            return excludeMatchingSettingsKeys;
+        }
+        return new String[0];
+    }
+
+    /**
+     * Will return {@link Object} if no value has been configured.
+     * It is up to clients to construct the recommended default value of context.getClass().getPackage().getName() + BuildConfig.class
+     */
+    @NonNull
+    Class buildConfigClass() {
+        if (buildConfigClass != null) {
+            return buildConfigClass;
+        }
+        return Object.class;
+    }
+
+    @NonNull
+    String applicationLogFile() {
+        if (applicationLogFile != null) {
+            return applicationLogFile;
+        }
+        return DEFAULT_APPLICATION_LOGFILE;
+    }
+
+    int applicationLogFileLines() {
+        if (applicationLogFileLines != null) {
+            return applicationLogFileLines;
+        }
+        return DEFAULT_APPLICATION_LOGFILE_LINES;
+    }
+
+    @NonNull
+    Directory applicationLogFileDir() {
+        if (applicationLogFileDir != null) {
+            return applicationLogFileDir;
+        }
+        return Directory.FILES_LEGACY;
+    }
+
+    @NonNull
+    Class<? extends BaseCrashReportDialog> reportDialogClass() {
+        if (reportDialogClass != null) {
+            return reportDialogClass;
+        }
+        return CrashReportDialog.class;
+    }
+
+    @NonNull
+    Class<? extends ReportPrimer> reportPrimerClass() {
+        if (reportPrimerClass != null) {
+            return reportPrimerClass;
+        }
+        return NoOpReportPrimer.class;
+    }
+
+    @NonNull
+    Method httpMethod() {
+        if (httpMethod != null) {
+            return httpMethod;
+        }
+        return Method.POST;
+    }
+
+    @NonNull
+    Type reportType() {
+        if (reportType != null) {
+            return reportType;
+        }
+        return Type.FORM;
+    }
+
+    @NonNull
+    Class<? extends ReportSenderFactory>[] reportSenderFactoryClasses() {
+        if (reportSenderFactoryClasses != null) {
+            return reportSenderFactoryClasses;
+        }
+        //noinspection unchecked
+        return new Class[]{DefaultReportSenderFactory.class};
+    }
+
+    @NonNull
+    Class<? extends KeyStoreFactory> keyStoreFactoryClass() {
+        if (keyStoreFactoryClass != null) {
+            return keyStoreFactoryClass;
+        }
+        return NoKeyStoreFactory.class;
+    }
+
+    @RawRes
+    int resCertificate() {
+        if (resCertificate != null) {
+            return resCertificate;
+        }
+        return DEFAULT_RES_VALUE;
+    }
+
+    @NonNull
+    String certificatePath() {
+        if (certificatePath != null) {
+            return certificatePath;
+        }
+        return DEFAULT_STRING_VALUE;
+    }
+
+    @NonNull
+    String certificateType() {
+        if (certificateType != null) {
+            return certificateType;
+        }
+        return DEFAULT_CERTIFICATE_TYPE;
+    }
+
+    @NonNull
+    Map<String, String> httpHeaders() {
+        return httpHeaders;
+    }
+
+    @NonNull
+    Class<? extends RetryPolicy> retryPolicyClass() {
+        if (retryPolicyClass != null) {
+            return retryPolicyClass;
+        }
+        return DefaultRetryPolicy.class;
+    }
+
+    boolean stopServicesOnCrash() {
+        if (stopServicesOnCrash != null) {
+            return stopServicesOnCrash;
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/org/acra/config/DefaultRetryPolicy.java b/src/main/java/org/acra/config/DefaultRetryPolicy.java
new file mode 100644
index 00000000..d03639cf
--- /dev/null
+++ b/src/main/java/org/acra/config/DefaultRetryPolicy.java
@@ -0,0 +1,33 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import org.acra.sender.ReportSender;
+
+import java.util.List;
+
+/**
+ * Default {@link RetryPolicy}. Only resend if all senders failed.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public class DefaultRetryPolicy implements RetryPolicy {
+    @Override
+    public boolean shouldRetrySend(List<ReportSender> senders, List<FailedSender> failedSenders) {
+        return (senders.size() == failedSenders.size()) && !senders.isEmpty();
+    }
+}
diff --git a/src/main/java/org/acra/config/RetryPolicy.java b/src/main/java/org/acra/config/RetryPolicy.java
new file mode 100644
index 00000000..b27b24ee
--- /dev/null
+++ b/src/main/java/org/acra/config/RetryPolicy.java
@@ -0,0 +1,56 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.config;
+
+import org.acra.sender.ReportSender;
+import org.acra.sender.ReportSenderException;
+
+import java.util.List;
+
+/**
+ * A policy which determines if a report should be resent.
+ *
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public interface RetryPolicy {
+
+    /**
+     * @param senders a list of all senders.
+     * @param failedSenders a list of all failed senders with the thrown exceptions.
+     * @return <code>true</code> if the request should be resent later, otherwise <code>false</code>.
+     */
+    boolean shouldRetrySend(List<ReportSender> senders, List<FailedSender> failedSenders);
+
+    class FailedSender {
+
+        private final ReportSender sender;
+        private final ReportSenderException exception;
+
+        public FailedSender(ReportSender sender, ReportSenderException exception) {
+            this.sender = sender;
+            this.exception = exception;
+        }
+
+        public ReportSender getSender() {
+            return sender;
+        }
+
+        public ReportSenderException getException() {
+            return exception;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/dialog/BaseCrashReportDialog.java b/src/main/java/org/acra/dialog/BaseCrashReportDialog.java
new file mode 100644
index 00000000..45676c9c
--- /dev/null
+++ b/src/main/java/org/acra/dialog/BaseCrashReportDialog.java
@@ -0,0 +1,154 @@
+package org.acra.dialog;
+
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.FragmentActivity;
+import android.widget.Toast;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.BulkReportDeleter;
+import org.acra.file.CrashReportPersister;
+import org.acra.sender.SenderServiceStarter;
+import org.acra.util.ToastSender;
+import org.json.JSONException;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import static org.acra.ACRA.LOG_TAG;
+import static org.acra.ReportField.USER_COMMENT;
+import static org.acra.ReportField.USER_EMAIL;
+
+/**
+ * Activity which implements the base functionality for a CrashReportDialog.
+ *
+ * Activities which extend from this class can override init to create a custom view.
+ *
+ * The methods sendCrash(comment, userEmail) and cancelReports() can be used to send or cancel
+ * sending of reports respectively.
+ *
+ * This Activity will be instantiated with 3 (or 4) arguments:
+ * <ol>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_FILE}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_EXCEPTION}</li>
+ * <li>{@link ACRAConstants#EXTRA_REPORT_CONFIG}</li>
+ * <li>{@link ACRAConstants#EXTRA_FORCE_CANCEL} (optional)</li>
+ * </ol>
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public abstract class BaseCrashReportDialog extends FragmentActivity {
+
+    private File reportFile;
+    private ACRAConfiguration config;
+    private Throwable exception;
+
+    /**
+     * NB if you were previously creating and showing your dialog in this method,
+     * you should move that code to {@link #init(Bundle)}.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    @Override
+    protected final void onCreate(@Nullable Bundle savedInstanceState) {
+        preInit(savedInstanceState);
+        super.onCreate(savedInstanceState);
+
+
+        if (ACRA.DEV_LOGGING) {
+            ACRA.log.d(LOG_TAG, "CrashReportDialog extras=" + getIntent().getExtras());
+        }
+
+        final Serializable sConfig = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_CONFIG);
+        final Serializable sReportFile = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_FILE);
+        final Serializable sException = getIntent().getSerializableExtra(ACRAConstants.EXTRA_REPORT_EXCEPTION);
+        final boolean forceCancel = getIntent().getBooleanExtra(ACRAConstants.EXTRA_FORCE_CANCEL, false);
+
+        if (forceCancel) {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Forced reports deletion.");
+            cancelReports();
+            finish();
+        } else if ((sConfig instanceof ACRAConfiguration) && (sReportFile instanceof File) && ((sException instanceof Throwable) || sException == null)) {
+            config = (ACRAConfiguration) sConfig;
+            reportFile = (File) sReportFile;
+            exception = (Throwable) sException;
+            init(savedInstanceState);
+        } else {
+            ACRA.log.w(LOG_TAG, "Illegal or incomplete call of BaseCrashReportDialog.");
+            finish();
+        }
+    }
+
+    /**
+     * Handle any necessary pre-onCreate() setup here.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    protected void preInit(@Nullable Bundle savedInstanceState) {
+    }
+
+    /**
+     * Responsible for creating and showing the crash report dialog.
+     *
+     * @param savedInstanceState    If the activity is being re-initialized after
+     *     previously being shut down then this Bundle contains the data it most
+     *     recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
+     */
+    protected void init(@Nullable Bundle savedInstanceState) {
+    }
+
+
+    /**
+     * Cancel any pending crash reports.
+     */
+    protected final void cancelReports() {
+        new BulkReportDeleter(getApplicationContext()).deleteReports(false, 0);
+    }
+
+
+    /**
+     * Send crash report given user's comment and email address. If none should be empty strings
+     *
+     * @param comment   Comment (may be null) provided by the user.
+     * @param userEmail Email address (may be null) provided by the client.
+     */
+    protected final void sendCrash(@Nullable String comment, @Nullable String userEmail) {
+        final CrashReportPersister persister = new CrashReportPersister();
+        try {
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Add user comment to " + reportFile);
+            final CrashReportData crashData = persister.load(reportFile);
+            crashData.putString(USER_COMMENT, comment == null ? "" : comment);
+            crashData.putString(USER_EMAIL, userEmail == null ? "" : userEmail);
+            persister.store(crashData, reportFile);
+        } catch (IOException e) {
+            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
+        } catch (JSONException e) {
+            ACRA.log.w(LOG_TAG, "User comment not added: ", e);
+        }
+
+        // Start the report sending task
+        final SenderServiceStarter starter = new SenderServiceStarter(getApplicationContext(), config);
+        starter.startService(false, true);
+
+        // Optional Toast to thank the user
+        final int toastId = config.resDialogOkToast();
+        if (toastId != 0) {
+            ToastSender.sendToast(getApplicationContext(), toastId, Toast.LENGTH_LONG);
+        }
+    }
+
+    protected final ACRAConfiguration getConfig() {
+        return config;
+    }
+
+    protected final Throwable getException() {
+        return exception;
+    }
+}
diff --git a/src/main/java/org/acra/dialog/CrashReportDialog.java b/src/main/java/org/acra/dialog/CrashReportDialog.java
new file mode 100644
index 00000000..f71f0313
--- /dev/null
+++ b/src/main/java/org/acra/dialog/CrashReportDialog.java
@@ -0,0 +1,259 @@
+package org.acra.dialog;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.support.annotation.CallSuper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.InputType;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.ScrollView;
+import android.widget.TextView;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.prefs.PrefUtils;
+import org.acra.prefs.SharedPreferencesFactory;
+
+
+/**
+ * This is the dialog Activity used by ACRA to get authorization from the user
+ * to send reports. Requires android:launchMode="singleInstance" in your
+ * AndroidManifest to work properly.
+ **/
+@SuppressWarnings({"WeakerAccess", "unused"})
+public class CrashReportDialog extends BaseCrashReportDialog implements DialogInterface.OnClickListener {
+
+    private static final String STATE_EMAIL = "email";
+    private static final String STATE_COMMENT = "comment";
+    private static final int PADDING = 10;
+
+    private LinearLayout scrollable;
+    private EditText userCommentView;
+    private EditText userEmailView;
+    private SharedPreferencesFactory sharedPreferencesFactory;
+
+    private AlertDialog mDialog;
+
+    @CallSuper
+    @Override
+    protected void init(@Nullable Bundle savedInstanceState) {
+        scrollable = new LinearLayout(this);
+        scrollable.setOrientation(LinearLayout.VERTICAL);
+        sharedPreferencesFactory = new SharedPreferencesFactory(getApplicationContext(), getConfig());
+        final int themeResourceId = getConfig().resDialogTheme();
+        if(themeResourceId != ACRAConstants.DEFAULT_RES_VALUE) setTheme(themeResourceId);
+
+        buildAndShowDialog(savedInstanceState);
+    }
+
+    /**
+     * Build the dialog from the values in config
+     *
+     * @param savedInstanceState old state to restore
+     */
+    protected void buildAndShowDialog(@Nullable Bundle savedInstanceState) {
+        final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
+        final int titleResourceId = getConfig().resDialogTitle();
+        if (titleResourceId != ACRAConstants.DEFAULT_RES_VALUE) {
+            dialogBuilder.setTitle(titleResourceId);
+        }
+        final int iconResourceId = getConfig().resDialogIcon();
+        if (iconResourceId != ACRAConstants.DEFAULT_RES_VALUE) {
+            dialogBuilder.setIcon(iconResourceId);
+        }
+        dialogBuilder.setView(buildCustomView(savedInstanceState))
+                .setPositiveButton(getText(getConfig().resDialogPositiveButtonText()), this)
+                .setNegativeButton(getText(getConfig().resDialogNegativeButtonText()), this);
+
+        mDialog = dialogBuilder.create();
+        mDialog.setCanceledOnTouchOutside(false);
+        mDialog.show();
+    }
+
+    @NonNull
+    protected View buildCustomView(@Nullable Bundle savedInstanceState) {
+        final ScrollView root = new ScrollView(this);
+        root.setPadding(PADDING, PADDING, PADDING, PADDING);
+        root.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        root.setFocusable(true);
+        root.setFocusableInTouchMode(true);
+        root.addView(scrollable);
+
+        addViewToDialog(getMainView());
+
+        // Add an optional prompt for user comments
+        final View comment = getCommentLabel();
+        if (comment != null) {
+            comment.setPadding(comment.getPaddingLeft(), PADDING, comment.getPaddingRight(), comment.getPaddingBottom());
+            addViewToDialog(comment);
+            String savedComment = null;
+            if (savedInstanceState != null) {
+                savedComment = savedInstanceState.getString(STATE_COMMENT);
+            }
+            userCommentView = getCommentPrompt(savedComment);
+            addViewToDialog(userCommentView);
+        }
+
+        // Add an optional user email field
+        final View email = getEmailLabel();
+        if (email != null) {
+            email.setPadding(email.getPaddingLeft(), PADDING, email.getPaddingRight(), email.getPaddingBottom());
+            addViewToDialog(email);
+            String savedEmail = null;
+            if (savedInstanceState != null) {
+                savedEmail = savedInstanceState.getString(STATE_EMAIL);
+            }
+            userEmailView = getEmailPrompt(savedEmail);
+            addViewToDialog(userEmailView);
+        }
+        return root;
+    }
+
+    /**
+     * adds a view to the end of the dialog
+     *
+     * @param v the view to add
+     */
+    protected final void addViewToDialog(@NonNull View v) {
+        scrollable.addView(v);
+    }
+
+    /**
+     * Creates a main view containing text of resDialogText, or nothing if not found
+     *
+     * @return the main view
+     */
+    @NonNull
+    protected View getMainView() {
+        final TextView text = new TextView(this);
+        final int dialogTextId = getConfig().resDialogText();
+        if (dialogTextId != ACRAConstants.DEFAULT_RES_VALUE) {
+            text.setText(getText(dialogTextId));
+        }
+        return text;
+    }
+
+    /**
+     * creates a comment label view with resDialogCommentPrompt as text
+     *
+     * @return the label or null if there is no resource
+     */
+    @Nullable
+    protected View getCommentLabel() {
+        final int commentPromptId = getConfig().resDialogCommentPrompt();
+        if (commentPromptId != ACRAConstants.DEFAULT_RES_VALUE) {
+            final TextView labelView = new TextView(this);
+            labelView.setText(getText(commentPromptId));
+            return labelView;
+        }
+        return null;
+    }
+
+    /**
+     * creates a comment prompt
+     *
+     * @param savedComment the content of the prompt (usually from a saved state)
+     * @return the comment prompt
+     */
+    @NonNull
+    protected EditText getCommentPrompt(@Nullable CharSequence savedComment) {
+        final EditText userCommentView = new EditText(this);
+        userCommentView.setLines(2);
+        if (savedComment != null) {
+            userCommentView.setText(savedComment);
+        }
+        return userCommentView;
+    }
+
+    /**
+     * creates a email label view with resDialogEmailPrompt as text
+     *
+     * @return the label or null if there is no resource
+     */
+    @Nullable
+    protected View getEmailLabel() {
+        final int emailPromptId = getConfig().resDialogEmailPrompt();
+        if (emailPromptId != ACRAConstants.DEFAULT_RES_VALUE) {
+            final TextView labelView = new TextView(this);
+            labelView.setText(getText(emailPromptId));
+            return labelView;
+        }
+        return null;
+    }
+
+    /**
+     * creates an email prompt
+     *
+     * @param savedEmail the content of the prompt (usually from a saved state or settings)
+     * @return the email prompt
+     */
+    @NonNull
+    protected EditText getEmailPrompt(@Nullable CharSequence savedEmail) {
+        final EditText userEmailView = new EditText(this);
+        userEmailView.setSingleLine();
+        userEmailView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+
+        if (savedEmail != null) {
+            userEmailView.setText(savedEmail);
+        } else {
+            final SharedPreferences prefs = sharedPreferencesFactory.create();
+            userEmailView.setText(prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, ""));
+        }
+        return userEmailView;
+    }
+
+    @Override
+    public void onClick(DialogInterface dialog, int which) {
+        if (which == DialogInterface.BUTTON_POSITIVE) {
+            // Retrieve user comment
+            final String comment = userCommentView != null ? userCommentView.getText().toString() : "";
+
+            // Store the user email
+            final String userEmail;
+            final SharedPreferences prefs = sharedPreferencesFactory.create();
+            if (userEmailView != null) {
+                userEmail = userEmailView.getText().toString();
+                final SharedPreferences.Editor prefEditor = prefs.edit();
+                prefEditor.putString(ACRA.PREF_USER_EMAIL_ADDRESS, userEmail);
+                PrefUtils.save(prefEditor);
+            } else {
+                userEmail = prefs.getString(ACRA.PREF_USER_EMAIL_ADDRESS, "");
+            }
+            sendCrash(comment, userEmail);
+        } else {
+            cancelReports();
+        }
+
+        finish();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
+     */
+    @CallSuper
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+        if (userCommentView != null && userCommentView.getText() != null) {
+            outState.putString(STATE_COMMENT, userCommentView.getText().toString());
+        }
+        if (userEmailView != null && userEmailView.getText() != null) {
+            outState.putString(STATE_EMAIL, userEmailView.getText().toString());
+        }
+    }
+
+    /**
+     * @return the AlertDialog displayed by this Activity
+     */
+    protected AlertDialog getDialog() {
+        return mDialog;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/acra/file/BulkReportDeleter.java b/src/main/java/org/acra/file/BulkReportDeleter.java
new file mode 100644
index 00000000..edc9b6b1
--- /dev/null
+++ b/src/main/java/org/acra/file/BulkReportDeleter.java
@@ -0,0 +1,40 @@
+package org.acra.file;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.File;
+import java.util.Arrays;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Deletes unsent reports.
+ */
+public final class BulkReportDeleter {
+
+    @NonNull
+    private final ReportLocator reportLocator;
+
+    public BulkReportDeleter(@NonNull Context context) {
+        this.reportLocator = new ReportLocator(context);
+    }
+
+    /**
+     * @param approved  Whether to delete approved or unapproved reports.
+     * @param nrToKeep  Number of latest reports to keep.
+     */
+    public void deleteReports(boolean approved, int nrToKeep) {
+        final File[] files = approved ? reportLocator.getApprovedReports() : reportLocator.getUnapprovedReports();
+
+        Arrays.sort(files, new LastModifiedComparator());
+
+        for (int i = 0; i < files.length - nrToKeep; i++) {
+            if (!files[i].delete()) {
+                ACRA.log.w(LOG_TAG, "Could not delete report : " + files[i]);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/acra/CrashReportFileNameParser.java b/src/main/java/org/acra/file/CrashReportFileNameParser.java
similarity index 84%
rename from src/main/java/org/acra/CrashReportFileNameParser.java
rename to src/main/java/org/acra/file/CrashReportFileNameParser.java
index 609906d0..91b64642 100644
--- a/src/main/java/org/acra/CrashReportFileNameParser.java
+++ b/src/main/java/org/acra/file/CrashReportFileNameParser.java
@@ -1,52 +1,57 @@
-/*
- *  Copyright 2012 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra;
-
-/**
- * Responsible for determining the state of a Crash Report based on its file name.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-final class CrashReportFileNameParser {
-
-    /**
-     * Guess that a report is silent from its file name.
-     *
-     * @param reportFileName    Name of the report to check whether it should be sent silently.
-     * @return True if the report has been declared explicitly silent using {@link ErrorReporter#handleSilentException(Throwable)}.
-     */
-    public boolean isSilent(String reportFileName) {
-        return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
-    }
-
-    /**
-     * Returns true if the report is considered as approved.
-     * <p>
-          This includes:
-     * </p>
-     * <ul>
-     * <li>Reports which were pending when the user agreed to send a report in the NOTIFICATION mode Dialog.</li>
-     * <li>Explicit silent reports</li>
-     * </ul>
-     *
-     * @param reportFileName    Name of report to check whether it is approved to be sent.
-     * @return True if a report can be sent.
-     */
-    public boolean isApproved(String reportFileName) {
-        return isSilent(reportFileName) || reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
-    }
-}
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.ErrorReporter;
+
+/**
+ * Responsible for determining the state of a Crash Report based on its file name.
+ *
+ * @author William Ferguson
+ * @since 4.3.0
+ */
+public final class CrashReportFileNameParser {
+
+    /**
+     * Guess that a report is silent from its file name.
+     *
+     * @param reportFileName    Name of the report to check whether it should be sent silently.
+     * @return True if the report has been declared explicitly silent using {@link ErrorReporter#handleSilentException(Throwable)}.
+     */
+    public boolean isSilent(@NonNull String reportFileName) {
+        return reportFileName.contains(ACRAConstants.SILENT_SUFFIX);
+    }
+
+    /**
+     * Returns true if the report is considered as approved.
+     * <p>
+          This includes:
+     * </p>
+     * <ul>
+     * <li>Reports which were pending when the user agreed to send a report in the NOTIFICATION mode Dialog.</li>
+     * <li>Explicit silent reports</li>
+     * </ul>
+     *
+     * @param reportFileName    Name of report to check whether it is approved to be sent.
+     * @return True if a report can be sent.
+     */
+    public boolean isApproved(@NonNull String reportFileName) {
+        return isSilent(reportFileName) || reportFileName.contains(ACRAConstants.APPROVED_SUFFIX);
+    }
+}
diff --git a/src/main/java/org/acra/file/CrashReportPersister.java b/src/main/java/org/acra/file/CrashReportPersister.java
new file mode 100644
index 00000000..79a51c88
--- /dev/null
+++ b/src/main/java/org/acra/file/CrashReportPersister.java
@@ -0,0 +1,87 @@
+/*
+ * java.util.Properties.java modified by Kevin Gaudin to allow usage of enums as keys.
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import org.acra.ACRAConstants;
+import org.acra.collector.CrashReportData;
+import org.acra.util.JsonUtils;
+import org.acra.util.IOUtils;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+
+/**
+ * Stores a crash reports data with {@link org.acra.ReportField} enum values as keys.
+ * This is basically the source of {@link java.util.Properties} adapted to extend an
+ * EnumMap instead of Hashtable and with a few tweaks to avoid losing crazy
+ * amounts of android time in the generation of a date comment when storing to
+ * file.
+ */
+public final class CrashReportPersister {
+    private static final String CHARSET = "UTF-8";
+
+    /**
+     * Loads properties from the specified {@code File}.
+     *
+     * @param file  Report file from which to load the CrashData.
+     * @return CrashReportData read from the supplied File.
+     * @throws IOException if error occurs during reading from the {@code File}.
+     * @throws JSONException if the stream cannot be parsed as a JSON object.
+     */
+    @NonNull
+    public CrashReportData load(@NonNull File file) throws IOException, JSONException {
+
+        final InputStream in = new BufferedInputStream(new FileInputStream(file), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            return JsonUtils.toCrashReportData(new JSONObject(IOUtils.streamToString(in)));
+        }finally {
+            IOUtils.safeClose(in);
+        }
+    }
+
+    /**
+     * Stores the mappings in this Properties to the specified OutputStream,
+     * putting the specified comment at the beginning. The output from this
+     * method is suitable for being read by the load() method.
+     *
+     * @param crashData     CrashReportData to save.
+     * @param file          File into which to store the CrashReportData.
+     * @throws java.io.IOException if the CrashReportData could not be written to the OutputStream.
+     */
+    public void store(@NonNull CrashReportData crashData, @NonNull File file) throws IOException {
+
+        final OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), CHARSET);
+        try {
+            writer.write(crashData.toJSON().toString());
+            writer.flush();
+        } finally {
+            IOUtils.safeClose(writer);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/file/Directory.java b/src/main/java/org/acra/file/Directory.java
new file mode 100644
index 00000000..739c0691
--- /dev/null
+++ b/src/main/java/org/acra/file/Directory.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.acra.file;
+
+import android.content.Context;
+import android.os.Environment;
+
+/**
+ * @author F43nd1r
+ * @since 4.9.1
+ */
+public enum Directory {
+    /**
+     * Legacy behaviour:
+     * If the string starts with a path separator, this behaves like {@link #ROOT}.
+     * Otherwise it behaves like {@link #FILES}.
+     */
+    FILES_LEGACY,
+    /**
+     * Directory returned by {@link Context#getFilesDir()}
+     */
+    FILES,
+    /**
+     * Directory returned by {@link Context#getExternalFilesDir(String)}
+     */
+    EXTERNAL_FILES,
+    /**
+     * Directory returned by {@link Context#getCacheDir()}
+     */
+    CACHE,
+    /**
+     * Directory returned by {@link Context#getExternalCacheDir()}
+     */
+    EXTERNAL_CACHE,
+    /**
+     * Directory returned by {@link Context#getNoBackupFilesDir()}.
+     * Will fall back to {@link Context#getFilesDir()} on API &lt; 21
+     */
+    NO_BACKUP_FILES,
+    /**
+     * Directory returned by {@link Environment#getExternalStorageDirectory()}
+     */
+    EXTERNAL_STORAGE,
+    /**
+     * Root Directory, paths in this directory are absolute paths
+     */
+    ROOT
+}
diff --git a/src/main/java/org/acra/file/LastModifiedComparator.java b/src/main/java/org/acra/file/LastModifiedComparator.java
new file mode 100644
index 00000000..a12a5e18
--- /dev/null
+++ b/src/main/java/org/acra/file/LastModifiedComparator.java
@@ -0,0 +1,18 @@
+package org.acra.file;
+
+import android.support.annotation.NonNull;
+
+import java.io.File;
+import java.util.Comparator;
+
+/**
+ * Orders files from oldest to newest based on their last modified date.
+ */
+final class LastModifiedComparator implements Comparator<File> {
+    @Override
+    public int compare(@NonNull File lhs, @NonNull File rhs) {
+        long l = lhs.lastModified();
+        long r = rhs.lastModified();
+        return l < r ? -1 : (l == r ? 0 : 1);
+    }
+}
diff --git a/src/main/java/org/acra/file/ReportLocator.java b/src/main/java/org/acra/file/ReportLocator.java
new file mode 100644
index 00000000..838a145c
--- /dev/null
+++ b/src/main/java/org/acra/file/ReportLocator.java
@@ -0,0 +1,58 @@
+package org.acra.file;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import java.io.File;
+import java.util.Arrays;
+
+/**
+ * Locates crash reports.
+ *
+ * @author William Ferguson
+ * @since 4.8.0
+ */
+public final class ReportLocator {
+
+    // Folders under the app folder.
+    private static final String UNAPPROVED_FOLDER_NAME = "ACRA-unapproved";
+    private static final String APPROVED_FOLDER_NAME = "ACRA-approved";
+
+    private final Context context;
+
+    public ReportLocator(@NonNull Context context) {
+        this.context = context;
+    }
+
+    @NonNull
+    public File getUnapprovedFolder() {
+        return context.getDir(UNAPPROVED_FOLDER_NAME, Context.MODE_PRIVATE);
+    }
+
+    @NonNull
+    public File[] getUnapprovedReports() {
+        final File[] reports = getUnapprovedFolder().listFiles();
+        if (reports == null) {
+            return new File[0];
+        }
+        return reports;
+    }
+
+    @NonNull
+    public File getApprovedFolder() {
+        return context.getDir(APPROVED_FOLDER_NAME, Context.MODE_PRIVATE);
+    }
+
+    /**
+     * @return Approved reports sorted by creation time.
+     */
+    @NonNull
+    public File[] getApprovedReports() {
+        final File[] reports = getApprovedFolder().listFiles();
+        if (reports == null) {
+            return new File[0];
+        }
+        Arrays.sort(reports, new LastModifiedComparator());
+        return reports;
+    }
+}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
deleted file mode 100644
index cb0762fa..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksAdapter.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-/**
- * This adapter class provides empty implementations of the methods from {@link ActivityLifecycleCallbacksCompat}.
- * Any custom listener that cares only about a subset of the methods of this listener can simply subclass this
- * adapter class instead of implementing the interface directly.
- */
-public class ActivityLifecycleCallbacksAdapter implements ActivityLifecycleCallbacksCompat {
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {}
-
-    @Override
-    public void onActivityStarted(Activity activity) {}
-
-    @Override
-    public void onActivityResumed(Activity activity) {}
-
-    @Override
-    public void onActivityPaused(Activity activity) {}
-
-    @Override
-    public void onActivityStopped(Activity activity) {}
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {}
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
deleted file mode 100644
index 0d7f0df8..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksCompat.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-/**
- * Equivalent of {@link ActivityLifecycleCallbacks} to be used with
- * {@link ApplicationHelper#registerActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)} and
- * {@link ApplicationHelper#unregisterActivityLifecycleCallbacks(Application, ActivityLifecycleCallbacksCompat)}.
- */
-public interface ActivityLifecycleCallbacksCompat {
-    void onActivityCreated(Activity activity, Bundle savedInstanceState);
-
-    void onActivityStarted(Activity activity);
-
-    void onActivityResumed(Activity activity);
-
-    void onActivityPaused(Activity activity);
-
-    void onActivityStopped(Activity activity);
-
-    void onActivitySaveInstanceState(Activity activity, Bundle outState);
-
-    void onActivityDestroyed(Activity activity);
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
deleted file mode 100644
index da249637..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ActivityLifecycleCallbacksWrapper.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.app.Activity;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-import java.util.concurrent.Callable;
-
-/**
- * Wraps an {@link ActivityLifecycleCallbacksCompat} into an {@link ActivityLifecycleCallbacks}.
- */
-/* package */class ActivityLifecycleCallbacksWrapper implements ActivityLifecycleCallbacks {
-    private org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat mCallback;
-
-    public ActivityLifecycleCallbacksWrapper(org.acra.jraf.android.util.activitylifecyclecallbackscompat.ActivityLifecycleCallbacksCompat callback) {
-        mCallback = callback;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        mCallback.onActivityCreated(activity, savedInstanceState);
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        mCallback.onActivityStarted(activity);
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        mCallback.onActivityResumed(activity);
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        mCallback.onActivityPaused(activity);
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        mCallback.onActivityStopped(activity);
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        mCallback.onActivitySaveInstanceState(activity, outState);
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        mCallback.onActivityDestroyed(activity);
-    }
-
-    /**
-     * Compare the current wrapped callback with another object wrapped callback
-     */
-    @Override
-    public boolean equals(Object object) {
-        if( !(object instanceof ActivityLifecycleCallbacksWrapper) )
-            return false;
-        ActivityLifecycleCallbacksWrapper that = ( ActivityLifecycleCallbacksWrapper )object;
-        return null == mCallback ? null == that.mCallback : mCallback.equals( that.mCallback );
-    }
-
-    /**
-     *
-     * return wrapped callback object hashCode
-     */
-    @Override
-    public int hashCode() {
-        return null != mCallback ? mCallback.hashCode() : 0;
-    }
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
deleted file mode 100644
index 3c147c69..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/ApplicationHelper.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Build;
-
-/**
- * Helper for accessing {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} introduced in API level 14 in a
- * backwards compatible fashion.<br>
- * When running on API level 14 or above, the framework's implementations of these methods will be used.
- */
-public class ApplicationHelper {
-    public static final boolean PRE_ICS = Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-
-    /*
-     * Register.
-     */
-
-    /**
-     * Registers a callback to be called following the life cycle of the application's {@link Activity activities}.
-     * 
-     * @param application The application with which to register the callback.
-     * @param callback The callback to register.
-     */
-    public static void registerActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        if (PRE_ICS) {
-            preIcsRegisterActivityLifecycleCallbacks(callback);
-        } else {
-            postIcsRegisterActivityLifecycleCallbacks(application, callback);
-        }
-    }
-
-    private static void preIcsRegisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        MainLifecycleDispatcher.get().registerActivityLifecycleCallbacks(callback);
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    private static void postIcsRegisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
-
-
-    /*
-     * Unregister.
-     */
-
-    /**
-     * Unregisters a previously registered callback.
-     * 
-     * @param application The application with which to unregister the callback.
-     * @param callback The callback to unregister.
-     */
-    public void unregisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        if (PRE_ICS) {
-            preIcsUnregisterActivityLifecycleCallbacks(callback);
-        } else {
-            postIcsUnregisterActivityLifecycleCallbacks(application, callback);
-        }
-    }
-
-    private static void preIcsUnregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        MainLifecycleDispatcher.get().unregisterActivityLifecycleCallbacks(callback);
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    private static void postIcsUnregisterActivityLifecycleCallbacks(Application application, ActivityLifecycleCallbacksCompat callback) {
-        application.unregisterActivityLifecycleCallbacks(new ActivityLifecycleCallbacksWrapper(callback));
-    }
-
-}
diff --git a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java b/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
deleted file mode 100644
index de1bb1ed..00000000
--- a/src/main/java/org/acra/jraf/android/util/activitylifecyclecallbackscompat/MainLifecycleDispatcher.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * This source is part of the
- *      _____  ___   ____
- *  __ / / _ \/ _ | / __/___  _______ _
- * / // / , _/ __ |/ _/_/ _ \/ __/ _ `/
- * \___/_/|_/_/ |_/_/ (_)___/_/  \_, /
- *                              /___/
- * repository.
- *
- * Copyright (C) 2013 Benoit 'BoD' Lubek (BoD@JRAF.org)
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.acra.jraf.android.util.activitylifecyclecallbackscompat;
-
-import java.util.ArrayList;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.os.Bundle;
-
-/**
- * Keeps a list of {@link ActivityLifecycleCallbacksCompat}s that will be called following the life cycle of the application's {@link Activity activities}.
- * This class is used when the app is running on an older platform version that does not support
- * {@link Application#registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)} and
- * {@link Application#unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks)}.
- */
-public class MainLifecycleDispatcher implements ActivityLifecycleCallbacksCompat {
-    private static final MainLifecycleDispatcher INSTANCE = new MainLifecycleDispatcher();
-
-    public static MainLifecycleDispatcher get() {
-        return INSTANCE;
-    }
-
-    private MainLifecycleDispatcher() {}
-
-    private ArrayList<ActivityLifecycleCallbacksCompat> mActivityLifecycleCallbacks = new ArrayList<ActivityLifecycleCallbacksCompat>();
-
-    /* package */void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.add(callback);
-        }
-    }
-
-    /* package */void unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacksCompat callback) {
-        synchronized (mActivityLifecycleCallbacks) {
-            mActivityLifecycleCallbacks.remove(callback);
-        }
-    }
-
-    private Object[] collectActivityLifecycleCallbacks() {
-        Object[] callbacks = null;
-        synchronized (mActivityLifecycleCallbacks) {
-            if (mActivityLifecycleCallbacks.size() > 0) {
-                callbacks = mActivityLifecycleCallbacks.toArray();
-            }
-        }
-        return callbacks;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityCreated(activity, savedInstanceState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStarted(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityResumed(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityPaused(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityStopped(activity);
-            }
-        }
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivitySaveInstanceState(activity, outState);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        Object[] callbacks = collectActivityLifecycleCallbacks();
-        if (callbacks != null) {
-            for (Object callback : callbacks) {
-                ((ActivityLifecycleCallbacksCompat) callback).onActivityDestroyed(activity);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/acra/legacy/LegacyFileHandler.java b/src/main/java/org/acra/legacy/LegacyFileHandler.java
new file mode 100644
index 00000000..e73638a2
--- /dev/null
+++ b/src/main/java/org/acra/legacy/LegacyFileHandler.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.legacy;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import org.acra.prefs.PrefUtils;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+public class LegacyFileHandler {
+    private static final String PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0 = "acra.legacyAlreadyConvertedTo4.8.0";
+    private static final String PREF__LEGACY_ALREADY_CONVERTED_TO_JSON = "acra.legacyAlreadyConvertedToJson";
+    private final Context context;
+    private final SharedPreferences prefs;
+
+    public LegacyFileHandler(Context context, SharedPreferences prefs) {
+        this.context = context;
+        this.prefs = prefs;
+    }
+
+    public void updateToCurrentVersionIfNecessary(){
+        // Check prefs to see if we have converted from legacy (pre 4.8.0) ACRA
+        if (!prefs.getBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0, false)) {
+            // If not then move reports to approved/unapproved folders and mark as converted.
+            new ReportMigrator(context).migrate();
+
+            // Mark as converted.
+            final SharedPreferences.Editor editor = prefs.edit().putBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_4_8_0, true);
+            PrefUtils.save(editor);
+        }
+        if(!prefs.getBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_JSON, false)){
+            new ReportConverter(context).convert();
+
+            // Mark as converted.
+            final SharedPreferences.Editor editor = prefs.edit().putBoolean(PREF__LEGACY_ALREADY_CONVERTED_TO_JSON, true);
+            PrefUtils.save(editor);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/legacy/ReportConverter.java b/src/main/java/org/acra/legacy/ReportConverter.java
new file mode 100644
index 00000000..9ee145d2
--- /dev/null
+++ b/src/main/java/org/acra/legacy/ReportConverter.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.legacy;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.ReportField;
+import org.acra.file.CrashReportPersister;
+import org.acra.file.ReportLocator;
+import org.acra.model.BooleanElement;
+import org.acra.model.ComplexElement;
+import org.acra.collector.CrashReportData;
+import org.acra.model.Element;
+import org.acra.model.NumberElement;
+import org.acra.model.StringElement;
+import org.acra.util.IOUtils;
+import org.json.JSONException;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Converts acras old file format to json
+ *
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+class ReportConverter {
+    private static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;
+    private final Context context;
+
+    ReportConverter(Context context) {
+        this.context = context;
+    }
+
+    void convert() {
+        ACRA.log.i(LOG_TAG, "Converting unsent ACRA reports to json");
+        final ReportLocator locator = new ReportLocator(context);
+        final CrashReportPersister persister = new CrashReportPersister();
+        final List<File> reportFiles = new ArrayList<File>();
+        reportFiles.addAll(Arrays.asList(locator.getUnapprovedReports()));
+        reportFiles.addAll(Arrays.asList(locator.getApprovedReports()));
+        int converted = 0;
+        for (File report : reportFiles) {
+            InputStream in = null;
+            try {
+                in = new BufferedInputStream(new FileInputStream(report), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+                CrashReportData data = legacyLoad(new InputStreamReader(in, "ISO8859-1")); //$NON-NLS-1$
+                if (data.containsKey(ReportField.REPORT_ID) && data.containsKey(ReportField.USER_CRASH_DATE)) {
+                    persister.store(data, report);
+                } else {
+                    //reports without these keys are probably invalid
+                    IOUtils.deleteReport(report);
+                }
+            } catch (IOException e) {
+                ACRA.log.w(LOG_TAG, "Unable to read report file " + report.getPath(), e);
+            } finally {
+                IOUtils.safeClose(in);
+            }
+        }
+        ACRA.log.i(LOG_TAG, "Converted " + converted + " unsent reports");
+    }
+
+
+    /**
+     * Loads properties from the specified InputStream. The properties are of
+     * the form <code>key=value</code>, one property per line. It may be not
+     * encode as 'ISO-8859-1'.The {@code Properties} file is interpreted
+     * according to the following rules:
+     * <ul>
+     * <li>Empty lines are ignored.</li>
+     * <li>Lines starting with either a "#" or a "!" are comment lines and are
+     * ignored.</li>
+     * <li>A backslash at the end of the line escapes the following newline
+     * character ("\r", "\n", "\r\n"). If there's a whitespace after the
+     * backslash it will just escape that whitespace instead of concatenating
+     * the lines. This does not apply to comment lines.</li>
+     * <li>A property line consists of the key, the space between the key and
+     * the value, and the value. The key goes up to the first whitespace, "=" or
+     * ":" that is not escaped. The space between the key and the value contains
+     * either one whitespace, one "=" or one ":" and any number of additional
+     * whitespaces before and after that character. The value starts with the
+     * first character after the space between the key and the value.</li>
+     * <li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",
+     * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>
+     * </ul>
+     *
+     * @param reader Reader from which to read the properties of this CrashReportData.
+     * @return CrashReportData read from the supplied Reader.
+     * @throws java.io.IOException if the properties could not be read.
+     * @since 1.6
+     */
+    @NonNull
+    private synchronized CrashReportData legacyLoad(@NonNull Reader reader) throws IOException {
+        int mode = NONE, unicode = 0, count = 0;
+        char nextChar;
+        char[] buf = new char[40];
+        int offset = 0, keyLength = -1, intVal;
+        boolean firstChar = true;
+
+        final CrashReportData crashData = new CrashReportData();
+        final BufferedReader br = new BufferedReader(reader, ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            while (true) {
+                intVal = br.read();
+                if (intVal == -1) {
+                    break;
+                }
+                nextChar = (char) intVal;
+
+                if (offset == buf.length) {
+                    final char[] newBuf = new char[buf.length * 2];
+                    System.arraycopy(buf, 0, newBuf, 0, offset);
+                    buf = newBuf;
+                }
+                if (mode == UNICODE) {
+                    final int digit = Character.digit(nextChar, 16);
+                    if (digit >= 0) {
+                        unicode = (unicode << 4) + digit;
+                        if (++count < 4) {
+                            continue;
+                        }
+                    } else if (count <= 4) {
+                        // luni.09=Invalid Unicode sequence: illegal character
+                        throw new IllegalArgumentException("luni.09");
+                    }
+                    mode = NONE;
+                    buf[offset++] = (char) unicode;
+                    if (nextChar != '\n' && nextChar != '\u0085') {
+                        continue;
+                    }
+                }
+                if (mode == SLASH) {
+                    mode = NONE;
+                    switch (nextChar) {
+                        case '\r':
+                            mode = CONTINUE; // Look for a following \n
+                            continue;
+                        case '\u0085':
+                        case '\n':
+                            mode = IGNORE; // Ignore whitespace on the next line
+                            continue;
+                        case 'b':
+                            nextChar = '\b';
+                            break;
+                        case 'f':
+                            nextChar = '\f';
+                            break;
+                        case 'n':
+                            nextChar = '\n';
+                            break;
+                        case 'r':
+                            nextChar = '\r';
+                            break;
+                        case 't':
+                            nextChar = '\t';
+                            break;
+                        case 'u':
+                            mode = UNICODE;
+                            unicode = count = 0;
+                            continue;
+                    }
+                } else {
+                    switch (nextChar) {
+                        case '#':
+                        case '!':
+                            if (firstChar) {
+                                while (true) {
+                                    intVal = br.read();
+                                    if (intVal == -1) {
+                                        break;
+                                    }
+                                    nextChar = (char) intVal; // & 0xff
+                                    // not
+                                    // required
+                                    if (nextChar == '\r' || nextChar == '\n' || nextChar == '\u0085') {
+                                        break;
+                                    }
+                                }
+                                continue;
+                            }
+                            break;
+                        case '\n':
+                            if (mode == CONTINUE) { // Part of a \r\n sequence
+                                mode = IGNORE; // Ignore whitespace on the next line
+                                continue;
+                            }
+                            // fall into the next case
+                        case '\u0085':
+                        case '\r':
+                            mode = NONE;
+                            firstChar = true;
+                            if (offset > 0 || (offset == 0 && keyLength == 0)) {
+                                if (keyLength == -1) {
+                                    keyLength = offset;
+                                }
+                                final String temp = new String(buf, 0, offset);
+                                final String elementString = temp.substring(keyLength);
+                                Element element;
+                                try {
+                                    element = new ComplexElement(elementString);
+                                } catch (JSONException e1) {
+                                    try {
+                                        element = new NumberElement(Double.valueOf(elementString));
+                                    } catch (NumberFormatException e2) {
+                                        if (elementString.equals("true")) {
+                                            element = new BooleanElement(true);
+                                        } else if (elementString.equals("false")) {
+                                            element = new BooleanElement(false);
+                                        } else {
+                                            element = new StringElement(elementString);
+                                        }
+                                    }
+                                }
+                                crashData.put(Enum.valueOf(ReportField.class, temp.substring(0, keyLength)), element);
+                            }
+                            keyLength = -1;
+                            offset = 0;
+                            continue;
+                        case '\\':
+                            if (mode == KEY_DONE) {
+                                keyLength = offset;
+                            }
+                            mode = SLASH;
+                            continue;
+                        case ':':
+                        case '=':
+                            if (keyLength == -1) { // if parsing the key
+                                mode = NONE;
+                                keyLength = offset;
+                                continue;
+                            }
+                            break;
+                    }
+                    if (Character.isWhitespace(nextChar)) {
+                        if (mode == CONTINUE) {
+                            mode = IGNORE;
+                        }
+                        // if key length == 0 or value length == 0
+                        if (offset == 0 || offset == keyLength || mode == IGNORE) {
+                            continue;
+                        }
+                        if (keyLength == -1) { // if parsing the key
+                            mode = KEY_DONE;
+                            continue;
+                        }
+                    }
+                    if (mode == IGNORE || mode == CONTINUE) {
+                        mode = NONE;
+                    }
+                }
+                firstChar = false;
+                if (mode == KEY_DONE) {
+                    keyLength = offset;
+                    mode = NONE;
+                }
+                buf[offset++] = nextChar;
+            }
+            if (mode == UNICODE && count <= 4) {
+                // luni.08=Invalid Unicode sequence: expected format \\uxxxx
+                throw new IllegalArgumentException("luni.08");
+            }
+            if (keyLength == -1 && offset > 0) {
+                keyLength = offset;
+            }
+            if (keyLength >= 0) {
+                final String temp = new String(buf, 0, offset);
+                final ReportField key = Enum.valueOf(ReportField.class, temp.substring(0, keyLength));
+                String value = temp.substring(keyLength);
+                if (mode == SLASH) {
+                    value += "\u0000";
+                }
+                Element element;
+                try {
+                    element = new ComplexElement(value);
+                } catch (JSONException e1) {
+                    try {
+                        element = new NumberElement(Double.valueOf(value));
+                    } catch (NumberFormatException e2) {
+                        if (value.equals("true")) {
+                            element = new BooleanElement(true);
+                        } else if (value.equals("false")) {
+                            element = new BooleanElement(false);
+                        } else {
+                            element = new StringElement(value);
+                        }
+                    }
+                }
+                crashData.put(key, element);
+            }
+
+            IOUtils.safeClose(reader);
+
+            return crashData;
+        } finally {
+            IOUtils.safeClose(br);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/legacy/ReportMigrator.java b/src/main/java/org/acra/legacy/ReportMigrator.java
new file mode 100644
index 00000000..f6abe927
--- /dev/null
+++ b/src/main/java/org/acra/legacy/ReportMigrator.java
@@ -0,0 +1,78 @@
+package org.acra.legacy;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+
+import java.io.File;
+import java.io.FilenameFilter;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Migrates reports from the pre 4.8.0 location to the 4.8.0+ locations.
+ */
+final class ReportMigrator {
+
+    private final Context context;
+    private final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+    @NonNull
+    private final ReportLocator reportLocator;
+
+    ReportMigrator(@NonNull Context context) {
+        this.context = context;
+        this.reportLocator = new ReportLocator(context);
+    }
+
+    void migrate() {
+        ACRA.log.i(LOG_TAG, "Migrating unsent ACRA reports to new file locations");
+
+        final File[] reportFiles = getCrashReportFiles();
+
+        for (final File file : reportFiles) {
+            // Move it to unapproved or approved folders.
+            final String fileName = file.getName();
+            if (fileNameParser.isApproved(fileName)) {
+                if (file.renameTo(new File(reportLocator.getApprovedFolder(), fileName))) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Cold not migrate unsent ACRA crash report : " + fileName);
+                }
+            } else {
+                if (file.renameTo(new File(reportLocator.getUnapprovedFolder(), fileName))) {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Cold not migrate unsent ACRA crash report : " + fileName);
+                }
+            }
+        }
+        ACRA.log.i(LOG_TAG, "Migrated " + reportFiles.length + " unsent reports");
+    }
+
+    /**
+     * Returns an array containing the names of pending crash report files.
+     *
+     * @return an array containing the names of pending crash report files.
+     */
+    @NonNull
+    private File[] getCrashReportFiles() {
+        final File dir = context.getFilesDir();
+        if (dir == null) {
+            ACRA.log.w(LOG_TAG, "Application files directory does not exist! The application may not be installed correctly. Please try reinstalling.");
+            return new File[0];
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Looking for error files in " + dir.getAbsolutePath());
+
+        // Filter for ".stacktrace" files
+        final FilenameFilter filter = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, @NonNull String name) {
+                return name.endsWith(ACRAConstants.REPORTFILE_EXTENSION);
+            }
+        };
+        final File[] result = dir.listFiles(filter);
+        return (result == null) ? new File[0] : result;
+    }
+
+}
diff --git a/src/main/java/org/acra/log/ACRALog.java b/src/main/java/org/acra/log/ACRALog.java
index 482b4aba..1f70afd6 100644
--- a/src/main/java/org/acra/log/ACRALog.java
+++ b/src/main/java/org/acra/log/ACRALog.java
@@ -1,5 +1,7 @@
 package org.acra.log;
 
+import android.support.annotation.Nullable;
+
 /**
  * Responsible for providing ACRA classes with a platform neutral way of logging.
  * <p>
@@ -10,18 +12,19 @@
  * @since 4.3.0
  */
 public interface ACRALog {
-    public int v(java.lang.String tag, java.lang.String msg);
-    public int v(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int d(java.lang.String tag, java.lang.String msg);
-    public int d(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int i(java.lang.String tag, java.lang.String msg);
-    public int i(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public int w(java.lang.String tag, java.lang.String msg);
-    public int w(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int v(java.lang.String tag, java.lang.String msg);
+    int v(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int d(java.lang.String tag, java.lang.String msg);
+    int d(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int i(java.lang.String tag, java.lang.String msg);
+    int i(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    int w(java.lang.String tag, java.lang.String msg);
+    int w(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
     //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(java.lang.String tag, java.lang.Throwable tr);
-    public int e(java.lang.String tag, java.lang.String msg);
-    public int e(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
-    public java.lang.String getStackTraceString(java.lang.Throwable tr);
+    int w(java.lang.String tag, java.lang.Throwable tr);
+    int e(java.lang.String tag, java.lang.String msg);
+    int e(java.lang.String tag, java.lang.String msg, java.lang.Throwable tr);
+    @Nullable
+    java.lang.String getStackTraceString(java.lang.Throwable tr);
     //public native  int println(int priority, java.lang.String tag, java.lang.String msg);
 }
diff --git a/src/main/java/org/acra/log/AndroidLogDelegate.java b/src/main/java/org/acra/log/AndroidLogDelegate.java
index bd2a366c..be95efa0 100644
--- a/src/main/java/org/acra/log/AndroidLogDelegate.java
+++ b/src/main/java/org/acra/log/AndroidLogDelegate.java
@@ -5,45 +5,57 @@
 
 /**
  * Responsible for delegating calls to the Android logging system.
- * <p/>
+ *
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class AndroidLogDelegate implements ACRALog {
+    @Override
     public int v(String tag, String msg) {
         return Log.v(tag, msg);
     }
+    @Override
     public int v(String tag, String msg, Throwable tr) {
         return Log.v(tag, msg, tr);
     }
+    @Override
     public int d(String tag, String msg) {
         return Log.d(tag, msg);
     }
+    @Override
     public int d(String tag, String msg, Throwable tr) {
         return Log.d(tag, msg, tr);
     }
+    @Override
     public int i(String tag, String msg) {
         return Log.i(tag, msg);
     }
+    @Override
     public int i(String tag, String msg, Throwable tr) {
         return Log.i(tag, msg, tr);
     }
+    @Override
     public int w(String tag, String msg) {
         return Log.w(tag, msg);
     }
+    @Override
     public int w(String tag, String msg, Throwable tr) {
         return Log.w(tag, msg, tr);
     }
     //public native  boolean isLoggable(java.lang.String tag, int level);
+    @Override
     public int w(String tag, Throwable tr) {
         return Log.w(tag, tr);
     }
+    @Override
     public int e(String tag, String msg) {
         return Log.e(tag, msg);
     }
+    @Override
     public int e(String tag, String msg, Throwable tr) {
         return Log.e(tag, msg, tr);
     }
+    @Override
     public String getStackTraceString(Throwable tr) {
         return Log.getStackTraceString(tr);
     }
diff --git a/src/main/java/org/acra/log/HollowLog.java b/src/main/java/org/acra/log/HollowLog.java
new file mode 100644
index 00000000..94b2cb6c
--- /dev/null
+++ b/src/main/java/org/acra/log/HollowLog.java
@@ -0,0 +1,70 @@
+package org.acra.log;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Stub implementation of {@link org.acra.log.ACRALog}, quenches all logging.
+ */
+@SuppressWarnings("unused")
+public final class HollowLog implements ACRALog {
+    @Override
+    public int v(String tag, String msg) {
+        return 0;
+    }
+
+    @Override
+    public int v(String tag, String msg, Throwable tr) {
+        return 0;
+    }
+
+    @Override
+    public int d(String tag, String msg) {
+        return 0;
+    }
+
+    @Override
+    public int d(String tag, String msg, Throwable tr) {
+        return 0;
+    }
+
+    @Override
+    public int i(String tag, String msg) {
+        return 0;
+    }
+
+    @Override
+    public int i(String tag, String msg, Throwable tr) {
+        return 0;
+    }
+
+    @Override
+    public int w(String tag, String msg) {
+        return 0;
+    }
+
+    @Override
+    public int w(String tag, String msg, Throwable tr) {
+        return 0;
+    }
+
+    @Override
+    public int w(String tag, Throwable tr) {
+        return 0;
+    }
+
+    @Override
+    public int e(String tag, String msg) {
+        return 0;
+    }
+
+    @Override
+    public int e(String tag, String msg, Throwable tr) {
+        return 0;
+    }
+
+    @Nullable
+    @Override
+    public String getStackTraceString(Throwable tr) {
+        return null;
+    }
+}
diff --git a/src/main/java/org/acra/model/BooleanElement.java b/src/main/java/org/acra/model/BooleanElement.java
new file mode 100644
index 00000000..29559568
--- /dev/null
+++ b/src/main/java/org/acra/model/BooleanElement.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 13.10.2016
+ */
+
+public class BooleanElement implements Element {
+    private final boolean content;
+
+    public BooleanElement(boolean content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{toString()};
+    }
+
+    @Override
+    public String toString() {
+        return String.valueOf(content);
+    }
+}
diff --git a/src/main/java/org/acra/model/ComplexElement.java b/src/main/java/org/acra/model/ComplexElement.java
new file mode 100644
index 00000000..7e2a9f84
--- /dev/null
+++ b/src/main/java/org/acra/model/ComplexElement.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+import android.support.annotation.NonNull;
+
+import org.acra.util.JsonUtils;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Map;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public class ComplexElement extends JSONObject implements Element {
+    public ComplexElement() {
+    }
+
+    public ComplexElement(String json) throws JSONException {
+        super(json);
+    }
+
+    public ComplexElement(Map<String, ?> copyFrom) {
+        super(copyFrom);
+    }
+
+    public ComplexElement(JSONObject copyFrom) throws JSONException {
+        super(copyFrom, getNames(copyFrom));
+    }
+
+    @NonNull
+    private static String[] getNames(JSONObject object) throws JSONException {
+        JSONArray json = object.names();
+        if(json != null) {
+            String[] names = new String[json.length()];
+            for (int i = 0; i < json.length(); i++) {
+                names[i] = json.getString(i);
+            }
+            return names;
+        }
+        return new String[0];
+    }
+
+    @Override
+    public Object value() {
+        return this;
+    }
+
+    @Override
+    public String[] flatten() {
+        try {
+            return JsonUtils.flatten(this).toArray(new String[0]);
+        } catch (JSONException e) {
+            return new String[0];
+        }
+    }
+}
diff --git a/src/main/java/org/acra/model/Element.java b/src/main/java/org/acra/model/Element.java
new file mode 100644
index 00000000..7e7e1ac0
--- /dev/null
+++ b/src/main/java/org/acra/model/Element.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public interface Element {
+    /**
+     * @return this elements json value.
+     * This must be one of the valid json types: bull, boolean, number, String, JSONObject or JSONArray
+     */
+    Object value();
+
+    String[] flatten();
+}
diff --git a/src/main/java/org/acra/model/NumberElement.java b/src/main/java/org/acra/model/NumberElement.java
new file mode 100644
index 00000000..98c8109d
--- /dev/null
+++ b/src/main/java/org/acra/model/NumberElement.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 13.10.2016
+ */
+
+public class NumberElement implements Element {
+    private final Number content;
+
+    public NumberElement(Number content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{toString()};
+    }
+
+    @Override
+    public String toString() {
+        return content.toString();
+    }
+}
diff --git a/src/main/java/org/acra/model/StringElement.java b/src/main/java/org/acra/model/StringElement.java
new file mode 100644
index 00000000..8d33b72f
--- /dev/null
+++ b/src/main/java/org/acra/model/StringElement.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.model;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+public class StringElement implements Element {
+    private final String content;
+
+    public StringElement(String content) {
+        this.content = content;
+    }
+
+    @Override
+    public Object value() {
+        return content;
+    }
+
+    @Override
+    public String[] flatten() {
+        return new String[]{content};
+    }
+
+    @Override
+    public String toString() {
+        return content;
+    }
+}
diff --git a/src/main/java/org/acra/prefs/PrefUtils.java b/src/main/java/org/acra/prefs/PrefUtils.java
new file mode 100644
index 00000000..1359c6b5
--- /dev/null
+++ b/src/main/java/org/acra/prefs/PrefUtils.java
@@ -0,0 +1,17 @@
+package org.acra.prefs;
+
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+public final class PrefUtils {
+    private PrefUtils(){}
+
+    public static void save(@NonNull SharedPreferences.Editor editor) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            editor.apply();
+        } else {
+            editor.commit();
+        }
+    }
+}
diff --git a/src/main/java/org/acra/prefs/SharedPreferencesFactory.java b/src/main/java/org/acra/prefs/SharedPreferencesFactory.java
new file mode 100644
index 00000000..c9695c79
--- /dev/null
+++ b/src/main/java/org/acra/prefs/SharedPreferencesFactory.java
@@ -0,0 +1,44 @@
+package org.acra.prefs;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
+
+import org.acra.annotation.ReportsCrashes;
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Responsible for creating a SharedPreferences instance which stores ACRA settings.
+ * <p>
+ * Retrieves the {@link SharedPreferences} instance where user adjustable
+ * settings for ACRA are stored. Default are the Application default
+ * SharedPreferences, but you can provide another SharedPreferences name
+ * with {@link ReportsCrashes#sharedPreferencesName()}.
+ * </p>
+ */
+public class SharedPreferencesFactory {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public SharedPreferencesFactory(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * @return The Shared Preferences where ACRA will retrieve its user adjustable setting.
+     */
+    @NonNull
+    public SharedPreferences create() {
+        //noinspection ConstantConditions
+        if (context == null) {
+            throw new IllegalStateException("Cannot call ACRA.getACRASharedPreferences() before ACRA.init().");
+        } else if (!"".equals(config.sharedPreferencesName())) {
+            return context.getSharedPreferences(config.sharedPreferencesName(), config.sharedPreferencesMode());
+        } else {
+            return PreferenceManager.getDefaultSharedPreferences(context);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/security/AssetKeyStoreFactory.java b/src/main/java/org/acra/security/AssetKeyStoreFactory.java
new file mode 100644
index 00000000..9f3779a6
--- /dev/null
+++ b/src/main/java/org/acra/security/AssetKeyStoreFactory.java
@@ -0,0 +1,57 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * KeyStoreFactory for a certificate stored in an asset file
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class AssetKeyStoreFactory extends BaseKeyStoreFactory {
+
+    private final String assetName;
+
+    /**
+     * creates a new KeyStoreFactory for the specified asset with a custom certificate type
+     * @param certificateType the certificate type
+     * @param assetName the asset
+     */
+    AssetKeyStoreFactory(String certificateType, String assetName) {
+        super(certificateType);
+        this.assetName = assetName;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        try {
+            return context.getAssets().open(assetName);
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "Could not open certificate in asset://"+assetName, e);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/org/acra/security/BaseKeyStoreFactory.java b/src/main/java/org/acra/security/BaseKeyStoreFactory.java
new file mode 100644
index 00000000..b51c9821
--- /dev/null
+++ b/src/main/java/org/acra/security/BaseKeyStoreFactory.java
@@ -0,0 +1,117 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.util.IOUtils;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Provides base KeyStoreFactory implementation
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public abstract class BaseKeyStoreFactory implements KeyStoreFactory {
+
+    public enum Type {
+        CERTIFICATE,
+        KEYSTORE
+    }
+
+    private final String certificateType;
+
+    /**
+     * creates a new KeyStoreFactory for the default certificate type {@link ACRAConstants#DEFAULT_CERTIFICATE_TYPE}
+     */
+    public BaseKeyStoreFactory() {
+        this(ACRAConstants.DEFAULT_CERTIFICATE_TYPE);
+    }
+
+    /**
+     * creates a new KeyStoreFactory with the specified certificate type
+     *
+     * @param certificateType the certificate type
+     */
+    public BaseKeyStoreFactory(String certificateType) {
+        this.certificateType = certificateType;
+    }
+
+    protected abstract InputStream getInputStream(@NonNull Context context);
+
+    protected String getKeyStoreType() {
+        return KeyStore.getDefaultType();
+    }
+
+    protected Type getStreamType() {
+        return Type.CERTIFICATE;
+    }
+
+    protected char[] getPassword() {
+        return null;
+    }
+
+    @Override
+    @Nullable
+    public final KeyStore create(@NonNull Context context) {
+        final InputStream inputStream = getInputStream(context);
+        if (inputStream != null) {
+            final BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);
+            try {
+                final KeyStore keyStore = KeyStore.getInstance(getKeyStoreType());
+                switch (getStreamType()) {
+                    case CERTIFICATE:
+                        final CertificateFactory certificateFactory = CertificateFactory.getInstance(certificateType);
+                        final Certificate certificate = certificateFactory.generateCertificate(bufferedInputStream);
+                        keyStore.load(null, null);
+                        keyStore.setCertificateEntry("ca", certificate);
+                        break;
+                    case KEYSTORE:
+                        keyStore.load(bufferedInputStream, getPassword());
+                }
+                return keyStore;
+            } catch (CertificateException e) {
+                ACRA.log.e(LOG_TAG, "Could not load certificate", e);
+            } catch (KeyStoreException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } catch (NoSuchAlgorithmException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } catch (IOException e) {
+                ACRA.log.e(LOG_TAG, "Could not load keystore", e);
+            } finally {
+                IOUtils.safeClose(bufferedInputStream);
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/org/acra/security/FileKeyStoreFactory.java b/src/main/java/org/acra/security/FileKeyStoreFactory.java
new file mode 100644
index 00000000..3aaa9d02
--- /dev/null
+++ b/src/main/java/org/acra/security/FileKeyStoreFactory.java
@@ -0,0 +1,58 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * KeyStoreFactory for a certificate stored in a file
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class FileKeyStoreFactory extends BaseKeyStoreFactory {
+
+    private final String filePath;
+
+    /**
+     * creates a new KeyStoreFactory for the specified file with a custom certificate type
+     * @param certificateType the certificate type
+     * @param filePath path to the file
+     */
+    FileKeyStoreFactory(String certificateType, String filePath) {
+        super(certificateType);
+        this.filePath = filePath;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        try {
+            return new FileInputStream(filePath);
+        } catch (FileNotFoundException e) {
+            ACRA.log.e(LOG_TAG, "Could not find File "+filePath, e);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/org/acra/security/KeyStoreFactory.java b/src/main/java/org/acra/security/KeyStoreFactory.java
new file mode 100644
index 00000000..abd981c0
--- /dev/null
+++ b/src/main/java/org/acra/security/KeyStoreFactory.java
@@ -0,0 +1,34 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.security.KeyStore;
+
+/**
+ * The interface can be used to provide a KeyStore with certificates.
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+public interface KeyStoreFactory {
+
+    @Nullable
+    KeyStore create(@NonNull Context context);
+}
diff --git a/src/main/java/org/acra/security/KeyStoreHelper.java b/src/main/java/org/acra/security/KeyStoreHelper.java
new file mode 100644
index 00000000..569b5b4e
--- /dev/null
+++ b/src/main/java/org/acra/security/KeyStoreHelper.java
@@ -0,0 +1,76 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+
+import java.security.KeyStore;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Helper to get a KeyStore from a configuration
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public final class KeyStoreHelper {
+    private static final String ASSET_PREFIX = "asset://";
+
+    private KeyStoreHelper() {
+    }
+
+    /**
+     * try to get the keystore
+     * @param context a context
+     * @param config the configuration
+     * @return the keystore, or null if none provided / failure
+     */
+    @Nullable
+    public static KeyStore getKeyStore(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        final Class<? extends KeyStoreFactory> keyStoreFactory = config.keyStoreFactoryClass();
+        KeyStore keyStore = null;
+        try {
+            keyStore = keyStoreFactory.newInstance().create(context);
+        } catch (InstantiationException e) {
+            ACRA.log.e(LOG_TAG, "Could not get keystore from factory", e);
+        } catch (IllegalAccessException e) {
+            ACRA.log.e(LOG_TAG, "Could not get keystore from factory", e);
+        }
+        if(keyStore == null) {
+            //either users factory did not create a keystore, or the configuration is default {@link NoKeyStoreFactory}
+            final int certificateRes = config.resCertificate();
+            final String certificatePath = config.certificatePath();
+            final String certificateType = config.certificateType();
+            if(certificateRes != ACRAConstants.DEFAULT_RES_VALUE){
+                keyStore = new ResourceKeyStoreFactory(certificateType, certificateRes).create(context);
+            }else if(!certificatePath.equals(ACRAConstants.DEFAULT_STRING_VALUE)){
+                if(certificatePath.startsWith(ASSET_PREFIX)) {
+                    keyStore = new AssetKeyStoreFactory(certificateType, certificatePath.substring(ASSET_PREFIX.length())).create(context);
+                } else {
+                    keyStore = new FileKeyStoreFactory(certificateType, certificatePath).create(context);
+                }
+            }
+        }
+        return keyStore;
+    }
+}
diff --git a/src/main/java/org/acra/security/NoKeyStoreFactory.java b/src/main/java/org/acra/security/NoKeyStoreFactory.java
new file mode 100644
index 00000000..da833424
--- /dev/null
+++ b/src/main/java/org/acra/security/NoKeyStoreFactory.java
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.security.KeyStore;
+
+/**
+ * Default KeyStoreFactory. Does not provide any KeyStore
+ *
+ * @author F43nd1r
+ * @since 4.9.0
+ */
+public class NoKeyStoreFactory implements KeyStoreFactory {
+    @Nullable
+    @Override
+    public KeyStore create(@NonNull Context context) {
+        return null;
+    }
+}
diff --git a/src/main/java/org/acra/security/ResourceKeyStoreFactory.java b/src/main/java/org/acra/security/ResourceKeyStoreFactory.java
new file mode 100644
index 00000000..dc8f1344
--- /dev/null
+++ b/src/main/java/org/acra/security/ResourceKeyStoreFactory.java
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.security;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.RawRes;
+
+import java.io.InputStream;
+
+/**
+ * KeyStoreFactory for a certificate stored in a raw resource
+ *
+ * @author F43nd1r
+ * @since 4.8.3
+ */
+final class ResourceKeyStoreFactory extends BaseKeyStoreFactory {
+
+    @RawRes
+    private final int rawRes;
+
+    /**
+     * creates a new KeyStoreFactory for the specified resource with a custom certificate type
+     * @param certificateType the certificate type
+     * @param rawRes raw resource id
+     */
+    ResourceKeyStoreFactory(String certificateType, @RawRes int rawRes) {
+        super(certificateType);
+        this.rawRes = rawRes;
+    }
+
+    @Override
+    public InputStream getInputStream(@NonNull Context context) {
+        return context.getResources().openRawResource(rawRes);
+    }
+}
diff --git a/src/main/java/org/acra/sender/DefaultReportSenderFactory.java b/src/main/java/org/acra/sender/DefaultReportSenderFactory.java
new file mode 100644
index 00000000..829d0be0
--- /dev/null
+++ b/src/main/java/org/acra/sender/DefaultReportSenderFactory.java
@@ -0,0 +1,49 @@
+package org.acra.sender;
+
+import android.Manifest;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.config.ACRAConfiguration;
+import org.acra.util.PackageManagerWrapper;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Will send reports by email if the 'mailTo' parameter is configured,
+ * otherwise via HTTP if the 'formUri' parameter is configured and
+ * internet permission has been granted.
+ *
+ * If neither 'formUri' or 'mailTo' has been configured, then a NullSender will be returned.
+ */
+public final class DefaultReportSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        final PackageManagerWrapper pm = new PackageManagerWrapper(context);
+        if (!"".equals(config.mailTo())) {
+            // Try to send by mail. If a mailTo address is provided, do not add other senders.
+            ACRA.log.w(LOG_TAG, context.getPackageName() + " reports will be sent by email (if accepted by user).");
+            return new EmailIntentSenderFactory().create(context, config);
+        } else if (!pm.hasPermission(Manifest.permission.INTERNET)) {
+            // NB If the PackageManager has died then this will erroneously log
+            // the error that the App doesn't have Internet (even though it does).
+            // I think that is a small price to pay to ensure that ACRA doesn't
+            // crash if the PackageManager has died.
+            ACRA.log.e(LOG_TAG,
+                    context.getPackageName()
+                            + " should be granted permission "
+                            + Manifest.permission.INTERNET
+                            + " if you want your crash reports to be sent. If you don't want to add this permission to your application you can also enable sending reports by email. If this is your will then provide your email address in @AcraConfig(mailTo=\"your.account@domain.com\"");
+            return new NullSender();
+        } else if (config.formUri() != null && !"".equals(config.formUri())) {
+            // If formUri is set, instantiate a sender for a generic HTTP POST form with default mapping.
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, context.getPackageName() + " reports will be sent by Http.");
+            return new HttpSenderFactory().create(context, config);
+        } else {
+            return new NullSender();
+        }
+    }
+}
diff --git a/src/main/java/org/acra/sender/EmailIntentSender.java b/src/main/java/org/acra/sender/EmailIntentSender.java
index 78cb165c..6b9bce32 100644
--- a/src/main/java/org/acra/sender/EmailIntentSender.java
+++ b/src/main/java/org/acra/sender/EmailIntentSender.java
@@ -15,54 +15,64 @@
  */
 package org.acra.sender;
 
-import org.acra.ACRA;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
 import org.acra.ACRAConstants;
-import org.acra.collector.CrashReportData;
 import org.acra.ReportField;
 import org.acra.annotation.ReportsCrashes;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.collections.ImmutableSet;
+import org.acra.model.Element;
 
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
+import java.util.Set;
 
 /**
- * Send reports through an email intent. The user will be asked to chose his
- * preferred email client. Included report fields can be defined using
+ * Send reports through an email intent.
+ * <p>
+ * The user will be asked to chose his preferred email client. Included report fields can be defined using
  * {@link org.acra.annotation.ReportsCrashes#customReportContent()}. Crash receiving mailbox has to be
  * defined with {@link ReportsCrashes#mailTo()}.
  */
 public class EmailIntentSender implements ReportSender {
 
-    private final Context mContext;
+    private final ACRAConfiguration config;
 
-    public EmailIntentSender(Context ctx) {
-        mContext = ctx;
+    public EmailIntentSender(@NonNull ACRAConfiguration config) {
+        this.config = config;
     }
 
     @Override
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException {
+    public void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException {
 
-        final String subject = mContext.getPackageName() + " Crash Report";
+        final String subject = context.getPackageName() + " Crash Report";
         final String body = buildBody(errorContent);
 
         final Intent emailIntent = new Intent(android.content.Intent.ACTION_SENDTO);
-        emailIntent.setData(Uri.fromParts("mailto", ACRA.getConfig().mailTo(), null));
+        emailIntent.setData(Uri.fromParts("mailto", config.mailTo(), null));
         emailIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
         emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, body);
-        mContext.startActivity(emailIntent);
+        context.startActivity(emailIntent);
     }
 
-    private String buildBody(CrashReportData errorContent) {
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if(fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS;
+    private String buildBody(@NonNull CrashReportData errorContent) {
+        Set<ReportField> fields = config.getReportFields();
+        if (fields.isEmpty()) {
+            fields = new ImmutableSet<ReportField>(ACRAConstants.DEFAULT_MAIL_REPORT_FIELDS);
         }
 
         final StringBuilder builder = new StringBuilder();
         for (ReportField field : fields) {
-            builder.append(field.toString()).append("=");
-            builder.append(errorContent.get(field));
+            builder.append(field.toString()).append('=');
+            Element value = errorContent.get(field);
+            if (value != null) {
+                builder.append(TextUtils.join("\n\t", value.flatten()));
+            }
             builder.append('\n');
         }
         return builder.toString();
diff --git a/src/main/java/org/acra/sender/EmailIntentSenderFactory.java b/src/main/java/org/acra/sender/EmailIntentSenderFactory.java
new file mode 100644
index 00000000..6b23f66a
--- /dev/null
+++ b/src/main/java/org/acra/sender/EmailIntentSenderFactory.java
@@ -0,0 +1,18 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Constructs an {@link EmailIntentSender}.
+ */
+public final class EmailIntentSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        return new EmailIntentSender(config);
+    }
+}
diff --git a/src/main/java/org/acra/sender/HttpSender.java b/src/main/java/org/acra/sender/HttpSender.java
index 690bcbc1..cde8daa2 100644
--- a/src/main/java/org/acra/sender/HttpSender.java
+++ b/src/main/java/org/acra/sender/HttpSender.java
@@ -15,25 +15,29 @@
  */
 package org.acra.sender;
 
-import static org.acra.ACRA.LOG_TAG;
-
-import java.io.IOException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-
 import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
 import org.acra.ACRA;
-import org.acra.ACRAConfiguration;
 import org.acra.ACRAConstants;
 import org.acra.ReportField;
 import org.acra.annotation.ReportsCrashes;
+import org.acra.collections.ImmutableSet;
 import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.model.Element;
 import org.acra.util.HttpRequest;
-import org.acra.util.JSONReportBuilder.JSONReportException;
 
-import android.net.Uri;
-import android.util.Log;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * <p>
@@ -51,23 +55,8 @@
  * </p>
  * 
  * <pre>
- * &#64;ReportsCrashes(...)
- * public class myApplication extends Application {
- * 
- *     public void onCreate() {
- *         super.onCreate();
- *         ACRA.init(this);
- *         Map&lt;ReportField, String&gt; mapping = new HashMap&lt;ReportField, String&gt;();
- *         mapping.put(ReportField.APP_VERSION_CODE, &quot;myAppVerCode'); 
- *         mapping.put(ReportField.APP_VERSION_NAME, &quot;myAppVerName');
- *         //... 
- *         mapping.put(ReportField.USER_EMAIL, &quot;userEmail');
- *         // remove any default report sender
- *         ErrorReporter.getInstance().removeAllReportSenders();
- *         // create your own instance with your specific mapping
- *         ErrorReporter.getInstance().addReportSender(new ReportSender(&quot;http://my.domain.com/reports/receiver.py&quot;, mapping));
- *     }
- * }
+ * Just create and declare a {@link ReportSenderFactory} that constructs a mapping
+ * from each {@link ReportField} to another name.
  * </pre>
  * 
  */
@@ -91,6 +80,7 @@
          * @see <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">Form content types</a>
          */
         FORM {
+            @NonNull
             @Override
             public String getContentType() {
                 return "application/x-www-form-urlencoded";
@@ -100,29 +90,34 @@ public String getContentType() {
          * Send data as a structured JSON tree.
          */
         JSON {
+            @NonNull
             @Override
             public String getContentType() {
                 return "application/json";
             }
         };
 
+        @NonNull
         public abstract String getContentType();
     }
 
+    private final ACRAConfiguration config;
+    @Nullable
     private final Uri mFormUri;
     private final Map<ReportField, String> mMapping;
     private final Method mMethod;
     private final Type mType;
+    @Nullable
     private String mUsername;
+    @Nullable
     private String mPassword;
 
     /**
      * <p>
-     * Create a new HttpSender instance with its destination taken from
-     * {@link ACRA#getConfig()} dynamically. Configuration changes to the
-     * formUri are applied automatically.
+     * Create a new HttpSender instance with its destination taken from the supplied config.
      * </p>
-     * 
+     *
+     * @param config    AcraConfig declaring the
      * @param method
      *            HTTP {@link Method} to be used to send data. Currently only
      *            {@link Method#POST} and {@link Method#PUT} are available. If
@@ -141,13 +136,8 @@ public String getContentType() {
      *            parameters will be named with the result of
      *            mapping.get(ReportField.SOME_FIELD);
      */
-    public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
-        mMethod = method;
-        mFormUri = null;
-        mMapping = mapping;
-        mType = type;
-        mUsername = null;
-        mPassword = null;
+    public HttpSender(@NonNull ACRAConfiguration config, @NonNull Method method, @NonNull Type type, @Nullable Map<ReportField, String> mapping) {
+        this(config, method, type, null, mapping);
     }
 
     /**
@@ -155,7 +145,8 @@ public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
      * Create a new HttpPostSender instance with a fixed destination provided as
      * a parameter. Configuration changes to the formUri are not applied.
      * </p>
-     * 
+     *
+     * @param config    AcraConfig declaring the
      * @param method
      *            HTTP {@link Method} to be used to send data. Currently only
      *            {@link Method#POST} and {@link Method#PUT} are available. If
@@ -175,9 +166,10 @@ public HttpSender(Method method, Type type, Map<ReportField, String> mapping) {
      *            parameters will be named with the result of
      *            mapping.get(ReportField.SOME_FIELD);
      */
-    public HttpSender(Method method, Type type, String formUri, Map<ReportField, String> mapping) {
+    public HttpSender(@NonNull ACRAConfiguration config, @NonNull Method method, @NonNull Type type, @Nullable String formUri, @Nullable Map<ReportField, String> mapping) {
+        this.config = config;
         mMethod = method;
-        mFormUri = Uri.parse(formUri);
+        mFormUri = (formUri == null) ? null : Uri.parse(formUri);
         mMapping = mapping;
         mType = type;
         mUsername = null;
@@ -196,30 +188,27 @@ public HttpSender(Method method, Type type, String formUri, Map<ReportField, Str
      *            The password to set for HTTP Basic Auth.
      */
     @SuppressWarnings( "unused" )
-    public void setBasicAuth(String username, String password) {
+    public void setBasicAuth(@Nullable String username, @Nullable String password) {
         mUsername = username;
         mPassword = password;
     }    
 
     @Override
-    public void send(Context context, CrashReportData report) throws ReportSenderException {
+    public void send(@NonNull Context context, @NonNull CrashReportData report) throws ReportSenderException {
 
         try {
-            URL reportUrl = mFormUri == null ? new URL(ACRA.getConfig().formUri()) : new URL(mFormUri.toString());
-            Log.d(LOG_TAG, "Connect to " + reportUrl.toString());
+            URL reportUrl = mFormUri == null ? new URL(config.formUri()) : new URL(mFormUri.toString());
+            if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Connect to " + reportUrl.toString());
 
-            final String login = mUsername != null ? mUsername : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthLogin()) ? null : ACRA
-                    .getConfig().formUriBasicAuthLogin();
-            final String password = mPassword != null ? mPassword : ACRAConfiguration.isNull(ACRA.getConfig().formUriBasicAuthPassword()) ? null : ACRA
-                    .getConfig().formUriBasicAuthPassword();
+            final String login = mUsername != null ? mUsername : isNull(config.formUriBasicAuthLogin()) ? null : config.formUriBasicAuthLogin();
+            final String password = mPassword != null ? mPassword : isNull(config.formUriBasicAuthPassword()) ? null : config.formUriBasicAuthPassword();
 
-            final HttpRequest request = new HttpRequest();
-            request.setConnectionTimeOut(ACRA.getConfig().connectionTimeout());
-            request.setSocketTimeOut(ACRA.getConfig().socketTimeout());
-            request.setMaxNrRetries(ACRA.getConfig().maxNumberOfRequestRetries());
+            final HttpRequest request = new HttpRequest(config);
+            request.setConnectionTimeOut(config.connectionTimeout());
+            request.setSocketTimeOut(config.socketTimeout());
             request.setLogin(login);
             request.setPassword(password);
-            request.setHeaders(ACRA.getConfig().getHttpHeaders());
+            request.setHeaders(config.getHttpHeaders());
 
             // Generate report body depending on requested type
             final String reportAsString;
@@ -232,7 +221,6 @@ public void send(Context context, CrashReportData report) throws ReportSenderExc
                 final Map<String, String> finalReport = remap(report);
                 reportAsString = HttpRequest.getParamsAsFormString(finalReport);
                 break;
-
             }
 
             // Adjust URL depending on method
@@ -247,31 +235,33 @@ public void send(Context context, CrashReportData report) throws ReportSenderExc
             }
             request.send(context, reportUrl, mMethod, reportAsString, mType);
 
-        } catch (IOException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
-                    + " report via Http " + mMethod.name(), e);
-        } catch (JSONReportException e) {
-            throw new ReportSenderException("Error while sending " + ACRA.getConfig().reportType()
+        } catch (@NonNull IOException e) {
+            throw new ReportSenderException("Error while sending " + config.reportType()
                     + " report via Http " + mMethod.name(), e);
         }
     }
 
-    private Map<String, String> remap(Map<ReportField, String> report) {
+    @NonNull
+    private Map<String, String> remap(@NonNull Map<ReportField, Element> report) {
 
-        ReportField[] fields = ACRA.getConfig().customReportContent();
-        if (fields.length == 0) {
-            fields = ACRAConstants.DEFAULT_REPORT_FIELDS;
+        Set<ReportField> fields = config.getReportFields();
+        if (fields.isEmpty()) {
+            fields = new ImmutableSet<ReportField>(ACRAConstants.DEFAULT_REPORT_FIELDS);
         }
 
         final Map<String, String> finalReport = new HashMap<String, String>(report.size());
         for (ReportField field : fields) {
+            String value = TextUtils.join("\n", report.get(field).flatten());
             if (mMapping == null || mMapping.get(field) == null) {
-                finalReport.put(field.toString(), report.get(field));
+                finalReport.put(field.toString(), value);
             } else {
-                finalReport.put(mMapping.get(field), report.get(field));
+                finalReport.put(mMapping.get(field), value);
             }
         }
         return finalReport;
     }
 
+    private boolean isNull(@Nullable String aString) {
+        return aString == null || ACRAConstants.NULL_VALUE.equals(aString);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/acra/sender/HttpSenderFactory.java b/src/main/java/org/acra/sender/HttpSenderFactory.java
new file mode 100644
index 00000000..b0872635
--- /dev/null
+++ b/src/main/java/org/acra/sender/HttpSenderFactory.java
@@ -0,0 +1,18 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Constructs a {@link HttpSender} with no report field mappings.
+ */
+public final class HttpSenderFactory implements ReportSenderFactory {
+
+    @NonNull
+    @Override
+    public ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        return new HttpSender(config, config.httpMethod(), config.reportType(), null);
+    }
+}
diff --git a/src/main/java/org/acra/sender/NullSender.java b/src/main/java/org/acra/sender/NullSender.java
new file mode 100644
index 00000000..a3539c06
--- /dev/null
+++ b/src/main/java/org/acra/sender/NullSender.java
@@ -0,0 +1,19 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.collector.CrashReportData;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Sends no report.
+ */
+final class NullSender implements ReportSender {
+    @Override
+    public void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException {
+        ACRA.log.w(LOG_TAG, context.getPackageName() + " reports will NOT be sent - no valid ReportSender is configured. Try setting 'formUri' or 'mailTo'");
+    }
+}
diff --git a/src/main/java/org/acra/sender/ReportDistributor.java b/src/main/java/org/acra/sender/ReportDistributor.java
new file mode 100644
index 00000000..40076417
--- /dev/null
+++ b/src/main/java/org/acra/sender/ReportDistributor.java
@@ -0,0 +1,156 @@
+/*
+ *  Copyright 2012 Kevin Gaudin
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.sender;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import org.acra.ACRA;
+import org.acra.collector.CrashReportData;
+import org.acra.config.ACRAConfiguration;
+import org.acra.config.DefaultRetryPolicy;
+import org.acra.config.RetryPolicy;
+import org.acra.file.CrashReportPersister;
+import org.acra.util.IOUtils;
+import org.json.JSONException;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Distributes reports to all Senders.
+ *
+ * @author William Ferguson
+ * @since 4.8.0
+ */
+final class ReportDistributor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final List<ReportSender> reportSenders;
+
+    /**
+     * Creates a new {@link ReportDistributor} to try sending pending reports.
+     *
+     * @param context               ApplicationContext in which the reports are being sent.
+     * @param config                Configuration to use while sending.
+     * @param reportSenders         List of ReportSender to use to send the crash reports.
+     */
+    ReportDistributor(@NonNull Context context, @NonNull ACRAConfiguration config, @NonNull List<ReportSender> reportSenders) {
+        this.context = context;
+        this.config = config;
+        this.reportSenders = reportSenders;
+    }
+
+    /**
+     * Send report via all senders.
+     *
+     * @param reportFile    Report to send.
+     */
+    public void distribute(@NonNull File reportFile) {
+
+        ACRA.log.i(LOG_TAG, "Sending report " + reportFile );
+        try {
+            final CrashReportPersister persister = new CrashReportPersister();
+            final CrashReportData previousCrashReport = persister.load(reportFile);
+            sendCrashReport(previousCrashReport);
+            IOUtils.deleteReport(reportFile);
+        } catch (RuntimeException e) {
+            ACRA.log.e(LOG_TAG, "Failed to send crash reports for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        } catch (IOException e) {
+            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        } catch (JSONException e) {
+            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);
+            IOUtils.deleteReport(reportFile);
+        }catch (ReportSenderException e) {
+            ACRA.log.e(LOG_TAG, "Failed to send crash report for " + reportFile, e);
+            // An issue occurred while sending this report but we can still try to
+            // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS
+            // so there's not much to fear about overloading a failing server.
+        }
+    }
+
+    /**
+     * Sends the report with all configured ReportSenders. If at least one
+     * sender completed its job, the report is considered as sent and will not
+     * be sent again for failing senders.
+     *
+     * @param errorContent  Crash data.
+     * @throws ReportSenderException if unable to send the crash report.
+     */
+    private void sendCrashReport(@NonNull CrashReportData errorContent) throws ReportSenderException {
+        if (!isDebuggable() || config.sendReportsInDevMode()) {
+            final List<RetryPolicy.FailedSender> failedSenders = new LinkedList<RetryPolicy.FailedSender>();
+            for (ReportSender sender : reportSenders) {
+                try {
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Sending report using " + sender.getClass().getName());
+                    sender.send(context, errorContent);
+                    if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Sent report using " + sender.getClass().getName());
+                } catch (ReportSenderException e) {
+                    failedSenders.add(new RetryPolicy.FailedSender(sender, e));
+                }
+            }
+
+            if (failedSenders.isEmpty()) {
+                if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Report was sent by all senders");
+            } else if (getRetryPolicy().shouldRetrySend(reportSenders, failedSenders)) {
+                final Throwable firstFailure = failedSenders.get(0).getException();
+                throw new ReportSenderException("Policy marked this task as incomplete. ACRA will try to send this report again.", firstFailure);
+            } else {
+                final StringBuilder builder = new StringBuilder("ReportSenders of classes [");
+                for (final RetryPolicy.FailedSender failedSender : failedSenders) {
+                    builder.append(failedSender.getSender().getClass().getName());
+                    builder.append(", ");
+                }
+                builder.append("] failed, but Policy marked this task as complete. ACRA will not send this report again.");
+                ACRA.log.w(LOG_TAG, builder.toString());
+            }
+        }
+    }
+
+    private RetryPolicy getRetryPolicy() {
+        try {
+            return config.retryPolicyClass().newInstance();
+        } catch (InstantiationException e) {
+            ACRA.log.e(LOG_TAG, "Failed to create policy instance of class " + config.retryPolicyClass().getName(), e);
+        } catch (IllegalAccessException e) {
+            ACRA.log.e(LOG_TAG, "Failed to create policy instance of class " + config.retryPolicyClass().getName(), e);
+        }
+
+        return new DefaultRetryPolicy();
+    }
+
+    /**
+     * Returns true if the application is debuggable.
+     *
+     * @return true if the application is debuggable.
+     */
+    private boolean isDebuggable() {
+        final PackageManager pm = context.getPackageManager();
+        try {
+            return (pm.getApplicationInfo(context.getPackageName(), 0).flags & ApplicationInfo.FLAG_DEBUGGABLE) > 0;
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/sender/ReportSender.java b/src/main/java/org/acra/sender/ReportSender.java
index 5271019c..06a56e62 100644
--- a/src/main/java/org/acra/sender/ReportSender.java
+++ b/src/main/java/org/acra/sender/ReportSender.java
@@ -16,35 +16,35 @@
 package org.acra.sender;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+
 import org.acra.collector.CrashReportData;
 
 /**
- * A simple interface for defining various crash report senders. You can reuse
- * {@link HttpSender} to send reports to your custom server-side report
+ * A simple interface for defining various crash report senders.
+ *
+ * You can reuse {@link HttpSender} to send reports to your custom server-side report
  * collection script even if you expect (or prefer) specific names for each
  * report field as {@link HttpSender#send(Context, CrashReportData)}
  * can take a {@code Map<ReportField, String>} as an input to convert each field name to
  * your preferred POST parameter name.
  * 
  * @author Kevin Gaudin
- * 
  */
 public interface ReportSender {
+
     /**
-     * Send crash report data. You don't have to take care of managing Threads,
-     * just implement what is necessary to handle the data. ACRA will use a
-     * specific Thread (not the UI Thread) to run your sender.
-     *
+     * Send crash report data.
      *
+     * Method will be called from the {@link SenderService}.
      *
      * @param context       Android Context in which to send the crash report.
-     * @param errorContent
-     *            Stores key/value pairs for each report field. A report field
-     *            is identified by a {@link org.acra.ReportField} enum value.
+     * @param errorContent  Stores key/value pairs for each report field.
+     *                      A report field is identified by a {@link org.acra.ReportField} enum value.
      * @throws ReportSenderException
      *             If anything goes fatally wrong during the handling of crash
      *             data, you can (should) throw a {@link ReportSenderException}
      *             with a custom message.
      */
-    public void send(Context context, CrashReportData errorContent) throws ReportSenderException;
+    void send(@NonNull Context context, @NonNull CrashReportData errorContent) throws ReportSenderException;
 }
diff --git a/src/main/java/org/acra/sender/ReportSenderException.java b/src/main/java/org/acra/sender/ReportSenderException.java
index b4c8cf44..54a7b000 100644
--- a/src/main/java/org/acra/sender/ReportSenderException.java
+++ b/src/main/java/org/acra/sender/ReportSenderException.java
@@ -16,7 +16,7 @@
 package org.acra.sender;
 
 /**
- * This exception is thrown when an error ocurred while sending crash data in a
+ * This exception is thrown when an error occurred while sending crash data in a
  * {@link ReportSender} implementation.
  * 
  * @author Kevin Gaudin
diff --git a/src/main/java/org/acra/sender/ReportSenderFactory.java b/src/main/java/org/acra/sender/ReportSenderFactory.java
new file mode 100644
index 00000000..122abb2e
--- /dev/null
+++ b/src/main/java/org/acra/sender/ReportSenderFactory.java
@@ -0,0 +1,25 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import org.acra.config.ACRAConfiguration;
+
+/**
+ * Factory for creating and configuring a {@link ReportSender} instance.
+ * Implementations must have a no argument constructor.
+ *
+ * Each configured ReportSenderFactory is created within the {@link SenderService}
+ * and is used to construct and configure a single {@link ReportSender}.
+ *
+ * Created by William on 4-JAN-2016.
+ */
+public interface ReportSenderFactory {
+
+    /**
+     * @param context   Application context.
+     * @param config    Configuration to use when sending reports.
+     * @return Fully configured instance of the relevant ReportSender.
+     */
+    @NonNull
+    ReportSender create(@NonNull Context context, @NonNull ACRAConfiguration config);
+}
diff --git a/src/main/java/org/acra/sender/SenderService.java b/src/main/java/org/acra/sender/SenderService.java
new file mode 100644
index 00000000..1090ac6d
--- /dev/null
+++ b/src/main/java/org/acra/sender/SenderService.java
@@ -0,0 +1,114 @@
+package org.acra.sender;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+public class SenderService extends IntentService {
+
+    public static final String EXTRA_ONLY_SEND_SILENT_REPORTS = "onlySendSilentReports";
+    public static final String EXTRA_APPROVE_REPORTS_FIRST = "approveReportsFirst";
+    public static final String EXTRA_ACRA_CONFIG = "acraConfig";
+
+    private final ReportLocator locator = new ReportLocator(this);
+
+    public SenderService() {
+        super("ACRA SenderService");
+        setIntentRedelivery(true);
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable final Intent intent) {
+        if (intent == null || !intent.hasExtra(EXTRA_ACRA_CONFIG)) {
+            if(ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "SenderService was started but no valid intent was delivered, will now quit");
+            return;
+        }
+
+        final boolean onlySendSilentReports = intent.getBooleanExtra(EXTRA_ONLY_SEND_SILENT_REPORTS, false);
+        final boolean approveReportsFirst = intent.getBooleanExtra(EXTRA_APPROVE_REPORTS_FIRST, false);
+
+        final ACRAConfiguration config = (ACRAConfiguration) intent.getSerializableExtra(EXTRA_ACRA_CONFIG);
+
+        final Collection<Class<? extends ReportSenderFactory>> senderFactoryClasses = config.reportSenderFactoryClasses();
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "About to start sending reports from SenderService");
+        try {
+            final List<ReportSender> senderInstances = getSenderInstances(config, senderFactoryClasses);
+
+            // Mark reports as approved
+            if (approveReportsFirst) {
+                markReportsAsApproved();
+            }
+
+            // Get approved reports
+            final File[] reports = locator.getApprovedReports();
+
+            final ReportDistributor reportDistributor = new ReportDistributor(this, config, senderInstances);
+
+            // Iterate over approved reports and send via all Senders.
+            int reportsSentCount = 0; // Use to rate limit sending
+            final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+            for (final File report : reports) {
+                if (onlySendSilentReports && !fileNameParser.isSilent(report.getName())) {
+                    continue;
+                }
+
+                if (reportsSentCount >= ACRAConstants.MAX_SEND_REPORTS) {
+                    break; // send only a few reports to avoid overloading the network
+                }
+
+                reportDistributor.distribute(report);
+                reportsSentCount++;
+            }
+        } catch (Exception e) {
+            ACRA.log.e(LOG_TAG, "", e);
+        }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Finished sending reports from SenderService");
+    }
+
+    @NonNull
+    private List<ReportSender> getSenderInstances(@NonNull ACRAConfiguration config, @NonNull Collection<Class<? extends ReportSenderFactory>> factoryClasses) {
+        final List<ReportSender> reportSenders = new ArrayList<ReportSender>();
+        for (final Class<? extends ReportSenderFactory> factoryClass : factoryClasses) {
+            try {
+                final ReportSenderFactory factory = factoryClass.newInstance();
+                final ReportSender sender = factory.create(this.getApplication(), config);
+                reportSenders.add(sender);
+            } catch (InstantiationException e) {
+                ACRA.log.w(LOG_TAG, "Could not construct ReportSender from " + factoryClass, e);
+            } catch (IllegalAccessException e) {
+                ACRA.log.w(LOG_TAG, "Could not construct ReportSender from " + factoryClass, e);
+            }
+        }
+        return reportSenders;
+    }
+
+    /**
+     * Flag all pending reports as "approved" by the user. These reports can be sent.
+     */
+    private void markReportsAsApproved() {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Mark all pending reports as approved.");
+
+        for (File report : locator.getUnapprovedReports()) {
+            final File approvedReport = new File(locator.getApprovedFolder(), report.getName());
+            if (!report.renameTo(approvedReport)) {
+                ACRA.log.w(LOG_TAG, "Could not rename approved report from " + report + " to " + approvedReport);
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/acra/sender/SenderServiceStarter.java b/src/main/java/org/acra/sender/SenderServiceStarter.java
new file mode 100644
index 00000000..4475e247
--- /dev/null
+++ b/src/main/java/org/acra/sender/SenderServiceStarter.java
@@ -0,0 +1,39 @@
+package org.acra.sender;
+
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+import org.acra.config.ACRAConfiguration;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Starts the Service(Intent)Service to process and send pending reports.
+ */
+public class SenderServiceStarter {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public SenderServiceStarter(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Starts a Thread to start sending outstanding error reports.
+     *
+     * @param onlySendSilentReports If true then only send silent reports.
+     * @param approveReportsFirst   If true then approve unapproved reports first.
+     */
+    public void startService(boolean onlySendSilentReports, boolean approveReportsFirst) {
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "About to start SenderService");
+        final Intent intent = new Intent(context, SenderService.class);
+        intent.putExtra(SenderService.EXTRA_ONLY_SEND_SILENT_REPORTS, onlySendSilentReports);
+        intent.putExtra(SenderService.EXTRA_APPROVE_REPORTS_FIRST, approveReportsFirst);
+        intent.putExtra(SenderService.EXTRA_ACRA_CONFIG, config);
+        context.startService(intent);
+    }
+}
diff --git a/src/main/java/org/acra/util/ApplicationStartupProcessor.java b/src/main/java/org/acra/util/ApplicationStartupProcessor.java
new file mode 100644
index 00000000..f4814a4a
--- /dev/null
+++ b/src/main/java/org/acra/util/ApplicationStartupProcessor.java
@@ -0,0 +1,104 @@
+package org.acra.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.PackageInfo;
+import android.support.annotation.NonNull;
+import android.widget.Toast;
+import org.acra.ACRA;
+import org.acra.ReportingInteractionMode;
+import org.acra.config.ACRAConfiguration;
+import org.acra.file.BulkReportDeleter;
+import org.acra.file.CrashReportFileNameParser;
+import org.acra.file.ReportLocator;
+import org.acra.prefs.PrefUtils;
+import org.acra.prefs.SharedPreferencesFactory;
+import org.acra.sender.SenderServiceStarter;
+
+import java.io.File;
+
+/**
+ * Looks for any existing reports and starts sending them.
+ */
+public final class ApplicationStartupProcessor {
+
+    private final Context context;
+    private final ACRAConfiguration config;
+
+    public ApplicationStartupProcessor(@NonNull Context context, @NonNull ACRAConfiguration config) {
+        this.context = context;
+        this.config = config;
+    }
+
+    /**
+     * Delete any old unsent reports if this is a newer version of the app than when we last started.
+     */
+    public void deleteUnsentReportsFromOldAppVersion() {
+        final SharedPreferences prefs = new SharedPreferencesFactory(context, config).create();
+        final long lastVersionNr = prefs.getInt(ACRA.PREF_LAST_VERSION_NR, 0);
+        final int appVersion = getAppVersion();
+
+        if (appVersion > lastVersionNr) {
+            final BulkReportDeleter reportDeleter = new BulkReportDeleter(context);
+            reportDeleter.deleteReports(true, 0);
+            reportDeleter.deleteReports(false, 0);
+
+            final SharedPreferences.Editor prefsEditor = prefs.edit();
+            prefsEditor.putInt(ACRA.PREF_LAST_VERSION_NR, appVersion);
+            PrefUtils.save(prefsEditor);
+        }
+    }
+
+    /**
+     * Deletes all the unapproved reports except for the last one.
+     *
+     * NOTIFICATION or DIALOG mode require explicit approval by user.
+     * If latest notification/dialog has been ignored: neither accepted nor refused; they will accumulate.
+     * So destroy all unapproved reports bar the last one.
+     */
+    public void deleteAllUnapprovedReportsBarOne() {
+        new BulkReportDeleter(context).deleteReports(false, 1);
+    }
+
+    /**
+     * If ReportingInteractionMode == Toast and at least one non silent report then show a Toast.
+     * All approved reports will be sent.
+     */
+    public void sendApprovedReports() {
+
+        final ReportLocator reportLocator = new ReportLocator(context);
+        final File[] reportFiles = reportLocator.getApprovedReports();
+
+        if (reportFiles.length == 0) {
+            return; // There are no approved reports, so bail now.
+        }
+
+        if (config.mode() == ReportingInteractionMode.TOAST && hasNonSilentApprovedReports(reportFiles)) {
+            ToastSender.sendToast(context, config.resToastText(), Toast.LENGTH_LONG);
+        }
+
+        // Send the approved reports.
+        final SenderServiceStarter starter = new SenderServiceStarter(context, config);
+        starter.startService(false, false);
+
+    }
+
+    /**
+     * @return app version or 0 if PackageInfo was not available.
+     */
+    private int getAppVersion() {
+        final PackageManagerWrapper packageManagerWrapper = new PackageManagerWrapper(context);
+        final PackageInfo packageInfo = packageManagerWrapper.getPackageInfo();
+        return (packageInfo == null) ? 0 : packageInfo.versionCode;
+    }
+
+    private boolean hasNonSilentApprovedReports(File[] reportFiles) {
+        final CrashReportFileNameParser fileNameParser = new CrashReportFileNameParser();
+        for (final File file : reportFiles) {
+            if (!fileNameParser.isSilent(file.getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
deleted file mode 100644
index c5b69bb3..00000000
--- a/src/main/java/org/acra/util/DefaultHttpsSocketFactoryFactory.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.acra.util;
-
-import android.content.Context;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-
-/**
- * Default implementation of a HttpSocketFactoryFactory.
- */
-public final class DefaultHttpsSocketFactoryFactory implements HttpsSocketFactoryFactory {
-
-    public static final HttpsSocketFactoryFactory INSTANCE = new DefaultHttpsSocketFactoryFactory();
-
-    @Override
-    public SocketFactory create(Context context) {
-        return new TlsSniSocketFactory();
-    }
-}
diff --git a/src/main/java/org/acra/util/FakeSocketFactory.java b/src/main/java/org/acra/util/FakeSocketFactory.java
deleted file mode 100644
index 73b9a5c2..00000000
--- a/src/main/java/org/acra/util/FakeSocketFactory.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Utility class copied from http://transdroid.googlecode.com with the authorization from Eric Kok to redistribute it under Apache Software License. 
- */
-package org.acra.util;
-
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.TrustManager;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-
-public class FakeSocketFactory implements SocketFactory, LayeredSocketFactory {
-
-    private SSLContext sslcontext = null;
-
-    private static SSLContext createEasySSLContext() throws IOException {
-        try {
-            final SSLContext context = SSLContext.getInstance("TLS");
-            context.init(null, new TrustManager[] { new NaiveTrustManager() }, null);
-            return context;
-        } catch (Exception e) {
-            throw new IOException(e.getMessage());
-        }
-    }
-
-    private SSLContext getSSLContext() throws IOException {
-        if (this.sslcontext == null) {
-            this.sslcontext = createEasySSLContext();
-        }
-        return this.sslcontext;
-    }
-
-    @Override
-    public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        final int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
-        final int soTimeout = HttpConnectionParams.getSoTimeout(params);
-
-        final InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
-        final SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());
-
-        if ((localAddress != null) || (localPort > 0)) {
-            // we need to bind explicitly
-            if (localPort < 0) {
-                localPort = 0; // indicates "any"
-            }
-            final InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
-            sslsock.bind(isa);
-        }
-
-        sslsock.connect(remoteAddress, connTimeout);
-        sslsock.setSoTimeout(soTimeout);
-
-        return sslsock;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return getSSLContext().getSocketFactory().createSocket();
-    }
-
-    @Override
-    public boolean isSecure(Socket arg0) throws IllegalArgumentException {
-        return true;
-    }
-
-    @Override
-    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
-        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
-    }
-
-}
diff --git a/src/main/java/org/acra/util/HttpRequest.java b/src/main/java/org/acra/util/HttpRequest.java
index 839cb0fa..c5b0eb5b 100644
--- a/src/main/java/org/acra/util/HttpRequest.java
+++ b/src/main/java/org/acra/util/HttpRequest.java
@@ -5,105 +5,56 @@
  */
 package org.acra.util;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Base64;
+
+import org.acra.ACRA;
+import org.acra.config.ACRAConfiguration;
+import org.acra.security.KeyStoreHelper;
+import org.acra.sender.HttpSender.Method;
+import org.acra.sender.HttpSender.Type;
+
+import java.io.BufferedOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
-import java.net.SocketTimeoutException;
+import java.net.HttpURLConnection;
 import java.net.URL;
 import java.net.URLEncoder;
-import java.security.KeyManagementException;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.UnrecoverableKeyException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.Map;
 
-import android.content.Context;
-import org.acra.ACRA;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.HttpRequestRetryHandler;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.client.params.ClientPNames;
-import org.apache.http.client.params.CookiePolicy;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.PlainSocketFactory;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.scheme.SchemeRegistry;
-import org.apache.http.conn.scheme.SocketFactory;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.impl.auth.BasicScheme;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.SingleClientConnManager;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.protocol.BasicHttpContext;
-import org.apache.http.protocol.HttpContext;
-import org.apache.http.util.EntityUtils;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
 
-public final class HttpRequest {
+import ch.acra.acra.BuildConfig;
 
-    private static class SocketTimeOutRetryHandler implements HttpRequestRetryHandler {
-
-        private final HttpParams httpParams;
-        private final int maxNrRetries;
-
-        /**
-         * @param httpParams
-         *            HttpParams that will be used in the HttpRequest.
-         * @param maxNrRetries
-         *            Max number of times to retry Request on failure due to
-         *            SocketTimeOutException.
-         */
-        private SocketTimeOutRetryHandler(HttpParams httpParams, int maxNrRetries) {
-            this.httpParams = httpParams;
-            this.maxNrRetries = maxNrRetries;
-        }
+import static org.acra.ACRA.LOG_TAG;
 
-        @Override
-        public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
-            if (exception instanceof SocketTimeoutException) {
-                if (executionCount <= maxNrRetries) {
-
-                    if (httpParams != null) {
-                        final int newSocketTimeOut = HttpConnectionParams.getSoTimeout(httpParams) * 2;
-                        HttpConnectionParams.setSoTimeout(httpParams, newSocketTimeOut);
-                        ACRA.log.d(ACRA.LOG_TAG, "SocketTimeOut - increasing time out to " + newSocketTimeOut
-                                + " millis and trying again");
-                    } else {
-                        ACRA.log.d(ACRA.LOG_TAG,
-                                "SocketTimeOut - no HttpParams, cannot increase time out. Trying again with current settings");
-                    }
-
-                    return true;
-                }
-
-                ACRA.log.d(ACRA.LOG_TAG, "SocketTimeOut but exceeded max number of retries : " + maxNrRetries);
-            }
+public final class HttpRequest {
 
-            return false; // To change body of implemented methods use File |
-                          // Settings | File Templates.
-        }
-    }
+    private static final String UTF8 = "UTF-8";
 
+    private final ACRAConfiguration config;
     private String login;
     private String password;
     private int connectionTimeOut = 3000;
     private int socketTimeOut = 3000;
-    private int maxNrRetries = 3;
-    private Map<String,String> headers;
-    
-    public void setLogin(String login) {
+    private Map<String, String> headers;
+
+    public HttpRequest(@NonNull ACRAConfiguration config) {
+        this.config = config;
+    }
+
+    public void setLogin(@Nullable String login) {
         this.login = login;
     }
 
-    public void setPassword(String password) {
+    public void setPassword(@Nullable String password) {
         this.password = password;
     }
 
@@ -115,203 +66,129 @@ public void setSocketTimeOut(int socketTimeOut) {
         this.socketTimeOut = socketTimeOut;
     }
 
-    public void setHeaders(Map<String,String> headers) {
-       this.headers = headers;
+    public void setHeaders(@Nullable Map<String, String> headers) {
+        this.headers = headers;
     }
 
-    
-    /**
-     * The default number of retries is 3.
-     * 
-     * @param maxNrRetries
-     *            Max number of times to retry Request on failure due to
-     *            SocketTimeOutException.
-     */
-    public void setMaxNrRetries(int maxNrRetries) {
-        this.maxNrRetries = maxNrRetries;
-    }
 
     /**
      * Posts to a URL.
-     * 
      *
-     * @param context   Android context for which to create the SocketFactory.
-     * @param url       URL to which to post.
-     * @param content   Map of parameters to post to a URL.
+     * @param url     URL to which to post.
+     * @param content Map of parameters to post to a URL.
      * @throws IOException if the data cannot be posted.
      */
-    public void send(Context context, URL url, Method method, String content, Type type) throws IOException {
+    public void send(@NonNull Context context, @NonNull URL url, @NonNull Method method, @NonNull String content, @NonNull Type type) throws IOException {
 
-        final HttpClient httpClient = getHttpClient(context);
-        final HttpEntityEnclosingRequestBase httpRequest = getHttpRequest(url, method, content, type);
+        final HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
 
-        ACRA.log.d(ACRA.LOG_TAG, "Sending request to " + url);
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(ACRA.LOG_TAG, "Http " + method.name() + " content : ");
-        if (ACRA.DEV_LOGGING)
-            ACRA.log.d(ACRA.LOG_TAG, content);
+        // Configure SSL
+        if (urlConnection instanceof HttpsURLConnection) {
+            try {
+                final HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) urlConnection;
 
-        HttpResponse response = null;
-        try {
-            response = httpClient.execute(httpRequest, new BasicHttpContext());
-            if (response != null) {
-                final StatusLine statusLine = response.getStatusLine();
-                if (statusLine != null) {
-                    final String statusCode = Integer.toString(response.getStatusLine().getStatusCode());
-    
-                    if (!statusCode.equals("409") // 409 return code means that the
-                                                  // report has been received
-                                                  // already. So we can discard it.
-                            && !statusCode.equals("403") // a 403 error code is an explicit data validation refusal
-                                                         // from the server. The request must not be repeated.
-                                                         // Discard it.
-                            && (statusCode.startsWith("4") || statusCode.startsWith("5"))) {
-                        if (ACRA.DEV_LOGGING) {
-                            ACRA.log.d(ACRA.LOG_TAG, "Could not send HttpPost : " + httpRequest);
-                            ACRA.log.d(ACRA.LOG_TAG, "HttpResponse Status : "
-                                    + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                            final String respContent = EntityUtils.toString(response.getEntity());
-                            ACRA.log.d(ACRA.LOG_TAG,
-                                    "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-                        }
-                        throw new IOException("Host returned error code " + statusCode);
-                    }
-                }
-
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(ACRA.LOG_TAG, "HttpResponse Status : "
-                            + (statusLine != null ? statusLine.getStatusCode() : "NoStatusLine#noCode"));
-                final String respContent = EntityUtils.toString(response.getEntity());
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(ACRA.LOG_TAG,
-                            "HttpResponse Content : " + respContent.substring(0, Math.min(respContent.length(), 200)));
-
-            } else {
-                if (ACRA.DEV_LOGGING)
-                    ACRA.log.d(ACRA.LOG_TAG, "HTTP no Response!!");
-            }
-        } finally {
-            if (response != null) {
-				response.getEntity().consumeContent();
-			}
-        }
-    }
+                final String algorithm = TrustManagerFactory.getDefaultAlgorithm();
+                final TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
+                final KeyStore keyStore = KeyStoreHelper.getKeyStore(context, config);
 
-    /**
-     * @return HttpClient to use with this HttpRequest.
-     */
-    private HttpClient getHttpClient(Context context) {
-        final HttpParams httpParams = new BasicHttpParams();
-        httpParams.setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.RFC_2109);
-        HttpConnectionParams.setConnectionTimeout(httpParams, connectionTimeOut);
-        HttpConnectionParams.setSoTimeout(httpParams, socketTimeOut);
-        HttpConnectionParams.setSocketBufferSize(httpParams, 8192);
-
-        final SchemeRegistry registry = new SchemeRegistry();
-        registry.register(new Scheme("http", new PlainSocketFactory(), 80));
-        if (ACRA.getConfig().disableSSLCertValidation()) {
-            registry.register(new Scheme("https", (new FakeSocketFactory()), 443));
-        } else if (ACRA.getConfig().keyStore() != null) {
-            try {
-                SSLSocketFactory sf = new SSLSocketFactory(ACRA.getConfig().keyStore());
-                sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
-                registry.register(new Scheme("https", sf, 443));
-            } catch (KeyManagementException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (UnrecoverableKeyException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (NoSuchAlgorithmException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
-            } catch (KeyStoreException e) {
-                registry.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
+                tmf.init(keyStore);
+
+                final SSLContext sslContext = SSLContext.getInstance("TLS");
+                sslContext.init(null, tmf.getTrustManagers(), null);
+
+                httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
+            } catch (GeneralSecurityException e) {
+                ACRA.log.e(LOG_TAG, "Could not configure SSL for ACRA request to " + url, e);
             }
-        } else {
-            final HttpsSocketFactoryFactory factory = ACRA.getConfig().getHttpSocketFactoryFactory();
-            final SocketFactory socketFactory = factory.create(context);
-            registry.register(new Scheme("https", socketFactory, 443));
         }
 
-        final ClientConnectionManager clientConnectionManager = new SingleClientConnManager(httpParams, registry);
-        final DefaultHttpClient httpClient = new DefaultHttpClient(clientConnectionManager, httpParams);
+        // Set Credentials
+        if (login != null && password != null) {
+            final String credentials = login + ':' + password;
+            final String encoded = new String(Base64.encode(credentials.getBytes(UTF8), Base64.NO_WRAP), UTF8);
+            urlConnection.setRequestProperty("Authorization", "Basic " + encoded);
+        }
 
-        final HttpRequestRetryHandler retryHandler = new SocketTimeOutRetryHandler(httpParams, maxNrRetries);
-        httpClient.setHttpRequestRetryHandler(retryHandler);
+        urlConnection.setConnectTimeout(connectionTimeOut);
+        urlConnection.setReadTimeout(socketTimeOut);
 
-        return httpClient;
-    }
+        // Set Headers
+        urlConnection.setRequestProperty("User-Agent", String.format("Android ACRA %1$s", BuildConfig.VERSION_NAME)); //sent ACRA version to server
+        urlConnection.setRequestProperty("Accept",
+                "text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
+        urlConnection.setRequestProperty("Content-Type", type.getContentType());
 
-    /**
-     * @return Credentials to use with this HttpRequest or null if no
-     *         credentials were supplied.
-     */
-    private UsernamePasswordCredentials getCredentials() {
-        if (login != null || password != null) {
-            return new UsernamePasswordCredentials(login, password);
+        if (headers != null) {
+            for (final Map.Entry<String, String> header : headers.entrySet()) {
+                urlConnection.setRequestProperty(header.getKey(), header.getValue());
+            }
         }
 
-        return null;
-    }
+        final byte[] contentAsBytes = content.getBytes(UTF8);
 
-    private HttpEntityEnclosingRequestBase getHttpRequest(URL url, Method method, String content, Type type)
-            throws UnsupportedEncodingException, UnsupportedOperationException {
-
-        final HttpEntityEnclosingRequestBase httpRequest;
-        switch (method) {
-        case POST:
-            httpRequest = new HttpPost(url.toString());
-            break;
-        case PUT:
-            httpRequest = new HttpPut(url.toString());
-            break;
-        default:
-            throw new UnsupportedOperationException("Unknown method: " + method.name());
-        }
+        // write output - see http://developer.android.com/reference/java/net/HttpURLConnection.html
+        urlConnection.setRequestMethod(method.name());
+        urlConnection.setDoOutput(true);
+        urlConnection.setFixedLengthStreamingMode(contentAsBytes.length);
+
+        // Disable ConnectionPooling because otherwise OkHttp ConnectionPool will try to start a Thread on #connect
+        System.setProperty("http.keepAlive", "false");
 
-        final UsernamePasswordCredentials creds = getCredentials();
-        if (creds != null) {
-            httpRequest.addHeader(BasicScheme.authenticate(creds, "UTF-8", false));
+        urlConnection.connect();
+
+        final OutputStream outputStream = new BufferedOutputStream(urlConnection.getOutputStream());
+        try {
+            outputStream.write(contentAsBytes);
+            outputStream.flush();
+        } finally {
+            IOUtils.safeClose(outputStream);
         }
-        httpRequest.setHeader("User-Agent", "Android");
-        httpRequest
-                .setHeader("Accept",
-                        "text/html,application/xml,application/json,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
-        httpRequest.setHeader("Content-Type", type.getContentType());
-
-        if(headers != null) {
-            for (final String header : headers.keySet()) {
-              final String value = headers.get(header);
-              httpRequest.setHeader(header, value);
-           }
+
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Sending request to " + url);
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Http " + method.name() + " content : ");
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, content);
+
+        final int responseCode = urlConnection.getResponseCode();
+        if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Request response : " + responseCode + " : " + urlConnection.getResponseMessage());
+        if (responseCode >= HttpURLConnection.HTTP_OK && responseCode < HttpURLConnection.HTTP_MULT_CHOICE) {
+            // All is good
+            ACRA.log.i(LOG_TAG, "Request received by server");
+        } else if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT || responseCode >= HttpURLConnection.HTTP_INTERNAL_ERROR) {
+            //timeout or server error. Repeat the request later.
+            ACRA.log.w(LOG_TAG, "Could not send ACRA Post responseCode=" + responseCode + " message=" + urlConnection.getResponseMessage());
+            throw new IOException("Host returned error code " + responseCode);
+        } else if (responseCode >= HttpURLConnection.HTTP_BAD_REQUEST && responseCode < HttpURLConnection.HTTP_INTERNAL_ERROR) {
+            // Client error. The request must not be repeated. Discard it.
+            ACRA.log.w(LOG_TAG, responseCode+": Client error - request will be discarded");
+        } else {
+            ACRA.log.w(LOG_TAG, "Could not send ACRA Post - request will be discarded. responseCode=" + responseCode + " message=" + urlConnection.getResponseMessage());
         }
-        
-        httpRequest.setEntity(new StringEntity(content, "UTF-8"));
 
-        return httpRequest;
+        urlConnection.disconnect();
     }
 
     /**
      * Converts a Map of parameters into a URL encoded Sting.
-     * 
-     * @param parameters
-     *            Map of parameters to convert.
+     *
+     * @param parameters Map of parameters to convert.
      * @return URL encoded String representing the parameters.
-     * @throws UnsupportedEncodingException
-     *             if one of the parameters couldn't be converted to UTF-8.
+     * @throws UnsupportedEncodingException if one of the parameters couldn't be converted to UTF-8.
      */
-    public static String getParamsAsFormString(Map<?, ?> parameters) throws UnsupportedEncodingException {
+    @NonNull
+    public static String getParamsAsFormString(@NonNull Map<?, ?> parameters) throws UnsupportedEncodingException {
 
         final StringBuilder dataBfr = new StringBuilder();
-        for (final Object key : parameters.keySet()) {
+        for (final Map.Entry<?, ?> entry : parameters.entrySet()) {
             if (dataBfr.length() != 0) {
                 dataBfr.append('&');
             }
-            final Object preliminaryValue = parameters.get(key);
+            final Object preliminaryValue = entry.getValue();
             final Object value = (preliminaryValue == null) ? "" : preliminaryValue;
-            dataBfr.append(URLEncoder.encode(key.toString(), "UTF-8"));
+            dataBfr.append(URLEncoder.encode(entry.getKey().toString(), UTF8));
             dataBfr.append('=');
-            dataBfr.append(URLEncoder.encode(value.toString(), "UTF-8"));
+            dataBfr.append(URLEncoder.encode(value.toString(), UTF8));
         }
 
         return dataBfr.toString();
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java b/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
deleted file mode 100644
index 398975d1..00000000
--- a/src/main/java/org/acra/util/HttpsSocketFactoryFactory.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.acra.util;
-
-import android.content.Context;
-import org.apache.http.conn.scheme.SocketFactory;
-
-/**
- * Factory that creates an instance of a Https SocketFactory.
- */
-public interface HttpsSocketFactoryFactory {
-
-    /**
-     * @param context   Android context for which to create the SocketFactory.
-     * @return SocketFactory that was created.
-     */
-    public SocketFactory create(Context context);
-}
diff --git a/src/main/java/org/acra/util/IOUtils.java b/src/main/java/org/acra/util/IOUtils.java
new file mode 100644
index 00000000..c1568d81
--- /dev/null
+++ b/src/main/java/org/acra/util/IOUtils.java
@@ -0,0 +1,179 @@
+/*
+ *  Copyright 2016
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.acra.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.android.internal.util.Predicate;
+
+import org.acra.ACRA;
+import org.acra.ACRAConstants;
+import org.acra.collections.BoundedLinkedList;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author William Ferguson, F43nd1r
+ * @since 4.6.0
+ */
+public final class IOUtils {
+
+    private static final Predicate<String> DEFAULT_FILTER = new Predicate<String>() {
+        @Override
+        public boolean apply(String s) {
+            return true;
+        }
+    };
+    private static final int NO_LIMIT = -1;
+	private static final int READ_TIMEOUT = 3000;
+
+    private IOUtils() {
+    }
+
+
+    /**
+     * Closes a Closeable.
+     *
+     * @param closeable Closeable to close. If closeable is null then method just returns.
+     */
+    public static void safeClose(@Nullable Closeable closeable) {
+        if (closeable == null) return;
+
+        try {
+            closeable.close();
+        } catch (IOException ignored) {
+            // We made out best effort to release this resource. Nothing more we can do.
+        }
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input) throws IOException {
+        return streamToString(input, DEFAULT_FILTER, NO_LIMIT);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @param filter should return false for lines which should be excluded
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, Predicate<String> filter) throws IOException {
+        return streamToString(input, filter, NO_LIMIT);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @param limit the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, int limit) throws IOException {
+        return streamToString(input, DEFAULT_FILTER, limit);
+    }
+
+    /**
+     * Reads an InputStream into a string
+     *
+     * @param input  InputStream to read.
+     * @param filter Predicate that should return false for lines which should be excluded.
+     * @param limit the maximum number of lines to read (the last x lines are kept)
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToString(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(input), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        try {
+            String line;
+            final List<String> buffer = limit == NO_LIMIT ? new LinkedList<String>() : new BoundedLinkedList<String>(limit);
+            while ((line = reader.readLine()) != null) {
+                if (filter.apply(line)) {
+                    buffer.add(line);
+                }
+            }
+            return TextUtils.join("\n", buffer);
+        } finally {
+            safeClose(reader);
+        }
+    }
+	
+	/**
+     * Reads an InputStream into a string without blocking the current thread.
+     * It has a default timeout of 3 seconds.
+     *
+     * @param input  InputStream to read.
+     * @param filter Predicate that should return false for lines which should be excluded.
+     * @param limit the maximum number of lines to read (the last x lines are kept).
+     * @return the String that was read.
+     * @throws IOException if the InputStream could not be read.
+     */
+    @NonNull
+    public static String streamToStringNonBlockingRead(@NonNull InputStream input, Predicate<String> filter, int limit) throws IOException {
+        final BufferedReader reader = new BufferedReader(new InputStreamReader(input), ACRAConstants.DEFAULT_BUFFER_SIZE_IN_BYTES);
+        final NonBlockingBufferedReader nonBlockingReader = new NonBlockingBufferedReader(reader);
+        try {
+            final List<String> buffer = limit == NO_LIMIT ? new LinkedList<String>() : new BoundedLinkedList<String>(limit);
+            final long end = System.currentTimeMillis() + READ_TIMEOUT;
+            try {
+                while ((System.currentTimeMillis() < end)) {
+                    final String line = nonBlockingReader.readLine();
+                    if (line == null) {
+                        break;
+                    }
+                    if (filter.apply(line)) {
+                        buffer.add(line);
+                    }
+                }
+            } catch (InterruptedException e) {
+                if (ACRA.DEV_LOGGING) ACRA.log.d(LOG_TAG, "Interrupted while reading stream", e);
+            }
+            return TextUtils.join("\n", buffer);
+        } finally {
+            nonBlockingReader.close();
+        }
+    }
+
+    public static void deleteReport(@NonNull File file) {
+        final boolean deleted = file.delete();
+        if (!deleted) {
+            ACRA.log.w(LOG_TAG, "Could not delete error report : " + file);
+        }
+    }
+}
diff --git a/src/main/java/org/acra/util/Installation.java b/src/main/java/org/acra/util/Installation.java
index 54689a80..f7ff59ad 100644
--- a/src/main/java/org/acra/util/Installation.java
+++ b/src/main/java/org/acra/util/Installation.java
@@ -4,16 +4,18 @@
  */
 package org.acra.util;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import org.acra.ACRA;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.util.UUID;
 
-import org.acra.ACRA;
-
-import android.content.Context;
-import android.util.Log;
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * <p>
@@ -26,12 +28,14 @@
  * android developers blog.</a>
  * </p>
  */
-public class Installation {
+public final class Installation {
+    private Installation(){}
 
     private static String sID;
     private static final String INSTALLATION = "ACRA-INSTALLATION";
 
-    public synchronized static String id(Context context) {
+    @NonNull
+    public static synchronized String id(@NonNull Context context) {
         if (sID == null) {
             final File installation = new File(context.getFilesDir(), INSTALLATION);
             try {
@@ -40,34 +44,35 @@ public synchronized static String id(Context context) {
                 }
                 sID = readInstallationFile(installation);
             } catch (IOException e) {
-                Log.w(ACRA.LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
+                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
                 return "Couldn't retrieve InstallationId";
             } catch (RuntimeException e) {
-                Log.w(ACRA.LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
+                ACRA.log.w(LOG_TAG, "Couldn't retrieve InstallationId for " + context.getPackageName(), e);
                 return "Couldn't retrieve InstallationId";
             }
         }
         return sID;
     }
 
-    private static String readInstallationFile(File installation) throws IOException {
+    @NonNull
+    private static String readInstallationFile(@NonNull File installation) throws IOException {
         final RandomAccessFile f = new RandomAccessFile(installation, "r");
         final byte[] bytes = new byte[(int) f.length()];
         try {
             f.readFully(bytes);
         } finally {
-            f.close();
+            IOUtils.safeClose(f);
         }
         return new String(bytes);
     }
 
-    private static void writeInstallationFile(File installation) throws IOException {
+    private static void writeInstallationFile(@NonNull File installation) throws IOException {
         final FileOutputStream out = new FileOutputStream(installation);
         try {
             final String id = UUID.randomUUID().toString();
             out.write(id.getBytes());
         } finally {
-            out.close();
+            IOUtils.safeClose(out);
         }
     }
 }
diff --git a/src/main/java/org/acra/util/JSONReportBuilder.java b/src/main/java/org/acra/util/JSONReportBuilder.java
deleted file mode 100644
index 26ae0c45..00000000
--- a/src/main/java/org/acra/util/JSONReportBuilder.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package org.acra.util;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.StringReader;
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.Locale;
-
-import org.acra.ACRA;
-import org.acra.ReportField;
-import org.acra.collector.CollectorUtil;
-import org.acra.collector.CrashReportData;
-import org.acra.sender.ReportSenderException;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-public class JSONReportBuilder {
-    /**
-     * <p>
-     * Create a JSONObject containing the whole report data with the most
-     * detailed possible structure depth. Fields are not just converted to a
-     * single key=value pair. If a value can be decomposed into subobjects, it
-     * is done.
-     * </p>
-     *
-     * <p>
-     * For example, a String containing:
-     *
-     * <pre>
-     * some.key.name1=value1
-     * some.key.name2=value2
-     * some.other=value3
-     * any.other.key=value4
-     * key.without.value5
-     * </pre>
-     *
-     * is converted to
-     *
-     * <pre>
-     * {
-     *   some : {
-     *     key : {
-     *       name1 : "value1",
-     *       name2 : "value2"
-     *     },
-     *     other : "value3"
-     *   },
-     *   any : {
-     *     other : {
-     *       key : "value4"
-     *     }
-     *   }
-     *   key.without.value : true
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param errorContent
-     *            The ACRA report data structure.
-     * @return A JSONObject containing all fields from the report converted to
-     *         JSON.
-     * @throws ReportSenderException
-     * @throws JSONReportException
-     */
-    public static JSONObject buildJSONReport(CrashReportData errorContent) throws JSONReportException {
-        JSONObject jsonReport = new JSONObject();
-        BufferedReader reader = null;
-        for (ReportField key : errorContent.keySet()) {
-            try {
-                // Each ReportField can be identified as a substructure and not
-                // a simple String value.
-                if (key.containsKeyValuePairs()) {
-                    JSONObject subObject = new JSONObject();
-                    String strContent = errorContent.getProperty(key);
-                    reader = new BufferedReader(new StringReader(strContent), 1024);
-                    String line = null;
-                    try {
-                        while ((line = reader.readLine()) != null) {
-                            addJSONFromProperty(subObject, line);
-                        }
-                    } catch (IOException e) {
-                        ACRA.log.e(ACRA.LOG_TAG, "Error while converting " + key.name() + " to JSON.", e);
-                    }
-                    jsonReport.accumulate(key.name(), subObject);
-                } else {
-                    // This field is a simple String value, store it as it is
-                    jsonReport.accumulate(key.name(), guessType(errorContent.getProperty(key)));
-                }
-            } catch (JSONException e) {
-                throw new JSONReportException("Could not create JSON object for key " + key, e);
-            } finally {
-            	CollectorUtil.safeClose(reader);
-            }
-        }
-        return jsonReport;
-    }
-
-    /**
-     * <p>
-     * Given a String containing key=value pairs on each line, adds a detailed
-     * JSON structure to an existing JSONObject, reusing intermediate subobjects
-     * if available when keys are composed of a succession of subkeys delimited
-     * by dots.
-     * </p>
-     *
-     * <p>
-     * For example, adding the string "metrics.xdpi=160.0" to an object
-     * containing
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * results in
-     *
-     * <pre>
-     * {
-     *   "metrics" : { "ydpi" : "160.0", "xdpi" : "160.0"},
-     *   "width" : "320",
-     *   "height" : "533"
-     * }
-     * </pre>
-     *
-     * </p>
-     *
-     * @param destination
-     *            The JSONObject where the data must be inserted.
-     * @param propertyString
-     *            A string containing "some.key.name=Any value"
-     * @throws JSONException
-     */
-    private static void addJSONFromProperty(JSONObject destination, String propertyString) throws JSONException {
-        int equalsIndex = propertyString.indexOf('=');
-        if (equalsIndex > 0) {
-            JSONObject finalObject = destination;
-            String currentKey = propertyString.substring(0, equalsIndex).trim();
-            String currentValue = propertyString.substring(equalsIndex + 1).trim();
-            Object value = guessType(currentValue);
-            if(value instanceof String) {
-                value = ((String) value).replaceAll("\\\\n","\n");
-            }
-            String[] splitKey = currentKey.split("\\.");
-            if (splitKey.length > 1) {
-                addJSONSubTree(finalObject, splitKey, value);
-            } else {
-                finalObject.accumulate(currentKey, value);
-            }
-        } else {
-            destination.put(propertyString.trim(), true);
-        }
-    }
-
-    private static Object guessType(String value) {
-        if (value.equalsIgnoreCase("true"))
-            return true;
-        if (value.equalsIgnoreCase("false"))
-            return false;
-
-        if (value.matches("(?:^|\\s)([1-9](?:\\d*|(?:\\d{0,2})(?:,\\d{3})*)(?:\\.\\d*[1-9])?|0?\\.\\d*[1-9]|0)(?:\\s|$)")) {
-            NumberFormat format = NumberFormat.getInstance(Locale.US);
-            try {
-                Number number = format.parse(value);
-                return number;
-            } catch (ParseException e) {
-                // never mind
-            }
-        }
-        return value;
-    }
-
-    /**
-     * Deep insert a value inside a JSONObject, reusing existing subobjects when
-     * available or creating them when necessary.
-     *
-     * @param destination
-     *            The JSONObject which receives the additional subitem.
-     * @param keys
-     *            An array containing the path keys leading to where the value
-     *            has to be inserted.
-     * @param value
-     *            The value to be inserted.
-     * @throws JSONException
-     */
-    private static void addJSONSubTree(JSONObject destination, String[] keys, Object value) throws JSONException {
-        for (int i = 0; i < keys.length; i++) {
-            String subKey = keys[i];
-            if (i < keys.length - 1) {
-                JSONObject intermediate = null;
-                if (destination.isNull(subKey)) {
-                    intermediate = new JSONObject();
-                    destination.accumulate(subKey, intermediate);
-                } else {
-                    Object target = destination.get(subKey);
-                    if (target instanceof JSONObject) {
-                        intermediate = destination.getJSONObject(subKey);
-                    } else if (target instanceof JSONArray) {
-                        // Unexpected JSONArray, see issue #186
-                        JSONArray wildCard = destination.getJSONArray(subKey);
-                        for (int j = 0; j < wildCard.length(); j++) {
-                            intermediate = wildCard.optJSONObject(j);
-                            if (intermediate != null) {
-                                // Found the original JSONObject we were looking for
-                                break;
-                            }
-                        }
-                    }
-
-                    if (intermediate == null) {
-                        ACRA.log.e(ACRA.LOG_TAG, "Unknown json subtree type, see issue #186");
-                        // We should never get here, but if we do, drop this value to still send the report
-                        return;
-                    }
-                }
-                destination = intermediate;
-            } else {
-                destination.accumulate(subKey, value);
-            }
-        }
-    }
-
-    public static class JSONReportException extends Exception {
-        private static final long serialVersionUID = -694684023635442219L;
-
-        public JSONReportException(String message, Throwable e) {
-            super(message, e);
-        }
-    };
-}
diff --git a/src/main/java/org/acra/util/JsonUtils.java b/src/main/java/org/acra/util/JsonUtils.java
new file mode 100644
index 00000000..f05d09d9
--- /dev/null
+++ b/src/main/java/org/acra/util/JsonUtils.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.util;
+
+import android.util.Log;
+
+import org.acra.ReportField;
+import org.acra.model.ComplexElement;
+import org.acra.collector.CrashReportData;
+import org.acra.model.Element;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * @author F43nd1r
+ * @since 12.10.2016
+ */
+
+public final class JsonUtils {
+    private JsonUtils() {
+    }
+
+    public static JSONObject toJson(CrashReportData data) {
+        Map<String, Object> map = new HashMap<String, Object>();
+        for (Map.Entry<ReportField, Element> entry : data.entrySet()) {
+            Element element = entry.getValue();
+            map.put(entry.getKey().name(), element.value());
+        }
+        return new JSONObject(map);
+    }
+
+    public static CrashReportData toCrashReportData(JSONObject json) {
+        CrashReportData data = new CrashReportData();
+        for (Iterator<String> iterator = json.keys(); iterator.hasNext(); ) {
+            String key = iterator.next();
+            try {
+                ReportField field = ReportField.valueOf(key);
+                Object value = json.get(key);
+                if (value instanceof JSONObject) {
+                    data.put(field, new ComplexElement((JSONObject) value));
+                } else if (value instanceof Number) {
+                    data.putNumber(field, (Number) value);
+                } else if (value instanceof Boolean) {
+                    data.putBoolean(field, (Boolean) value);
+                } else {
+                    data.putString(field, value.toString());
+                }
+            } catch (IllegalArgumentException e) {
+                Log.w(LOG_TAG, "Unknown report key " + key, e);
+            } catch (JSONException e) {
+                Log.w(LOG_TAG, "Unable to read report field " + key, e);
+            }
+        }
+        return data;
+    }
+
+    public static List<String> flatten(JSONObject json) throws JSONException {
+        List<String> result = new ArrayList<String>();
+        for (Iterator<String> iterator = json.keys(); iterator.hasNext(); ) {
+            String key = iterator.next();
+            Object value = json.get(key);
+            if (value instanceof JSONObject) {
+                for (String s : flatten((JSONObject) value)) {
+                    result.add(key + "." + s);
+                }
+            } else {
+                result.add(key + "=" + value);
+            }
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/acra/util/NaiveTrustManager.java b/src/main/java/org/acra/util/NaiveTrustManager.java
deleted file mode 100644
index 57746ecd..00000000
--- a/src/main/java/org/acra/util/NaiveTrustManager.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- *  Copyright 2010 Kevin Gaudin
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.acra.util;
-
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.X509TrustManager;
-
-/**
- * Accepts any certificate, ideal for self-signed certificates.
- */
-class NaiveTrustManager implements X509TrustManager {
-    /*
-     * (non-Javadoc)
-     * 
-     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
-     */
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-        return new X509Certificate[0];
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkClientTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkClientTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * javax.net.ssl.X509TrustManager#checkServerTrusted(java.security.cert.
-     * X509Certificate[], java.lang.String)
-     */
-    @Override
-    public void checkServerTrusted(X509Certificate[] x509CertificateArray,
-            String string) throws CertificateException {
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/acra/util/NonBlockingBufferedReader.java b/src/main/java/org/acra/util/NonBlockingBufferedReader.java
new file mode 100644
index 00000000..e9ceb54b
--- /dev/null
+++ b/src/main/java/org/acra/util/NonBlockingBufferedReader.java
@@ -0,0 +1,57 @@
+package org.acra.util;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Asynchronously reads a buffer into a List of String.
+ *
+ * @author C-Romeo
+ * @since 4.9.0
+ */
+final class NonBlockingBufferedReader {
+
+    private final BlockingQueue<String> lines = new LinkedBlockingQueue<String>();
+    private Thread backgroundReaderThread = null;
+    private volatile IOException exception = null;
+
+    NonBlockingBufferedReader(final BufferedReader bufferedReader) {
+        backgroundReaderThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    while (!Thread.interrupted()) {
+                        final String line = bufferedReader.readLine();
+                        if (line == null) {
+                            break;
+                        }
+                        lines.add(line);
+                    }
+                } catch (IOException e) {
+                    exception = e;
+                } finally {
+                    IOUtils.safeClose(bufferedReader);
+                }
+            }
+        });
+        backgroundReaderThread.setDaemon(true);
+        backgroundReaderThread.start();
+    }
+
+    String readLine() throws InterruptedException, IOException {
+        if(exception != null){
+            throw exception;
+        }
+        return lines.isEmpty() ? null : lines.poll(500L, TimeUnit.MILLISECONDS);
+    }
+
+    void close() {
+        if (backgroundReaderThread != null) {
+            backgroundReaderThread.interrupt();
+            backgroundReaderThread = null;
+        }
+    }
+}
diff --git a/src/main/java/org/acra/util/PackageManagerWrapper.java b/src/main/java/org/acra/util/PackageManagerWrapper.java
index d5ef76c1..fc582d4b 100644
--- a/src/main/java/org/acra/util/PackageManagerWrapper.java
+++ b/src/main/java/org/acra/util/PackageManagerWrapper.java
@@ -1,11 +1,14 @@
 package org.acra.util;
 
-import static org.acra.ACRA.LOG_TAG;
-
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.util.Log;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+
+import static org.acra.ACRA.LOG_TAG;
 
 /**
  * Responsible for wrapping calls to PackageManager to ensure that they always complete without throwing RuntimeExceptions.
@@ -27,7 +30,7 @@
 
     private final Context context;
 
-    public PackageManagerWrapper(Context context) {
+    public PackageManagerWrapper(@NonNull Context context) {
         this.context = context;
     }
 
@@ -35,7 +38,7 @@ public PackageManagerWrapper(Context context) {
      * @param permission    Manifest.permission to check whether it has been granted.
      * @return true if the permission has been granted to the app, false if it hasn't been granted or the PackageManager could not be contacted.
      */
-    public boolean hasPermission(String permission) {
+    public boolean hasPermission(@NonNull String permission) {
         final PackageManager pm = context.getPackageManager();
         if (pm == null) {
             return false;
@@ -53,6 +56,7 @@ public boolean hasPermission(String permission) {
     /**
      * @return PackageInfo for the current application or null if the PackageManager could not be contacted.
      */
+    @Nullable
     public PackageInfo getPackageInfo() {
         final PackageManager pm = context.getPackageManager();
         if (pm == null) {
@@ -62,7 +66,7 @@ public PackageInfo getPackageInfo() {
         try {
             return pm.getPackageInfo(context.getPackageName(), 0);
         } catch (PackageManager.NameNotFoundException e) {
-            Log.v(LOG_TAG, "Failed to find PackageInfo for current App : " + context.getPackageName());
+            ACRA.log.w(LOG_TAG, "Failed to find PackageInfo for current App : " + context.getPackageName());
             return null;
         } catch (RuntimeException e) {
             // To catch RuntimeException("Package manager has died") that can occur on some version of Android,
diff --git a/src/main/java/org/acra/util/ProcessFinisher.java b/src/main/java/org/acra/util/ProcessFinisher.java
new file mode 100644
index 00000000..968106a1
--- /dev/null
+++ b/src/main/java/org/acra/util/ProcessFinisher.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2016
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.acra.util;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import org.acra.ACRA;
+import org.acra.builder.LastActivityManager;
+import org.acra.config.ACRAConfiguration;
+import org.acra.sender.SenderService;
+
+import java.util.List;
+
+import static org.acra.ACRA.LOG_TAG;
+
+/**
+ * Takes care of cleaning up a process and killing it.
+ *
+ * @author F43nd1r
+ * @since 4.9.2
+ */
+
+public final class ProcessFinisher {
+    private final Context context;
+    private final ACRAConfiguration config;
+    private final LastActivityManager lastActivityManager;
+
+    public ProcessFinisher(@NonNull Context context, @NonNull ACRAConfiguration config, @NonNull LastActivityManager lastActivityManager) {
+        this.context = context;
+        this.config = config;
+        this.lastActivityManager = lastActivityManager;
+    }
+
+    public void endApplication(@Nullable Thread uncaughtExceptionThread) {
+        finishLastActivity(uncaughtExceptionThread);
+        stopServices();
+        killProcessAndExit();
+    }
+
+    public void finishLastActivity(@Nullable Thread uncaughtExceptionThread) {
+        // Trying to solve https://github.com/ACRA/acra/issues/42#issuecomment-12134144
+        // Determine the current/last Activity that was started and close
+        // it. Activity#finish (and maybe it's parent too).
+        final Activity lastActivity = lastActivityManager.getLastActivity();
+        if (lastActivity != null) {
+            if (ACRA.DEV_LOGGING)
+                ACRA.log.d(LOG_TAG, "Finishing the last Activity prior to killing the Process");
+            lastActivity.runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    lastActivity.finish();
+                    if (ACRA.DEV_LOGGING)
+                        ACRA.log.d(LOG_TAG, "Finished " + lastActivity.getClass());
+                }
+            });
+
+            // A crashed activity won't continue its lifecycle. So we only wait if something else crashed
+            if (uncaughtExceptionThread != lastActivity.getMainLooper().getThread()) {
+                lastActivityManager.waitForActivityStop(100);
+            }
+            lastActivityManager.clearLastActivity();
+        }
+    }
+
+    private void stopServices() {
+        if (config.stopServicesOnCrash()) {
+            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+            final List<ActivityManager.RunningServiceInfo> runningServices = activityManager.getRunningServices(Integer.MAX_VALUE);
+            final int pid = Process.myPid();
+            for (ActivityManager.RunningServiceInfo serviceInfo : runningServices) {
+                if (serviceInfo.pid == pid && !SenderService.class.getName().equals(serviceInfo.service.getClassName())) {
+                    try {
+                        final Intent intent = new Intent();
+                        intent.setComponent(serviceInfo.service);
+                        context.stopService(intent);
+                    } catch (SecurityException e) {
+                        if (ACRA.DEV_LOGGING)
+                            ACRA.log.d(ACRA.LOG_TAG, "Unable to stop Service " + serviceInfo.service.getClassName() + ". Permission denied");
+                    }
+                }
+            }
+        }
+    }
+
+    private void killProcessAndExit() {
+        android.os.Process.killProcess(android.os.Process.myPid());
+        System.exit(10);
+    }
+}
diff --git a/src/main/java/org/acra/util/ReflectionException.java b/src/main/java/org/acra/util/ReflectionException.java
deleted file mode 100644
index 16bb0e26..00000000
--- a/src/main/java/org/acra/util/ReflectionException.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.acra.util;
-
-/**
- * Thrown when an error occurs during reflection.
- */
-public final class ReflectionException extends Exception  {
-
-    public ReflectionException(String msg, Throwable th) {
-        super(msg, th);
-    }
-}
diff --git a/src/main/java/org/acra/util/ReflectionHelper.java b/src/main/java/org/acra/util/ReflectionHelper.java
deleted file mode 100644
index 6463e309..00000000
--- a/src/main/java/org/acra/util/ReflectionHelper.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.acra.util;
-
-/**
- * Helps to construct objects via reflection.
- */
-public final class ReflectionHelper {
-
-    public Object create(String className) throws ReflectionException {
-        try {
-            final Class clazz = Class.forName(className);
-            return clazz.newInstance();
-        } catch (ClassNotFoundException e) {
-            throw new ReflectionException("Could not find class : " + className, e);
-        } catch (InstantiationException e) {
-            throw new ReflectionException("Could not instantiate class : " + className, e);
-        } catch (IllegalAccessException e) {
-            throw new ReflectionException("Could not access class : " + className, e);
-        }
-    }
-}
diff --git a/src/main/java/org/acra/util/ReportUtils.java b/src/main/java/org/acra/util/ReportUtils.java
deleted file mode 100644
index 0262acd0..00000000
--- a/src/main/java/org/acra/util/ReportUtils.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package org.acra.util;
-
-import java.io.File;
-import java.net.InetAddress;
-import java.net.NetworkInterface;
-import java.net.SocketException;
-import java.text.SimpleDateFormat;
-import java.util.Enumeration;
-import java.util.Locale;
-
-import org.acra.ACRA;
-import org.acra.ACRAConstants;
-
-import android.content.Context;
-import android.os.Environment;
-import android.os.StatFs;
-import android.telephony.TelephonyManager;
-import android.text.format.Time;
-import android.util.Log;
-import android.util.SparseArray;
-
-/**
- * Responsible for providing base utilities used when constructing the report.
- * <p/>
- * @author William Ferguson
- * @since 4.3.0
- */
-public final class ReportUtils {
-
-    /**
-     * Calculates the free memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Number of bytes available.
-     */
-    public static long getAvailableInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long availableBlocks = stat.getAvailableBlocks();
-        return availableBlocks * blockSize;
-    }
-
-    /**
-     * Calculates the total memory of the device. This is based on an inspection of the filesystem, which in android
-     * devices is stored in RAM.
-     *
-     * @return Total number of bytes.
-     */
-    public static long getTotalInternalMemorySize() {
-        final File path = Environment.getDataDirectory();
-        final StatFs stat = new StatFs(path.getPath());
-        final long blockSize = stat.getBlockSize();
-        final long totalBlocks = stat.getBlockCount();
-        return totalBlocks * blockSize;
-    }
-
-    /**
-     * Returns the DeviceId according to the TelephonyManager.
-     *
-     * @param context   Context for the application being reported.
-     * @return Returns the DeviceId according to the TelephonyManager or null if there is no TelephonyManager.
-     */
-    public static String getDeviceId(Context context) {
-        try {
-            final TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-            return tm.getDeviceId();
-        } catch (RuntimeException e) {
-            Log.w(ACRA.LOG_TAG, "Couldn't retrieve DeviceId for : " + context.getPackageName(), e);
-            return null;
-        }
-    }
-
-    public static String getApplicationFilePath(Context context) {
-        final File filesDir = context.getFilesDir();
-        if (filesDir != null) {
-            return filesDir.getAbsolutePath();
-        }
-
-        Log.w(ACRA.LOG_TAG, "Couldn't retrieve ApplicationFilePath for : " + context.getPackageName());
-        return "Couldn't retrieve ApplicationFilePath";
-    }
-    
-    /**
-     * Utility method used for debugging purposes, writes the content of a SparseArray to a String.
-     * @param sparseArray
-     * @return "{ key1 => value1, key2 => value2, ...}"
-     */
-    public static String sparseArrayToString(SparseArray<?> sparseArray) {
-        StringBuilder result = new StringBuilder();
-        if (sparseArray == null) {
-            return "null";
-        }
-
-        result.append('{');
-        for (int i = 0; i < sparseArray.size(); i++) {
-            result.append(sparseArray.keyAt(i));
-            result.append(" => ");
-            if (sparseArray.valueAt(i) == null) {
-                result.append("null");
-            } else {
-                result.append(sparseArray.valueAt(i).toString());
-            }
-            if(i < sparseArray.size() - 1) {
-                result.append(", ");
-            }
-        }
-        result.append('}');
-        return result.toString();
-    }
-
-    public static String getLocalIpAddress() {
-        StringBuilder result = new StringBuilder();
-        boolean first = true;
-        try {
-            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
-                NetworkInterface intf = en.nextElement();
-                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
-                    InetAddress inetAddress = enumIpAddr.nextElement();
-                    if (!inetAddress.isLoopbackAddress()) {
-                        if(!first) {
-                            result.append('\n');
-                        }
-                        result.append(inetAddress.getHostAddress().toString());
-                        first = false;
-                    }
-                }
-            }
-        } catch (SocketException ex) {
-            ACRA.log.w(ACRA.LOG_TAG, ex.toString());
-        }
-        return result.toString();
-    }
-
-    public static String getTimeString(Time time)
-    {
-        SimpleDateFormat format = new SimpleDateFormat(ACRAConstants.DATE_TIME_FORMAT_STRING, Locale.ENGLISH);
-        return format.format(time.toMillis(true));
-    }
-}
diff --git a/src/main/java/org/acra/util/TlsSniSocketFactory.java b/src/main/java/org/acra/util/TlsSniSocketFactory.java
deleted file mode 100644
index 5df6db09..00000000
--- a/src/main/java/org/acra/util/TlsSniSocketFactory.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * This class was copied from this blog post:
- * http://blog.dev001.net/post/67082904181/android-using-sni-and-tlsv1-2-with-apache-httpclient
- * Thanks go to Dev001!
- * Also, changes for using only secure cipher suites were included from code of DAVdroid.
- * Thankgs go to Ricki Hirner (bitfire web engineering)!
- */
-package org.acra.util;
-
-import android.annotation.TargetApi;
-import android.net.SSLCertificateSocketFactory;
-import android.os.Build;
-import android.text.TextUtils;
-import android.util.Log;
-
-import org.apache.http.conn.scheme.LayeredSocketFactory;
-import org.apache.http.conn.ssl.BrowserCompatHostnameVerifier;
-import org.apache.http.params.HttpParams;
-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-
-/**
- * Provides a SSLSocketFactory that is able to use SNI for SSL connections and
- * therefore allows multiple SSL servers on one IP address.<br/>
- *   1) socket = createSocket() is called
- *   2) reasonable encryption settings are applied to socket
- *   3) SNI is set up for socket
- *   4) handshake and certificate/host name verification
- * <p/>
- * @author Philipp Kapfer
- * @since 4.6.0
- */
-public class TlsSniSocketFactory implements LayeredSocketFactory {
-
-    private static final String TAG =  TlsSniSocketFactory.class.getSimpleName();
-    
-    private final static int VERSION_CODES_JELLY_BEAN_MR1 = 17;
-    private final static int VERSION_CODES_LOLLIPOP = 21;
-    
-    private final SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getDefault(0);
-
-    // use BrowserCompatHostnameVerifier to allow IP addresses in the Common Name
-    private final static HostnameVerifier hostnameVerifier = new BrowserCompatHostnameVerifier();
-
-    private static final List<String> ALLOWED_CIPHERS = Arrays.asList(
-        // allowed secure ciphers according to NIST.SP.800-52r1.pdf Section 3.3.1 (see http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-52r1.pdf)
-        // TLS 1.2
-        "TLS_RSA_WITH_AES_256_GCM_SHA384",
-        "TLS_RSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
-        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
-        "TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256",
-        // maximum interoperability
-        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_RSA_WITH_AES_128_CBC_SHA",
-        // additionally
-        "TLS_RSA_WITH_AES_256_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
-        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
-    );
-
-    // Plain TCP/IP (layer below TLS)
-
-    @Override
-    public Socket connectSocket(Socket s, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
-        return null;
-    }
-
-    @Override
-    public Socket createSocket() throws IOException {
-        return null;
-    }
-
-    @Override
-    public boolean isSecure(Socket s) throws IllegalArgumentException {
-        return (s instanceof SSLSocket) && s.isConnected();
-    }
-
-
-    // TLS layer
-
-    @Override
-    public Socket createSocket(Socket plainSocket, String host, int port, boolean autoClose) throws IOException {
-        if (autoClose) {
-            // we don't need the plainSocket
-            plainSocket.close();
-        }
-
-        // create and connect SSL socket, but don't do hostname/certificate verification yet
-        final SSLSocket ssl = (SSLSocket) sslSocketFactory.createSocket(InetAddress.getByName(host), port);
-
-        // establish and verify TLS connection
-        establishAndVerify(ssl, host);
-
-        return ssl;
-    }
-    
-    /**
-     * Establishes and verifies a TLS connection to a (TCP-)connected SSLSocket:
-     *   - set TLS parameters like allowed protocols and ciphers
-     *   - set SNI host name
-     *   - verify host name
-     *   - verify certificate
-     * @param socket    unconnected SSLSocket
-     * @param host      host name for SNI
-     * @throws IOException if the connection could not be established.
-     */
-    private void establishAndVerify(SSLSocket socket, String host) throws IOException {
-        setTlsParameters(socket);
-        setSniHostname(socket, host);
-        
-        // TLS handshake, throws an exception for untrusted certificates
-        socket.startHandshake();
-
-        // verify hostname and certificate
-        SSLSession session = socket.getSession();
-        if (!hostnameVerifier.verify(host, session)) {
-            // throw exception for invalid host names
-            throw new SSLPeerUnverifiedException(host);
-        }
-
-        Log.i(TAG, "Established " + session.getProtocol() + " connection with " + session.getPeerHost() + " using " + session.getCipherSuite());
-    }
-    
-    /**
-     * Prepares a TLS/SSL connection socket by:
-     *   - setting reasonable TLS protocol versions
-     *   - setting reasonable cipher suites (if required)
-     * @param socket   unconnected SSLSocket to prepare
-     */
-    private void setTlsParameters(SSLSocket socket) {
-        // Android 5.0+ (API level21) provides reasonable default settings
-        // but it still allows SSLv3
-        // https://developer.android.com/about/versions/android-5.0-changes.html#ssl
-
-        /* set reasonable protocol versions */
-        // - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android <5.0)
-        // - remove all SSL versions (especially SSLv3) because they're insecure now
-        final List<String> protocols = new LinkedList<String>();
-        for (String protocol : socket.getSupportedProtocols()) {
-            if (!protocol.toUpperCase().contains("SSL")) {
-                protocols.add(protocol);
-            }
-        }
-        Log.v(TAG, "Setting allowed TLS protocols: " + TextUtils.join(", ", protocols));
-        socket.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));
-
-        /* set reasonable cipher suites */
-        if (Build.VERSION.SDK_INT < VERSION_CODES_LOLLIPOP) {
-            // choose secure cipher suites
-
-            final List<String> availableCiphers = Arrays.asList(socket.getSupportedCipherSuites());
-            
-            // preferred ciphers = allowed Ciphers \ availableCiphers
-            final Set<String> preferredCiphers = new HashSet<String>(ALLOWED_CIPHERS);
-            preferredCiphers.retainAll(availableCiphers);
-            
-            // add enabled ciphers to preferred ciphers
-            // for maximum security, preferred ciphers should *replace* enabled ciphers,
-            // but for the security level of ACRA, disabling of insecure
-            // ciphers should be a server-side task
-            preferredCiphers.addAll(Arrays.asList(socket.getEnabledCipherSuites()));
-            
-            Log.v(TAG, "Setting allowed TLS ciphers: " + TextUtils.join(", ", preferredCiphers));
-            socket.setEnabledCipherSuites(preferredCiphers.toArray(new String[preferredCiphers.size()]));
-        }
-    }
-    
-    @TargetApi(VERSION_CODES_JELLY_BEAN_MR1)
-    private void setSniHostname(SSLSocket socket, String hostName) {
-        // set SNI host name
-        if (Build.VERSION.SDK_INT >= VERSION_CODES_JELLY_BEAN_MR1) {
-            Log.d(TAG, "Using documented SNI with host name " + hostName);
-            sslSocketFactory.setHostname(socket, hostName);
-        } else {
-            Log.d(TAG, "No documented SNI support on Android <4.2, trying reflection method with host name " + hostName);
-            try {
-                final Method setHostnameMethod = socket.getClass().getMethod("setHostname", String.class);
-                setHostnameMethod.invoke(socket, hostName);
-            } catch (Exception e) {
-                Log.w(TAG, "SNI not usable", e);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/acra/util/ToastSender.java b/src/main/java/org/acra/util/ToastSender.java
index f1bb245f..d467207a 100644
--- a/src/main/java/org/acra/util/ToastSender.java
+++ b/src/main/java/org/acra/util/ToastSender.java
@@ -1,31 +1,36 @@
 package org.acra.util;
 
-import org.acra.ACRA;
-
 import android.content.Context;
-import android.util.Log;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.StringRes;
 import android.widget.Toast;
 
+import org.acra.ACRA;
+
+import static org.acra.ACRA.LOG_TAG;
+
 /**
  * Responsible for sending Toasts under all circumstances.
- * <p/>
+ *
  * @author William Ferguson
  * @since 4.3.0
  */
 public final class ToastSender {
+    private ToastSender(){}
 
     /**
      * Sends a Toast and ensures that any Exception thrown during sending is handled.
      *
-     * @param context           Application context.
-     * @param toastResourceId   Id of the resource to send as the Toast message.
-     * @param toastLength       Length of the Toast.
+     * @param context         Application context.
+     * @param toastResourceId Id of the resource to send as the Toast message.
+     * @param toastLength     Length of the Toast.
      */
-    public static void sendToast(Context context, int toastResourceId, int toastLength) {
+    public static void sendToast(@NonNull Context context, @StringRes int toastResourceId, @IntRange(from = 0, to = 1) int toastLength) {
         try {
             Toast.makeText(context, toastResourceId, toastLength).show();
         } catch (RuntimeException e) {
-            Log.e(ACRA.LOG_TAG, "Could not send crash Toast", e);
+            ACRA.log.w(LOG_TAG, "Could not send crash Toast", e);
         }
     }
 }
diff --git a/src/main/proguard/proguard.cfg b/src/main/proguard/proguard.cfg
new file mode 100644
index 00000000..5c4d5e30
--- /dev/null
+++ b/src/main/proguard/proguard.cfg
@@ -0,0 +1,19 @@
+#ACRA specifics
+# Restore some Source file names and restore approximate line numbers in the stack traces,
+# otherwise the stack traces are pretty useless
+-keepattributes SourceFile,LineNumberTable
+
+# ACRA needs "annotations" so add this...
+# Note: This may already be defined in the default "proguard-android-optimize.txt"
+# file in the SDK. If it is, then you don't need to duplicate it. See your
+# "project.properties" file to get the path to the default "proguard-android-optimize.txt".
+-keepattributes *Annotation*
+
+# Keep all the ACRA classes
+-keep class org.acra.** { *; }
+
+# Don't warn about removed methods from AppCompat
+-dontwarn android.support.v4.app.NotificationCompat*
+
+# These classes are constucted with reflection.
+-keep public class * implements org.acra.sender.ReportSenderFactory { public <methods>; }
diff --git a/src/main/res/values/strings.xml b/src/main/res/values/strings.xml
new file mode 100644
index 00000000..a3d564ca
--- /dev/null
+++ b/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+This file is just here to force android-maven-plugin:4.4.3 to include a /res folder in the AAR
+which is now a requirement https://developer.android.com/studio/projects/android-library.html#aar-contents
+-->
+<resources>
+    <string name="not_used">Only here to ensure that android-maven-plugin:4.4.3 creates an R.txt</string>
+</resources>
diff --git a/src/test/java/org/acra/log/NonAndroidLog.java b/src/test/java/org/acra/log/NonAndroidLog.java
index a132f290..28f3f601 100644
--- a/src/test/java/org/acra/log/NonAndroidLog.java
+++ b/src/test/java/org/acra/log/NonAndroidLog.java
@@ -1,13 +1,13 @@
 package org.acra.log;
 
 
+import android.support.annotation.NonNull;
+
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.Writer;
 
-import android.util.Log;
-
 /**
  * Responsible for delegating calls to the Android logging system.
  * <p/>
@@ -31,7 +31,7 @@
     /**
      * Any log that is output at level less that the supplied logLevel will be ignored.
      * <p>
-     *     The deault log level is {@link NonAndroidLog#VERBOSE}
+     *     The default log level is {@link NonAndroidLog#VERBOSE}
      * </p>
      *
      * @param logLevel LogLevel to use to filter log output.
@@ -47,7 +47,7 @@ public int v(String tag, String msg) {
         return 0;
     }
 
-    public int v(String tag, String msg, Throwable tr) {
+    public int v(String tag, String msg, @NonNull Throwable tr) {
         if (logLevel <= VERBOSE) {
             out.println(tag + " : " + msg);
             tr.printStackTrace(out);
@@ -62,7 +62,7 @@ public int d(String tag, String msg) {
         return 0;
     }
 
-    public int d(String tag, String msg, Throwable tr) {
+    public int d(String tag, String msg, @NonNull Throwable tr) {
         if (logLevel <= DEBUG) {
             out.println(tag + " : " + msg);
             tr.printStackTrace(out);
@@ -77,7 +77,7 @@ public int i(String tag, String msg) {
         return 0;
     }
 
-    public int i(String tag, String msg, Throwable tr) {
+    public int i(String tag, String msg, @NonNull Throwable tr) {
         if (logLevel <= INFO) {
             out.println(tag + " : " + msg);
             tr.printStackTrace(out);
@@ -92,7 +92,7 @@ public int w(String tag, String msg) {
         return 0;
     }
 
-    public int w(String tag, String msg, Throwable tr) {
+    public int w(String tag, String msg, @NonNull Throwable tr) {
         if (logLevel <= WARN) {
             out.println(tag + " : " + msg);
             tr.printStackTrace(out);
@@ -101,8 +101,12 @@ public int w(String tag, String msg, Throwable tr) {
     }
 
     //public native  boolean isLoggable(java.lang.String tag, int level);
-    public int w(String tag, Throwable tr) {
-        return Log.w(tag, tr);
+    public int w(String tag, @NonNull Throwable tr) {
+        if (logLevel <= WARN) {
+            out.println(tag + " : ");
+            tr.printStackTrace(out);
+        }
+        return 0;
     }
 
     public int e(String tag, String msg) {
@@ -112,7 +116,7 @@ public int e(String tag, String msg) {
         return 0;
     }
 
-    public int e(String tag, String msg, Throwable tr) {
+    public int e(String tag, String msg, @NonNull Throwable tr) {
         if (logLevel <= ERROR) {
             out.println(tag + " : " + msg);
             tr.printStackTrace(out);
diff --git a/src/test/java/org/acra/util/HttpRequestTest.java b/src/test/java/org/acra/util/HttpRequestTest.java
deleted file mode 100644
index 10a9a1fc..00000000
--- a/src/test/java/org/acra/util/HttpRequestTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.acra.util;
-
-
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.acra.ACRA;
-import org.acra.log.NonAndroidLog;
-import org.acra.sender.HttpSender.Method;
-import org.acra.sender.HttpSender.Type;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-/**
- * Responsible for testing HttpRequest.
- * <p/>
- * User: William
- * Date: 17/07/11
- * Time: 9:37 AM
- */
-public class HttpRequestTest {
-
-    // This is a form for a publicly viewable GoogleDoc
-    // The Doc is viewable at https://spreadsheets.google.com/spreadsheet/ccc?key=0Al8DtaRlEtcodDAtVDRabnhvZVdIOUxXWTFEM3gzSlE
-    private static final String FORM_KEY = "dDAtVDRabnhvZVdIOUxXWTFEM3gzSlE6MQ";
-
-    @Before
-    public void setUp() throws Exception {
-        final NonAndroidLog log = new NonAndroidLog();
-        ACRA.setLog(log);
-        ACRA.getConfig().setDisableSSLCertValidation(true);
-    }
-
-
-    @Test
-    public void testSocketTimeOutCausesRequestToBeRetriedSeveralTimes_Issue63() throws Exception {
-
-        final URL url = new URL("https://spreadsheets.google.com/formResponse?formkey=" + FORM_KEY + "&amp;ifq");
-        final Map<String, String> params = new HashMap<String, String>();
-
-        // Values observed in the GoogleDocs original html form. I presume they are required to ensure the GoogleDoc form is posted to the spreadsheet.
-        params.put("pageNumber", "0");
-        params.put("backupCache", "");
-        params.put("submit", "Envoyer");
-
-        params.put("entry.0.single", "HttpRequestTest#testIssue63");
-        params.put("entry.1.single", new Date().toString());
-
-        final HttpRequest request = new HttpRequest();
-        request.setSocketTimeOut(100); // Set a very low SocketTimeOut. Something that will almost certainly fail.
-        request.setMaxNrRetries(0);
-
-        // Context will be null because default HttpsSocketFactoryFactory doesn't require the Android Context.
-        try {
-            request.send(null /*context*/, url, Method.POST, HttpRequest.getParamsAsFormString(params), Type.FORM);
-            Assert.fail("Should not be able to get a response with an impossibly low SocketTimeOut");
-        } catch (SocketTimeoutException e) {
-            // as expected.
-        }
-
-        // Tell the HttpRequest to retry on Socket time out.
-        request.setMaxNrRetries(5);
-        try {
-            request.send(null /*context*/, url, Method.POST, HttpRequest.getParamsAsFormString(params), Type.FORM);
-        } catch (SocketTimeoutException e) {
-            Assert.fail("Should not get a SocketTimeOut when using SocketTimeOutRetryHandler");
-        }
-    }
-}
