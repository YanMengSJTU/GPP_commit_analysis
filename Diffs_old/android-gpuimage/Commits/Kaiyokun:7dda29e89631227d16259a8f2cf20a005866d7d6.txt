diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index 855b72c5..f50e5a4c 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -24,10 +24,39 @@
             </intent-filter>
         </activity>
         <activity android:name=".activity.ActivityGallery" />
+        <activity android:name="com.ict.camera.CameraActivity" />
         <activity
             android:name="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityCamera"
             android:screenOrientation="portrait"
             android:theme="@style/AppTheme.NoActionBar" />
     </application>
 
+    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
+    <uses-permission android:name="android.permission.CAMERA"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-permission android:name="android.permission.RESTART_PACKAGES"/>
+    <uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/>
+    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
+
+    <uses-feature android:name="android.hardware.camera"/>
+    <uses-feature android:name="android.hardware.camera.autofocus"/>
+    <uses-feature android:name="android.hardware.camera2.full"/>
+
+    <uses-permission android:name="android.permission.VIBRATE"/>
+    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>
+    <uses-permission android:name="android.permission.GET_TASKS"/>
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
+    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
 </manifest>
\ No newline at end of file
diff --git a/sample/res/layout/activity_camera.xml b/sample/res/layout/activity_camera.xml
index 16a64d0d..04a2b5fc 100644
--- a/sample/res/layout/activity_camera.xml
+++ b/sample/res/layout/activity_camera.xml
@@ -7,7 +7,12 @@
         android:id="@+id/surfaceView"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
-        android:layout_above="@+id/bar" />
+        android:layout_below="@+id/img_switch_camera"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        android:layout_marginLeft="456dp"
+        android:layout_marginStart="456dp"
+        android:layout_marginTop="113dp" />
 
     <ImageView
         android:id="@+id/img_switch_camera"
diff --git a/sample/res/layout/main.xml b/sample/res/layout/main.xml
new file mode 100644
index 00000000..47a1d44f
--- /dev/null
+++ b/sample/res/layout/main.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <Button
+        android:id="@+id/btn_start"
+        android:layout_width="100dp"
+        android:layout_height="wrap_content"
+        android:text="开始" />
+    <Button
+        android:id="@+id/btn_stop"
+        android:layout_width="100dp"
+        android:layout_height="wrap_content"
+        android:text="停止" />
+
+</LinearLayout>
diff --git a/sample/src/cn/ict/xhealth/exception/ArgumentExpt.java b/sample/src/cn/ict/xhealth/exception/ArgumentExpt.java
new file mode 100644
index 00000000..d26b7755
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/ArgumentExpt.java
@@ -0,0 +1,15 @@
+package cn.ict.xhealth.exception;
+
+/**
+ * 参数异常
+ * @author yingzi
+ *
+ */
+public class ArgumentExpt extends XHCustomException 
+{
+   
+   public ArgumentExpt(String detailMessage) 
+   {
+	   super(detailMessage);
+   }
+}
diff --git a/sample/src/cn/ict/xhealth/exception/AuthExpt.java b/sample/src/cn/ict/xhealth/exception/AuthExpt.java
new file mode 100644
index 00000000..7bc4275b
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/AuthExpt.java
@@ -0,0 +1,15 @@
+package cn.ict.xhealth.exception;
+
+/**
+ * 验证异常
+ * @author yingzi
+ *
+ */
+public class AuthExpt extends XHCustomException 
+{
+   
+   public AuthExpt(String detailMessage) 
+   {
+	   super(detailMessage);
+   }
+}
diff --git a/sample/src/cn/ict/xhealth/exception/ConnectExpt.java b/sample/src/cn/ict/xhealth/exception/ConnectExpt.java
new file mode 100644
index 00000000..7d11756e
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/ConnectExpt.java
@@ -0,0 +1,15 @@
+package cn.ict.xhealth.exception;
+
+/**
+ * 与服务器通信异常
+ * @author yingzi
+ *
+ */
+public class ConnectExpt extends XHCustomException 
+{
+   
+   public ConnectExpt() 
+   {
+	   super("There is no network available ");
+   }
+}
diff --git a/sample/src/cn/ict/xhealth/exception/DefaultExpt.java b/sample/src/cn/ict/xhealth/exception/DefaultExpt.java
new file mode 100644
index 00000000..ad80d4b2
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/DefaultExpt.java
@@ -0,0 +1,79 @@
+package cn.ict.xhealth.exception;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import android.content.Context;
+import android.os.Environment;
+import android.util.Log;
+
+/**
+ * 未捕获异常类
+ * @author yingzi
+ *
+ */
+public class DefaultExpt implements XHDefaultExceptionHandler{
+
+	private static DefaultExpt defaultExpt;
+	private Context mContext;
+	private Thread.UncaughtExceptionHandler mDefaultHandler;
+
+	private DefaultExpt() {
+	}
+
+	/**
+	 * 获取UncaughtException对象
+	 * 
+	 * @return
+	 */
+	public static DefaultExpt getInstance() {
+		if (defaultExpt == null) {
+			synchronized (DefaultExpt.class) {
+				if (defaultExpt == null) {
+					defaultExpt = new DefaultExpt();
+				}
+			}
+		}
+		return defaultExpt;
+	}
+
+	@Override
+	public void init(Context context) {
+		this.mContext = context;
+		this.mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
+		Thread.setDefaultUncaughtExceptionHandler(this);
+	}
+
+	@Override
+	public void uncaughtException(Thread thread, Throwable ex) {
+		dumpExToSDCard(ex);
+	}
+
+	@Override
+	public void dumpExToSDCard(Throwable ex) {
+		String path = Environment.getExternalStorageDirectory()
+				+ File.separator + "exception.txt";
+		FileHandler fileHandler = new FileHandler();
+		File file = fileHandler.createNewFile(path);
+		fileHandler.savedToText(file, getNeedDeviceThrowableInfo(ex), true);
+	}
+
+	private String getNeedDeviceThrowableInfo(Throwable throwable) {
+		Writer writer = new StringWriter();
+		PrintWriter printWriter = new PrintWriter(writer);
+		throwable.printStackTrace(printWriter);
+		Throwable cause = throwable.getCause();
+		while (cause != null) {
+			cause.printStackTrace(printWriter);
+			cause = cause.getCause();
+		}
+		printWriter.close();
+		return writer.toString();
+	}
+
+}
diff --git a/sample/src/cn/ict/xhealth/exception/FileHandler.java b/sample/src/cn/ict/xhealth/exception/FileHandler.java
new file mode 100644
index 00000000..f15cb284
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/FileHandler.java
@@ -0,0 +1,168 @@
+package cn.ict.xhealth.exception;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+
+import android.os.Environment;
+
+/**
+ * 文件操作类
+ * 
+ * @author yingzi
+ * 
+ */
+public class FileHandler {
+	/**
+	 * 创建新文件filePath。
+	 * 如果文件不存在，则先判断父目录是否存在，父目录不存在则创建父目录，如果父目录创建失败则返回null。父目录创建成功后，再在当前目录下创建该文件
+	 * 
+	 * @param filePath
+	 *            需要创建的文件的绝对路径
+	 * @return 返回创建的文件file，父目录创建失败，返回null
+	 */
+	public File createNewFile(String filePath) {
+		File file = new File(filePath);
+		if (!file.exists()) {
+			if (!isFolderExists(file.getParent())) { return null; }
+			try {
+				file.createNewFile();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+
+		return file;
+	}
+
+	/**
+	 * 判断文件路径是否存在
+	 * 
+	 * @param path
+	 * @return
+	 */
+	public Boolean isFileExisted(String path) {
+		return (new File(path)).exists();
+	}
+
+	/**
+	 * 判断是否有SD卡
+	 * 
+	 * @return
+	 */
+	public Boolean hasSdcard() {
+		String state = Environment.getExternalStorageState();
+		if (state.equals(Environment.MEDIA_MOUNTED)) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	/**
+	 * 判断目录路径（只包含所有文件夹）是否存在，不存在则创建此路径
+	 * 
+	 * @param path
+	 * @return
+	 */
+	public Boolean isFolderExists(String path) {
+		if (!isFileExisted(path)) {
+			File file = new File(path);
+			if (file.mkdir() || file.mkdirs()) {
+				return true;
+			} else {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * 把text写到file中，isAppend为true时，则在原来的基础上增加数据，isAppend为false,则覆盖原有数据
+	 * 
+	 * @param file
+	 * @param text
+	 * @param isAppend
+	 */
+	public void savedToText(File file, String text, boolean isAppend) {
+		if (hasSdcard() && null != file) {
+			OutputStreamWriter outWriter = null;
+			try {
+				if (!file.exists()) {
+					file.createNewFile();
+					outWriter = new OutputStreamWriter(new FileOutputStream(
+							file), "utf-8");
+				} else {
+					outWriter = new OutputStreamWriter(new FileOutputStream(
+							file, isAppend), "utf-8");
+				}
+				outWriter.write(text);
+				outWriter.flush();
+				outWriter.close();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+		}
+
+	}
+
+	/**
+	 * 删除文件
+	 * 
+	 * @param file
+	 */
+	public void deleteFile(File file) {
+		if (file.exists()) {
+			if (file.isFile()) {
+				file.delete();
+			} else if (file.isDirectory()) {
+				File files[] = file.listFiles();
+				for (int i = 0; i < files.length; i++) {
+					this.deleteFile(files[i]);
+				}
+				file.delete();
+			}
+
+		}
+	}
+
+	/**
+	 * 把b保存到路径outputFile下的文件中
+	 * 
+	 * @param b
+	 *            需要保存的byte数组
+	 * @param outputFile
+	 *            文件路径
+	 */
+	public static void getFileFromBytes(byte[] b, String outputFile) {
+		BufferedOutputStream stream = null;
+		File file = null;
+		FileOutputStream fstream = null;
+		try {
+			file = new File(outputFile);
+			fstream = new FileOutputStream(file);
+			stream = new BufferedOutputStream(fstream);
+			stream.write(b);
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			if (stream != null) {
+				try {
+					stream.close();
+				} catch (IOException e1) {
+					e1.printStackTrace();
+				}
+			}
+			if (fstream != null) {
+				try {
+					fstream.close();
+				} catch (IOException e1) {
+					e1.printStackTrace();
+				}
+			}
+		}
+	}
+}
diff --git a/sample/src/cn/ict/xhealth/exception/InitializeExpt.java b/sample/src/cn/ict/xhealth/exception/InitializeExpt.java
new file mode 100644
index 00000000..61d2cc97
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/InitializeExpt.java
@@ -0,0 +1,10 @@
+package cn.ict.xhealth.exception;
+
+public class InitializeExpt extends XHCustomException 
+{
+	   public InitializeExpt(String detailMessage) 
+	   {
+		   super(detailMessage);
+	   }
+	}
+
diff --git a/sample/src/cn/ict/xhealth/exception/PermissionExpt.java b/sample/src/cn/ict/xhealth/exception/PermissionExpt.java
new file mode 100644
index 00000000..9e85605e
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/PermissionExpt.java
@@ -0,0 +1,13 @@
+package cn.ict.xhealth.exception;
+
+/**
+ * 权限异常
+ * @author yingzi
+ *
+ */
+public class PermissionExpt extends XHCustomException {
+
+	public PermissionExpt(String detailMessage) {
+		super("you don't have permission "+detailMessage);
+	}
+}
diff --git a/sample/src/cn/ict/xhealth/exception/StorageExpt.java b/sample/src/cn/ict/xhealth/exception/StorageExpt.java
new file mode 100644
index 00000000..14365e79
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/StorageExpt.java
@@ -0,0 +1,13 @@
+//Source file: D:\\test\\cn\\ict\\exception\\StorageExpt.java
+
+package cn.ict.xhealth.exception;
+
+
+public class StorageExpt extends XHCustomException 
+{
+   
+   public StorageExpt(String detailMessage) 
+   {
+	   super(detailMessage);
+   }
+}
diff --git a/sample/src/cn/ict/xhealth/exception/UserInfoExpt.java b/sample/src/cn/ict/xhealth/exception/UserInfoExpt.java
new file mode 100644
index 00000000..fac1f23a
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/UserInfoExpt.java
@@ -0,0 +1,14 @@
+package cn.ict.xhealth.exception;
+
+/**
+ * 用户信息异常
+ * @author yingzi
+ *
+ */
+public class UserInfoExpt extends XHCustomException 
+{
+   public UserInfoExpt(String detailMessage) 
+   {
+	   super(detailMessage);
+   }
+}
diff --git a/sample/src/cn/ict/xhealth/exception/XHCustomException.java b/sample/src/cn/ict/xhealth/exception/XHCustomException.java
new file mode 100644
index 00000000..fa217f5c
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/XHCustomException.java
@@ -0,0 +1,48 @@
+package cn.ict.xhealth.exception;
+
+import android.util.Log;
+
+/**
+ * 知晓的异常
+ * @author yingzi
+ *
+ */
+public class XHCustomException extends Exception{
+	
+	
+	public XHCustomException(){
+		super();
+	}
+	
+	/**
+	 * @param detailMessage 异常详细信息
+	 */
+	public XHCustomException(String detailMessage){
+		super(detailMessage);
+	}
+	
+	/**
+	 * 获取Sdk版本名
+	 * @return
+	 */
+	
+	/**
+	 * 获取sdk版本号
+	 * @return
+	 */
+	
+	/**
+	 * 异常发生所在的类名、方法名、行号组成的hashcode
+	 * @return
+	 */
+	public int getHashId(){
+		StackTraceElement[] stackTrace = this.getStackTrace();
+		StringBuilder stringBuilder = new StringBuilder();
+		stringBuilder.append(stackTrace[0].getClassName())
+				.append(stackTrace[0].getMethodName())
+				.append(stackTrace[0].getLineNumber());
+		Log.e("XHCustomException", ""+stringBuilder.toString());
+		return stringBuilder.toString().hashCode();
+	}
+	
+}
diff --git a/sample/src/cn/ict/xhealth/exception/XHDefaultExceptionHandler.java b/sample/src/cn/ict/xhealth/exception/XHDefaultExceptionHandler.java
new file mode 100644
index 00000000..90994a0e
--- /dev/null
+++ b/sample/src/cn/ict/xhealth/exception/XHDefaultExceptionHandler.java
@@ -0,0 +1,42 @@
+package cn.ict.xhealth.exception;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+
+import android.content.Context;
+
+
+/**
+ * 系统的未捕获异常接口
+ * @author yingzi
+ *
+ */
+public interface XHDefaultExceptionHandler extends UncaughtExceptionHandler
+{
+   
+  /**
+   * 初始化
+   * 设置默认的异常处理程序
+   * @param context
+   */
+   public void init(Context context);
+   
+  /**
+   * 出现未捕获的异常时系统自动调用的函数处理
+   */
+   public void uncaughtException(Thread thread, Throwable ex);
+   
+   /**
+    * 把异常保存到SD卡txt文档中
+    * @param ex 异常
+    */
+   public void dumpExToSDCard(Throwable ex);
+//   
+//   /**
+//    *   把异常上传到服务器上
+//    * @param ex 异常
+//    * @param add 标记哪个通信接口
+//    * @return 返回上传结果
+//    * @throws Exception
+//    */
+//   public void uploadToServer(Throwable ex, GatewayType add) throws Exception;
+}
diff --git a/sample/src/com/ict/camera/CameraActivity.java b/sample/src/com/ict/camera/CameraActivity.java
new file mode 100644
index 00000000..abcd3e84
--- /dev/null
+++ b/sample/src/com/ict/camera/CameraActivity.java
@@ -0,0 +1,59 @@
+package com.ict.camera;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import jp.co.cyberagent.android.gpuimage.sample.R;
+
+public class CameraActivity extends Activity implements OnClickListener {
+	private CameraHandler cameraHandler;
+	private CameraManagerFive cameraManagerFive;
+	private boolean start = false;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.main);
+		Button btnStart = (Button) findViewById(R.id.btn_start);
+		btnStart.setOnClickListener(this);
+		Button btnStop = (Button) findViewById(R.id.btn_stop);
+		btnStop.setOnClickListener(this);
+	}
+
+	@Override
+	protected void onPause() {
+		if (start)
+			cameraHandler.closeCamera();
+		super.onPause();
+
+	}
+
+	@Override
+	public void onClick(View v) {
+		switch (v.getId()) {
+		case R.id.btn_start:
+			if(!start){
+			cameraHandler = CameraFactory
+					.getCameraHandler(getApplicationContext());
+			DataProcessor dataProcessor = new DataModel(getApplicationContext());
+			cameraHandler.setDataProcessor(dataProcessor);
+			cameraHandler.openCamera();
+			start = true;
+			}
+			break;
+
+		case R.id.btn_stop:
+			if (start) {
+				cameraHandler.closeCamera();
+				start = false;
+			}
+			break;
+		default:
+			break;
+		}
+
+	}
+
+}
diff --git a/sample/src/com/ict/camera/CameraFactory.java b/sample/src/com/ict/camera/CameraFactory.java
new file mode 100644
index 00000000..b7ce22f0
--- /dev/null
+++ b/sample/src/com/ict/camera/CameraFactory.java
@@ -0,0 +1,32 @@
+package com.ict.camera;
+
+
+import android.content.Context;
+/**
+ *摄像头工厂
+ * @author yingzi
+ */
+public class CameraFactory {
+	/**
+	 * 根据sdk版本，返回对应的CameraHandler
+	 * @param context
+	 * @return
+	 */
+	public static CameraHandler getCameraHandler(Context context){
+		int sdkVersion = android.os.Build.VERSION.SDK_INT;
+		if(sdkVersion > 13 && sdkVersion < 21){
+			CameraManagerFour cameraHandler = new CameraManagerFour();
+			cameraHandler.intData(context);
+			return cameraHandler;
+			
+		}else if(sdkVersion >= 21){
+			CameraManagerFive cameraHandler = new CameraManagerFive();
+			cameraHandler.intData(context);
+			return cameraHandler;
+		}else {
+			return null;
+		}
+		
+	}
+
+}
diff --git a/sample/src/com/ict/camera/CameraHandler.java b/sample/src/com/ict/camera/CameraHandler.java
new file mode 100644
index 00000000..f3c0d91f
--- /dev/null
+++ b/sample/src/com/ict/camera/CameraHandler.java
@@ -0,0 +1,24 @@
+package com.ict.camera;
+
+/**
+ * 摄像头接口
+ * @author yingzi
+ *
+ */
+public interface CameraHandler {
+	/**
+	 * 设置数据回调接口DataProcessor
+	 * @param dp
+	 */
+	public void setDataProcessor(DataProcessor dp);
+
+	/**
+	 * 打开摄像头
+	 */
+	public void openCamera();
+
+	/**
+	 *关闭摄像头
+	 */
+	public void closeCamera();
+}
diff --git a/sample/src/com/ict/camera/CameraManagerFive.java b/sample/src/com/ict/camera/CameraManagerFive.java
new file mode 100644
index 00000000..16b55921
--- /dev/null
+++ b/sample/src/com/ict/camera/CameraManagerFive.java
@@ -0,0 +1,352 @@
+package com.ict.camera;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.Comparator;
+
+import javax.security.auth.login.LoginException;
+
+import cn.ict.xhealth.exception.ArgumentExpt;
+import cn.ict.xhealth.exception.DefaultExpt;
+import cn.ict.xhealth.exception.InitializeExpt;
+import cn.ict.xhealth.exception.PermissionExpt;
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.pm.FeatureInfo;
+import android.content.pm.PackageManager;
+import android.graphics.ImageFormat;
+import android.graphics.SurfaceTexture;
+import android.hardware.camera2.CameraAccessException;
+import android.hardware.camera2.CameraCaptureSession;
+import android.hardware.camera2.CameraCharacteristics;
+import android.hardware.camera2.CameraDevice;
+import android.hardware.camera2.CameraManager;
+import android.hardware.camera2.CameraMetadata;
+import android.hardware.camera2.CaptureRequest;
+import android.hardware.camera2.params.StreamConfigurationMap;
+import android.media.Image;
+import android.media.ImageReader;
+import android.media.ImageReader.OnImageAvailableListener;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+import android.util.Size;
+import android.view.Surface;
+import android.view.View.MeasureSpec;
+
+/**
+ * 适合android5.0以上，android6.0以下的系统调用
+ * @author yingzi
+ *
+ */
+public class CameraManagerFive implements CameraHandler {
+	public static final String TAG = "CameraManagerFive";
+	
+	private Size mPreviewSize;
+	private CameraDevice mCameraDevice;
+	private CaptureRequest.Builder mPreviewBuilder;
+	private CameraCaptureSession mPreviewSession;
+	private Context mContext;
+	private String currentCameraId;
+	private boolean isLight;
+	private CameraManager manager;
+	private boolean isInit;
+	private DataProcessor dataProcessor;
+	private Looper looper;
+	private MyHandler myHandler = null;
+	private OpenCameraThread gThread;
+	private ImageReader iReader;
+	private Surface mSurface;
+
+	/**
+	 * 设置数据回调接口DataProcessor
+	 * @param dp
+	 */
+	@Override
+	public void setDataProcessor(DataProcessor dp) {
+		dataProcessor = dp;
+	}
+
+	/**
+	 * 打开摄像头
+	 */
+	@Override
+	public void openCamera() {
+		try {
+			if(!isInit)
+				throw new InitializeExpt("CameraHandler don't initialize data");
+			if(dataProcessor == null)
+				throw new ArgumentExpt("app don't set DataProcessor");
+			myHandler.obtainMessage(100).sendToTarget();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 *关闭摄像头
+	 */
+	@Override
+	public void closeCamera() {
+		try {
+			stopCameraPreview();
+			if (dataProcessor != null) {
+				dataProcessor.onCameraClose(true);
+				dataProcessor = null;
+			}
+		} catch (Exception e) {
+		}
+	}
+	
+	/**
+	 * 初始化摄像头数据
+	 * @param context
+	 */
+	public synchronized void intData(Context context) {
+		try {
+			mContext = context;
+			gThread = new OpenCameraThread();
+			if (!gThread.isAlive()) {
+				gThread.start();
+			}
+			isLight = isSurportFlashlight(mContext);
+			manager = (CameraManager) mContext
+					.getSystemService(Context.CAMERA_SERVICE);
+			currentCameraId = manager.getCameraIdList()[0];
+			for (String cid : manager.getCameraIdList()) {
+				CameraCharacteristics characteristics = manager
+						.getCameraCharacteristics(cid);
+				if (characteristics.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK) {
+					currentCameraId = cid;
+					StreamConfigurationMap map = characteristics
+							.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
+					Size[] sizes = map.getOutputSizes(SurfaceTexture.class);
+					Arrays.sort(sizes, new ComparatorSize());
+					for (Size e : sizes) {
+//						L.e("h:" + e.getHeight() + ",w:"+e.getWidth()+",m:"+(e.getHeight()*e.getWidth()));
+					}
+					
+					for (Size e : sizes) {
+						if (e.getWidth() < 320) {
+							continue;
+						}
+						mPreviewSize = e;
+						break;
+					}
+					break;
+				}
+			}
+			isInit = true;
+		} catch (CameraAccessException e) {
+			e.printStackTrace();
+		} catch (Exception e1) {
+			e1.printStackTrace();
+		}
+	}
+
+	@SuppressLint("NewApi")
+	private boolean isSurportFlashlight(Context context) {
+		boolean flag = false;
+		PackageManager pm = context.getPackageManager();
+		FeatureInfo[] features = pm.getSystemAvailableFeatures();
+		for (FeatureInfo f : features) {
+			if (PackageManager.FEATURE_CAMERA_FLASH.equals(f.name)) {
+				flag = true;
+				break;
+			}
+		}
+		return flag;
+	}
+
+	private CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {
+
+		@Override
+		public void onOpened(CameraDevice camera) {
+			mCameraDevice = camera;
+			startCameraPreview();
+			notifyCameraOpenResult(true);
+		}
+
+		@Override
+		public void onDisconnected(CameraDevice camera) {
+		}
+
+		@Override
+		public void onError(CameraDevice camera, int error) {
+		}
+
+	};
+
+	private void notifyCameraOpenResult(boolean result) {
+		try {
+			if (dataProcessor != null) {
+				dataProcessor.onCameraOpen(result);
+			}
+		} catch (Exception e) {
+		}
+	}
+
+	private void getCapturedImgToData(Image image) {
+		Image.Plane[] planes = image.getPlanes();
+		if (planes[0].getBuffer() == null) {
+			return;
+		}
+		ByteBuffer buffer = planes[0].getBuffer();
+		ByteBuffer bu = planes[1].getBuffer();
+		ByteBuffer bv = planes[2].getBuffer();
+		byte[] dy = new byte[buffer.remaining()];
+		byte[] du = new byte[bu.remaining()];
+		byte[] dv = new byte[bv.remaining()];
+		buffer.get(dy);
+		bu.get(du);
+		bv.get(dv);
+//		L.e("Y:"+dy.length+"U:"+du.length+"V:"+dv.length);
+		if (dataProcessor != null) {
+			int width = planes[0].getRowStride();
+			int height = dy.length / width;
+			FrameData frameData = new FrameData(byteMerger(dy, du, dv), width,
+					height, image.getTimestamp() / 1000000,
+					ImageFormat.YUV_420_888);
+			dataProcessor.onDataCaptured(frameData);
+		}
+	}
+
+	private byte[]  byteMerger(byte[] y,byte[] u, byte[] v){
+		byte[] data = new byte[y.length+u.length+v.length];
+		 System.arraycopy(y, 0, data, 0, y.length); 
+		 System.arraycopy(u, 0, data, y.length, u.length); 
+		 System.arraycopy(v, 0, data, y.length+u.length, v.length); 
+		 return data;
+		
+	}
+	private void startCameraPreview() {
+		if (null == mCameraDevice || null == mPreviewSize) {
+			return;
+		}
+		iReader = ImageReader.newInstance(mPreviewSize.getWidth(),
+				mPreviewSize.getHeight(), ImageFormat.YUV_420_888, 3);
+		iReader.setOnImageAvailableListener(new OnImageAvailableListener() {
+			@Override
+			public void onImageAvailable(ImageReader arg0) {
+				Image image = arg0.acquireLatestImage();
+				if (null != image) {
+					getCapturedImgToData(image);
+					image.close();
+				}
+			}
+
+		}, null);
+		mSurface = iReader.getSurface();
+		try {
+			mPreviewBuilder = mCameraDevice
+					.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
+			mPreviewBuilder.addTarget(mSurface);
+			mCameraDevice.createCaptureSession(Arrays.asList(mSurface),
+					new CameraCaptureSession.StateCallback() {
+
+						@Override
+						public void onConfigured(CameraCaptureSession session) {
+							mPreviewSession = session;
+							updatePreview();
+						}
+
+						@Override
+						public void onConfigureFailed(
+								CameraCaptureSession session) {
+						}
+					}, null);
+		} catch (CameraAccessException e) {
+			e.printStackTrace();
+		}
+	}
+
+	private void updatePreview() {
+		if (null == mCameraDevice) {
+			return;
+		}
+		mPreviewBuilder.set(CaptureRequest.CONTROL_MODE,
+				CameraMetadata.CONTROL_MODE_AUTO);
+		mPreviewBuilder.set(CaptureRequest.FLASH_MODE,
+				CameraMetadata.FLASH_MODE_TORCH);
+
+		HandlerThread thread = new HandlerThread("CameraPreview");
+		thread.start();
+		Handler backgroundHandler = new Handler(thread.getLooper());
+
+		try {
+			mPreviewSession.setRepeatingRequest(mPreviewBuilder.build(), null,
+					backgroundHandler);
+		} catch (CameraAccessException e) {
+			e.printStackTrace();
+		}
+	}
+
+	private void stopCameraPreview() {
+		if (mSurface != null && mPreviewBuilder != null) {
+			mPreviewBuilder.removeTarget(mSurface);
+			mPreviewBuilder = null;
+		}
+		if (mPreviewSession != null) {
+			mPreviewSession.close();
+			mPreviewSession = null;
+		}
+		if (null != mCameraDevice) {
+			mCameraDevice.close();
+			mCameraDevice = null;
+
+		}
+		if (iReader != null) {
+			iReader.close();
+			iReader = null;
+		}
+	}
+
+	private class ComparatorSize implements Comparator<Size> {
+
+		@Override
+		public int compare(Size s0, Size s1) {
+			if (s0.getWidth() > s1.getWidth())
+				return 1;
+			else
+				return -1;
+		}
+
+	}
+
+	private class MyHandler extends Handler {
+
+		@Override
+		public void handleMessage(Message msg) {
+			switch (msg.what) {
+			case 100:
+				try {
+					CameraDevice curCamDevice = mCameraDevice;
+					if (curCamDevice != null) {
+						synchronized (curCamDevice) {
+							curCamDevice.close();
+							curCamDevice = null;
+						}
+					}
+					manager.openCamera(currentCameraId, mStateCallback, null);
+				} catch (Exception e) {
+					notifyCameraOpenResult(false);
+				}
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	private class OpenCameraThread extends Thread {
+		@SuppressLint("NewApi")
+		public void run() {
+			Looper.prepare();
+			looper = Looper.myLooper();
+			myHandler = new MyHandler();
+			Looper.loop();
+		}
+	}
+}
diff --git a/sample/src/com/ict/camera/CameraManagerFour.java b/sample/src/com/ict/camera/CameraManagerFour.java
new file mode 100644
index 00000000..923a685e
--- /dev/null
+++ b/sample/src/com/ict/camera/CameraManagerFour.java
@@ -0,0 +1,237 @@
+package com.ict.camera;
+
+import java.io.IOException;
+import java.util.List;
+
+import cn.ict.xhealth.exception.ArgumentExpt;
+import cn.ict.xhealth.exception.DefaultExpt;
+import cn.ict.xhealth.exception.InitializeExpt;
+import cn.ict.xhealth.exception.PermissionExpt;
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.pm.FeatureInfo;
+import android.content.pm.PackageManager;
+import android.graphics.ImageFormat;
+import android.graphics.SurfaceTexture;
+import android.graphics.SurfaceTexture.OnFrameAvailableListener;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.PreviewCallback;
+import android.hardware.Camera.Size;
+import android.opengl.GLES11Ext;
+import android.util.Log;
+
+/**
+ * 适合android4.0以上，android5.0以下的系统调用
+ * @author yingzi
+ *
+ */
+public class CameraManagerFour implements PreviewCallback, CameraHandler {
+	private static final String TAG = "CameraManagerFour";
+
+	private Camera currentCamera;
+	private Camera.Parameters oriPara;
+	private int currentCameraId;
+	private byte[] previewBuffer;
+	private SurfaceTexture gTexture;
+	private DataProcessor dataProcessor;
+	private boolean isLight;
+	private boolean isInit;
+	private int buffersize;
+	private long timestamp;
+	private byte[] y;
+	private byte[] u;
+	private byte[] v;
+	private boolean updateSurface;
+
+	/**
+	 * 设置数据回调接口DataProcessor
+	 * @param dp
+	 */
+	@Override
+	public void setDataProcessor(DataProcessor dp) {
+		dataProcessor = dp;
+	}
+
+	/**
+	 * 打开摄像头
+	 */
+	@Override
+	public void openCamera() {	
+		try {
+			if(!isInit)
+				throw new InitializeExpt("CameraHandler don't initialize data");
+			if(dataProcessor == null)
+				throw new ArgumentExpt("app don't set DataProcessor");
+			setCameraParamters();
+			if (gTexture != null) {
+				currentCamera.setPreviewTexture(gTexture);
+				startCameraPreview();
+			}
+			notifyCameraOpenResult(true);
+		} catch (Exception e) {
+			e.printStackTrace();
+			notifyCameraOpenResult(false);
+		}
+
+	}
+
+	/**
+	 *关闭摄像头
+	 */
+	@Override
+	public void closeCamera() {
+		if (currentCamera != null) {
+			stopCameraPreview();
+		}
+		if (dataProcessor != null) {
+			dataProcessor.onCameraClose(true);
+			dataProcessor = null;
+		}
+		if (gTexture != null) {
+			gTexture.release();
+			gTexture = null;
+		}
+		if (currentCamera != null) {
+			currentCamera.release();
+			currentCamera = null;
+		}
+	}
+
+	/**
+	 * 采集图像数据函数
+	 */
+	@Override
+	public void onPreviewFrame(byte[] data, Camera camera) {
+		FrameData frameData = null;
+		try {
+			gTexture.updateTexImage();
+			timestamp = gTexture.getTimestamp() / 1000000;
+			camera.addCallbackBuffer(this.previewBuffer);
+//			dataTranslate(data);
+			frameData = new FrameData(data, 320, 240,
+					timestamp, ImageFormat.NV21);
+			dataProcessor.onDataCaptured(frameData);
+		} catch (Exception e) {
+			e.printStackTrace();
+			if (camera != null)
+				camera.addCallbackBuffer(this.previewBuffer);
+			return;
+		} finally {
+			frameData = null;
+		}
+	}
+
+	private void dataTranslate(byte[] data) {
+		int frameSize = 320 * 240;
+		y = new byte[frameSize];
+		v = new byte[frameSize / 4];
+		u = new byte[frameSize / 4];
+		int vp = 0;
+		int up = 0;
+		int uvp;
+		for (int i = 0; i < frameSize; i++) {
+			y[i] = data[i];
+		}
+		uvp = frameSize;
+		for (int j = 0; j < 240 * 320 / 4; j++) {
+			v[vp++] = data[uvp++];
+			u[up++] = data[uvp++];
+		}
+	}
+	
+	/**
+	 * 初始化摄像头数据
+	 * @param context
+	 */
+	public synchronized void intData(Context context) {
+		try {
+			isLight = isSurportFlashlight(context);
+			buffersize = 320 * 240
+					* ImageFormat.getBitsPerPixel(ImageFormat.NV21) / 8;
+			currentCameraId = 0;
+			int totalCameraCount = Camera.getNumberOfCameras();
+			CameraInfo cameraInfo = new CameraInfo();
+			for (int i = 0; i < totalCameraCount; i++) {
+				Camera.getCameraInfo(i, cameraInfo);
+				if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
+					currentCameraId = i;
+					break;
+				}
+			}
+			isInit = true;
+		} catch (Exception e) {
+		
+		}
+	}
+
+	@SuppressLint("NewApi")
+	private boolean isSurportFlashlight(Context context) {
+		boolean flag = false;
+		PackageManager pm = context.getPackageManager();
+		FeatureInfo[] features = pm.getSystemAvailableFeatures();
+		for (FeatureInfo feature : features) {
+			if (PackageManager.FEATURE_CAMERA_FLASH.equals(feature.name)) {
+				flag = true;
+				break;
+			}
+		}
+		return flag;
+	}
+
+	private void setCameraParamters() {
+		previewBuffer = new byte[buffersize];
+		gTexture = new SurfaceTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES);
+		currentCamera = Camera.open(currentCameraId);
+		Parameters cameraParameters = currentCamera.getParameters();
+		oriPara = currentCamera.getParameters();
+		cameraParameters.setPreviewSize(320, 240);
+		currentCamera.setDisplayOrientation(90);
+		CameraInfo info = new CameraInfo();
+		Camera.getCameraInfo(currentCameraId, info);
+		int gCurrentCameraFacing = info.facing;
+		if (gCurrentCameraFacing == CameraInfo.CAMERA_FACING_BACK && isLight) {
+			cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
+		} else {
+			cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
+		}
+		currentCamera.setParameters(cameraParameters);
+	}
+
+	private void startCameraPreview() throws Exception{
+		currentCamera.addCallbackBuffer(previewBuffer);
+		currentCamera.setPreviewCallbackWithBuffer(CameraManagerFour.this);
+		if (dataProcessor == null) {
+			if (oriPara != null)
+				currentCamera.setParameters(oriPara);
+			throw new ArgumentExpt("app don't set DataProcessor");
+		}
+		currentCamera.startPreview();
+	}
+
+	private void stopCameraPreview() {
+		if (oriPara != null) {
+			try {
+				currentCamera.setParameters(oriPara);
+			} catch (Exception e) {
+				e.printStackTrace();
+			} finally {
+				oriPara = null;
+			}
+		}
+		currentCamera.stopPreview();
+		currentCamera.setPreviewCallback(null);
+	}
+
+	private void notifyCameraOpenResult(boolean result) {
+		try {
+			if (dataProcessor != null) {
+				dataProcessor.onCameraOpen(result);
+			}
+		} catch (Exception e) {
+
+		}
+	}
+
+}
diff --git a/sample/src/com/ict/camera/DataModel.java b/sample/src/com/ict/camera/DataModel.java
new file mode 100644
index 00000000..9b12cdcf
--- /dev/null
+++ b/sample/src/com/ict/camera/DataModel.java
@@ -0,0 +1,56 @@
+package com.ict.camera;
+
+import java.util.concurrent.LinkedBlockingDeque;
+
+import android.content.Context;
+import android.util.Log;
+
+/**
+ * 数据处理类
+ * @author yingzi
+ *
+ */
+public class DataModel implements DataProcessor {
+	private static LinkedBlockingDeque<FrameData> frameBuffer;
+//	private DataControllers dataControllers;
+	private Context context;
+
+	@Override
+	public void onDataCaptured(FrameData frameData) {
+			FrameData curFrameData = new FrameData(frameData.getData(), frameData.getWidth(), frameData.getHeight(), frameData.getTimestamp(),
+				frameData.getPicType());
+		try {
+			while (frameBuffer.size() >= 20)
+				frameBuffer.take();
+			frameBuffer.put(curFrameData);
+		} catch (InterruptedException e) {
+//			e.printStackTrace();
+		} finally {
+			frameData = null;
+		}
+	}
+
+	@Override
+	public void onCameraOpen(boolean result) {
+		if (result) {
+			Log.d("DataModel", "CameraOpen");
+			frameBuffer = new LinkedBlockingDeque<FrameData>(20);
+//			dataControllers = new DataControllers();
+//			dataControllers.init(context, frameBuffer);
+//			dataControllers.startDataProcess();
+		}
+	}
+
+	@Override
+	public void onCameraClose(boolean result) {
+//		dataControllers.stopDataProcess();
+	}
+	
+	/**
+	 * @param context
+	 */
+	public DataModel(Context context) {
+		this.context = context;
+	}
+
+}
diff --git a/sample/src/com/ict/camera/DataProcessor.java b/sample/src/com/ict/camera/DataProcessor.java
new file mode 100644
index 00000000..2be9ae76
--- /dev/null
+++ b/sample/src/com/ict/camera/DataProcessor.java
@@ -0,0 +1,24 @@
+package com.ict.camera;
+
+/**
+ *  数据处理接口
+ * @author yingzi
+ * 2015-12-5 下午3：00
+ */
+public interface DataProcessor{
+	/**
+	 * 捕捉图像帧数据
+	 * @param frameData
+	 */
+	public void onDataCaptured(FrameData frameData);
+	/**
+	 * 摄像头是否打开
+	 * @param result
+	 */
+	public void onCameraOpen(boolean result);
+	/**
+	 * 摄像头是否关闭
+	 * @param result
+	 */
+	public void onCameraClose(boolean result);
+}
diff --git a/sample/src/com/ict/camera/FrameData.java b/sample/src/com/ict/camera/FrameData.java
new file mode 100644
index 00000000..39f04118
--- /dev/null
+++ b/sample/src/com/ict/camera/FrameData.java
@@ -0,0 +1,145 @@
+package com.ict.camera;
+/**
+ * 图像帧格式类
+ * @author yingzi
+ *
+ */
+public class FrameData implements Cloneable {
+	private long timestamp;
+	private int width;
+	private int height;
+	private int picType;
+//	private byte[] y;
+//	private byte[] u;
+//	private byte[] v;
+	private byte[] data;
+	
+	public FrameData(byte[] data, int width, int height,
+			long timestamp, int picType) {
+		this.data = data;
+		this.width = width;
+		this.height = height;
+		this.timestamp = timestamp;
+		this.picType = picType;
+	}
+
+
+	/**
+	 * 获得时间戳
+	 * 
+	 * @return the current value of the timestamp property
+	 */
+	public long getTimestamp() {
+		return timestamp;
+	}
+
+	/**
+	 * 设置时间戳.
+	 * 
+	 * @param aTimestamp
+	 *            the new value of the timestamp property
+	 */
+	public void setTimestamp(long aTimestamp) {
+		timestamp = aTimestamp;
+	}
+
+	/**
+	 * 获得图像类型.
+	 * 
+	 * @return the current value of the picType property
+	 */
+	public int getPicType() {
+		return picType;
+	}
+
+	/**
+	 *  设置图像类型.
+	 * 
+	 * @param aPicType
+	 *            the new value of the picType property
+	 */
+	public void setPicType(int aPicType) {
+		picType = aPicType;
+	}
+
+	/**
+	 *  获得图像数据.
+	 * 
+	 * @return the current value of the y property
+	 */
+	public byte[] getData() {
+		return data;
+	}
+
+	/**
+	 *  设置图像数据
+	 * 
+	 * @param aY
+	 *            the new value of the y property
+	 */
+	public void setData(byte[] data) {
+		this.data = data;
+	}
+
+
+	/**
+	 * 获得图像宽度.
+	 * 
+	 * @return the current value of the width property
+	 */
+	public int getWidth() {
+		return width;
+	}
+
+	/**
+	 *设置图像宽度.
+	 * 
+	 * @param aWidth
+	 *            the new value of the width property
+	 */
+	public void setWidth(int aWidth) {
+		width = aWidth;
+	}
+
+	/**
+	 * 获得图像高度
+	 * 
+	 * @return the current value of the height property
+	 */
+	public int getHeight() {
+		return height;
+	}
+
+	/**
+	 * 设置图像高度
+	 * 
+	 * @param aHeight
+	 *            the new value of the height property
+	 */
+	public void setHeight(int aHeight) {
+		height = aHeight;
+	}
+	
+	/**
+	 * 清空图像帧数据
+	 */
+	public void clear() {
+		this.data = null;
+		this.width = 0;
+		this.height = 0;
+		this.timestamp = 0;
+		this.picType = 0;
+	}
+	/**
+	 * 克隆图像帧对象
+	 */
+	public FrameData clone() {
+		FrameData object = null;
+		try {
+			object = (FrameData) super.clone();
+		} catch (CloneNotSupportedException e) {
+			System.out.println(e.toString());
+		}
+		return object;
+	}
+}
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 0a1d7802..fe3ca342 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
 import jp.co.cyberagent.android.gpuimage.sample.R;
+import com.ict.camera.CameraActivity;
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
@@ -40,7 +41,7 @@ public void onClick(final View v) {
                 startActivity(ActivityGallery.class);
                 break;
             case R.id.button_camera:
-                startActivity(ActivityCamera.class);
+                startActivity(CameraActivity.class);
                 break;
 
             default:
